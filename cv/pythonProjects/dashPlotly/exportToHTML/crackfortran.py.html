<html>
<head>
<title>crackfortran.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
crackfortran.py</font>
</center></td></tr></table>
<pre><span class="s0">#!/usr/bin/env python3</span>
<span class="s2">&quot;&quot;&quot; 
crackfortran --- read fortran (77,90) code and extract declaration information. 
 
Copyright 1999-2004 Pearu Peterson all rights reserved, 
Pearu Peterson &lt;pearu@ioc.ee&gt; 
Permission to use, modify, and distribute this software is given under the 
terms of the NumPy License. 
 
NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK. 
$Date: 2005/09/27 07:13:49 $ 
Pearu Peterson 
 
 
Usage of crackfortran: 
====================== 
Command line keys: -quiet,-verbose,-fix,-f77,-f90,-show,-h &lt;pyffilename&gt; 
                   -m &lt;module name for f77 routines&gt;,--ignore-contains 
Functions: crackfortran, crack2fortran 
The following Fortran statements/constructions are supported 
(or will be if needed): 
   block data,byte,call,character,common,complex,contains,data, 
   dimension,double complex,double precision,end,external,function, 
   implicit,integer,intent,interface,intrinsic, 
   logical,module,optional,parameter,private,public, 
   program,real,(sequence?),subroutine,type,use,virtual, 
   include,pythonmodule 
Note: 'virtual' is mapped to 'dimension'. 
Note: 'implicit integer (z) static (z)' is 'implicit static (z)' (this is minor bug). 
Note: code after 'contains' will be ignored until its scope ends. 
Note: 'common' statement is extended: dimensions are moved to variable definitions 
Note: f2py directive: &lt;commentchar&gt;f2py&lt;line&gt; is read as &lt;line&gt; 
Note: pythonmodule is introduced to represent Python module 
 
Usage: 
  `postlist=crackfortran(files)` 
  `postlist` contains declaration information read from the list of files `files`. 
  `crack2fortran(postlist)` returns a fortran code to be saved to pyf-file 
 
  `postlist` has the following structure: 
 *** it is a list of dictionaries containing `blocks': 
     B = {'block','body','vars','parent_block'[,'name','prefix','args','result', 
          'implicit','externals','interfaced','common','sortvars', 
          'commonvars','note']} 
     B['block'] = 'interface' | 'function' | 'subroutine' | 'module' | 
                  'program' | 'block data' | 'type' | 'pythonmodule' | 
                  'abstract interface' 
     B['body'] --- list containing `subblocks' with the same structure as `blocks' 
     B['parent_block'] --- dictionary of a parent block: 
                             C['body'][&lt;index&gt;]['parent_block'] is C 
     B['vars'] --- dictionary of variable definitions 
     B['sortvars'] --- dictionary of variable definitions sorted by dependence (independent first) 
     B['name'] --- name of the block (not if B['block']=='interface') 
     B['prefix'] --- prefix string (only if B['block']=='function') 
     B['args'] --- list of argument names if B['block']== 'function' | 'subroutine' 
     B['result'] --- name of the return value (only if B['block']=='function') 
     B['implicit'] --- dictionary {'a':&lt;variable definition&gt;,'b':...} | None 
     B['externals'] --- list of variables being external 
     B['interfaced'] --- list of variables being external and defined 
     B['common'] --- dictionary of common blocks (list of objects) 
     B['commonvars'] --- list of variables used in common blocks (dimensions are moved to variable definitions) 
     B['from'] --- string showing the 'parents' of the current block 
     B['use'] --- dictionary of modules used in current block: 
         {&lt;modulename&gt;:{['only':&lt;0|1&gt;],['map':{&lt;local_name1&gt;:&lt;use_name1&gt;,...}]}} 
     B['note'] --- list of LaTeX comments on the block 
     B['f2pyenhancements'] --- optional dictionary 
          {'threadsafe':'','fortranname':&lt;name&gt;, 
           'callstatement':&lt;C-expr&gt;|&lt;multi-line block&gt;, 
           'callprotoargument':&lt;C-expr-list&gt;, 
           'usercode':&lt;multi-line block&gt;|&lt;list of multi-line blocks&gt;, 
           'pymethoddef:&lt;multi-line block&gt;' 
           } 
     B['entry'] --- dictionary {entryname:argslist,..} 
     B['varnames'] --- list of variable names given in the order of reading the 
                       Fortran code, useful for derived types. 
     B['saved_interface'] --- a string of scanned routine signature, defines explicit interface 
 *** Variable definition is a dictionary 
     D = B['vars'][&lt;variable name&gt;] = 
     {'typespec'[,'attrspec','kindselector','charselector','=','typename']} 
     D['typespec'] = 'byte' | 'character' | 'complex' | 'double complex' | 
                     'double precision' | 'integer' | 'logical' | 'real' | 'type' 
     D['attrspec'] --- list of attributes (e.g. 'dimension(&lt;arrayspec&gt;)', 
                       'external','intent(in|out|inout|hide|c|callback|cache|aligned4|aligned8|aligned16)', 
                       'optional','required', etc) 
     K = D['kindselector'] = {['*','kind']} (only if D['typespec'] = 
                         'complex' | 'integer' | 'logical' | 'real' ) 
     C = D['charselector'] = {['*','len','kind']} 
                             (only if D['typespec']=='character') 
     D['='] --- initialization expression string 
     D['typename'] --- name of the type if D['typespec']=='type' 
     D['dimension'] --- list of dimension bounds 
     D['intent'] --- list of intent specifications 
     D['depend'] --- list of variable names on which current variable depends on 
     D['check'] --- list of C-expressions; if C-expr returns zero, exception is raised 
     D['note'] --- list of LaTeX comments on the variable 
 *** Meaning of kind/char selectors (few examples): 
     D['typespec&gt;']*K['*'] 
     D['typespec'](kind=K['kind']) 
     character*C['*'] 
     character(len=C['len'],kind=C['kind']) 
     (see also fortran type declaration statement formats below) 
 
Fortran 90 type declaration statement format (F77 is subset of F90) 
==================================================================== 
(Main source: IBM XL Fortran 5.1 Language Reference Manual) 
type declaration = &lt;typespec&gt; [[&lt;attrspec&gt;]::] &lt;entitydecl&gt; 
&lt;typespec&gt; = byte                          | 
             character[&lt;charselector&gt;]     | 
             complex[&lt;kindselector&gt;]       | 
             double complex                | 
             double precision              | 
             integer[&lt;kindselector&gt;]       | 
             logical[&lt;kindselector&gt;]       | 
             real[&lt;kindselector&gt;]          | 
             type(&lt;typename&gt;) 
&lt;charselector&gt; = * &lt;charlen&gt;               | 
             ([len=]&lt;len&gt;[,[kind=]&lt;kind&gt;]) | 
             (kind=&lt;kind&gt;[,len=&lt;len&gt;]) 
&lt;kindselector&gt; = * &lt;intlen&gt;                | 
             ([kind=]&lt;kind&gt;) 
&lt;attrspec&gt; = comma separated list of attributes. 
             Only the following attributes are used in 
             building up the interface: 
                external 
                (parameter --- affects '=' key) 
                optional 
                intent 
             Other attributes are ignored. 
&lt;intentspec&gt; = in | out | inout 
&lt;arrayspec&gt; = comma separated list of dimension bounds. 
&lt;entitydecl&gt; = &lt;name&gt; [[*&lt;charlen&gt;][(&lt;arrayspec&gt;)] | [(&lt;arrayspec&gt;)]*&lt;charlen&gt;] 
                      [/&lt;init_expr&gt;/ | =&lt;init_expr&gt;] [,&lt;entitydecl&gt;] 
 
In addition, the following attributes are used: check,depend,note 
 
TODO: 
    * Apply 'parameter' attribute (e.g. 'integer parameter :: i=2' 'real x(i)' 
                                   -&gt; 'real x(2)') 
    The above may be solved by creating appropriate preprocessor program, for example. 
 
&quot;&quot;&quot;</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">string</span>
<span class="s3">import </span><span class="s1">fileinput</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">copy</span>
<span class="s3">import </span><span class="s1">platform</span>

<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">__version__</span>

<span class="s0"># The environment provided by auxfuncs.py is needed for some calls to eval.</span>
<span class="s0"># As the needed functions cannot be determined by static inspection of the</span>
<span class="s0"># code, it is safest to use import * pending a major refactoring of f2py.</span>
<span class="s3">from </span><span class="s1">.auxfuncs </span><span class="s3">import </span><span class="s1">*</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">symbolic</span>

<span class="s1">f2py_version = __version__.version</span>

<span class="s0"># Global flags:</span>
<span class="s1">strictf77 = </span><span class="s4">1          </span><span class="s0"># Ignore `!' comments unless line[0]=='!'</span>
<span class="s1">sourcecodeform = </span><span class="s5">'fix'  </span><span class="s0"># 'fix','free'</span>
<span class="s1">quiet = </span><span class="s4">0              </span><span class="s0"># Be verbose if 0 (Obsolete: not used any more)</span>
<span class="s1">verbose = </span><span class="s4">1            </span><span class="s0"># Be quiet if 0, extra verbose if &gt; 1.</span>
<span class="s1">tabchar = </span><span class="s4">4 </span><span class="s1">* </span><span class="s5">' '</span>
<span class="s1">pyffilename = </span><span class="s5">''</span>
<span class="s1">f77modulename = </span><span class="s5">''</span>
<span class="s1">skipemptyends = </span><span class="s4">0      </span><span class="s0"># for old F77 programs without 'program' statement</span>
<span class="s1">ignorecontains = </span><span class="s4">1</span>
<span class="s1">dolowercase = </span><span class="s4">1</span>
<span class="s1">debug = []</span>

<span class="s0"># Global variables</span>
<span class="s1">beginpattern = </span><span class="s5">''</span>
<span class="s1">currentfilename = </span><span class="s5">''</span>
<span class="s1">expectbegin = </span><span class="s4">1</span>
<span class="s1">f90modulevars = {}</span>
<span class="s1">filepositiontext = </span><span class="s5">''</span>
<span class="s1">gotnextfile = </span><span class="s4">1</span>
<span class="s1">groupcache = </span><span class="s3">None</span>
<span class="s1">groupcounter = </span><span class="s4">0</span>
<span class="s1">grouplist = {groupcounter: []}</span>
<span class="s1">groupname = </span><span class="s5">''</span>
<span class="s1">include_paths = []</span>
<span class="s1">neededmodule = -</span><span class="s4">1</span>
<span class="s1">onlyfuncs = []</span>
<span class="s1">previous_context = </span><span class="s3">None</span>
<span class="s1">skipblocksuntil = -</span><span class="s4">1</span>
<span class="s1">skipfuncs = []</span>
<span class="s1">skipfunctions = []</span>
<span class="s1">usermodules = []</span>


<span class="s3">def </span><span class="s1">reset_global_f2py_vars():</span>
    <span class="s3">global </span><span class="s1">groupcounter</span><span class="s3">, </span><span class="s1">grouplist</span><span class="s3">, </span><span class="s1">neededmodule</span><span class="s3">, </span><span class="s1">expectbegin</span>
    <span class="s3">global </span><span class="s1">skipblocksuntil</span><span class="s3">, </span><span class="s1">usermodules</span><span class="s3">, </span><span class="s1">f90modulevars</span><span class="s3">, </span><span class="s1">gotnextfile</span>
    <span class="s3">global </span><span class="s1">filepositiontext</span><span class="s3">, </span><span class="s1">currentfilename</span><span class="s3">, </span><span class="s1">skipfunctions</span><span class="s3">, </span><span class="s1">skipfuncs</span>
    <span class="s3">global </span><span class="s1">onlyfuncs</span><span class="s3">, </span><span class="s1">include_paths</span><span class="s3">, </span><span class="s1">previous_context</span>
    <span class="s3">global </span><span class="s1">strictf77</span><span class="s3">, </span><span class="s1">sourcecodeform</span><span class="s3">, </span><span class="s1">quiet</span><span class="s3">, </span><span class="s1">verbose</span><span class="s3">, </span><span class="s1">tabchar</span><span class="s3">, </span><span class="s1">pyffilename</span>
    <span class="s3">global </span><span class="s1">f77modulename</span><span class="s3">, </span><span class="s1">skipemptyends</span><span class="s3">, </span><span class="s1">ignorecontains</span><span class="s3">, </span><span class="s1">dolowercase</span><span class="s3">, </span><span class="s1">debug</span>

    <span class="s0"># flags</span>
    <span class="s1">strictf77 = </span><span class="s4">1</span>
    <span class="s1">sourcecodeform = </span><span class="s5">'fix'</span>
    <span class="s1">quiet = </span><span class="s4">0</span>
    <span class="s1">verbose = </span><span class="s4">1</span>
    <span class="s1">tabchar = </span><span class="s4">4 </span><span class="s1">* </span><span class="s5">' '</span>
    <span class="s1">pyffilename = </span><span class="s5">''</span>
    <span class="s1">f77modulename = </span><span class="s5">''</span>
    <span class="s1">skipemptyends = </span><span class="s4">0</span>
    <span class="s1">ignorecontains = </span><span class="s4">1</span>
    <span class="s1">dolowercase = </span><span class="s4">1</span>
    <span class="s1">debug = []</span>
    <span class="s0"># variables</span>
    <span class="s1">groupcounter = </span><span class="s4">0</span>
    <span class="s1">grouplist = {groupcounter: []}</span>
    <span class="s1">neededmodule = -</span><span class="s4">1</span>
    <span class="s1">expectbegin = </span><span class="s4">1</span>
    <span class="s1">skipblocksuntil = -</span><span class="s4">1</span>
    <span class="s1">usermodules = []</span>
    <span class="s1">f90modulevars = {}</span>
    <span class="s1">gotnextfile = </span><span class="s4">1</span>
    <span class="s1">filepositiontext = </span><span class="s5">''</span>
    <span class="s1">currentfilename = </span><span class="s5">''</span>
    <span class="s1">skipfunctions = []</span>
    <span class="s1">skipfuncs = []</span>
    <span class="s1">onlyfuncs = []</span>
    <span class="s1">include_paths = []</span>
    <span class="s1">previous_context = </span><span class="s3">None</span>


<span class="s3">def </span><span class="s1">outmess(line</span><span class="s3">, </span><span class="s1">flag=</span><span class="s4">1</span><span class="s1">):</span>
    <span class="s3">global </span><span class="s1">filepositiontext</span>

    <span class="s3">if not </span><span class="s1">verbose:</span>
        <span class="s3">return</span>
    <span class="s3">if not </span><span class="s1">quiet:</span>
        <span class="s3">if </span><span class="s1">flag:</span>
            <span class="s1">sys.stdout.write(filepositiontext)</span>
        <span class="s1">sys.stdout.write(line)</span>

<span class="s1">re._MAXCACHE = </span><span class="s4">50</span>
<span class="s1">defaultimplicitrules = {}</span>
<span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s5">&quot;abcdefghopqrstuvwxyz$_&quot;</span><span class="s1">:</span>
    <span class="s1">defaultimplicitrules[c] = {</span><span class="s5">'typespec'</span><span class="s1">: </span><span class="s5">'real'</span><span class="s1">}</span>
<span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s5">&quot;ijklmn&quot;</span><span class="s1">:</span>
    <span class="s1">defaultimplicitrules[c] = {</span><span class="s5">'typespec'</span><span class="s1">: </span><span class="s5">'integer'</span><span class="s1">}</span>
<span class="s1">badnames = {}</span>
<span class="s1">invbadnames = {}</span>
<span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'int'</span><span class="s3">, </span><span class="s5">'double'</span><span class="s3">, </span><span class="s5">'float'</span><span class="s3">, </span><span class="s5">'char'</span><span class="s3">, </span><span class="s5">'short'</span><span class="s3">, </span><span class="s5">'long'</span><span class="s3">, </span><span class="s5">'void'</span><span class="s3">, </span><span class="s5">'case'</span><span class="s3">, </span><span class="s5">'while'</span><span class="s3">,</span>
          <span class="s5">'return'</span><span class="s3">, </span><span class="s5">'signed'</span><span class="s3">, </span><span class="s5">'unsigned'</span><span class="s3">, </span><span class="s5">'if'</span><span class="s3">, </span><span class="s5">'for'</span><span class="s3">, </span><span class="s5">'typedef'</span><span class="s3">, </span><span class="s5">'sizeof'</span><span class="s3">, </span><span class="s5">'union'</span><span class="s3">,</span>
          <span class="s5">'struct'</span><span class="s3">, </span><span class="s5">'static'</span><span class="s3">, </span><span class="s5">'register'</span><span class="s3">, </span><span class="s5">'new'</span><span class="s3">, </span><span class="s5">'break'</span><span class="s3">, </span><span class="s5">'do'</span><span class="s3">, </span><span class="s5">'goto'</span><span class="s3">, </span><span class="s5">'switch'</span><span class="s3">,</span>
          <span class="s5">'continue'</span><span class="s3">, </span><span class="s5">'else'</span><span class="s3">, </span><span class="s5">'inline'</span><span class="s3">, </span><span class="s5">'extern'</span><span class="s3">, </span><span class="s5">'delete'</span><span class="s3">, </span><span class="s5">'const'</span><span class="s3">, </span><span class="s5">'auto'</span><span class="s3">,</span>
          <span class="s5">'len'</span><span class="s3">, </span><span class="s5">'rank'</span><span class="s3">, </span><span class="s5">'shape'</span><span class="s3">, </span><span class="s5">'index'</span><span class="s3">, </span><span class="s5">'slen'</span><span class="s3">, </span><span class="s5">'size'</span><span class="s3">, </span><span class="s5">'_i'</span><span class="s3">,</span>
          <span class="s5">'max'</span><span class="s3">, </span><span class="s5">'min'</span><span class="s3">,</span>
          <span class="s5">'flen'</span><span class="s3">, </span><span class="s5">'fshape'</span><span class="s3">,</span>
          <span class="s5">'string'</span><span class="s3">, </span><span class="s5">'complex_double'</span><span class="s3">, </span><span class="s5">'float_double'</span><span class="s3">, </span><span class="s5">'stdin'</span><span class="s3">, </span><span class="s5">'stderr'</span><span class="s3">, </span><span class="s5">'stdout'</span><span class="s3">,</span>
          <span class="s5">'type'</span><span class="s3">, </span><span class="s5">'default'</span><span class="s1">]:</span>
    <span class="s1">badnames[n] = n + </span><span class="s5">'_bn'</span>
    <span class="s1">invbadnames[n + </span><span class="s5">'_bn'</span><span class="s1">] = n</span>


<span class="s3">def </span><span class="s1">rmbadname1(name):</span>
    <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">badnames:</span>
        <span class="s1">errmess(</span><span class="s5">'rmbadname1: Replacing &quot;%s&quot; with &quot;%s&quot;.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">%</span>
                <span class="s1">(name</span><span class="s3">, </span><span class="s1">badnames[name]))</span>
        <span class="s3">return </span><span class="s1">badnames[name]</span>
    <span class="s3">return </span><span class="s1">name</span>


<span class="s3">def </span><span class="s1">rmbadname(names):</span>
    <span class="s3">return </span><span class="s1">[rmbadname1(_m) </span><span class="s3">for </span><span class="s1">_m </span><span class="s3">in </span><span class="s1">names]</span>


<span class="s3">def </span><span class="s1">undo_rmbadname1(name):</span>
    <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">invbadnames:</span>
        <span class="s1">errmess(</span><span class="s5">'undo_rmbadname1: Replacing &quot;%s&quot; with &quot;%s&quot;.</span><span class="s3">\n</span><span class="s5">'</span>
                <span class="s1">% (name</span><span class="s3">, </span><span class="s1">invbadnames[name]))</span>
        <span class="s3">return </span><span class="s1">invbadnames[name]</span>
    <span class="s3">return </span><span class="s1">name</span>


<span class="s3">def </span><span class="s1">undo_rmbadname(names):</span>
    <span class="s3">return </span><span class="s1">[undo_rmbadname1(_m) </span><span class="s3">for </span><span class="s1">_m </span><span class="s3">in </span><span class="s1">names]</span>


<span class="s3">def </span><span class="s1">getextension(name):</span>
    <span class="s1">i = name.rfind(</span><span class="s5">'.'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">i == -</span><span class="s4">1</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s5">''</span>
    <span class="s3">if </span><span class="s5">'</span><span class="s3">\\</span><span class="s5">' </span><span class="s3">in </span><span class="s1">name[i:]:</span>
        <span class="s3">return </span><span class="s5">''</span>
    <span class="s3">if </span><span class="s5">'/' </span><span class="s3">in </span><span class="s1">name[i:]:</span>
        <span class="s3">return </span><span class="s5">''</span>
    <span class="s3">return </span><span class="s1">name[i + </span><span class="s4">1</span><span class="s1">:]</span>

<span class="s1">is_f_file = re.compile(</span><span class="s5">r'.*\.(for|ftn|f77|f)\Z'</span><span class="s3">, </span><span class="s1">re.I).match</span>
<span class="s1">_has_f_header = re.compile(</span><span class="s5">r'-\*-\s*fortran\s*-\*-'</span><span class="s3">, </span><span class="s1">re.I).search</span>
<span class="s1">_has_f90_header = re.compile(</span><span class="s5">r'-\*-\s*f90\s*-\*-'</span><span class="s3">, </span><span class="s1">re.I).search</span>
<span class="s1">_has_fix_header = re.compile(</span><span class="s5">r'-\*-\s*fix\s*-\*-'</span><span class="s3">, </span><span class="s1">re.I).search</span>
<span class="s1">_free_f90_start = re.compile(</span><span class="s5">r'[^c*]\s*[^\s\d\t]'</span><span class="s3">, </span><span class="s1">re.I).match</span>


<span class="s3">def </span><span class="s1">is_free_format(file):</span>
    <span class="s2">&quot;&quot;&quot;Check if file is in free format Fortran.&quot;&quot;&quot;</span>
    <span class="s0"># f90 allows both fixed and free format, assuming fixed unless</span>
    <span class="s0"># signs of free format are detected.</span>
    <span class="s1">result = </span><span class="s4">0</span>
    <span class="s3">with </span><span class="s1">open(file</span><span class="s3">, </span><span class="s5">'r'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
        <span class="s1">line = f.readline()</span>
        <span class="s1">n = </span><span class="s4">15  </span><span class="s0"># the number of non-comment lines to scan for hints</span>
        <span class="s3">if </span><span class="s1">_has_f_header(line):</span>
            <span class="s1">n = </span><span class="s4">0</span>
        <span class="s3">elif </span><span class="s1">_has_f90_header(line):</span>
            <span class="s1">n = </span><span class="s4">0</span>
            <span class="s1">result = </span><span class="s4">1</span>
        <span class="s3">while </span><span class="s1">n &gt; </span><span class="s4">0 </span><span class="s3">and </span><span class="s1">line:</span>
            <span class="s3">if </span><span class="s1">line[</span><span class="s4">0</span><span class="s1">] != </span><span class="s5">'!' </span><span class="s3">and </span><span class="s1">line.strip():</span>
                <span class="s1">n -= </span><span class="s4">1</span>
                <span class="s3">if </span><span class="s1">(line[</span><span class="s4">0</span><span class="s1">] != </span><span class="s5">'</span><span class="s3">\t</span><span class="s5">' </span><span class="s3">and </span><span class="s1">_free_f90_start(line[:</span><span class="s4">5</span><span class="s1">])) </span><span class="s3">or </span><span class="s1">line[-</span><span class="s4">2</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">] == </span><span class="s5">'&amp;'</span><span class="s1">:</span>
                    <span class="s1">result = </span><span class="s4">1</span>
                    <span class="s3">break</span>
            <span class="s1">line = f.readline()</span>
    <span class="s3">return </span><span class="s1">result</span>


<span class="s0"># Read fortran (77,90) code</span>
<span class="s3">def </span><span class="s1">readfortrancode(ffile</span><span class="s3">, </span><span class="s1">dowithline=show</span><span class="s3">, </span><span class="s1">istop=</span><span class="s4">1</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Read fortran codes from files and 
     1) Get rid of comments, line continuations, and empty lines; lower cases. 
     2) Call dowithline(line) on every line. 
     3) Recursively call itself when statement \&quot;include '&lt;filename&gt;'\&quot; is met. 
    &quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">gotnextfile</span><span class="s3">, </span><span class="s1">filepositiontext</span><span class="s3">, </span><span class="s1">currentfilename</span><span class="s3">, </span><span class="s1">sourcecodeform</span><span class="s3">, </span><span class="s1">strictf77</span>
    <span class="s3">global </span><span class="s1">beginpattern</span><span class="s3">, </span><span class="s1">quiet</span><span class="s3">, </span><span class="s1">verbose</span><span class="s3">, </span><span class="s1">dolowercase</span><span class="s3">, </span><span class="s1">include_paths</span>

    <span class="s3">if not </span><span class="s1">istop:</span>
        <span class="s1">saveglobals = gotnextfile</span><span class="s3">, </span><span class="s1">filepositiontext</span><span class="s3">, </span><span class="s1">currentfilename</span><span class="s3">, </span><span class="s1">sourcecodeform</span><span class="s3">, </span><span class="s1">strictf77</span><span class="s3">,</span><span class="s1">\</span>
            <span class="s1">beginpattern</span><span class="s3">, </span><span class="s1">quiet</span><span class="s3">, </span><span class="s1">verbose</span><span class="s3">, </span><span class="s1">dolowercase</span>
    <span class="s3">if </span><span class="s1">ffile == []:</span>
        <span class="s3">return</span>
    <span class="s1">localdolowercase = dolowercase</span>
    <span class="s0"># cont: set to True when the content of the last line read</span>
    <span class="s0"># indicates statement continuation</span>
    <span class="s1">cont = </span><span class="s3">False</span>
    <span class="s1">finalline = </span><span class="s5">''</span>
    <span class="s1">ll = </span><span class="s5">''</span>
    <span class="s1">includeline = re.compile(</span>
        <span class="s5">r'\s*include\s*(\'|&quot;)(?P&lt;name&gt;[^\'&quot;]*)(\'|&quot;)'</span><span class="s3">, </span><span class="s1">re.I)</span>
    <span class="s1">cont1 = re.compile(</span><span class="s5">r'(?P&lt;line&gt;.*)&amp;\s*\Z'</span><span class="s1">)</span>
    <span class="s1">cont2 = re.compile(</span><span class="s5">r'(\s*&amp;|)(?P&lt;line&gt;.*)'</span><span class="s1">)</span>
    <span class="s1">mline_mark = re.compile(</span><span class="s5">r&quot;.*?'''&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">istop:</span>
        <span class="s1">dowithline(</span><span class="s5">''</span><span class="s3">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">ll</span><span class="s3">, </span><span class="s1">l1 = </span><span class="s5">''</span><span class="s3">, </span><span class="s5">''</span>
    <span class="s1">spacedigits = [</span><span class="s5">' '</span><span class="s1">] + [str(_m) </span><span class="s3">for </span><span class="s1">_m </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">10</span><span class="s1">)]</span>
    <span class="s1">filepositiontext = </span><span class="s5">''</span>
    <span class="s1">fin = fileinput.FileInput(ffile)</span>
    <span class="s3">while True</span><span class="s1">:</span>
        <span class="s1">l = fin.readline()</span>
        <span class="s3">if not </span><span class="s1">l:</span>
            <span class="s3">break</span>
        <span class="s3">if </span><span class="s1">fin.isfirstline():</span>
            <span class="s1">filepositiontext = </span><span class="s5">''</span>
            <span class="s1">currentfilename = fin.filename()</span>
            <span class="s1">gotnextfile = </span><span class="s4">1</span>
            <span class="s1">l1 = l</span>
            <span class="s1">strictf77 = </span><span class="s4">0</span>
            <span class="s1">sourcecodeform = </span><span class="s5">'fix'</span>
            <span class="s1">ext = os.path.splitext(currentfilename)[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">is_f_file(currentfilename) </span><span class="s3">and </span><span class="s1">\</span>
                    <span class="s3">not </span><span class="s1">(_has_f90_header(l) </span><span class="s3">or </span><span class="s1">_has_fix_header(l)):</span>
                <span class="s1">strictf77 = </span><span class="s4">1</span>
            <span class="s3">elif </span><span class="s1">is_free_format(currentfilename) </span><span class="s3">and not </span><span class="s1">_has_fix_header(l):</span>
                <span class="s1">sourcecodeform = </span><span class="s5">'free'</span>
            <span class="s3">if </span><span class="s1">strictf77:</span>
                <span class="s1">beginpattern = beginpattern77</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">beginpattern = beginpattern90</span>
            <span class="s1">outmess(</span><span class="s5">'</span><span class="s3">\t</span><span class="s5">Reading file %s (format:%s%s)</span><span class="s3">\n</span><span class="s5">'</span>
                    <span class="s1">% (repr(currentfilename)</span><span class="s3">, </span><span class="s1">sourcecodeform</span><span class="s3">,</span>
                       <span class="s1">strictf77 </span><span class="s3">and </span><span class="s5">',strict' </span><span class="s3">or </span><span class="s5">''</span><span class="s1">))</span>

        <span class="s1">l = l.expandtabs().replace(</span><span class="s5">'</span><span class="s3">\xa0</span><span class="s5">'</span><span class="s3">, </span><span class="s5">' '</span><span class="s1">)</span>
        <span class="s0"># Get rid of newline characters</span>
        <span class="s3">while not </span><span class="s1">l == </span><span class="s5">''</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">l[-</span><span class="s4">1</span><span class="s1">] </span><span class="s3">not in </span><span class="s5">&quot;</span><span class="s3">\n\r\f</span><span class="s5">&quot;</span><span class="s1">:</span>
                <span class="s3">break</span>
            <span class="s1">l = l[:-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s3">if not </span><span class="s1">strictf77:</span>
            <span class="s1">(l</span><span class="s3">, </span><span class="s1">rl) = split_by_unquoted(l</span><span class="s3">, </span><span class="s5">'!'</span><span class="s1">)</span>
            <span class="s1">l += </span><span class="s5">' '</span>
            <span class="s3">if </span><span class="s1">rl[:</span><span class="s4">5</span><span class="s1">].lower() == </span><span class="s5">'!f2py'</span><span class="s1">:  </span><span class="s0"># f2py directive</span>
                <span class="s1">l</span><span class="s3">, </span><span class="s1">_ = split_by_unquoted(l + </span><span class="s4">4 </span><span class="s1">* </span><span class="s5">' ' </span><span class="s1">+ rl[</span><span class="s4">5</span><span class="s1">:]</span><span class="s3">, </span><span class="s5">'!'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">l.strip() == </span><span class="s5">''</span><span class="s1">:  </span><span class="s0"># Skip empty line</span>
            <span class="s3">if </span><span class="s1">sourcecodeform == </span><span class="s5">'free'</span><span class="s1">:</span>
                <span class="s0"># In free form, a statement continues in the next line</span>
                <span class="s0"># that is not a comment line [3.3.2.4^1], lines with</span>
                <span class="s0"># blanks are comment lines [3.3.2.3^1]. Hence, the</span>
                <span class="s0"># line continuation flag must retain its state.</span>
                <span class="s3">pass</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># In fixed form, statement continuation is determined</span>
                <span class="s0"># by a non-blank character at the 6-th position. Empty</span>
                <span class="s0"># line indicates a start of a new statement</span>
                <span class="s0"># [3.3.3.3^1]. Hence, the line continuation flag must</span>
                <span class="s0"># be reset.</span>
                <span class="s1">cont = </span><span class="s3">False</span>
            <span class="s3">continue</span>
        <span class="s3">if </span><span class="s1">sourcecodeform == </span><span class="s5">'fix'</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">l[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'*'</span><span class="s3">, </span><span class="s5">'c'</span><span class="s3">, </span><span class="s5">'!'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">, </span><span class="s5">'#'</span><span class="s1">]:</span>
                <span class="s3">if </span><span class="s1">l[</span><span class="s4">1</span><span class="s1">:</span><span class="s4">5</span><span class="s1">].lower() == </span><span class="s5">'f2py'</span><span class="s1">:  </span><span class="s0"># f2py directive</span>
                    <span class="s1">l = </span><span class="s5">'     ' </span><span class="s1">+ l[</span><span class="s4">5</span><span class="s1">:]</span>
                <span class="s3">else</span><span class="s1">:  </span><span class="s0"># Skip comment line</span>
                    <span class="s1">cont = </span><span class="s3">False</span>
                    <span class="s3">continue</span>
            <span class="s3">elif </span><span class="s1">strictf77:</span>
                <span class="s3">if </span><span class="s1">len(l) &gt; </span><span class="s4">72</span><span class="s1">:</span>
                    <span class="s1">l = l[:</span><span class="s4">72</span><span class="s1">]</span>
            <span class="s3">if not </span><span class="s1">(l[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">in </span><span class="s1">spacedigits):</span>
                <span class="s3">raise </span><span class="s1">Exception(</span><span class="s5">'readfortrancode: Found non-(space,digit) char '</span>
                                <span class="s5">'in the first column.</span><span class="s3">\n\t</span><span class="s5">Are you sure that '</span>
                                <span class="s5">'this code is in fix form?</span><span class="s3">\n\t</span><span class="s5">line=%s' </span><span class="s1">% repr(l))</span>

            <span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">cont </span><span class="s3">or </span><span class="s1">strictf77) </span><span class="s3">and </span><span class="s1">(len(l) &gt; </span><span class="s4">5 </span><span class="s3">and not </span><span class="s1">l[</span><span class="s4">5</span><span class="s1">] == </span><span class="s5">' '</span><span class="s1">):</span>
                <span class="s0"># Continuation of a previous line</span>
                <span class="s1">ll = ll + l[</span><span class="s4">6</span><span class="s1">:]</span>
                <span class="s1">finalline = </span><span class="s5">''</span>
                <span class="s1">origfinalline = </span><span class="s5">''</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if not </span><span class="s1">strictf77:</span>
                    <span class="s0"># F90 continuation</span>
                    <span class="s1">r = cont1.match(l)</span>
                    <span class="s3">if </span><span class="s1">r:</span>
                        <span class="s1">l = r.group(</span><span class="s5">'line'</span><span class="s1">)  </span><span class="s0"># Continuation follows ..</span>
                    <span class="s3">if </span><span class="s1">cont:</span>
                        <span class="s1">ll = ll + cont2.match(l).group(</span><span class="s5">'line'</span><span class="s1">)</span>
                        <span class="s1">finalline = </span><span class="s5">''</span>
                        <span class="s1">origfinalline = </span><span class="s5">''</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s0"># clean up line beginning from possible digits.</span>
                        <span class="s1">l = </span><span class="s5">'     ' </span><span class="s1">+ l[</span><span class="s4">5</span><span class="s1">:]</span>
                        <span class="s3">if </span><span class="s1">localdolowercase:</span>
                            <span class="s1">finalline = ll.lower()</span>
                        <span class="s3">else</span><span class="s1">:</span>
                            <span class="s1">finalline = ll</span>
                        <span class="s1">origfinalline = ll</span>
                        <span class="s1">ll = l</span>
                    <span class="s1">cont = (r </span><span class="s3">is not None</span><span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s0"># clean up line beginning from possible digits.</span>
                    <span class="s1">l = </span><span class="s5">'     ' </span><span class="s1">+ l[</span><span class="s4">5</span><span class="s1">:]</span>
                    <span class="s3">if </span><span class="s1">localdolowercase:</span>
                        <span class="s1">finalline = ll.lower()</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">finalline = ll</span>
                    <span class="s1">origfinalline = ll</span>
                    <span class="s1">ll = l</span>

        <span class="s3">elif </span><span class="s1">sourcecodeform == </span><span class="s5">'free'</span><span class="s1">:</span>
            <span class="s3">if not </span><span class="s1">cont </span><span class="s3">and </span><span class="s1">ext == </span><span class="s5">'.pyf' </span><span class="s3">and </span><span class="s1">mline_mark.match(l):</span>
                <span class="s1">l = l + </span><span class="s5">'</span><span class="s3">\n</span><span class="s5">'</span>
                <span class="s3">while True</span><span class="s1">:</span>
                    <span class="s1">lc = fin.readline()</span>
                    <span class="s3">if not </span><span class="s1">lc:</span>
                        <span class="s1">errmess(</span>
                            <span class="s5">'Unexpected end of file when reading multiline</span><span class="s3">\n</span><span class="s5">'</span><span class="s1">)</span>
                        <span class="s3">break</span>
                    <span class="s1">l = l + lc</span>
                    <span class="s3">if </span><span class="s1">mline_mark.match(lc):</span>
                        <span class="s3">break</span>
                <span class="s1">l = l.rstrip()</span>
            <span class="s1">r = cont1.match(l)</span>
            <span class="s3">if </span><span class="s1">r:</span>
                <span class="s1">l = r.group(</span><span class="s5">'line'</span><span class="s1">)  </span><span class="s0"># Continuation follows ..</span>
            <span class="s3">if </span><span class="s1">cont:</span>
                <span class="s1">ll = ll + cont2.match(l).group(</span><span class="s5">'line'</span><span class="s1">)</span>
                <span class="s1">finalline = </span><span class="s5">''</span>
                <span class="s1">origfinalline = </span><span class="s5">''</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">localdolowercase:</span>
                    <span class="s1">finalline = ll.lower()</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">finalline = ll</span>
                <span class="s1">origfinalline = ll</span>
                <span class="s1">ll = l</span>
            <span class="s1">cont = (r </span><span class="s3">is not None</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s5">&quot;Flag sourcecodeform must be either 'fix' or 'free': %s&quot; </span><span class="s1">% repr(sourcecodeform))</span>
        <span class="s1">filepositiontext = </span><span class="s5">'Line #%d in %s:&quot;%s&quot;</span><span class="s3">\n\t</span><span class="s5">' </span><span class="s1">% (</span>
            <span class="s1">fin.filelineno() - </span><span class="s4">1</span><span class="s3">, </span><span class="s1">currentfilename</span><span class="s3">, </span><span class="s1">l1)</span>
        <span class="s1">m = includeline.match(origfinalline)</span>
        <span class="s3">if </span><span class="s1">m:</span>
            <span class="s1">fn = m.group(</span><span class="s5">'name'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">os.path.isfile(fn):</span>
                <span class="s1">readfortrancode(fn</span><span class="s3">, </span><span class="s1">dowithline=dowithline</span><span class="s3">, </span><span class="s1">istop=</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">include_dirs = [</span>
                    <span class="s1">os.path.dirname(currentfilename)] + include_paths</span>
                <span class="s1">foundfile = </span><span class="s4">0</span>
                <span class="s3">for </span><span class="s1">inc_dir </span><span class="s3">in </span><span class="s1">include_dirs:</span>
                    <span class="s1">fn1 = os.path.join(inc_dir</span><span class="s3">, </span><span class="s1">fn)</span>
                    <span class="s3">if </span><span class="s1">os.path.isfile(fn1):</span>
                        <span class="s1">foundfile = </span><span class="s4">1</span>
                        <span class="s1">readfortrancode(fn1</span><span class="s3">, </span><span class="s1">dowithline=dowithline</span><span class="s3">, </span><span class="s1">istop=</span><span class="s4">0</span><span class="s1">)</span>
                        <span class="s3">break</span>
                <span class="s3">if not </span><span class="s1">foundfile:</span>
                    <span class="s1">outmess(</span><span class="s5">'readfortrancode: could not find include file %s in %s. Ignoring.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (</span>
                        <span class="s1">repr(fn)</span><span class="s3">, </span><span class="s1">os.pathsep.join(include_dirs)))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">dowithline(finalline)</span>
        <span class="s1">l1 = ll</span>
    <span class="s3">if </span><span class="s1">localdolowercase:</span>
        <span class="s1">finalline = ll.lower()</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">finalline = ll</span>
    <span class="s1">origfinalline = ll</span>
    <span class="s1">filepositiontext = </span><span class="s5">'Line #%d in %s:&quot;%s&quot;</span><span class="s3">\n\t</span><span class="s5">' </span><span class="s1">% (</span>
        <span class="s1">fin.filelineno() - </span><span class="s4">1</span><span class="s3">, </span><span class="s1">currentfilename</span><span class="s3">, </span><span class="s1">l1)</span>
    <span class="s1">m = includeline.match(origfinalline)</span>
    <span class="s3">if </span><span class="s1">m:</span>
        <span class="s1">fn = m.group(</span><span class="s5">'name'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">os.path.isfile(fn):</span>
            <span class="s1">readfortrancode(fn</span><span class="s3">, </span><span class="s1">dowithline=dowithline</span><span class="s3">, </span><span class="s1">istop=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">include_dirs = [os.path.dirname(currentfilename)] + include_paths</span>
            <span class="s1">foundfile = </span><span class="s4">0</span>
            <span class="s3">for </span><span class="s1">inc_dir </span><span class="s3">in </span><span class="s1">include_dirs:</span>
                <span class="s1">fn1 = os.path.join(inc_dir</span><span class="s3">, </span><span class="s1">fn)</span>
                <span class="s3">if </span><span class="s1">os.path.isfile(fn1):</span>
                    <span class="s1">foundfile = </span><span class="s4">1</span>
                    <span class="s1">readfortrancode(fn1</span><span class="s3">, </span><span class="s1">dowithline=dowithline</span><span class="s3">, </span><span class="s1">istop=</span><span class="s4">0</span><span class="s1">)</span>
                    <span class="s3">break</span>
            <span class="s3">if not </span><span class="s1">foundfile:</span>
                <span class="s1">outmess(</span><span class="s5">'readfortrancode: could not find include file %s in %s. Ignoring.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (</span>
                    <span class="s1">repr(fn)</span><span class="s3">, </span><span class="s1">os.pathsep.join(include_dirs)))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">dowithline(finalline)</span>
    <span class="s1">filepositiontext = </span><span class="s5">''</span>
    <span class="s1">fin.close()</span>
    <span class="s3">if </span><span class="s1">istop:</span>
        <span class="s1">dowithline(</span><span class="s5">''</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">gotnextfile</span><span class="s3">, </span><span class="s1">filepositiontext</span><span class="s3">, </span><span class="s1">currentfilename</span><span class="s3">, </span><span class="s1">sourcecodeform</span><span class="s3">, </span><span class="s1">strictf77</span><span class="s3">,</span><span class="s1">\</span>
            <span class="s1">beginpattern</span><span class="s3">, </span><span class="s1">quiet</span><span class="s3">, </span><span class="s1">verbose</span><span class="s3">, </span><span class="s1">dolowercase = saveglobals</span>

<span class="s0"># Crack line</span>
<span class="s1">beforethisafter = </span><span class="s5">r'\s*(?P&lt;before&gt;%s(?=\s*(\b(%s)\b)))' </span><span class="s1">+ \</span>
    <span class="s5">r'\s*(?P&lt;this&gt;(\b(%s)\b))' </span><span class="s1">+ \</span>
    <span class="s5">r'\s*(?P&lt;after&gt;%s)\s*\Z'</span>
<span class="s0">##</span>
<span class="s1">fortrantypes = </span><span class="s5">r'character|logical|integer|real|complex|double\s*(precision\s*(complex|)|complex)|type(?=\s*\([\w\s,=(*)]*\))|byte'</span>
<span class="s1">typespattern = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s1">fortrantypes</span><span class="s3">, </span><span class="s1">fortrantypes</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'type'</span>
<span class="s1">typespattern4implicit = re.compile(beforethisafter % (</span>
    <span class="s5">''</span><span class="s3">, </span><span class="s1">fortrantypes + </span><span class="s5">'|static|automatic|undefined'</span><span class="s3">, </span><span class="s1">fortrantypes + </span><span class="s5">'|static|automatic|undefined'</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span>
<span class="s0">#</span>
<span class="s1">functionpattern = re.compile(beforethisafter % (</span>
    <span class="s5">r'([a-z]+[\w\s(=*+-/)]*?|)'</span><span class="s3">, </span><span class="s5">'function'</span><span class="s3">, </span><span class="s5">'function'</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'begin'</span>
<span class="s1">subroutinepattern = re.compile(beforethisafter % (</span>
    <span class="s5">r'[a-z\s]*?'</span><span class="s3">, </span><span class="s5">'subroutine'</span><span class="s3">, </span><span class="s5">'subroutine'</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'begin'</span>
<span class="s0"># modulepattern=re.compile(beforethisafter%('[a-z\s]*?','module','module','.*'),re.I),'begin'</span>
<span class="s0">#</span>
<span class="s1">groupbegins77 = </span><span class="s5">r'program|block\s*data'</span>
<span class="s1">beginpattern77 = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s1">groupbegins77</span><span class="s3">, </span><span class="s1">groupbegins77</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'begin'</span>
<span class="s1">groupbegins90 = groupbegins77 + \</span>
    <span class="s5">r'|module(?!\s*procedure)|python\s*module|(abstract|)\s*interface|' </span><span class="s1">+ \</span>
    <span class="s5">r'type(?!\s*\()'</span>
<span class="s1">beginpattern90 = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s1">groupbegins90</span><span class="s3">, </span><span class="s1">groupbegins90</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'begin'</span>
<span class="s1">groupends = (</span><span class="s5">r'end|endprogram|endblockdata|endmodule|endpythonmodule|'</span>
             <span class="s5">r'endinterface|endsubroutine|endfunction'</span><span class="s1">)</span>
<span class="s1">endpattern = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s1">groupends</span><span class="s3">, </span><span class="s1">groupends</span><span class="s3">, </span><span class="s5">r'[\w\s]*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'end'</span>
<span class="s1">endifs = </span><span class="s5">r'(end\s*(if|do|where|select|while|forall|associate|block|critical|enum|team))|(module\s*procedure)'</span>
<span class="s1">endifpattern = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">r'[\w]*?'</span><span class="s3">, </span><span class="s1">endifs</span><span class="s3">, </span><span class="s1">endifs</span><span class="s3">, </span><span class="s5">r'[\w\s]*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'endif'</span>
<span class="s0">#</span>
<span class="s1">implicitpattern = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s5">'implicit'</span><span class="s3">, </span><span class="s5">'implicit'</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'implicit'</span>
<span class="s1">dimensionpattern = re.compile(beforethisafter % (</span>
    <span class="s5">''</span><span class="s3">, </span><span class="s5">'dimension|virtual'</span><span class="s3">, </span><span class="s5">'dimension|virtual'</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'dimension'</span>
<span class="s1">externalpattern = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s5">'external'</span><span class="s3">, </span><span class="s5">'external'</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'external'</span>
<span class="s1">optionalpattern = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s5">'optional'</span><span class="s3">, </span><span class="s5">'optional'</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'optional'</span>
<span class="s1">requiredpattern = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s5">'required'</span><span class="s3">, </span><span class="s5">'required'</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'required'</span>
<span class="s1">publicpattern = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s5">'public'</span><span class="s3">, </span><span class="s5">'public'</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'public'</span>
<span class="s1">privatepattern = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s5">'private'</span><span class="s3">, </span><span class="s5">'private'</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'private'</span>
<span class="s1">intrinsicpattern = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s5">'intrinsic'</span><span class="s3">, </span><span class="s5">'intrinsic'</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'intrinsic'</span>
<span class="s1">intentpattern = re.compile(beforethisafter % (</span>
    <span class="s5">''</span><span class="s3">, </span><span class="s5">'intent|depend|note|check'</span><span class="s3">, </span><span class="s5">'intent|depend|note|check'</span><span class="s3">, </span><span class="s5">r'\s*\(.*?\).*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'intent'</span>
<span class="s1">parameterpattern = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s5">'parameter'</span><span class="s3">, </span><span class="s5">'parameter'</span><span class="s3">, </span><span class="s5">r'\s*\(.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'parameter'</span>
<span class="s1">datapattern = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s5">'data'</span><span class="s3">, </span><span class="s5">'data'</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'data'</span>
<span class="s1">callpattern = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s5">'call'</span><span class="s3">, </span><span class="s5">'call'</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'call'</span>
<span class="s1">entrypattern = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s5">'entry'</span><span class="s3">, </span><span class="s5">'entry'</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'entry'</span>
<span class="s1">callfunpattern = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s5">'callfun'</span><span class="s3">, </span><span class="s5">'callfun'</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'callfun'</span>
<span class="s1">commonpattern = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s5">'common'</span><span class="s3">, </span><span class="s5">'common'</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'common'</span>
<span class="s1">usepattern = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s5">'use'</span><span class="s3">, </span><span class="s5">'use'</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'use'</span>
<span class="s1">containspattern = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s5">'contains'</span><span class="s3">, </span><span class="s5">'contains'</span><span class="s3">, </span><span class="s5">''</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'contains'</span>
<span class="s1">formatpattern = re.compile(</span>
    <span class="s1">beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s5">'format'</span><span class="s3">, </span><span class="s5">'format'</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span><span class="s3">, </span><span class="s5">'format'</span>
<span class="s0"># Non-fortran and f2py-specific statements</span>
<span class="s1">f2pyenhancementspattern = re.compile(beforethisafter % (</span><span class="s5">''</span><span class="s3">, </span><span class="s5">'threadsafe|fortranname|callstatement|callprotoargument|usercode|pymethoddef'</span><span class="s3">,</span>
                                                        <span class="s5">'threadsafe|fortranname|callstatement|callprotoargument|usercode|pymethoddef'</span><span class="s3">, </span><span class="s5">'.*'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I | re.S)</span><span class="s3">, </span><span class="s5">'f2pyenhancements'</span>
<span class="s1">multilinepattern = re.compile(</span>
    <span class="s5">r&quot;\s*(?P&lt;before&gt;''')(?P&lt;this&gt;.*?)(?P&lt;after&gt;''')\s*\Z&quot;</span><span class="s3">, </span><span class="s1">re.S)</span><span class="s3">, </span><span class="s5">'multiline'</span>
<span class="s0">##</span>

<span class="s3">def </span><span class="s1">split_by_unquoted(line</span><span class="s3">, </span><span class="s1">characters):</span>
    <span class="s2">&quot;&quot;&quot; 
    Splits the line into (line[:i], line[i:]), 
    where i is the index of first occurrence of one of the characters 
    not within quotes, or len(line) if no such index exists 
    &quot;&quot;&quot;</span>
    <span class="s3">assert not </span><span class="s1">(set(</span><span class="s5">'&quot;</span><span class="s3">\'</span><span class="s5">'</span><span class="s1">) &amp; set(characters))</span><span class="s3">, </span><span class="s5">&quot;cannot split by unquoted quotes&quot;</span>
    <span class="s1">r = re.compile(</span>
        <span class="s5">r&quot;\A(?P&lt;before&gt;({single_quoted}|{double_quoted}|{not_quoted})*)&quot;</span>
        <span class="s5">r&quot;(?P&lt;after&gt;{char}.*)\Z&quot;</span><span class="s1">.format(</span>
            <span class="s1">not_quoted=</span><span class="s5">&quot;[^</span><span class="s3">\&quot;</span><span class="s5">'{}]&quot;</span><span class="s1">.format(re.escape(characters))</span><span class="s3">,</span>
            <span class="s1">char=</span><span class="s5">&quot;[{}]&quot;</span><span class="s1">.format(re.escape(characters))</span><span class="s3">,</span>
            <span class="s1">single_quoted=</span><span class="s5">r&quot;('([^'\\]|(\\.))*')&quot;</span><span class="s3">,</span>
            <span class="s1">double_quoted=</span><span class="s5">r'(&quot;([^&quot;\\]|(\\.))*&quot;)'</span><span class="s1">))</span>
    <span class="s1">m = r.match(line)</span>
    <span class="s3">if </span><span class="s1">m:</span>
        <span class="s1">d = m.groupdict()</span>
        <span class="s3">return </span><span class="s1">(d[</span><span class="s5">&quot;before&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">d[</span><span class="s5">&quot;after&quot;</span><span class="s1">])</span>
    <span class="s3">return </span><span class="s1">(line</span><span class="s3">, </span><span class="s5">&quot;&quot;</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">_simplifyargs(argsline):</span>
    <span class="s1">a = []</span>
    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">markoutercomma(argsline).split(</span><span class="s5">'@,@'</span><span class="s1">):</span>
        <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s5">'(),'</span><span class="s1">:</span>
            <span class="s1">n = n.replace(r</span><span class="s3">, </span><span class="s5">'_'</span><span class="s1">)</span>
        <span class="s1">a.append(n)</span>
    <span class="s3">return </span><span class="s5">','</span><span class="s1">.join(a)</span>

<span class="s1">crackline_re_1 = re.compile(</span><span class="s5">r'\s*(?P&lt;result&gt;\b[a-z]+\w*\b)\s*=.*'</span><span class="s3">, </span><span class="s1">re.I)</span>


<span class="s3">def </span><span class="s1">crackline(line</span><span class="s3">, </span><span class="s1">reset=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    reset=-1  --- initialize 
    reset=0   --- crack the line 
    reset=1   --- final check if mismatch of blocks occurred 
 
    Cracked data is saved in grouplist[0]. 
    &quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">beginpattern</span><span class="s3">, </span><span class="s1">groupcounter</span><span class="s3">, </span><span class="s1">groupname</span><span class="s3">, </span><span class="s1">groupcache</span><span class="s3">, </span><span class="s1">grouplist</span>
    <span class="s3">global </span><span class="s1">filepositiontext</span><span class="s3">, </span><span class="s1">currentfilename</span><span class="s3">, </span><span class="s1">neededmodule</span><span class="s3">, </span><span class="s1">expectbegin</span>
    <span class="s3">global </span><span class="s1">skipblocksuntil</span><span class="s3">, </span><span class="s1">skipemptyends</span><span class="s3">, </span><span class="s1">previous_context</span><span class="s3">, </span><span class="s1">gotnextfile</span>

    <span class="s1">_</span><span class="s3">, </span><span class="s1">has_semicolon = split_by_unquoted(line</span><span class="s3">, </span><span class="s5">&quot;;&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">has_semicolon </span><span class="s3">and not </span><span class="s1">(f2pyenhancementspattern[</span><span class="s4">0</span><span class="s1">].match(line) </span><span class="s3">or</span>
                               <span class="s1">multilinepattern[</span><span class="s4">0</span><span class="s1">].match(line)):</span>
        <span class="s0"># XXX: non-zero reset values need testing</span>
        <span class="s3">assert </span><span class="s1">reset == </span><span class="s4">0</span><span class="s3">, </span><span class="s1">repr(reset)</span>
        <span class="s0"># split line on unquoted semicolons</span>
        <span class="s1">line</span><span class="s3">, </span><span class="s1">semicolon_line = split_by_unquoted(line</span><span class="s3">, </span><span class="s5">&quot;;&quot;</span><span class="s1">)</span>
        <span class="s3">while </span><span class="s1">semicolon_line:</span>
            <span class="s1">crackline(line</span><span class="s3">, </span><span class="s1">reset)</span>
            <span class="s1">line</span><span class="s3">, </span><span class="s1">semicolon_line = split_by_unquoted(semicolon_line[</span><span class="s4">1</span><span class="s1">:]</span><span class="s3">, </span><span class="s5">&quot;;&quot;</span><span class="s1">)</span>
        <span class="s1">crackline(line</span><span class="s3">, </span><span class="s1">reset)</span>
        <span class="s3">return</span>
    <span class="s3">if </span><span class="s1">reset &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">groupcounter = </span><span class="s4">0</span>
        <span class="s1">groupname = {groupcounter: </span><span class="s5">''</span><span class="s1">}</span>
        <span class="s1">groupcache = {groupcounter: {}}</span>
        <span class="s1">grouplist = {groupcounter: []}</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'body'</span><span class="s1">] = []</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">] = {}</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'block'</span><span class="s1">] = </span><span class="s5">''</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'name'</span><span class="s1">] = </span><span class="s5">''</span>
        <span class="s1">neededmodule = -</span><span class="s4">1</span>
        <span class="s1">skipblocksuntil = -</span><span class="s4">1</span>
        <span class="s3">return</span>
    <span class="s3">if </span><span class="s1">reset &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">fl = </span><span class="s4">0</span>
        <span class="s3">if </span><span class="s1">f77modulename </span><span class="s3">and </span><span class="s1">neededmodule == groupcounter:</span>
            <span class="s1">fl = </span><span class="s4">2</span>
        <span class="s3">while </span><span class="s1">groupcounter &gt; fl:</span>
            <span class="s1">outmess(</span><span class="s5">'crackline: groupcounter=%s groupname=%s</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">%</span>
                    <span class="s1">(repr(groupcounter)</span><span class="s3">, </span><span class="s1">repr(groupname)))</span>
            <span class="s1">outmess(</span>
                <span class="s5">'crackline: Mismatch of blocks encountered. Trying to fix it by assuming &quot;end&quot; statement.</span><span class="s3">\n</span><span class="s5">'</span><span class="s1">)</span>
            <span class="s1">grouplist[groupcounter - </span><span class="s4">1</span><span class="s1">].append(groupcache[groupcounter])</span>
            <span class="s1">grouplist[groupcounter - </span><span class="s4">1</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">][</span><span class="s5">'body'</span><span class="s1">] = grouplist[groupcounter]</span>
            <span class="s3">del </span><span class="s1">grouplist[groupcounter]</span>
            <span class="s1">groupcounter = groupcounter - </span><span class="s4">1</span>
        <span class="s3">if </span><span class="s1">f77modulename </span><span class="s3">and </span><span class="s1">neededmodule == groupcounter:</span>
            <span class="s1">grouplist[groupcounter - </span><span class="s4">1</span><span class="s1">].append(groupcache[groupcounter])</span>
            <span class="s1">grouplist[groupcounter - </span><span class="s4">1</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">][</span><span class="s5">'body'</span><span class="s1">] = grouplist[groupcounter]</span>
            <span class="s3">del </span><span class="s1">grouplist[groupcounter]</span>
            <span class="s1">groupcounter = groupcounter - </span><span class="s4">1  </span><span class="s0"># end interface</span>
            <span class="s1">grouplist[groupcounter - </span><span class="s4">1</span><span class="s1">].append(groupcache[groupcounter])</span>
            <span class="s1">grouplist[groupcounter - </span><span class="s4">1</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">][</span><span class="s5">'body'</span><span class="s1">] = grouplist[groupcounter]</span>
            <span class="s3">del </span><span class="s1">grouplist[groupcounter]</span>
            <span class="s1">groupcounter = groupcounter - </span><span class="s4">1  </span><span class="s0"># end module</span>
            <span class="s1">neededmodule = -</span><span class="s4">1</span>
        <span class="s3">return</span>
    <span class="s3">if </span><span class="s1">line == </span><span class="s5">''</span><span class="s1">:</span>
        <span class="s3">return</span>
    <span class="s1">flag = </span><span class="s4">0</span>
    <span class="s3">for </span><span class="s1">pat </span><span class="s3">in </span><span class="s1">[dimensionpattern</span><span class="s3">, </span><span class="s1">externalpattern</span><span class="s3">, </span><span class="s1">intentpattern</span><span class="s3">, </span><span class="s1">optionalpattern</span><span class="s3">,</span>
                <span class="s1">requiredpattern</span><span class="s3">,</span>
                <span class="s1">parameterpattern</span><span class="s3">, </span><span class="s1">datapattern</span><span class="s3">, </span><span class="s1">publicpattern</span><span class="s3">, </span><span class="s1">privatepattern</span><span class="s3">,</span>
                <span class="s1">intrinsicpattern</span><span class="s3">,</span>
                <span class="s1">endifpattern</span><span class="s3">, </span><span class="s1">endpattern</span><span class="s3">,</span>
                <span class="s1">formatpattern</span><span class="s3">,</span>
                <span class="s1">beginpattern</span><span class="s3">, </span><span class="s1">functionpattern</span><span class="s3">, </span><span class="s1">subroutinepattern</span><span class="s3">,</span>
                <span class="s1">implicitpattern</span><span class="s3">, </span><span class="s1">typespattern</span><span class="s3">, </span><span class="s1">commonpattern</span><span class="s3">,</span>
                <span class="s1">callpattern</span><span class="s3">, </span><span class="s1">usepattern</span><span class="s3">, </span><span class="s1">containspattern</span><span class="s3">,</span>
                <span class="s1">entrypattern</span><span class="s3">,</span>
                <span class="s1">f2pyenhancementspattern</span><span class="s3">,</span>
                <span class="s1">multilinepattern</span>
                <span class="s1">]:</span>
        <span class="s1">m = pat[</span><span class="s4">0</span><span class="s1">].match(line)</span>
        <span class="s3">if </span><span class="s1">m:</span>
            <span class="s3">break</span>
        <span class="s1">flag = flag + </span><span class="s4">1</span>
    <span class="s3">if not </span><span class="s1">m:</span>
        <span class="s1">re_1 = crackline_re_1</span>
        <span class="s3">if </span><span class="s4">0 </span><span class="s1">&lt;= skipblocksuntil &lt;= groupcounter:</span>
            <span class="s3">return</span>
        <span class="s3">if </span><span class="s5">'externals' </span><span class="s3">in </span><span class="s1">groupcache[groupcounter]:</span>
            <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">groupcache[groupcounter][</span><span class="s5">'externals'</span><span class="s1">]:</span>
                <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">invbadnames:</span>
                    <span class="s1">name = invbadnames[name]</span>
                <span class="s3">if </span><span class="s5">'interfaced' </span><span class="s3">in </span><span class="s1">groupcache[groupcounter] </span><span class="s3">and </span><span class="s1">name </span><span class="s3">in </span><span class="s1">groupcache[groupcounter][</span><span class="s5">'interfaced'</span><span class="s1">]:</span>
                    <span class="s3">continue</span>
                <span class="s1">m1 = re.match(</span>
                    <span class="s5">r'(?P&lt;before&gt;[^&quot;]*)\b%s\b\s*@\(@(?P&lt;args&gt;[^@]*)@\)@.*\Z' </span><span class="s1">% name</span><span class="s3">, </span><span class="s1">markouterparen(line)</span><span class="s3">, </span><span class="s1">re.I)</span>
                <span class="s3">if </span><span class="s1">m1:</span>
                    <span class="s1">m2 = re_1.match(m1.group(</span><span class="s5">'before'</span><span class="s1">))</span>
                    <span class="s1">a = _simplifyargs(m1.group(</span><span class="s5">'args'</span><span class="s1">))</span>
                    <span class="s3">if </span><span class="s1">m2:</span>
                        <span class="s1">line = </span><span class="s5">'callfun %s(%s) result (%s)' </span><span class="s1">% (</span>
                            <span class="s1">name</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">m2.group(</span><span class="s5">'result'</span><span class="s1">))</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">line = </span><span class="s5">'callfun %s(%s)' </span><span class="s1">% (name</span><span class="s3">, </span><span class="s1">a)</span>
                    <span class="s1">m = callfunpattern[</span><span class="s4">0</span><span class="s1">].match(line)</span>
                    <span class="s3">if not </span><span class="s1">m:</span>
                        <span class="s1">outmess(</span>
                            <span class="s5">'crackline: could not resolve function call for line=%s.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% repr(line))</span>
                        <span class="s3">return</span>
                    <span class="s1">analyzeline(m</span><span class="s3">, </span><span class="s5">'callfun'</span><span class="s3">, </span><span class="s1">line)</span>
                    <span class="s3">return</span>
        <span class="s3">if </span><span class="s1">verbose &gt; </span><span class="s4">1 </span><span class="s3">or </span><span class="s1">(verbose == </span><span class="s4">1 </span><span class="s3">and </span><span class="s1">currentfilename.lower().endswith(</span><span class="s5">'.pyf'</span><span class="s1">)):</span>
            <span class="s1">previous_context = </span><span class="s3">None</span>
            <span class="s1">outmess(</span><span class="s5">'crackline:%d: No pattern for line</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (groupcounter))</span>
        <span class="s3">return</span>
    <span class="s3">elif </span><span class="s1">pat[</span><span class="s4">1</span><span class="s1">] == </span><span class="s5">'end'</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s4">0 </span><span class="s1">&lt;= skipblocksuntil &lt; groupcounter:</span>
            <span class="s1">groupcounter = groupcounter - </span><span class="s4">1</span>
            <span class="s3">if </span><span class="s1">skipblocksuntil &lt;= groupcounter:</span>
                <span class="s3">return</span>
        <span class="s3">if </span><span class="s1">groupcounter &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">Exception(</span><span class="s5">'crackline: groupcounter(=%s) is nonpositive. '</span>
                            <span class="s5">'Check the blocks.'</span>
                            <span class="s1">% (groupcounter))</span>
        <span class="s1">m1 = beginpattern[</span><span class="s4">0</span><span class="s1">].match((line))</span>
        <span class="s3">if </span><span class="s1">(m1) </span><span class="s3">and </span><span class="s1">(</span><span class="s3">not </span><span class="s1">m1.group(</span><span class="s5">'this'</span><span class="s1">) == groupname[groupcounter]):</span>
            <span class="s3">raise </span><span class="s1">Exception(</span><span class="s5">'crackline: End group %s does not match with '</span>
                            <span class="s5">'previous Begin group %s</span><span class="s3">\n\t</span><span class="s5">%s' </span><span class="s1">%</span>
                            <span class="s1">(repr(m1.group(</span><span class="s5">'this'</span><span class="s1">))</span><span class="s3">, </span><span class="s1">repr(groupname[groupcounter])</span><span class="s3">,</span>
                             <span class="s1">filepositiontext)</span>
                            <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">skipblocksuntil == groupcounter:</span>
            <span class="s1">skipblocksuntil = -</span><span class="s4">1</span>
        <span class="s1">grouplist[groupcounter - </span><span class="s4">1</span><span class="s1">].append(groupcache[groupcounter])</span>
        <span class="s1">grouplist[groupcounter - </span><span class="s4">1</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">][</span><span class="s5">'body'</span><span class="s1">] = grouplist[groupcounter]</span>
        <span class="s3">del </span><span class="s1">grouplist[groupcounter]</span>
        <span class="s1">groupcounter = groupcounter - </span><span class="s4">1</span>
        <span class="s3">if not </span><span class="s1">skipemptyends:</span>
            <span class="s1">expectbegin = </span><span class="s4">1</span>
    <span class="s3">elif </span><span class="s1">pat[</span><span class="s4">1</span><span class="s1">] == </span><span class="s5">'begin'</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s4">0 </span><span class="s1">&lt;= skipblocksuntil &lt;= groupcounter:</span>
            <span class="s1">groupcounter = groupcounter + </span><span class="s4">1</span>
            <span class="s3">return</span>
        <span class="s1">gotnextfile = </span><span class="s4">0</span>
        <span class="s1">analyzeline(m</span><span class="s3">, </span><span class="s1">pat[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">line)</span>
        <span class="s1">expectbegin = </span><span class="s4">0</span>
    <span class="s3">elif </span><span class="s1">pat[</span><span class="s4">1</span><span class="s1">] == </span><span class="s5">'endif'</span><span class="s1">:</span>
        <span class="s3">pass</span>
    <span class="s3">elif </span><span class="s1">pat[</span><span class="s4">1</span><span class="s1">] == </span><span class="s5">'contains'</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">ignorecontains:</span>
            <span class="s3">return</span>
        <span class="s3">if </span><span class="s4">0 </span><span class="s1">&lt;= skipblocksuntil &lt;= groupcounter:</span>
            <span class="s3">return</span>
        <span class="s1">skipblocksuntil = groupcounter</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s4">0 </span><span class="s1">&lt;= skipblocksuntil &lt;= groupcounter:</span>
            <span class="s3">return</span>
        <span class="s1">analyzeline(m</span><span class="s3">, </span><span class="s1">pat[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">line)</span>


<span class="s3">def </span><span class="s1">markouterparen(line):</span>
    <span class="s1">l = </span><span class="s5">''</span>
    <span class="s1">f = </span><span class="s4">0</span>
    <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">line:</span>
        <span class="s3">if </span><span class="s1">c == </span><span class="s5">'('</span><span class="s1">:</span>
            <span class="s1">f = f + </span><span class="s4">1</span>
            <span class="s3">if </span><span class="s1">f == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">l = l + </span><span class="s5">'@(@'</span>
                <span class="s3">continue</span>
        <span class="s3">elif </span><span class="s1">c == </span><span class="s5">')'</span><span class="s1">:</span>
            <span class="s1">f = f - </span><span class="s4">1</span>
            <span class="s3">if </span><span class="s1">f == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">l = l + </span><span class="s5">'@)@'</span>
                <span class="s3">continue</span>
        <span class="s1">l = l + c</span>
    <span class="s3">return </span><span class="s1">l</span>


<span class="s3">def </span><span class="s1">markoutercomma(line</span><span class="s3">, </span><span class="s1">comma=</span><span class="s5">','</span><span class="s1">):</span>
    <span class="s1">l = </span><span class="s5">''</span>
    <span class="s1">f = </span><span class="s4">0</span>
    <span class="s1">before</span><span class="s3">, </span><span class="s1">after = split_by_unquoted(line</span><span class="s3">, </span><span class="s1">comma + </span><span class="s5">'()'</span><span class="s1">)</span>
    <span class="s1">l += before</span>
    <span class="s3">while </span><span class="s1">after:</span>
        <span class="s3">if </span><span class="s1">(after[</span><span class="s4">0</span><span class="s1">] == comma) </span><span class="s3">and </span><span class="s1">(f == </span><span class="s4">0</span><span class="s1">):</span>
            <span class="s1">l += </span><span class="s5">'@' </span><span class="s1">+ comma + </span><span class="s5">'@'</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">l += after[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">after[</span><span class="s4">0</span><span class="s1">] == </span><span class="s5">'('</span><span class="s1">:</span>
                <span class="s1">f += </span><span class="s4">1</span>
            <span class="s3">elif </span><span class="s1">after[</span><span class="s4">0</span><span class="s1">] == </span><span class="s5">')'</span><span class="s1">:</span>
                <span class="s1">f -= </span><span class="s4">1</span>
        <span class="s1">before</span><span class="s3">, </span><span class="s1">after = split_by_unquoted(after[</span><span class="s4">1</span><span class="s1">:]</span><span class="s3">, </span><span class="s1">comma + </span><span class="s5">'()'</span><span class="s1">)</span>
        <span class="s1">l += before</span>
    <span class="s3">assert not </span><span class="s1">f</span><span class="s3">, </span><span class="s1">repr((f</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">l))</span>
    <span class="s3">return </span><span class="s1">l</span>

<span class="s3">def </span><span class="s1">unmarkouterparen(line):</span>
    <span class="s1">r = line.replace(</span><span class="s5">'@(@'</span><span class="s3">, </span><span class="s5">'('</span><span class="s1">).replace(</span><span class="s5">'@)@'</span><span class="s3">, </span><span class="s5">')'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">r</span>


<span class="s3">def </span><span class="s1">appenddecl(decl</span><span class="s3">, </span><span class="s1">decl2</span><span class="s3">, </span><span class="s1">force=</span><span class="s4">1</span><span class="s1">):</span>
    <span class="s3">if not </span><span class="s1">decl:</span>
        <span class="s1">decl = {}</span>
    <span class="s3">if not </span><span class="s1">decl2:</span>
        <span class="s3">return </span><span class="s1">decl</span>
    <span class="s3">if </span><span class="s1">decl </span><span class="s3">is </span><span class="s1">decl2:</span>
        <span class="s3">return </span><span class="s1">decl</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(decl2.keys()):</span>
        <span class="s3">if </span><span class="s1">k == </span><span class="s5">'typespec'</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">force </span><span class="s3">or </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">decl:</span>
                <span class="s1">decl[k] = decl2[k]</span>
        <span class="s3">elif </span><span class="s1">k == </span><span class="s5">'attrspec'</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">decl2[k]:</span>
                <span class="s1">decl = setattrspec(decl</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">force)</span>
        <span class="s3">elif </span><span class="s1">k == </span><span class="s5">'kindselector'</span><span class="s1">:</span>
            <span class="s1">decl = setkindselector(decl</span><span class="s3">, </span><span class="s1">decl2[k]</span><span class="s3">, </span><span class="s1">force)</span>
        <span class="s3">elif </span><span class="s1">k == </span><span class="s5">'charselector'</span><span class="s1">:</span>
            <span class="s1">decl = setcharselector(decl</span><span class="s3">, </span><span class="s1">decl2[k]</span><span class="s3">, </span><span class="s1">force)</span>
        <span class="s3">elif </span><span class="s1">k </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'='</span><span class="s3">, </span><span class="s5">'typename'</span><span class="s1">]:</span>
            <span class="s3">if </span><span class="s1">force </span><span class="s3">or </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">decl:</span>
                <span class="s1">decl[k] = decl2[k]</span>
        <span class="s3">elif </span><span class="s1">k == </span><span class="s5">'note'</span><span class="s1">:</span>
            <span class="s3">pass</span>
        <span class="s3">elif </span><span class="s1">k </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'intent'</span><span class="s3">, </span><span class="s5">'check'</span><span class="s3">, </span><span class="s5">'dimension'</span><span class="s3">, </span><span class="s5">'optional'</span><span class="s3">,</span>
                   <span class="s5">'required'</span><span class="s3">, </span><span class="s5">'depend'</span><span class="s1">]:</span>
            <span class="s1">errmess(</span><span class="s5">'appenddecl: &quot;%s&quot; not implemented.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% k)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">Exception(</span><span class="s5">'appenddecl: Unknown variable definition key: ' </span><span class="s1">+</span>
                            <span class="s1">str(k))</span>
    <span class="s3">return </span><span class="s1">decl</span>

<span class="s1">selectpattern = re.compile(</span>
    <span class="s5">r'\s*(?P&lt;this&gt;(@\(@.*?@\)@|\*[\d*]+|\*\s*@\(@.*?@\)@|))(?P&lt;after&gt;.*)\Z'</span><span class="s3">, </span><span class="s1">re.I)</span>
<span class="s1">nameargspattern = re.compile(</span>
    <span class="s5">r'\s*(?P&lt;name&gt;\b[\w$]+\b)\s*(@\(@\s*(?P&lt;args&gt;[\w\s,]*)\s*@\)@|)\s*((result(\s*@\(@\s*(?P&lt;result&gt;\b[\w$]+\b)\s*@\)@|))|(bind\s*@\(@\s*(?P&lt;bind&gt;.*)\s*@\)@))*\s*\Z'</span><span class="s3">, </span><span class="s1">re.I)</span>
<span class="s1">callnameargspattern = re.compile(</span>
    <span class="s5">r'\s*(?P&lt;name&gt;\b[\w$]+\b)\s*@\(@\s*(?P&lt;args&gt;.*)\s*@\)@\s*\Z'</span><span class="s3">, </span><span class="s1">re.I)</span>
<span class="s1">real16pattern = re.compile(</span>
    <span class="s5">r'([-+]?(?:\d+(?:\.\d*)?|\d*\.\d+))[dD]((?:[-+]?\d+)?)'</span><span class="s1">)</span>
<span class="s1">real8pattern = re.compile(</span>
    <span class="s5">r'([-+]?((?:\d+(?:\.\d*)?|\d*\.\d+))[eE]((?:[-+]?\d+)?)|(\d+\.\d*))'</span><span class="s1">)</span>

<span class="s1">_intentcallbackpattern = re.compile(</span><span class="s5">r'intent\s*\(.*?\bcallback\b'</span><span class="s3">, </span><span class="s1">re.I)</span>


<span class="s3">def </span><span class="s1">_is_intent_callback(vdecl):</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">vdecl.get(</span><span class="s5">'attrspec'</span><span class="s3">, </span><span class="s1">[]):</span>
        <span class="s3">if </span><span class="s1">_intentcallbackpattern.match(a):</span>
            <span class="s3">return </span><span class="s4">1</span>
    <span class="s3">return </span><span class="s4">0</span>


<span class="s3">def </span><span class="s1">_resolvenameargspattern(line):</span>
    <span class="s1">line = markouterparen(line)</span>
    <span class="s1">m1 = nameargspattern.match(line)</span>
    <span class="s3">if </span><span class="s1">m1:</span>
        <span class="s3">return </span><span class="s1">m1.group(</span><span class="s5">'name'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">m1.group(</span><span class="s5">'args'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">m1.group(</span><span class="s5">'result'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">m1.group(</span><span class="s5">'bind'</span><span class="s1">)</span>
    <span class="s1">m1 = callnameargspattern.match(line)</span>
    <span class="s3">if </span><span class="s1">m1:</span>
        <span class="s3">return </span><span class="s1">m1.group(</span><span class="s5">'name'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">m1.group(</span><span class="s5">'args'</span><span class="s1">)</span><span class="s3">, None, None</span>
    <span class="s3">return None, </span><span class="s1">[]</span><span class="s3">, None, None</span>


<span class="s3">def </span><span class="s1">analyzeline(m</span><span class="s3">, </span><span class="s1">case</span><span class="s3">, </span><span class="s1">line):</span>
    <span class="s3">global </span><span class="s1">groupcounter</span><span class="s3">, </span><span class="s1">groupname</span><span class="s3">, </span><span class="s1">groupcache</span><span class="s3">, </span><span class="s1">grouplist</span><span class="s3">, </span><span class="s1">filepositiontext</span>
    <span class="s3">global </span><span class="s1">currentfilename</span><span class="s3">, </span><span class="s1">f77modulename</span><span class="s3">, </span><span class="s1">neededinterface</span><span class="s3">, </span><span class="s1">neededmodule</span>
    <span class="s3">global </span><span class="s1">expectbegin</span><span class="s3">, </span><span class="s1">gotnextfile</span><span class="s3">, </span><span class="s1">previous_context</span>

    <span class="s1">block = m.group(</span><span class="s5">'this'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">case != </span><span class="s5">'multiline'</span><span class="s1">:</span>
        <span class="s1">previous_context = </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">expectbegin </span><span class="s3">and </span><span class="s1">case </span><span class="s3">not in </span><span class="s1">[</span><span class="s5">'begin'</span><span class="s3">, </span><span class="s5">'call'</span><span class="s3">, </span><span class="s5">'callfun'</span><span class="s3">, </span><span class="s5">'type'</span><span class="s1">] \</span>
       <span class="s3">and not </span><span class="s1">skipemptyends </span><span class="s3">and </span><span class="s1">groupcounter &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">newname = os.path.basename(currentfilename).split(</span><span class="s5">'.'</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">outmess(</span>
            <span class="s5">'analyzeline: no group yet. Creating program group with name &quot;%s&quot;.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% newname)</span>
        <span class="s1">gotnextfile = </span><span class="s4">0</span>
        <span class="s1">groupcounter = groupcounter + </span><span class="s4">1</span>
        <span class="s1">groupname[groupcounter] = </span><span class="s5">'program'</span>
        <span class="s1">groupcache[groupcounter] = {}</span>
        <span class="s1">grouplist[groupcounter] = []</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'body'</span><span class="s1">] = []</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">] = {}</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'block'</span><span class="s1">] = </span><span class="s5">'program'</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'name'</span><span class="s1">] = newname</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'from'</span><span class="s1">] = </span><span class="s5">'fromsky'</span>
        <span class="s1">expectbegin = </span><span class="s4">0</span>
    <span class="s3">if </span><span class="s1">case </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'begin'</span><span class="s3">, </span><span class="s5">'call'</span><span class="s3">, </span><span class="s5">'callfun'</span><span class="s1">]:</span>
        <span class="s0"># Crack line =&gt; block,name,args,result</span>
        <span class="s1">block = block.lower()</span>
        <span class="s3">if </span><span class="s1">re.match(</span><span class="s5">r'block\s*data'</span><span class="s3">, </span><span class="s1">block</span><span class="s3">, </span><span class="s1">re.I):</span>
            <span class="s1">block = </span><span class="s5">'block data'</span>
        <span class="s3">elif </span><span class="s1">re.match(</span><span class="s5">r'python\s*module'</span><span class="s3">, </span><span class="s1">block</span><span class="s3">, </span><span class="s1">re.I):</span>
            <span class="s1">block = </span><span class="s5">'python module'</span>
        <span class="s3">elif </span><span class="s1">re.match(</span><span class="s5">r'abstract\s*interface'</span><span class="s3">, </span><span class="s1">block</span><span class="s3">, </span><span class="s1">re.I):</span>
            <span class="s1">block = </span><span class="s5">'abstract interface'</span>
        <span class="s1">name</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">result</span><span class="s3">, </span><span class="s1">bind = _resolvenameargspattern(m.group(</span><span class="s5">'after'</span><span class="s1">))</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">block == </span><span class="s5">'block data'</span><span class="s1">:</span>
                <span class="s1">name = </span><span class="s5">'_BLOCK_DATA_'</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">name = </span><span class="s5">''</span>
            <span class="s3">if </span><span class="s1">block </span><span class="s3">not in </span><span class="s1">[</span><span class="s5">'interface'</span><span class="s3">, </span><span class="s5">'block data'</span><span class="s3">, </span><span class="s5">'abstract interface'</span><span class="s1">]:</span>
                <span class="s1">outmess(</span><span class="s5">'analyzeline: No name/args pattern found for line.</span><span class="s3">\n</span><span class="s5">'</span><span class="s1">)</span>

        <span class="s1">previous_context = (block</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">groupcounter)</span>
        <span class="s3">if </span><span class="s1">args:</span>
            <span class="s1">args = rmbadname([x.strip()</span>
                              <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma(args).split(</span><span class="s5">'@,@'</span><span class="s1">)])</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">args = []</span>
        <span class="s3">if </span><span class="s5">'' </span><span class="s3">in </span><span class="s1">args:</span>
            <span class="s3">while </span><span class="s5">'' </span><span class="s3">in </span><span class="s1">args:</span>
                <span class="s1">args.remove(</span><span class="s5">''</span><span class="s1">)</span>
            <span class="s1">outmess(</span>
                <span class="s5">'analyzeline: argument list is malformed (missing argument).</span><span class="s3">\n</span><span class="s5">'</span><span class="s1">)</span>

        <span class="s0"># end of crack line =&gt; block,name,args,result</span>
        <span class="s1">needmodule = </span><span class="s4">0</span>
        <span class="s1">needinterface = </span><span class="s4">0</span>

        <span class="s3">if </span><span class="s1">case </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'call'</span><span class="s3">, </span><span class="s5">'callfun'</span><span class="s1">]:</span>
            <span class="s1">needinterface = </span><span class="s4">1</span>
            <span class="s3">if </span><span class="s5">'args' </span><span class="s3">not in </span><span class="s1">groupcache[groupcounter]:</span>
                <span class="s3">return</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">groupcache[groupcounter][</span><span class="s5">'args'</span><span class="s1">]:</span>
                <span class="s3">return</span>
            <span class="s3">for </span><span class="s1">it </span><span class="s3">in </span><span class="s1">grouplist[groupcounter]:</span>
                <span class="s3">if </span><span class="s1">it[</span><span class="s5">'name'</span><span class="s1">] == name:</span>
                    <span class="s3">return</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">groupcache[groupcounter][</span><span class="s5">'interfaced'</span><span class="s1">]:</span>
                <span class="s3">return</span>
            <span class="s1">block = {</span><span class="s5">'call'</span><span class="s1">: </span><span class="s5">'subroutine'</span><span class="s3">, </span><span class="s5">'callfun'</span><span class="s1">: </span><span class="s5">'function'</span><span class="s1">}[case]</span>
        <span class="s3">if </span><span class="s1">f77modulename </span><span class="s3">and </span><span class="s1">neededmodule == -</span><span class="s4">1 </span><span class="s3">and </span><span class="s1">groupcounter &lt;= </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">neededmodule = groupcounter + </span><span class="s4">2</span>
            <span class="s1">needmodule = </span><span class="s4">1</span>
            <span class="s3">if </span><span class="s1">block </span><span class="s3">not in </span><span class="s1">[</span><span class="s5">'interface'</span><span class="s3">, </span><span class="s5">'abstract interface'</span><span class="s1">]:</span>
                <span class="s1">needinterface = </span><span class="s4">1</span>
        <span class="s0"># Create new block(s)</span>
        <span class="s1">groupcounter = groupcounter + </span><span class="s4">1</span>
        <span class="s1">groupcache[groupcounter] = {}</span>
        <span class="s1">grouplist[groupcounter] = []</span>
        <span class="s3">if </span><span class="s1">needmodule:</span>
            <span class="s3">if </span><span class="s1">verbose &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">outmess(</span><span class="s5">'analyzeline: Creating module block %s</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">%</span>
                        <span class="s1">repr(f77modulename)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">groupname[groupcounter] = </span><span class="s5">'module'</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'block'</span><span class="s1">] = </span><span class="s5">'python module'</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'name'</span><span class="s1">] = f77modulename</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'from'</span><span class="s1">] = </span><span class="s5">''</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'body'</span><span class="s1">] = []</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'externals'</span><span class="s1">] = []</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'interfaced'</span><span class="s1">] = []</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">] = {}</span>
            <span class="s1">groupcounter = groupcounter + </span><span class="s4">1</span>
            <span class="s1">groupcache[groupcounter] = {}</span>
            <span class="s1">grouplist[groupcounter] = []</span>
        <span class="s3">if </span><span class="s1">needinterface:</span>
            <span class="s3">if </span><span class="s1">verbose &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">outmess(</span><span class="s5">'analyzeline: Creating additional interface block (groupcounter=%s).</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (</span>
                    <span class="s1">groupcounter)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">groupname[groupcounter] = </span><span class="s5">'interface'</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'block'</span><span class="s1">] = </span><span class="s5">'interface'</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'name'</span><span class="s1">] = </span><span class="s5">'unknown_interface'</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'from'</span><span class="s1">] = </span><span class="s5">'%s:%s' </span><span class="s1">% (</span>
                <span class="s1">groupcache[groupcounter - </span><span class="s4">1</span><span class="s1">][</span><span class="s5">'from'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">groupcache[groupcounter - </span><span class="s4">1</span><span class="s1">][</span><span class="s5">'name'</span><span class="s1">])</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'body'</span><span class="s1">] = []</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'externals'</span><span class="s1">] = []</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'interfaced'</span><span class="s1">] = []</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">] = {}</span>
            <span class="s1">groupcounter = groupcounter + </span><span class="s4">1</span>
            <span class="s1">groupcache[groupcounter] = {}</span>
            <span class="s1">grouplist[groupcounter] = []</span>
        <span class="s1">groupname[groupcounter] = block</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'block'</span><span class="s1">] = block</span>
        <span class="s3">if not </span><span class="s1">name:</span>
            <span class="s1">name = </span><span class="s5">'unknown_' </span><span class="s1">+ block.replace(</span><span class="s5">' '</span><span class="s3">, </span><span class="s5">'_'</span><span class="s1">)</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'prefix'</span><span class="s1">] = m.group(</span><span class="s5">'before'</span><span class="s1">)</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'name'</span><span class="s1">] = rmbadname1(name)</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'result'</span><span class="s1">] = result</span>
        <span class="s3">if </span><span class="s1">groupcounter == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'from'</span><span class="s1">] = currentfilename</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">f77modulename </span><span class="s3">and </span><span class="s1">groupcounter == </span><span class="s4">3</span><span class="s1">:</span>
                <span class="s1">groupcache[groupcounter][</span><span class="s5">'from'</span><span class="s1">] = </span><span class="s5">'%s:%s' </span><span class="s1">% (</span>
                    <span class="s1">groupcache[groupcounter - </span><span class="s4">1</span><span class="s1">][</span><span class="s5">'from'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">currentfilename)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">groupcache[groupcounter][</span><span class="s5">'from'</span><span class="s1">] = </span><span class="s5">'%s:%s' </span><span class="s1">% (</span>
                    <span class="s1">groupcache[groupcounter - </span><span class="s4">1</span><span class="s1">][</span><span class="s5">'from'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">groupcache[groupcounter - </span><span class="s4">1</span><span class="s1">][</span><span class="s5">'name'</span><span class="s1">])</span>
        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(groupcache[groupcounter].keys()):</span>
            <span class="s3">if not </span><span class="s1">groupcache[groupcounter][k]:</span>
                <span class="s3">del </span><span class="s1">groupcache[groupcounter][k]</span>

        <span class="s1">groupcache[groupcounter][</span><span class="s5">'args'</span><span class="s1">] = args</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'body'</span><span class="s1">] = []</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'externals'</span><span class="s1">] = []</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'interfaced'</span><span class="s1">] = []</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">] = {}</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'entry'</span><span class="s1">] = {}</span>
        <span class="s0"># end of creation</span>
        <span class="s3">if </span><span class="s1">block == </span><span class="s5">'type'</span><span class="s1">:</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'varnames'</span><span class="s1">] = []</span>

        <span class="s3">if </span><span class="s1">case </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'call'</span><span class="s3">, </span><span class="s5">'callfun'</span><span class="s1">]:  </span><span class="s0"># set parents variables</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">groupcache[groupcounter - </span><span class="s4">2</span><span class="s1">][</span><span class="s5">'externals'</span><span class="s1">]:</span>
                <span class="s1">groupcache[groupcounter - </span><span class="s4">2</span><span class="s1">][</span><span class="s5">'externals'</span><span class="s1">].append(name)</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">] = copy.deepcopy(</span>
                <span class="s1">groupcache[groupcounter - </span><span class="s4">2</span><span class="s1">][</span><span class="s5">'vars'</span><span class="s1">])</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">del </span><span class="s1">groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">][name][</span>
                    <span class="s1">groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">][name][</span><span class="s5">'attrspec'</span><span class="s1">].index(</span><span class="s5">'external'</span><span class="s1">)]</span>
            <span class="s3">except </span><span class="s1">Exception:</span>
                <span class="s3">pass</span>
        <span class="s3">if </span><span class="s1">block </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'function'</span><span class="s3">, </span><span class="s5">'subroutine'</span><span class="s1">]:  </span><span class="s0"># set global attributes</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">][name] = appenddecl(</span>
                    <span class="s1">groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">][name]</span><span class="s3">, </span><span class="s1">groupcache[groupcounter - </span><span class="s4">2</span><span class="s1">][</span><span class="s5">'vars'</span><span class="s1">][</span><span class="s5">''</span><span class="s1">])</span>
            <span class="s3">except </span><span class="s1">Exception:</span>
                <span class="s3">pass</span>
            <span class="s3">if </span><span class="s1">case == </span><span class="s5">'callfun'</span><span class="s1">:  </span><span class="s0"># return type</span>
                <span class="s3">if </span><span class="s1">result </span><span class="s3">and </span><span class="s1">result </span><span class="s3">in </span><span class="s1">groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">]:</span>
                    <span class="s3">if not </span><span class="s1">name == result:</span>
                        <span class="s1">groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">][name] = appenddecl(</span>
                            <span class="s1">groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">][name]</span><span class="s3">, </span><span class="s1">groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">][result])</span>
            <span class="s0"># if groupcounter&gt;1: # name is interfaced</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">groupcache[groupcounter - </span><span class="s4">2</span><span class="s1">][</span><span class="s5">'interfaced'</span><span class="s1">].append(name)</span>
            <span class="s3">except </span><span class="s1">Exception:</span>
                <span class="s3">pass</span>
        <span class="s3">if </span><span class="s1">block == </span><span class="s5">'function'</span><span class="s1">:</span>
            <span class="s1">t = typespattern[</span><span class="s4">0</span><span class="s1">].match(m.group(</span><span class="s5">'before'</span><span class="s1">) + </span><span class="s5">' ' </span><span class="s1">+ name)</span>
            <span class="s3">if </span><span class="s1">t:</span>
                <span class="s1">typespec</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">edecl = cracktypespec0(</span>
                    <span class="s1">t.group(</span><span class="s5">'this'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">t.group(</span><span class="s5">'after'</span><span class="s1">))</span>
                <span class="s1">updatevars(typespec</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">edecl)</span>

        <span class="s3">if </span><span class="s1">case </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'call'</span><span class="s3">, </span><span class="s5">'callfun'</span><span class="s1">]:</span>
            <span class="s1">grouplist[groupcounter - </span><span class="s4">1</span><span class="s1">].append(groupcache[groupcounter])</span>
            <span class="s1">grouplist[groupcounter - </span><span class="s4">1</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">][</span><span class="s5">'body'</span><span class="s1">] = grouplist[groupcounter]</span>
            <span class="s3">del </span><span class="s1">grouplist[groupcounter]</span>
            <span class="s1">groupcounter = groupcounter - </span><span class="s4">1  </span><span class="s0"># end routine</span>
            <span class="s1">grouplist[groupcounter - </span><span class="s4">1</span><span class="s1">].append(groupcache[groupcounter])</span>
            <span class="s1">grouplist[groupcounter - </span><span class="s4">1</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">][</span><span class="s5">'body'</span><span class="s1">] = grouplist[groupcounter]</span>
            <span class="s3">del </span><span class="s1">grouplist[groupcounter]</span>
            <span class="s1">groupcounter = groupcounter - </span><span class="s4">1  </span><span class="s0"># end interface</span>

    <span class="s3">elif </span><span class="s1">case == </span><span class="s5">'entry'</span><span class="s1">:</span>
        <span class="s1">name</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">result</span><span class="s3">, </span><span class="s1">bind = _resolvenameargspattern(m.group(</span><span class="s5">'after'</span><span class="s1">))</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">args:</span>
                <span class="s1">args = rmbadname([x.strip()</span>
                                  <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma(args).split(</span><span class="s5">'@,@'</span><span class="s1">)])</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">args = []</span>
            <span class="s3">assert </span><span class="s1">result </span><span class="s3">is None, </span><span class="s1">repr(result)</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'entry'</span><span class="s1">][name] = args</span>
            <span class="s1">previous_context = (</span><span class="s5">'entry'</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">groupcounter)</span>
    <span class="s3">elif </span><span class="s1">case == </span><span class="s5">'type'</span><span class="s1">:</span>
        <span class="s1">typespec</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">edecl = cracktypespec0(</span>
            <span class="s1">block</span><span class="s3">, </span><span class="s1">m.group(</span><span class="s5">'after'</span><span class="s1">))</span>
        <span class="s1">last_name = updatevars(typespec</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">edecl)</span>
        <span class="s3">if </span><span class="s1">last_name </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">previous_context = (</span><span class="s5">'variable'</span><span class="s3">, </span><span class="s1">last_name</span><span class="s3">, </span><span class="s1">groupcounter)</span>
    <span class="s3">elif </span><span class="s1">case </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'dimension'</span><span class="s3">, </span><span class="s5">'intent'</span><span class="s3">, </span><span class="s5">'optional'</span><span class="s3">, </span><span class="s5">'required'</span><span class="s3">, </span><span class="s5">'external'</span><span class="s3">, </span><span class="s5">'public'</span><span class="s3">, </span><span class="s5">'private'</span><span class="s3">, </span><span class="s5">'intrinsic'</span><span class="s1">]:</span>
        <span class="s1">edecl = groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">]</span>
        <span class="s1">ll = m.group(</span><span class="s5">'after'</span><span class="s1">).strip()</span>
        <span class="s1">i = ll.find(</span><span class="s5">'::'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">i &lt; </span><span class="s4">0 </span><span class="s3">and </span><span class="s1">case == </span><span class="s5">'intent'</span><span class="s1">:</span>
            <span class="s1">i = markouterparen(ll).find(</span><span class="s5">'@)@'</span><span class="s1">) - </span><span class="s4">2</span>
            <span class="s1">ll = ll[:i + </span><span class="s4">1</span><span class="s1">] + </span><span class="s5">'::' </span><span class="s1">+ ll[i + </span><span class="s4">1</span><span class="s1">:]</span>
            <span class="s1">i = ll.find(</span><span class="s5">'::'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">ll[i:] == </span><span class="s5">'::' </span><span class="s3">and </span><span class="s5">'args' </span><span class="s3">in </span><span class="s1">groupcache[groupcounter]:</span>
                <span class="s1">outmess(</span><span class="s5">'All arguments will have attribute %s%s</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">%</span>
                        <span class="s1">(m.group(</span><span class="s5">'this'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">ll[:i]))</span>
                <span class="s1">ll = ll + </span><span class="s5">','</span><span class="s1">.join(groupcache[groupcounter][</span><span class="s5">'args'</span><span class="s1">])</span>
        <span class="s3">if </span><span class="s1">i &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">i = </span><span class="s4">0</span>
            <span class="s1">pl = </span><span class="s5">''</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">pl = ll[:i].strip()</span>
            <span class="s1">ll = ll[i + </span><span class="s4">2</span><span class="s1">:]</span>
        <span class="s1">ch = markoutercomma(pl).split(</span><span class="s5">'@,@'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">len(ch) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">pl = ch[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">outmess(</span><span class="s5">'analyzeline: cannot handle multiple attributes without type specification. Ignoring %r.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (</span>
                <span class="s5">','</span><span class="s1">.join(ch[</span><span class="s4">1</span><span class="s1">:])))</span>
        <span class="s1">last_name = </span><span class="s3">None</span>

        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">[x.strip() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma(ll).split(</span><span class="s5">'@,@'</span><span class="s1">)]:</span>
            <span class="s1">m1 = namepattern.match(e)</span>
            <span class="s3">if not </span><span class="s1">m1:</span>
                <span class="s3">if </span><span class="s1">case </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'public'</span><span class="s3">, </span><span class="s5">'private'</span><span class="s1">]:</span>
                    <span class="s1">k = </span><span class="s5">''</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">print(m.groupdict())</span>
                    <span class="s1">outmess(</span><span class="s5">'analyzeline: no name pattern found in %s statement for %s. Skipping.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (</span>
                        <span class="s1">case</span><span class="s3">, </span><span class="s1">repr(e)))</span>
                    <span class="s3">continue</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">k = rmbadname1(m1.group(</span><span class="s5">'name'</span><span class="s1">))</span>
            <span class="s3">if </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">edecl:</span>
                <span class="s1">edecl[k] = {}</span>
            <span class="s3">if </span><span class="s1">case == </span><span class="s5">'dimension'</span><span class="s1">:</span>
                <span class="s1">ap = case + m1.group(</span><span class="s5">'after'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">case == </span><span class="s5">'intent'</span><span class="s1">:</span>
                <span class="s1">ap = m.group(</span><span class="s5">'this'</span><span class="s1">) + pl</span>
                <span class="s3">if </span><span class="s1">_intentcallbackpattern.match(ap):</span>
                    <span class="s3">if </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">groupcache[groupcounter][</span><span class="s5">'args'</span><span class="s1">]:</span>
                        <span class="s3">if </span><span class="s1">groupcounter &gt; </span><span class="s4">1</span><span class="s1">:</span>
                            <span class="s3">if </span><span class="s5">'__user__' </span><span class="s3">not in </span><span class="s1">groupcache[groupcounter - </span><span class="s4">2</span><span class="s1">][</span><span class="s5">'name'</span><span class="s1">]:</span>
                                <span class="s1">outmess(</span>
                                    <span class="s5">'analyzeline: missing __user__ module (could be nothing)</span><span class="s3">\n</span><span class="s5">'</span><span class="s1">)</span>
                            <span class="s0"># fixes ticket 1693</span>
                            <span class="s3">if </span><span class="s1">k != groupcache[groupcounter][</span><span class="s5">'name'</span><span class="s1">]:</span>
                                <span class="s1">outmess(</span><span class="s5">'analyzeline: appending intent(callback) %s'</span>
                                        <span class="s5">' to %s arguments</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (k</span><span class="s3">, </span><span class="s1">groupcache[groupcounter][</span><span class="s5">'name'</span><span class="s1">]))</span>
                                <span class="s1">groupcache[groupcounter][</span><span class="s5">'args'</span><span class="s1">].append(k)</span>
                        <span class="s3">else</span><span class="s1">:</span>
                            <span class="s1">errmess(</span>
                                <span class="s5">'analyzeline: intent(callback) %s is ignored</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (k))</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">errmess(</span><span class="s5">'analyzeline: intent(callback) %s is already'</span>
                                <span class="s5">' in argument list</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (k))</span>
            <span class="s3">if </span><span class="s1">case </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'optional'</span><span class="s3">, </span><span class="s5">'required'</span><span class="s3">, </span><span class="s5">'public'</span><span class="s3">, </span><span class="s5">'external'</span><span class="s3">, </span><span class="s5">'private'</span><span class="s3">, </span><span class="s5">'intrinsic'</span><span class="s1">]:</span>
                <span class="s1">ap = case</span>
            <span class="s3">if </span><span class="s5">'attrspec' </span><span class="s3">in </span><span class="s1">edecl[k]:</span>
                <span class="s1">edecl[k][</span><span class="s5">'attrspec'</span><span class="s1">].append(ap)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">edecl[k][</span><span class="s5">'attrspec'</span><span class="s1">] = [ap]</span>
            <span class="s3">if </span><span class="s1">case == </span><span class="s5">'external'</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">groupcache[groupcounter][</span><span class="s5">'block'</span><span class="s1">] == </span><span class="s5">'program'</span><span class="s1">:</span>
                    <span class="s1">outmess(</span><span class="s5">'analyzeline: ignoring program arguments</span><span class="s3">\n</span><span class="s5">'</span><span class="s1">)</span>
                    <span class="s3">continue</span>
                <span class="s3">if </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">groupcache[groupcounter][</span><span class="s5">'args'</span><span class="s1">]:</span>
                    <span class="s3">continue</span>
                <span class="s3">if </span><span class="s5">'externals' </span><span class="s3">not in </span><span class="s1">groupcache[groupcounter]:</span>
                    <span class="s1">groupcache[groupcounter][</span><span class="s5">'externals'</span><span class="s1">] = []</span>
                <span class="s1">groupcache[groupcounter][</span><span class="s5">'externals'</span><span class="s1">].append(k)</span>
            <span class="s1">last_name = k</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">] = edecl</span>
        <span class="s3">if </span><span class="s1">last_name </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">previous_context = (</span><span class="s5">'variable'</span><span class="s3">, </span><span class="s1">last_name</span><span class="s3">, </span><span class="s1">groupcounter)</span>
    <span class="s3">elif </span><span class="s1">case == </span><span class="s5">'parameter'</span><span class="s1">:</span>
        <span class="s1">edecl = groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">]</span>
        <span class="s1">ll = m.group(</span><span class="s5">'after'</span><span class="s1">).strip()[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">last_name = </span><span class="s3">None</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">markoutercomma(ll).split(</span><span class="s5">'@,@'</span><span class="s1">):</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">k</span><span class="s3">, </span><span class="s1">initexpr = [x.strip() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">e.split(</span><span class="s5">'='</span><span class="s1">)]</span>
            <span class="s3">except </span><span class="s1">Exception:</span>
                <span class="s1">outmess(</span>
                    <span class="s5">'analyzeline: could not extract name,expr in parameter statement &quot;%s&quot; of &quot;%s&quot;</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (e</span><span class="s3">, </span><span class="s1">ll))</span>
                <span class="s3">continue</span>
            <span class="s1">params = get_parameters(edecl)</span>
            <span class="s1">k = rmbadname1(k)</span>
            <span class="s3">if </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">edecl:</span>
                <span class="s1">edecl[k] = {}</span>
            <span class="s3">if </span><span class="s5">'=' </span><span class="s3">in </span><span class="s1">edecl[k] </span><span class="s3">and </span><span class="s1">(</span><span class="s3">not </span><span class="s1">edecl[k][</span><span class="s5">'='</span><span class="s1">] == initexpr):</span>
                <span class="s1">outmess(</span><span class="s5">'analyzeline: Overwriting the value of parameter &quot;%s&quot; (&quot;%s&quot;) with &quot;%s&quot;.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (</span>
                    <span class="s1">k</span><span class="s3">, </span><span class="s1">edecl[k][</span><span class="s5">'='</span><span class="s1">]</span><span class="s3">, </span><span class="s1">initexpr))</span>
            <span class="s1">t = determineexprtype(initexpr</span><span class="s3">, </span><span class="s1">params)</span>
            <span class="s3">if </span><span class="s1">t:</span>
                <span class="s3">if </span><span class="s1">t.get(</span><span class="s5">'typespec'</span><span class="s1">) == </span><span class="s5">'real'</span><span class="s1">:</span>
                    <span class="s1">tt = list(initexpr)</span>
                    <span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">real16pattern.finditer(initexpr):</span>
                        <span class="s1">tt[m.start():m.end()] = list(</span>
                            <span class="s1">initexpr[m.start():m.end()].lower().replace(</span><span class="s5">'d'</span><span class="s3">, </span><span class="s5">'e'</span><span class="s1">))</span>
                    <span class="s1">initexpr = </span><span class="s5">''</span><span class="s1">.join(tt)</span>
                <span class="s3">elif </span><span class="s1">t.get(</span><span class="s5">'typespec'</span><span class="s1">) == </span><span class="s5">'complex'</span><span class="s1">:</span>
                    <span class="s1">initexpr = initexpr[</span><span class="s4">1</span><span class="s1">:].lower().replace(</span><span class="s5">'d'</span><span class="s3">, </span><span class="s5">'e'</span><span class="s1">).\</span>
                        <span class="s1">replace(</span><span class="s5">','</span><span class="s3">, </span><span class="s5">'+1j*('</span><span class="s1">)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">v = eval(initexpr</span><span class="s3">, </span><span class="s1">{}</span><span class="s3">, </span><span class="s1">params)</span>
            <span class="s3">except </span><span class="s1">(SyntaxError</span><span class="s3">, </span><span class="s1">NameError</span><span class="s3">, </span><span class="s1">TypeError) </span><span class="s3">as </span><span class="s1">msg:</span>
                <span class="s1">errmess(</span><span class="s5">'analyzeline: Failed to evaluate %r. Ignoring: %s</span><span class="s3">\n</span><span class="s5">'</span>
                        <span class="s1">% (initexpr</span><span class="s3">, </span><span class="s1">msg))</span>
                <span class="s3">continue</span>
            <span class="s1">edecl[k][</span><span class="s5">'='</span><span class="s1">] = repr(v)</span>
            <span class="s3">if </span><span class="s5">'attrspec' </span><span class="s3">in </span><span class="s1">edecl[k]:</span>
                <span class="s1">edecl[k][</span><span class="s5">'attrspec'</span><span class="s1">].append(</span><span class="s5">'parameter'</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">edecl[k][</span><span class="s5">'attrspec'</span><span class="s1">] = [</span><span class="s5">'parameter'</span><span class="s1">]</span>
            <span class="s1">last_name = k</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">] = edecl</span>
        <span class="s3">if </span><span class="s1">last_name </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">previous_context = (</span><span class="s5">'variable'</span><span class="s3">, </span><span class="s1">last_name</span><span class="s3">, </span><span class="s1">groupcounter)</span>
    <span class="s3">elif </span><span class="s1">case == </span><span class="s5">'implicit'</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">m.group(</span><span class="s5">'after'</span><span class="s1">).strip().lower() == </span><span class="s5">'none'</span><span class="s1">:</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'implicit'</span><span class="s1">] = </span><span class="s3">None</span>
        <span class="s3">elif </span><span class="s1">m.group(</span><span class="s5">'after'</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s5">'implicit' </span><span class="s3">in </span><span class="s1">groupcache[groupcounter]:</span>
                <span class="s1">impl = groupcache[groupcounter][</span><span class="s5">'implicit'</span><span class="s1">]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">impl = {}</span>
            <span class="s3">if </span><span class="s1">impl </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">outmess(</span>
                    <span class="s5">'analyzeline: Overwriting earlier &quot;implicit none&quot; statement.</span><span class="s3">\n</span><span class="s5">'</span><span class="s1">)</span>
                <span class="s1">impl = {}</span>
            <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">markoutercomma(m.group(</span><span class="s5">'after'</span><span class="s1">)).split(</span><span class="s5">'@,@'</span><span class="s1">):</span>
                <span class="s1">decl = {}</span>
                <span class="s1">m1 = re.match(</span>
                    <span class="s5">r'\s*(?P&lt;this&gt;.*?)\s*(\(\s*(?P&lt;after&gt;[a-z-, ]+)\s*\)\s*|)\Z'</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">re.I)</span>
                <span class="s3">if not </span><span class="s1">m1:</span>
                    <span class="s1">outmess(</span>
                        <span class="s5">'analyzeline: could not extract info of implicit statement part &quot;%s&quot;</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (e))</span>
                    <span class="s3">continue</span>
                <span class="s1">m2 = typespattern4implicit.match(m1.group(</span><span class="s5">'this'</span><span class="s1">))</span>
                <span class="s3">if not </span><span class="s1">m2:</span>
                    <span class="s1">outmess(</span>
                        <span class="s5">'analyzeline: could not extract types pattern of implicit statement part &quot;%s&quot;</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (e))</span>
                    <span class="s3">continue</span>
                <span class="s1">typespec</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">edecl = cracktypespec0(</span>
                    <span class="s1">m2.group(</span><span class="s5">'this'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">m2.group(</span><span class="s5">'after'</span><span class="s1">))</span>
                <span class="s1">kindselect</span><span class="s3">, </span><span class="s1">charselect</span><span class="s3">, </span><span class="s1">typename = cracktypespec(</span>
                    <span class="s1">typespec</span><span class="s3">, </span><span class="s1">selector)</span>
                <span class="s1">decl[</span><span class="s5">'typespec'</span><span class="s1">] = typespec</span>
                <span class="s1">decl[</span><span class="s5">'kindselector'</span><span class="s1">] = kindselect</span>
                <span class="s1">decl[</span><span class="s5">'charselector'</span><span class="s1">] = charselect</span>
                <span class="s1">decl[</span><span class="s5">'typename'</span><span class="s1">] = typename</span>
                <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(decl.keys()):</span>
                    <span class="s3">if not </span><span class="s1">decl[k]:</span>
                        <span class="s3">del </span><span class="s1">decl[k]</span>
                <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">markoutercomma(m1.group(</span><span class="s5">'after'</span><span class="s1">)).split(</span><span class="s5">'@,@'</span><span class="s1">):</span>
                    <span class="s3">if </span><span class="s5">'-' </span><span class="s3">in </span><span class="s1">r:</span>
                        <span class="s3">try</span><span class="s1">:</span>
                            <span class="s1">begc</span><span class="s3">, </span><span class="s1">endc = [x.strip() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">r.split(</span><span class="s5">'-'</span><span class="s1">)]</span>
                        <span class="s3">except </span><span class="s1">Exception:</span>
                            <span class="s1">outmess(</span>
                                <span class="s5">'analyzeline: expected &quot;&lt;char&gt;-&lt;char&gt;&quot; instead of &quot;%s&quot; in range list of implicit statement</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% r)</span>
                            <span class="s3">continue</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">begc = endc = r.strip()</span>
                    <span class="s3">if not </span><span class="s1">len(begc) == len(endc) == </span><span class="s4">1</span><span class="s1">:</span>
                        <span class="s1">outmess(</span>
                            <span class="s5">'analyzeline: expected &quot;&lt;char&gt;-&lt;char&gt;&quot; instead of &quot;%s&quot; in range list of implicit statement (2)</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% r)</span>
                        <span class="s3">continue</span>
                    <span class="s3">for </span><span class="s1">o </span><span class="s3">in </span><span class="s1">range(ord(begc)</span><span class="s3">, </span><span class="s1">ord(endc) + </span><span class="s4">1</span><span class="s1">):</span>
                        <span class="s1">impl[chr(o)] = decl</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'implicit'</span><span class="s1">] = impl</span>
    <span class="s3">elif </span><span class="s1">case == </span><span class="s5">'data'</span><span class="s1">:</span>
        <span class="s1">ll = []</span>
        <span class="s1">dl = </span><span class="s5">''</span>
        <span class="s1">il = </span><span class="s5">''</span>
        <span class="s1">f = </span><span class="s4">0</span>
        <span class="s1">fc = </span><span class="s4">1</span>
        <span class="s1">inp = </span><span class="s4">0</span>
        <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">m.group(</span><span class="s5">'after'</span><span class="s1">):</span>
            <span class="s3">if not </span><span class="s1">inp:</span>
                <span class="s3">if </span><span class="s1">c == </span><span class="s5">&quot;'&quot;</span><span class="s1">:</span>
                    <span class="s1">fc = </span><span class="s3">not </span><span class="s1">fc</span>
                <span class="s3">if </span><span class="s1">c == </span><span class="s5">'/' </span><span class="s3">and </span><span class="s1">fc:</span>
                    <span class="s1">f = f + </span><span class="s4">1</span>
                    <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">c == </span><span class="s5">'('</span><span class="s1">:</span>
                <span class="s1">inp = inp + </span><span class="s4">1</span>
            <span class="s3">elif </span><span class="s1">c == </span><span class="s5">')'</span><span class="s1">:</span>
                <span class="s1">inp = inp - </span><span class="s4">1</span>
            <span class="s3">if </span><span class="s1">f == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">dl = dl + c</span>
            <span class="s3">elif </span><span class="s1">f == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">il = il + c</span>
            <span class="s3">elif </span><span class="s1">f == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">dl = dl.strip()</span>
                <span class="s3">if </span><span class="s1">dl.startswith(</span><span class="s5">','</span><span class="s1">):</span>
                    <span class="s1">dl = dl[</span><span class="s4">1</span><span class="s1">:].strip()</span>
                <span class="s1">ll.append([dl</span><span class="s3">, </span><span class="s1">il])</span>
                <span class="s1">dl = c</span>
                <span class="s1">il = </span><span class="s5">''</span>
                <span class="s1">f = </span><span class="s4">0</span>
        <span class="s3">if </span><span class="s1">f == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">dl = dl.strip()</span>
            <span class="s3">if </span><span class="s1">dl.startswith(</span><span class="s5">','</span><span class="s1">):</span>
                <span class="s1">dl = dl[</span><span class="s4">1</span><span class="s1">:].strip()</span>
            <span class="s1">ll.append([dl</span><span class="s3">, </span><span class="s1">il])</span>
        <span class="s1">vars = {}</span>
        <span class="s3">if </span><span class="s5">'vars' </span><span class="s3">in </span><span class="s1">groupcache[groupcounter]:</span>
            <span class="s1">vars = groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">]</span>
        <span class="s1">last_name = </span><span class="s3">None</span>
        <span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">ll:</span>
            <span class="s1">l = [x.strip() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">l]</span>
            <span class="s3">if </span><span class="s1">l[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">] == </span><span class="s5">','</span><span class="s1">:</span>
                <span class="s1">l[</span><span class="s4">0</span><span class="s1">] = l[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">:]</span>
            <span class="s3">if </span><span class="s1">l[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">] == </span><span class="s5">'('</span><span class="s1">:</span>
                <span class="s1">outmess(</span>
                    <span class="s5">'analyzeline: implied-DO list &quot;%s&quot; is not supported. Skipping.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% l[</span><span class="s4">0</span><span class="s1">])</span>
                <span class="s3">continue</span>
            <span class="s1">i = </span><span class="s4">0</span>
            <span class="s1">j = </span><span class="s4">0</span>
            <span class="s1">llen = len(l[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">rmbadname([x.strip() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma(l[</span><span class="s4">0</span><span class="s1">]).split(</span><span class="s5">'@,@'</span><span class="s1">)]):</span>
                <span class="s3">if </span><span class="s1">v[</span><span class="s4">0</span><span class="s1">] == </span><span class="s5">'('</span><span class="s1">:</span>
                    <span class="s1">outmess(</span>
                        <span class="s5">'analyzeline: implied-DO list &quot;%s&quot; is not supported. Skipping.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% v)</span>
                    <span class="s0"># XXX: subsequent init expressions may get wrong values.</span>
                    <span class="s0"># Ignoring since data statements are irrelevant for</span>
                    <span class="s0"># wrapping.</span>
                    <span class="s3">continue</span>
                <span class="s1">fc = </span><span class="s4">0</span>
                <span class="s3">while </span><span class="s1">(i &lt; llen) </span><span class="s3">and </span><span class="s1">(fc </span><span class="s3">or not </span><span class="s1">l[</span><span class="s4">1</span><span class="s1">][i] == </span><span class="s5">','</span><span class="s1">):</span>
                    <span class="s3">if </span><span class="s1">l[</span><span class="s4">1</span><span class="s1">][i] == </span><span class="s5">&quot;'&quot;</span><span class="s1">:</span>
                        <span class="s1">fc = </span><span class="s3">not </span><span class="s1">fc</span>
                    <span class="s1">i = i + </span><span class="s4">1</span>
                <span class="s1">i = i + </span><span class="s4">1</span>
                <span class="s3">if </span><span class="s1">v </span><span class="s3">not in </span><span class="s1">vars:</span>
                    <span class="s1">vars[v] = {}</span>
                <span class="s3">if </span><span class="s5">'=' </span><span class="s3">in </span><span class="s1">vars[v] </span><span class="s3">and not </span><span class="s1">vars[v][</span><span class="s5">'='</span><span class="s1">] == l[</span><span class="s4">1</span><span class="s1">][j:i - </span><span class="s4">1</span><span class="s1">]:</span>
                    <span class="s1">outmess(</span><span class="s5">'analyzeline: changing init expression of &quot;%s&quot; (&quot;%s&quot;) to &quot;%s&quot;</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (</span>
                        <span class="s1">v</span><span class="s3">, </span><span class="s1">vars[v][</span><span class="s5">'='</span><span class="s1">]</span><span class="s3">, </span><span class="s1">l[</span><span class="s4">1</span><span class="s1">][j:i - </span><span class="s4">1</span><span class="s1">]))</span>
                <span class="s1">vars[v][</span><span class="s5">'='</span><span class="s1">] = l[</span><span class="s4">1</span><span class="s1">][j:i - </span><span class="s4">1</span><span class="s1">]</span>
                <span class="s1">j = i</span>
                <span class="s1">last_name = v</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">] = vars</span>
        <span class="s3">if </span><span class="s1">last_name </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">previous_context = (</span><span class="s5">'variable'</span><span class="s3">, </span><span class="s1">last_name</span><span class="s3">, </span><span class="s1">groupcounter)</span>
    <span class="s3">elif </span><span class="s1">case == </span><span class="s5">'common'</span><span class="s1">:</span>
        <span class="s1">line = m.group(</span><span class="s5">'after'</span><span class="s1">).strip()</span>
        <span class="s3">if not </span><span class="s1">line[</span><span class="s4">0</span><span class="s1">] == </span><span class="s5">'/'</span><span class="s1">:</span>
            <span class="s1">line = </span><span class="s5">'//' </span><span class="s1">+ line</span>
        <span class="s1">cl = []</span>
        <span class="s1">f = </span><span class="s4">0</span>
        <span class="s1">bn = </span><span class="s5">''</span>
        <span class="s1">ol = </span><span class="s5">''</span>
        <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">line:</span>
            <span class="s3">if </span><span class="s1">c == </span><span class="s5">'/'</span><span class="s1">:</span>
                <span class="s1">f = f + </span><span class="s4">1</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">f &gt;= </span><span class="s4">3</span><span class="s1">:</span>
                <span class="s1">bn = bn.strip()</span>
                <span class="s3">if not </span><span class="s1">bn:</span>
                    <span class="s1">bn = </span><span class="s5">'_BLNK_'</span>
                <span class="s1">cl.append([bn</span><span class="s3">, </span><span class="s1">ol])</span>
                <span class="s1">f = f - </span><span class="s4">2</span>
                <span class="s1">bn = </span><span class="s5">''</span>
                <span class="s1">ol = </span><span class="s5">''</span>
            <span class="s3">if </span><span class="s1">f % </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">bn = bn + c</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">ol = ol + c</span>
        <span class="s1">bn = bn.strip()</span>
        <span class="s3">if not </span><span class="s1">bn:</span>
            <span class="s1">bn = </span><span class="s5">'_BLNK_'</span>
        <span class="s1">cl.append([bn</span><span class="s3">, </span><span class="s1">ol])</span>
        <span class="s1">commonkey = {}</span>
        <span class="s3">if </span><span class="s5">'common' </span><span class="s3">in </span><span class="s1">groupcache[groupcounter]:</span>
            <span class="s1">commonkey = groupcache[groupcounter][</span><span class="s5">'common'</span><span class="s1">]</span>
        <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">cl:</span>
            <span class="s3">if </span><span class="s1">c[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">not in </span><span class="s1">commonkey:</span>
                <span class="s1">commonkey[c[</span><span class="s4">0</span><span class="s1">]] = []</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">[x.strip() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma(c[</span><span class="s4">1</span><span class="s1">]).split(</span><span class="s5">'@,@'</span><span class="s1">)]:</span>
                <span class="s3">if </span><span class="s1">i:</span>
                    <span class="s1">commonkey[c[</span><span class="s4">0</span><span class="s1">]].append(i)</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'common'</span><span class="s1">] = commonkey</span>
        <span class="s1">previous_context = (</span><span class="s5">'common'</span><span class="s3">, </span><span class="s1">bn</span><span class="s3">, </span><span class="s1">groupcounter)</span>
    <span class="s3">elif </span><span class="s1">case == </span><span class="s5">'use'</span><span class="s1">:</span>
        <span class="s1">m1 = re.match(</span>
            <span class="s5">r'\A\s*(?P&lt;name&gt;\b\w+\b)\s*((,(\s*\bonly\b\s*:|(?P&lt;notonly&gt;))\s*(?P&lt;list&gt;.*))|)\s*\Z'</span><span class="s3">, </span><span class="s1">m.group(</span><span class="s5">'after'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">re.I)</span>
        <span class="s3">if </span><span class="s1">m1:</span>
            <span class="s1">mm = m1.groupdict()</span>
            <span class="s3">if </span><span class="s5">'use' </span><span class="s3">not in </span><span class="s1">groupcache[groupcounter]:</span>
                <span class="s1">groupcache[groupcounter][</span><span class="s5">'use'</span><span class="s1">] = {}</span>
            <span class="s1">name = m1.group(</span><span class="s5">'name'</span><span class="s1">)</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'use'</span><span class="s1">][name] = {}</span>
            <span class="s1">isonly = </span><span class="s4">0</span>
            <span class="s3">if </span><span class="s5">'list' </span><span class="s3">in </span><span class="s1">mm </span><span class="s3">and </span><span class="s1">mm[</span><span class="s5">'list'</span><span class="s1">] </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s5">'notonly' </span><span class="s3">in </span><span class="s1">mm </span><span class="s3">and </span><span class="s1">mm[</span><span class="s5">'notonly'</span><span class="s1">] </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s1">isonly = </span><span class="s4">1</span>
                <span class="s1">groupcache[groupcounter][</span><span class="s5">'use'</span><span class="s1">][name][</span><span class="s5">'only'</span><span class="s1">] = isonly</span>
                <span class="s1">ll = [x.strip() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">mm[</span><span class="s5">'list'</span><span class="s1">].split(</span><span class="s5">','</span><span class="s1">)]</span>
                <span class="s1">rl = {}</span>
                <span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">ll:</span>
                    <span class="s3">if </span><span class="s5">'=' </span><span class="s3">in </span><span class="s1">l:</span>
                        <span class="s1">m2 = re.match(</span>
                            <span class="s5">r'\A\s*(?P&lt;local&gt;\b\w+\b)\s*=\s*&gt;\s*(?P&lt;use&gt;\b\w+\b)\s*\Z'</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">re.I)</span>
                        <span class="s3">if </span><span class="s1">m2:</span>
                            <span class="s1">rl[m2.group(</span><span class="s5">'local'</span><span class="s1">).strip()] = m2.group(</span>
                                <span class="s5">'use'</span><span class="s1">).strip()</span>
                        <span class="s3">else</span><span class="s1">:</span>
                            <span class="s1">outmess(</span>
                                <span class="s5">'analyzeline: Not local=&gt;use pattern found in %s</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% repr(l))</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">rl[l] = l</span>
                    <span class="s1">groupcache[groupcounter][</span><span class="s5">'use'</span><span class="s1">][name][</span><span class="s5">'map'</span><span class="s1">] = rl</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">pass</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">print(m.groupdict())</span>
            <span class="s1">outmess(</span><span class="s5">'analyzeline: Could not crack the use statement.</span><span class="s3">\n</span><span class="s5">'</span><span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">case </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'f2pyenhancements'</span><span class="s1">]:</span>
        <span class="s3">if </span><span class="s5">'f2pyenhancements' </span><span class="s3">not in </span><span class="s1">groupcache[groupcounter]:</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'f2pyenhancements'</span><span class="s1">] = {}</span>
        <span class="s1">d = groupcache[groupcounter][</span><span class="s5">'f2pyenhancements'</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">m.group(</span><span class="s5">'this'</span><span class="s1">) == </span><span class="s5">'usercode' </span><span class="s3">and </span><span class="s5">'usercode' </span><span class="s3">in </span><span class="s1">d:</span>
            <span class="s3">if </span><span class="s1">isinstance(d[</span><span class="s5">'usercode'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">str):</span>
                <span class="s1">d[</span><span class="s5">'usercode'</span><span class="s1">] = [d[</span><span class="s5">'usercode'</span><span class="s1">]]</span>
            <span class="s1">d[</span><span class="s5">'usercode'</span><span class="s1">].append(m.group(</span><span class="s5">'after'</span><span class="s1">))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">d[m.group(</span><span class="s5">'this'</span><span class="s1">)] = m.group(</span><span class="s5">'after'</span><span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">case == </span><span class="s5">'multiline'</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">previous_context </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">verbose:</span>
                <span class="s1">outmess(</span><span class="s5">'analyzeline: No context for multiline block.</span><span class="s3">\n</span><span class="s5">'</span><span class="s1">)</span>
            <span class="s3">return</span>
        <span class="s1">gc = groupcounter</span>
        <span class="s1">appendmultiline(groupcache[gc]</span><span class="s3">,</span>
                        <span class="s1">previous_context[:</span><span class="s4">2</span><span class="s1">]</span><span class="s3">,</span>
                        <span class="s1">m.group(</span><span class="s5">'this'</span><span class="s1">))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">verbose &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">print(m.groupdict())</span>
            <span class="s1">outmess(</span><span class="s5">'analyzeline: No code implemented for line.</span><span class="s3">\n</span><span class="s5">'</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">appendmultiline(group</span><span class="s3">, </span><span class="s1">context_name</span><span class="s3">, </span><span class="s1">ml):</span>
    <span class="s3">if </span><span class="s5">'f2pymultilines' </span><span class="s3">not in </span><span class="s1">group:</span>
        <span class="s1">group[</span><span class="s5">'f2pymultilines'</span><span class="s1">] = {}</span>
    <span class="s1">d = group[</span><span class="s5">'f2pymultilines'</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">context_name </span><span class="s3">not in </span><span class="s1">d:</span>
        <span class="s1">d[context_name] = []</span>
    <span class="s1">d[context_name].append(ml)</span>
    <span class="s3">return</span>


<span class="s3">def </span><span class="s1">cracktypespec0(typespec</span><span class="s3">, </span><span class="s1">ll):</span>
    <span class="s1">selector = </span><span class="s3">None</span>
    <span class="s1">attr = </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">re.match(</span><span class="s5">r'double\s*complex'</span><span class="s3">, </span><span class="s1">typespec</span><span class="s3">, </span><span class="s1">re.I):</span>
        <span class="s1">typespec = </span><span class="s5">'double complex'</span>
    <span class="s3">elif </span><span class="s1">re.match(</span><span class="s5">r'double\s*precision'</span><span class="s3">, </span><span class="s1">typespec</span><span class="s3">, </span><span class="s1">re.I):</span>
        <span class="s1">typespec = </span><span class="s5">'double precision'</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">typespec = typespec.strip().lower()</span>
    <span class="s1">m1 = selectpattern.match(markouterparen(ll))</span>
    <span class="s3">if not </span><span class="s1">m1:</span>
        <span class="s1">outmess(</span>
            <span class="s5">'cracktypespec0: no kind/char_selector pattern found for line.</span><span class="s3">\n</span><span class="s5">'</span><span class="s1">)</span>
        <span class="s3">return</span>
    <span class="s1">d = m1.groupdict()</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(d.keys()):</span>
        <span class="s1">d[k] = unmarkouterparen(d[k])</span>
    <span class="s3">if </span><span class="s1">typespec </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'complex'</span><span class="s3">, </span><span class="s5">'integer'</span><span class="s3">, </span><span class="s5">'logical'</span><span class="s3">, </span><span class="s5">'real'</span><span class="s3">, </span><span class="s5">'character'</span><span class="s3">, </span><span class="s5">'type'</span><span class="s1">]:</span>
        <span class="s1">selector = d[</span><span class="s5">'this'</span><span class="s1">]</span>
        <span class="s1">ll = d[</span><span class="s5">'after'</span><span class="s1">]</span>
    <span class="s1">i = ll.find(</span><span class="s5">'::'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">i &gt;= </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">attr = ll[:i].strip()</span>
        <span class="s1">ll = ll[i + </span><span class="s4">2</span><span class="s1">:]</span>
    <span class="s3">return </span><span class="s1">typespec</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">ll</span>
<span class="s0">#####</span>
<span class="s1">namepattern = re.compile(</span><span class="s5">r'\s*(?P&lt;name&gt;\b\w+\b)\s*(?P&lt;after&gt;.*)\s*\Z'</span><span class="s3">, </span><span class="s1">re.I)</span>
<span class="s1">kindselector = re.compile(</span>
    <span class="s5">r'\s*(\(\s*(kind\s*=)?\s*(?P&lt;kind&gt;.*)\s*\)|\*\s*(?P&lt;kind2&gt;.*?))\s*\Z'</span><span class="s3">, </span><span class="s1">re.I)</span>
<span class="s1">charselector = re.compile(</span>
    <span class="s5">r'\s*(\((?P&lt;lenkind&gt;.*)\)|\*\s*(?P&lt;charlen&gt;.*))\s*\Z'</span><span class="s3">, </span><span class="s1">re.I)</span>
<span class="s1">lenkindpattern = re.compile(</span>
    <span class="s5">r'\s*(kind\s*=\s*(?P&lt;kind&gt;.*?)\s*(@,@\s*len\s*=\s*(?P&lt;len&gt;.*)|)|(len\s*=\s*|)(?P&lt;len2&gt;.*?)\s*(@,@\s*(kind\s*=\s*|)(?P&lt;kind2&gt;.*)|))\s*\Z'</span><span class="s3">, </span><span class="s1">re.I)</span>
<span class="s1">lenarraypattern = re.compile(</span>
    <span class="s5">r'\s*(@\(@\s*(?!/)\s*(?P&lt;array&gt;.*?)\s*@\)@\s*\*\s*(?P&lt;len&gt;.*?)|(\*\s*(?P&lt;len2&gt;.*?)|)\s*(@\(@\s*(?!/)\s*(?P&lt;array2&gt;.*?)\s*@\)@|))\s*(=\s*(?P&lt;init&gt;.*?)|(@\(@|)/\s*(?P&lt;init2&gt;.*?)\s*/(@\)@|)|)\s*\Z'</span><span class="s3">, </span><span class="s1">re.I)</span>


<span class="s3">def </span><span class="s1">removespaces(expr):</span>
    <span class="s1">expr = expr.strip()</span>
    <span class="s3">if </span><span class="s1">len(expr) &lt;= </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">expr</span>
    <span class="s1">expr2 = expr[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">len(expr) - </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">(expr[i] == </span><span class="s5">' ' </span><span class="s3">and</span>
            <span class="s1">((expr[i + </span><span class="s4">1</span><span class="s1">] </span><span class="s3">in </span><span class="s5">&quot;()[]{}=+-/* &quot;</span><span class="s1">) </span><span class="s3">or</span>
                <span class="s1">(expr[i - </span><span class="s4">1</span><span class="s1">] </span><span class="s3">in </span><span class="s5">&quot;()[]{}=+-/* &quot;</span><span class="s1">))):</span>
            <span class="s3">continue</span>
        <span class="s1">expr2 = expr2 + expr[i]</span>
    <span class="s1">expr2 = expr2 + expr[-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s3">return </span><span class="s1">expr2</span>


<span class="s3">def </span><span class="s1">markinnerspaces(line):</span>
    <span class="s2">&quot;&quot;&quot; 
    The function replace all spaces in the input variable line which are  
    surrounded with quotation marks, with the triplet &quot;@_@&quot;. 
 
    For instance, for the input &quot;a 'b c'&quot; the function returns &quot;a 'b@_@c'&quot; 
 
    Parameters 
    ---------- 
    line : str 
 
    Returns 
    ------- 
    str 
 
    &quot;&quot;&quot;  </span>
    <span class="s1">fragment = </span><span class="s5">''</span>
    <span class="s1">inside = </span><span class="s3">False</span>
    <span class="s1">current_quote = </span><span class="s3">None</span>
    <span class="s1">escaped = </span><span class="s5">''</span>
    <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">line:</span>
        <span class="s3">if </span><span class="s1">escaped == </span><span class="s5">'</span><span class="s3">\\</span><span class="s5">' </span><span class="s3">and </span><span class="s1">c </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'</span><span class="s3">\\</span><span class="s5">'</span><span class="s3">, </span><span class="s5">'</span><span class="s3">\'</span><span class="s5">'</span><span class="s3">, </span><span class="s5">'&quot;'</span><span class="s1">]:</span>
            <span class="s1">fragment += c</span>
            <span class="s1">escaped = c</span>
            <span class="s3">continue</span>
        <span class="s3">if not </span><span class="s1">inside </span><span class="s3">and </span><span class="s1">c </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'</span><span class="s3">\'</span><span class="s5">'</span><span class="s3">, </span><span class="s5">'&quot;'</span><span class="s1">]:</span>
            <span class="s1">current_quote = c</span>
        <span class="s3">if </span><span class="s1">c == current_quote:</span>
            <span class="s1">inside = </span><span class="s3">not </span><span class="s1">inside</span>
        <span class="s3">elif </span><span class="s1">c == </span><span class="s5">' ' </span><span class="s3">and </span><span class="s1">inside:</span>
            <span class="s1">fragment += </span><span class="s5">'@_@'</span>
            <span class="s3">continue</span>
        <span class="s1">fragment += c</span>
        <span class="s1">escaped = c  </span><span class="s0"># reset to non-backslash</span>
    <span class="s3">return </span><span class="s1">fragment</span>


<span class="s3">def </span><span class="s1">updatevars(typespec</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">attrspec</span><span class="s3">, </span><span class="s1">entitydecl):</span>
    <span class="s3">global </span><span class="s1">groupcache</span><span class="s3">, </span><span class="s1">groupcounter</span>

    <span class="s1">last_name = </span><span class="s3">None</span>
    <span class="s1">kindselect</span><span class="s3">, </span><span class="s1">charselect</span><span class="s3">, </span><span class="s1">typename = cracktypespec(typespec</span><span class="s3">, </span><span class="s1">selector)</span>
    <span class="s3">if </span><span class="s1">attrspec:</span>
        <span class="s1">attrspec = [x.strip() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma(attrspec).split(</span><span class="s5">'@,@'</span><span class="s1">)]</span>
        <span class="s1">l = []</span>
        <span class="s1">c = re.compile(</span><span class="s5">r'(?P&lt;start&gt;[a-zA-Z]+)'</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">attrspec:</span>
            <span class="s3">if not </span><span class="s1">a:</span>
                <span class="s3">continue</span>
            <span class="s1">m = c.match(a)</span>
            <span class="s3">if </span><span class="s1">m:</span>
                <span class="s1">s = m.group(</span><span class="s5">'start'</span><span class="s1">).lower()</span>
                <span class="s1">a = s + a[len(s):]</span>
            <span class="s1">l.append(a)</span>
        <span class="s1">attrspec = l</span>
    <span class="s1">el = [x.strip() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma(entitydecl).split(</span><span class="s5">'@,@'</span><span class="s1">)]</span>
    <span class="s1">el1 = []</span>
    <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">el:</span>
        <span class="s3">for </span><span class="s1">e1 </span><span class="s3">in </span><span class="s1">[x.strip() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma(removespaces(markinnerspaces(e))</span><span class="s3">, </span><span class="s1">comma=</span><span class="s5">' '</span><span class="s1">).split(</span><span class="s5">'@ @'</span><span class="s1">)]:</span>
            <span class="s3">if </span><span class="s1">e1:</span>
                <span class="s1">el1.append(e1.replace(</span><span class="s5">'@_@'</span><span class="s3">, </span><span class="s5">' '</span><span class="s1">))</span>
    <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">el1:</span>
        <span class="s1">m = namepattern.match(e)</span>
        <span class="s3">if not </span><span class="s1">m:</span>
            <span class="s1">outmess(</span>
                <span class="s5">'updatevars: no name pattern found for entity=%s. Skipping.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (repr(e)))</span>
            <span class="s3">continue</span>
        <span class="s1">ename = rmbadname1(m.group(</span><span class="s5">'name'</span><span class="s1">))</span>
        <span class="s1">edecl = {}</span>
        <span class="s3">if </span><span class="s1">ename </span><span class="s3">in </span><span class="s1">groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">]:</span>
            <span class="s1">edecl = groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">][ename].copy()</span>
            <span class="s1">not_has_typespec = </span><span class="s5">'typespec' </span><span class="s3">not in </span><span class="s1">edecl</span>
            <span class="s3">if </span><span class="s1">not_has_typespec:</span>
                <span class="s1">edecl[</span><span class="s5">'typespec'</span><span class="s1">] = typespec</span>
            <span class="s3">elif </span><span class="s1">typespec </span><span class="s3">and </span><span class="s1">(</span><span class="s3">not </span><span class="s1">typespec == edecl[</span><span class="s5">'typespec'</span><span class="s1">]):</span>
                <span class="s1">outmess(</span><span class="s5">'updatevars: attempt to change the type of &quot;%s&quot; (&quot;%s&quot;) to &quot;%s&quot;. Ignoring.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (</span>
                    <span class="s1">ename</span><span class="s3">, </span><span class="s1">edecl[</span><span class="s5">'typespec'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">typespec))</span>
            <span class="s3">if </span><span class="s5">'kindselector' </span><span class="s3">not in </span><span class="s1">edecl:</span>
                <span class="s1">edecl[</span><span class="s5">'kindselector'</span><span class="s1">] = copy.copy(kindselect)</span>
            <span class="s3">elif </span><span class="s1">kindselect:</span>
                <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(kindselect.keys()):</span>
                    <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">edecl[</span><span class="s5">'kindselector'</span><span class="s1">] </span><span class="s3">and </span><span class="s1">(</span><span class="s3">not </span><span class="s1">kindselect[k] == edecl[</span><span class="s5">'kindselector'</span><span class="s1">][k]):</span>
                        <span class="s1">outmess(</span><span class="s5">'updatevars: attempt to change the kindselector &quot;%s&quot; of &quot;%s&quot; (&quot;%s&quot;) to &quot;%s&quot;. Ignoring.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (</span>
                            <span class="s1">k</span><span class="s3">, </span><span class="s1">ename</span><span class="s3">, </span><span class="s1">edecl[</span><span class="s5">'kindselector'</span><span class="s1">][k]</span><span class="s3">, </span><span class="s1">kindselect[k]))</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">edecl[</span><span class="s5">'kindselector'</span><span class="s1">][k] = copy.copy(kindselect[k])</span>
            <span class="s3">if </span><span class="s5">'charselector' </span><span class="s3">not in </span><span class="s1">edecl </span><span class="s3">and </span><span class="s1">charselect:</span>
                <span class="s3">if </span><span class="s1">not_has_typespec:</span>
                    <span class="s1">edecl[</span><span class="s5">'charselector'</span><span class="s1">] = charselect</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">errmess(</span><span class="s5">'updatevars:%s: attempt to change empty charselector to %r. Ignoring.</span><span class="s3">\n</span><span class="s5">'</span>
                            <span class="s1">% (ename</span><span class="s3">, </span><span class="s1">charselect))</span>
            <span class="s3">elif </span><span class="s1">charselect:</span>
                <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(charselect.keys()):</span>
                    <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">edecl[</span><span class="s5">'charselector'</span><span class="s1">] </span><span class="s3">and </span><span class="s1">(</span><span class="s3">not </span><span class="s1">charselect[k] == edecl[</span><span class="s5">'charselector'</span><span class="s1">][k]):</span>
                        <span class="s1">outmess(</span><span class="s5">'updatevars: attempt to change the charselector &quot;%s&quot; of &quot;%s&quot; (&quot;%s&quot;) to &quot;%s&quot;. Ignoring.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (</span>
                            <span class="s1">k</span><span class="s3">, </span><span class="s1">ename</span><span class="s3">, </span><span class="s1">edecl[</span><span class="s5">'charselector'</span><span class="s1">][k]</span><span class="s3">, </span><span class="s1">charselect[k]))</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">edecl[</span><span class="s5">'charselector'</span><span class="s1">][k] = copy.copy(charselect[k])</span>
            <span class="s3">if </span><span class="s5">'typename' </span><span class="s3">not in </span><span class="s1">edecl:</span>
                <span class="s1">edecl[</span><span class="s5">'typename'</span><span class="s1">] = typename</span>
            <span class="s3">elif </span><span class="s1">typename </span><span class="s3">and </span><span class="s1">(</span><span class="s3">not </span><span class="s1">edecl[</span><span class="s5">'typename'</span><span class="s1">] == typename):</span>
                <span class="s1">outmess(</span><span class="s5">'updatevars: attempt to change the typename of &quot;%s&quot; (&quot;%s&quot;) to &quot;%s&quot;. Ignoring.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (</span>
                    <span class="s1">ename</span><span class="s3">, </span><span class="s1">edecl[</span><span class="s5">'typename'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">typename))</span>
            <span class="s3">if </span><span class="s5">'attrspec' </span><span class="s3">not in </span><span class="s1">edecl:</span>
                <span class="s1">edecl[</span><span class="s5">'attrspec'</span><span class="s1">] = copy.copy(attrspec)</span>
            <span class="s3">elif </span><span class="s1">attrspec:</span>
                <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">attrspec:</span>
                    <span class="s3">if </span><span class="s1">a </span><span class="s3">not in </span><span class="s1">edecl[</span><span class="s5">'attrspec'</span><span class="s1">]:</span>
                        <span class="s1">edecl[</span><span class="s5">'attrspec'</span><span class="s1">].append(a)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">edecl[</span><span class="s5">'typespec'</span><span class="s1">] = copy.copy(typespec)</span>
            <span class="s1">edecl[</span><span class="s5">'kindselector'</span><span class="s1">] = copy.copy(kindselect)</span>
            <span class="s1">edecl[</span><span class="s5">'charselector'</span><span class="s1">] = copy.copy(charselect)</span>
            <span class="s1">edecl[</span><span class="s5">'typename'</span><span class="s1">] = typename</span>
            <span class="s1">edecl[</span><span class="s5">'attrspec'</span><span class="s1">] = copy.copy(attrspec)</span>
        <span class="s3">if </span><span class="s5">'external' </span><span class="s3">in </span><span class="s1">(edecl.get(</span><span class="s5">'attrspec'</span><span class="s1">) </span><span class="s3">or </span><span class="s1">[]) </span><span class="s3">and </span><span class="s1">e </span><span class="s3">in </span><span class="s1">groupcache[groupcounter][</span><span class="s5">'args'</span><span class="s1">]:</span>
            <span class="s3">if </span><span class="s5">'externals' </span><span class="s3">not in </span><span class="s1">groupcache[groupcounter]:</span>
                <span class="s1">groupcache[groupcounter][</span><span class="s5">'externals'</span><span class="s1">] = []</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'externals'</span><span class="s1">].append(e)</span>
        <span class="s3">if </span><span class="s1">m.group(</span><span class="s5">'after'</span><span class="s1">):</span>
            <span class="s1">m1 = lenarraypattern.match(markouterparen(m.group(</span><span class="s5">'after'</span><span class="s1">)))</span>
            <span class="s3">if </span><span class="s1">m1:</span>
                <span class="s1">d1 = m1.groupdict()</span>
                <span class="s3">for </span><span class="s1">lk </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'len'</span><span class="s3">, </span><span class="s5">'array'</span><span class="s3">, </span><span class="s5">'init'</span><span class="s1">]:</span>
                    <span class="s3">if </span><span class="s1">d1[lk + </span><span class="s5">'2'</span><span class="s1">] </span><span class="s3">is not None</span><span class="s1">:</span>
                        <span class="s1">d1[lk] = d1[lk + </span><span class="s5">'2'</span><span class="s1">]</span>
                        <span class="s3">del </span><span class="s1">d1[lk + </span><span class="s5">'2'</span><span class="s1">]</span>
                <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(d1.keys()):</span>
                    <span class="s3">if </span><span class="s1">d1[k] </span><span class="s3">is not None</span><span class="s1">:</span>
                        <span class="s1">d1[k] = unmarkouterparen(d1[k])</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s3">del </span><span class="s1">d1[k]</span>
                <span class="s3">if </span><span class="s5">'len' </span><span class="s3">in </span><span class="s1">d1 </span><span class="s3">and </span><span class="s5">'array' </span><span class="s3">in </span><span class="s1">d1:</span>
                    <span class="s3">if </span><span class="s1">d1[</span><span class="s5">'len'</span><span class="s1">] == </span><span class="s5">''</span><span class="s1">:</span>
                        <span class="s1">d1[</span><span class="s5">'len'</span><span class="s1">] = d1[</span><span class="s5">'array'</span><span class="s1">]</span>
                        <span class="s3">del </span><span class="s1">d1[</span><span class="s5">'array'</span><span class="s1">]</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">d1[</span><span class="s5">'array'</span><span class="s1">] = d1[</span><span class="s5">'array'</span><span class="s1">] + </span><span class="s5">',' </span><span class="s1">+ d1[</span><span class="s5">'len'</span><span class="s1">]</span>
                        <span class="s3">del </span><span class="s1">d1[</span><span class="s5">'len'</span><span class="s1">]</span>
                        <span class="s1">errmess(</span><span class="s5">'updatevars: &quot;%s %s&quot; is mapped to &quot;%s %s(%s)&quot;</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (</span>
                            <span class="s1">typespec</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">typespec</span><span class="s3">, </span><span class="s1">ename</span><span class="s3">, </span><span class="s1">d1[</span><span class="s5">'array'</span><span class="s1">]))</span>
                <span class="s3">if </span><span class="s5">'array' </span><span class="s3">in </span><span class="s1">d1:</span>
                    <span class="s1">dm = </span><span class="s5">'dimension(%s)' </span><span class="s1">% d1[</span><span class="s5">'array'</span><span class="s1">]</span>
                    <span class="s3">if </span><span class="s5">'attrspec' </span><span class="s3">not in </span><span class="s1">edecl </span><span class="s3">or </span><span class="s1">(</span><span class="s3">not </span><span class="s1">edecl[</span><span class="s5">'attrspec'</span><span class="s1">]):</span>
                        <span class="s1">edecl[</span><span class="s5">'attrspec'</span><span class="s1">] = [dm]</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">edecl[</span><span class="s5">'attrspec'</span><span class="s1">].append(dm)</span>
                        <span class="s3">for </span><span class="s1">dm1 </span><span class="s3">in </span><span class="s1">edecl[</span><span class="s5">'attrspec'</span><span class="s1">]:</span>
                            <span class="s3">if </span><span class="s1">dm1[:</span><span class="s4">9</span><span class="s1">] == </span><span class="s5">'dimension' </span><span class="s3">and </span><span class="s1">dm1 != dm:</span>
                                <span class="s3">del </span><span class="s1">edecl[</span><span class="s5">'attrspec'</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">]</span>
                                <span class="s1">errmess(</span><span class="s5">'updatevars:%s: attempt to change %r to %r. Ignoring.</span><span class="s3">\n</span><span class="s5">'</span>
                                        <span class="s1">% (ename</span><span class="s3">, </span><span class="s1">dm1</span><span class="s3">, </span><span class="s1">dm))</span>
                                <span class="s3">break</span>

                <span class="s3">if </span><span class="s5">'len' </span><span class="s3">in </span><span class="s1">d1:</span>
                    <span class="s3">if </span><span class="s1">typespec </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'complex'</span><span class="s3">, </span><span class="s5">'integer'</span><span class="s3">, </span><span class="s5">'logical'</span><span class="s3">, </span><span class="s5">'real'</span><span class="s1">]:</span>
                        <span class="s3">if </span><span class="s1">(</span><span class="s5">'kindselector' </span><span class="s3">not in </span><span class="s1">edecl) </span><span class="s3">or </span><span class="s1">(</span><span class="s3">not </span><span class="s1">edecl[</span><span class="s5">'kindselector'</span><span class="s1">]):</span>
                            <span class="s1">edecl[</span><span class="s5">'kindselector'</span><span class="s1">] = {}</span>
                        <span class="s1">edecl[</span><span class="s5">'kindselector'</span><span class="s1">][</span><span class="s5">'*'</span><span class="s1">] = d1[</span><span class="s5">'len'</span><span class="s1">]</span>
                    <span class="s3">elif </span><span class="s1">typespec == </span><span class="s5">'character'</span><span class="s1">:</span>
                        <span class="s3">if </span><span class="s1">(</span><span class="s5">'charselector' </span><span class="s3">not in </span><span class="s1">edecl) </span><span class="s3">or </span><span class="s1">(</span><span class="s3">not </span><span class="s1">edecl[</span><span class="s5">'charselector'</span><span class="s1">]):</span>
                            <span class="s1">edecl[</span><span class="s5">'charselector'</span><span class="s1">] = {}</span>
                        <span class="s3">if </span><span class="s5">'len' </span><span class="s3">in </span><span class="s1">edecl[</span><span class="s5">'charselector'</span><span class="s1">]:</span>
                            <span class="s3">del </span><span class="s1">edecl[</span><span class="s5">'charselector'</span><span class="s1">][</span><span class="s5">'len'</span><span class="s1">]</span>
                        <span class="s1">edecl[</span><span class="s5">'charselector'</span><span class="s1">][</span><span class="s5">'*'</span><span class="s1">] = d1[</span><span class="s5">'len'</span><span class="s1">]</span>
                <span class="s3">if </span><span class="s5">'init' </span><span class="s3">in </span><span class="s1">d1:</span>
                    <span class="s3">if </span><span class="s5">'=' </span><span class="s3">in </span><span class="s1">edecl </span><span class="s3">and </span><span class="s1">(</span><span class="s3">not </span><span class="s1">edecl[</span><span class="s5">'='</span><span class="s1">] == d1[</span><span class="s5">'init'</span><span class="s1">]):</span>
                        <span class="s1">outmess(</span><span class="s5">'updatevars: attempt to change the init expression of &quot;%s&quot; (&quot;%s&quot;) to &quot;%s&quot;. Ignoring.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (</span>
                            <span class="s1">ename</span><span class="s3">, </span><span class="s1">edecl[</span><span class="s5">'='</span><span class="s1">]</span><span class="s3">, </span><span class="s1">d1[</span><span class="s5">'init'</span><span class="s1">]))</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">edecl[</span><span class="s5">'='</span><span class="s1">] = d1[</span><span class="s5">'init'</span><span class="s1">]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">outmess(</span><span class="s5">'updatevars: could not crack entity declaration &quot;%s&quot;. Ignoring.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (</span>
                    <span class="s1">ename + m.group(</span><span class="s5">'after'</span><span class="s1">)))</span>
        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(edecl.keys()):</span>
            <span class="s3">if not </span><span class="s1">edecl[k]:</span>
                <span class="s3">del </span><span class="s1">edecl[k]</span>
        <span class="s1">groupcache[groupcounter][</span><span class="s5">'vars'</span><span class="s1">][ename] = edecl</span>
        <span class="s3">if </span><span class="s5">'varnames' </span><span class="s3">in </span><span class="s1">groupcache[groupcounter]:</span>
            <span class="s1">groupcache[groupcounter][</span><span class="s5">'varnames'</span><span class="s1">].append(ename)</span>
        <span class="s1">last_name = ename</span>
    <span class="s3">return </span><span class="s1">last_name</span>


<span class="s3">def </span><span class="s1">cracktypespec(typespec</span><span class="s3">, </span><span class="s1">selector):</span>
    <span class="s1">kindselect = </span><span class="s3">None</span>
    <span class="s1">charselect = </span><span class="s3">None</span>
    <span class="s1">typename = </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">selector:</span>
        <span class="s3">if </span><span class="s1">typespec </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'complex'</span><span class="s3">, </span><span class="s5">'integer'</span><span class="s3">, </span><span class="s5">'logical'</span><span class="s3">, </span><span class="s5">'real'</span><span class="s1">]:</span>
            <span class="s1">kindselect = kindselector.match(selector)</span>
            <span class="s3">if not </span><span class="s1">kindselect:</span>
                <span class="s1">outmess(</span>
                    <span class="s5">'cracktypespec: no kindselector pattern found for %s</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (repr(selector)))</span>
                <span class="s3">return</span>
            <span class="s1">kindselect = kindselect.groupdict()</span>
            <span class="s1">kindselect[</span><span class="s5">'*'</span><span class="s1">] = kindselect[</span><span class="s5">'kind2'</span><span class="s1">]</span>
            <span class="s3">del </span><span class="s1">kindselect[</span><span class="s5">'kind2'</span><span class="s1">]</span>
            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(kindselect.keys()):</span>
                <span class="s3">if not </span><span class="s1">kindselect[k]:</span>
                    <span class="s3">del </span><span class="s1">kindselect[k]</span>
            <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">i </span><span class="s3">in </span><span class="s1">list(kindselect.items()):</span>
                <span class="s1">kindselect[k] = rmbadname1(i)</span>
        <span class="s3">elif </span><span class="s1">typespec == </span><span class="s5">'character'</span><span class="s1">:</span>
            <span class="s1">charselect = charselector.match(selector)</span>
            <span class="s3">if not </span><span class="s1">charselect:</span>
                <span class="s1">outmess(</span>
                    <span class="s5">'cracktypespec: no charselector pattern found for %s</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (repr(selector)))</span>
                <span class="s3">return</span>
            <span class="s1">charselect = charselect.groupdict()</span>
            <span class="s1">charselect[</span><span class="s5">'*'</span><span class="s1">] = charselect[</span><span class="s5">'charlen'</span><span class="s1">]</span>
            <span class="s3">del </span><span class="s1">charselect[</span><span class="s5">'charlen'</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">charselect[</span><span class="s5">'lenkind'</span><span class="s1">]:</span>
                <span class="s1">lenkind = lenkindpattern.match(</span>
                    <span class="s1">markoutercomma(charselect[</span><span class="s5">'lenkind'</span><span class="s1">]))</span>
                <span class="s1">lenkind = lenkind.groupdict()</span>
                <span class="s3">for </span><span class="s1">lk </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'len'</span><span class="s3">, </span><span class="s5">'kind'</span><span class="s1">]:</span>
                    <span class="s3">if </span><span class="s1">lenkind[lk + </span><span class="s5">'2'</span><span class="s1">]:</span>
                        <span class="s1">lenkind[lk] = lenkind[lk + </span><span class="s5">'2'</span><span class="s1">]</span>
                    <span class="s1">charselect[lk] = lenkind[lk]</span>
                    <span class="s3">del </span><span class="s1">lenkind[lk + </span><span class="s5">'2'</span><span class="s1">]</span>
            <span class="s3">del </span><span class="s1">charselect[</span><span class="s5">'lenkind'</span><span class="s1">]</span>
            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(charselect.keys()):</span>
                <span class="s3">if not </span><span class="s1">charselect[k]:</span>
                    <span class="s3">del </span><span class="s1">charselect[k]</span>
            <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">i </span><span class="s3">in </span><span class="s1">list(charselect.items()):</span>
                <span class="s1">charselect[k] = rmbadname1(i)</span>
        <span class="s3">elif </span><span class="s1">typespec == </span><span class="s5">'type'</span><span class="s1">:</span>
            <span class="s1">typename = re.match(</span><span class="s5">r'\s*\(\s*(?P&lt;name&gt;\w+)\s*\)'</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">re.I)</span>
            <span class="s3">if </span><span class="s1">typename:</span>
                <span class="s1">typename = typename.group(</span><span class="s5">'name'</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">outmess(</span><span class="s5">'cracktypespec: no typename found in %s</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">%</span>
                        <span class="s1">(repr(typespec + selector)))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">outmess(</span><span class="s5">'cracktypespec: no selector used for %s</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">%</span>
                    <span class="s1">(repr(selector)))</span>
    <span class="s3">return </span><span class="s1">kindselect</span><span class="s3">, </span><span class="s1">charselect</span><span class="s3">, </span><span class="s1">typename</span>
<span class="s0">######</span>


<span class="s3">def </span><span class="s1">setattrspec(decl</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">force=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s3">if not </span><span class="s1">decl:</span>
        <span class="s1">decl = {}</span>
    <span class="s3">if not </span><span class="s1">attr:</span>
        <span class="s3">return </span><span class="s1">decl</span>
    <span class="s3">if </span><span class="s5">'attrspec' </span><span class="s3">not in </span><span class="s1">decl:</span>
        <span class="s1">decl[</span><span class="s5">'attrspec'</span><span class="s1">] = [attr]</span>
        <span class="s3">return </span><span class="s1">decl</span>
    <span class="s3">if </span><span class="s1">force:</span>
        <span class="s1">decl[</span><span class="s5">'attrspec'</span><span class="s1">].append(attr)</span>
    <span class="s3">if </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">decl[</span><span class="s5">'attrspec'</span><span class="s1">]:</span>
        <span class="s3">return </span><span class="s1">decl</span>
    <span class="s3">if </span><span class="s1">attr == </span><span class="s5">'static' </span><span class="s3">and </span><span class="s5">'automatic' </span><span class="s3">not in </span><span class="s1">decl[</span><span class="s5">'attrspec'</span><span class="s1">]:</span>
        <span class="s1">decl[</span><span class="s5">'attrspec'</span><span class="s1">].append(attr)</span>
    <span class="s3">elif </span><span class="s1">attr == </span><span class="s5">'automatic' </span><span class="s3">and </span><span class="s5">'static' </span><span class="s3">not in </span><span class="s1">decl[</span><span class="s5">'attrspec'</span><span class="s1">]:</span>
        <span class="s1">decl[</span><span class="s5">'attrspec'</span><span class="s1">].append(attr)</span>
    <span class="s3">elif </span><span class="s1">attr == </span><span class="s5">'public'</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s5">'private' </span><span class="s3">not in </span><span class="s1">decl[</span><span class="s5">'attrspec'</span><span class="s1">]:</span>
            <span class="s1">decl[</span><span class="s5">'attrspec'</span><span class="s1">].append(attr)</span>
    <span class="s3">elif </span><span class="s1">attr == </span><span class="s5">'private'</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s5">'public' </span><span class="s3">not in </span><span class="s1">decl[</span><span class="s5">'attrspec'</span><span class="s1">]:</span>
            <span class="s1">decl[</span><span class="s5">'attrspec'</span><span class="s1">].append(attr)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">decl[</span><span class="s5">'attrspec'</span><span class="s1">].append(attr)</span>
    <span class="s3">return </span><span class="s1">decl</span>


<span class="s3">def </span><span class="s1">setkindselector(decl</span><span class="s3">, </span><span class="s1">sel</span><span class="s3">, </span><span class="s1">force=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s3">if not </span><span class="s1">decl:</span>
        <span class="s1">decl = {}</span>
    <span class="s3">if not </span><span class="s1">sel:</span>
        <span class="s3">return </span><span class="s1">decl</span>
    <span class="s3">if </span><span class="s5">'kindselector' </span><span class="s3">not in </span><span class="s1">decl:</span>
        <span class="s1">decl[</span><span class="s5">'kindselector'</span><span class="s1">] = sel</span>
        <span class="s3">return </span><span class="s1">decl</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(sel.keys()):</span>
        <span class="s3">if </span><span class="s1">force </span><span class="s3">or </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">decl[</span><span class="s5">'kindselector'</span><span class="s1">]:</span>
            <span class="s1">decl[</span><span class="s5">'kindselector'</span><span class="s1">][k] = sel[k]</span>
    <span class="s3">return </span><span class="s1">decl</span>


<span class="s3">def </span><span class="s1">setcharselector(decl</span><span class="s3">, </span><span class="s1">sel</span><span class="s3">, </span><span class="s1">force=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s3">if not </span><span class="s1">decl:</span>
        <span class="s1">decl = {}</span>
    <span class="s3">if not </span><span class="s1">sel:</span>
        <span class="s3">return </span><span class="s1">decl</span>
    <span class="s3">if </span><span class="s5">'charselector' </span><span class="s3">not in </span><span class="s1">decl:</span>
        <span class="s1">decl[</span><span class="s5">'charselector'</span><span class="s1">] = sel</span>
        <span class="s3">return </span><span class="s1">decl</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(sel.keys()):</span>
        <span class="s3">if </span><span class="s1">force </span><span class="s3">or </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">decl[</span><span class="s5">'charselector'</span><span class="s1">]:</span>
            <span class="s1">decl[</span><span class="s5">'charselector'</span><span class="s1">][k] = sel[k]</span>
    <span class="s3">return </span><span class="s1">decl</span>


<span class="s3">def </span><span class="s1">getblockname(block</span><span class="s3">, </span><span class="s1">unknown=</span><span class="s5">'unknown'</span><span class="s1">):</span>
    <span class="s3">if </span><span class="s5">'name' </span><span class="s3">in </span><span class="s1">block:</span>
        <span class="s3">return </span><span class="s1">block[</span><span class="s5">'name'</span><span class="s1">]</span>
    <span class="s3">return </span><span class="s1">unknown</span>

<span class="s0"># post processing</span>


<span class="s3">def </span><span class="s1">setmesstext(block):</span>
    <span class="s3">global </span><span class="s1">filepositiontext</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">filepositiontext = </span><span class="s5">'In: %s:%s</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (block[</span><span class="s5">'from'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">block[</span><span class="s5">'name'</span><span class="s1">])</span>
    <span class="s3">except </span><span class="s1">Exception:</span>
        <span class="s3">pass</span>


<span class="s3">def </span><span class="s1">get_usedict(block):</span>
    <span class="s1">usedict = {}</span>
    <span class="s3">if </span><span class="s5">'parent_block' </span><span class="s3">in </span><span class="s1">block:</span>
        <span class="s1">usedict = get_usedict(block[</span><span class="s5">'parent_block'</span><span class="s1">])</span>
    <span class="s3">if </span><span class="s5">'use' </span><span class="s3">in </span><span class="s1">block:</span>
        <span class="s1">usedict.update(block[</span><span class="s5">'use'</span><span class="s1">])</span>
    <span class="s3">return </span><span class="s1">usedict</span>


<span class="s3">def </span><span class="s1">get_useparameters(block</span><span class="s3">, </span><span class="s1">param_map=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">global </span><span class="s1">f90modulevars</span>

    <span class="s3">if </span><span class="s1">param_map </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">param_map = {}</span>
    <span class="s1">usedict = get_usedict(block)</span>
    <span class="s3">if not </span><span class="s1">usedict:</span>
        <span class="s3">return </span><span class="s1">param_map</span>
    <span class="s3">for </span><span class="s1">usename</span><span class="s3">, </span><span class="s1">mapping </span><span class="s3">in </span><span class="s1">list(usedict.items()):</span>
        <span class="s1">usename = usename.lower()</span>
        <span class="s3">if </span><span class="s1">usename </span><span class="s3">not in </span><span class="s1">f90modulevars:</span>
            <span class="s1">outmess(</span><span class="s5">'get_useparameters: no module %s info used by %s</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">%</span>
                    <span class="s1">(usename</span><span class="s3">, </span><span class="s1">block.get(</span><span class="s5">'name'</span><span class="s1">)))</span>
            <span class="s3">continue</span>
        <span class="s1">mvars = f90modulevars[usename]</span>
        <span class="s1">params = get_parameters(mvars)</span>
        <span class="s3">if not </span><span class="s1">params:</span>
            <span class="s3">continue</span>
        <span class="s0"># XXX: apply mapping</span>
        <span class="s3">if </span><span class="s1">mapping:</span>
            <span class="s1">errmess(</span><span class="s5">'get_useparameters: mapping for %s not impl.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (mapping))</span>
        <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">list(params.items()):</span>
            <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">param_map:</span>
                <span class="s1">outmess(</span><span class="s5">'get_useparameters: overriding parameter %s with'</span>
                        <span class="s5">' value from module %s</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (repr(k)</span><span class="s3">, </span><span class="s1">repr(usename)))</span>
            <span class="s1">param_map[k] = v</span>

    <span class="s3">return </span><span class="s1">param_map</span>


<span class="s3">def </span><span class="s1">postcrack2(block</span><span class="s3">, </span><span class="s1">tab=</span><span class="s5">''</span><span class="s3">, </span><span class="s1">param_map=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">global </span><span class="s1">f90modulevars</span>

    <span class="s3">if not </span><span class="s1">f90modulevars:</span>
        <span class="s3">return </span><span class="s1">block</span>
    <span class="s3">if </span><span class="s1">isinstance(block</span><span class="s3">, </span><span class="s1">list):</span>
        <span class="s1">ret = [postcrack2(g</span><span class="s3">, </span><span class="s1">tab=tab + </span><span class="s5">'</span><span class="s3">\t</span><span class="s5">'</span><span class="s3">, </span><span class="s1">param_map=param_map)</span>
               <span class="s3">for </span><span class="s1">g </span><span class="s3">in </span><span class="s1">block]</span>
        <span class="s3">return </span><span class="s1">ret</span>
    <span class="s1">setmesstext(block)</span>
    <span class="s1">outmess(</span><span class="s5">'%sBlock: %s</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (tab</span><span class="s3">, </span><span class="s1">block[</span><span class="s5">'name'</span><span class="s1">])</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">param_map </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">param_map = get_useparameters(block)</span>

    <span class="s3">if </span><span class="s1">param_map </span><span class="s3">is not None and </span><span class="s5">'vars' </span><span class="s3">in </span><span class="s1">block:</span>
        <span class="s1">vars = block[</span><span class="s5">'vars'</span><span class="s1">]</span>
        <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">list(vars.keys()):</span>
            <span class="s1">var = vars[n]</span>
            <span class="s3">if </span><span class="s5">'kindselector' </span><span class="s3">in </span><span class="s1">var:</span>
                <span class="s1">kind = var[</span><span class="s5">'kindselector'</span><span class="s1">]</span>
                <span class="s3">if </span><span class="s5">'kind' </span><span class="s3">in </span><span class="s1">kind:</span>
                    <span class="s1">val = kind[</span><span class="s5">'kind'</span><span class="s1">]</span>
                    <span class="s3">if </span><span class="s1">val </span><span class="s3">in </span><span class="s1">param_map:</span>
                        <span class="s1">kind[</span><span class="s5">'kind'</span><span class="s1">] = param_map[val]</span>
    <span class="s1">new_body = [postcrack2(b</span><span class="s3">, </span><span class="s1">tab=tab + </span><span class="s5">'</span><span class="s3">\t</span><span class="s5">'</span><span class="s3">, </span><span class="s1">param_map=param_map)</span>
                <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'body'</span><span class="s1">]]</span>
    <span class="s1">block[</span><span class="s5">'body'</span><span class="s1">] = new_body</span>

    <span class="s3">return </span><span class="s1">block</span>


<span class="s3">def </span><span class="s1">postcrack(block</span><span class="s3">, </span><span class="s1">args=</span><span class="s3">None, </span><span class="s1">tab=</span><span class="s5">''</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    TODO: 
          function return values 
          determine expression types if in argument list 
    &quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">usermodules</span><span class="s3">, </span><span class="s1">onlyfunctions</span>

    <span class="s3">if </span><span class="s1">isinstance(block</span><span class="s3">, </span><span class="s1">list):</span>
        <span class="s1">gret = []</span>
        <span class="s1">uret = []</span>
        <span class="s3">for </span><span class="s1">g </span><span class="s3">in </span><span class="s1">block:</span>
            <span class="s1">setmesstext(g)</span>
            <span class="s1">g = postcrack(g</span><span class="s3">, </span><span class="s1">tab=tab + </span><span class="s5">'</span><span class="s3">\t</span><span class="s5">'</span><span class="s1">)</span>
            <span class="s0"># sort user routines to appear first</span>
            <span class="s3">if </span><span class="s5">'name' </span><span class="s3">in </span><span class="s1">g </span><span class="s3">and </span><span class="s5">'__user__' </span><span class="s3">in </span><span class="s1">g[</span><span class="s5">'name'</span><span class="s1">]:</span>
                <span class="s1">uret.append(g)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">gret.append(g)</span>
        <span class="s3">return </span><span class="s1">uret + gret</span>
    <span class="s1">setmesstext(block)</span>
    <span class="s3">if not </span><span class="s1">isinstance(block</span><span class="s3">, </span><span class="s1">dict) </span><span class="s3">and </span><span class="s5">'block' </span><span class="s3">not in </span><span class="s1">block:</span>
        <span class="s3">raise </span><span class="s1">Exception(</span><span class="s5">'postcrack: Expected block dictionary instead of ' </span><span class="s1">+</span>
                        <span class="s1">str(block))</span>
    <span class="s3">if </span><span class="s5">'name' </span><span class="s3">in </span><span class="s1">block </span><span class="s3">and not </span><span class="s1">block[</span><span class="s5">'name'</span><span class="s1">] == </span><span class="s5">'unknown_interface'</span><span class="s1">:</span>
        <span class="s1">outmess(</span><span class="s5">'%sBlock: %s</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (tab</span><span class="s3">, </span><span class="s1">block[</span><span class="s5">'name'</span><span class="s1">])</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">block = analyzeargs(block)</span>
    <span class="s1">block = analyzecommon(block)</span>
    <span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">] = analyzevars(block)</span>
    <span class="s1">block[</span><span class="s5">'sortvars'</span><span class="s1">] = sortvarnames(block[</span><span class="s5">'vars'</span><span class="s1">])</span>
    <span class="s3">if </span><span class="s5">'args' </span><span class="s3">in </span><span class="s1">block </span><span class="s3">and </span><span class="s1">block[</span><span class="s5">'args'</span><span class="s1">]:</span>
        <span class="s1">args = block[</span><span class="s5">'args'</span><span class="s1">]</span>
    <span class="s1">block[</span><span class="s5">'body'</span><span class="s1">] = analyzebody(block</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">tab=tab)</span>

    <span class="s1">userisdefined = []</span>
    <span class="s3">if </span><span class="s5">'use' </span><span class="s3">in </span><span class="s1">block:</span>
        <span class="s1">useblock = block[</span><span class="s5">'use'</span><span class="s1">]</span>
        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(useblock.keys()):</span>
            <span class="s3">if </span><span class="s5">'__user__' </span><span class="s3">in </span><span class="s1">k:</span>
                <span class="s1">userisdefined.append(k)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">useblock = {}</span>
    <span class="s1">name = </span><span class="s5">''</span>
    <span class="s3">if </span><span class="s5">'name' </span><span class="s3">in </span><span class="s1">block:</span>
        <span class="s1">name = block[</span><span class="s5">'name'</span><span class="s1">]</span>
    <span class="s0"># and not userisdefined: # Build a __user__ module</span>
    <span class="s3">if </span><span class="s5">'externals' </span><span class="s3">in </span><span class="s1">block </span><span class="s3">and </span><span class="s1">block[</span><span class="s5">'externals'</span><span class="s1">]:</span>
        <span class="s1">interfaced = []</span>
        <span class="s3">if </span><span class="s5">'interfaced' </span><span class="s3">in </span><span class="s1">block:</span>
            <span class="s1">interfaced = block[</span><span class="s5">'interfaced'</span><span class="s1">]</span>
        <span class="s1">mvars = copy.copy(block[</span><span class="s5">'vars'</span><span class="s1">])</span>
        <span class="s3">if </span><span class="s1">name:</span>
            <span class="s1">mname = name + </span><span class="s5">'__user__routines'</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">mname = </span><span class="s5">'unknown__user__routines'</span>
        <span class="s3">if </span><span class="s1">mname </span><span class="s3">in </span><span class="s1">userisdefined:</span>
            <span class="s1">i = </span><span class="s4">1</span>
            <span class="s3">while </span><span class="s5">'%s_%i' </span><span class="s1">% (mname</span><span class="s3">, </span><span class="s1">i) </span><span class="s3">in </span><span class="s1">userisdefined:</span>
                <span class="s1">i = i + </span><span class="s4">1</span>
            <span class="s1">mname = </span><span class="s5">'%s_%i' </span><span class="s1">% (mname</span><span class="s3">, </span><span class="s1">i)</span>
        <span class="s1">interface = {</span><span class="s5">'block'</span><span class="s1">: </span><span class="s5">'interface'</span><span class="s3">, </span><span class="s5">'body'</span><span class="s1">: []</span><span class="s3">,</span>
                     <span class="s5">'vars'</span><span class="s1">: {}</span><span class="s3">, </span><span class="s5">'name'</span><span class="s1">: name + </span><span class="s5">'_user_interface'</span><span class="s1">}</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'externals'</span><span class="s1">]:</span>
            <span class="s3">if </span><span class="s1">e </span><span class="s3">in </span><span class="s1">interfaced:</span>
                <span class="s1">edef = []</span>
                <span class="s1">j = -</span><span class="s4">1</span>
                <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'body'</span><span class="s1">]:</span>
                    <span class="s1">j = j + </span><span class="s4">1</span>
                    <span class="s3">if </span><span class="s1">b[</span><span class="s5">'block'</span><span class="s1">] == </span><span class="s5">'interface'</span><span class="s1">:</span>
                        <span class="s1">i = -</span><span class="s4">1</span>
                        <span class="s3">for </span><span class="s1">bb </span><span class="s3">in </span><span class="s1">b[</span><span class="s5">'body'</span><span class="s1">]:</span>
                            <span class="s1">i = i + </span><span class="s4">1</span>
                            <span class="s3">if </span><span class="s5">'name' </span><span class="s3">in </span><span class="s1">bb </span><span class="s3">and </span><span class="s1">bb[</span><span class="s5">'name'</span><span class="s1">] == e:</span>
                                <span class="s1">edef = copy.copy(bb)</span>
                                <span class="s3">del </span><span class="s1">b[</span><span class="s5">'body'</span><span class="s1">][i]</span>
                                <span class="s3">break</span>
                        <span class="s3">if </span><span class="s1">edef:</span>
                            <span class="s3">if not </span><span class="s1">b[</span><span class="s5">'body'</span><span class="s1">]:</span>
                                <span class="s3">del </span><span class="s1">block[</span><span class="s5">'body'</span><span class="s1">][j]</span>
                            <span class="s3">del </span><span class="s1">interfaced[interfaced.index(e)]</span>
                            <span class="s3">break</span>
                <span class="s1">interface[</span><span class="s5">'body'</span><span class="s1">].append(edef)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">e </span><span class="s3">in </span><span class="s1">mvars </span><span class="s3">and not </span><span class="s1">isexternal(mvars[e]):</span>
                    <span class="s1">interface[</span><span class="s5">'vars'</span><span class="s1">][e] = mvars[e]</span>
        <span class="s3">if </span><span class="s1">interface[</span><span class="s5">'vars'</span><span class="s1">] </span><span class="s3">or </span><span class="s1">interface[</span><span class="s5">'body'</span><span class="s1">]:</span>
            <span class="s1">block[</span><span class="s5">'interfaced'</span><span class="s1">] = interfaced</span>
            <span class="s1">mblock = {</span><span class="s5">'block'</span><span class="s1">: </span><span class="s5">'python module'</span><span class="s3">, </span><span class="s5">'body'</span><span class="s1">: [</span>
                <span class="s1">interface]</span><span class="s3">, </span><span class="s5">'vars'</span><span class="s1">: {}</span><span class="s3">, </span><span class="s5">'name'</span><span class="s1">: mname</span><span class="s3">, </span><span class="s5">'interfaced'</span><span class="s1">: block[</span><span class="s5">'externals'</span><span class="s1">]}</span>
            <span class="s1">useblock[mname] = {}</span>
            <span class="s1">usermodules.append(mblock)</span>
    <span class="s3">if </span><span class="s1">useblock:</span>
        <span class="s1">block[</span><span class="s5">'use'</span><span class="s1">] = useblock</span>
    <span class="s3">return </span><span class="s1">block</span>


<span class="s3">def </span><span class="s1">sortvarnames(vars):</span>
    <span class="s1">indep = []</span>
    <span class="s1">dep = []</span>
    <span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">list(vars.keys()):</span>
        <span class="s3">if </span><span class="s5">'depend' </span><span class="s3">in </span><span class="s1">vars[v] </span><span class="s3">and </span><span class="s1">vars[v][</span><span class="s5">'depend'</span><span class="s1">]:</span>
            <span class="s1">dep.append(v)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">indep.append(v)</span>
    <span class="s1">n = len(dep)</span>
    <span class="s1">i = </span><span class="s4">0</span>
    <span class="s3">while </span><span class="s1">dep:  </span><span class="s0"># XXX: How to catch dependence cycles correctly?</span>
        <span class="s1">v = dep[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">fl = </span><span class="s4">0</span>
        <span class="s3">for </span><span class="s1">w </span><span class="s3">in </span><span class="s1">dep[</span><span class="s4">1</span><span class="s1">:]:</span>
            <span class="s3">if </span><span class="s1">w </span><span class="s3">in </span><span class="s1">vars[v][</span><span class="s5">'depend'</span><span class="s1">]:</span>
                <span class="s1">fl = </span><span class="s4">1</span>
                <span class="s3">break</span>
        <span class="s3">if </span><span class="s1">fl:</span>
            <span class="s1">dep = dep[</span><span class="s4">1</span><span class="s1">:] + [v]</span>
            <span class="s1">i = i + </span><span class="s4">1</span>
            <span class="s3">if </span><span class="s1">i &gt; n:</span>
                <span class="s1">errmess(</span><span class="s5">'sortvarnames: failed to compute dependencies because'</span>
                        <span class="s5">' of cyclic dependencies between '</span>
                        <span class="s1">+ </span><span class="s5">', '</span><span class="s1">.join(dep) + </span><span class="s5">'</span><span class="s3">\n</span><span class="s5">'</span><span class="s1">)</span>
                <span class="s1">indep = indep + dep</span>
                <span class="s3">break</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">indep.append(v)</span>
            <span class="s1">dep = dep[</span><span class="s4">1</span><span class="s1">:]</span>
            <span class="s1">n = len(dep)</span>
            <span class="s1">i = </span><span class="s4">0</span>
    <span class="s3">return </span><span class="s1">indep</span>


<span class="s3">def </span><span class="s1">analyzecommon(block):</span>
    <span class="s3">if not </span><span class="s1">hascommon(block):</span>
        <span class="s3">return </span><span class="s1">block</span>
    <span class="s1">commonvars = []</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(block[</span><span class="s5">'common'</span><span class="s1">].keys()):</span>
        <span class="s1">comvars = []</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'common'</span><span class="s1">][k]:</span>
            <span class="s1">m = re.match(</span>
                <span class="s5">r'\A\s*\b(?P&lt;name&gt;.*?)\b\s*(\((?P&lt;dims&gt;.*?)\)|)\s*\Z'</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">re.I)</span>
            <span class="s3">if </span><span class="s1">m:</span>
                <span class="s1">dims = []</span>
                <span class="s3">if </span><span class="s1">m.group(</span><span class="s5">'dims'</span><span class="s1">):</span>
                    <span class="s1">dims = [x.strip()</span>
                            <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma(m.group(</span><span class="s5">'dims'</span><span class="s1">)).split(</span><span class="s5">'@,@'</span><span class="s1">)]</span>
                <span class="s1">n = rmbadname1(m.group(</span><span class="s5">'name'</span><span class="s1">).strip())</span>
                <span class="s3">if </span><span class="s1">n </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">]:</span>
                    <span class="s3">if </span><span class="s5">'attrspec' </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">][n]:</span>
                        <span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">][n][</span><span class="s5">'attrspec'</span><span class="s1">].append(</span>
                            <span class="s5">'dimension(%s)' </span><span class="s1">% (</span><span class="s5">','</span><span class="s1">.join(dims)))</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">][n][</span><span class="s5">'attrspec'</span><span class="s1">] = [</span>
                            <span class="s5">'dimension(%s)' </span><span class="s1">% (</span><span class="s5">','</span><span class="s1">.join(dims))]</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">dims:</span>
                        <span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">][n] = {</span>
                            <span class="s5">'attrspec'</span><span class="s1">: [</span><span class="s5">'dimension(%s)' </span><span class="s1">% (</span><span class="s5">','</span><span class="s1">.join(dims))]}</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">][n] = {}</span>
                <span class="s3">if </span><span class="s1">n </span><span class="s3">not in </span><span class="s1">commonvars:</span>
                    <span class="s1">commonvars.append(n)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">n = e</span>
                <span class="s1">errmess(</span>
                    <span class="s5">'analyzecommon: failed to extract &quot;&lt;name&gt;[(&lt;dims&gt;)]&quot; from &quot;%s&quot; in common /%s/.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (e</span><span class="s3">, </span><span class="s1">k))</span>
            <span class="s1">comvars.append(n)</span>
        <span class="s1">block[</span><span class="s5">'common'</span><span class="s1">][k] = comvars</span>
    <span class="s3">if </span><span class="s5">'commonvars' </span><span class="s3">not in </span><span class="s1">block:</span>
        <span class="s1">block[</span><span class="s5">'commonvars'</span><span class="s1">] = commonvars</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">block[</span><span class="s5">'commonvars'</span><span class="s1">] = block[</span><span class="s5">'commonvars'</span><span class="s1">] + commonvars</span>
    <span class="s3">return </span><span class="s1">block</span>


<span class="s3">def </span><span class="s1">analyzebody(block</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">tab=</span><span class="s5">''</span><span class="s1">):</span>
    <span class="s3">global </span><span class="s1">usermodules</span><span class="s3">, </span><span class="s1">skipfuncs</span><span class="s3">, </span><span class="s1">onlyfuncs</span><span class="s3">, </span><span class="s1">f90modulevars</span>

    <span class="s1">setmesstext(block)</span>
    <span class="s1">body = []</span>
    <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'body'</span><span class="s1">]:</span>
        <span class="s1">b[</span><span class="s5">'parent_block'</span><span class="s1">] = block</span>
        <span class="s3">if </span><span class="s1">b[</span><span class="s5">'block'</span><span class="s1">] </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'function'</span><span class="s3">, </span><span class="s5">'subroutine'</span><span class="s1">]:</span>
            <span class="s3">if </span><span class="s1">args </span><span class="s3">is not None and </span><span class="s1">b[</span><span class="s5">'name'</span><span class="s1">] </span><span class="s3">not in </span><span class="s1">args:</span>
                <span class="s3">continue</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">as_ = b[</span><span class="s5">'args'</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">b[</span><span class="s5">'name'</span><span class="s1">] </span><span class="s3">in </span><span class="s1">skipfuncs:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">onlyfuncs </span><span class="s3">and </span><span class="s1">b[</span><span class="s5">'name'</span><span class="s1">] </span><span class="s3">not in </span><span class="s1">onlyfuncs:</span>
                <span class="s3">continue</span>
            <span class="s1">b[</span><span class="s5">'saved_interface'</span><span class="s1">] = crack2fortrangen(</span>
                <span class="s1">b</span><span class="s3">, </span><span class="s5">'</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">+ </span><span class="s5">' ' </span><span class="s1">* </span><span class="s4">6</span><span class="s3">, </span><span class="s1">as_interface=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">as_ = args</span>
        <span class="s1">b = postcrack(b</span><span class="s3">, </span><span class="s1">as_</span><span class="s3">, </span><span class="s1">tab=tab + </span><span class="s5">'</span><span class="s3">\t</span><span class="s5">'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">b[</span><span class="s5">'block'</span><span class="s1">] </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'interface'</span><span class="s3">, </span><span class="s5">'abstract interface'</span><span class="s1">] </span><span class="s3">and not </span><span class="s1">b[</span><span class="s5">'body'</span><span class="s1">]:</span>
            <span class="s3">if </span><span class="s5">'f2pyenhancements' </span><span class="s3">not in </span><span class="s1">b:</span>
                <span class="s3">continue</span>
        <span class="s3">if </span><span class="s1">b[</span><span class="s5">'block'</span><span class="s1">].replace(</span><span class="s5">' '</span><span class="s3">, </span><span class="s5">''</span><span class="s1">) == </span><span class="s5">'pythonmodule'</span><span class="s1">:</span>
            <span class="s1">usermodules.append(b)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">b[</span><span class="s5">'block'</span><span class="s1">] == </span><span class="s5">'module'</span><span class="s1">:</span>
                <span class="s1">f90modulevars[b[</span><span class="s5">'name'</span><span class="s1">]] = b[</span><span class="s5">'vars'</span><span class="s1">]</span>
            <span class="s1">body.append(b)</span>
    <span class="s3">return </span><span class="s1">body</span>


<span class="s3">def </span><span class="s1">buildimplicitrules(block):</span>
    <span class="s1">setmesstext(block)</span>
    <span class="s1">implicitrules = defaultimplicitrules</span>
    <span class="s1">attrrules = {}</span>
    <span class="s3">if </span><span class="s5">'implicit' </span><span class="s3">in </span><span class="s1">block:</span>
        <span class="s3">if </span><span class="s1">block[</span><span class="s5">'implicit'</span><span class="s1">] </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">implicitrules = </span><span class="s3">None</span>
            <span class="s3">if </span><span class="s1">verbose &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">outmess(</span>
                    <span class="s5">'buildimplicitrules: no implicit rules for routine %s.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% repr(block[</span><span class="s5">'name'</span><span class="s1">]))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(block[</span><span class="s5">'implicit'</span><span class="s1">].keys()):</span>
                <span class="s3">if </span><span class="s1">block[</span><span class="s5">'implicit'</span><span class="s1">][k].get(</span><span class="s5">'typespec'</span><span class="s1">) </span><span class="s3">not in </span><span class="s1">[</span><span class="s5">'static'</span><span class="s3">, </span><span class="s5">'automatic'</span><span class="s1">]:</span>
                    <span class="s1">implicitrules[k] = block[</span><span class="s5">'implicit'</span><span class="s1">][k]</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">attrrules[k] = block[</span><span class="s5">'implicit'</span><span class="s1">][k][</span><span class="s5">'typespec'</span><span class="s1">]</span>
    <span class="s3">return </span><span class="s1">implicitrules</span><span class="s3">, </span><span class="s1">attrrules</span>


<span class="s3">def </span><span class="s1">myeval(e</span><span class="s3">, </span><span class="s1">g=</span><span class="s3">None, </span><span class="s1">l=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; Like `eval` but returns only integers and floats &quot;&quot;&quot;</span>
    <span class="s1">r = eval(e</span><span class="s3">, </span><span class="s1">g</span><span class="s3">, </span><span class="s1">l)</span>
    <span class="s3">if </span><span class="s1">type(r) </span><span class="s3">in </span><span class="s1">[int</span><span class="s3">, </span><span class="s1">float]:</span>
        <span class="s3">return </span><span class="s1">r</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'r=%r' </span><span class="s1">% (r))</span>

<span class="s1">getlincoef_re_1 = re.compile(</span><span class="s5">r'\A\b\w+\b\Z'</span><span class="s3">, </span><span class="s1">re.I)</span>


<span class="s3">def </span><span class="s1">getlincoef(e</span><span class="s3">, </span><span class="s1">xset):  </span><span class="s0"># e = a*x+b ; x in xset</span>
    <span class="s2">&quot;&quot;&quot; 
    Obtain ``a`` and ``b`` when ``e == &quot;a*x+b&quot;``, where ``x`` is a symbol in 
    xset. 
 
    &gt;&gt;&gt; getlincoef('2*x + 1', {'x'}) 
    (2, 1, 'x') 
    &gt;&gt;&gt; getlincoef('3*x + x*2 + 2 + 1', {'x'}) 
    (5, 3, 'x') 
    &gt;&gt;&gt; getlincoef('0', {'x'}) 
    (0, 0, None) 
    &gt;&gt;&gt; getlincoef('0*x', {'x'}) 
    (0, 0, 'x') 
    &gt;&gt;&gt; getlincoef('x*x', {'x'}) 
    (None, None, None) 
 
    This can be tricked by sufficiently complex expressions 
 
    &gt;&gt;&gt; getlincoef('(x - 0.5)*(x - 1.5)*(x - 1)*x + 2*x + 3', {'x'}) 
    (2.0, 3.0, 'x') 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">c = int(myeval(e</span><span class="s3">, </span><span class="s1">{}</span><span class="s3">, </span><span class="s1">{}))</span>
        <span class="s3">return </span><span class="s4">0</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, None</span>
    <span class="s3">except </span><span class="s1">Exception:</span>
        <span class="s3">pass</span>
    <span class="s3">if </span><span class="s1">getlincoef_re_1.match(e):</span>
        <span class="s3">return </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">e</span>
    <span class="s1">len_e = len(e)</span>
    <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">xset:</span>
        <span class="s3">if </span><span class="s1">len(x) &gt; len_e:</span>
            <span class="s3">continue</span>
        <span class="s3">if </span><span class="s1">re.search(</span><span class="s5">r'\w\s*\([^)]*\b' </span><span class="s1">+ x + </span><span class="s5">r'\b'</span><span class="s3">, </span><span class="s1">e):</span>
            <span class="s0"># skip function calls having x as an argument, e.g max(1, x)</span>
            <span class="s3">continue</span>
        <span class="s1">re_1 = re.compile(</span><span class="s5">r'(?P&lt;before&gt;.*?)\b' </span><span class="s1">+ x + </span><span class="s5">r'\b(?P&lt;after&gt;.*)'</span><span class="s3">, </span><span class="s1">re.I)</span>
        <span class="s1">m = re_1.match(e)</span>
        <span class="s3">if </span><span class="s1">m:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">m1 = re_1.match(e)</span>
                <span class="s3">while </span><span class="s1">m1:</span>
                    <span class="s1">ee = </span><span class="s5">'%s(%s)%s' </span><span class="s1">% (</span>
                        <span class="s1">m1.group(</span><span class="s5">'before'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">m1.group(</span><span class="s5">'after'</span><span class="s1">))</span>
                    <span class="s1">m1 = re_1.match(ee)</span>
                <span class="s1">b = myeval(ee</span><span class="s3">, </span><span class="s1">{}</span><span class="s3">, </span><span class="s1">{})</span>
                <span class="s1">m1 = re_1.match(e)</span>
                <span class="s3">while </span><span class="s1">m1:</span>
                    <span class="s1">ee = </span><span class="s5">'%s(%s)%s' </span><span class="s1">% (</span>
                        <span class="s1">m1.group(</span><span class="s5">'before'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">m1.group(</span><span class="s5">'after'</span><span class="s1">))</span>
                    <span class="s1">m1 = re_1.match(ee)</span>
                <span class="s1">a = myeval(ee</span><span class="s3">, </span><span class="s1">{}</span><span class="s3">, </span><span class="s1">{}) - b</span>
                <span class="s1">m1 = re_1.match(e)</span>
                <span class="s3">while </span><span class="s1">m1:</span>
                    <span class="s1">ee = </span><span class="s5">'%s(%s)%s' </span><span class="s1">% (</span>
                        <span class="s1">m1.group(</span><span class="s5">'before'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">0.5</span><span class="s3">, </span><span class="s1">m1.group(</span><span class="s5">'after'</span><span class="s1">))</span>
                    <span class="s1">m1 = re_1.match(ee)</span>
                <span class="s1">c = myeval(ee</span><span class="s3">, </span><span class="s1">{}</span><span class="s3">, </span><span class="s1">{})</span>
                <span class="s0"># computing another point to be sure that expression is linear</span>
                <span class="s1">m1 = re_1.match(e)</span>
                <span class="s3">while </span><span class="s1">m1:</span>
                    <span class="s1">ee = </span><span class="s5">'%s(%s)%s' </span><span class="s1">% (</span>
                        <span class="s1">m1.group(</span><span class="s5">'before'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">1.5</span><span class="s3">, </span><span class="s1">m1.group(</span><span class="s5">'after'</span><span class="s1">))</span>
                    <span class="s1">m1 = re_1.match(ee)</span>
                <span class="s1">c2 = myeval(ee</span><span class="s3">, </span><span class="s1">{}</span><span class="s3">, </span><span class="s1">{})</span>
                <span class="s3">if </span><span class="s1">(a * </span><span class="s4">0.5 </span><span class="s1">+ b == c </span><span class="s3">and </span><span class="s1">a * </span><span class="s4">1.5 </span><span class="s1">+ b == c2):</span>
                    <span class="s3">return </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">x</span>
            <span class="s3">except </span><span class="s1">Exception:</span>
                <span class="s3">pass</span>
            <span class="s3">break</span>
    <span class="s3">return None, None, None</span>


<span class="s1">word_pattern = re.compile(</span><span class="s5">r'\b[a-z][\w$]*\b'</span><span class="s3">, </span><span class="s1">re.I)</span>


<span class="s3">def </span><span class="s1">_get_depend_dict(name</span><span class="s3">, </span><span class="s1">vars</span><span class="s3">, </span><span class="s1">deps):</span>
    <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">vars:</span>
        <span class="s1">words = vars[name].get(</span><span class="s5">'depend'</span><span class="s3">, </span><span class="s1">[])</span>

        <span class="s3">if </span><span class="s5">'=' </span><span class="s3">in </span><span class="s1">vars[name] </span><span class="s3">and not </span><span class="s1">isstring(vars[name]):</span>
            <span class="s3">for </span><span class="s1">word </span><span class="s3">in </span><span class="s1">word_pattern.findall(vars[name][</span><span class="s5">'='</span><span class="s1">]):</span>
                <span class="s0"># The word_pattern may return values that are not</span>
                <span class="s0"># only variables, they can be string content for instance</span>
                <span class="s3">if </span><span class="s1">word </span><span class="s3">not in </span><span class="s1">words </span><span class="s3">and </span><span class="s1">word </span><span class="s3">in </span><span class="s1">vars </span><span class="s3">and </span><span class="s1">word != name:</span>
                    <span class="s1">words.append(word)</span>
        <span class="s3">for </span><span class="s1">word </span><span class="s3">in </span><span class="s1">words[:]:</span>
            <span class="s3">for </span><span class="s1">w </span><span class="s3">in </span><span class="s1">deps.get(word</span><span class="s3">, </span><span class="s1">[]) \</span>
                    <span class="s3">or </span><span class="s1">_get_depend_dict(word</span><span class="s3">, </span><span class="s1">vars</span><span class="s3">, </span><span class="s1">deps):</span>
                <span class="s3">if </span><span class="s1">w </span><span class="s3">not in </span><span class="s1">words:</span>
                    <span class="s1">words.append(w)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">outmess(</span><span class="s5">'_get_depend_dict: no dependence info for %s</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (repr(name)))</span>
        <span class="s1">words = []</span>
    <span class="s1">deps[name] = words</span>
    <span class="s3">return </span><span class="s1">words</span>


<span class="s3">def </span><span class="s1">_calc_depend_dict(vars):</span>
    <span class="s1">names = list(vars.keys())</span>
    <span class="s1">depend_dict = {}</span>
    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">names:</span>
        <span class="s1">_get_depend_dict(n</span><span class="s3">, </span><span class="s1">vars</span><span class="s3">, </span><span class="s1">depend_dict)</span>
    <span class="s3">return </span><span class="s1">depend_dict</span>


<span class="s3">def </span><span class="s1">get_sorted_names(vars):</span>
    <span class="s2">&quot;&quot;&quot; 
    &quot;&quot;&quot;</span>
    <span class="s1">depend_dict = _calc_depend_dict(vars)</span>
    <span class="s1">names = []</span>
    <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">list(depend_dict.keys()):</span>
        <span class="s3">if not </span><span class="s1">depend_dict[name]:</span>
            <span class="s1">names.append(name)</span>
            <span class="s3">del </span><span class="s1">depend_dict[name]</span>
    <span class="s3">while </span><span class="s1">depend_dict:</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">lst </span><span class="s3">in </span><span class="s1">list(depend_dict.items()):</span>
            <span class="s1">new_lst = [n </span><span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">lst </span><span class="s3">if </span><span class="s1">n </span><span class="s3">in </span><span class="s1">depend_dict]</span>
            <span class="s3">if not </span><span class="s1">new_lst:</span>
                <span class="s1">names.append(name)</span>
                <span class="s3">del </span><span class="s1">depend_dict[name]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">depend_dict[name] = new_lst</span>
    <span class="s3">return </span><span class="s1">[name </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">names </span><span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">vars]</span>


<span class="s3">def </span><span class="s1">_kind_func(string):</span>
    <span class="s0"># XXX: return something sensible.</span>
    <span class="s3">if </span><span class="s1">string[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">in </span><span class="s5">&quot;'</span><span class="s3">\&quot;</span><span class="s5">&quot;</span><span class="s1">:</span>
        <span class="s1">string = string[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">real16pattern.match(string):</span>
        <span class="s3">return </span><span class="s4">8</span>
    <span class="s3">elif </span><span class="s1">real8pattern.match(string):</span>
        <span class="s3">return </span><span class="s4">4</span>
    <span class="s3">return </span><span class="s5">'kind(' </span><span class="s1">+ string + </span><span class="s5">')'</span>


<span class="s3">def </span><span class="s1">_selected_int_kind_func(r):</span>
    <span class="s0"># XXX: This should be processor dependent</span>
    <span class="s1">m = </span><span class="s4">10 </span><span class="s1">** r</span>
    <span class="s3">if </span><span class="s1">m &lt;= </span><span class="s4">2 </span><span class="s1">** </span><span class="s4">8</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s4">1</span>
    <span class="s3">if </span><span class="s1">m &lt;= </span><span class="s4">2 </span><span class="s1">** </span><span class="s4">16</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s4">2</span>
    <span class="s3">if </span><span class="s1">m &lt;= </span><span class="s4">2 </span><span class="s1">** </span><span class="s4">32</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s4">4</span>
    <span class="s3">if </span><span class="s1">m &lt;= </span><span class="s4">2 </span><span class="s1">** </span><span class="s4">63</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s4">8</span>
    <span class="s3">if </span><span class="s1">m &lt;= </span><span class="s4">2 </span><span class="s1">** </span><span class="s4">128</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s4">16</span>
    <span class="s3">return </span><span class="s1">-</span><span class="s4">1</span>


<span class="s3">def </span><span class="s1">_selected_real_kind_func(p</span><span class="s3">, </span><span class="s1">r=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">radix=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s0"># XXX: This should be processor dependent</span>
    <span class="s0"># This is only good for 0 &lt;= p &lt;= 20</span>
    <span class="s3">if </span><span class="s1">p &lt; </span><span class="s4">7</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s4">4</span>
    <span class="s3">if </span><span class="s1">p &lt; </span><span class="s4">16</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s4">8</span>
    <span class="s1">machine = platform.machine().lower()</span>
    <span class="s3">if </span><span class="s1">machine.startswith((</span><span class="s5">'aarch64'</span><span class="s3">, </span><span class="s5">'power'</span><span class="s3">, </span><span class="s5">'ppc'</span><span class="s3">, </span><span class="s5">'riscv'</span><span class="s3">, </span><span class="s5">'s390x'</span><span class="s3">, </span><span class="s5">'sparc'</span><span class="s1">)):</span>
        <span class="s3">if </span><span class="s1">p &lt;= </span><span class="s4">20</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">16</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">p &lt; </span><span class="s4">19</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">10</span>
        <span class="s3">elif </span><span class="s1">p &lt;= </span><span class="s4">20</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">16</span>
    <span class="s3">return </span><span class="s1">-</span><span class="s4">1</span>


<span class="s3">def </span><span class="s1">get_parameters(vars</span><span class="s3">, </span><span class="s1">global_params={}):</span>
    <span class="s1">params = copy.copy(global_params)</span>
    <span class="s1">g_params = copy.copy(global_params)</span>
    <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">func </span><span class="s3">in </span><span class="s1">[(</span><span class="s5">'kind'</span><span class="s3">, </span><span class="s1">_kind_func)</span><span class="s3">,</span>
                       <span class="s1">(</span><span class="s5">'selected_int_kind'</span><span class="s3">, </span><span class="s1">_selected_int_kind_func)</span><span class="s3">,</span>
                       <span class="s1">(</span><span class="s5">'selected_real_kind'</span><span class="s3">, </span><span class="s1">_selected_real_kind_func)</span><span class="s3">, </span><span class="s1">]:</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">g_params:</span>
            <span class="s1">g_params[name] = func</span>
    <span class="s1">param_names = []</span>
    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">get_sorted_names(vars):</span>
        <span class="s3">if </span><span class="s5">'attrspec' </span><span class="s3">in </span><span class="s1">vars[n] </span><span class="s3">and </span><span class="s5">'parameter' </span><span class="s3">in </span><span class="s1">vars[n][</span><span class="s5">'attrspec'</span><span class="s1">]:</span>
            <span class="s1">param_names.append(n)</span>
    <span class="s1">kind_re = re.compile(</span><span class="s5">r'\bkind\s*\(\s*(?P&lt;value&gt;.*)\s*\)'</span><span class="s3">, </span><span class="s1">re.I)</span>
    <span class="s1">selected_int_kind_re = re.compile(</span>
        <span class="s5">r'\bselected_int_kind\s*\(\s*(?P&lt;value&gt;.*)\s*\)'</span><span class="s3">, </span><span class="s1">re.I)</span>
    <span class="s1">selected_kind_re = re.compile(</span>
        <span class="s5">r'\bselected_(int|real)_kind\s*\(\s*(?P&lt;value&gt;.*)\s*\)'</span><span class="s3">, </span><span class="s1">re.I)</span>
    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">param_names:</span>
        <span class="s3">if </span><span class="s5">'=' </span><span class="s3">in </span><span class="s1">vars[n]:</span>
            <span class="s1">v = vars[n][</span><span class="s5">'='</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">islogical(vars[n]):</span>
                <span class="s1">v = v.lower()</span>
                <span class="s3">for </span><span class="s1">repl </span><span class="s3">in </span><span class="s1">[</span>
                    <span class="s1">(</span><span class="s5">'.false.'</span><span class="s3">, </span><span class="s5">'False'</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">(</span><span class="s5">'.true.'</span><span class="s3">, </span><span class="s5">'True'</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s0"># TODO: test .eq., .neq., etc replacements.</span>
                <span class="s1">]:</span>
                    <span class="s1">v = v.replace(*repl)</span>
            <span class="s1">v = kind_re.sub(</span><span class="s5">r'kind(&quot;\1&quot;)'</span><span class="s3">, </span><span class="s1">v)</span>
            <span class="s1">v = selected_int_kind_re.sub(</span><span class="s5">r'selected_int_kind(\1)'</span><span class="s3">, </span><span class="s1">v)</span>

            <span class="s0"># We need to act according to the data.</span>
            <span class="s0"># The easy case is if the data has a kind-specifier,</span>
            <span class="s0"># then we may easily remove those specifiers.</span>
            <span class="s0"># However, it may be that the user uses other specifiers...(!)</span>
            <span class="s1">is_replaced = </span><span class="s3">False</span>
            <span class="s3">if </span><span class="s5">'kindselector' </span><span class="s3">in </span><span class="s1">vars[n]:</span>
                <span class="s3">if </span><span class="s5">'kind' </span><span class="s3">in </span><span class="s1">vars[n][</span><span class="s5">'kindselector'</span><span class="s1">]:</span>
                    <span class="s1">orig_v_len = len(v)</span>
                    <span class="s1">v = v.replace(</span><span class="s5">'_' </span><span class="s1">+ vars[n][</span><span class="s5">'kindselector'</span><span class="s1">][</span><span class="s5">'kind'</span><span class="s1">]</span><span class="s3">, </span><span class="s5">''</span><span class="s1">)</span>
                    <span class="s0"># Again, this will be true if even a single specifier</span>
                    <span class="s0"># has been replaced, see comment above.</span>
                    <span class="s1">is_replaced = len(v) &lt; orig_v_len</span>
                    
            <span class="s3">if not </span><span class="s1">is_replaced:</span>
                <span class="s3">if not </span><span class="s1">selected_kind_re.match(v):</span>
                    <span class="s1">v_ = v.split(</span><span class="s5">'_'</span><span class="s1">)</span>
                    <span class="s0"># In case there are additive parameters</span>
                    <span class="s3">if </span><span class="s1">len(v_) &gt; </span><span class="s4">1</span><span class="s1">: </span>
                        <span class="s1">v = </span><span class="s5">''</span><span class="s1">.join(v_[:-</span><span class="s4">1</span><span class="s1">]).lower().replace(v_[-</span><span class="s4">1</span><span class="s1">].lower()</span><span class="s3">, </span><span class="s5">''</span><span class="s1">)</span>

            <span class="s0"># Currently this will not work for complex numbers.</span>
            <span class="s0"># There is missing code for extracting a complex number,</span>
            <span class="s0"># which may be defined in either of these:</span>
            <span class="s0">#  a) (Re, Im)</span>
            <span class="s0">#  b) cmplx(Re, Im)</span>
            <span class="s0">#  c) dcmplx(Re, Im)</span>
            <span class="s0">#  d) cmplx(Re, Im, &lt;prec&gt;)</span>

            <span class="s3">if </span><span class="s1">isdouble(vars[n]):</span>
                <span class="s1">tt = list(v)</span>
                <span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">real16pattern.finditer(v):</span>
                    <span class="s1">tt[m.start():m.end()] = list(</span>
                        <span class="s1">v[m.start():m.end()].lower().replace(</span><span class="s5">'d'</span><span class="s3">, </span><span class="s5">'e'</span><span class="s1">))</span>
                <span class="s1">v = </span><span class="s5">''</span><span class="s1">.join(tt)</span>

            <span class="s3">elif </span><span class="s1">iscomplex(vars[n]):</span>
                <span class="s1">outmess(</span><span class="s5">f'get_parameters[TODO]: '</span>
                        <span class="s5">f'implement evaluation of complex expression </span><span class="s3">{</span><span class="s1">v</span><span class="s3">}\n</span><span class="s5">'</span><span class="s1">)</span>

            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">params[n] = eval(v</span><span class="s3">, </span><span class="s1">g_params</span><span class="s3">, </span><span class="s1">params)</span>
            <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">msg:</span>
                <span class="s1">params[n] = v</span>
                <span class="s1">outmess(</span><span class="s5">'get_parameters: got &quot;%s&quot; on %s</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (msg</span><span class="s3">, </span><span class="s1">repr(v)))</span>
            <span class="s3">if </span><span class="s1">isstring(vars[n]) </span><span class="s3">and </span><span class="s1">isinstance(params[n]</span><span class="s3">, </span><span class="s1">int):</span>
                <span class="s1">params[n] = chr(params[n])</span>
            <span class="s1">nl = n.lower()</span>
            <span class="s3">if </span><span class="s1">nl != n:</span>
                <span class="s1">params[nl] = params[n]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">print(vars[n])</span>
            <span class="s1">outmess(</span>
                <span class="s5">'get_parameters:parameter %s does not have value?!</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (repr(n)))</span>
    <span class="s3">return </span><span class="s1">params</span>


<span class="s3">def </span><span class="s1">_eval_length(length</span><span class="s3">, </span><span class="s1">params):</span>
    <span class="s3">if </span><span class="s1">length </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'(:)'</span><span class="s3">, </span><span class="s5">'(*)'</span><span class="s3">, </span><span class="s5">'*'</span><span class="s1">]:</span>
        <span class="s3">return </span><span class="s5">'(*)'</span>
    <span class="s3">return </span><span class="s1">_eval_scalar(length</span><span class="s3">, </span><span class="s1">params)</span>

<span class="s1">_is_kind_number = re.compile(</span><span class="s5">r'\d+_'</span><span class="s1">).match</span>


<span class="s3">def </span><span class="s1">_eval_scalar(value</span><span class="s3">, </span><span class="s1">params):</span>
    <span class="s3">if </span><span class="s1">_is_kind_number(value):</span>
        <span class="s1">value = value.split(</span><span class="s5">'_'</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">value = eval(value</span><span class="s3">, </span><span class="s1">{}</span><span class="s3">, </span><span class="s1">params)</span>
        <span class="s1">value = (repr </span><span class="s3">if </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">str) </span><span class="s3">else </span><span class="s1">str)(value)</span>
    <span class="s3">except </span><span class="s1">(NameError</span><span class="s3">, </span><span class="s1">SyntaxError</span><span class="s3">, </span><span class="s1">TypeError):</span>
        <span class="s3">return </span><span class="s1">value</span>
    <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">msg:</span>
        <span class="s1">errmess(</span><span class="s5">'&quot;%s&quot; in evaluating %r '</span>
                <span class="s5">'(available names: %s)</span><span class="s3">\n</span><span class="s5">'</span>
                <span class="s1">% (msg</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">list(params.keys())))</span>
    <span class="s3">return </span><span class="s1">value</span>


<span class="s3">def </span><span class="s1">analyzevars(block):</span>
    <span class="s3">global </span><span class="s1">f90modulevars</span>

    <span class="s1">setmesstext(block)</span>
    <span class="s1">implicitrules</span><span class="s3">, </span><span class="s1">attrrules = buildimplicitrules(block)</span>
    <span class="s1">vars = copy.copy(block[</span><span class="s5">'vars'</span><span class="s1">])</span>
    <span class="s3">if </span><span class="s1">block[</span><span class="s5">'block'</span><span class="s1">] == </span><span class="s5">'function' </span><span class="s3">and </span><span class="s1">block[</span><span class="s5">'name'</span><span class="s1">] </span><span class="s3">not in </span><span class="s1">vars:</span>
        <span class="s1">vars[block[</span><span class="s5">'name'</span><span class="s1">]] = {}</span>
    <span class="s3">if </span><span class="s5">'' </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">]:</span>
        <span class="s3">del </span><span class="s1">vars[</span><span class="s5">''</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s5">'attrspec' </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">][</span><span class="s5">''</span><span class="s1">]:</span>
            <span class="s1">gen = block[</span><span class="s5">'vars'</span><span class="s1">][</span><span class="s5">''</span><span class="s1">][</span><span class="s5">'attrspec'</span><span class="s1">]</span>
            <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">list(vars.keys()):</span>
                <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'public'</span><span class="s3">, </span><span class="s5">'private'</span><span class="s1">]:</span>
                    <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">gen:</span>
                        <span class="s1">vars[n] = setattrspec(vars[n]</span><span class="s3">, </span><span class="s1">k)</span>
    <span class="s1">svars = []</span>
    <span class="s1">args = block[</span><span class="s5">'args'</span><span class="s1">]</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">args:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">vars[a]</span>
            <span class="s1">svars.append(a)</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">pass</span>
    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">list(vars.keys()):</span>
        <span class="s3">if </span><span class="s1">n </span><span class="s3">not in </span><span class="s1">args:</span>
            <span class="s1">svars.append(n)</span>

    <span class="s1">params = get_parameters(vars</span><span class="s3">, </span><span class="s1">get_useparameters(block))</span>

    <span class="s1">dep_matches = {}</span>
    <span class="s1">name_match = re.compile(</span><span class="s5">r'[A-Za-z][\w$]*'</span><span class="s1">).match</span>
    <span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">list(vars.keys()):</span>
        <span class="s1">m = name_match(v)</span>
        <span class="s3">if </span><span class="s1">m:</span>
            <span class="s1">n = v[m.start():m.end()]</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">dep_matches[n]</span>
            <span class="s3">except </span><span class="s1">KeyError:</span>
                <span class="s1">dep_matches[n] = re.compile(</span><span class="s5">r'.*\b%s\b' </span><span class="s1">% (v)</span><span class="s3">, </span><span class="s1">re.I).match</span>
    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">svars:</span>
        <span class="s3">if </span><span class="s1">n[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">in </span><span class="s1">list(attrrules.keys()):</span>
            <span class="s1">vars[n] = setattrspec(vars[n]</span><span class="s3">, </span><span class="s1">attrrules[n[</span><span class="s4">0</span><span class="s1">]])</span>
        <span class="s3">if </span><span class="s5">'typespec' </span><span class="s3">not in </span><span class="s1">vars[n]:</span>
            <span class="s3">if not</span><span class="s1">(</span><span class="s5">'attrspec' </span><span class="s3">in </span><span class="s1">vars[n] </span><span class="s3">and </span><span class="s5">'external' </span><span class="s3">in </span><span class="s1">vars[n][</span><span class="s5">'attrspec'</span><span class="s1">]):</span>
                <span class="s3">if </span><span class="s1">implicitrules:</span>
                    <span class="s1">ln0 = n[</span><span class="s4">0</span><span class="s1">].lower()</span>
                    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(implicitrules[ln0].keys()):</span>
                        <span class="s3">if </span><span class="s1">k == </span><span class="s5">'typespec' </span><span class="s3">and </span><span class="s1">implicitrules[ln0][k] == </span><span class="s5">'undefined'</span><span class="s1">:</span>
                            <span class="s3">continue</span>
                        <span class="s3">if </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">vars[n]:</span>
                            <span class="s1">vars[n][k] = implicitrules[ln0][k]</span>
                        <span class="s3">elif </span><span class="s1">k == </span><span class="s5">'attrspec'</span><span class="s1">:</span>
                            <span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">implicitrules[ln0][k]:</span>
                                <span class="s1">vars[n] = setattrspec(vars[n]</span><span class="s3">, </span><span class="s1">l)</span>
                <span class="s3">elif </span><span class="s1">n </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'args'</span><span class="s1">]:</span>
                    <span class="s1">outmess(</span><span class="s5">'analyzevars: typespec of variable %s is not defined in routine %s.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (</span>
                        <span class="s1">repr(n)</span><span class="s3">, </span><span class="s1">block[</span><span class="s5">'name'</span><span class="s1">]))</span>

        <span class="s3">if </span><span class="s5">'charselector' </span><span class="s3">in </span><span class="s1">vars[n]:</span>
            <span class="s3">if </span><span class="s5">'len' </span><span class="s3">in </span><span class="s1">vars[n][</span><span class="s5">'charselector'</span><span class="s1">]:</span>
                <span class="s1">l = vars[n][</span><span class="s5">'charselector'</span><span class="s1">][</span><span class="s5">'len'</span><span class="s1">]</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">l = str(eval(l</span><span class="s3">, </span><span class="s1">{}</span><span class="s3">, </span><span class="s1">params))</span>
                <span class="s3">except </span><span class="s1">Exception:</span>
                    <span class="s3">pass</span>
                <span class="s1">vars[n][</span><span class="s5">'charselector'</span><span class="s1">][</span><span class="s5">'len'</span><span class="s1">] = l</span>

        <span class="s3">if </span><span class="s5">'kindselector' </span><span class="s3">in </span><span class="s1">vars[n]:</span>
            <span class="s3">if </span><span class="s5">'kind' </span><span class="s3">in </span><span class="s1">vars[n][</span><span class="s5">'kindselector'</span><span class="s1">]:</span>
                <span class="s1">l = vars[n][</span><span class="s5">'kindselector'</span><span class="s1">][</span><span class="s5">'kind'</span><span class="s1">]</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">l = str(eval(l</span><span class="s3">, </span><span class="s1">{}</span><span class="s3">, </span><span class="s1">params))</span>
                <span class="s3">except </span><span class="s1">Exception:</span>
                    <span class="s3">pass</span>
                <span class="s1">vars[n][</span><span class="s5">'kindselector'</span><span class="s1">][</span><span class="s5">'kind'</span><span class="s1">] = l</span>

        <span class="s1">dimension_exprs = {}</span>
        <span class="s3">if </span><span class="s5">'attrspec' </span><span class="s3">in </span><span class="s1">vars[n]:</span>
            <span class="s1">attr = vars[n][</span><span class="s5">'attrspec'</span><span class="s1">]</span>
            <span class="s1">attr.reverse()</span>
            <span class="s1">vars[n][</span><span class="s5">'attrspec'</span><span class="s1">] = []</span>
            <span class="s1">dim</span><span class="s3">, </span><span class="s1">intent</span><span class="s3">, </span><span class="s1">depend</span><span class="s3">, </span><span class="s1">check</span><span class="s3">, </span><span class="s1">note = </span><span class="s3">None, None, None, None, None</span>
            <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">attr:</span>
                <span class="s3">if </span><span class="s1">a[:</span><span class="s4">9</span><span class="s1">] == </span><span class="s5">'dimension'</span><span class="s1">:</span>
                    <span class="s1">dim = (a[</span><span class="s4">9</span><span class="s1">:].strip())[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s3">elif </span><span class="s1">a[:</span><span class="s4">6</span><span class="s1">] == </span><span class="s5">'intent'</span><span class="s1">:</span>
                    <span class="s1">intent = (a[</span><span class="s4">6</span><span class="s1">:].strip())[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s3">elif </span><span class="s1">a[:</span><span class="s4">6</span><span class="s1">] == </span><span class="s5">'depend'</span><span class="s1">:</span>
                    <span class="s1">depend = (a[</span><span class="s4">6</span><span class="s1">:].strip())[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s3">elif </span><span class="s1">a[:</span><span class="s4">5</span><span class="s1">] == </span><span class="s5">'check'</span><span class="s1">:</span>
                    <span class="s1">check = (a[</span><span class="s4">5</span><span class="s1">:].strip())[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s3">elif </span><span class="s1">a[:</span><span class="s4">4</span><span class="s1">] == </span><span class="s5">'note'</span><span class="s1">:</span>
                    <span class="s1">note = (a[</span><span class="s4">4</span><span class="s1">:].strip())[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">vars[n] = setattrspec(vars[n]</span><span class="s3">, </span><span class="s1">a)</span>
                <span class="s3">if </span><span class="s1">intent:</span>
                    <span class="s3">if </span><span class="s5">'intent' </span><span class="s3">not in </span><span class="s1">vars[n]:</span>
                        <span class="s1">vars[n][</span><span class="s5">'intent'</span><span class="s1">] = []</span>
                    <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">[x.strip() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma(intent).split(</span><span class="s5">'@,@'</span><span class="s1">)]:</span>
                        <span class="s0"># Remove spaces so that 'in out' becomes 'inout'</span>
                        <span class="s1">tmp = c.replace(</span><span class="s5">' '</span><span class="s3">, </span><span class="s5">''</span><span class="s1">)</span>
                        <span class="s3">if </span><span class="s1">tmp </span><span class="s3">not in </span><span class="s1">vars[n][</span><span class="s5">'intent'</span><span class="s1">]:</span>
                            <span class="s1">vars[n][</span><span class="s5">'intent'</span><span class="s1">].append(tmp)</span>
                    <span class="s1">intent = </span><span class="s3">None</span>
                <span class="s3">if </span><span class="s1">note:</span>
                    <span class="s1">note = note.replace(</span><span class="s5">'</span><span class="s3">\\</span><span class="s5">n</span><span class="s3">\\</span><span class="s5">n'</span><span class="s3">, </span><span class="s5">'</span><span class="s3">\n\n</span><span class="s5">'</span><span class="s1">)</span>
                    <span class="s1">note = note.replace(</span><span class="s5">'</span><span class="s3">\\</span><span class="s5">n '</span><span class="s3">, </span><span class="s5">'</span><span class="s3">\n</span><span class="s5">'</span><span class="s1">)</span>
                    <span class="s3">if </span><span class="s5">'note' </span><span class="s3">not in </span><span class="s1">vars[n]:</span>
                        <span class="s1">vars[n][</span><span class="s5">'note'</span><span class="s1">] = [note]</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">vars[n][</span><span class="s5">'note'</span><span class="s1">].append(note)</span>
                    <span class="s1">note = </span><span class="s3">None</span>
                <span class="s3">if </span><span class="s1">depend </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s5">'depend' </span><span class="s3">not in </span><span class="s1">vars[n]:</span>
                        <span class="s1">vars[n][</span><span class="s5">'depend'</span><span class="s1">] = []</span>
                    <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">rmbadname([x.strip() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma(depend).split(</span><span class="s5">'@,@'</span><span class="s1">)]):</span>
                        <span class="s3">if </span><span class="s1">c </span><span class="s3">not in </span><span class="s1">vars[n][</span><span class="s5">'depend'</span><span class="s1">]:</span>
                            <span class="s1">vars[n][</span><span class="s5">'depend'</span><span class="s1">].append(c)</span>
                    <span class="s1">depend = </span><span class="s3">None</span>
                <span class="s3">if </span><span class="s1">check </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s5">'check' </span><span class="s3">not in </span><span class="s1">vars[n]:</span>
                        <span class="s1">vars[n][</span><span class="s5">'check'</span><span class="s1">] = []</span>
                    <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">[x.strip() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma(check).split(</span><span class="s5">'@,@'</span><span class="s1">)]:</span>
                        <span class="s3">if </span><span class="s1">c </span><span class="s3">not in </span><span class="s1">vars[n][</span><span class="s5">'check'</span><span class="s1">]:</span>
                            <span class="s1">vars[n][</span><span class="s5">'check'</span><span class="s1">].append(c)</span>
                    <span class="s1">check = </span><span class="s3">None</span>
            <span class="s3">if </span><span class="s1">dim </span><span class="s3">and </span><span class="s5">'dimension' </span><span class="s3">not in </span><span class="s1">vars[n]:</span>
                <span class="s1">vars[n][</span><span class="s5">'dimension'</span><span class="s1">] = []</span>
                <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">rmbadname([x.strip() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma(dim).split(</span><span class="s5">'@,@'</span><span class="s1">)]):</span>
                    <span class="s1">star = </span><span class="s5">':' </span><span class="s3">if </span><span class="s1">d == </span><span class="s5">':' </span><span class="s3">else </span><span class="s5">'*'</span>
                    <span class="s0"># Evaluate `d` with respect to params</span>
                    <span class="s3">if </span><span class="s1">d </span><span class="s3">in </span><span class="s1">params:</span>
                        <span class="s1">d = str(params[d])</span>
                    <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">params:</span>
                        <span class="s1">re_1 = re.compile(</span><span class="s5">r'(?P&lt;before&gt;.*?)\b' </span><span class="s1">+ p + </span><span class="s5">r'\b(?P&lt;after&gt;.*)'</span><span class="s3">, </span><span class="s1">re.I)</span>
                        <span class="s1">m = re_1.match(d)</span>
                        <span class="s3">while </span><span class="s1">m:</span>
                            <span class="s1">d = m.group(</span><span class="s5">'before'</span><span class="s1">) + \</span>
                                <span class="s1">str(params[p]) + m.group(</span><span class="s5">'after'</span><span class="s1">)</span>
                            <span class="s1">m = re_1.match(d)</span>

                    <span class="s3">if </span><span class="s1">d == star:</span>
                        <span class="s1">dl = [star]</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">dl = markoutercomma(d</span><span class="s3">, </span><span class="s5">':'</span><span class="s1">).split(</span><span class="s5">'@:@'</span><span class="s1">)</span>
                    <span class="s3">if </span><span class="s1">len(dl) == </span><span class="s4">2 </span><span class="s3">and </span><span class="s5">'*' </span><span class="s3">in </span><span class="s1">dl:  </span><span class="s0"># e.g. dimension(5:*)</span>
                        <span class="s1">dl = [</span><span class="s5">'*'</span><span class="s1">]</span>
                        <span class="s1">d = </span><span class="s5">'*'</span>
                    <span class="s3">if </span><span class="s1">len(dl) == </span><span class="s4">1 </span><span class="s3">and </span><span class="s1">dl[</span><span class="s4">0</span><span class="s1">] != star:</span>
                        <span class="s1">dl = [</span><span class="s5">'1'</span><span class="s3">, </span><span class="s1">dl[</span><span class="s4">0</span><span class="s1">]]</span>
                    <span class="s3">if </span><span class="s1">len(dl) == </span><span class="s4">2</span><span class="s1">:</span>
                        <span class="s1">d1</span><span class="s3">, </span><span class="s1">d2 = map(symbolic.Expr.parse</span><span class="s3">, </span><span class="s1">dl)</span>
                        <span class="s1">dsize = d2 - d1 + </span><span class="s4">1</span>
                        <span class="s1">d = dsize.tostring(language=symbolic.Language.C)</span>
                        <span class="s0"># find variables v that define d as a linear</span>
                        <span class="s0"># function, `d == a * v + b`, and store</span>
                        <span class="s0"># coefficients a and b for further analysis.</span>
                        <span class="s1">solver_and_deps = {}</span>
                        <span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">]:</span>
                            <span class="s1">s = symbolic.as_symbol(v)</span>
                            <span class="s3">if </span><span class="s1">dsize.contains(s):</span>
                                <span class="s3">try</span><span class="s1">:</span>
                                    <span class="s1">a</span><span class="s3">, </span><span class="s1">b = dsize.linear_solve(s)</span>

                                    <span class="s3">def </span><span class="s1">solve_v(s</span><span class="s3">, </span><span class="s1">a=a</span><span class="s3">, </span><span class="s1">b=b):</span>
                                        <span class="s3">return </span><span class="s1">(s - b) / a</span>

                                    <span class="s1">all_symbols = set(a.symbols())</span>
                                    <span class="s1">all_symbols.update(b.symbols())</span>
                                <span class="s3">except </span><span class="s1">RuntimeError </span><span class="s3">as </span><span class="s1">msg:</span>
                                    <span class="s0"># d is not a linear function of v,</span>
                                    <span class="s0"># however, if v can be determined</span>
                                    <span class="s0"># from d using other means,</span>
                                    <span class="s0"># implement the corresponding</span>
                                    <span class="s0"># solve_v function here.</span>
                                    <span class="s1">solve_v = </span><span class="s3">None</span>
                                    <span class="s1">all_symbols = set(dsize.symbols())</span>
                                <span class="s1">v_deps = set(</span>
                                    <span class="s1">s.data </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">all_symbols</span>
                                    <span class="s3">if </span><span class="s1">s.data </span><span class="s3">in </span><span class="s1">vars)</span>
                                <span class="s1">solver_and_deps[v] = solve_v</span><span class="s3">, </span><span class="s1">list(v_deps)</span>
                        <span class="s0"># Note that dsize may contain symbols that are</span>
                        <span class="s0"># not defined in block['vars']. Here we assume</span>
                        <span class="s0"># these correspond to Fortran/C intrinsic</span>
                        <span class="s0"># functions or that are defined by other</span>
                        <span class="s0"># means. We'll let the compiler validate the</span>
                        <span class="s0"># definiteness of such symbols.</span>
                        <span class="s1">dimension_exprs[d] = solver_and_deps</span>
                    <span class="s1">vars[n][</span><span class="s5">'dimension'</span><span class="s1">].append(d)</span>

        <span class="s3">if </span><span class="s5">'dimension' </span><span class="s3">in </span><span class="s1">vars[n]:</span>
            <span class="s3">if </span><span class="s1">isstringarray(vars[n]):</span>
                <span class="s3">if </span><span class="s5">'charselector' </span><span class="s3">in </span><span class="s1">vars[n]:</span>
                    <span class="s1">d = vars[n][</span><span class="s5">'charselector'</span><span class="s1">]</span>
                    <span class="s3">if </span><span class="s5">'*' </span><span class="s3">in </span><span class="s1">d:</span>
                        <span class="s1">d = d[</span><span class="s5">'*'</span><span class="s1">]</span>
                        <span class="s1">errmess(</span><span class="s5">'analyzevars: character array &quot;character*%s %s(%s)&quot; is considered as &quot;character %s(%s)&quot;; &quot;intent(c)&quot; is forced.</span><span class="s3">\n</span><span class="s5">'</span>
                                <span class="s1">% (d</span><span class="s3">, </span><span class="s1">n</span><span class="s3">,</span>
                                   <span class="s5">','</span><span class="s1">.join(vars[n][</span><span class="s5">'dimension'</span><span class="s1">])</span><span class="s3">,</span>
                                   <span class="s1">n</span><span class="s3">, </span><span class="s5">','</span><span class="s1">.join(vars[n][</span><span class="s5">'dimension'</span><span class="s1">] + [d])))</span>
                        <span class="s1">vars[n][</span><span class="s5">'dimension'</span><span class="s1">].append(d)</span>
                        <span class="s3">del </span><span class="s1">vars[n][</span><span class="s5">'charselector'</span><span class="s1">]</span>
                        <span class="s3">if </span><span class="s5">'intent' </span><span class="s3">not in </span><span class="s1">vars[n]:</span>
                            <span class="s1">vars[n][</span><span class="s5">'intent'</span><span class="s1">] = []</span>
                        <span class="s3">if </span><span class="s5">'c' </span><span class="s3">not in </span><span class="s1">vars[n][</span><span class="s5">'intent'</span><span class="s1">]:</span>
                            <span class="s1">vars[n][</span><span class="s5">'intent'</span><span class="s1">].append(</span><span class="s5">'c'</span><span class="s1">)</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">errmess(</span>
                            <span class="s5">&quot;analyzevars: charselector=%r unhandled.</span><span class="s3">\n</span><span class="s5">&quot; </span><span class="s1">% (d))</span>

        <span class="s3">if </span><span class="s5">'check' </span><span class="s3">not in </span><span class="s1">vars[n] </span><span class="s3">and </span><span class="s5">'args' </span><span class="s3">in </span><span class="s1">block </span><span class="s3">and </span><span class="s1">n </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'args'</span><span class="s1">]:</span>
            <span class="s0"># n is an argument that has no checks defined. Here we</span>
            <span class="s0"># generate some consistency checks for n, and when n is an</span>
            <span class="s0"># array, generate checks for its dimensions and construct</span>
            <span class="s0"># initialization expressions.</span>
            <span class="s1">n_deps = vars[n].get(</span><span class="s5">'depend'</span><span class="s3">, </span><span class="s1">[])</span>
            <span class="s1">n_checks = []</span>
            <span class="s1">n_is_input = l_or(isintent_in</span><span class="s3">, </span><span class="s1">isintent_inout</span><span class="s3">,</span>
                              <span class="s1">isintent_inplace)(vars[n])</span>
            <span class="s3">if </span><span class="s5">'dimension' </span><span class="s3">in </span><span class="s1">vars[n]:  </span><span class="s0"># n is array</span>
                <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">d </span><span class="s3">in </span><span class="s1">enumerate(vars[n][</span><span class="s5">'dimension'</span><span class="s1">]):</span>
                    <span class="s1">coeffs_and_deps = dimension_exprs.get(d)</span>
                    <span class="s3">if </span><span class="s1">coeffs_and_deps </span><span class="s3">is None</span><span class="s1">:</span>
                        <span class="s0"># d is `:` or `*` or a constant expression</span>
                        <span class="s3">pass</span>
                    <span class="s3">elif </span><span class="s1">n_is_input:</span>
                        <span class="s0"># n is an input array argument and its shape</span>
                        <span class="s0"># may define variables used in dimension</span>
                        <span class="s0"># specifications.</span>
                        <span class="s3">for </span><span class="s1">v</span><span class="s3">, </span><span class="s1">(solver</span><span class="s3">, </span><span class="s1">deps) </span><span class="s3">in </span><span class="s1">coeffs_and_deps.items():</span>
                            <span class="s3">if </span><span class="s1">((v </span><span class="s3">in </span><span class="s1">n_deps</span>
                                 <span class="s3">or </span><span class="s5">'=' </span><span class="s3">in </span><span class="s1">vars[v]</span>
                                 <span class="s3">or </span><span class="s5">'depend' </span><span class="s3">in </span><span class="s1">vars[v])):</span>
                                <span class="s0"># Skip a variable that</span>
                                <span class="s0"># - n depends on</span>
                                <span class="s0"># - has user-defined initialization expression</span>
                                <span class="s0"># - has user-defined dependecies</span>
                                <span class="s3">continue</span>
                            <span class="s3">if </span><span class="s1">solver </span><span class="s3">is not None</span><span class="s1">:</span>
                                <span class="s0"># v can be solved from d, hence, we</span>
                                <span class="s0"># make it an optional argument with</span>
                                <span class="s0"># initialization expression:</span>
                                <span class="s1">is_required = </span><span class="s3">False</span>
                                <span class="s1">init = solver(symbolic.as_symbol(</span>
                                    <span class="s5">f'shape(</span><span class="s3">{</span><span class="s1">n</span><span class="s3">}</span><span class="s5">, </span><span class="s3">{</span><span class="s1">i</span><span class="s3">}</span><span class="s5">)'</span><span class="s1">))</span>
                                <span class="s1">init = init.tostring(</span>
                                    <span class="s1">language=symbolic.Language.C)</span>
                                <span class="s1">vars[v][</span><span class="s5">'='</span><span class="s1">] = init</span>
                                <span class="s0"># n needs to be initialized before v. So,</span>
                                <span class="s0"># making v dependent on n and on any</span>
                                <span class="s0"># variables in solver or d.</span>
                                <span class="s1">vars[v][</span><span class="s5">'depend'</span><span class="s1">] = [n] + deps</span>
                                <span class="s3">if </span><span class="s5">'check' </span><span class="s3">not in </span><span class="s1">vars[v]:</span>
                                    <span class="s0"># add check only when no</span>
                                    <span class="s0"># user-specified checks exist</span>
                                    <span class="s1">vars[v][</span><span class="s5">'check'</span><span class="s1">] = [</span>
                                        <span class="s5">f'shape(</span><span class="s3">{</span><span class="s1">n</span><span class="s3">}</span><span class="s5">, </span><span class="s3">{</span><span class="s1">i</span><span class="s3">}</span><span class="s5">) == </span><span class="s3">{</span><span class="s1">d</span><span class="s3">}</span><span class="s5">'</span><span class="s1">]</span>
                            <span class="s3">else</span><span class="s1">:</span>
                                <span class="s0"># d is a non-linear function on v,</span>
                                <span class="s0"># hence, v must be a required input</span>
                                <span class="s0"># argument that n will depend on</span>
                                <span class="s1">is_required = </span><span class="s3">True</span>
                                <span class="s3">if </span><span class="s5">'intent' </span><span class="s3">not in </span><span class="s1">vars[v]:</span>
                                    <span class="s1">vars[v][</span><span class="s5">'intent'</span><span class="s1">] = []</span>
                                <span class="s3">if </span><span class="s5">'in' </span><span class="s3">not in </span><span class="s1">vars[v][</span><span class="s5">'intent'</span><span class="s1">]:</span>
                                    <span class="s1">vars[v][</span><span class="s5">'intent'</span><span class="s1">].append(</span><span class="s5">'in'</span><span class="s1">)</span>
                                <span class="s0"># v needs to be initialized before n</span>
                                <span class="s1">n_deps.append(v)</span>
                                <span class="s1">n_checks.append(</span>
                                    <span class="s5">f'shape(</span><span class="s3">{</span><span class="s1">n</span><span class="s3">}</span><span class="s5">, </span><span class="s3">{</span><span class="s1">i</span><span class="s3">}</span><span class="s5">) == </span><span class="s3">{</span><span class="s1">d</span><span class="s3">}</span><span class="s5">'</span><span class="s1">)</span>
                            <span class="s1">v_attr = vars[v].get(</span><span class="s5">'attrspec'</span><span class="s3">, </span><span class="s1">[])</span>
                            <span class="s3">if not </span><span class="s1">(</span><span class="s5">'optional' </span><span class="s3">in </span><span class="s1">v_attr</span>
                                    <span class="s3">or </span><span class="s5">'required' </span><span class="s3">in </span><span class="s1">v_attr):</span>
                                <span class="s1">v_attr.append(</span>
                                    <span class="s5">'required' </span><span class="s3">if </span><span class="s1">is_required </span><span class="s3">else </span><span class="s5">'optional'</span><span class="s1">)</span>
                            <span class="s3">if </span><span class="s1">v_attr:</span>
                                <span class="s1">vars[v][</span><span class="s5">'attrspec'</span><span class="s1">] = v_attr</span>
                    <span class="s3">if </span><span class="s1">coeffs_and_deps </span><span class="s3">is not None</span><span class="s1">:</span>
                        <span class="s0"># extend v dependencies with ones specified in attrspec</span>
                        <span class="s3">for </span><span class="s1">v</span><span class="s3">, </span><span class="s1">(solver</span><span class="s3">, </span><span class="s1">deps) </span><span class="s3">in </span><span class="s1">coeffs_and_deps.items():</span>
                            <span class="s1">v_deps = vars[v].get(</span><span class="s5">'depend'</span><span class="s3">, </span><span class="s1">[])</span>
                            <span class="s3">for </span><span class="s1">aa </span><span class="s3">in </span><span class="s1">vars[v].get(</span><span class="s5">'attrspec'</span><span class="s3">, </span><span class="s1">[]):</span>
                                <span class="s3">if </span><span class="s1">aa.startswith(</span><span class="s5">'depend'</span><span class="s1">):</span>
                                    <span class="s1">aa = </span><span class="s5">''</span><span class="s1">.join(aa.split())</span>
                                    <span class="s1">v_deps.extend(aa[</span><span class="s4">7</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">].split(</span><span class="s5">','</span><span class="s1">))</span>
                            <span class="s3">if </span><span class="s1">v_deps:</span>
                                <span class="s1">vars[v][</span><span class="s5">'depend'</span><span class="s1">] = list(set(v_deps))</span>
                            <span class="s3">if </span><span class="s1">n </span><span class="s3">not in </span><span class="s1">v_deps:</span>
                                <span class="s1">n_deps.append(v)</span>
            <span class="s3">elif </span><span class="s1">isstring(vars[n]):</span>
                <span class="s3">if </span><span class="s5">'charselector' </span><span class="s3">in </span><span class="s1">vars[n]:</span>
                    <span class="s3">if </span><span class="s5">'*' </span><span class="s3">in </span><span class="s1">vars[n][</span><span class="s5">'charselector'</span><span class="s1">]:</span>
                        <span class="s1">length = _eval_length(vars[n][</span><span class="s5">'charselector'</span><span class="s1">][</span><span class="s5">'*'</span><span class="s1">]</span><span class="s3">,</span>
                                              <span class="s1">params)</span>
                        <span class="s1">vars[n][</span><span class="s5">'charselector'</span><span class="s1">][</span><span class="s5">'*'</span><span class="s1">] = length</span>
                    <span class="s3">elif </span><span class="s5">'len' </span><span class="s3">in </span><span class="s1">vars[n][</span><span class="s5">'charselector'</span><span class="s1">]:</span>
                        <span class="s1">length = _eval_length(vars[n][</span><span class="s5">'charselector'</span><span class="s1">][</span><span class="s5">'len'</span><span class="s1">]</span><span class="s3">,</span>
                                              <span class="s1">params)</span>
                        <span class="s3">del </span><span class="s1">vars[n][</span><span class="s5">'charselector'</span><span class="s1">][</span><span class="s5">'len'</span><span class="s1">]</span>
                        <span class="s1">vars[n][</span><span class="s5">'charselector'</span><span class="s1">][</span><span class="s5">'*'</span><span class="s1">] = length</span>
            <span class="s3">if </span><span class="s1">n_checks:</span>
                <span class="s1">vars[n][</span><span class="s5">'check'</span><span class="s1">] = n_checks</span>
            <span class="s3">if </span><span class="s1">n_deps:</span>
                <span class="s1">vars[n][</span><span class="s5">'depend'</span><span class="s1">] = list(set(n_deps))</span>

        <span class="s3">if </span><span class="s5">'=' </span><span class="s3">in </span><span class="s1">vars[n]:</span>
            <span class="s3">if </span><span class="s5">'attrspec' </span><span class="s3">not in </span><span class="s1">vars[n]:</span>
                <span class="s1">vars[n][</span><span class="s5">'attrspec'</span><span class="s1">] = []</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s5">'optional' </span><span class="s3">not in </span><span class="s1">vars[n][</span><span class="s5">'attrspec'</span><span class="s1">]) </span><span class="s3">and </span><span class="s1">\</span>
               <span class="s1">(</span><span class="s5">'required' </span><span class="s3">not in </span><span class="s1">vars[n][</span><span class="s5">'attrspec'</span><span class="s1">]):</span>
                <span class="s1">vars[n][</span><span class="s5">'attrspec'</span><span class="s1">].append(</span><span class="s5">'optional'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s5">'depend' </span><span class="s3">not in </span><span class="s1">vars[n]:</span>
                <span class="s1">vars[n][</span><span class="s5">'depend'</span><span class="s1">] = []</span>
                <span class="s3">for </span><span class="s1">v</span><span class="s3">, </span><span class="s1">m </span><span class="s3">in </span><span class="s1">list(dep_matches.items()):</span>
                    <span class="s3">if </span><span class="s1">m(vars[n][</span><span class="s5">'='</span><span class="s1">]):</span>
                        <span class="s1">vars[n][</span><span class="s5">'depend'</span><span class="s1">].append(v)</span>
                <span class="s3">if not </span><span class="s1">vars[n][</span><span class="s5">'depend'</span><span class="s1">]:</span>
                    <span class="s3">del </span><span class="s1">vars[n][</span><span class="s5">'depend'</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">isscalar(vars[n]):</span>
                <span class="s1">vars[n][</span><span class="s5">'='</span><span class="s1">] = _eval_scalar(vars[n][</span><span class="s5">'='</span><span class="s1">]</span><span class="s3">, </span><span class="s1">params)</span>

    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">list(vars.keys()):</span>
        <span class="s3">if </span><span class="s1">n == block[</span><span class="s5">'name'</span><span class="s1">]:  </span><span class="s0"># n is block name</span>
            <span class="s3">if </span><span class="s5">'note' </span><span class="s3">in </span><span class="s1">vars[n]:</span>
                <span class="s1">block[</span><span class="s5">'note'</span><span class="s1">] = vars[n][</span><span class="s5">'note'</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">block[</span><span class="s5">'block'</span><span class="s1">] == </span><span class="s5">'function'</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s5">'result' </span><span class="s3">in </span><span class="s1">block </span><span class="s3">and </span><span class="s1">block[</span><span class="s5">'result'</span><span class="s1">] </span><span class="s3">in </span><span class="s1">vars:</span>
                    <span class="s1">vars[n] = appenddecl(vars[n]</span><span class="s3">, </span><span class="s1">vars[block[</span><span class="s5">'result'</span><span class="s1">]])</span>
                <span class="s3">if </span><span class="s5">'prefix' </span><span class="s3">in </span><span class="s1">block:</span>
                    <span class="s1">pr = block[</span><span class="s5">'prefix'</span><span class="s1">]</span>
                    <span class="s1">pr1 = pr.replace(</span><span class="s5">'pure'</span><span class="s3">, </span><span class="s5">''</span><span class="s1">)</span>
                    <span class="s1">ispure = (</span><span class="s3">not </span><span class="s1">pr == pr1)</span>
                    <span class="s1">pr = pr1.replace(</span><span class="s5">'recursive'</span><span class="s3">, </span><span class="s5">''</span><span class="s1">)</span>
                    <span class="s1">isrec = (</span><span class="s3">not </span><span class="s1">pr == pr1)</span>
                    <span class="s1">m = typespattern[</span><span class="s4">0</span><span class="s1">].match(pr)</span>
                    <span class="s3">if </span><span class="s1">m:</span>
                        <span class="s1">typespec</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">edecl = cracktypespec0(</span>
                            <span class="s1">m.group(</span><span class="s5">'this'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">m.group(</span><span class="s5">'after'</span><span class="s1">))</span>
                        <span class="s1">kindselect</span><span class="s3">, </span><span class="s1">charselect</span><span class="s3">, </span><span class="s1">typename = cracktypespec(</span>
                            <span class="s1">typespec</span><span class="s3">, </span><span class="s1">selector)</span>
                        <span class="s1">vars[n][</span><span class="s5">'typespec'</span><span class="s1">] = typespec</span>
                        <span class="s3">if </span><span class="s1">kindselect:</span>
                            <span class="s3">if </span><span class="s5">'kind' </span><span class="s3">in </span><span class="s1">kindselect:</span>
                                <span class="s3">try</span><span class="s1">:</span>
                                    <span class="s1">kindselect[</span><span class="s5">'kind'</span><span class="s1">] = eval(</span>
                                        <span class="s1">kindselect[</span><span class="s5">'kind'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">{}</span><span class="s3">, </span><span class="s1">params)</span>
                                <span class="s3">except </span><span class="s1">Exception:</span>
                                    <span class="s3">pass</span>
                            <span class="s1">vars[n][</span><span class="s5">'kindselector'</span><span class="s1">] = kindselect</span>
                        <span class="s3">if </span><span class="s1">charselect:</span>
                            <span class="s1">vars[n][</span><span class="s5">'charselector'</span><span class="s1">] = charselect</span>
                        <span class="s3">if </span><span class="s1">typename:</span>
                            <span class="s1">vars[n][</span><span class="s5">'typename'</span><span class="s1">] = typename</span>
                        <span class="s3">if </span><span class="s1">ispure:</span>
                            <span class="s1">vars[n] = setattrspec(vars[n]</span><span class="s3">, </span><span class="s5">'pure'</span><span class="s1">)</span>
                        <span class="s3">if </span><span class="s1">isrec:</span>
                            <span class="s1">vars[n] = setattrspec(vars[n]</span><span class="s3">, </span><span class="s5">'recursive'</span><span class="s1">)</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">outmess(</span>
                            <span class="s5">'analyzevars: prefix (%s) were not used</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% repr(block[</span><span class="s5">'prefix'</span><span class="s1">]))</span>
    <span class="s3">if not </span><span class="s1">block[</span><span class="s5">'block'</span><span class="s1">] </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'module'</span><span class="s3">, </span><span class="s5">'pythonmodule'</span><span class="s3">, </span><span class="s5">'python module'</span><span class="s3">, </span><span class="s5">'block data'</span><span class="s1">]:</span>
        <span class="s3">if </span><span class="s5">'commonvars' </span><span class="s3">in </span><span class="s1">block:</span>
            <span class="s1">neededvars = copy.copy(block[</span><span class="s5">'args'</span><span class="s1">] + block[</span><span class="s5">'commonvars'</span><span class="s1">])</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">neededvars = copy.copy(block[</span><span class="s5">'args'</span><span class="s1">])</span>
        <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">list(vars.keys()):</span>
            <span class="s3">if </span><span class="s1">l_or(isintent_callback</span><span class="s3">, </span><span class="s1">isintent_aux)(vars[n]):</span>
                <span class="s1">neededvars.append(n)</span>
        <span class="s3">if </span><span class="s5">'entry' </span><span class="s3">in </span><span class="s1">block:</span>
            <span class="s1">neededvars.extend(list(block[</span><span class="s5">'entry'</span><span class="s1">].keys()))</span>
            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(block[</span><span class="s5">'entry'</span><span class="s1">].keys()):</span>
                <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'entry'</span><span class="s1">][k]:</span>
                    <span class="s3">if </span><span class="s1">n </span><span class="s3">not in </span><span class="s1">neededvars:</span>
                        <span class="s1">neededvars.append(n)</span>
        <span class="s3">if </span><span class="s1">block[</span><span class="s5">'block'</span><span class="s1">] == </span><span class="s5">'function'</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s5">'result' </span><span class="s3">in </span><span class="s1">block:</span>
                <span class="s1">neededvars.append(block[</span><span class="s5">'result'</span><span class="s1">])</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">neededvars.append(block[</span><span class="s5">'name'</span><span class="s1">])</span>
        <span class="s3">if </span><span class="s1">block[</span><span class="s5">'block'</span><span class="s1">] </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'subroutine'</span><span class="s3">, </span><span class="s5">'function'</span><span class="s1">]:</span>
            <span class="s1">name = block[</span><span class="s5">'name'</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">vars </span><span class="s3">and </span><span class="s5">'intent' </span><span class="s3">in </span><span class="s1">vars[name]:</span>
                <span class="s1">block[</span><span class="s5">'intent'</span><span class="s1">] = vars[name][</span><span class="s5">'intent'</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">block[</span><span class="s5">'block'</span><span class="s1">] == </span><span class="s5">'type'</span><span class="s1">:</span>
            <span class="s1">neededvars.extend(list(vars.keys()))</span>
        <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">list(vars.keys()):</span>
            <span class="s3">if </span><span class="s1">n </span><span class="s3">not in </span><span class="s1">neededvars:</span>
                <span class="s3">del </span><span class="s1">vars[n]</span>
    <span class="s3">return </span><span class="s1">vars</span>

<span class="s1">analyzeargs_re_1 = re.compile(</span><span class="s5">r'\A[a-z]+[\w$]*\Z'</span><span class="s3">, </span><span class="s1">re.I)</span>


<span class="s3">def </span><span class="s1">expr2name(a</span><span class="s3">, </span><span class="s1">block</span><span class="s3">, </span><span class="s1">args=[]):</span>
    <span class="s1">orig_a = a</span>
    <span class="s1">a_is_expr = </span><span class="s3">not </span><span class="s1">analyzeargs_re_1.match(a)</span>
    <span class="s3">if </span><span class="s1">a_is_expr:  </span><span class="s0"># `a` is an expression</span>
        <span class="s1">implicitrules</span><span class="s3">, </span><span class="s1">attrrules = buildimplicitrules(block)</span>
        <span class="s1">at = determineexprtype(a</span><span class="s3">, </span><span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">implicitrules)</span>
        <span class="s1">na = </span><span class="s5">'e_'</span>
        <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">a:</span>
            <span class="s1">c = c.lower()</span>
            <span class="s3">if </span><span class="s1">c </span><span class="s3">not in </span><span class="s1">string.ascii_lowercase + string.digits:</span>
                <span class="s1">c = </span><span class="s5">'_'</span>
            <span class="s1">na = na + c</span>
        <span class="s3">if </span><span class="s1">na[-</span><span class="s4">1</span><span class="s1">] == </span><span class="s5">'_'</span><span class="s1">:</span>
            <span class="s1">na = na + </span><span class="s5">'e'</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">na = na + </span><span class="s5">'_e'</span>
        <span class="s1">a = na</span>
        <span class="s3">while </span><span class="s1">a </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">] </span><span class="s3">or </span><span class="s1">a </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'args'</span><span class="s1">]:</span>
            <span class="s1">a = a + </span><span class="s5">'r'</span>
    <span class="s3">if </span><span class="s1">a </span><span class="s3">in </span><span class="s1">args:</span>
        <span class="s1">k = </span><span class="s4">1</span>
        <span class="s3">while </span><span class="s1">a + str(k) </span><span class="s3">in </span><span class="s1">args:</span>
            <span class="s1">k = k + </span><span class="s4">1</span>
        <span class="s1">a = a + str(k)</span>
    <span class="s3">if </span><span class="s1">a_is_expr:</span>
        <span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">][a] = at</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">a </span><span class="s3">not in </span><span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">]:</span>
            <span class="s3">if </span><span class="s1">orig_a </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">]:</span>
                <span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">][a] = block[</span><span class="s5">'vars'</span><span class="s1">][orig_a]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">][a] = {}</span>
        <span class="s3">if </span><span class="s5">'externals' </span><span class="s3">in </span><span class="s1">block </span><span class="s3">and </span><span class="s1">orig_a </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'externals'</span><span class="s1">] + block[</span><span class="s5">'interfaced'</span><span class="s1">]:</span>
            <span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">][a] = setattrspec(block[</span><span class="s5">'vars'</span><span class="s1">][a]</span><span class="s3">, </span><span class="s5">'external'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">a</span>


<span class="s3">def </span><span class="s1">analyzeargs(block):</span>
    <span class="s1">setmesstext(block)</span>
    <span class="s1">implicitrules</span><span class="s3">, </span><span class="s1">_ = buildimplicitrules(block)</span>
    <span class="s3">if </span><span class="s5">'args' </span><span class="s3">not in </span><span class="s1">block:</span>
        <span class="s1">block[</span><span class="s5">'args'</span><span class="s1">] = []</span>
    <span class="s1">args = []</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'args'</span><span class="s1">]:</span>
        <span class="s1">a = expr2name(a</span><span class="s3">, </span><span class="s1">block</span><span class="s3">, </span><span class="s1">args)</span>
        <span class="s1">args.append(a)</span>
    <span class="s1">block[</span><span class="s5">'args'</span><span class="s1">] = args</span>
    <span class="s3">if </span><span class="s5">'entry' </span><span class="s3">in </span><span class="s1">block:</span>
        <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">args1 </span><span class="s3">in </span><span class="s1">list(block[</span><span class="s5">'entry'</span><span class="s1">].items()):</span>
            <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">args1:</span>
                <span class="s3">if </span><span class="s1">a </span><span class="s3">not in </span><span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">]:</span>
                    <span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">][a] = {}</span>

    <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'body'</span><span class="s1">]:</span>
        <span class="s3">if </span><span class="s1">b[</span><span class="s5">'name'</span><span class="s1">] </span><span class="s3">in </span><span class="s1">args:</span>
            <span class="s3">if </span><span class="s5">'externals' </span><span class="s3">not in </span><span class="s1">block:</span>
                <span class="s1">block[</span><span class="s5">'externals'</span><span class="s1">] = []</span>
            <span class="s3">if </span><span class="s1">b[</span><span class="s5">'name'</span><span class="s1">] </span><span class="s3">not in </span><span class="s1">block[</span><span class="s5">'externals'</span><span class="s1">]:</span>
                <span class="s1">block[</span><span class="s5">'externals'</span><span class="s1">].append(b[</span><span class="s5">'name'</span><span class="s1">])</span>
    <span class="s3">if </span><span class="s5">'result' </span><span class="s3">in </span><span class="s1">block </span><span class="s3">and </span><span class="s1">block[</span><span class="s5">'result'</span><span class="s1">] </span><span class="s3">not in </span><span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">]:</span>
        <span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">][block[</span><span class="s5">'result'</span><span class="s1">]] = {}</span>
    <span class="s3">return </span><span class="s1">block</span>

<span class="s1">determineexprtype_re_1 = re.compile(</span><span class="s5">r'\A\(.+?,.+?\)\Z'</span><span class="s3">, </span><span class="s1">re.I)</span>
<span class="s1">determineexprtype_re_2 = re.compile(</span><span class="s5">r'\A[+-]?\d+(_(?P&lt;name&gt;\w+)|)\Z'</span><span class="s3">, </span><span class="s1">re.I)</span>
<span class="s1">determineexprtype_re_3 = re.compile(</span>
    <span class="s5">r'\A[+-]?[\d.]+[-\d+de.]*(_(?P&lt;name&gt;\w+)|)\Z'</span><span class="s3">, </span><span class="s1">re.I)</span>
<span class="s1">determineexprtype_re_4 = re.compile(</span><span class="s5">r'\A\(.*\)\Z'</span><span class="s3">, </span><span class="s1">re.I)</span>
<span class="s1">determineexprtype_re_5 = re.compile(</span><span class="s5">r'\A(?P&lt;name&gt;\w+)\s*\(.*?\)\s*\Z'</span><span class="s3">, </span><span class="s1">re.I)</span>


<span class="s3">def </span><span class="s1">_ensure_exprdict(r):</span>
    <span class="s3">if </span><span class="s1">isinstance(r</span><span class="s3">, </span><span class="s1">int):</span>
        <span class="s3">return </span><span class="s1">{</span><span class="s5">'typespec'</span><span class="s1">: </span><span class="s5">'integer'</span><span class="s1">}</span>
    <span class="s3">if </span><span class="s1">isinstance(r</span><span class="s3">, </span><span class="s1">float):</span>
        <span class="s3">return </span><span class="s1">{</span><span class="s5">'typespec'</span><span class="s1">: </span><span class="s5">'real'</span><span class="s1">}</span>
    <span class="s3">if </span><span class="s1">isinstance(r</span><span class="s3">, </span><span class="s1">complex):</span>
        <span class="s3">return </span><span class="s1">{</span><span class="s5">'typespec'</span><span class="s1">: </span><span class="s5">'complex'</span><span class="s1">}</span>
    <span class="s3">if </span><span class="s1">isinstance(r</span><span class="s3">, </span><span class="s1">dict):</span>
        <span class="s3">return </span><span class="s1">r</span>
    <span class="s3">raise </span><span class="s1">AssertionError(repr(r))</span>


<span class="s3">def </span><span class="s1">determineexprtype(expr</span><span class="s3">, </span><span class="s1">vars</span><span class="s3">, </span><span class="s1">rules={}):</span>
    <span class="s3">if </span><span class="s1">expr </span><span class="s3">in </span><span class="s1">vars:</span>
        <span class="s3">return </span><span class="s1">_ensure_exprdict(vars[expr])</span>
    <span class="s1">expr = expr.strip()</span>
    <span class="s3">if </span><span class="s1">determineexprtype_re_1.match(expr):</span>
        <span class="s3">return </span><span class="s1">{</span><span class="s5">'typespec'</span><span class="s1">: </span><span class="s5">'complex'</span><span class="s1">}</span>
    <span class="s1">m = determineexprtype_re_2.match(expr)</span>
    <span class="s3">if </span><span class="s1">m:</span>
        <span class="s3">if </span><span class="s5">'name' </span><span class="s3">in </span><span class="s1">m.groupdict() </span><span class="s3">and </span><span class="s1">m.group(</span><span class="s5">'name'</span><span class="s1">):</span>
            <span class="s1">outmess(</span>
                <span class="s5">'determineexprtype: selected kind types not supported (%s)</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% repr(expr))</span>
        <span class="s3">return </span><span class="s1">{</span><span class="s5">'typespec'</span><span class="s1">: </span><span class="s5">'integer'</span><span class="s1">}</span>
    <span class="s1">m = determineexprtype_re_3.match(expr)</span>
    <span class="s3">if </span><span class="s1">m:</span>
        <span class="s3">if </span><span class="s5">'name' </span><span class="s3">in </span><span class="s1">m.groupdict() </span><span class="s3">and </span><span class="s1">m.group(</span><span class="s5">'name'</span><span class="s1">):</span>
            <span class="s1">outmess(</span>
                <span class="s5">'determineexprtype: selected kind types not supported (%s)</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% repr(expr))</span>
        <span class="s3">return </span><span class="s1">{</span><span class="s5">'typespec'</span><span class="s1">: </span><span class="s5">'real'</span><span class="s1">}</span>
    <span class="s3">for </span><span class="s1">op </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'+'</span><span class="s3">, </span><span class="s5">'-'</span><span class="s3">, </span><span class="s5">'*'</span><span class="s3">, </span><span class="s5">'/'</span><span class="s1">]:</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">[x.strip() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma(expr</span><span class="s3">, </span><span class="s1">comma=op).split(</span><span class="s5">'@' </span><span class="s1">+ op + </span><span class="s5">'@'</span><span class="s1">)]:</span>
            <span class="s3">if </span><span class="s1">e </span><span class="s3">in </span><span class="s1">vars:</span>
                <span class="s3">return </span><span class="s1">_ensure_exprdict(vars[e])</span>
    <span class="s1">t = {}</span>
    <span class="s3">if </span><span class="s1">determineexprtype_re_4.match(expr):  </span><span class="s0"># in parenthesis</span>
        <span class="s1">t = determineexprtype(expr[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">vars</span><span class="s3">, </span><span class="s1">rules)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">m = determineexprtype_re_5.match(expr)</span>
        <span class="s3">if </span><span class="s1">m:</span>
            <span class="s1">rn = m.group(</span><span class="s5">'name'</span><span class="s1">)</span>
            <span class="s1">t = determineexprtype(m.group(</span><span class="s5">'name'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">vars</span><span class="s3">, </span><span class="s1">rules)</span>
            <span class="s3">if </span><span class="s1">t </span><span class="s3">and </span><span class="s5">'attrspec' </span><span class="s3">in </span><span class="s1">t:</span>
                <span class="s3">del </span><span class="s1">t[</span><span class="s5">'attrspec'</span><span class="s1">]</span>
            <span class="s3">if not </span><span class="s1">t:</span>
                <span class="s3">if </span><span class="s1">rn[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">in </span><span class="s1">rules:</span>
                    <span class="s3">return </span><span class="s1">_ensure_exprdict(rules[rn[</span><span class="s4">0</span><span class="s1">]])</span>
    <span class="s3">if </span><span class="s1">expr[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">in </span><span class="s5">'</span><span class="s3">\'</span><span class="s5">&quot;'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">{</span><span class="s5">'typespec'</span><span class="s1">: </span><span class="s5">'character'</span><span class="s3">, </span><span class="s5">'charselector'</span><span class="s1">: {</span><span class="s5">'*'</span><span class="s1">: </span><span class="s5">'*'</span><span class="s1">}}</span>
    <span class="s3">if not </span><span class="s1">t:</span>
        <span class="s1">outmess(</span>
            <span class="s5">'determineexprtype: could not determine expressions (%s) type.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (repr(expr)))</span>
    <span class="s3">return </span><span class="s1">t</span>

<span class="s0">######</span>


<span class="s3">def </span><span class="s1">crack2fortrangen(block</span><span class="s3">, </span><span class="s1">tab=</span><span class="s5">'</span><span class="s3">\n</span><span class="s5">'</span><span class="s3">, </span><span class="s1">as_interface=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s3">global </span><span class="s1">skipfuncs</span><span class="s3">, </span><span class="s1">onlyfuncs</span>

    <span class="s1">setmesstext(block)</span>
    <span class="s1">ret = </span><span class="s5">''</span>
    <span class="s3">if </span><span class="s1">isinstance(block</span><span class="s3">, </span><span class="s1">list):</span>
        <span class="s3">for </span><span class="s1">g </span><span class="s3">in </span><span class="s1">block:</span>
            <span class="s3">if </span><span class="s1">g </span><span class="s3">and </span><span class="s1">g[</span><span class="s5">'block'</span><span class="s1">] </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'function'</span><span class="s3">, </span><span class="s5">'subroutine'</span><span class="s1">]:</span>
                <span class="s3">if </span><span class="s1">g[</span><span class="s5">'name'</span><span class="s1">] </span><span class="s3">in </span><span class="s1">skipfuncs:</span>
                    <span class="s3">continue</span>
                <span class="s3">if </span><span class="s1">onlyfuncs </span><span class="s3">and </span><span class="s1">g[</span><span class="s5">'name'</span><span class="s1">] </span><span class="s3">not in </span><span class="s1">onlyfuncs:</span>
                    <span class="s3">continue</span>
            <span class="s1">ret = ret + crack2fortrangen(g</span><span class="s3">, </span><span class="s1">tab</span><span class="s3">, </span><span class="s1">as_interface=as_interface)</span>
        <span class="s3">return </span><span class="s1">ret</span>
    <span class="s1">prefix = </span><span class="s5">''</span>
    <span class="s1">name = </span><span class="s5">''</span>
    <span class="s1">args = </span><span class="s5">''</span>
    <span class="s1">blocktype = block[</span><span class="s5">'block'</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">blocktype == </span><span class="s5">'program'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s5">''</span>
    <span class="s1">argsl = []</span>
    <span class="s3">if </span><span class="s5">'name' </span><span class="s3">in </span><span class="s1">block:</span>
        <span class="s1">name = block[</span><span class="s5">'name'</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s5">'args' </span><span class="s3">in </span><span class="s1">block:</span>
        <span class="s1">vars = block[</span><span class="s5">'vars'</span><span class="s1">]</span>
        <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'args'</span><span class="s1">]:</span>
            <span class="s1">a = expr2name(a</span><span class="s3">, </span><span class="s1">block</span><span class="s3">, </span><span class="s1">argsl)</span>
            <span class="s3">if not </span><span class="s1">isintent_callback(vars[a]):</span>
                <span class="s1">argsl.append(a)</span>
        <span class="s3">if </span><span class="s1">block[</span><span class="s5">'block'</span><span class="s1">] == </span><span class="s5">'function' </span><span class="s3">or </span><span class="s1">argsl:</span>
            <span class="s1">args = </span><span class="s5">'(%s)' </span><span class="s1">% </span><span class="s5">','</span><span class="s1">.join(argsl)</span>
    <span class="s1">f2pyenhancements = </span><span class="s5">''</span>
    <span class="s3">if </span><span class="s5">'f2pyenhancements' </span><span class="s3">in </span><span class="s1">block:</span>
        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(block[</span><span class="s5">'f2pyenhancements'</span><span class="s1">].keys()):</span>
            <span class="s1">f2pyenhancements = </span><span class="s5">'%s%s%s %s' </span><span class="s1">% (</span>
                <span class="s1">f2pyenhancements</span><span class="s3">, </span><span class="s1">tab + tabchar</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">block[</span><span class="s5">'f2pyenhancements'</span><span class="s1">][k])</span>
    <span class="s1">intent_lst = block.get(</span><span class="s5">'intent'</span><span class="s3">, </span><span class="s1">[])[:]</span>
    <span class="s3">if </span><span class="s1">blocktype == </span><span class="s5">'function' </span><span class="s3">and </span><span class="s5">'callback' </span><span class="s3">in </span><span class="s1">intent_lst:</span>
        <span class="s1">intent_lst.remove(</span><span class="s5">'callback'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">intent_lst:</span>
        <span class="s1">f2pyenhancements = </span><span class="s5">'%s%sintent(%s) %s' </span><span class="s1">%\</span>
                           <span class="s1">(f2pyenhancements</span><span class="s3">, </span><span class="s1">tab + tabchar</span><span class="s3">,</span>
                            <span class="s5">','</span><span class="s1">.join(intent_lst)</span><span class="s3">, </span><span class="s1">name)</span>
    <span class="s1">use = </span><span class="s5">''</span>
    <span class="s3">if </span><span class="s5">'use' </span><span class="s3">in </span><span class="s1">block:</span>
        <span class="s1">use = use2fortran(block[</span><span class="s5">'use'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">tab + tabchar)</span>
    <span class="s1">common = </span><span class="s5">''</span>
    <span class="s3">if </span><span class="s5">'common' </span><span class="s3">in </span><span class="s1">block:</span>
        <span class="s1">common = common2fortran(block[</span><span class="s5">'common'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">tab + tabchar)</span>
    <span class="s3">if </span><span class="s1">name == </span><span class="s5">'unknown_interface'</span><span class="s1">:</span>
        <span class="s1">name = </span><span class="s5">''</span>
    <span class="s1">result = </span><span class="s5">''</span>
    <span class="s3">if </span><span class="s5">'result' </span><span class="s3">in </span><span class="s1">block:</span>
        <span class="s1">result = </span><span class="s5">' result (%s)' </span><span class="s1">% block[</span><span class="s5">'result'</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">block[</span><span class="s5">'result'</span><span class="s1">] </span><span class="s3">not in </span><span class="s1">argsl:</span>
            <span class="s1">argsl.append(block[</span><span class="s5">'result'</span><span class="s1">])</span>
    <span class="s1">body = crack2fortrangen(block[</span><span class="s5">'body'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">tab + tabchar</span><span class="s3">, </span><span class="s1">as_interface=as_interface)</span>
    <span class="s1">vars = vars2fortran(</span>
        <span class="s1">block</span><span class="s3">, </span><span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">argsl</span><span class="s3">, </span><span class="s1">tab + tabchar</span><span class="s3">, </span><span class="s1">as_interface=as_interface)</span>
    <span class="s1">mess = </span><span class="s5">''</span>
    <span class="s3">if </span><span class="s5">'from' </span><span class="s3">in </span><span class="s1">block </span><span class="s3">and not </span><span class="s1">as_interface:</span>
        <span class="s1">mess = </span><span class="s5">'! in %s' </span><span class="s1">% block[</span><span class="s5">'from'</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s5">'entry' </span><span class="s3">in </span><span class="s1">block:</span>
        <span class="s1">entry_stmts = </span><span class="s5">''</span>
        <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">i </span><span class="s3">in </span><span class="s1">list(block[</span><span class="s5">'entry'</span><span class="s1">].items()):</span>
            <span class="s1">entry_stmts = </span><span class="s5">'%s%sentry %s(%s)' </span><span class="s1">\</span>
                          <span class="s1">% (entry_stmts</span><span class="s3">, </span><span class="s1">tab + tabchar</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s5">','</span><span class="s1">.join(i))</span>
        <span class="s1">body = body + entry_stmts</span>
    <span class="s3">if </span><span class="s1">blocktype == </span><span class="s5">'block data' </span><span class="s3">and </span><span class="s1">name == </span><span class="s5">'_BLOCK_DATA_'</span><span class="s1">:</span>
        <span class="s1">name = </span><span class="s5">''</span>
    <span class="s1">ret = </span><span class="s5">'%s%s%s %s%s%s %s%s%s%s%s%s%send %s %s' </span><span class="s1">% (</span>
        <span class="s1">tab</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">blocktype</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">result</span><span class="s3">, </span><span class="s1">mess</span><span class="s3">, </span><span class="s1">f2pyenhancements</span><span class="s3">, </span><span class="s1">use</span><span class="s3">, </span><span class="s1">vars</span><span class="s3">, </span><span class="s1">common</span><span class="s3">, </span><span class="s1">body</span><span class="s3">, </span><span class="s1">tab</span><span class="s3">, </span><span class="s1">blocktype</span><span class="s3">, </span><span class="s1">name)</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">common2fortran(common</span><span class="s3">, </span><span class="s1">tab=</span><span class="s5">''</span><span class="s1">):</span>
    <span class="s1">ret = </span><span class="s5">''</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(common.keys()):</span>
        <span class="s3">if </span><span class="s1">k == </span><span class="s5">'_BLNK_'</span><span class="s1">:</span>
            <span class="s1">ret = </span><span class="s5">'%s%scommon %s' </span><span class="s1">% (ret</span><span class="s3">, </span><span class="s1">tab</span><span class="s3">, </span><span class="s5">','</span><span class="s1">.join(common[k]))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">ret = </span><span class="s5">'%s%scommon /%s/ %s' </span><span class="s1">% (ret</span><span class="s3">, </span><span class="s1">tab</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s5">','</span><span class="s1">.join(common[k]))</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">use2fortran(use</span><span class="s3">, </span><span class="s1">tab=</span><span class="s5">''</span><span class="s1">):</span>
    <span class="s1">ret = </span><span class="s5">''</span>
    <span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">list(use.keys()):</span>
        <span class="s1">ret = </span><span class="s5">'%s%suse %s,' </span><span class="s1">% (ret</span><span class="s3">, </span><span class="s1">tab</span><span class="s3">, </span><span class="s1">m)</span>
        <span class="s3">if </span><span class="s1">use[m] == {}:</span>
            <span class="s3">if </span><span class="s1">ret </span><span class="s3">and </span><span class="s1">ret[-</span><span class="s4">1</span><span class="s1">] == </span><span class="s5">','</span><span class="s1">:</span>
                <span class="s1">ret = ret[:-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s3">continue</span>
        <span class="s3">if </span><span class="s5">'only' </span><span class="s3">in </span><span class="s1">use[m] </span><span class="s3">and </span><span class="s1">use[m][</span><span class="s5">'only'</span><span class="s1">]:</span>
            <span class="s1">ret = </span><span class="s5">'%s only:' </span><span class="s1">% (ret)</span>
        <span class="s3">if </span><span class="s5">'map' </span><span class="s3">in </span><span class="s1">use[m] </span><span class="s3">and </span><span class="s1">use[m][</span><span class="s5">'map'</span><span class="s1">]:</span>
            <span class="s1">c = </span><span class="s5">' '</span>
            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list(use[m][</span><span class="s5">'map'</span><span class="s1">].keys()):</span>
                <span class="s3">if </span><span class="s1">k == use[m][</span><span class="s5">'map'</span><span class="s1">][k]:</span>
                    <span class="s1">ret = </span><span class="s5">'%s%s%s' </span><span class="s1">% (ret</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k)</span>
                    <span class="s1">c = </span><span class="s5">','</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">ret = </span><span class="s5">'%s%s%s=&gt;%s' </span><span class="s1">% (ret</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">use[m][</span><span class="s5">'map'</span><span class="s1">][k])</span>
                    <span class="s1">c = </span><span class="s5">','</span>
        <span class="s3">if </span><span class="s1">ret </span><span class="s3">and </span><span class="s1">ret[-</span><span class="s4">1</span><span class="s1">] == </span><span class="s5">','</span><span class="s1">:</span>
            <span class="s1">ret = ret[:-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">true_intent_list(var):</span>
    <span class="s1">lst = var[</span><span class="s5">'intent'</span><span class="s1">]</span>
    <span class="s1">ret = []</span>
    <span class="s3">for </span><span class="s1">intent </span><span class="s3">in </span><span class="s1">lst:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">f = globals()[</span><span class="s5">'isintent_%s' </span><span class="s1">% intent]</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">pass</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">f(var):</span>
                <span class="s1">ret.append(intent)</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">vars2fortran(block</span><span class="s3">, </span><span class="s1">vars</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">tab=</span><span class="s5">''</span><span class="s3">, </span><span class="s1">as_interface=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    TODO: 
    public sub 
    ... 
    &quot;&quot;&quot;</span>
    <span class="s1">setmesstext(block)</span>
    <span class="s1">ret = </span><span class="s5">''</span>
    <span class="s1">nout = []</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">args:</span>
        <span class="s3">if </span><span class="s1">a </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'vars'</span><span class="s1">]:</span>
            <span class="s1">nout.append(a)</span>
    <span class="s3">if </span><span class="s5">'commonvars' </span><span class="s3">in </span><span class="s1">block:</span>
        <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'commonvars'</span><span class="s1">]:</span>
            <span class="s3">if </span><span class="s1">a </span><span class="s3">in </span><span class="s1">vars:</span>
                <span class="s3">if </span><span class="s1">a </span><span class="s3">not in </span><span class="s1">nout:</span>
                    <span class="s1">nout.append(a)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">errmess(</span>
                    <span class="s5">'vars2fortran: Confused?!: &quot;%s&quot; is not defined in vars.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% a)</span>
    <span class="s3">if </span><span class="s5">'varnames' </span><span class="s3">in </span><span class="s1">block:</span>
        <span class="s1">nout.extend(block[</span><span class="s5">'varnames'</span><span class="s1">])</span>
    <span class="s3">if not </span><span class="s1">as_interface:</span>
        <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">list(vars.keys()):</span>
            <span class="s3">if </span><span class="s1">a </span><span class="s3">not in </span><span class="s1">nout:</span>
                <span class="s1">nout.append(a)</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">nout:</span>
        <span class="s3">if </span><span class="s5">'depend' </span><span class="s3">in </span><span class="s1">vars[a]:</span>
            <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">vars[a][</span><span class="s5">'depend'</span><span class="s1">]:</span>
                <span class="s3">if </span><span class="s1">d </span><span class="s3">in </span><span class="s1">vars </span><span class="s3">and </span><span class="s5">'depend' </span><span class="s3">in </span><span class="s1">vars[d] </span><span class="s3">and </span><span class="s1">a </span><span class="s3">in </span><span class="s1">vars[d][</span><span class="s5">'depend'</span><span class="s1">]:</span>
                    <span class="s1">errmess(</span>
                        <span class="s5">'vars2fortran: Warning: cross-dependence between variables &quot;%s&quot; and &quot;%s&quot;</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% (a</span><span class="s3">, </span><span class="s1">d))</span>
        <span class="s3">if </span><span class="s5">'externals' </span><span class="s3">in </span><span class="s1">block </span><span class="s3">and </span><span class="s1">a </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'externals'</span><span class="s1">]:</span>
            <span class="s3">if </span><span class="s1">isintent_callback(vars[a]):</span>
                <span class="s1">ret = </span><span class="s5">'%s%sintent(callback) %s' </span><span class="s1">% (ret</span><span class="s3">, </span><span class="s1">tab</span><span class="s3">, </span><span class="s1">a)</span>
            <span class="s1">ret = </span><span class="s5">'%s%sexternal %s' </span><span class="s1">% (ret</span><span class="s3">, </span><span class="s1">tab</span><span class="s3">, </span><span class="s1">a)</span>
            <span class="s3">if </span><span class="s1">isoptional(vars[a]):</span>
                <span class="s1">ret = </span><span class="s5">'%s%soptional %s' </span><span class="s1">% (ret</span><span class="s3">, </span><span class="s1">tab</span><span class="s3">, </span><span class="s1">a)</span>
            <span class="s3">if </span><span class="s1">a </span><span class="s3">in </span><span class="s1">vars </span><span class="s3">and </span><span class="s5">'typespec' </span><span class="s3">not in </span><span class="s1">vars[a]:</span>
                <span class="s3">continue</span>
            <span class="s1">cont = </span><span class="s4">1</span>
            <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">block[</span><span class="s5">'body'</span><span class="s1">]:</span>
                <span class="s3">if </span><span class="s1">a == b[</span><span class="s5">'name'</span><span class="s1">] </span><span class="s3">and </span><span class="s1">b[</span><span class="s5">'block'</span><span class="s1">] == </span><span class="s5">'function'</span><span class="s1">:</span>
                    <span class="s1">cont = </span><span class="s4">0</span>
                    <span class="s3">break</span>
            <span class="s3">if </span><span class="s1">cont:</span>
                <span class="s3">continue</span>
        <span class="s3">if </span><span class="s1">a </span><span class="s3">not in </span><span class="s1">vars:</span>
            <span class="s1">show(vars)</span>
            <span class="s1">outmess(</span><span class="s5">'vars2fortran: No definition for argument &quot;%s&quot;.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% a)</span>
            <span class="s3">continue</span>
        <span class="s3">if </span><span class="s1">a == block[</span><span class="s5">'name'</span><span class="s1">]:</span>
            <span class="s3">if </span><span class="s1">block[</span><span class="s5">'block'</span><span class="s1">] != </span><span class="s5">'function' </span><span class="s3">or </span><span class="s1">block.get(</span><span class="s5">'result'</span><span class="s1">):</span>
                <span class="s0"># 1) skip declaring a variable that name matches with</span>
                <span class="s0">#    subroutine name</span>
                <span class="s0"># 2) skip declaring function when its type is</span>
                <span class="s0">#    declared via `result` construction</span>
                <span class="s3">continue</span>
        <span class="s3">if </span><span class="s5">'typespec' </span><span class="s3">not in </span><span class="s1">vars[a]:</span>
            <span class="s3">if </span><span class="s5">'attrspec' </span><span class="s3">in </span><span class="s1">vars[a] </span><span class="s3">and </span><span class="s5">'external' </span><span class="s3">in </span><span class="s1">vars[a][</span><span class="s5">'attrspec'</span><span class="s1">]:</span>
                <span class="s3">if </span><span class="s1">a </span><span class="s3">in </span><span class="s1">args:</span>
                    <span class="s1">ret = </span><span class="s5">'%s%sexternal %s' </span><span class="s1">% (ret</span><span class="s3">, </span><span class="s1">tab</span><span class="s3">, </span><span class="s1">a)</span>
                <span class="s3">continue</span>
            <span class="s1">show(vars[a])</span>
            <span class="s1">outmess(</span><span class="s5">'vars2fortran: No typespec for argument &quot;%s&quot;.</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% a)</span>
            <span class="s3">continue</span>
        <span class="s1">vardef = vars[a][</span><span class="s5">'typespec'</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">vardef == </span><span class="s5">'type' </span><span class="s3">and </span><span class="s5">'typename' </span><span class="s3">in </span><span class="s1">vars[a]:</span>
            <span class="s1">vardef = </span><span class="s5">'%s(%s)' </span><span class="s1">% (vardef</span><span class="s3">, </span><span class="s1">vars[a][</span><span class="s5">'typename'</span><span class="s1">])</span>
        <span class="s1">selector = {}</span>
        <span class="s3">if </span><span class="s5">'kindselector' </span><span class="s3">in </span><span class="s1">vars[a]:</span>
            <span class="s1">selector = vars[a][</span><span class="s5">'kindselector'</span><span class="s1">]</span>
        <span class="s3">elif </span><span class="s5">'charselector' </span><span class="s3">in </span><span class="s1">vars[a]:</span>
            <span class="s1">selector = vars[a][</span><span class="s5">'charselector'</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s5">'*' </span><span class="s3">in </span><span class="s1">selector:</span>
            <span class="s3">if </span><span class="s1">selector[</span><span class="s5">'*'</span><span class="s1">] </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'*'</span><span class="s3">, </span><span class="s5">':'</span><span class="s1">]:</span>
                <span class="s1">vardef = </span><span class="s5">'%s*(%s)' </span><span class="s1">% (vardef</span><span class="s3">, </span><span class="s1">selector[</span><span class="s5">'*'</span><span class="s1">])</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">vardef = </span><span class="s5">'%s*%s' </span><span class="s1">% (vardef</span><span class="s3">, </span><span class="s1">selector[</span><span class="s5">'*'</span><span class="s1">])</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s5">'len' </span><span class="s3">in </span><span class="s1">selector:</span>
                <span class="s1">vardef = </span><span class="s5">'%s(len=%s' </span><span class="s1">% (vardef</span><span class="s3">, </span><span class="s1">selector[</span><span class="s5">'len'</span><span class="s1">])</span>
                <span class="s3">if </span><span class="s5">'kind' </span><span class="s3">in </span><span class="s1">selector:</span>
                    <span class="s1">vardef = </span><span class="s5">'%s,kind=%s)' </span><span class="s1">% (vardef</span><span class="s3">, </span><span class="s1">selector[</span><span class="s5">'kind'</span><span class="s1">])</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">vardef = </span><span class="s5">'%s)' </span><span class="s1">% (vardef)</span>
            <span class="s3">elif </span><span class="s5">'kind' </span><span class="s3">in </span><span class="s1">selector:</span>
                <span class="s1">vardef = </span><span class="s5">'%s(kind=%s)' </span><span class="s1">% (vardef</span><span class="s3">, </span><span class="s1">selector[</span><span class="s5">'kind'</span><span class="s1">])</span>
        <span class="s1">c = </span><span class="s5">' '</span>
        <span class="s3">if </span><span class="s5">'attrspec' </span><span class="s3">in </span><span class="s1">vars[a]:</span>
            <span class="s1">attr = [l </span><span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">vars[a][</span><span class="s5">'attrspec'</span><span class="s1">]</span>
                    <span class="s3">if </span><span class="s1">l </span><span class="s3">not in </span><span class="s1">[</span><span class="s5">'external'</span><span class="s1">]]</span>
            <span class="s3">if </span><span class="s1">attr:</span>
                <span class="s1">vardef = </span><span class="s5">'%s, %s' </span><span class="s1">% (vardef</span><span class="s3">, </span><span class="s5">','</span><span class="s1">.join(attr))</span>
                <span class="s1">c = </span><span class="s5">','</span>
        <span class="s3">if </span><span class="s5">'dimension' </span><span class="s3">in </span><span class="s1">vars[a]:</span>
            <span class="s1">vardef = </span><span class="s5">'%s%sdimension(%s)' </span><span class="s1">% (</span>
                <span class="s1">vardef</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s5">','</span><span class="s1">.join(vars[a][</span><span class="s5">'dimension'</span><span class="s1">]))</span>
            <span class="s1">c = </span><span class="s5">','</span>
        <span class="s3">if </span><span class="s5">'intent' </span><span class="s3">in </span><span class="s1">vars[a]:</span>
            <span class="s1">lst = true_intent_list(vars[a])</span>
            <span class="s3">if </span><span class="s1">lst:</span>
                <span class="s1">vardef = </span><span class="s5">'%s%sintent(%s)' </span><span class="s1">% (vardef</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s5">','</span><span class="s1">.join(lst))</span>
            <span class="s1">c = </span><span class="s5">','</span>
        <span class="s3">if </span><span class="s5">'check' </span><span class="s3">in </span><span class="s1">vars[a]:</span>
            <span class="s1">vardef = </span><span class="s5">'%s%scheck(%s)' </span><span class="s1">% (vardef</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s5">','</span><span class="s1">.join(vars[a][</span><span class="s5">'check'</span><span class="s1">]))</span>
            <span class="s1">c = </span><span class="s5">','</span>
        <span class="s3">if </span><span class="s5">'depend' </span><span class="s3">in </span><span class="s1">vars[a]:</span>
            <span class="s1">vardef = </span><span class="s5">'%s%sdepend(%s)' </span><span class="s1">% (</span>
                <span class="s1">vardef</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s5">','</span><span class="s1">.join(vars[a][</span><span class="s5">'depend'</span><span class="s1">]))</span>
            <span class="s1">c = </span><span class="s5">','</span>
        <span class="s3">if </span><span class="s5">'=' </span><span class="s3">in </span><span class="s1">vars[a]:</span>
            <span class="s1">v = vars[a][</span><span class="s5">'='</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">vars[a][</span><span class="s5">'typespec'</span><span class="s1">] </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'complex'</span><span class="s3">, </span><span class="s5">'double complex'</span><span class="s1">]:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">v = eval(v)</span>
                    <span class="s1">v = </span><span class="s5">'(%s,%s)' </span><span class="s1">% (v.real</span><span class="s3">, </span><span class="s1">v.imag)</span>
                <span class="s3">except </span><span class="s1">Exception:</span>
                    <span class="s3">pass</span>
            <span class="s1">vardef = </span><span class="s5">'%s :: %s=%s' </span><span class="s1">% (vardef</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">v)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">vardef = </span><span class="s5">'%s :: %s' </span><span class="s1">% (vardef</span><span class="s3">, </span><span class="s1">a)</span>
        <span class="s1">ret = </span><span class="s5">'%s%s%s' </span><span class="s1">% (ret</span><span class="s3">, </span><span class="s1">tab</span><span class="s3">, </span><span class="s1">vardef)</span>
    <span class="s3">return </span><span class="s1">ret</span>
<span class="s0">######</span>


<span class="s3">def </span><span class="s1">crackfortran(files):</span>
    <span class="s3">global </span><span class="s1">usermodules</span>

    <span class="s1">outmess(</span><span class="s5">'Reading fortran codes...</span><span class="s3">\n</span><span class="s5">'</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">readfortrancode(files</span><span class="s3">, </span><span class="s1">crackline)</span>
    <span class="s1">outmess(</span><span class="s5">'Post-processing...</span><span class="s3">\n</span><span class="s5">'</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">usermodules = []</span>
    <span class="s1">postlist = postcrack(grouplist[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">outmess(</span><span class="s5">'Post-processing (stage 2)...</span><span class="s3">\n</span><span class="s5">'</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">postlist = postcrack2(postlist)</span>
    <span class="s3">return </span><span class="s1">usermodules + postlist</span>


<span class="s3">def </span><span class="s1">crack2fortran(block):</span>
    <span class="s3">global </span><span class="s1">f2py_version</span>

    <span class="s1">pyf = crack2fortrangen(block) + </span><span class="s5">'</span><span class="s3">\n</span><span class="s5">'</span>
    <span class="s1">header = </span><span class="s5">&quot;&quot;&quot;!    -*- f90 -*- 
! Note: the context of this file is case sensitive. 
&quot;&quot;&quot;</span>
    <span class="s1">footer = </span><span class="s5">&quot;&quot;&quot; 
! This file was auto-generated with f2py (version:%s). 
! See: 
! https://web.archive.org/web/20140822061353/http://cens.ioc.ee/projects/f2py2e 
&quot;&quot;&quot; </span><span class="s1">% (f2py_version)</span>
    <span class="s3">return </span><span class="s1">header + pyf + footer</span>

<span class="s3">if </span><span class="s1">__name__ == </span><span class="s5">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s1">files = []</span>
    <span class="s1">funcs = []</span>
    <span class="s1">f = </span><span class="s4">1</span>
    <span class="s1">f2 = </span><span class="s4">0</span>
    <span class="s1">f3 = </span><span class="s4">0</span>
    <span class="s1">showblocklist = </span><span class="s4">0</span>
    <span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">sys.argv[</span><span class="s4">1</span><span class="s1">:]:</span>
        <span class="s3">if </span><span class="s1">l == </span><span class="s5">''</span><span class="s1">:</span>
            <span class="s3">pass</span>
        <span class="s3">elif </span><span class="s1">l[</span><span class="s4">0</span><span class="s1">] == </span><span class="s5">':'</span><span class="s1">:</span>
            <span class="s1">f = </span><span class="s4">0</span>
        <span class="s3">elif </span><span class="s1">l == </span><span class="s5">'-quiet'</span><span class="s1">:</span>
            <span class="s1">quiet = </span><span class="s4">1</span>
            <span class="s1">verbose = </span><span class="s4">0</span>
        <span class="s3">elif </span><span class="s1">l == </span><span class="s5">'-verbose'</span><span class="s1">:</span>
            <span class="s1">verbose = </span><span class="s4">2</span>
            <span class="s1">quiet = </span><span class="s4">0</span>
        <span class="s3">elif </span><span class="s1">l == </span><span class="s5">'-fix'</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">strictf77:</span>
                <span class="s1">outmess(</span>
                    <span class="s5">'Use option -f90 before -fix if Fortran 90 code is in fix form.</span><span class="s3">\n</span><span class="s5">'</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">skipemptyends = </span><span class="s4">1</span>
            <span class="s1">sourcecodeform = </span><span class="s5">'fix'</span>
        <span class="s3">elif </span><span class="s1">l == </span><span class="s5">'-skipemptyends'</span><span class="s1">:</span>
            <span class="s1">skipemptyends = </span><span class="s4">1</span>
        <span class="s3">elif </span><span class="s1">l == </span><span class="s5">'--ignore-contains'</span><span class="s1">:</span>
            <span class="s1">ignorecontains = </span><span class="s4">1</span>
        <span class="s3">elif </span><span class="s1">l == </span><span class="s5">'-f77'</span><span class="s1">:</span>
            <span class="s1">strictf77 = </span><span class="s4">1</span>
            <span class="s1">sourcecodeform = </span><span class="s5">'fix'</span>
        <span class="s3">elif </span><span class="s1">l == </span><span class="s5">'-f90'</span><span class="s1">:</span>
            <span class="s1">strictf77 = </span><span class="s4">0</span>
            <span class="s1">sourcecodeform = </span><span class="s5">'free'</span>
            <span class="s1">skipemptyends = </span><span class="s4">1</span>
        <span class="s3">elif </span><span class="s1">l == </span><span class="s5">'-h'</span><span class="s1">:</span>
            <span class="s1">f2 = </span><span class="s4">1</span>
        <span class="s3">elif </span><span class="s1">l == </span><span class="s5">'-show'</span><span class="s1">:</span>
            <span class="s1">showblocklist = </span><span class="s4">1</span>
        <span class="s3">elif </span><span class="s1">l == </span><span class="s5">'-m'</span><span class="s1">:</span>
            <span class="s1">f3 = </span><span class="s4">1</span>
        <span class="s3">elif </span><span class="s1">l[</span><span class="s4">0</span><span class="s1">] == </span><span class="s5">'-'</span><span class="s1">:</span>
            <span class="s1">errmess(</span><span class="s5">'Unknown option %s</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% repr(l))</span>
        <span class="s3">elif </span><span class="s1">f2:</span>
            <span class="s1">f2 = </span><span class="s4">0</span>
            <span class="s1">pyffilename = l</span>
        <span class="s3">elif </span><span class="s1">f3:</span>
            <span class="s1">f3 = </span><span class="s4">0</span>
            <span class="s1">f77modulename = l</span>
        <span class="s3">elif </span><span class="s1">f:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">open(l).close()</span>
                <span class="s1">files.append(l)</span>
            <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">detail:</span>
                <span class="s1">errmess(</span><span class="s5">f'OSError: </span><span class="s3">{</span><span class="s1">detail</span><span class="s3">!s}\n</span><span class="s5">'</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">funcs.append(l)</span>
    <span class="s3">if not </span><span class="s1">strictf77 </span><span class="s3">and </span><span class="s1">f77modulename </span><span class="s3">and not </span><span class="s1">skipemptyends:</span>
        <span class="s1">outmess(</span><span class="s5">&quot;&quot;&quot;</span><span class="s3">\ 
  </span><span class="s5">Warning: You have specified module name for non Fortran 77 code 
  that should not need one (expect if you are scanning F90 code 
  for non module blocks but then you should use flag -skipemptyends 
  and also be sure that the files do not contain programs without program statement). 
&quot;&quot;&quot;</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">postlist = crackfortran(files)</span>
    <span class="s3">if </span><span class="s1">pyffilename:</span>
        <span class="s1">outmess(</span><span class="s5">'Writing fortran code to file %s</span><span class="s3">\n</span><span class="s5">' </span><span class="s1">% repr(pyffilename)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">pyf = crack2fortran(postlist)</span>
        <span class="s3">with </span><span class="s1">open(pyffilename</span><span class="s3">, </span><span class="s5">'w'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f: </span>
            <span class="s1">f.write(pyf)</span>
    <span class="s3">if </span><span class="s1">showblocklist:</span>
        <span class="s1">show(postlist)</span>
</pre>
</body>
</html>