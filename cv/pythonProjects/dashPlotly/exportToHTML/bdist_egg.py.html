<html>
<head>
<title>bdist_egg.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
bdist_egg.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;setuptools.command.bdist_egg 
 
Build .egg distributions&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">distutils.dir_util </span><span class="s2">import </span><span class="s1">remove_tree</span><span class="s2">, </span><span class="s1">mkpath</span>
<span class="s2">from </span><span class="s1">distutils </span><span class="s2">import </span><span class="s1">log</span>
<span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">CodeType</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">textwrap</span>
<span class="s2">import </span><span class="s1">marshal</span>

<span class="s2">from </span><span class="s1">pkg_resources </span><span class="s2">import </span><span class="s1">get_build_platform</span><span class="s2">, </span><span class="s1">Distribution</span><span class="s2">, </span><span class="s1">ensure_directory</span>
<span class="s2">from </span><span class="s1">setuptools.extension </span><span class="s2">import </span><span class="s1">Library</span>
<span class="s2">from </span><span class="s1">setuptools </span><span class="s2">import </span><span class="s1">Command</span>

<span class="s2">from </span><span class="s1">sysconfig </span><span class="s2">import </span><span class="s1">get_path</span><span class="s2">, </span><span class="s1">get_python_version</span>


<span class="s2">def </span><span class="s1">_get_purelib():</span>
    <span class="s2">return </span><span class="s1">get_path(</span><span class="s3">&quot;purelib&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">strip_module(filename):</span>
    <span class="s2">if </span><span class="s3">'.' </span><span class="s2">in </span><span class="s1">filename:</span>
        <span class="s1">filename = os.path.splitext(filename)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">filename.endswith(</span><span class="s3">'module'</span><span class="s1">):</span>
        <span class="s1">filename = filename[:-</span><span class="s4">6</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">filename</span>


<span class="s2">def </span><span class="s1">sorted_walk(dir):</span>
    <span class="s0">&quot;&quot;&quot;Do os.walk in a reproducible way, 
    independent of indeterministic filesystem readdir order 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">base</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files </span><span class="s2">in </span><span class="s1">os.walk(dir):</span>
        <span class="s1">dirs.sort()</span>
        <span class="s1">files.sort()</span>
        <span class="s2">yield </span><span class="s1">base</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files</span>


<span class="s2">def </span><span class="s1">write_stub(resource</span><span class="s2">, </span><span class="s1">pyfile):</span>
    <span class="s1">_stub_template = textwrap.dedent(</span><span class="s3">&quot;&quot;&quot; 
        def __bootstrap__(): 
            global __bootstrap__, __loader__, __file__ 
            import sys, pkg_resources, importlib.util 
            __file__ = pkg_resources.resource_filename(__name__, %r) 
            __loader__ = None; del __bootstrap__, __loader__ 
            spec = importlib.util.spec_from_file_location(__name__,__file__) 
            mod = importlib.util.module_from_spec(spec) 
            spec.loader.exec_module(mod) 
        __bootstrap__() 
        &quot;&quot;&quot;</span><span class="s1">).lstrip()</span>
    <span class="s2">with </span><span class="s1">open(pyfile</span><span class="s2">, </span><span class="s3">'w'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s1">f.write(_stub_template % resource)</span>


<span class="s2">class </span><span class="s1">bdist_egg(Command):</span>
    <span class="s1">description = </span><span class="s3">&quot;create an </span><span class="s2">\&quot;</span><span class="s3">egg</span><span class="s2">\&quot; </span><span class="s3">distribution&quot;</span>

    <span class="s1">user_options = [</span>
        <span class="s1">(</span><span class="s3">'bdist-dir='</span><span class="s2">, </span><span class="s3">'b'</span><span class="s2">,</span>
         <span class="s3">&quot;temporary directory for creating the distribution&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'plat-name='</span><span class="s2">, </span><span class="s3">'p'</span><span class="s2">, </span><span class="s3">&quot;platform name to embed in generated filenames &quot;</span>
                            <span class="s3">&quot;(default: %s)&quot; </span><span class="s1">% get_build_platform())</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'exclude-source-files'</span><span class="s2">, None,</span>
         <span class="s3">&quot;remove all .py files from the generated egg&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'keep-temp'</span><span class="s2">, </span><span class="s3">'k'</span><span class="s2">,</span>
         <span class="s3">&quot;keep the pseudo-installation tree around after &quot; </span><span class="s1">+</span>
         <span class="s3">&quot;creating the distribution archive&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'dist-dir='</span><span class="s2">, </span><span class="s3">'d'</span><span class="s2">,</span>
         <span class="s3">&quot;directory to put final built distributions in&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'skip-build'</span><span class="s2">, None,</span>
         <span class="s3">&quot;skip rebuilding everything (for testing/debugging)&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s1">boolean_options = [</span>
        <span class="s3">'keep-temp'</span><span class="s2">, </span><span class="s3">'skip-build'</span><span class="s2">, </span><span class="s3">'exclude-source-files'</span>
    <span class="s1">]</span>

    <span class="s2">def </span><span class="s1">initialize_options(self):</span>
        <span class="s1">self.bdist_dir = </span><span class="s2">None</span>
        <span class="s1">self.plat_name = </span><span class="s2">None</span>
        <span class="s1">self.keep_temp = </span><span class="s4">0</span>
        <span class="s1">self.dist_dir = </span><span class="s2">None</span>
        <span class="s1">self.skip_build = </span><span class="s4">0</span>
        <span class="s1">self.egg_output = </span><span class="s2">None</span>
        <span class="s1">self.exclude_source_files = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">finalize_options(self):</span>
        <span class="s1">ei_cmd = self.ei_cmd = self.get_finalized_command(</span><span class="s3">&quot;egg_info&quot;</span><span class="s1">)</span>
        <span class="s1">self.egg_info = ei_cmd.egg_info</span>

        <span class="s2">if </span><span class="s1">self.bdist_dir </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">bdist_base = self.get_finalized_command(</span><span class="s3">'bdist'</span><span class="s1">).bdist_base</span>
            <span class="s1">self.bdist_dir = os.path.join(bdist_base</span><span class="s2">, </span><span class="s3">'egg'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.plat_name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.plat_name = get_build_platform()</span>

        <span class="s1">self.set_undefined_options(</span><span class="s3">'bdist'</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'dist_dir'</span><span class="s2">, </span><span class="s3">'dist_dir'</span><span class="s1">))</span>

        <span class="s2">if </span><span class="s1">self.egg_output </span><span class="s2">is None</span><span class="s1">:</span>

            <span class="s5"># Compute filename of the output egg</span>
            <span class="s1">basename = Distribution(</span>
                <span class="s2">None, None, </span><span class="s1">ei_cmd.egg_name</span><span class="s2">, </span><span class="s1">ei_cmd.egg_version</span><span class="s2">,</span>
                <span class="s1">get_python_version()</span><span class="s2">,</span>
                <span class="s1">self.distribution.has_ext_modules() </span><span class="s2">and </span><span class="s1">self.plat_name</span>
            <span class="s1">).egg_name()</span>

            <span class="s1">self.egg_output = os.path.join(self.dist_dir</span><span class="s2">, </span><span class="s1">basename + </span><span class="s3">'.egg'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">do_install_data(self):</span>
        <span class="s5"># Hack for packages that install data to install's --install-lib</span>
        <span class="s1">self.get_finalized_command(</span><span class="s3">'install'</span><span class="s1">).install_lib = self.bdist_dir</span>

        <span class="s1">site_packages = os.path.normcase(os.path.realpath(_get_purelib()))</span>
        <span class="s1">old</span><span class="s2">, </span><span class="s1">self.distribution.data_files = self.distribution.data_files</span><span class="s2">, </span><span class="s1">[]</span>

        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">old:</span>
            <span class="s2">if </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">tuple) </span><span class="s2">and </span><span class="s1">len(item) == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">os.path.isabs(item[</span><span class="s4">0</span><span class="s1">]):</span>
                    <span class="s1">realpath = os.path.realpath(item[</span><span class="s4">0</span><span class="s1">])</span>
                    <span class="s1">normalized = os.path.normcase(realpath)</span>
                    <span class="s2">if </span><span class="s1">normalized == site_packages </span><span class="s2">or </span><span class="s1">normalized.startswith(</span>
                        <span class="s1">site_packages + os.sep</span>
                    <span class="s1">):</span>
                        <span class="s1">item = realpath[len(site_packages) + </span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">item[</span><span class="s4">1</span><span class="s1">]</span>
                        <span class="s5"># XXX else: raise ???</span>
            <span class="s1">self.distribution.data_files.append(item)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">log.info(</span><span class="s3">&quot;installing package data to %s&quot;</span><span class="s2">, </span><span class="s1">self.bdist_dir)</span>
            <span class="s1">self.call_command(</span><span class="s3">'install_data'</span><span class="s2">, </span><span class="s1">force=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">root=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">self.distribution.data_files = old</span>

    <span class="s2">def </span><span class="s1">get_outputs(self):</span>
        <span class="s2">return </span><span class="s1">[self.egg_output]</span>

    <span class="s2">def </span><span class="s1">call_command(self</span><span class="s2">, </span><span class="s1">cmdname</span><span class="s2">, </span><span class="s1">**kw):</span>
        <span class="s0">&quot;&quot;&quot;Invoke reinitialized command `cmdname` with keyword args&quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">dirname </span><span class="s2">in </span><span class="s1">INSTALL_DIRECTORY_ATTRS:</span>
            <span class="s1">kw.setdefault(dirname</span><span class="s2">, </span><span class="s1">self.bdist_dir)</span>
        <span class="s1">kw.setdefault(</span><span class="s3">'skip_build'</span><span class="s2">, </span><span class="s1">self.skip_build)</span>
        <span class="s1">kw.setdefault(</span><span class="s3">'dry_run'</span><span class="s2">, </span><span class="s1">self.dry_run)</span>
        <span class="s1">cmd = self.reinitialize_command(cmdname</span><span class="s2">, </span><span class="s1">**kw)</span>
        <span class="s1">self.run_command(cmdname)</span>
        <span class="s2">return </span><span class="s1">cmd</span>

    <span class="s2">def </span><span class="s1">run(self):  </span><span class="s5"># noqa: C901  # is too complex (14)  # FIXME</span>
        <span class="s5"># Generate metadata first</span>
        <span class="s1">self.run_command(</span><span class="s3">&quot;egg_info&quot;</span><span class="s1">)</span>
        <span class="s5"># We run install_lib before install_data, because some data hacks</span>
        <span class="s5"># pull their data path from the install_lib command.</span>
        <span class="s1">log.info(</span><span class="s3">&quot;installing library code to %s&quot;</span><span class="s2">, </span><span class="s1">self.bdist_dir)</span>
        <span class="s1">instcmd = self.get_finalized_command(</span><span class="s3">'install'</span><span class="s1">)</span>
        <span class="s1">old_root = instcmd.root</span>
        <span class="s1">instcmd.root = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">self.distribution.has_c_libraries() </span><span class="s2">and not </span><span class="s1">self.skip_build:</span>
            <span class="s1">self.run_command(</span><span class="s3">'build_clib'</span><span class="s1">)</span>
        <span class="s1">cmd = self.call_command(</span><span class="s3">'install_lib'</span><span class="s2">, </span><span class="s1">warn_dir=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">instcmd.root = old_root</span>

        <span class="s1">all_outputs</span><span class="s2">, </span><span class="s1">ext_outputs = self.get_ext_outputs()</span>
        <span class="s1">self.stubs = []</span>
        <span class="s1">to_compile = []</span>
        <span class="s2">for </span><span class="s1">(p</span><span class="s2">, </span><span class="s1">ext_name) </span><span class="s2">in </span><span class="s1">enumerate(ext_outputs):</span>
            <span class="s1">filename</span><span class="s2">, </span><span class="s1">ext = os.path.splitext(ext_name)</span>
            <span class="s1">pyfile = os.path.join(self.bdist_dir</span><span class="s2">, </span><span class="s1">strip_module(filename) +</span>
                                  <span class="s3">'.py'</span><span class="s1">)</span>
            <span class="s1">self.stubs.append(pyfile)</span>
            <span class="s1">log.info(</span><span class="s3">&quot;creating stub loader for %s&quot;</span><span class="s2">, </span><span class="s1">ext_name)</span>
            <span class="s2">if not </span><span class="s1">self.dry_run:</span>
                <span class="s1">write_stub(os.path.basename(ext_name)</span><span class="s2">, </span><span class="s1">pyfile)</span>
            <span class="s1">to_compile.append(pyfile)</span>
            <span class="s1">ext_outputs[p] = ext_name.replace(os.sep</span><span class="s2">, </span><span class="s3">'/'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">to_compile:</span>
            <span class="s1">cmd.byte_compile(to_compile)</span>
        <span class="s2">if </span><span class="s1">self.distribution.data_files:</span>
            <span class="s1">self.do_install_data()</span>

        <span class="s5"># Make the EGG-INFO directory</span>
        <span class="s1">archive_root = self.bdist_dir</span>
        <span class="s1">egg_info = os.path.join(archive_root</span><span class="s2">, </span><span class="s3">'EGG-INFO'</span><span class="s1">)</span>
        <span class="s1">self.mkpath(egg_info)</span>
        <span class="s2">if </span><span class="s1">self.distribution.scripts:</span>
            <span class="s1">script_dir = os.path.join(egg_info</span><span class="s2">, </span><span class="s3">'scripts'</span><span class="s1">)</span>
            <span class="s1">log.info(</span><span class="s3">&quot;installing scripts to %s&quot;</span><span class="s2">, </span><span class="s1">script_dir)</span>
            <span class="s1">self.call_command(</span><span class="s3">'install_scripts'</span><span class="s2">, </span><span class="s1">install_dir=script_dir</span><span class="s2">,</span>
                              <span class="s1">no_ep=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">self.copy_metadata_to(egg_info)</span>
        <span class="s1">native_libs = os.path.join(egg_info</span><span class="s2">, </span><span class="s3">&quot;native_libs.txt&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">all_outputs:</span>
            <span class="s1">log.info(</span><span class="s3">&quot;writing %s&quot;</span><span class="s2">, </span><span class="s1">native_libs)</span>
            <span class="s2">if not </span><span class="s1">self.dry_run:</span>
                <span class="s1">ensure_directory(native_libs)</span>
                <span class="s1">libs_file = open(native_libs</span><span class="s2">, </span><span class="s3">'wt'</span><span class="s1">)</span>
                <span class="s1">libs_file.write(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(all_outputs))</span>
                <span class="s1">libs_file.write(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>
                <span class="s1">libs_file.close()</span>
        <span class="s2">elif </span><span class="s1">os.path.isfile(native_libs):</span>
            <span class="s1">log.info(</span><span class="s3">&quot;removing %s&quot;</span><span class="s2">, </span><span class="s1">native_libs)</span>
            <span class="s2">if not </span><span class="s1">self.dry_run:</span>
                <span class="s1">os.unlink(native_libs)</span>

        <span class="s1">write_safety_flag(</span>
            <span class="s1">os.path.join(archive_root</span><span class="s2">, </span><span class="s3">'EGG-INFO'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">self.zip_safe()</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">os.path.exists(os.path.join(self.egg_info</span><span class="s2">, </span><span class="s3">'depends.txt'</span><span class="s1">)):</span>
            <span class="s1">log.warn(</span>
                <span class="s3">&quot;WARNING: 'depends.txt' will not be used by setuptools 0.6!</span><span class="s2">\n</span><span class="s3">&quot;</span>
                <span class="s3">&quot;Use the install_requires/extras_require setup() args instead.&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.exclude_source_files:</span>
            <span class="s1">self.zap_pyfiles()</span>

        <span class="s5"># Make the archive</span>
        <span class="s1">make_zipfile(self.egg_output</span><span class="s2">, </span><span class="s1">archive_root</span><span class="s2">, </span><span class="s1">verbose=self.verbose</span><span class="s2">,</span>
                     <span class="s1">dry_run=self.dry_run</span><span class="s2">, </span><span class="s1">mode=self.gen_header())</span>
        <span class="s2">if not </span><span class="s1">self.keep_temp:</span>
            <span class="s1">remove_tree(self.bdist_dir</span><span class="s2">, </span><span class="s1">dry_run=self.dry_run)</span>

        <span class="s5"># Add to 'Distribution.dist_files' so that the &quot;upload&quot; command works</span>
        <span class="s1">getattr(self.distribution</span><span class="s2">, </span><span class="s3">'dist_files'</span><span class="s2">, </span><span class="s1">[]).append(</span>
            <span class="s1">(</span><span class="s3">'bdist_egg'</span><span class="s2">, </span><span class="s1">get_python_version()</span><span class="s2">, </span><span class="s1">self.egg_output))</span>

    <span class="s2">def </span><span class="s1">zap_pyfiles(self):</span>
        <span class="s1">log.info(</span><span class="s3">&quot;Removing .py files from temporary directory&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">base</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files </span><span class="s2">in </span><span class="s1">walk_egg(self.bdist_dir):</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">files:</span>
                <span class="s1">path = os.path.join(base</span><span class="s2">, </span><span class="s1">name)</span>

                <span class="s2">if </span><span class="s1">name.endswith(</span><span class="s3">'.py'</span><span class="s1">):</span>
                    <span class="s1">log.debug(</span><span class="s3">&quot;Deleting %s&quot;</span><span class="s2">, </span><span class="s1">path)</span>
                    <span class="s1">os.unlink(path)</span>

                <span class="s2">if </span><span class="s1">base.endswith(</span><span class="s3">'__pycache__'</span><span class="s1">):</span>
                    <span class="s1">path_old = path</span>

                    <span class="s1">pattern = </span><span class="s3">r'(?P&lt;name&gt;.+)\.(?P&lt;magic&gt;[^.]+)\.pyc'</span>
                    <span class="s1">m = re.match(pattern</span><span class="s2">, </span><span class="s1">name)</span>
                    <span class="s1">path_new = os.path.join(</span>
                        <span class="s1">base</span><span class="s2">, </span><span class="s1">os.pardir</span><span class="s2">, </span><span class="s1">m.group(</span><span class="s3">'name'</span><span class="s1">) + </span><span class="s3">'.pyc'</span><span class="s1">)</span>
                    <span class="s1">log.info(</span>
                        <span class="s3">&quot;Renaming file from [%s] to [%s]&quot;</span>
                        <span class="s1">% (path_old</span><span class="s2">, </span><span class="s1">path_new))</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">os.remove(path_new)</span>
                    <span class="s2">except </span><span class="s1">OSError:</span>
                        <span class="s2">pass</span>
                    <span class="s1">os.rename(path_old</span><span class="s2">, </span><span class="s1">path_new)</span>

    <span class="s2">def </span><span class="s1">zip_safe(self):</span>
        <span class="s1">safe = getattr(self.distribution</span><span class="s2">, </span><span class="s3">'zip_safe'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">safe </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">safe</span>
        <span class="s1">log.warn(</span><span class="s3">&quot;zip_safe flag not set; analyzing archive contents...&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">analyze_egg(self.bdist_dir</span><span class="s2">, </span><span class="s1">self.stubs)</span>

    <span class="s2">def </span><span class="s1">gen_header(self):</span>
        <span class="s2">return </span><span class="s3">'w'</span>

    <span class="s2">def </span><span class="s1">copy_metadata_to(self</span><span class="s2">, </span><span class="s1">target_dir):</span>
        <span class="s0">&quot;Copy metadata (egg info) to the target_dir&quot;</span>
        <span class="s5"># normalize the path (so that a forward-slash in egg_info will</span>
        <span class="s5"># match using startswith below)</span>
        <span class="s1">norm_egg_info = os.path.normpath(self.egg_info)</span>
        <span class="s1">prefix = os.path.join(norm_egg_info</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">self.ei_cmd.filelist.files:</span>
            <span class="s2">if </span><span class="s1">path.startswith(prefix):</span>
                <span class="s1">target = os.path.join(target_dir</span><span class="s2">, </span><span class="s1">path[len(prefix):])</span>
                <span class="s1">ensure_directory(target)</span>
                <span class="s1">self.copy_file(path</span><span class="s2">, </span><span class="s1">target)</span>

    <span class="s2">def </span><span class="s1">get_ext_outputs(self):</span>
        <span class="s0">&quot;&quot;&quot;Get a list of relative paths to C extensions in the output distro&quot;&quot;&quot;</span>

        <span class="s1">all_outputs = []</span>
        <span class="s1">ext_outputs = []</span>

        <span class="s1">paths = {self.bdist_dir: </span><span class="s3">''</span><span class="s1">}</span>
        <span class="s2">for </span><span class="s1">base</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files </span><span class="s2">in </span><span class="s1">sorted_walk(self.bdist_dir):</span>
            <span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">files:</span>
                <span class="s2">if </span><span class="s1">os.path.splitext(filename)[</span><span class="s4">1</span><span class="s1">].lower() </span><span class="s2">in </span><span class="s1">NATIVE_EXTENSIONS:</span>
                    <span class="s1">all_outputs.append(paths[base] + filename)</span>
            <span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">dirs:</span>
                <span class="s1">paths[os.path.join(base</span><span class="s2">, </span><span class="s1">filename)] = (paths[base] +</span>
                                                       <span class="s1">filename + </span><span class="s3">'/'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.distribution.has_ext_modules():</span>
            <span class="s1">build_cmd = self.get_finalized_command(</span><span class="s3">'build_ext'</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">ext </span><span class="s2">in </span><span class="s1">build_cmd.extensions:</span>
                <span class="s2">if </span><span class="s1">isinstance(ext</span><span class="s2">, </span><span class="s1">Library):</span>
                    <span class="s2">continue</span>
                <span class="s1">fullname = build_cmd.get_ext_fullname(ext.name)</span>
                <span class="s1">filename = build_cmd.get_ext_filename(fullname)</span>
                <span class="s2">if not </span><span class="s1">os.path.basename(filename).startswith(</span><span class="s3">'dl-'</span><span class="s1">):</span>
                    <span class="s2">if </span><span class="s1">os.path.exists(os.path.join(self.bdist_dir</span><span class="s2">, </span><span class="s1">filename)):</span>
                        <span class="s1">ext_outputs.append(filename)</span>

        <span class="s2">return </span><span class="s1">all_outputs</span><span class="s2">, </span><span class="s1">ext_outputs</span>


<span class="s1">NATIVE_EXTENSIONS = dict.fromkeys(</span><span class="s3">'.dll .so .dylib .pyd'</span><span class="s1">.split())</span>


<span class="s2">def </span><span class="s1">walk_egg(egg_dir):</span>
    <span class="s0">&quot;&quot;&quot;Walk an unpacked egg's contents, skipping the metadata directory&quot;&quot;&quot;</span>
    <span class="s1">walker = sorted_walk(egg_dir)</span>
    <span class="s1">base</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files = next(walker)</span>
    <span class="s2">if </span><span class="s3">'EGG-INFO' </span><span class="s2">in </span><span class="s1">dirs:</span>
        <span class="s1">dirs.remove(</span><span class="s3">'EGG-INFO'</span><span class="s1">)</span>
    <span class="s2">yield </span><span class="s1">base</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files</span>
    <span class="s2">for </span><span class="s1">bdf </span><span class="s2">in </span><span class="s1">walker:</span>
        <span class="s2">yield </span><span class="s1">bdf</span>


<span class="s2">def </span><span class="s1">analyze_egg(egg_dir</span><span class="s2">, </span><span class="s1">stubs):</span>
    <span class="s5"># check for existing flag in EGG-INFO</span>
    <span class="s2">for </span><span class="s1">flag</span><span class="s2">, </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">safety_flags.items():</span>
        <span class="s2">if </span><span class="s1">os.path.exists(os.path.join(egg_dir</span><span class="s2">, </span><span class="s3">'EGG-INFO'</span><span class="s2">, </span><span class="s1">fn)):</span>
            <span class="s2">return </span><span class="s1">flag</span>
    <span class="s2">if not </span><span class="s1">can_scan():</span>
        <span class="s2">return False</span>
    <span class="s1">safe = </span><span class="s2">True</span>
    <span class="s2">for </span><span class="s1">base</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files </span><span class="s2">in </span><span class="s1">walk_egg(egg_dir):</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">files:</span>
            <span class="s2">if </span><span class="s1">name.endswith(</span><span class="s3">'.py'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">name.endswith(</span><span class="s3">'.pyw'</span><span class="s1">):</span>
                <span class="s2">continue</span>
            <span class="s2">elif </span><span class="s1">name.endswith(</span><span class="s3">'.pyc'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">name.endswith(</span><span class="s3">'.pyo'</span><span class="s1">):</span>
                <span class="s5"># always scan, even if we already know we're not safe</span>
                <span class="s1">safe = scan_module(egg_dir</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">stubs) </span><span class="s2">and </span><span class="s1">safe</span>
    <span class="s2">return </span><span class="s1">safe</span>


<span class="s2">def </span><span class="s1">write_safety_flag(egg_dir</span><span class="s2">, </span><span class="s1">safe):</span>
    <span class="s5"># Write or remove zip safety flag file(s)</span>
    <span class="s2">for </span><span class="s1">flag</span><span class="s2">, </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">safety_flags.items():</span>
        <span class="s1">fn = os.path.join(egg_dir</span><span class="s2">, </span><span class="s1">fn)</span>
        <span class="s2">if </span><span class="s1">os.path.exists(fn):</span>
            <span class="s2">if </span><span class="s1">safe </span><span class="s2">is None or </span><span class="s1">bool(safe) != flag:</span>
                <span class="s1">os.unlink(fn)</span>
        <span class="s2">elif </span><span class="s1">safe </span><span class="s2">is not None and </span><span class="s1">bool(safe) == flag:</span>
            <span class="s1">f = open(fn</span><span class="s2">, </span><span class="s3">'wt'</span><span class="s1">)</span>
            <span class="s1">f.write(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>
            <span class="s1">f.close()</span>


<span class="s1">safety_flags = {</span>
    <span class="s2">True</span><span class="s1">: </span><span class="s3">'zip-safe'</span><span class="s2">,</span>
    <span class="s2">False</span><span class="s1">: </span><span class="s3">'not-zip-safe'</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s2">def </span><span class="s1">scan_module(egg_dir</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">stubs):</span>
    <span class="s0">&quot;&quot;&quot;Check whether module possibly uses unsafe-for-zipfile stuff&quot;&quot;&quot;</span>

    <span class="s1">filename = os.path.join(base</span><span class="s2">, </span><span class="s1">name)</span>
    <span class="s2">if </span><span class="s1">filename[:-</span><span class="s4">1</span><span class="s1">] </span><span class="s2">in </span><span class="s1">stubs:</span>
        <span class="s2">return True  </span><span class="s5"># Extension module</span>
    <span class="s1">pkg = base[len(egg_dir) + </span><span class="s4">1</span><span class="s1">:].replace(os.sep</span><span class="s2">, </span><span class="s3">'.'</span><span class="s1">)</span>
    <span class="s1">module = pkg + (pkg </span><span class="s2">and </span><span class="s3">'.' </span><span class="s2">or </span><span class="s3">''</span><span class="s1">) + os.path.splitext(name)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">sys.version_info &lt; (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">7</span><span class="s1">):</span>
        <span class="s1">skip = </span><span class="s4">12  </span><span class="s5"># skip magic &amp; date &amp; file size</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">skip = </span><span class="s4">16  </span><span class="s5"># skip magic &amp; reserved? &amp; date &amp; file size</span>
    <span class="s1">f = open(filename</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">)</span>
    <span class="s1">f.read(skip)</span>
    <span class="s1">code = marshal.load(f)</span>
    <span class="s1">f.close()</span>
    <span class="s1">safe = </span><span class="s2">True</span>
    <span class="s1">symbols = dict.fromkeys(iter_symbols(code))</span>
    <span class="s2">for </span><span class="s1">bad </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'__file__'</span><span class="s2">, </span><span class="s3">'__path__'</span><span class="s1">]:</span>
        <span class="s2">if </span><span class="s1">bad </span><span class="s2">in </span><span class="s1">symbols:</span>
            <span class="s1">log.warn(</span><span class="s3">&quot;%s: module references %s&quot;</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">bad)</span>
            <span class="s1">safe = </span><span class="s2">False</span>
    <span class="s2">if </span><span class="s3">'inspect' </span><span class="s2">in </span><span class="s1">symbols:</span>
        <span class="s2">for </span><span class="s1">bad </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">'getsource'</span><span class="s2">, </span><span class="s3">'getabsfile'</span><span class="s2">, </span><span class="s3">'getsourcefile'</span><span class="s2">, </span><span class="s3">'getfile'</span>
            <span class="s3">'getsourcelines'</span><span class="s2">, </span><span class="s3">'findsource'</span><span class="s2">, </span><span class="s3">'getcomments'</span><span class="s2">, </span><span class="s3">'getframeinfo'</span><span class="s2">,</span>
            <span class="s3">'getinnerframes'</span><span class="s2">, </span><span class="s3">'getouterframes'</span><span class="s2">, </span><span class="s3">'stack'</span><span class="s2">, </span><span class="s3">'trace'</span>
        <span class="s1">]:</span>
            <span class="s2">if </span><span class="s1">bad </span><span class="s2">in </span><span class="s1">symbols:</span>
                <span class="s1">log.warn(</span><span class="s3">&quot;%s: module MAY be using inspect.%s&quot;</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">bad)</span>
                <span class="s1">safe = </span><span class="s2">False</span>
    <span class="s2">return </span><span class="s1">safe</span>


<span class="s2">def </span><span class="s1">iter_symbols(code):</span>
    <span class="s0">&quot;&quot;&quot;Yield names and strings used by `code` and its nested code objects&quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">code.co_names:</span>
        <span class="s2">yield </span><span class="s1">name</span>
    <span class="s2">for </span><span class="s1">const </span><span class="s2">in </span><span class="s1">code.co_consts:</span>
        <span class="s2">if </span><span class="s1">isinstance(const</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">yield </span><span class="s1">const</span>
        <span class="s2">elif </span><span class="s1">isinstance(const</span><span class="s2">, </span><span class="s1">CodeType):</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">iter_symbols(const):</span>
                <span class="s2">yield </span><span class="s1">name</span>


<span class="s2">def </span><span class="s1">can_scan():</span>
    <span class="s2">if not </span><span class="s1">sys.platform.startswith(</span><span class="s3">'java'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">sys.platform != </span><span class="s3">'cli'</span><span class="s1">:</span>
        <span class="s5"># CPython, PyPy, etc.</span>
        <span class="s2">return True</span>
    <span class="s1">log.warn(</span><span class="s3">&quot;Unable to analyze compiled code on this platform.&quot;</span><span class="s1">)</span>
    <span class="s1">log.warn(</span><span class="s3">&quot;Please ask the author to include a 'zip_safe'&quot;</span>
             <span class="s3">&quot; setting (either True or False) in the package's setup.py&quot;</span><span class="s1">)</span>


<span class="s5"># Attribute names of options for commands that might need to be convinced to</span>
<span class="s5"># install to the egg build directory</span>

<span class="s1">INSTALL_DIRECTORY_ATTRS = [</span>
    <span class="s3">'install_lib'</span><span class="s2">, </span><span class="s3">'install_dir'</span><span class="s2">, </span><span class="s3">'install_data'</span><span class="s2">, </span><span class="s3">'install_base'</span>
<span class="s1">]</span>


<span class="s2">def </span><span class="s1">make_zipfile(zip_filename</span><span class="s2">, </span><span class="s1">base_dir</span><span class="s2">, </span><span class="s1">verbose=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">dry_run=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">compress=</span><span class="s2">True,</span>
                 <span class="s1">mode=</span><span class="s3">'w'</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Create a zip file from all the files under 'base_dir'.  The output 
    zip file will be named 'base_dir' + &quot;.zip&quot;.  Uses either the &quot;zipfile&quot; 
    Python module (if available) or the InfoZIP &quot;zip&quot; utility (if installed 
    and found on the default search path).  If neither tool is available, 
    raises DistutilsExecError.  Returns the name of the output zip file. 
    &quot;&quot;&quot;</span>
    <span class="s2">import </span><span class="s1">zipfile</span>

    <span class="s1">mkpath(os.path.dirname(zip_filename)</span><span class="s2">, </span><span class="s1">dry_run=dry_run)</span>
    <span class="s1">log.info(</span><span class="s3">&quot;creating '%s' and adding '%s' to it&quot;</span><span class="s2">, </span><span class="s1">zip_filename</span><span class="s2">, </span><span class="s1">base_dir)</span>

    <span class="s2">def </span><span class="s1">visit(z</span><span class="s2">, </span><span class="s1">dirname</span><span class="s2">, </span><span class="s1">names):</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names:</span>
            <span class="s1">path = os.path.normpath(os.path.join(dirname</span><span class="s2">, </span><span class="s1">name))</span>
            <span class="s2">if </span><span class="s1">os.path.isfile(path):</span>
                <span class="s1">p = path[len(base_dir) + </span><span class="s4">1</span><span class="s1">:]</span>
                <span class="s2">if not </span><span class="s1">dry_run:</span>
                    <span class="s1">z.write(path</span><span class="s2">, </span><span class="s1">p)</span>
                <span class="s1">log.debug(</span><span class="s3">&quot;adding '%s'&quot;</span><span class="s2">, </span><span class="s1">p)</span>

    <span class="s1">compression = zipfile.ZIP_DEFLATED </span><span class="s2">if </span><span class="s1">compress </span><span class="s2">else </span><span class="s1">zipfile.ZIP_STORED</span>
    <span class="s2">if not </span><span class="s1">dry_run:</span>
        <span class="s1">z = zipfile.ZipFile(zip_filename</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">compression=compression)</span>
        <span class="s2">for </span><span class="s1">dirname</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files </span><span class="s2">in </span><span class="s1">sorted_walk(base_dir):</span>
            <span class="s1">visit(z</span><span class="s2">, </span><span class="s1">dirname</span><span class="s2">, </span><span class="s1">files)</span>
        <span class="s1">z.close()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">dirname</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files </span><span class="s2">in </span><span class="s1">sorted_walk(base_dir):</span>
            <span class="s1">visit(</span><span class="s2">None, </span><span class="s1">dirname</span><span class="s2">, </span><span class="s1">files)</span>
    <span class="s2">return </span><span class="s1">zip_filename</span>
</pre>
</body>
</html>