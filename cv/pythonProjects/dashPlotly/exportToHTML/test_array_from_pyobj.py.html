<html>
<head>
<title>test_array_from_pyobj.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_array_from_pyobj.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">copy</span>
<span class="s0">import </span><span class="s1">platform</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_</span><span class="s0">, </span><span class="s1">assert_equal</span>
<span class="s0">from </span><span class="s1">numpy.core.multiarray </span><span class="s0">import </span><span class="s1">typeinfo</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">util</span>

<span class="s1">wrap = </span><span class="s0">None</span>


<span class="s0">def </span><span class="s1">setup_module():</span>
    <span class="s2">&quot;&quot;&quot; 
    Build the required testing extension module 
 
    &quot;&quot;&quot;</span>
    <span class="s0">global </span><span class="s1">wrap</span>

    <span class="s3"># Check compiler availability first</span>
    <span class="s0">if not </span><span class="s1">util.has_c_compiler():</span>
        <span class="s1">pytest.skip(</span><span class="s4">&quot;No C compiler available&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">wrap </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">config_code = </span><span class="s4">&quot;&quot;&quot; 
        config.add_extension('test_array_from_pyobj_ext', 
                             sources=['wrapmodule.c', 'fortranobject.c'], 
                             define_macros=[]) 
        &quot;&quot;&quot;</span>
        <span class="s1">d = os.path.dirname(__file__)</span>
        <span class="s1">src = [os.path.join(d</span><span class="s0">, </span><span class="s4">'src'</span><span class="s0">, </span><span class="s4">'array_from_pyobj'</span><span class="s0">, </span><span class="s4">'wrapmodule.c'</span><span class="s1">)</span><span class="s0">,</span>
               <span class="s1">os.path.join(d</span><span class="s0">, </span><span class="s4">'..'</span><span class="s0">, </span><span class="s4">'src'</span><span class="s0">, </span><span class="s4">'fortranobject.c'</span><span class="s1">)</span><span class="s0">,</span>
               <span class="s1">os.path.join(d</span><span class="s0">, </span><span class="s4">'..'</span><span class="s0">, </span><span class="s4">'src'</span><span class="s0">, </span><span class="s4">'fortranobject.h'</span><span class="s1">)]</span>
        <span class="s1">wrap = util.build_module_distutils(src</span><span class="s0">, </span><span class="s1">config_code</span><span class="s0">,</span>
                                           <span class="s4">'test_array_from_pyobj_ext'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">flags_info(arr):</span>
    <span class="s1">flags = wrap.array_attrs(arr)[</span><span class="s5">6</span><span class="s1">]</span>
    <span class="s0">return </span><span class="s1">flags2names(flags)</span>


<span class="s0">def </span><span class="s1">flags2names(flags):</span>
    <span class="s1">info = []</span>
    <span class="s0">for </span><span class="s1">flagname </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'CONTIGUOUS'</span><span class="s0">, </span><span class="s4">'FORTRAN'</span><span class="s0">, </span><span class="s4">'OWNDATA'</span><span class="s0">, </span><span class="s4">'ENSURECOPY'</span><span class="s0">,</span>
                     <span class="s4">'ENSUREARRAY'</span><span class="s0">, </span><span class="s4">'ALIGNED'</span><span class="s0">, </span><span class="s4">'NOTSWAPPED'</span><span class="s0">, </span><span class="s4">'WRITEABLE'</span><span class="s0">,</span>
                     <span class="s4">'WRITEBACKIFCOPY'</span><span class="s0">, </span><span class="s4">'UPDATEIFCOPY'</span><span class="s0">, </span><span class="s4">'BEHAVED'</span><span class="s0">, </span><span class="s4">'BEHAVED_RO'</span><span class="s0">,</span>
                     <span class="s4">'CARRAY'</span><span class="s0">, </span><span class="s4">'FARRAY'</span>
                     <span class="s1">]:</span>
        <span class="s0">if </span><span class="s1">abs(flags) &amp; getattr(wrap</span><span class="s0">, </span><span class="s1">flagname</span><span class="s0">, </span><span class="s5">0</span><span class="s1">):</span>
            <span class="s1">info.append(flagname)</span>
    <span class="s0">return </span><span class="s1">info</span>


<span class="s0">class </span><span class="s1">Intent:</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">intent_list=[]):</span>
        <span class="s1">self.intent_list = intent_list[:]</span>
        <span class="s1">flags = </span><span class="s5">0</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">intent_list:</span>
            <span class="s0">if </span><span class="s1">i == </span><span class="s4">'optional'</span><span class="s1">:</span>
                <span class="s1">flags |= wrap.F2PY_OPTIONAL</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">flags |= getattr(wrap</span><span class="s0">, </span><span class="s4">'F2PY_INTENT_' </span><span class="s1">+ i.upper())</span>
        <span class="s1">self.flags = flags</span>

    <span class="s0">def </span><span class="s1">__getattr__(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s1">name = name.lower()</span>
        <span class="s0">if </span><span class="s1">name == </span><span class="s4">'in_'</span><span class="s1">:</span>
            <span class="s1">name = </span><span class="s4">'in'</span>
        <span class="s0">return </span><span class="s1">self.__class__(self.intent_list + [name])</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s4">'intent(%s)' </span><span class="s1">% (</span><span class="s4">','</span><span class="s1">.join(self.intent_list))</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s4">'Intent(%r)' </span><span class="s1">% (self.intent_list)</span>

    <span class="s0">def </span><span class="s1">is_intent(self</span><span class="s0">, </span><span class="s1">*names):</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names:</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">self.intent_list:</span>
                <span class="s0">return False</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">is_intent_exact(self</span><span class="s0">, </span><span class="s1">*names):</span>
        <span class="s0">return </span><span class="s1">len(self.intent_list) == len(names) </span><span class="s0">and </span><span class="s1">self.is_intent(*names)</span>

<span class="s1">intent = Intent()</span>

<span class="s1">_type_names = [</span><span class="s4">'BOOL'</span><span class="s0">, </span><span class="s4">'BYTE'</span><span class="s0">, </span><span class="s4">'UBYTE'</span><span class="s0">, </span><span class="s4">'SHORT'</span><span class="s0">, </span><span class="s4">'USHORT'</span><span class="s0">, </span><span class="s4">'INT'</span><span class="s0">, </span><span class="s4">'UINT'</span><span class="s0">,</span>
               <span class="s4">'LONG'</span><span class="s0">, </span><span class="s4">'ULONG'</span><span class="s0">, </span><span class="s4">'LONGLONG'</span><span class="s0">, </span><span class="s4">'ULONGLONG'</span><span class="s0">,</span>
               <span class="s4">'FLOAT'</span><span class="s0">, </span><span class="s4">'DOUBLE'</span><span class="s0">, </span><span class="s4">'CFLOAT'</span><span class="s1">]</span>

<span class="s1">_cast_dict = {</span><span class="s4">'BOOL'</span><span class="s1">: [</span><span class="s4">'BOOL'</span><span class="s1">]}</span>
<span class="s1">_cast_dict[</span><span class="s4">'BYTE'</span><span class="s1">] = _cast_dict[</span><span class="s4">'BOOL'</span><span class="s1">] + [</span><span class="s4">'BYTE'</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s4">'UBYTE'</span><span class="s1">] = _cast_dict[</span><span class="s4">'BOOL'</span><span class="s1">] + [</span><span class="s4">'UBYTE'</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s4">'BYTE'</span><span class="s1">] = [</span><span class="s4">'BYTE'</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s4">'UBYTE'</span><span class="s1">] = [</span><span class="s4">'UBYTE'</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s4">'SHORT'</span><span class="s1">] = _cast_dict[</span><span class="s4">'BYTE'</span><span class="s1">] + [</span><span class="s4">'UBYTE'</span><span class="s0">, </span><span class="s4">'SHORT'</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s4">'USHORT'</span><span class="s1">] = _cast_dict[</span><span class="s4">'UBYTE'</span><span class="s1">] + [</span><span class="s4">'BYTE'</span><span class="s0">, </span><span class="s4">'USHORT'</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s4">'INT'</span><span class="s1">] = _cast_dict[</span><span class="s4">'SHORT'</span><span class="s1">] + [</span><span class="s4">'USHORT'</span><span class="s0">, </span><span class="s4">'INT'</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s4">'UINT'</span><span class="s1">] = _cast_dict[</span><span class="s4">'USHORT'</span><span class="s1">] + [</span><span class="s4">'SHORT'</span><span class="s0">, </span><span class="s4">'UINT'</span><span class="s1">]</span>

<span class="s1">_cast_dict[</span><span class="s4">'LONG'</span><span class="s1">] = _cast_dict[</span><span class="s4">'INT'</span><span class="s1">] + [</span><span class="s4">'LONG'</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s4">'ULONG'</span><span class="s1">] = _cast_dict[</span><span class="s4">'UINT'</span><span class="s1">] + [</span><span class="s4">'ULONG'</span><span class="s1">]</span>

<span class="s1">_cast_dict[</span><span class="s4">'LONGLONG'</span><span class="s1">] = _cast_dict[</span><span class="s4">'LONG'</span><span class="s1">] + [</span><span class="s4">'LONGLONG'</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s4">'ULONGLONG'</span><span class="s1">] = _cast_dict[</span><span class="s4">'ULONG'</span><span class="s1">] + [</span><span class="s4">'ULONGLONG'</span><span class="s1">]</span>

<span class="s1">_cast_dict[</span><span class="s4">'FLOAT'</span><span class="s1">] = _cast_dict[</span><span class="s4">'SHORT'</span><span class="s1">] + [</span><span class="s4">'USHORT'</span><span class="s0">, </span><span class="s4">'FLOAT'</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s4">'DOUBLE'</span><span class="s1">] = _cast_dict[</span><span class="s4">'INT'</span><span class="s1">] + [</span><span class="s4">'UINT'</span><span class="s0">, </span><span class="s4">'FLOAT'</span><span class="s0">, </span><span class="s4">'DOUBLE'</span><span class="s1">]</span>

<span class="s1">_cast_dict[</span><span class="s4">'CFLOAT'</span><span class="s1">] = _cast_dict[</span><span class="s4">'FLOAT'</span><span class="s1">] + [</span><span class="s4">'CFLOAT'</span><span class="s1">]</span>

<span class="s3"># 32 bit system malloc typically does not provide the alignment required by</span>
<span class="s3"># 16 byte long double types this means the inout intent cannot be satisfied</span>
<span class="s3"># and several tests fail as the alignment flag can be randomly true or fals</span>
<span class="s3"># when numpy gains an aligned allocator the tests could be enabled again</span>
<span class="s3">#</span>
<span class="s3"># Furthermore, on macOS ARM64, LONGDOUBLE is an alias for DOUBLE.</span>
<span class="s0">if </span><span class="s1">((np.intp().dtype.itemsize != </span><span class="s5">4 </span><span class="s0">or </span><span class="s1">np.clongdouble().dtype.alignment &lt;= </span><span class="s5">8</span><span class="s1">) </span><span class="s0">and</span>
        <span class="s1">sys.platform != </span><span class="s4">'win32' </span><span class="s0">and</span>
        <span class="s1">(platform.system()</span><span class="s0">, </span><span class="s1">platform.processor()) != (</span><span class="s4">'Darwin'</span><span class="s0">, </span><span class="s4">'arm'</span><span class="s1">)):</span>
    <span class="s1">_type_names.extend([</span><span class="s4">'LONGDOUBLE'</span><span class="s0">, </span><span class="s4">'CDOUBLE'</span><span class="s0">, </span><span class="s4">'CLONGDOUBLE'</span><span class="s1">])</span>
    <span class="s1">_cast_dict[</span><span class="s4">'LONGDOUBLE'</span><span class="s1">] = _cast_dict[</span><span class="s4">'LONG'</span><span class="s1">] + \</span>
        <span class="s1">[</span><span class="s4">'ULONG'</span><span class="s0">, </span><span class="s4">'FLOAT'</span><span class="s0">, </span><span class="s4">'DOUBLE'</span><span class="s0">, </span><span class="s4">'LONGDOUBLE'</span><span class="s1">]</span>
    <span class="s1">_cast_dict[</span><span class="s4">'CLONGDOUBLE'</span><span class="s1">] = _cast_dict[</span><span class="s4">'LONGDOUBLE'</span><span class="s1">] + \</span>
        <span class="s1">[</span><span class="s4">'CFLOAT'</span><span class="s0">, </span><span class="s4">'CDOUBLE'</span><span class="s0">, </span><span class="s4">'CLONGDOUBLE'</span><span class="s1">]</span>
    <span class="s1">_cast_dict[</span><span class="s4">'CDOUBLE'</span><span class="s1">] = _cast_dict[</span><span class="s4">'DOUBLE'</span><span class="s1">] + [</span><span class="s4">'CFLOAT'</span><span class="s0">, </span><span class="s4">'CDOUBLE'</span><span class="s1">]</span>


<span class="s0">class </span><span class="s1">Type:</span>
    <span class="s1">_type_cache = {}</span>

    <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s0">if </span><span class="s1">isinstance(name</span><span class="s0">, </span><span class="s1">np.dtype):</span>
            <span class="s1">dtype0 = name</span>
            <span class="s1">name = </span><span class="s0">None</span>
            <span class="s0">for </span><span class="s1">n</span><span class="s0">, </span><span class="s1">i </span><span class="s0">in </span><span class="s1">typeinfo.items():</span>
                <span class="s0">if not </span><span class="s1">isinstance(i</span><span class="s0">, </span><span class="s1">type) </span><span class="s0">and </span><span class="s1">dtype0.type </span><span class="s0">is </span><span class="s1">i.type:</span>
                    <span class="s1">name = n</span>
                    <span class="s0">break</span>
        <span class="s1">obj = cls._type_cache.get(name.upper()</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">obj </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">obj</span>
        <span class="s1">obj = object.__new__(cls)</span>
        <span class="s1">obj._init(name)</span>
        <span class="s1">cls._type_cache[name.upper()] = obj</span>
        <span class="s0">return </span><span class="s1">obj</span>

    <span class="s0">def </span><span class="s1">_init(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s1">self.NAME = name.upper()</span>
        <span class="s1">info = typeinfo[self.NAME]</span>
        <span class="s1">self.type_num = getattr(wrap</span><span class="s0">, </span><span class="s4">'NPY_' </span><span class="s1">+ self.NAME)</span>
        <span class="s1">assert_equal(self.type_num</span><span class="s0">, </span><span class="s1">info.num)</span>
        <span class="s1">self.dtype = np.dtype(info.type)</span>
        <span class="s1">self.type = info.type</span>
        <span class="s1">self.elsize = info.bits / </span><span class="s5">8</span>
        <span class="s1">self.dtypechar = info.char</span>

    <span class="s0">def </span><span class="s1">cast_types(self):</span>
        <span class="s0">return </span><span class="s1">[self.__class__(_m) </span><span class="s0">for </span><span class="s1">_m </span><span class="s0">in </span><span class="s1">_cast_dict[self.NAME]]</span>

    <span class="s0">def </span><span class="s1">all_types(self):</span>
        <span class="s0">return </span><span class="s1">[self.__class__(_m) </span><span class="s0">for </span><span class="s1">_m </span><span class="s0">in </span><span class="s1">_type_names]</span>

    <span class="s0">def </span><span class="s1">smaller_types(self):</span>
        <span class="s1">bits = typeinfo[self.NAME].alignment</span>
        <span class="s1">types = []</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">_type_names:</span>
            <span class="s0">if </span><span class="s1">typeinfo[name].alignment &lt; bits:</span>
                <span class="s1">types.append(Type(name))</span>
        <span class="s0">return </span><span class="s1">types</span>

    <span class="s0">def </span><span class="s1">equal_types(self):</span>
        <span class="s1">bits = typeinfo[self.NAME].alignment</span>
        <span class="s1">types = []</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">_type_names:</span>
            <span class="s0">if </span><span class="s1">name == self.NAME:</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">typeinfo[name].alignment == bits:</span>
                <span class="s1">types.append(Type(name))</span>
        <span class="s0">return </span><span class="s1">types</span>

    <span class="s0">def </span><span class="s1">larger_types(self):</span>
        <span class="s1">bits = typeinfo[self.NAME].alignment</span>
        <span class="s1">types = []</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">_type_names:</span>
            <span class="s0">if </span><span class="s1">typeinfo[name].alignment &gt; bits:</span>
                <span class="s1">types.append(Type(name))</span>
        <span class="s0">return </span><span class="s1">types</span>


<span class="s0">class </span><span class="s1">Array:</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">typ</span><span class="s0">, </span><span class="s1">dims</span><span class="s0">, </span><span class="s1">intent</span><span class="s0">, </span><span class="s1">obj):</span>
        <span class="s1">self.type = typ</span>
        <span class="s1">self.dims = dims</span>
        <span class="s1">self.intent = intent</span>
        <span class="s1">self.obj_copy = copy.deepcopy(obj)</span>
        <span class="s1">self.obj = obj</span>

        <span class="s3"># arr.dtypechar may be different from typ.dtypechar</span>
        <span class="s1">self.arr = wrap.call(typ.type_num</span><span class="s0">, </span><span class="s1">dims</span><span class="s0">, </span><span class="s1">intent.flags</span><span class="s0">, </span><span class="s1">obj)</span>

        <span class="s1">assert_(isinstance(self.arr</span><span class="s0">, </span><span class="s1">np.ndarray)</span><span class="s0">, </span><span class="s1">repr(type(self.arr)))</span>

        <span class="s1">self.arr_attr = wrap.array_attrs(self.arr)</span>

        <span class="s0">if </span><span class="s1">len(dims) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.intent.is_intent(</span><span class="s4">'c'</span><span class="s1">):</span>
                <span class="s1">assert_(intent.flags &amp; wrap.F2PY_INTENT_C)</span>
                <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">self.arr.flags[</span><span class="s4">'FORTRAN'</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">repr((self.arr.flags</span><span class="s0">, </span><span class="s1">getattr(obj</span><span class="s0">, </span><span class="s4">'flags'</span><span class="s0">, None</span><span class="s1">))))</span>
                <span class="s1">assert_(self.arr.flags[</span><span class="s4">'CONTIGUOUS'</span><span class="s1">])</span>
                <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">self.arr_attr[</span><span class="s5">6</span><span class="s1">] &amp; wrap.FORTRAN)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">intent.flags &amp; wrap.F2PY_INTENT_C)</span>
                <span class="s1">assert_(self.arr.flags[</span><span class="s4">'FORTRAN'</span><span class="s1">])</span>
                <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">self.arr.flags[</span><span class="s4">'CONTIGUOUS'</span><span class="s1">])</span>
                <span class="s1">assert_(self.arr_attr[</span><span class="s5">6</span><span class="s1">] &amp; wrap.FORTRAN)</span>

        <span class="s0">if </span><span class="s1">obj </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.pyarr = </span><span class="s0">None</span>
            <span class="s1">self.pyarr_attr = </span><span class="s0">None</span>
            <span class="s0">return</span>

        <span class="s0">if </span><span class="s1">intent.is_intent(</span><span class="s4">'cache'</span><span class="s1">):</span>
            <span class="s1">assert_(isinstance(obj</span><span class="s0">, </span><span class="s1">np.ndarray)</span><span class="s0">, </span><span class="s1">repr(type(obj)))</span>
            <span class="s1">self.pyarr = np.array(obj).reshape(*dims).copy()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.pyarr = np.array(</span>
                    <span class="s1">np.array(obj</span><span class="s0">, </span><span class="s1">dtype=typ.dtypechar).reshape(*dims)</span><span class="s0">,</span>
                    <span class="s1">order=self.intent.is_intent(</span><span class="s4">'c'</span><span class="s1">) </span><span class="s0">and </span><span class="s4">'C' </span><span class="s0">or </span><span class="s4">'F'</span><span class="s1">)</span>
            <span class="s1">assert_(self.pyarr.dtype == typ</span><span class="s0">,</span>
                    <span class="s1">repr((self.pyarr.dtype</span><span class="s0">, </span><span class="s1">typ)))</span>
        <span class="s1">self.pyarr.setflags(write=self.arr.flags[</span><span class="s4">'WRITEABLE'</span><span class="s1">])</span>
        <span class="s1">assert_(self.pyarr.flags[</span><span class="s4">'OWNDATA'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(obj</span><span class="s0">, </span><span class="s1">intent))</span>
        <span class="s1">self.pyarr_attr = wrap.array_attrs(self.pyarr)</span>

        <span class="s0">if </span><span class="s1">len(dims) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.intent.is_intent(</span><span class="s4">'c'</span><span class="s1">):</span>
                <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">self.pyarr.flags[</span><span class="s4">'FORTRAN'</span><span class="s1">])</span>
                <span class="s1">assert_(self.pyarr.flags[</span><span class="s4">'CONTIGUOUS'</span><span class="s1">])</span>
                <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">self.pyarr_attr[</span><span class="s5">6</span><span class="s1">] &amp; wrap.FORTRAN)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assert_(self.pyarr.flags[</span><span class="s4">'FORTRAN'</span><span class="s1">])</span>
                <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">self.pyarr.flags[</span><span class="s4">'CONTIGUOUS'</span><span class="s1">])</span>
                <span class="s1">assert_(self.pyarr_attr[</span><span class="s5">6</span><span class="s1">] &amp; wrap.FORTRAN)</span>

        <span class="s1">assert_(self.arr_attr[</span><span class="s5">1</span><span class="s1">] == self.pyarr_attr[</span><span class="s5">1</span><span class="s1">])  </span><span class="s3"># nd</span>
        <span class="s1">assert_(self.arr_attr[</span><span class="s5">2</span><span class="s1">] == self.pyarr_attr[</span><span class="s5">2</span><span class="s1">])  </span><span class="s3"># dimensions</span>
        <span class="s0">if </span><span class="s1">self.arr_attr[</span><span class="s5">1</span><span class="s1">] &lt;= </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">assert_(self.arr_attr[</span><span class="s5">3</span><span class="s1">] == self.pyarr_attr[</span><span class="s5">3</span><span class="s1">]</span><span class="s0">,</span>
                    <span class="s1">repr((self.arr_attr[</span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.pyarr_attr[</span><span class="s5">3</span><span class="s1">]</span><span class="s0">,</span>
                          <span class="s1">self.arr.tobytes()</span><span class="s0">, </span><span class="s1">self.pyarr.tobytes())))  </span><span class="s3"># strides</span>
        <span class="s1">assert_(self.arr_attr[</span><span class="s5">5</span><span class="s1">][-</span><span class="s5">2</span><span class="s1">:] == self.pyarr_attr[</span><span class="s5">5</span><span class="s1">][-</span><span class="s5">2</span><span class="s1">:]</span><span class="s0">,</span>
                <span class="s1">repr((self.arr_attr[</span><span class="s5">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.pyarr_attr[</span><span class="s5">5</span><span class="s1">])))  </span><span class="s3"># descr</span>
        <span class="s1">assert_(self.arr_attr[</span><span class="s5">6</span><span class="s1">] == self.pyarr_attr[</span><span class="s5">6</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">repr((self.arr_attr[</span><span class="s5">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.pyarr_attr[</span><span class="s5">6</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">flags2names(</span><span class="s5">0 </span><span class="s1">* self.arr_attr[</span><span class="s5">6</span><span class="s1">] - self.pyarr_attr[</span><span class="s5">6</span><span class="s1">])</span><span class="s0">,</span>
                      <span class="s1">flags2names(self.arr_attr[</span><span class="s5">6</span><span class="s1">])</span><span class="s0">, </span><span class="s1">intent)))  </span><span class="s3"># flags</span>

        <span class="s0">if </span><span class="s1">intent.is_intent(</span><span class="s4">'cache'</span><span class="s1">):</span>
            <span class="s1">assert_(self.arr_attr[</span><span class="s5">5</span><span class="s1">][</span><span class="s5">3</span><span class="s1">] &gt;= self.type.elsize</span><span class="s0">,</span>
                    <span class="s1">repr((self.arr_attr[</span><span class="s5">5</span><span class="s1">][</span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.type.elsize)))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">assert_(self.arr_attr[</span><span class="s5">5</span><span class="s1">][</span><span class="s5">3</span><span class="s1">] == self.type.elsize</span><span class="s0">,</span>
                    <span class="s1">repr((self.arr_attr[</span><span class="s5">5</span><span class="s1">][</span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.type.elsize)))</span>
        <span class="s1">assert_(self.arr_equal(self.pyarr</span><span class="s0">, </span><span class="s1">self.arr))</span>

        <span class="s0">if </span><span class="s1">isinstance(self.obj</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
            <span class="s0">if </span><span class="s1">typ.elsize == Type(obj.dtype).elsize:</span>
                <span class="s0">if not </span><span class="s1">intent.is_intent(</span><span class="s4">'copy'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">self.arr_attr[</span><span class="s5">1</span><span class="s1">] &lt;= </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">assert_(self.has_shared_memory())</span>

    <span class="s0">def </span><span class="s1">arr_equal(self</span><span class="s0">, </span><span class="s1">arr1</span><span class="s0">, </span><span class="s1">arr2):</span>
        <span class="s0">if </span><span class="s1">arr1.shape != arr2.shape:</span>
            <span class="s0">return False</span>
        <span class="s0">return </span><span class="s1">(arr1 == arr2).all()</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s1">str(self.arr)</span>

    <span class="s0">def </span><span class="s1">has_shared_memory(self):</span>
        <span class="s2">&quot;&quot;&quot;Check that created array shares data with input array. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.obj </span><span class="s0">is </span><span class="s1">self.arr:</span>
            <span class="s0">return True</span>
        <span class="s0">if not </span><span class="s1">isinstance(self.obj</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
            <span class="s0">return False</span>
        <span class="s1">obj_attr = wrap.array_attrs(self.obj)</span>
        <span class="s0">return </span><span class="s1">obj_attr[</span><span class="s5">0</span><span class="s1">] == self.arr_attr[</span><span class="s5">0</span><span class="s1">]</span>


<span class="s0">class </span><span class="s1">TestIntent:</span>

    <span class="s0">def </span><span class="s1">test_in_out(self):</span>
        <span class="s1">assert_equal(str(intent.in_.out)</span><span class="s0">, </span><span class="s4">'intent(in,out)'</span><span class="s1">)</span>
        <span class="s1">assert_(intent.in_.c.is_intent(</span><span class="s4">'c'</span><span class="s1">))</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">intent.in_.c.is_intent_exact(</span><span class="s4">'c'</span><span class="s1">))</span>
        <span class="s1">assert_(intent.in_.c.is_intent_exact(</span><span class="s4">'c'</span><span class="s0">, </span><span class="s4">'in'</span><span class="s1">))</span>
        <span class="s1">assert_(intent.in_.c.is_intent_exact(</span><span class="s4">'in'</span><span class="s0">, </span><span class="s4">'c'</span><span class="s1">))</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">intent.in_.is_intent(</span><span class="s4">'c'</span><span class="s1">))</span>


<span class="s0">class </span><span class="s1">TestSharedMemory:</span>
    <span class="s1">num2seq = [</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span>
    <span class="s1">num23seq = [[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">6</span><span class="s1">]]</span>

    <span class="s1">@pytest.fixture(autouse=</span><span class="s0">True, </span><span class="s1">scope=</span><span class="s4">'class'</span><span class="s0">, </span><span class="s1">params=_type_names)</span>
    <span class="s0">def </span><span class="s1">setup_type(self</span><span class="s0">, </span><span class="s1">request):</span>
        <span class="s1">request.cls.type = Type(request.param)</span>
        <span class="s1">request.cls.array = </span><span class="s0">lambda </span><span class="s1">self</span><span class="s0">, </span><span class="s1">dims</span><span class="s0">, </span><span class="s1">intent</span><span class="s0">, </span><span class="s1">obj: \</span>
            <span class="s1">Array(Type(request.param)</span><span class="s0">, </span><span class="s1">dims</span><span class="s0">, </span><span class="s1">intent</span><span class="s0">, </span><span class="s1">obj)</span>

    <span class="s0">def </span><span class="s1">test_in_from_2seq(self):</span>
        <span class="s1">a = self.array([</span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">intent.in_</span><span class="s0">, </span><span class="s1">self.num2seq)</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">a.has_shared_memory())</span>

    <span class="s0">def </span><span class="s1">test_in_from_2casttype(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.cast_types():</span>
            <span class="s1">obj = np.array(self.num2seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype)</span>
            <span class="s1">a = self.array([len(self.num2seq)]</span><span class="s0">, </span><span class="s1">intent.in_</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s0">if </span><span class="s1">t.elsize == self.type.elsize:</span>
                <span class="s1">assert_(</span>
                    <span class="s1">a.has_shared_memory()</span><span class="s0">, </span><span class="s1">repr((self.type.dtype</span><span class="s0">, </span><span class="s1">t.dtype)))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">a.has_shared_memory()</span><span class="s0">, </span><span class="s1">repr(t.dtype))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'write'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">'w'</span><span class="s0">, </span><span class="s4">'ro'</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'order'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">'C'</span><span class="s0">, </span><span class="s4">'F'</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'inp'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">'2seq'</span><span class="s0">, </span><span class="s4">'23seq'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_in_nocopy(self</span><span class="s0">, </span><span class="s1">write</span><span class="s0">, </span><span class="s1">order</span><span class="s0">, </span><span class="s1">inp):</span>
        <span class="s2">&quot;&quot;&quot;Test if intent(in) array can be passed without copies 
        &quot;&quot;&quot;</span>
        <span class="s1">seq = getattr(self</span><span class="s0">, </span><span class="s4">'num' </span><span class="s1">+ inp)</span>
        <span class="s1">obj = np.array(seq</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype</span><span class="s0">, </span><span class="s1">order=order)</span>
        <span class="s1">obj.setflags(write=(write == </span><span class="s4">'w'</span><span class="s1">))</span>
        <span class="s1">a = self.array(obj.shape</span><span class="s0">, </span><span class="s1">((order==</span><span class="s4">'C' </span><span class="s0">and </span><span class="s1">intent.in_.c) </span><span class="s0">or </span><span class="s1">intent.in_)</span><span class="s0">, </span><span class="s1">obj)</span>
        <span class="s0">assert </span><span class="s1">a.has_shared_memory()</span>

    <span class="s0">def </span><span class="s1">test_inout_2seq(self):</span>
        <span class="s1">obj = np.array(self.num2seq</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype)</span>
        <span class="s1">a = self.array([len(self.num2seq)]</span><span class="s0">, </span><span class="s1">intent.inout</span><span class="s0">, </span><span class="s1">obj)</span>
        <span class="s1">assert_(a.has_shared_memory())</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">a = self.array([</span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">intent.in_.inout</span><span class="s0">, </span><span class="s1">self.num2seq)</span>
        <span class="s0">except </span><span class="s1">TypeError </span><span class="s0">as </span><span class="s1">msg:</span>
            <span class="s0">if not </span><span class="s1">str(msg).startswith(</span><span class="s4">'failed to initialize intent'</span>
                                       <span class="s4">'(inout|inplace|cache) array'</span><span class="s1">):</span>
                <span class="s0">raise</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">SystemError(</span><span class="s4">'intent(inout) should have failed on sequence'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_f_inout_23seq(self):</span>
        <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype</span><span class="s0">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
        <span class="s1">shape = (len(self.num23seq)</span><span class="s0">, </span><span class="s1">len(self.num23seq[</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.in_.inout</span><span class="s0">, </span><span class="s1">obj)</span>
        <span class="s1">assert_(a.has_shared_memory())</span>

        <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype</span><span class="s0">, </span><span class="s1">order=</span><span class="s4">'C'</span><span class="s1">)</span>
        <span class="s1">shape = (len(self.num23seq)</span><span class="s0">, </span><span class="s1">len(self.num23seq[</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.in_.inout</span><span class="s0">, </span><span class="s1">obj)</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">msg:</span>
            <span class="s0">if not </span><span class="s1">str(msg).startswith(</span><span class="s4">'failed to initialize intent'</span>
                                       <span class="s4">'(inout) array'</span><span class="s1">):</span>
                <span class="s0">raise</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">SystemError(</span>
                <span class="s4">'intent(inout) should have failed on improper array'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_c_inout_23seq(self):</span>
        <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype)</span>
        <span class="s1">shape = (len(self.num23seq)</span><span class="s0">, </span><span class="s1">len(self.num23seq[</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.in_.c.inout</span><span class="s0">, </span><span class="s1">obj)</span>
        <span class="s1">assert_(a.has_shared_memory())</span>

    <span class="s0">def </span><span class="s1">test_in_copy_from_2casttype(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.cast_types():</span>
            <span class="s1">obj = np.array(self.num2seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype)</span>
            <span class="s1">a = self.array([len(self.num2seq)]</span><span class="s0">, </span><span class="s1">intent.in_.copy</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">a.has_shared_memory()</span><span class="s0">, </span><span class="s1">repr(t.dtype))</span>

    <span class="s0">def </span><span class="s1">test_c_in_from_23seq(self):</span>
        <span class="s1">a = self.array([len(self.num23seq)</span><span class="s0">, </span><span class="s1">len(self.num23seq[</span><span class="s5">0</span><span class="s1">])]</span><span class="s0">,</span>
                       <span class="s1">intent.in_</span><span class="s0">, </span><span class="s1">self.num23seq)</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">a.has_shared_memory())</span>

    <span class="s0">def </span><span class="s1">test_in_from_23casttype(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.cast_types():</span>
            <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype)</span>
            <span class="s1">a = self.array([len(self.num23seq)</span><span class="s0">, </span><span class="s1">len(self.num23seq[</span><span class="s5">0</span><span class="s1">])]</span><span class="s0">,</span>
                           <span class="s1">intent.in_</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">a.has_shared_memory()</span><span class="s0">, </span><span class="s1">repr(t.dtype))</span>

    <span class="s0">def </span><span class="s1">test_f_in_from_23casttype(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.cast_types():</span>
            <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype</span><span class="s0">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
            <span class="s1">a = self.array([len(self.num23seq)</span><span class="s0">, </span><span class="s1">len(self.num23seq[</span><span class="s5">0</span><span class="s1">])]</span><span class="s0">,</span>
                           <span class="s1">intent.in_</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s0">if </span><span class="s1">t.elsize == self.type.elsize:</span>
                <span class="s1">assert_(a.has_shared_memory()</span><span class="s0">, </span><span class="s1">repr(t.dtype))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">a.has_shared_memory()</span><span class="s0">, </span><span class="s1">repr(t.dtype))</span>

    <span class="s0">def </span><span class="s1">test_c_in_from_23casttype(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.cast_types():</span>
            <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype)</span>
            <span class="s1">a = self.array([len(self.num23seq)</span><span class="s0">, </span><span class="s1">len(self.num23seq[</span><span class="s5">0</span><span class="s1">])]</span><span class="s0">,</span>
                           <span class="s1">intent.in_.c</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s0">if </span><span class="s1">t.elsize == self.type.elsize:</span>
                <span class="s1">assert_(a.has_shared_memory()</span><span class="s0">, </span><span class="s1">repr(t.dtype))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">a.has_shared_memory()</span><span class="s0">, </span><span class="s1">repr(t.dtype))</span>

    <span class="s0">def </span><span class="s1">test_f_copy_in_from_23casttype(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.cast_types():</span>
            <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype</span><span class="s0">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
            <span class="s1">a = self.array([len(self.num23seq)</span><span class="s0">, </span><span class="s1">len(self.num23seq[</span><span class="s5">0</span><span class="s1">])]</span><span class="s0">,</span>
                           <span class="s1">intent.in_.copy</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">a.has_shared_memory()</span><span class="s0">, </span><span class="s1">repr(t.dtype))</span>

    <span class="s0">def </span><span class="s1">test_c_copy_in_from_23casttype(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.cast_types():</span>
            <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype)</span>
            <span class="s1">a = self.array([len(self.num23seq)</span><span class="s0">, </span><span class="s1">len(self.num23seq[</span><span class="s5">0</span><span class="s1">])]</span><span class="s0">,</span>
                           <span class="s1">intent.in_.c.copy</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">a.has_shared_memory()</span><span class="s0">, </span><span class="s1">repr(t.dtype))</span>

    <span class="s0">def </span><span class="s1">test_in_cache_from_2casttype(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.all_types():</span>
            <span class="s0">if </span><span class="s1">t.elsize != self.type.elsize:</span>
                <span class="s0">continue</span>
            <span class="s1">obj = np.array(self.num2seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype)</span>
            <span class="s1">shape = (len(self.num2seq)</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.in_.c.cache</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s1">assert_(a.has_shared_memory()</span><span class="s0">, </span><span class="s1">repr(t.dtype))</span>

            <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.in_.cache</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s1">assert_(a.has_shared_memory()</span><span class="s0">, </span><span class="s1">repr(t.dtype))</span>

            <span class="s1">obj = np.array(self.num2seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype</span><span class="s0">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
            <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.in_.c.cache</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s1">assert_(a.has_shared_memory()</span><span class="s0">, </span><span class="s1">repr(t.dtype))</span>

            <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.in_.cache</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s1">assert_(a.has_shared_memory()</span><span class="s0">, </span><span class="s1">repr(t.dtype))</span>

            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.in_.cache</span><span class="s0">, </span><span class="s1">obj[::-</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">msg:</span>
                <span class="s0">if not </span><span class="s1">str(msg).startswith(</span><span class="s4">'failed to initialize'</span>
                                           <span class="s4">' intent(cache) array'</span><span class="s1">):</span>
                    <span class="s0">raise</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">SystemError(</span>
                    <span class="s4">'intent(cache) should have failed on multisegmented array'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_in_cache_from_2casttype_failure(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.all_types():</span>
            <span class="s0">if </span><span class="s1">t.elsize &gt;= self.type.elsize:</span>
                <span class="s0">continue</span>
            <span class="s1">obj = np.array(self.num2seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype)</span>
            <span class="s1">shape = (len(self.num2seq)</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">self.array(shape</span><span class="s0">, </span><span class="s1">intent.in_.cache</span><span class="s0">, </span><span class="s1">obj)  </span><span class="s3"># Should succeed</span>
            <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">msg:</span>
                <span class="s0">if not </span><span class="s1">str(msg).startswith(</span><span class="s4">'failed to initialize'</span>
                                           <span class="s4">' intent(cache) array'</span><span class="s1">):</span>
                    <span class="s0">raise</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">SystemError(</span>
                    <span class="s4">'intent(cache) should have failed on smaller array'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_cache_hidden(self):</span>
        <span class="s1">shape = (</span><span class="s5">2</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.cache.hide</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">assert_(a.arr.shape == shape)</span>

        <span class="s1">shape = (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.cache.hide</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">assert_(a.arr.shape == shape)</span>

        <span class="s1">shape = (-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.cache.hide</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">msg:</span>
            <span class="s0">if not </span><span class="s1">str(msg).startswith(</span><span class="s4">'failed to create intent'</span>
                                       <span class="s4">'(cache|hide)|optional array'</span><span class="s1">):</span>
                <span class="s0">raise</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">SystemError(</span>
                <span class="s4">'intent(cache) should have failed on undefined dimensions'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_hidden(self):</span>
        <span class="s1">shape = (</span><span class="s5">2</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.hide</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">assert_(a.arr.shape == shape)</span>
        <span class="s1">assert_(a.arr_equal(a.arr</span><span class="s0">, </span><span class="s1">np.zeros(shape</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype)))</span>

        <span class="s1">shape = (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.hide</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">assert_(a.arr.shape == shape)</span>
        <span class="s1">assert_(a.arr_equal(a.arr</span><span class="s0">, </span><span class="s1">np.zeros(shape</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype)))</span>
        <span class="s1">assert_(a.arr.flags[</span><span class="s4">'FORTRAN'</span><span class="s1">] </span><span class="s0">and not </span><span class="s1">a.arr.flags[</span><span class="s4">'CONTIGUOUS'</span><span class="s1">])</span>

        <span class="s1">shape = (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.c.hide</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">assert_(a.arr.shape == shape)</span>
        <span class="s1">assert_(a.arr_equal(a.arr</span><span class="s0">, </span><span class="s1">np.zeros(shape</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype)))</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">a.arr.flags[</span><span class="s4">'FORTRAN'</span><span class="s1">] </span><span class="s0">and </span><span class="s1">a.arr.flags[</span><span class="s4">'CONTIGUOUS'</span><span class="s1">])</span>

        <span class="s1">shape = (-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.hide</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">msg:</span>
            <span class="s0">if not </span><span class="s1">str(msg).startswith(</span><span class="s4">'failed to create intent'</span>
                                       <span class="s4">'(cache|hide)|optional array'</span><span class="s1">):</span>
                <span class="s0">raise</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">SystemError(</span><span class="s4">'intent(hide) should have failed'</span>
                              <span class="s4">' on undefined dimensions'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_optional_none(self):</span>
        <span class="s1">shape = (</span><span class="s5">2</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.optional</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">assert_(a.arr.shape == shape)</span>
        <span class="s1">assert_(a.arr_equal(a.arr</span><span class="s0">, </span><span class="s1">np.zeros(shape</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype)))</span>

        <span class="s1">shape = (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.optional</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">assert_(a.arr.shape == shape)</span>
        <span class="s1">assert_(a.arr_equal(a.arr</span><span class="s0">, </span><span class="s1">np.zeros(shape</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype)))</span>
        <span class="s1">assert_(a.arr.flags[</span><span class="s4">'FORTRAN'</span><span class="s1">] </span><span class="s0">and not </span><span class="s1">a.arr.flags[</span><span class="s4">'CONTIGUOUS'</span><span class="s1">])</span>

        <span class="s1">shape = (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.c.optional</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">assert_(a.arr.shape == shape)</span>
        <span class="s1">assert_(a.arr_equal(a.arr</span><span class="s0">, </span><span class="s1">np.zeros(shape</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype)))</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">a.arr.flags[</span><span class="s4">'FORTRAN'</span><span class="s1">] </span><span class="s0">and </span><span class="s1">a.arr.flags[</span><span class="s4">'CONTIGUOUS'</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_optional_from_2seq(self):</span>
        <span class="s1">obj = self.num2seq</span>
        <span class="s1">shape = (len(obj)</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.optional</span><span class="s0">, </span><span class="s1">obj)</span>
        <span class="s1">assert_(a.arr.shape == shape)</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">a.has_shared_memory())</span>

    <span class="s0">def </span><span class="s1">test_optional_from_23seq(self):</span>
        <span class="s1">obj = self.num23seq</span>
        <span class="s1">shape = (len(obj)</span><span class="s0">, </span><span class="s1">len(obj[</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.optional</span><span class="s0">, </span><span class="s1">obj)</span>
        <span class="s1">assert_(a.arr.shape == shape)</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">a.has_shared_memory())</span>

        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.optional.c</span><span class="s0">, </span><span class="s1">obj)</span>
        <span class="s1">assert_(a.arr.shape == shape)</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">a.has_shared_memory())</span>

    <span class="s0">def </span><span class="s1">test_inplace(self):</span>
        <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype)</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">obj.flags[</span><span class="s4">'FORTRAN'</span><span class="s1">] </span><span class="s0">and </span><span class="s1">obj.flags[</span><span class="s4">'CONTIGUOUS'</span><span class="s1">])</span>
        <span class="s1">shape = obj.shape</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.inplace</span><span class="s0">, </span><span class="s1">obj)</span>
        <span class="s1">assert_(obj[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">2</span><span class="s1">] == a.arr[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">repr((obj</span><span class="s0">, </span><span class="s1">a.arr)))</span>
        <span class="s1">a.arr[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">2</span><span class="s1">] = </span><span class="s5">54</span>
        <span class="s1">assert_(obj[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">2</span><span class="s1">] == a.arr[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">2</span><span class="s1">] ==</span>
                <span class="s1">np.array(</span><span class="s5">54</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype)</span><span class="s0">, </span><span class="s1">repr((obj</span><span class="s0">, </span><span class="s1">a.arr)))</span>
        <span class="s1">assert_(a.arr </span><span class="s0">is </span><span class="s1">obj)</span>
        <span class="s1">assert_(obj.flags[</span><span class="s4">'FORTRAN'</span><span class="s1">])  </span><span class="s3"># obj attributes are changed inplace!</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">obj.flags[</span><span class="s4">'CONTIGUOUS'</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_inplace_from_casttype(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.cast_types():</span>
            <span class="s0">if </span><span class="s1">t </span><span class="s0">is </span><span class="s1">self.type:</span>
                <span class="s0">continue</span>
            <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype)</span>
            <span class="s1">assert_(obj.dtype.type == t.type)</span>
            <span class="s1">assert_(obj.dtype.type </span><span class="s0">is not </span><span class="s1">self.type.type)</span>
            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">obj.flags[</span><span class="s4">'FORTRAN'</span><span class="s1">] </span><span class="s0">and </span><span class="s1">obj.flags[</span><span class="s4">'CONTIGUOUS'</span><span class="s1">])</span>
            <span class="s1">shape = obj.shape</span>
            <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.inplace</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s1">assert_(obj[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">2</span><span class="s1">] == a.arr[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">repr((obj</span><span class="s0">, </span><span class="s1">a.arr)))</span>
            <span class="s1">a.arr[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">2</span><span class="s1">] = </span><span class="s5">54</span>
            <span class="s1">assert_(obj[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">2</span><span class="s1">] == a.arr[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">2</span><span class="s1">] ==</span>
                    <span class="s1">np.array(</span><span class="s5">54</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype)</span><span class="s0">, </span><span class="s1">repr((obj</span><span class="s0">, </span><span class="s1">a.arr)))</span>
            <span class="s1">assert_(a.arr </span><span class="s0">is </span><span class="s1">obj)</span>
            <span class="s1">assert_(obj.flags[</span><span class="s4">'FORTRAN'</span><span class="s1">])  </span><span class="s3"># obj attributes changed inplace!</span>
            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">obj.flags[</span><span class="s4">'CONTIGUOUS'</span><span class="s1">])</span>
            <span class="s1">assert_(obj.dtype.type </span><span class="s0">is </span><span class="s1">self.type.type)  </span><span class="s3"># obj changed inplace!</span>
</pre>
</body>
</html>