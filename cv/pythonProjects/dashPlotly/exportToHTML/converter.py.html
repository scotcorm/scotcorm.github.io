<html>
<head>
<title>converter.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
converter.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">contextlib</span>
<span class="s0">import </span><span class="s1">datetime </span><span class="s0">as </span><span class="s1">pydt</span>
<span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">datetime</span><span class="s0">,</span>
    <span class="s1">timedelta</span><span class="s0">,</span>
    <span class="s1">tzinfo</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">functools</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Any</span><span class="s0">,</span>
    <span class="s1">cast</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">dateutil.relativedelta </span><span class="s0">import </span><span class="s1">relativedelta</span>
<span class="s0">import </span><span class="s1">matplotlib.dates </span><span class="s0">as </span><span class="s1">dates</span>
<span class="s0">from </span><span class="s1">matplotlib.ticker </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">AutoLocator</span><span class="s0">,</span>
    <span class="s1">Formatter</span><span class="s0">,</span>
    <span class="s1">Locator</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">matplotlib.transforms </span><span class="s0">import </span><span class="s1">nonsingular</span>
<span class="s0">import </span><span class="s1">matplotlib.units </span><span class="s0">as </span><span class="s1">units</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas._libs </span><span class="s0">import </span><span class="s1">lib</span>
<span class="s0">from </span><span class="s1">pandas._libs.tslibs </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Timestamp</span><span class="s0">,</span>
    <span class="s1">to_offset</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas._libs.tslibs.dtypes </span><span class="s0">import </span><span class="s1">FreqGroup</span>
<span class="s0">from </span><span class="s1">pandas._libs.tslibs.offsets </span><span class="s0">import </span><span class="s1">BaseOffset</span>
<span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">F</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">is_float</span><span class="s0">,</span>
    <span class="s1">is_float_dtype</span><span class="s0">,</span>
    <span class="s1">is_integer</span><span class="s0">,</span>
    <span class="s1">is_integer_dtype</span><span class="s0">,</span>
    <span class="s1">is_nested_list_like</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">get_option</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas.core.common </span><span class="s0">as </span><span class="s1">com</span>
<span class="s0">from </span><span class="s1">pandas.core.indexes.datetimes </span><span class="s0">import </span><span class="s1">date_range</span>
<span class="s0">from </span><span class="s1">pandas.core.indexes.period </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Period</span><span class="s0">,</span>
    <span class="s1">PeriodIndex</span><span class="s0">,</span>
    <span class="s1">period_range</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas.core.tools.datetimes </span><span class="s0">as </span><span class="s1">tools</span>

<span class="s2"># constants</span>
<span class="s1">HOURS_PER_DAY = </span><span class="s3">24.0</span>
<span class="s1">MIN_PER_HOUR = </span><span class="s3">60.0</span>
<span class="s1">SEC_PER_MIN = </span><span class="s3">60.0</span>

<span class="s1">SEC_PER_HOUR = SEC_PER_MIN * MIN_PER_HOUR</span>
<span class="s1">SEC_PER_DAY = SEC_PER_HOUR * HOURS_PER_DAY</span>

<span class="s1">MUSEC_PER_DAY = </span><span class="s3">10 </span><span class="s1">** </span><span class="s3">6 </span><span class="s1">* SEC_PER_DAY</span>

<span class="s1">_mpl_units = {}  </span><span class="s2"># Cache for units overwritten by us</span>


<span class="s0">def </span><span class="s1">get_pairs():</span>
    <span class="s1">pairs = [</span>
        <span class="s1">(Timestamp</span><span class="s0">, </span><span class="s1">DatetimeConverter)</span><span class="s0">,</span>
        <span class="s1">(Period</span><span class="s0">, </span><span class="s1">PeriodConverter)</span><span class="s0">,</span>
        <span class="s1">(pydt.datetime</span><span class="s0">, </span><span class="s1">DatetimeConverter)</span><span class="s0">,</span>
        <span class="s1">(pydt.date</span><span class="s0">, </span><span class="s1">DatetimeConverter)</span><span class="s0">,</span>
        <span class="s1">(pydt.time</span><span class="s0">, </span><span class="s1">TimeConverter)</span><span class="s0">,</span>
        <span class="s1">(np.datetime64</span><span class="s0">, </span><span class="s1">DatetimeConverter)</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s0">return </span><span class="s1">pairs</span>


<span class="s0">def </span><span class="s1">register_pandas_matplotlib_converters(func: F) -&gt; F:</span>
    <span class="s4">&quot;&quot;&quot; 
    Decorator applying pandas_converters. 
    &quot;&quot;&quot;</span>

    <span class="s1">@functools.wraps(func)</span>
    <span class="s0">def </span><span class="s1">wrapper(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">with </span><span class="s1">pandas_converters():</span>
            <span class="s0">return </span><span class="s1">func(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">return </span><span class="s1">cast(F</span><span class="s0">, </span><span class="s1">wrapper)</span>


<span class="s1">@contextlib.contextmanager</span>
<span class="s0">def </span><span class="s1">pandas_converters():</span>
    <span class="s4">&quot;&quot;&quot; 
    Context manager registering pandas' converters for a plot. 
 
    See Also 
    -------- 
    register_pandas_matplotlib_converters : Decorator that applies this. 
    &quot;&quot;&quot;</span>
    <span class="s1">value = get_option(</span><span class="s5">&quot;plotting.matplotlib.register_converters&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">value:</span>
        <span class="s2"># register for True or &quot;auto&quot;</span>
        <span class="s1">register()</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">yield</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">value == </span><span class="s5">&quot;auto&quot;</span><span class="s1">:</span>
            <span class="s2"># only deregister for &quot;auto&quot;</span>
            <span class="s1">deregister()</span>


<span class="s0">def </span><span class="s1">register():</span>
    <span class="s1">pairs = get_pairs()</span>
    <span class="s0">for </span><span class="s1">type_</span><span class="s0">, </span><span class="s1">cls </span><span class="s0">in </span><span class="s1">pairs:</span>
        <span class="s2"># Cache previous converter if present</span>
        <span class="s0">if </span><span class="s1">type_ </span><span class="s0">in </span><span class="s1">units.registry </span><span class="s0">and not </span><span class="s1">isinstance(units.registry[type_]</span><span class="s0">, </span><span class="s1">cls):</span>
            <span class="s1">previous = units.registry[type_]</span>
            <span class="s1">_mpl_units[type_] = previous</span>
        <span class="s2"># Replace with pandas converter</span>
        <span class="s1">units.registry[type_] = cls()</span>


<span class="s0">def </span><span class="s1">deregister():</span>
    <span class="s2"># Renamed in pandas.plotting.__init__</span>
    <span class="s0">for </span><span class="s1">type_</span><span class="s0">, </span><span class="s1">cls </span><span class="s0">in </span><span class="s1">get_pairs():</span>
        <span class="s2"># We use type to catch our classes directly, no inheritance</span>
        <span class="s0">if </span><span class="s1">type(units.registry.get(type_)) </span><span class="s0">is </span><span class="s1">cls:</span>
            <span class="s1">units.registry.pop(type_)</span>

    <span class="s2"># restore the old keys</span>
    <span class="s0">for </span><span class="s1">unit</span><span class="s0">, </span><span class="s1">formatter </span><span class="s0">in </span><span class="s1">_mpl_units.items():</span>
        <span class="s0">if </span><span class="s1">type(formatter) </span><span class="s0">not in </span><span class="s1">{DatetimeConverter</span><span class="s0">, </span><span class="s1">PeriodConverter</span><span class="s0">, </span><span class="s1">TimeConverter}:</span>
            <span class="s2"># make it idempotent by excluding ours.</span>
            <span class="s1">units.registry[unit] = formatter</span>


<span class="s0">def </span><span class="s1">_to_ordinalf(tm: pydt.time) -&gt; float:</span>
    <span class="s1">tot_sec = tm.hour * </span><span class="s3">3600 </span><span class="s1">+ tm.minute * </span><span class="s3">60 </span><span class="s1">+ tm.second + tm.microsecond / </span><span class="s3">10 </span><span class="s1">** </span><span class="s3">6</span>
    <span class="s0">return </span><span class="s1">tot_sec</span>


<span class="s0">def </span><span class="s1">time2num(d):</span>
    <span class="s0">if </span><span class="s1">isinstance(d</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s1">parsed = tools.to_datetime(d)</span>
        <span class="s0">if not </span><span class="s1">isinstance(parsed</span><span class="s0">, </span><span class="s1">datetime):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;Could not parse time </span><span class="s0">{</span><span class="s1">d</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">_to_ordinalf(parsed.time())</span>
    <span class="s0">if </span><span class="s1">isinstance(d</span><span class="s0">, </span><span class="s1">pydt.time):</span>
        <span class="s0">return </span><span class="s1">_to_ordinalf(d)</span>
    <span class="s0">return </span><span class="s1">d</span>


<span class="s0">class </span><span class="s1">TimeConverter(units.ConversionInterface):</span>
    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">convert(value</span><span class="s0">, </span><span class="s1">unit</span><span class="s0">, </span><span class="s1">axis):</span>
        <span class="s1">valid_types = (str</span><span class="s0">, </span><span class="s1">pydt.time)</span>
        <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">valid_types) </span><span class="s0">or </span><span class="s1">is_integer(value) </span><span class="s0">or </span><span class="s1">is_float(value):</span>
            <span class="s0">return </span><span class="s1">time2num(value)</span>
        <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">Index):</span>
            <span class="s0">return </span><span class="s1">value.map(time2num)</span>
        <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">np.ndarray</span><span class="s0">, </span><span class="s1">Index)):</span>
            <span class="s0">return </span><span class="s1">[time2num(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">value]</span>
        <span class="s0">return </span><span class="s1">value</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">axisinfo(unit</span><span class="s0">, </span><span class="s1">axis) -&gt; units.AxisInfo | </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">unit != </span><span class="s5">&quot;time&quot;</span><span class="s1">:</span>
            <span class="s0">return None</span>

        <span class="s1">majloc = AutoLocator()</span>
        <span class="s1">majfmt = TimeFormatter(majloc)</span>
        <span class="s0">return </span><span class="s1">units.AxisInfo(majloc=majloc</span><span class="s0">, </span><span class="s1">majfmt=majfmt</span><span class="s0">, </span><span class="s1">label=</span><span class="s5">&quot;time&quot;</span><span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">default_units(x</span><span class="s0">, </span><span class="s1">axis) -&gt; str:</span>
        <span class="s0">return </span><span class="s5">&quot;time&quot;</span>


<span class="s2"># time formatter</span>
<span class="s0">class </span><span class="s1">TimeFormatter(Formatter):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">locs):</span>
        <span class="s1">self.locs = locs</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">pos=</span><span class="s3">0</span><span class="s1">) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot; 
        Return the time of day as a formatted string. 
 
        Parameters 
        ---------- 
        x : float 
            The time of day specified as seconds since 00:00 (midnight), 
            with up to microsecond precision. 
        pos 
            Unused 
 
        Returns 
        ------- 
        str 
            A string in HH:MM:SS.mmmuuu format. Microseconds, 
            milliseconds and seconds are only displayed if non-zero. 
        &quot;&quot;&quot;</span>
        <span class="s1">fmt = </span><span class="s5">&quot;%H:%M:%S.%f&quot;</span>
        <span class="s1">s = int(x)</span>
        <span class="s1">msus = round((x - s) * </span><span class="s3">10 </span><span class="s1">** </span><span class="s3">6</span><span class="s1">)</span>
        <span class="s1">ms = msus // </span><span class="s3">1000</span>
        <span class="s1">us = msus % </span><span class="s3">1000</span>
        <span class="s1">m</span><span class="s0">, </span><span class="s1">s = divmod(s</span><span class="s0">, </span><span class="s3">60</span><span class="s1">)</span>
        <span class="s1">h</span><span class="s0">, </span><span class="s1">m = divmod(m</span><span class="s0">, </span><span class="s3">60</span><span class="s1">)</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">h = divmod(h</span><span class="s0">, </span><span class="s3">24</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">us != </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">pydt.time(h</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">msus).strftime(fmt)</span>
        <span class="s0">elif </span><span class="s1">ms != </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">pydt.time(h</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">msus).strftime(fmt)[:-</span><span class="s3">3</span><span class="s1">]</span>
        <span class="s0">elif </span><span class="s1">s != </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">pydt.time(h</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">s).strftime(</span><span class="s5">&quot;%H:%M:%S&quot;</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">pydt.time(h</span><span class="s0">, </span><span class="s1">m).strftime(</span><span class="s5">&quot;%H:%M&quot;</span><span class="s1">)</span>


<span class="s2"># Period Conversion</span>


<span class="s0">class </span><span class="s1">PeriodConverter(dates.DateConverter):</span>
    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">convert(values</span><span class="s0">, </span><span class="s1">units</span><span class="s0">, </span><span class="s1">axis):</span>
        <span class="s0">if </span><span class="s1">is_nested_list_like(values):</span>
            <span class="s1">values = [PeriodConverter._convert_1d(v</span><span class="s0">, </span><span class="s1">units</span><span class="s0">, </span><span class="s1">axis) </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">values]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">values = PeriodConverter._convert_1d(values</span><span class="s0">, </span><span class="s1">units</span><span class="s0">, </span><span class="s1">axis)</span>
        <span class="s0">return </span><span class="s1">values</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_convert_1d(values</span><span class="s0">, </span><span class="s1">units</span><span class="s0">, </span><span class="s1">axis):</span>
        <span class="s0">if not </span><span class="s1">hasattr(axis</span><span class="s0">, </span><span class="s5">&quot;freq&quot;</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;Axis must have `freq` set to convert to Periods&quot;</span><span class="s1">)</span>
        <span class="s1">valid_types = (str</span><span class="s0">, </span><span class="s1">datetime</span><span class="s0">, </span><span class="s1">Period</span><span class="s0">, </span><span class="s1">pydt.date</span><span class="s0">, </span><span class="s1">pydt.time</span><span class="s0">, </span><span class="s1">np.datetime64)</span>
        <span class="s0">if </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">valid_types) </span><span class="s0">or </span><span class="s1">is_integer(values) </span><span class="s0">or </span><span class="s1">is_float(values):</span>
            <span class="s0">return </span><span class="s1">get_datevalue(values</span><span class="s0">, </span><span class="s1">axis.freq)</span>
        <span class="s0">elif </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">PeriodIndex):</span>
            <span class="s0">return </span><span class="s1">values.asfreq(axis.freq).asi8</span>
        <span class="s0">elif </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">Index):</span>
            <span class="s0">return </span><span class="s1">values.map(</span><span class="s0">lambda </span><span class="s1">x: get_datevalue(x</span><span class="s0">, </span><span class="s1">axis.freq))</span>
        <span class="s0">elif </span><span class="s1">lib.infer_dtype(values</span><span class="s0">, </span><span class="s1">skipna=</span><span class="s0">False</span><span class="s1">) == </span><span class="s5">&quot;period&quot;</span><span class="s1">:</span>
            <span class="s2"># https://github.com/pandas-dev/pandas/issues/24304</span>
            <span class="s2"># convert ndarray[period] -&gt; PeriodIndex</span>
            <span class="s0">return </span><span class="s1">PeriodIndex(values</span><span class="s0">, </span><span class="s1">freq=axis.freq).asi8</span>
        <span class="s0">elif </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">np.ndarray</span><span class="s0">, </span><span class="s1">Index)):</span>
            <span class="s0">return </span><span class="s1">[get_datevalue(x</span><span class="s0">, </span><span class="s1">axis.freq) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">values]</span>
        <span class="s0">return </span><span class="s1">values</span>


<span class="s0">def </span><span class="s1">get_datevalue(date</span><span class="s0">, </span><span class="s1">freq):</span>
    <span class="s0">if </span><span class="s1">isinstance(date</span><span class="s0">, </span><span class="s1">Period):</span>
        <span class="s0">return </span><span class="s1">date.asfreq(freq).ordinal</span>
    <span class="s0">elif </span><span class="s1">isinstance(date</span><span class="s0">, </span><span class="s1">(str</span><span class="s0">, </span><span class="s1">datetime</span><span class="s0">, </span><span class="s1">pydt.date</span><span class="s0">, </span><span class="s1">pydt.time</span><span class="s0">, </span><span class="s1">np.datetime64)):</span>
        <span class="s0">return </span><span class="s1">Period(date</span><span class="s0">, </span><span class="s1">freq).ordinal</span>
    <span class="s0">elif </span><span class="s1">(</span>
        <span class="s1">is_integer(date)</span>
        <span class="s0">or </span><span class="s1">is_float(date)</span>
        <span class="s0">or </span><span class="s1">(isinstance(date</span><span class="s0">, </span><span class="s1">(np.ndarray</span><span class="s0">, </span><span class="s1">Index)) </span><span class="s0">and </span><span class="s1">(date.size == </span><span class="s3">1</span><span class="s1">))</span>
    <span class="s1">):</span>
        <span class="s0">return </span><span class="s1">date</span>
    <span class="s0">elif </span><span class="s1">date </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return None</span>
    <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;Unrecognizable date '</span><span class="s0">{</span><span class="s1">date</span><span class="s0">}</span><span class="s5">'&quot;</span><span class="s1">)</span>


<span class="s2"># Datetime Conversion</span>
<span class="s0">class </span><span class="s1">DatetimeConverter(dates.DateConverter):</span>
    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">convert(values</span><span class="s0">, </span><span class="s1">unit</span><span class="s0">, </span><span class="s1">axis):</span>
        <span class="s2"># values might be a 1-d array, or a list-like of arrays.</span>
        <span class="s0">if </span><span class="s1">is_nested_list_like(values):</span>
            <span class="s1">values = [DatetimeConverter._convert_1d(v</span><span class="s0">, </span><span class="s1">unit</span><span class="s0">, </span><span class="s1">axis) </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">values]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">values = DatetimeConverter._convert_1d(values</span><span class="s0">, </span><span class="s1">unit</span><span class="s0">, </span><span class="s1">axis)</span>
        <span class="s0">return </span><span class="s1">values</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_convert_1d(values</span><span class="s0">, </span><span class="s1">unit</span><span class="s0">, </span><span class="s1">axis):</span>
        <span class="s0">def </span><span class="s1">try_parse(values):</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">dates.date2num(tools.to_datetime(values))</span>
            <span class="s0">except </span><span class="s1">Exception:</span>
                <span class="s0">return </span><span class="s1">values</span>

        <span class="s0">if </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">(datetime</span><span class="s0">, </span><span class="s1">pydt.date</span><span class="s0">, </span><span class="s1">np.datetime64</span><span class="s0">, </span><span class="s1">pydt.time)):</span>
            <span class="s0">return </span><span class="s1">dates.date2num(values)</span>
        <span class="s0">elif </span><span class="s1">is_integer(values) </span><span class="s0">or </span><span class="s1">is_float(values):</span>
            <span class="s0">return </span><span class="s1">values</span>
        <span class="s0">elif </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">return </span><span class="s1">try_parse(values)</span>
        <span class="s0">elif </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">np.ndarray</span><span class="s0">, </span><span class="s1">Index</span><span class="s0">, </span><span class="s1">Series)):</span>
            <span class="s0">if </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">Series):</span>
                <span class="s2"># https://github.com/matplotlib/matplotlib/issues/11391</span>
                <span class="s2"># Series was skipped. Convert to DatetimeIndex to get asi8</span>
                <span class="s1">values = Index(values)</span>
            <span class="s0">if </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">Index):</span>
                <span class="s1">values = values.values</span>
            <span class="s0">if not </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
                <span class="s1">values = com.asarray_tuplesafe(values)</span>

            <span class="s0">if </span><span class="s1">is_integer_dtype(values) </span><span class="s0">or </span><span class="s1">is_float_dtype(values):</span>
                <span class="s0">return </span><span class="s1">values</span>

            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">values = tools.to_datetime(values)</span>
            <span class="s0">except </span><span class="s1">Exception:</span>
                <span class="s0">pass</span>

            <span class="s1">values = dates.date2num(values)</span>

        <span class="s0">return </span><span class="s1">values</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">axisinfo(unit: tzinfo | </span><span class="s0">None, </span><span class="s1">axis) -&gt; units.AxisInfo:</span>
        <span class="s4">&quot;&quot;&quot; 
        Return the :class:`~matplotlib.units.AxisInfo` for *unit*. 
 
        *unit* is a tzinfo instance or None. 
        The *axis* argument is required but not used. 
        &quot;&quot;&quot;</span>
        <span class="s1">tz = unit</span>

        <span class="s1">majloc = PandasAutoDateLocator(tz=tz)</span>
        <span class="s1">majfmt = PandasAutoDateFormatter(majloc</span><span class="s0">, </span><span class="s1">tz=tz)</span>
        <span class="s1">datemin = pydt.date(</span><span class="s3">2000</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">datemax = pydt.date(</span><span class="s3">2010</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">units.AxisInfo(</span>
            <span class="s1">majloc=majloc</span><span class="s0">, </span><span class="s1">majfmt=majfmt</span><span class="s0">, </span><span class="s1">label=</span><span class="s5">&quot;&quot;</span><span class="s0">, </span><span class="s1">default_limits=(datemin</span><span class="s0">, </span><span class="s1">datemax)</span>
        <span class="s1">)</span>


<span class="s0">class </span><span class="s1">PandasAutoDateFormatter(dates.AutoDateFormatter):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">locator</span><span class="s0">, </span><span class="s1">tz=</span><span class="s0">None, </span><span class="s1">defaultfmt=</span><span class="s5">&quot;%Y-%m-%d&quot;</span><span class="s1">):</span>
        <span class="s1">dates.AutoDateFormatter.__init__(self</span><span class="s0">, </span><span class="s1">locator</span><span class="s0">, </span><span class="s1">tz</span><span class="s0">, </span><span class="s1">defaultfmt)</span>


<span class="s0">class </span><span class="s1">PandasAutoDateLocator(dates.AutoDateLocator):</span>
    <span class="s0">def </span><span class="s1">get_locator(self</span><span class="s0">, </span><span class="s1">dmin</span><span class="s0">, </span><span class="s1">dmax):</span>
        <span class="s4">&quot;&quot;&quot;Pick the best locator based on a distance.&quot;&quot;&quot;</span>
        <span class="s1">delta = relativedelta(dmax</span><span class="s0">, </span><span class="s1">dmin)</span>

        <span class="s1">num_days = (delta.years * </span><span class="s3">12.0 </span><span class="s1">+ delta.months) * </span><span class="s3">31.0 </span><span class="s1">+ delta.days</span>
        <span class="s1">num_sec = (delta.hours * </span><span class="s3">60.0 </span><span class="s1">+ delta.minutes) * </span><span class="s3">60.0 </span><span class="s1">+ delta.seconds</span>
        <span class="s1">tot_sec = num_days * </span><span class="s3">86400.0 </span><span class="s1">+ num_sec</span>

        <span class="s0">if </span><span class="s1">abs(tot_sec) &lt; self.minticks:</span>
            <span class="s1">self._freq = -</span><span class="s3">1</span>
            <span class="s1">locator = MilliSecondLocator(self.tz)</span>
            <span class="s1">locator.set_axis(self.axis)</span>

            <span class="s1">locator.axis.set_view_interval(*self.axis.get_view_interval())</span>
            <span class="s1">locator.axis.set_data_interval(*self.axis.get_data_interval())</span>
            <span class="s0">return </span><span class="s1">locator</span>

        <span class="s0">return </span><span class="s1">dates.AutoDateLocator.get_locator(self</span><span class="s0">, </span><span class="s1">dmin</span><span class="s0">, </span><span class="s1">dmax)</span>

    <span class="s0">def </span><span class="s1">_get_unit(self):</span>
        <span class="s0">return </span><span class="s1">MilliSecondLocator.get_unit_generic(self._freq)</span>


<span class="s0">class </span><span class="s1">MilliSecondLocator(dates.DateLocator):</span>

    <span class="s1">UNIT = </span><span class="s3">1.0 </span><span class="s1">/ (</span><span class="s3">24 </span><span class="s1">* </span><span class="s3">3600 </span><span class="s1">* </span><span class="s3">1000</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">tz):</span>
        <span class="s1">dates.DateLocator.__init__(self</span><span class="s0">, </span><span class="s1">tz)</span>
        <span class="s1">self._interval = </span><span class="s3">1.0</span>

    <span class="s0">def </span><span class="s1">_get_unit(self):</span>
        <span class="s0">return </span><span class="s1">self.get_unit_generic(-</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">get_unit_generic(freq):</span>
        <span class="s1">unit = dates.RRuleLocator.get_unit_generic(freq)</span>
        <span class="s0">if </span><span class="s1">unit &lt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">MilliSecondLocator.UNIT</span>
        <span class="s0">return </span><span class="s1">unit</span>

    <span class="s0">def </span><span class="s1">__call__(self):</span>
        <span class="s2"># if no data have been set, this will tank with a ValueError</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">dmin</span><span class="s0">, </span><span class="s1">dmax = self.viewlim_to_dt()</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s0">return </span><span class="s1">[]</span>

        <span class="s2"># We need to cap at the endpoints of valid datetime</span>
        <span class="s1">nmax</span><span class="s0">, </span><span class="s1">nmin = dates.date2num((dmax</span><span class="s0">, </span><span class="s1">dmin))</span>

        <span class="s1">num = (nmax - nmin) * </span><span class="s3">86400 </span><span class="s1">* </span><span class="s3">1000</span>
        <span class="s1">max_millis_ticks = </span><span class="s3">6</span>
        <span class="s0">for </span><span class="s1">interval </span><span class="s0">in </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">50</span><span class="s0">, </span><span class="s3">100</span><span class="s0">, </span><span class="s3">200</span><span class="s0">, </span><span class="s3">500</span><span class="s1">]:</span>
            <span class="s0">if </span><span class="s1">num &lt;= interval * (max_millis_ticks - </span><span class="s3">1</span><span class="s1">):</span>
                <span class="s1">self._interval = interval</span>
                <span class="s0">break</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># We went through the whole loop without breaking, default to 1</span>
                <span class="s1">self._interval = </span><span class="s3">1000.0</span>

        <span class="s1">estimate = (nmax - nmin) / (self._get_unit() * self._get_interval())</span>

        <span class="s0">if </span><span class="s1">estimate &gt; self.MAXTICKS * </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span>
                <span class="s5">&quot;MillisecondLocator estimated to generate &quot;</span>
                <span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">estimate</span><span class="s0">:</span><span class="s5">d</span><span class="s0">} </span><span class="s5">ticks from </span><span class="s0">{</span><span class="s1">dmin</span><span class="s0">} </span><span class="s5">to </span><span class="s0">{</span><span class="s1">dmax</span><span class="s0">}</span><span class="s5">: exceeds Locator.MAXTICKS&quot;</span>
                <span class="s5">f&quot;* 2 (</span><span class="s0">{</span><span class="s1">self.MAXTICKS * </span><span class="s3">2</span><span class="s0">:</span><span class="s5">d</span><span class="s0">}</span><span class="s5">) &quot;</span>
            <span class="s1">)</span>

        <span class="s1">interval = self._get_interval()</span>
        <span class="s1">freq = </span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">interval</span><span class="s0">}</span><span class="s5">L&quot;</span>
        <span class="s1">tz = self.tz.tzname(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">st = dmin.replace(tzinfo=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">ed = dmin.replace(tzinfo=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">all_dates = date_range(start=st</span><span class="s0">, </span><span class="s1">end=ed</span><span class="s0">, </span><span class="s1">freq=freq</span><span class="s0">, </span><span class="s1">tz=tz).astype(object)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">len(all_dates) &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">locs = self.raise_if_exceeds(dates.date2num(all_dates))</span>
                <span class="s0">return </span><span class="s1">locs</span>
        <span class="s0">except </span><span class="s1">Exception:  </span><span class="s2"># pragma: no cover</span>
            <span class="s0">pass</span>

        <span class="s1">lims = dates.date2num([dmin</span><span class="s0">, </span><span class="s1">dmax])</span>
        <span class="s0">return </span><span class="s1">lims</span>

    <span class="s0">def </span><span class="s1">_get_interval(self):</span>
        <span class="s0">return </span><span class="s1">self._interval</span>

    <span class="s0">def </span><span class="s1">autoscale(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set the view limits to include the data range. 
        &quot;&quot;&quot;</span>
        <span class="s2"># We need to cap at the endpoints of valid datetime</span>
        <span class="s1">dmin</span><span class="s0">, </span><span class="s1">dmax = self.datalim_to_dt()</span>

        <span class="s1">vmin = dates.date2num(dmin)</span>
        <span class="s1">vmax = dates.date2num(dmax)</span>

        <span class="s0">return </span><span class="s1">self.nonsingular(vmin</span><span class="s0">, </span><span class="s1">vmax)</span>


<span class="s0">def </span><span class="s1">_from_ordinal(x</span><span class="s0">, </span><span class="s1">tz: tzinfo | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">) -&gt; datetime:</span>
    <span class="s1">ix = int(x)</span>
    <span class="s1">dt = datetime.fromordinal(ix)</span>
    <span class="s1">remainder = float(x) - ix</span>
    <span class="s1">hour</span><span class="s0">, </span><span class="s1">remainder = divmod(</span><span class="s3">24 </span><span class="s1">* remainder</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">minute</span><span class="s0">, </span><span class="s1">remainder = divmod(</span><span class="s3">60 </span><span class="s1">* remainder</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">second</span><span class="s0">, </span><span class="s1">remainder = divmod(</span><span class="s3">60 </span><span class="s1">* remainder</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">microsecond = int(</span><span class="s3">1_000_000 </span><span class="s1">* remainder)</span>
    <span class="s0">if </span><span class="s1">microsecond &lt; </span><span class="s3">10</span><span class="s1">:</span>
        <span class="s1">microsecond = </span><span class="s3">0  </span><span class="s2"># compensate for rounding errors</span>
    <span class="s1">dt = datetime(</span>
        <span class="s1">dt.year</span><span class="s0">, </span><span class="s1">dt.month</span><span class="s0">, </span><span class="s1">dt.day</span><span class="s0">, </span><span class="s1">int(hour)</span><span class="s0">, </span><span class="s1">int(minute)</span><span class="s0">, </span><span class="s1">int(second)</span><span class="s0">, </span><span class="s1">microsecond</span>
    <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">tz </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">dt = dt.astimezone(tz)</span>

    <span class="s0">if </span><span class="s1">microsecond &gt; </span><span class="s3">999990</span><span class="s1">:  </span><span class="s2"># compensate for rounding errors</span>
        <span class="s1">dt += timedelta(microseconds=</span><span class="s3">1_000_000 </span><span class="s1">- microsecond)</span>

    <span class="s0">return </span><span class="s1">dt</span>


<span class="s2"># Fixed frequency dynamic tick locators and formatters</span>

<span class="s2"># -------------------------------------------------------------------------</span>
<span class="s2"># --- Locators ---</span>
<span class="s2"># -------------------------------------------------------------------------</span>


<span class="s0">def </span><span class="s1">_get_default_annual_spacing(nyears) -&gt; tuple[int</span><span class="s0">, </span><span class="s1">int]:</span>
    <span class="s4">&quot;&quot;&quot; 
    Returns a default spacing between consecutive ticks for annual data. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">nyears &lt; </span><span class="s3">11</span><span class="s1">:</span>
        <span class="s1">(min_spacing</span><span class="s0">, </span><span class="s1">maj_spacing) = (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">nyears &lt; </span><span class="s3">20</span><span class="s1">:</span>
        <span class="s1">(min_spacing</span><span class="s0">, </span><span class="s1">maj_spacing) = (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">nyears &lt; </span><span class="s3">50</span><span class="s1">:</span>
        <span class="s1">(min_spacing</span><span class="s0">, </span><span class="s1">maj_spacing) = (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">nyears &lt; </span><span class="s3">100</span><span class="s1">:</span>
        <span class="s1">(min_spacing</span><span class="s0">, </span><span class="s1">maj_spacing) = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">nyears &lt; </span><span class="s3">200</span><span class="s1">:</span>
        <span class="s1">(min_spacing</span><span class="s0">, </span><span class="s1">maj_spacing) = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">25</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">nyears &lt; </span><span class="s3">600</span><span class="s1">:</span>
        <span class="s1">(min_spacing</span><span class="s0">, </span><span class="s1">maj_spacing) = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">50</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">factor = nyears // </span><span class="s3">1000 </span><span class="s1">+ </span><span class="s3">1</span>
        <span class="s1">(min_spacing</span><span class="s0">, </span><span class="s1">maj_spacing) = (factor * </span><span class="s3">20</span><span class="s0">, </span><span class="s1">factor * </span><span class="s3">100</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">(min_spacing</span><span class="s0">, </span><span class="s1">maj_spacing)</span>


<span class="s0">def </span><span class="s1">period_break(dates: PeriodIndex</span><span class="s0">, </span><span class="s1">period: str) -&gt; np.ndarray:</span>
    <span class="s4">&quot;&quot;&quot; 
    Returns the indices where the given period changes. 
 
    Parameters 
    ---------- 
    dates : PeriodIndex 
        Array of intervals to monitor. 
    period : str 
        Name of the period to monitor. 
    &quot;&quot;&quot;</span>
    <span class="s1">current = getattr(dates</span><span class="s0">, </span><span class="s1">period)</span>
    <span class="s1">previous = getattr(dates - </span><span class="s3">1 </span><span class="s1">* dates.freq</span><span class="s0">, </span><span class="s1">period)</span>
    <span class="s0">return </span><span class="s1">np.nonzero(current - previous)[</span><span class="s3">0</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">has_level_label(label_flags: np.ndarray</span><span class="s0">, </span><span class="s1">vmin: float) -&gt; bool:</span>
    <span class="s4">&quot;&quot;&quot; 
    Returns true if the ``label_flags`` indicate there is at least one label 
    for this level. 
 
    if the minimum view limit is not an exact integer, then the first tick 
    label won't be shown, so we must adjust for that. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">label_flags.size == </span><span class="s3">0 </span><span class="s0">or </span><span class="s1">(</span>
        <span class="s1">label_flags.size == </span><span class="s3">1 </span><span class="s0">and </span><span class="s1">label_flags[</span><span class="s3">0</span><span class="s1">] == </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">vmin % </span><span class="s3">1 </span><span class="s1">&gt; </span><span class="s3">0.0</span>
    <span class="s1">):</span>
        <span class="s0">return False</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return True</span>


<span class="s0">def </span><span class="s1">_daily_finder(vmin</span><span class="s0">, </span><span class="s1">vmax</span><span class="s0">, </span><span class="s1">freq: BaseOffset):</span>
    <span class="s1">dtype_code = freq._period_dtype_code</span>

    <span class="s1">periodsperday = -</span><span class="s3">1</span>

    <span class="s0">if </span><span class="s1">dtype_code &gt;= FreqGroup.FR_HR.value:</span>
        <span class="s0">if </span><span class="s1">dtype_code == FreqGroup.FR_NS.value:</span>
            <span class="s1">periodsperday = </span><span class="s3">24 </span><span class="s1">* </span><span class="s3">60 </span><span class="s1">* </span><span class="s3">60 </span><span class="s1">* </span><span class="s3">1000000000</span>
        <span class="s0">elif </span><span class="s1">dtype_code == FreqGroup.FR_US.value:</span>
            <span class="s1">periodsperday = </span><span class="s3">24 </span><span class="s1">* </span><span class="s3">60 </span><span class="s1">* </span><span class="s3">60 </span><span class="s1">* </span><span class="s3">1000000</span>
        <span class="s0">elif </span><span class="s1">dtype_code == FreqGroup.FR_MS.value:</span>
            <span class="s1">periodsperday = </span><span class="s3">24 </span><span class="s1">* </span><span class="s3">60 </span><span class="s1">* </span><span class="s3">60 </span><span class="s1">* </span><span class="s3">1000</span>
        <span class="s0">elif </span><span class="s1">dtype_code == FreqGroup.FR_SEC.value:</span>
            <span class="s1">periodsperday = </span><span class="s3">24 </span><span class="s1">* </span><span class="s3">60 </span><span class="s1">* </span><span class="s3">60</span>
        <span class="s0">elif </span><span class="s1">dtype_code == FreqGroup.FR_MIN.value:</span>
            <span class="s1">periodsperday = </span><span class="s3">24 </span><span class="s1">* </span><span class="s3">60</span>
        <span class="s0">elif </span><span class="s1">dtype_code == FreqGroup.FR_HR.value:</span>
            <span class="s1">periodsperday = </span><span class="s3">24</span>
        <span class="s0">else</span><span class="s1">:  </span><span class="s2"># pragma: no cover</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;unexpected frequency: </span><span class="s0">{</span><span class="s1">dtype_code</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s1">)</span>
        <span class="s1">periodsperyear = </span><span class="s3">365 </span><span class="s1">* periodsperday</span>
        <span class="s1">periodspermonth = </span><span class="s3">28 </span><span class="s1">* periodsperday</span>

    <span class="s0">elif </span><span class="s1">dtype_code == FreqGroup.FR_BUS.value:</span>
        <span class="s1">periodsperyear = </span><span class="s3">261</span>
        <span class="s1">periodspermonth = </span><span class="s3">19</span>
    <span class="s0">elif </span><span class="s1">dtype_code == FreqGroup.FR_DAY.value:</span>
        <span class="s1">periodsperyear = </span><span class="s3">365</span>
        <span class="s1">periodspermonth = </span><span class="s3">28</span>
    <span class="s0">elif </span><span class="s1">FreqGroup.get_freq_group(dtype_code) == FreqGroup.FR_WK:</span>
        <span class="s1">periodsperyear = </span><span class="s3">52</span>
        <span class="s1">periodspermonth = </span><span class="s3">3</span>
    <span class="s0">else</span><span class="s1">:  </span><span class="s2"># pragma: no cover</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;unexpected frequency&quot;</span><span class="s1">)</span>

    <span class="s2"># save this for later usage</span>
    <span class="s1">vmin_orig = vmin</span>

    <span class="s1">(vmin</span><span class="s0">, </span><span class="s1">vmax) = (</span>
        <span class="s1">Period(ordinal=int(vmin)</span><span class="s0">, </span><span class="s1">freq=freq)</span><span class="s0">,</span>
        <span class="s1">Period(ordinal=int(vmax)</span><span class="s0">, </span><span class="s1">freq=freq)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">span = vmax.ordinal - vmin.ordinal + </span><span class="s3">1</span>
    <span class="s1">dates_ = period_range(start=vmin</span><span class="s0">, </span><span class="s1">end=vmax</span><span class="s0">, </span><span class="s1">freq=freq)</span>
    <span class="s2"># Initialize the output</span>
    <span class="s1">info = np.zeros(</span>
        <span class="s1">span</span><span class="s0">, </span><span class="s1">dtype=[(</span><span class="s5">&quot;val&quot;</span><span class="s0">, </span><span class="s1">np.int64)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">&quot;maj&quot;</span><span class="s0">, </span><span class="s1">bool)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">&quot;min&quot;</span><span class="s0">, </span><span class="s1">bool)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">&quot;fmt&quot;</span><span class="s0">, </span><span class="s5">&quot;|S20&quot;</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s1">info[</span><span class="s5">&quot;val&quot;</span><span class="s1">][:] = dates_.asi8</span>
    <span class="s1">info[</span><span class="s5">&quot;fmt&quot;</span><span class="s1">][:] = </span><span class="s5">&quot;&quot;</span>
    <span class="s1">info[</span><span class="s5">&quot;maj&quot;</span><span class="s1">][[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]] = </span><span class="s0">True</span>
    <span class="s2"># .. and set some shortcuts</span>
    <span class="s1">info_maj = info[</span><span class="s5">&quot;maj&quot;</span><span class="s1">]</span>
    <span class="s1">info_min = info[</span><span class="s5">&quot;min&quot;</span><span class="s1">]</span>
    <span class="s1">info_fmt = info[</span><span class="s5">&quot;fmt&quot;</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">first_label(label_flags):</span>
        <span class="s0">if </span><span class="s1">(label_flags[</span><span class="s3">0</span><span class="s1">] == </span><span class="s3">0</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(label_flags.size &gt; </span><span class="s3">1</span><span class="s1">) </span><span class="s0">and </span><span class="s1">((vmin_orig % </span><span class="s3">1</span><span class="s1">) &gt; </span><span class="s3">0.0</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">label_flags[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">label_flags[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s2"># Case 1. Less than a month</span>
    <span class="s0">if </span><span class="s1">span &lt;= periodspermonth:</span>
        <span class="s1">day_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;day&quot;</span><span class="s1">)</span>
        <span class="s1">month_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;month&quot;</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">_hour_finder(label_interval</span><span class="s0">, </span><span class="s1">force_year_start):</span>
            <span class="s1">_hour = dates_.hour</span>
            <span class="s1">_prev_hour = (dates_ - </span><span class="s3">1 </span><span class="s1">* dates_.freq).hour</span>
            <span class="s1">hour_start = (_hour - _prev_hour) != </span><span class="s3">0</span>
            <span class="s1">info_maj[day_start] = </span><span class="s0">True</span>
            <span class="s1">info_min[hour_start &amp; (_hour % label_interval == </span><span class="s3">0</span><span class="s1">)] = </span><span class="s0">True</span>
            <span class="s1">year_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;year&quot;</span><span class="s1">)</span>
            <span class="s1">info_fmt[hour_start &amp; (_hour % label_interval == </span><span class="s3">0</span><span class="s1">)] = </span><span class="s5">&quot;%H:%M&quot;</span>
            <span class="s1">info_fmt[day_start] = </span><span class="s5">&quot;%H:%M</span><span class="s0">\n</span><span class="s5">%d-%b&quot;</span>
            <span class="s1">info_fmt[year_start] = </span><span class="s5">&quot;%H:%M</span><span class="s0">\n</span><span class="s5">%d-%b</span><span class="s0">\n</span><span class="s5">%Y&quot;</span>
            <span class="s0">if </span><span class="s1">force_year_start </span><span class="s0">and not </span><span class="s1">has_level_label(year_start</span><span class="s0">, </span><span class="s1">vmin_orig):</span>
                <span class="s1">info_fmt[first_label(day_start)] = </span><span class="s5">&quot;%H:%M</span><span class="s0">\n</span><span class="s5">%d-%b</span><span class="s0">\n</span><span class="s5">%Y&quot;</span>

        <span class="s0">def </span><span class="s1">_minute_finder(label_interval):</span>
            <span class="s1">hour_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;hour&quot;</span><span class="s1">)</span>
            <span class="s1">_minute = dates_.minute</span>
            <span class="s1">_prev_minute = (dates_ - </span><span class="s3">1 </span><span class="s1">* dates_.freq).minute</span>
            <span class="s1">minute_start = (_minute - _prev_minute) != </span><span class="s3">0</span>
            <span class="s1">info_maj[hour_start] = </span><span class="s0">True</span>
            <span class="s1">info_min[minute_start &amp; (_minute % label_interval == </span><span class="s3">0</span><span class="s1">)] = </span><span class="s0">True</span>
            <span class="s1">year_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;year&quot;</span><span class="s1">)</span>
            <span class="s1">info_fmt = info[</span><span class="s5">&quot;fmt&quot;</span><span class="s1">]</span>
            <span class="s1">info_fmt[minute_start &amp; (_minute % label_interval == </span><span class="s3">0</span><span class="s1">)] = </span><span class="s5">&quot;%H:%M&quot;</span>
            <span class="s1">info_fmt[day_start] = </span><span class="s5">&quot;%H:%M</span><span class="s0">\n</span><span class="s5">%d-%b&quot;</span>
            <span class="s1">info_fmt[year_start] = </span><span class="s5">&quot;%H:%M</span><span class="s0">\n</span><span class="s5">%d-%b</span><span class="s0">\n</span><span class="s5">%Y&quot;</span>

        <span class="s0">def </span><span class="s1">_second_finder(label_interval):</span>
            <span class="s1">minute_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;minute&quot;</span><span class="s1">)</span>
            <span class="s1">_second = dates_.second</span>
            <span class="s1">_prev_second = (dates_ - </span><span class="s3">1 </span><span class="s1">* dates_.freq).second</span>
            <span class="s1">second_start = (_second - _prev_second) != </span><span class="s3">0</span>
            <span class="s1">info[</span><span class="s5">&quot;maj&quot;</span><span class="s1">][minute_start] = </span><span class="s0">True</span>
            <span class="s1">info[</span><span class="s5">&quot;min&quot;</span><span class="s1">][second_start &amp; (_second % label_interval == </span><span class="s3">0</span><span class="s1">)] = </span><span class="s0">True</span>
            <span class="s1">year_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;year&quot;</span><span class="s1">)</span>
            <span class="s1">info_fmt = info[</span><span class="s5">&quot;fmt&quot;</span><span class="s1">]</span>
            <span class="s1">info_fmt[second_start &amp; (_second % label_interval == </span><span class="s3">0</span><span class="s1">)] = </span><span class="s5">&quot;%H:%M:%S&quot;</span>
            <span class="s1">info_fmt[day_start] = </span><span class="s5">&quot;%H:%M:%S</span><span class="s0">\n</span><span class="s5">%d-%b&quot;</span>
            <span class="s1">info_fmt[year_start] = </span><span class="s5">&quot;%H:%M:%S</span><span class="s0">\n</span><span class="s5">%d-%b</span><span class="s0">\n</span><span class="s5">%Y&quot;</span>

        <span class="s0">if </span><span class="s1">span &lt; periodsperday / </span><span class="s3">12000</span><span class="s1">:</span>
            <span class="s1">_second_finder(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">span &lt; periodsperday / </span><span class="s3">6000</span><span class="s1">:</span>
            <span class="s1">_second_finder(</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">span &lt; periodsperday / </span><span class="s3">2400</span><span class="s1">:</span>
            <span class="s1">_second_finder(</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">span &lt; periodsperday / </span><span class="s3">1200</span><span class="s1">:</span>
            <span class="s1">_second_finder(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">span &lt; periodsperday / </span><span class="s3">800</span><span class="s1">:</span>
            <span class="s1">_second_finder(</span><span class="s3">15</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">span &lt; periodsperday / </span><span class="s3">400</span><span class="s1">:</span>
            <span class="s1">_second_finder(</span><span class="s3">30</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">span &lt; periodsperday / </span><span class="s3">150</span><span class="s1">:</span>
            <span class="s1">_minute_finder(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">span &lt; periodsperday / </span><span class="s3">70</span><span class="s1">:</span>
            <span class="s1">_minute_finder(</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">span &lt; periodsperday / </span><span class="s3">24</span><span class="s1">:</span>
            <span class="s1">_minute_finder(</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">span &lt; periodsperday / </span><span class="s3">12</span><span class="s1">:</span>
            <span class="s1">_minute_finder(</span><span class="s3">15</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">span &lt; periodsperday / </span><span class="s3">6</span><span class="s1">:</span>
            <span class="s1">_minute_finder(</span><span class="s3">30</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">span &lt; periodsperday / </span><span class="s3">2.5</span><span class="s1">:</span>
            <span class="s1">_hour_finder(</span><span class="s3">1</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">span &lt; periodsperday / </span><span class="s3">1.5</span><span class="s1">:</span>
            <span class="s1">_hour_finder(</span><span class="s3">2</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">span &lt; periodsperday * </span><span class="s3">1.25</span><span class="s1">:</span>
            <span class="s1">_hour_finder(</span><span class="s3">3</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">span &lt; periodsperday * </span><span class="s3">2.5</span><span class="s1">:</span>
            <span class="s1">_hour_finder(</span><span class="s3">6</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">span &lt; periodsperday * </span><span class="s3">4</span><span class="s1">:</span>
            <span class="s1">_hour_finder(</span><span class="s3">12</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">info_maj[month_start] = </span><span class="s0">True</span>
            <span class="s1">info_min[day_start] = </span><span class="s0">True</span>
            <span class="s1">year_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;year&quot;</span><span class="s1">)</span>
            <span class="s1">info_fmt = info[</span><span class="s5">&quot;fmt&quot;</span><span class="s1">]</span>
            <span class="s1">info_fmt[day_start] = </span><span class="s5">&quot;%d&quot;</span>
            <span class="s1">info_fmt[month_start] = </span><span class="s5">&quot;%d</span><span class="s0">\n</span><span class="s5">%b&quot;</span>
            <span class="s1">info_fmt[year_start] = </span><span class="s5">&quot;%d</span><span class="s0">\n</span><span class="s5">%b</span><span class="s0">\n</span><span class="s5">%Y&quot;</span>
            <span class="s0">if not </span><span class="s1">has_level_label(year_start</span><span class="s0">, </span><span class="s1">vmin_orig):</span>
                <span class="s0">if not </span><span class="s1">has_level_label(month_start</span><span class="s0">, </span><span class="s1">vmin_orig):</span>
                    <span class="s1">info_fmt[first_label(day_start)] = </span><span class="s5">&quot;%d</span><span class="s0">\n</span><span class="s5">%b</span><span class="s0">\n</span><span class="s5">%Y&quot;</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">info_fmt[first_label(month_start)] = </span><span class="s5">&quot;%d</span><span class="s0">\n</span><span class="s5">%b</span><span class="s0">\n</span><span class="s5">%Y&quot;</span>

    <span class="s2"># Case 2. Less than three months</span>
    <span class="s0">elif </span><span class="s1">span &lt;= periodsperyear // </span><span class="s3">4</span><span class="s1">:</span>
        <span class="s1">month_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;month&quot;</span><span class="s1">)</span>
        <span class="s1">info_maj[month_start] = </span><span class="s0">True</span>
        <span class="s0">if </span><span class="s1">dtype_code &lt; FreqGroup.FR_HR.value:</span>
            <span class="s1">info[</span><span class="s5">&quot;min&quot;</span><span class="s1">] = </span><span class="s0">True</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">day_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;day&quot;</span><span class="s1">)</span>
            <span class="s1">info[</span><span class="s5">&quot;min&quot;</span><span class="s1">][day_start] = </span><span class="s0">True</span>
        <span class="s1">week_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;week&quot;</span><span class="s1">)</span>
        <span class="s1">year_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;year&quot;</span><span class="s1">)</span>
        <span class="s1">info_fmt[week_start] = </span><span class="s5">&quot;%d&quot;</span>
        <span class="s1">info_fmt[month_start] = </span><span class="s5">&quot;</span><span class="s0">\n\n</span><span class="s5">%b&quot;</span>
        <span class="s1">info_fmt[year_start] = </span><span class="s5">&quot;</span><span class="s0">\n\n</span><span class="s5">%b</span><span class="s0">\n</span><span class="s5">%Y&quot;</span>
        <span class="s0">if not </span><span class="s1">has_level_label(year_start</span><span class="s0">, </span><span class="s1">vmin_orig):</span>
            <span class="s0">if not </span><span class="s1">has_level_label(month_start</span><span class="s0">, </span><span class="s1">vmin_orig):</span>
                <span class="s1">info_fmt[first_label(week_start)] = </span><span class="s5">&quot;</span><span class="s0">\n\n</span><span class="s5">%b</span><span class="s0">\n</span><span class="s5">%Y&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">info_fmt[first_label(month_start)] = </span><span class="s5">&quot;</span><span class="s0">\n\n</span><span class="s5">%b</span><span class="s0">\n</span><span class="s5">%Y&quot;</span>
    <span class="s2"># Case 3. Less than 14 months ...............</span>
    <span class="s0">elif </span><span class="s1">span &lt;= </span><span class="s3">1.15 </span><span class="s1">* periodsperyear:</span>
        <span class="s1">year_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;year&quot;</span><span class="s1">)</span>
        <span class="s1">month_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;month&quot;</span><span class="s1">)</span>
        <span class="s1">week_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;week&quot;</span><span class="s1">)</span>
        <span class="s1">info_maj[month_start] = </span><span class="s0">True</span>
        <span class="s1">info_min[week_start] = </span><span class="s0">True</span>
        <span class="s1">info_min[year_start] = </span><span class="s0">False</span>
        <span class="s1">info_min[month_start] = </span><span class="s0">False</span>
        <span class="s1">info_fmt[month_start] = </span><span class="s5">&quot;%b&quot;</span>
        <span class="s1">info_fmt[year_start] = </span><span class="s5">&quot;%b</span><span class="s0">\n</span><span class="s5">%Y&quot;</span>
        <span class="s0">if not </span><span class="s1">has_level_label(year_start</span><span class="s0">, </span><span class="s1">vmin_orig):</span>
            <span class="s1">info_fmt[first_label(month_start)] = </span><span class="s5">&quot;%b</span><span class="s0">\n</span><span class="s5">%Y&quot;</span>
    <span class="s2"># Case 4. Less than 2.5 years ...............</span>
    <span class="s0">elif </span><span class="s1">span &lt;= </span><span class="s3">2.5 </span><span class="s1">* periodsperyear:</span>
        <span class="s1">year_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;year&quot;</span><span class="s1">)</span>
        <span class="s1">quarter_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;quarter&quot;</span><span class="s1">)</span>
        <span class="s1">month_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;month&quot;</span><span class="s1">)</span>
        <span class="s1">info_maj[quarter_start] = </span><span class="s0">True</span>
        <span class="s1">info_min[month_start] = </span><span class="s0">True</span>
        <span class="s1">info_fmt[quarter_start] = </span><span class="s5">&quot;%b&quot;</span>
        <span class="s1">info_fmt[year_start] = </span><span class="s5">&quot;%b</span><span class="s0">\n</span><span class="s5">%Y&quot;</span>
    <span class="s2"># Case 4. Less than 4 years .................</span>
    <span class="s0">elif </span><span class="s1">span &lt;= </span><span class="s3">4 </span><span class="s1">* periodsperyear:</span>
        <span class="s1">year_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;year&quot;</span><span class="s1">)</span>
        <span class="s1">month_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;month&quot;</span><span class="s1">)</span>
        <span class="s1">info_maj[year_start] = </span><span class="s0">True</span>
        <span class="s1">info_min[month_start] = </span><span class="s0">True</span>
        <span class="s1">info_min[year_start] = </span><span class="s0">False</span>

        <span class="s1">month_break = dates_[month_start].month</span>
        <span class="s1">jan_or_jul = month_start[(month_break == </span><span class="s3">1</span><span class="s1">) | (month_break == </span><span class="s3">7</span><span class="s1">)]</span>
        <span class="s1">info_fmt[jan_or_jul] = </span><span class="s5">&quot;%b&quot;</span>
        <span class="s1">info_fmt[year_start] = </span><span class="s5">&quot;%b</span><span class="s0">\n</span><span class="s5">%Y&quot;</span>
    <span class="s2"># Case 5. Less than 11 years ................</span>
    <span class="s0">elif </span><span class="s1">span &lt;= </span><span class="s3">11 </span><span class="s1">* periodsperyear:</span>
        <span class="s1">year_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;year&quot;</span><span class="s1">)</span>
        <span class="s1">quarter_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;quarter&quot;</span><span class="s1">)</span>
        <span class="s1">info_maj[year_start] = </span><span class="s0">True</span>
        <span class="s1">info_min[quarter_start] = </span><span class="s0">True</span>
        <span class="s1">info_min[year_start] = </span><span class="s0">False</span>
        <span class="s1">info_fmt[year_start] = </span><span class="s5">&quot;%Y&quot;</span>
    <span class="s2"># Case 6. More than 12 years ................</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">year_start = period_break(dates_</span><span class="s0">, </span><span class="s5">&quot;year&quot;</span><span class="s1">)</span>
        <span class="s1">year_break = dates_[year_start].year</span>
        <span class="s1">nyears = span / periodsperyear</span>
        <span class="s1">(min_anndef</span><span class="s0">, </span><span class="s1">maj_anndef) = _get_default_annual_spacing(nyears)</span>
        <span class="s1">major_idx = year_start[(year_break % maj_anndef == </span><span class="s3">0</span><span class="s1">)]</span>
        <span class="s1">info_maj[major_idx] = </span><span class="s0">True</span>
        <span class="s1">minor_idx = year_start[(year_break % min_anndef == </span><span class="s3">0</span><span class="s1">)]</span>
        <span class="s1">info_min[minor_idx] = </span><span class="s0">True</span>
        <span class="s1">info_fmt[major_idx] = </span><span class="s5">&quot;%Y&quot;</span>

    <span class="s0">return </span><span class="s1">info</span>


<span class="s0">def </span><span class="s1">_monthly_finder(vmin</span><span class="s0">, </span><span class="s1">vmax</span><span class="s0">, </span><span class="s1">freq):</span>
    <span class="s1">periodsperyear = </span><span class="s3">12</span>

    <span class="s1">vmin_orig = vmin</span>
    <span class="s1">(vmin</span><span class="s0">, </span><span class="s1">vmax) = (int(vmin)</span><span class="s0">, </span><span class="s1">int(vmax))</span>
    <span class="s1">span = vmax - vmin + </span><span class="s3">1</span>

    <span class="s2"># Initialize the output</span>
    <span class="s1">info = np.zeros(</span>
        <span class="s1">span</span><span class="s0">, </span><span class="s1">dtype=[(</span><span class="s5">&quot;val&quot;</span><span class="s0">, </span><span class="s1">int)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">&quot;maj&quot;</span><span class="s0">, </span><span class="s1">bool)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">&quot;min&quot;</span><span class="s0">, </span><span class="s1">bool)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">&quot;fmt&quot;</span><span class="s0">, </span><span class="s5">&quot;|S8&quot;</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s1">info[</span><span class="s5">&quot;val&quot;</span><span class="s1">] = np.arange(vmin</span><span class="s0">, </span><span class="s1">vmax + </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">dates_ = info[</span><span class="s5">&quot;val&quot;</span><span class="s1">]</span>
    <span class="s1">info[</span><span class="s5">&quot;fmt&quot;</span><span class="s1">] = </span><span class="s5">&quot;&quot;</span>
    <span class="s1">year_start = (dates_ % </span><span class="s3">12 </span><span class="s1">== </span><span class="s3">0</span><span class="s1">).nonzero()[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">info_maj = info[</span><span class="s5">&quot;maj&quot;</span><span class="s1">]</span>
    <span class="s1">info_fmt = info[</span><span class="s5">&quot;fmt&quot;</span><span class="s1">]</span>

    <span class="s0">if </span><span class="s1">span &lt;= </span><span class="s3">1.15 </span><span class="s1">* periodsperyear:</span>
        <span class="s1">info_maj[year_start] = </span><span class="s0">True</span>
        <span class="s1">info[</span><span class="s5">&quot;min&quot;</span><span class="s1">] = </span><span class="s0">True</span>

        <span class="s1">info_fmt[:] = </span><span class="s5">&quot;%b&quot;</span>
        <span class="s1">info_fmt[year_start] = </span><span class="s5">&quot;%b</span><span class="s0">\n</span><span class="s5">%Y&quot;</span>

        <span class="s0">if not </span><span class="s1">has_level_label(year_start</span><span class="s0">, </span><span class="s1">vmin_orig):</span>
            <span class="s0">if </span><span class="s1">dates_.size &gt; </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">idx = </span><span class="s3">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">idx = </span><span class="s3">0</span>
            <span class="s1">info_fmt[idx] = </span><span class="s5">&quot;%b</span><span class="s0">\n</span><span class="s5">%Y&quot;</span>

    <span class="s0">elif </span><span class="s1">span &lt;= </span><span class="s3">2.5 </span><span class="s1">* periodsperyear:</span>
        <span class="s1">quarter_start = (dates_ % </span><span class="s3">3 </span><span class="s1">== </span><span class="s3">0</span><span class="s1">).nonzero()</span>
        <span class="s1">info_maj[year_start] = </span><span class="s0">True</span>
        <span class="s2"># TODO: Check the following : is it really info['fmt'] ?</span>
        <span class="s1">info[</span><span class="s5">&quot;fmt&quot;</span><span class="s1">][quarter_start] = </span><span class="s0">True</span>
        <span class="s1">info[</span><span class="s5">&quot;min&quot;</span><span class="s1">] = </span><span class="s0">True</span>

        <span class="s1">info_fmt[quarter_start] = </span><span class="s5">&quot;%b&quot;</span>
        <span class="s1">info_fmt[year_start] = </span><span class="s5">&quot;%b</span><span class="s0">\n</span><span class="s5">%Y&quot;</span>

    <span class="s0">elif </span><span class="s1">span &lt;= </span><span class="s3">4 </span><span class="s1">* periodsperyear:</span>
        <span class="s1">info_maj[year_start] = </span><span class="s0">True</span>
        <span class="s1">info[</span><span class="s5">&quot;min&quot;</span><span class="s1">] = </span><span class="s0">True</span>

        <span class="s1">jan_or_jul = (dates_ % </span><span class="s3">12 </span><span class="s1">== </span><span class="s3">0</span><span class="s1">) | (dates_ % </span><span class="s3">12 </span><span class="s1">== </span><span class="s3">6</span><span class="s1">)</span>
        <span class="s1">info_fmt[jan_or_jul] = </span><span class="s5">&quot;%b&quot;</span>
        <span class="s1">info_fmt[year_start] = </span><span class="s5">&quot;%b</span><span class="s0">\n</span><span class="s5">%Y&quot;</span>

    <span class="s0">elif </span><span class="s1">span &lt;= </span><span class="s3">11 </span><span class="s1">* periodsperyear:</span>
        <span class="s1">quarter_start = (dates_ % </span><span class="s3">3 </span><span class="s1">== </span><span class="s3">0</span><span class="s1">).nonzero()</span>
        <span class="s1">info_maj[year_start] = </span><span class="s0">True</span>
        <span class="s1">info[</span><span class="s5">&quot;min&quot;</span><span class="s1">][quarter_start] = </span><span class="s0">True</span>

        <span class="s1">info_fmt[year_start] = </span><span class="s5">&quot;%Y&quot;</span>

    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">nyears = span / periodsperyear</span>
        <span class="s1">(min_anndef</span><span class="s0">, </span><span class="s1">maj_anndef) = _get_default_annual_spacing(nyears)</span>
        <span class="s1">years = dates_[year_start] // </span><span class="s3">12 </span><span class="s1">+ </span><span class="s3">1</span>
        <span class="s1">major_idx = year_start[(years % maj_anndef == </span><span class="s3">0</span><span class="s1">)]</span>
        <span class="s1">info_maj[major_idx] = </span><span class="s0">True</span>
        <span class="s1">info[</span><span class="s5">&quot;min&quot;</span><span class="s1">][year_start[(years % min_anndef == </span><span class="s3">0</span><span class="s1">)]] = </span><span class="s0">True</span>

        <span class="s1">info_fmt[major_idx] = </span><span class="s5">&quot;%Y&quot;</span>

    <span class="s0">return </span><span class="s1">info</span>


<span class="s0">def </span><span class="s1">_quarterly_finder(vmin</span><span class="s0">, </span><span class="s1">vmax</span><span class="s0">, </span><span class="s1">freq):</span>
    <span class="s1">periodsperyear = </span><span class="s3">4</span>
    <span class="s1">vmin_orig = vmin</span>
    <span class="s1">(vmin</span><span class="s0">, </span><span class="s1">vmax) = (int(vmin)</span><span class="s0">, </span><span class="s1">int(vmax))</span>
    <span class="s1">span = vmax - vmin + </span><span class="s3">1</span>

    <span class="s1">info = np.zeros(</span>
        <span class="s1">span</span><span class="s0">, </span><span class="s1">dtype=[(</span><span class="s5">&quot;val&quot;</span><span class="s0">, </span><span class="s1">int)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">&quot;maj&quot;</span><span class="s0">, </span><span class="s1">bool)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">&quot;min&quot;</span><span class="s0">, </span><span class="s1">bool)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">&quot;fmt&quot;</span><span class="s0">, </span><span class="s5">&quot;|S8&quot;</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s1">info[</span><span class="s5">&quot;val&quot;</span><span class="s1">] = np.arange(vmin</span><span class="s0">, </span><span class="s1">vmax + </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">info[</span><span class="s5">&quot;fmt&quot;</span><span class="s1">] = </span><span class="s5">&quot;&quot;</span>
    <span class="s1">dates_ = info[</span><span class="s5">&quot;val&quot;</span><span class="s1">]</span>
    <span class="s1">info_maj = info[</span><span class="s5">&quot;maj&quot;</span><span class="s1">]</span>
    <span class="s1">info_fmt = info[</span><span class="s5">&quot;fmt&quot;</span><span class="s1">]</span>
    <span class="s1">year_start = (dates_ % </span><span class="s3">4 </span><span class="s1">== </span><span class="s3">0</span><span class="s1">).nonzero()[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s0">if </span><span class="s1">span &lt;= </span><span class="s3">3.5 </span><span class="s1">* periodsperyear:</span>
        <span class="s1">info_maj[year_start] = </span><span class="s0">True</span>
        <span class="s1">info[</span><span class="s5">&quot;min&quot;</span><span class="s1">] = </span><span class="s0">True</span>

        <span class="s1">info_fmt[:] = </span><span class="s5">&quot;Q%q&quot;</span>
        <span class="s1">info_fmt[year_start] = </span><span class="s5">&quot;Q%q</span><span class="s0">\n</span><span class="s5">%F&quot;</span>
        <span class="s0">if not </span><span class="s1">has_level_label(year_start</span><span class="s0">, </span><span class="s1">vmin_orig):</span>
            <span class="s0">if </span><span class="s1">dates_.size &gt; </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">idx = </span><span class="s3">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">idx = </span><span class="s3">0</span>
            <span class="s1">info_fmt[idx] = </span><span class="s5">&quot;Q%q</span><span class="s0">\n</span><span class="s5">%F&quot;</span>

    <span class="s0">elif </span><span class="s1">span &lt;= </span><span class="s3">11 </span><span class="s1">* periodsperyear:</span>
        <span class="s1">info_maj[year_start] = </span><span class="s0">True</span>
        <span class="s1">info[</span><span class="s5">&quot;min&quot;</span><span class="s1">] = </span><span class="s0">True</span>
        <span class="s1">info_fmt[year_start] = </span><span class="s5">&quot;%F&quot;</span>

    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">years = dates_[year_start] // </span><span class="s3">4 </span><span class="s1">+ </span><span class="s3">1</span>
        <span class="s1">nyears = span / periodsperyear</span>
        <span class="s1">(min_anndef</span><span class="s0">, </span><span class="s1">maj_anndef) = _get_default_annual_spacing(nyears)</span>
        <span class="s1">major_idx = year_start[(years % maj_anndef == </span><span class="s3">0</span><span class="s1">)]</span>
        <span class="s1">info_maj[major_idx] = </span><span class="s0">True</span>
        <span class="s1">info[</span><span class="s5">&quot;min&quot;</span><span class="s1">][year_start[(years % min_anndef == </span><span class="s3">0</span><span class="s1">)]] = </span><span class="s0">True</span>
        <span class="s1">info_fmt[major_idx] = </span><span class="s5">&quot;%F&quot;</span>

    <span class="s0">return </span><span class="s1">info</span>


<span class="s0">def </span><span class="s1">_annual_finder(vmin</span><span class="s0">, </span><span class="s1">vmax</span><span class="s0">, </span><span class="s1">freq):</span>
    <span class="s1">(vmin</span><span class="s0">, </span><span class="s1">vmax) = (int(vmin)</span><span class="s0">, </span><span class="s1">int(vmax + </span><span class="s3">1</span><span class="s1">))</span>
    <span class="s1">span = vmax - vmin + </span><span class="s3">1</span>

    <span class="s1">info = np.zeros(</span>
        <span class="s1">span</span><span class="s0">, </span><span class="s1">dtype=[(</span><span class="s5">&quot;val&quot;</span><span class="s0">, </span><span class="s1">int)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">&quot;maj&quot;</span><span class="s0">, </span><span class="s1">bool)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">&quot;min&quot;</span><span class="s0">, </span><span class="s1">bool)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">&quot;fmt&quot;</span><span class="s0">, </span><span class="s5">&quot;|S8&quot;</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s1">info[</span><span class="s5">&quot;val&quot;</span><span class="s1">] = np.arange(vmin</span><span class="s0">, </span><span class="s1">vmax + </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">info[</span><span class="s5">&quot;fmt&quot;</span><span class="s1">] = </span><span class="s5">&quot;&quot;</span>
    <span class="s1">dates_ = info[</span><span class="s5">&quot;val&quot;</span><span class="s1">]</span>

    <span class="s1">(min_anndef</span><span class="s0">, </span><span class="s1">maj_anndef) = _get_default_annual_spacing(span)</span>
    <span class="s1">major_idx = dates_ % maj_anndef == </span><span class="s3">0</span>
    <span class="s1">info[</span><span class="s5">&quot;maj&quot;</span><span class="s1">][major_idx] = </span><span class="s0">True</span>
    <span class="s1">info[</span><span class="s5">&quot;min&quot;</span><span class="s1">][(dates_ % min_anndef == </span><span class="s3">0</span><span class="s1">)] = </span><span class="s0">True</span>
    <span class="s1">info[</span><span class="s5">&quot;fmt&quot;</span><span class="s1">][major_idx] = </span><span class="s5">&quot;%Y&quot;</span>

    <span class="s0">return </span><span class="s1">info</span>


<span class="s0">def </span><span class="s1">get_finder(freq: BaseOffset):</span>
    <span class="s1">dtype_code = freq._period_dtype_code</span>
    <span class="s1">fgroup = (dtype_code // </span><span class="s3">1000</span><span class="s1">) * </span><span class="s3">1000</span>
    <span class="s1">fgroup = FreqGroup(fgroup)</span>

    <span class="s0">if </span><span class="s1">fgroup == FreqGroup.FR_ANN:</span>
        <span class="s0">return </span><span class="s1">_annual_finder</span>
    <span class="s0">elif </span><span class="s1">fgroup == FreqGroup.FR_QTR:</span>
        <span class="s0">return </span><span class="s1">_quarterly_finder</span>
    <span class="s0">elif </span><span class="s1">dtype_code == FreqGroup.FR_MTH.value:</span>
        <span class="s0">return </span><span class="s1">_monthly_finder</span>
    <span class="s0">elif </span><span class="s1">(dtype_code &gt;= FreqGroup.FR_BUS.value) </span><span class="s0">or </span><span class="s1">fgroup == FreqGroup.FR_WK:</span>
        <span class="s0">return </span><span class="s1">_daily_finder</span>
    <span class="s0">else</span><span class="s1">:  </span><span class="s2"># pragma: no cover</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s5">f&quot;Unsupported frequency: </span><span class="s0">{</span><span class="s1">dtype_code</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TimeSeries_DateLocator(Locator):</span>
    <span class="s4">&quot;&quot;&quot; 
    Locates the ticks along an axis controlled by a :class:`Series`. 
 
    Parameters 
    ---------- 
    freq : {var} 
        Valid frequency specifier. 
    minor_locator : {False, True}, optional 
        Whether the locator is for minor ticks (True) or not. 
    dynamic_mode : {True, False}, optional 
        Whether the locator should work in dynamic mode. 
    base : {int}, optional 
    quarter : {int}, optional 
    month : {int}, optional 
    day : {int}, optional 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">freq</span><span class="s0">,</span>
        <span class="s1">minor_locator=</span><span class="s0">False,</span>
        <span class="s1">dynamic_mode=</span><span class="s0">True,</span>
        <span class="s1">base=</span><span class="s3">1</span><span class="s0">,</span>
        <span class="s1">quarter=</span><span class="s3">1</span><span class="s0">,</span>
        <span class="s1">month=</span><span class="s3">1</span><span class="s0">,</span>
        <span class="s1">day=</span><span class="s3">1</span><span class="s0">,</span>
        <span class="s1">plot_obj=</span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s1">freq = to_offset(freq)</span>
        <span class="s1">self.freq = freq</span>
        <span class="s1">self.base = base</span>
        <span class="s1">(self.quarter</span><span class="s0">, </span><span class="s1">self.month</span><span class="s0">, </span><span class="s1">self.day) = (quarter</span><span class="s0">, </span><span class="s1">month</span><span class="s0">, </span><span class="s1">day)</span>
        <span class="s1">self.isminor = minor_locator</span>
        <span class="s1">self.isdynamic = dynamic_mode</span>
        <span class="s1">self.offset = </span><span class="s3">0</span>
        <span class="s1">self.plot_obj = plot_obj</span>
        <span class="s1">self.finder = get_finder(freq)</span>

    <span class="s0">def </span><span class="s1">_get_default_locs(self</span><span class="s0">, </span><span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax):</span>
        <span class="s4">&quot;&quot;&quot;Returns the default locations of ticks.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.plot_obj.date_axis_info </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.plot_obj.date_axis_info = self.finder(vmin</span><span class="s0">, </span><span class="s1">vmax</span><span class="s0">, </span><span class="s1">self.freq)</span>

        <span class="s1">locator = self.plot_obj.date_axis_info</span>

        <span class="s0">if </span><span class="s1">self.isminor:</span>
            <span class="s0">return </span><span class="s1">np.compress(locator[</span><span class="s5">&quot;min&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">locator[</span><span class="s5">&quot;val&quot;</span><span class="s1">])</span>
        <span class="s0">return </span><span class="s1">np.compress(locator[</span><span class="s5">&quot;maj&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">locator[</span><span class="s5">&quot;val&quot;</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">__call__(self):</span>
        <span class="s4">&quot;&quot;&quot;Return the locations of the ticks.&quot;&quot;&quot;</span>
        <span class="s2"># axis calls Locator.set_axis inside set_m&lt;xxxx&gt;_formatter</span>

        <span class="s1">vi = tuple(self.axis.get_view_interval())</span>
        <span class="s0">if </span><span class="s1">vi != self.plot_obj.view_interval:</span>
            <span class="s1">self.plot_obj.date_axis_info = </span><span class="s0">None</span>
        <span class="s1">self.plot_obj.view_interval = vi</span>
        <span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax = vi</span>
        <span class="s0">if </span><span class="s1">vmax &lt; vmin:</span>
            <span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax = vmax</span><span class="s0">, </span><span class="s1">vmin</span>
        <span class="s0">if </span><span class="s1">self.isdynamic:</span>
            <span class="s1">locs = self._get_default_locs(vmin</span><span class="s0">, </span><span class="s1">vmax)</span>
        <span class="s0">else</span><span class="s1">:  </span><span class="s2"># pragma: no cover</span>
            <span class="s1">base = self.base</span>
            <span class="s1">(d</span><span class="s0">, </span><span class="s1">m) = divmod(vmin</span><span class="s0">, </span><span class="s1">base)</span>
            <span class="s1">vmin = (d + </span><span class="s3">1</span><span class="s1">) * base</span>
            <span class="s1">locs = list(range(vmin</span><span class="s0">, </span><span class="s1">vmax + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">base))</span>
        <span class="s0">return </span><span class="s1">locs</span>

    <span class="s0">def </span><span class="s1">autoscale(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Sets the view limits to the nearest multiples of base that contain the 
        data. 
        &quot;&quot;&quot;</span>
        <span class="s2"># requires matplotlib &gt;= 0.98.0</span>
        <span class="s1">(vmin</span><span class="s0">, </span><span class="s1">vmax) = self.axis.get_data_interval()</span>

        <span class="s1">locs = self._get_default_locs(vmin</span><span class="s0">, </span><span class="s1">vmax)</span>
        <span class="s1">(vmin</span><span class="s0">, </span><span class="s1">vmax) = locs[[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]]</span>
        <span class="s0">if </span><span class="s1">vmin == vmax:</span>
            <span class="s1">vmin -= </span><span class="s3">1</span>
            <span class="s1">vmax += </span><span class="s3">1</span>
        <span class="s0">return </span><span class="s1">nonsingular(vmin</span><span class="s0">, </span><span class="s1">vmax)</span>


<span class="s2"># -------------------------------------------------------------------------</span>
<span class="s2"># --- Formatter ---</span>
<span class="s2"># -------------------------------------------------------------------------</span>


<span class="s0">class </span><span class="s1">TimeSeries_DateFormatter(Formatter):</span>
    <span class="s4">&quot;&quot;&quot; 
    Formats the ticks along an axis controlled by a :class:`PeriodIndex`. 
 
    Parameters 
    ---------- 
    freq : {int, string} 
        Valid frequency specifier. 
    minor_locator : bool, default False 
        Whether the current formatter should apply to minor ticks (True) or 
        major ticks (False). 
    dynamic_mode : bool, default True 
        Whether the formatter works in dynamic mode or not. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">freq</span><span class="s0">,</span>
        <span class="s1">minor_locator: bool = </span><span class="s0">False,</span>
        <span class="s1">dynamic_mode: bool = </span><span class="s0">True,</span>
        <span class="s1">plot_obj=</span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s1">freq = to_offset(freq)</span>
        <span class="s1">self.format = </span><span class="s0">None</span>
        <span class="s1">self.freq = freq</span>
        <span class="s1">self.locs: list[Any] = []  </span><span class="s2"># unused, for matplotlib compat</span>
        <span class="s1">self.formatdict: dict[Any</span><span class="s0">, </span><span class="s1">Any] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
        <span class="s1">self.isminor = minor_locator</span>
        <span class="s1">self.isdynamic = dynamic_mode</span>
        <span class="s1">self.offset = </span><span class="s3">0</span>
        <span class="s1">self.plot_obj = plot_obj</span>
        <span class="s1">self.finder = get_finder(freq)</span>

    <span class="s0">def </span><span class="s1">_set_default_format(self</span><span class="s0">, </span><span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax):</span>
        <span class="s4">&quot;&quot;&quot;Returns the default ticks spacing.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.plot_obj.date_axis_info </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.plot_obj.date_axis_info = self.finder(vmin</span><span class="s0">, </span><span class="s1">vmax</span><span class="s0">, </span><span class="s1">self.freq)</span>
        <span class="s1">info = self.plot_obj.date_axis_info</span>

        <span class="s0">if </span><span class="s1">self.isminor:</span>
            <span class="s1">format = np.compress(info[</span><span class="s5">&quot;min&quot;</span><span class="s1">] &amp; np.logical_not(info[</span><span class="s5">&quot;maj&quot;</span><span class="s1">])</span><span class="s0">, </span><span class="s1">info)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">format = np.compress(info[</span><span class="s5">&quot;maj&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">info)</span>
        <span class="s1">self.formatdict = {x: f </span><span class="s0">for </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">f) </span><span class="s0">in </span><span class="s1">format}</span>
        <span class="s0">return </span><span class="s1">self.formatdict</span>

    <span class="s0">def </span><span class="s1">set_locs(self</span><span class="s0">, </span><span class="s1">locs):</span>
        <span class="s4">&quot;&quot;&quot;Sets the locations of the ticks&quot;&quot;&quot;</span>
        <span class="s2"># don't actually use the locs. This is just needed to work with</span>
        <span class="s2"># matplotlib. Force to use vmin, vmax</span>

        <span class="s1">self.locs = locs</span>

        <span class="s1">(vmin</span><span class="s0">, </span><span class="s1">vmax) = vi = tuple(self.axis.get_view_interval())</span>
        <span class="s0">if </span><span class="s1">vi != self.plot_obj.view_interval:</span>
            <span class="s1">self.plot_obj.date_axis_info = </span><span class="s0">None</span>
        <span class="s1">self.plot_obj.view_interval = vi</span>
        <span class="s0">if </span><span class="s1">vmax &lt; vmin:</span>
            <span class="s1">(vmin</span><span class="s0">, </span><span class="s1">vmax) = (vmax</span><span class="s0">, </span><span class="s1">vmin)</span>
        <span class="s1">self._set_default_format(vmin</span><span class="s0">, </span><span class="s1">vmax)</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">pos=</span><span class="s3">0</span><span class="s1">) -&gt; str:</span>

        <span class="s0">if </span><span class="s1">self.formatdict </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s5">&quot;&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">fmt = self.formatdict.pop(x</span><span class="s0">, </span><span class="s5">&quot;&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">isinstance(fmt</span><span class="s0">, </span><span class="s1">np.bytes_):</span>
                <span class="s1">fmt = fmt.decode(</span><span class="s5">&quot;utf-8&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">Period(ordinal=int(x)</span><span class="s0">, </span><span class="s1">freq=self.freq).strftime(fmt)</span>


<span class="s0">class </span><span class="s1">TimeSeries_TimedeltaFormatter(Formatter):</span>
    <span class="s4">&quot;&quot;&quot; 
    Formats the ticks along an axis controlled by a :class:`TimedeltaIndex`. 
    &quot;&quot;&quot;</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">format_timedelta_ticks(x</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">n_decimals: int) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot; 
        Convert seconds to 'D days HH:MM:SS.F' 
        &quot;&quot;&quot;</span>
        <span class="s1">s</span><span class="s0">, </span><span class="s1">ns = divmod(x</span><span class="s0">, </span><span class="s3">10 </span><span class="s1">** </span><span class="s3">9</span><span class="s1">)</span>
        <span class="s1">m</span><span class="s0">, </span><span class="s1">s = divmod(s</span><span class="s0">, </span><span class="s3">60</span><span class="s1">)</span>
        <span class="s1">h</span><span class="s0">, </span><span class="s1">m = divmod(m</span><span class="s0">, </span><span class="s3">60</span><span class="s1">)</span>
        <span class="s1">d</span><span class="s0">, </span><span class="s1">h = divmod(h</span><span class="s0">, </span><span class="s3">24</span><span class="s1">)</span>
        <span class="s1">decimals = int(ns * </span><span class="s3">10 </span><span class="s1">** (n_decimals - </span><span class="s3">9</span><span class="s1">))</span>
        <span class="s1">s = </span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">int(h)</span><span class="s0">:</span><span class="s5">02d</span><span class="s0">}</span><span class="s5">:</span><span class="s0">{</span><span class="s1">int(m)</span><span class="s0">:</span><span class="s5">02d</span><span class="s0">}</span><span class="s5">:</span><span class="s0">{</span><span class="s1">int(s)</span><span class="s0">:</span><span class="s5">02d</span><span class="s0">}</span><span class="s5">&quot;</span>
        <span class="s0">if </span><span class="s1">n_decimals &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">s += </span><span class="s5">f&quot;.</span><span class="s0">{</span><span class="s1">decimals</span><span class="s0">:</span><span class="s5">0</span><span class="s0">{</span><span class="s1">n_decimals</span><span class="s0">}</span><span class="s5">d</span><span class="s0">}</span><span class="s5">&quot;</span>
        <span class="s0">if </span><span class="s1">d != </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">s = </span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">int(d)</span><span class="s0">:</span><span class="s5">d</span><span class="s0">} </span><span class="s5">days </span><span class="s0">{</span><span class="s1">s</span><span class="s0">}</span><span class="s5">&quot;</span>
        <span class="s0">return </span><span class="s1">s</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">pos=</span><span class="s3">0</span><span class="s1">) -&gt; str:</span>
        <span class="s1">(vmin</span><span class="s0">, </span><span class="s1">vmax) = tuple(self.axis.get_view_interval())</span>
        <span class="s1">n_decimals = int(np.ceil(np.log10(</span><span class="s3">100 </span><span class="s1">* </span><span class="s3">10 </span><span class="s1">** </span><span class="s3">9 </span><span class="s1">/ abs(vmax - vmin))))</span>
        <span class="s0">if </span><span class="s1">n_decimals &gt; </span><span class="s3">9</span><span class="s1">:</span>
            <span class="s1">n_decimals = </span><span class="s3">9</span>
        <span class="s0">return </span><span class="s1">self.format_timedelta_ticks(x</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">n_decimals)</span>
</pre>
</body>
</html>