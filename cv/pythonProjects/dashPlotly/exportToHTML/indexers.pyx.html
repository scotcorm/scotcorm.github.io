<html>
<head>
<title>indexers.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
indexers.pyx</font>
</center></td></tr></table>
<pre><span class="s0"># cython: boundscheck=False, wraparound=False, cdivision=True</span>

<span class="s0">import numpy as np</span>

<span class="s0">from numpy cimport (</span>
    <span class="s0">int64_t,</span>
    <span class="s0">ndarray,</span>
<span class="s0">)</span>

<span class="s0"># Cython routines for window indexers</span>


<span class="s0">def calculate_variable_window_bounds(</span>
    <span class="s0">int64_t num_values,</span>
    <span class="s0">int64_t window_size,</span>
    <span class="s0">object min_periods,  # unused but here to match get_window_bounds signature</span>
    <span class="s0">bint center,</span>
    <span class="s0">str closed,</span>
    <span class="s0">const int64_t[:] index</span>
<span class="s0">):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Calculate window boundaries for rolling windows from a time offset.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">num_values : int64</span>
        <span class="s0">total number of values</span>

    <span class="s0">window_size : int64</span>
        <span class="s0">window size calculated from the offset</span>

    <span class="s0">min_periods : object</span>
        <span class="s0">ignored, exists for compatibility</span>

    <span class="s0">center : bint</span>
        <span class="s0">center the rolling window on the current observation</span>

    <span class="s0">closed : str</span>
        <span class="s0">string of side of the window that should be closed</span>

    <span class="s0">index : ndarray[int64]</span>
        <span class="s0">time series index to roll over</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">(ndarray[int64], ndarray[int64])</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">bint left_closed = False</span>
        <span class="s0">bint right_closed = False</span>
        <span class="s0">ndarray[int64_t, ndim=1] start, end</span>
        <span class="s0">int64_t start_bound, end_bound, index_growth_sign = 1</span>
        <span class="s0">Py_ssize_t i, j</span>

    <span class="s0"># default is 'right'</span>
    <span class="s0">if closed is None:</span>
        <span class="s0">closed = 'right'</span>

    <span class="s0">if closed in ['right', 'both']:</span>
        <span class="s0">right_closed = True</span>

    <span class="s0">if closed in ['left', 'both']:</span>
        <span class="s0">left_closed = True</span>

    <span class="s0"># GH 43997:</span>
    <span class="s0"># If the forward and the backward facing windows</span>
    <span class="s0"># would result in a fraction of 1/2 a nanosecond</span>
    <span class="s0"># we need to make both interval ends inclusive.</span>
    <span class="s0">if center and window_size % 2 == 1:</span>
        <span class="s0">right_closed = True</span>
        <span class="s0">left_closed = True</span>

    <span class="s0">if index[num_values - 1] &lt; index[0]:</span>
        <span class="s0">index_growth_sign = -1</span>

    <span class="s0">start = np.empty(num_values, dtype='int64')</span>
    <span class="s0">start.fill(-1)</span>
    <span class="s0">end = np.empty(num_values, dtype='int64')</span>
    <span class="s0">end.fill(-1)</span>

    <span class="s0">start[0] = 0</span>

    <span class="s0"># right endpoint is closed</span>
    <span class="s0">if right_closed:</span>
        <span class="s0">end[0] = 1</span>
    <span class="s0"># right endpoint is open</span>
    <span class="s0">else:</span>
        <span class="s0">end[0] = 0</span>
    <span class="s0">if center:</span>
        <span class="s0">end_bound = index[0] + index_growth_sign * window_size / 2</span>
        <span class="s0">for j in range(0, num_values):</span>
            <span class="s0">if (index[j] - end_bound) * index_growth_sign &lt; 0:</span>
                <span class="s0">end[0] = j + 1</span>
            <span class="s0">elif (index[j] - end_bound) * index_growth_sign == 0 and right_closed:</span>
                <span class="s0">end[0] = j + 1</span>
            <span class="s0">elif (index[j] - end_bound) * index_growth_sign &gt;= 0:</span>
                <span class="s0">end[0] = j</span>
                <span class="s0">break</span>

    <span class="s0">with nogil:</span>

        <span class="s0"># start is start of slice interval (including)</span>
        <span class="s0"># end is end of slice interval (not including)</span>
        <span class="s0">for i in range(1, num_values):</span>
            <span class="s0">if center:</span>
                <span class="s0">end_bound = index[i] + index_growth_sign * window_size / 2</span>
                <span class="s0">start_bound = index[i] - index_growth_sign * window_size / 2</span>
            <span class="s0">else:</span>
                <span class="s0">end_bound = index[i]</span>
                <span class="s0">start_bound = index[i] - index_growth_sign * window_size</span>

            <span class="s0"># left endpoint is closed</span>
            <span class="s0">if left_closed:</span>
                <span class="s0">start_bound -= 1 * index_growth_sign</span>

            <span class="s0"># advance the start bound until we are</span>
            <span class="s0"># within the constraint</span>
            <span class="s0">start[i] = i</span>
            <span class="s0">for j in range(start[i - 1], i):</span>
                <span class="s0">if (index[j] - start_bound) * index_growth_sign &gt; 0:</span>
                    <span class="s0">start[i] = j</span>
                    <span class="s0">break</span>

            <span class="s0"># for centered window advance the end bound until we are</span>
            <span class="s0"># outside the constraint</span>
            <span class="s0">if center:</span>
                <span class="s0">for j in range(end[i - 1], num_values + 1):</span>
                    <span class="s0">if j == num_values:</span>
                        <span class="s0">end[i] = j</span>
                    <span class="s0">elif ((index[j] - end_bound) * index_growth_sign == 0 and</span>
                          <span class="s0">right_closed):</span>
                        <span class="s0">end[i] = j + 1</span>
                    <span class="s0">elif (index[j] - end_bound) * index_growth_sign &gt;= 0:</span>
                        <span class="s0">end[i] = j</span>
                        <span class="s0">break</span>
            <span class="s0"># end bound is previous end</span>
            <span class="s0"># or current index</span>
            <span class="s0">elif (index[end[i - 1]] - end_bound) * index_growth_sign &lt;= 0:</span>
                <span class="s0">end[i] = i + 1</span>
            <span class="s0">else:</span>
                <span class="s0">end[i] = end[i - 1]</span>

            <span class="s0"># right endpoint is open</span>
            <span class="s0">if not right_closed and not center:</span>
                <span class="s0">end[i] -= 1</span>
    <span class="s0">return start, end</span>
</pre>
</body>
</html>