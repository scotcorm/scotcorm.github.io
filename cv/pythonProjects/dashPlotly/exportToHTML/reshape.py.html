<html>
<head>
<title>reshape.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
reshape.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">import </span><span class="s1">pandas._libs.reshape </span><span class="s0">as </span><span class="s1">libreshape</span>
<span class="s0">from </span><span class="s1">pandas._libs.sparse </span><span class="s0">import </span><span class="s1">IntIndex</span>
<span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Dtype</span><span class="s0">,</span>
    <span class="s1">npt</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.errors </span><span class="s0">import </span><span class="s1">PerformanceWarning</span>
<span class="s0">from </span><span class="s1">pandas.util._decorators </span><span class="s0">import </span><span class="s1">cache_readonly</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s0">import </span><span class="s1">maybe_promote</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ensure_platform_int</span><span class="s0">,</span>
    <span class="s1">is_1d_only_ea_dtype</span><span class="s0">,</span>
    <span class="s1">is_extension_array_dtype</span><span class="s0">,</span>
    <span class="s1">is_integer</span><span class="s0">,</span>
    <span class="s1">is_integer_dtype</span><span class="s0">,</span>
    <span class="s1">is_list_like</span><span class="s0">,</span>
    <span class="s1">is_object_dtype</span><span class="s0">,</span>
    <span class="s1">needs_i8_conversion</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s0">import </span><span class="s1">ExtensionDtype</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s0">import </span><span class="s1">notna</span>

<span class="s0">import </span><span class="s1">pandas.core.algorithms </span><span class="s0">as </span><span class="s1">algos</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">SparseArray</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.categorical </span><span class="s0">import </span><span class="s1">factorize_from_iterable</span>
<span class="s0">from </span><span class="s1">pandas.core.construction </span><span class="s0">import </span><span class="s1">ensure_wrapped_if_datetimelike</span>
<span class="s0">from </span><span class="s1">pandas.core.frame </span><span class="s0">import </span><span class="s1">DataFrame</span>
<span class="s0">from </span><span class="s1">pandas.core.indexes.api </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">MultiIndex</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.indexes.frozen </span><span class="s0">import </span><span class="s1">FrozenList</span>
<span class="s0">from </span><span class="s1">pandas.core.series </span><span class="s0">import </span><span class="s1">Series</span>
<span class="s0">from </span><span class="s1">pandas.core.sorting </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">compress_group_index</span><span class="s0">,</span>
    <span class="s1">decons_obs_group_ids</span><span class="s0">,</span>
    <span class="s1">get_compressed_ids</span><span class="s0">,</span>
    <span class="s1">get_group_index</span><span class="s0">,</span>
    <span class="s1">get_group_index_sorter</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">ExtensionArray</span>


<span class="s0">class </span><span class="s1">_Unstacker:</span>
    <span class="s2">&quot;&quot;&quot; 
    Helper class to unstack data / pivot with multi-level index 
 
    Parameters 
    ---------- 
    index : MultiIndex 
    level : int or str, default last level 
        Level to &quot;unstack&quot;. Accepts a name for the level. 
    fill_value : scalar, optional 
        Default value to fill in missing values if subgroups do not have the 
        same set of labels. By default, missing values will be replaced with 
        the default fill value for that data type, NaN for float, NaT for 
        datetimelike, etc. For integer types, by default data will converted to 
        float and missing values will be set to NaN. 
    constructor : object 
        Pandas ``DataFrame`` or subclass used to create unstacked 
        response.  If None, DataFrame will be used. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; index = pd.MultiIndex.from_tuples([('one', 'a'), ('one', 'b'), 
    ...                                    ('two', 'a'), ('two', 'b')]) 
    &gt;&gt;&gt; s = pd.Series(np.arange(1, 5, dtype=np.int64), index=index) 
    &gt;&gt;&gt; s 
    one  a    1 
         b    2 
    two  a    3 
         b    4 
    dtype: int64 
 
    &gt;&gt;&gt; s.unstack(level=-1) 
         a  b 
    one  1  2 
    two  3  4 
 
    &gt;&gt;&gt; s.unstack(level=0) 
       one  two 
    a    1    3 
    b    2    4 
 
    Returns 
    ------- 
    unstacked : DataFrame 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">index: MultiIndex</span><span class="s0">, </span><span class="s1">level=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">constructor=</span><span class="s0">None</span><span class="s1">):</span>

        <span class="s0">if </span><span class="s1">constructor </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">constructor = DataFrame</span>
        <span class="s1">self.constructor = constructor</span>

        <span class="s1">self.index = index.remove_unused_levels()</span>

        <span class="s1">self.level = self.index._get_level_number(level)</span>

        <span class="s4"># when index includes `nan`, need to lift levels/strides by 1</span>
        <span class="s1">self.lift = </span><span class="s3">1 </span><span class="s0">if </span><span class="s1">-</span><span class="s3">1 </span><span class="s0">in </span><span class="s1">self.index.codes[self.level] </span><span class="s0">else </span><span class="s3">0</span>

        <span class="s4"># Note: the &quot;pop&quot; below alters these in-place.</span>
        <span class="s1">self.new_index_levels = list(self.index.levels)</span>
        <span class="s1">self.new_index_names = list(self.index.names)</span>

        <span class="s1">self.removed_name = self.new_index_names.pop(self.level)</span>
        <span class="s1">self.removed_level = self.new_index_levels.pop(self.level)</span>
        <span class="s1">self.removed_level_full = index.levels[self.level]</span>

        <span class="s4"># Bug fix GH 20601</span>
        <span class="s4"># If the data frame is too big, the number of unique index combination</span>
        <span class="s4"># will cause int32 overflow on windows environments.</span>
        <span class="s4"># We want to check and raise an error before this happens</span>
        <span class="s1">num_rows = np.max([index_level.size </span><span class="s0">for </span><span class="s1">index_level </span><span class="s0">in </span><span class="s1">self.new_index_levels])</span>
        <span class="s1">num_columns = self.removed_level.size</span>

        <span class="s4"># GH20601: This forces an overflow if the number of cells is too high.</span>
        <span class="s1">num_cells = num_rows * num_columns</span>

        <span class="s4"># GH 26314: Previous ValueError raised was too restrictive for many users.</span>
        <span class="s0">if </span><span class="s1">num_cells &gt; np.iinfo(np.int32).max:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s5">f&quot;The following operation may generate </span><span class="s0">{</span><span class="s1">num_cells</span><span class="s0">} </span><span class="s5">cells &quot;</span>
                <span class="s5">f&quot;in the resulting pandas object.&quot;</span><span class="s0">,</span>
                <span class="s1">PerformanceWarning</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s1">self._make_selectors()</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">_indexer_and_to_sort(</span>
        <span class="s1">self</span><span class="s0">,</span>
    <span class="s1">) -&gt; tuple[</span>
        <span class="s1">npt.NDArray[np.intp]</span><span class="s0">,</span>
        <span class="s1">list[np.ndarray]</span><span class="s0">,  </span><span class="s4"># each has _some_ signed integer dtype</span>
    <span class="s1">]:</span>
        <span class="s1">v = self.level</span>

        <span class="s1">codes = list(self.index.codes)</span>
        <span class="s1">levs = list(self.index.levels)</span>
        <span class="s1">to_sort = codes[:v] + codes[v + </span><span class="s3">1 </span><span class="s1">:] + [codes[v]]</span>
        <span class="s1">sizes = tuple(len(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">levs[:v] + levs[v + </span><span class="s3">1 </span><span class="s1">:] + [levs[v]])</span>

        <span class="s1">comp_index</span><span class="s0">, </span><span class="s1">obs_ids = get_compressed_ids(to_sort</span><span class="s0">, </span><span class="s1">sizes)</span>
        <span class="s1">ngroups = len(obs_ids)</span>

        <span class="s1">indexer = get_group_index_sorter(comp_index</span><span class="s0">, </span><span class="s1">ngroups)</span>
        <span class="s0">return </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">to_sort</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">sorted_labels(self):</span>
        <span class="s1">indexer</span><span class="s0">, </span><span class="s1">to_sort = self._indexer_and_to_sort</span>
        <span class="s0">return </span><span class="s1">[line.take(indexer) </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">to_sort]</span>

    <span class="s0">def </span><span class="s1">_make_sorted_values(self</span><span class="s0">, </span><span class="s1">values: np.ndarray) -&gt; np.ndarray:</span>
        <span class="s1">indexer</span><span class="s0">, </span><span class="s1">_ = self._indexer_and_to_sort</span>

        <span class="s1">sorted_values = algos.take_nd(values</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">sorted_values</span>

    <span class="s0">def </span><span class="s1">_make_selectors(self):</span>
        <span class="s1">new_levels = self.new_index_levels</span>

        <span class="s4"># make the mask</span>
        <span class="s1">remaining_labels = self.sorted_labels[:-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">level_sizes = tuple(len(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">new_levels)</span>

        <span class="s1">comp_index</span><span class="s0">, </span><span class="s1">obs_ids = get_compressed_ids(remaining_labels</span><span class="s0">, </span><span class="s1">level_sizes)</span>
        <span class="s1">ngroups = len(obs_ids)</span>

        <span class="s1">comp_index = ensure_platform_int(comp_index)</span>
        <span class="s1">stride = self.index.levshape[self.level] + self.lift</span>
        <span class="s1">self.full_shape = ngroups</span><span class="s0">, </span><span class="s1">stride</span>

        <span class="s1">selector = self.sorted_labels[-</span><span class="s3">1</span><span class="s1">] + stride * comp_index + self.lift</span>
        <span class="s1">mask = np.zeros(np.prod(self.full_shape)</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">mask.put(selector</span><span class="s0">, True</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">mask.sum() &lt; len(self.index):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Index contains duplicate entries, cannot reshape&quot;</span><span class="s1">)</span>

        <span class="s1">self.group_index = comp_index</span>
        <span class="s1">self.mask = mask</span>
        <span class="s1">self.unique_groups = obs_ids</span>
        <span class="s1">self.compressor = comp_index.searchsorted(np.arange(ngroups))</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">mask_all(self) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">bool(self.mask.all())</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">arange_result(self) -&gt; tuple[npt.NDArray[np.intp]</span><span class="s0">, </span><span class="s1">npt.NDArray[np.bool_]]:</span>
        <span class="s4"># We cache this for re-use in ExtensionBlock._unstack</span>
        <span class="s1">dummy_arr = np.arange(len(self.index)</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s1">new_values</span><span class="s0">, </span><span class="s1">mask = self.get_new_values(dummy_arr</span><span class="s0">, </span><span class="s1">fill_value=-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">new_values</span><span class="s0">, </span><span class="s1">mask.any(</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s4"># TODO: in all tests we have mask.any(0).all(); can we rely on that?</span>

    <span class="s0">def </span><span class="s1">get_result(self</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">value_columns</span><span class="s0">, </span><span class="s1">fill_value):</span>

        <span class="s0">if </span><span class="s1">values.ndim == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">values = values[:</span><span class="s0">, </span><span class="s1">np.newaxis]</span>

        <span class="s0">if </span><span class="s1">value_columns </span><span class="s0">is None and </span><span class="s1">values.shape[</span><span class="s3">1</span><span class="s1">] != </span><span class="s3">1</span><span class="s1">:  </span><span class="s4"># pragma: no cover</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;must pass column labels for multi-column data&quot;</span><span class="s1">)</span>

        <span class="s1">values</span><span class="s0">, </span><span class="s1">_ = self.get_new_values(values</span><span class="s0">, </span><span class="s1">fill_value)</span>
        <span class="s1">columns = self.get_new_columns(value_columns)</span>
        <span class="s1">index = self.new_index</span>

        <span class="s0">return </span><span class="s1">self.constructor(</span>
            <span class="s1">values</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">columns=columns</span><span class="s0">, </span><span class="s1">dtype=values.dtype</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_new_values(self</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s0">None</span><span class="s1">):</span>

        <span class="s0">if </span><span class="s1">values.ndim == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">values = values[:</span><span class="s0">, </span><span class="s1">np.newaxis]</span>

        <span class="s1">sorted_values = self._make_sorted_values(values)</span>

        <span class="s4"># place the values</span>
        <span class="s1">length</span><span class="s0">, </span><span class="s1">width = self.full_shape</span>
        <span class="s1">stride = values.shape[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">result_width = width * stride</span>
        <span class="s1">result_shape = (length</span><span class="s0">, </span><span class="s1">result_width)</span>
        <span class="s1">mask = self.mask</span>
        <span class="s1">mask_all = self.mask_all</span>

        <span class="s4"># we can simply reshape if we don't have a mask</span>
        <span class="s0">if </span><span class="s1">mask_all </span><span class="s0">and </span><span class="s1">len(values):</span>
            <span class="s4"># TODO: Under what circumstances can we rely on sorted_values</span>
            <span class="s4">#  matching values?  When that holds, we can slice instead</span>
            <span class="s4">#  of take (in particular for EAs)</span>
            <span class="s1">new_values = (</span>
                <span class="s1">sorted_values.reshape(length</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">stride)</span>
                <span class="s1">.swapaxes(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
                <span class="s1">.reshape(result_shape)</span>
            <span class="s1">)</span>
            <span class="s1">new_mask = np.ones(result_shape</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
            <span class="s0">return </span><span class="s1">new_values</span><span class="s0">, </span><span class="s1">new_mask</span>

        <span class="s1">dtype = values.dtype</span>

        <span class="s4"># if our mask is all True, then we can use our existing dtype</span>
        <span class="s0">if </span><span class="s1">mask_all:</span>
            <span class="s1">dtype = values.dtype</span>
            <span class="s1">new_values = np.empty(result_shape</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">ExtensionDtype):</span>
                <span class="s4"># GH#41875</span>
                <span class="s1">cls = dtype.construct_array_type()</span>
                <span class="s1">new_values = cls._empty(result_shape</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
                <span class="s1">new_values[:] = fill_value</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">dtype</span><span class="s0">, </span><span class="s1">fill_value = maybe_promote(dtype</span><span class="s0">, </span><span class="s1">fill_value)</span>
                <span class="s1">new_values = np.empty(result_shape</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
                <span class="s1">new_values.fill(fill_value)</span>

        <span class="s1">name = dtype.name</span>
        <span class="s1">new_mask = np.zeros(result_shape</span><span class="s0">, </span><span class="s1">dtype=bool)</span>

        <span class="s4"># we need to convert to a basic dtype</span>
        <span class="s4"># and possibly coerce an input to our output dtype</span>
        <span class="s4"># e.g. ints -&gt; floats</span>
        <span class="s0">if </span><span class="s1">needs_i8_conversion(values.dtype):</span>
            <span class="s1">sorted_values = sorted_values.view(</span><span class="s5">&quot;i8&quot;</span><span class="s1">)</span>
            <span class="s1">new_values = new_values.view(</span><span class="s5">&quot;i8&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">sorted_values = sorted_values.astype(name</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s4"># fill in our values &amp; mask</span>
        <span class="s1">libreshape.unstack(</span>
            <span class="s1">sorted_values</span><span class="s0">,</span>
            <span class="s1">mask.view(</span><span class="s5">&quot;u1&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">stride</span><span class="s0">,</span>
            <span class="s1">length</span><span class="s0">,</span>
            <span class="s1">width</span><span class="s0">,</span>
            <span class="s1">new_values</span><span class="s0">,</span>
            <span class="s1">new_mask.view(</span><span class="s5">&quot;u1&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s4"># reconstruct dtype if needed</span>
        <span class="s0">if </span><span class="s1">needs_i8_conversion(values.dtype):</span>
            <span class="s4"># view as datetime64 so we can wrap in DatetimeArray and use</span>
            <span class="s4">#  DTA's view method</span>
            <span class="s1">new_values = new_values.view(</span><span class="s5">&quot;M8[ns]&quot;</span><span class="s1">)</span>
            <span class="s1">new_values = ensure_wrapped_if_datetimelike(new_values)</span>
            <span class="s1">new_values = new_values.view(values.dtype)</span>

        <span class="s0">return </span><span class="s1">new_values</span><span class="s0">, </span><span class="s1">new_mask</span>

    <span class="s0">def </span><span class="s1">get_new_columns(self</span><span class="s0">, </span><span class="s1">value_columns: Index | </span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">value_columns </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.lift == </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self.removed_level._rename(name=self.removed_name)</span>

            <span class="s1">lev = self.removed_level.insert(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">item=self.removed_level._na_value)</span>
            <span class="s0">return </span><span class="s1">lev.rename(self.removed_name)</span>

        <span class="s1">stride = len(self.removed_level) + self.lift</span>
        <span class="s1">width = len(value_columns)</span>
        <span class="s1">propagator = np.repeat(np.arange(width)</span><span class="s0">, </span><span class="s1">stride)</span>

        <span class="s1">new_levels: FrozenList | list[Index]</span>

        <span class="s0">if </span><span class="s1">isinstance(value_columns</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
            <span class="s1">new_levels = value_columns.levels + (self.removed_level_full</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">new_names = value_columns.names + (self.removed_name</span><span class="s0">,</span><span class="s1">)</span>

            <span class="s1">new_codes = [lab.take(propagator) </span><span class="s0">for </span><span class="s1">lab </span><span class="s0">in </span><span class="s1">value_columns.codes]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">new_levels = [</span>
                <span class="s1">value_columns</span><span class="s0">,</span>
                <span class="s1">self.removed_level_full</span><span class="s0">,</span>
            <span class="s1">]</span>
            <span class="s1">new_names = [value_columns.name</span><span class="s0">, </span><span class="s1">self.removed_name]</span>
            <span class="s1">new_codes = [propagator]</span>

        <span class="s1">repeater = self._repeater</span>

        <span class="s4"># The entire level is then just a repetition of the single chunk:</span>
        <span class="s1">new_codes.append(np.tile(repeater</span><span class="s0">, </span><span class="s1">width))</span>
        <span class="s0">return </span><span class="s1">MultiIndex(</span>
            <span class="s1">levels=new_levels</span><span class="s0">, </span><span class="s1">codes=new_codes</span><span class="s0">, </span><span class="s1">names=new_names</span><span class="s0">, </span><span class="s1">verify_integrity=</span><span class="s0">False</span>
        <span class="s1">)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">_repeater(self) -&gt; np.ndarray:</span>
        <span class="s4"># The two indices differ only if the unstacked level had unused items:</span>
        <span class="s0">if </span><span class="s1">len(self.removed_level_full) != len(self.removed_level):</span>
            <span class="s4"># In this case, we remap the new codes to the original level:</span>
            <span class="s1">repeater = self.removed_level_full.get_indexer(self.removed_level)</span>
            <span class="s0">if </span><span class="s1">self.lift:</span>
                <span class="s1">repeater = np.insert(repeater</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># Otherwise, we just use each level item exactly once:</span>
            <span class="s1">stride = len(self.removed_level) + self.lift</span>
            <span class="s1">repeater = np.arange(stride) - self.lift</span>

        <span class="s0">return </span><span class="s1">repeater</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">new_index(self):</span>
        <span class="s4"># Does not depend on values or value_columns</span>
        <span class="s1">result_codes = [lab.take(self.compressor) </span><span class="s0">for </span><span class="s1">lab </span><span class="s0">in </span><span class="s1">self.sorted_labels[:-</span><span class="s3">1</span><span class="s1">]]</span>

        <span class="s4"># construct the new index</span>
        <span class="s0">if </span><span class="s1">len(self.new_index_levels) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">level</span><span class="s0">, </span><span class="s1">level_codes = self.new_index_levels[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">result_codes[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">(level_codes == -</span><span class="s3">1</span><span class="s1">).any():</span>
                <span class="s1">level = level.insert(len(level)</span><span class="s0">, </span><span class="s1">level._na_value)</span>
            <span class="s0">return </span><span class="s1">level.take(level_codes).rename(self.new_index_names[</span><span class="s3">0</span><span class="s1">])</span>

        <span class="s0">return </span><span class="s1">MultiIndex(</span>
            <span class="s1">levels=self.new_index_levels</span><span class="s0">,</span>
            <span class="s1">codes=result_codes</span><span class="s0">,</span>
            <span class="s1">names=self.new_index_names</span><span class="s0">,</span>
            <span class="s1">verify_integrity=</span><span class="s0">False,</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_unstack_multiple(data</span><span class="s0">, </span><span class="s1">clocs</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">len(clocs) == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">data</span>

    <span class="s4"># NOTE: This doesn't deal with hierarchical columns yet</span>

    <span class="s1">index = data.index</span>

    <span class="s4"># GH 19966 Make sure if MultiIndexed index has tuple name, they will be</span>
    <span class="s4"># recognised as a whole</span>
    <span class="s0">if </span><span class="s1">clocs </span><span class="s0">in </span><span class="s1">index.names:</span>
        <span class="s1">clocs = [clocs]</span>
    <span class="s1">clocs = [index._get_level_number(i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">clocs]</span>

    <span class="s1">rlocs = [i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(index.nlevels) </span><span class="s0">if </span><span class="s1">i </span><span class="s0">not in </span><span class="s1">clocs]</span>

    <span class="s1">clevels = [index.levels[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">clocs]</span>
    <span class="s1">ccodes = [index.codes[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">clocs]</span>
    <span class="s1">cnames = [index.names[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">clocs]</span>
    <span class="s1">rlevels = [index.levels[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">rlocs]</span>
    <span class="s1">rcodes = [index.codes[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">rlocs]</span>
    <span class="s1">rnames = [index.names[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">rlocs]</span>

    <span class="s1">shape = tuple(len(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">clevels)</span>
    <span class="s1">group_index = get_group_index(ccodes</span><span class="s0">, </span><span class="s1">shape</span><span class="s0">, </span><span class="s1">sort=</span><span class="s0">False, </span><span class="s1">xnull=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">comp_ids</span><span class="s0">, </span><span class="s1">obs_ids = compress_group_index(group_index</span><span class="s0">, </span><span class="s1">sort=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">recons_codes = decons_obs_group_ids(comp_ids</span><span class="s0">, </span><span class="s1">obs_ids</span><span class="s0">, </span><span class="s1">shape</span><span class="s0">, </span><span class="s1">ccodes</span><span class="s0">, </span><span class="s1">xnull=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">if not </span><span class="s1">rlocs:</span>
        <span class="s4"># Everything is in clocs, so the dummy df has a regular index</span>
        <span class="s1">dummy_index = Index(obs_ids</span><span class="s0">, </span><span class="s1">name=</span><span class="s5">&quot;__placeholder__&quot;</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">dummy_index = MultiIndex(</span>
            <span class="s1">levels=rlevels + [obs_ids]</span><span class="s0">,</span>
            <span class="s1">codes=rcodes + [comp_ids]</span><span class="s0">,</span>
            <span class="s1">names=rnames + [</span><span class="s5">&quot;__placeholder__&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">verify_integrity=</span><span class="s0">False,</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">isinstance(data</span><span class="s0">, </span><span class="s1">Series):</span>
        <span class="s1">dummy = data.copy()</span>
        <span class="s1">dummy.index = dummy_index</span>

        <span class="s1">unstacked = dummy.unstack(</span><span class="s5">&quot;__placeholder__&quot;</span><span class="s0">, </span><span class="s1">fill_value=fill_value)</span>
        <span class="s1">new_levels = clevels</span>
        <span class="s1">new_names = cnames</span>
        <span class="s1">new_codes = recons_codes</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">isinstance(data.columns</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
            <span class="s1">result = data</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(clocs)):</span>
                <span class="s1">val = clocs[i]</span>
                <span class="s1">result = result.unstack(val</span><span class="s0">, </span><span class="s1">fill_value=fill_value)</span>
                <span class="s1">clocs = [v </span><span class="s0">if </span><span class="s1">v &lt; val </span><span class="s0">else </span><span class="s1">v - </span><span class="s3">1 </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">clocs]</span>

            <span class="s0">return </span><span class="s1">result</span>

        <span class="s4"># GH#42579 deep=False to avoid consolidating</span>
        <span class="s1">dummy = data.copy(deep=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">dummy.index = dummy_index</span>

        <span class="s1">unstacked = dummy.unstack(</span><span class="s5">&quot;__placeholder__&quot;</span><span class="s0">, </span><span class="s1">fill_value=fill_value)</span>
        <span class="s0">if </span><span class="s1">isinstance(unstacked</span><span class="s0">, </span><span class="s1">Series):</span>
            <span class="s1">unstcols = unstacked.index</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">unstcols = unstacked.columns</span>
        <span class="s0">assert </span><span class="s1">isinstance(unstcols</span><span class="s0">, </span><span class="s1">MultiIndex)  </span><span class="s4"># for mypy</span>
        <span class="s1">new_levels = [unstcols.levels[</span><span class="s3">0</span><span class="s1">]] + clevels</span>
        <span class="s1">new_names = [data.columns.name] + cnames</span>

        <span class="s1">new_codes = [unstcols.codes[</span><span class="s3">0</span><span class="s1">]]</span>
        <span class="s0">for </span><span class="s1">rec </span><span class="s0">in </span><span class="s1">recons_codes:</span>
            <span class="s1">new_codes.append(rec.take(unstcols.codes[-</span><span class="s3">1</span><span class="s1">]))</span>

    <span class="s1">new_columns = MultiIndex(</span>
        <span class="s1">levels=new_levels</span><span class="s0">, </span><span class="s1">codes=new_codes</span><span class="s0">, </span><span class="s1">names=new_names</span><span class="s0">, </span><span class="s1">verify_integrity=</span><span class="s0">False</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">isinstance(unstacked</span><span class="s0">, </span><span class="s1">Series):</span>
        <span class="s1">unstacked.index = new_columns</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">unstacked.columns = new_columns</span>

    <span class="s0">return </span><span class="s1">unstacked</span>


<span class="s0">def </span><span class="s1">unstack(obj</span><span class="s0">, </span><span class="s1">level</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s0">None</span><span class="s1">):</span>

    <span class="s0">if </span><span class="s1">isinstance(level</span><span class="s0">, </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list)):</span>
        <span class="s0">if </span><span class="s1">len(level) != </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s4"># _unstack_multiple only handles MultiIndexes,</span>
            <span class="s4"># and isn't needed for a single level</span>
            <span class="s0">return </span><span class="s1">_unstack_multiple(obj</span><span class="s0">, </span><span class="s1">level</span><span class="s0">, </span><span class="s1">fill_value=fill_value)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">level = level[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s4"># Prioritize integer interpretation (GH #21677):</span>
    <span class="s0">if not </span><span class="s1">is_integer(level) </span><span class="s0">and not </span><span class="s1">level == </span><span class="s5">&quot;__placeholder__&quot;</span><span class="s1">:</span>
        <span class="s1">level = obj.index._get_level_number(level)</span>

    <span class="s0">if </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">DataFrame):</span>
        <span class="s0">if </span><span class="s1">isinstance(obj.index</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
            <span class="s0">return </span><span class="s1">_unstack_frame(obj</span><span class="s0">, </span><span class="s1">level</span><span class="s0">, </span><span class="s1">fill_value=fill_value)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">obj.T.stack(dropna=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">elif not </span><span class="s1">isinstance(obj.index</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
        <span class="s4"># GH 36113</span>
        <span class="s4"># Give nicer error messages when unstack a Series whose</span>
        <span class="s4"># Index is not a MultiIndex.</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s5">f&quot;index must be a MultiIndex to unstack, </span><span class="s0">{</span><span class="s1">type(obj.index)</span><span class="s0">} </span><span class="s5">was passed&quot;</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">is_1d_only_ea_dtype(obj.dtype):</span>
            <span class="s0">return </span><span class="s1">_unstack_extension_series(obj</span><span class="s0">, </span><span class="s1">level</span><span class="s0">, </span><span class="s1">fill_value)</span>
        <span class="s1">unstacker = _Unstacker(</span>
            <span class="s1">obj.index</span><span class="s0">, </span><span class="s1">level=level</span><span class="s0">, </span><span class="s1">constructor=obj._constructor_expanddim</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">unstacker.get_result(</span>
            <span class="s1">obj._values</span><span class="s0">, </span><span class="s1">value_columns=</span><span class="s0">None, </span><span class="s1">fill_value=fill_value</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_unstack_frame(obj</span><span class="s0">, </span><span class="s1">level</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">if not </span><span class="s1">obj._can_fast_transpose:</span>
        <span class="s1">unstacker = _Unstacker(obj.index</span><span class="s0">, </span><span class="s1">level=level)</span>
        <span class="s1">mgr = obj._mgr.unstack(unstacker</span><span class="s0">, </span><span class="s1">fill_value=fill_value)</span>
        <span class="s0">return </span><span class="s1">obj._constructor(mgr)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">unstacker = _Unstacker(obj.index</span><span class="s0">, </span><span class="s1">level=level</span><span class="s0">, </span><span class="s1">constructor=obj._constructor)</span>
        <span class="s0">return </span><span class="s1">unstacker.get_result(</span>
            <span class="s1">obj._values</span><span class="s0">, </span><span class="s1">value_columns=obj.columns</span><span class="s0">, </span><span class="s1">fill_value=fill_value</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_unstack_extension_series(series</span><span class="s0">, </span><span class="s1">level</span><span class="s0">, </span><span class="s1">fill_value):</span>
    <span class="s2">&quot;&quot;&quot; 
    Unstack an ExtensionArray-backed Series. 
 
    The ExtensionDtype is preserved. 
 
    Parameters 
    ---------- 
    series : Series 
        A Series with an ExtensionArray for values 
    level : Any 
        The level name or number. 
    fill_value : Any 
        The user-level (not physical storage) fill value to use for 
        missing values introduced by the reshape. Passed to 
        ``series.values.take``. 
 
    Returns 
    ------- 
    DataFrame 
        Each column of the DataFrame will have the same dtype as 
        the input Series. 
    &quot;&quot;&quot;</span>
    <span class="s4"># Defer to the logic in ExtensionBlock._unstack</span>
    <span class="s1">df = series.to_frame()</span>
    <span class="s1">result = df.unstack(level=level</span><span class="s0">, </span><span class="s1">fill_value=fill_value)</span>

    <span class="s4"># equiv: result.droplevel(level=0, axis=1)</span>
    <span class="s4">#  but this avoids an extra copy</span>
    <span class="s1">result.columns = result.columns.droplevel(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">stack(frame</span><span class="s0">, </span><span class="s1">level=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dropna=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert DataFrame to Series with multi-level Index. Columns become the 
    second level of the resulting hierarchical index 
 
    Returns 
    ------- 
    stacked : Series 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">factorize(index):</span>
        <span class="s0">if </span><span class="s1">index.is_unique:</span>
            <span class="s0">return </span><span class="s1">index</span><span class="s0">, </span><span class="s1">np.arange(len(index))</span>
        <span class="s1">codes</span><span class="s0">, </span><span class="s1">categories = factorize_from_iterable(index)</span>
        <span class="s0">return </span><span class="s1">categories</span><span class="s0">, </span><span class="s1">codes</span>

    <span class="s1">N</span><span class="s0">, </span><span class="s1">K = frame.shape</span>

    <span class="s4"># Will also convert negative level numbers and check if out of bounds.</span>
    <span class="s1">level_num = frame.columns._get_level_number(level)</span>

    <span class="s0">if </span><span class="s1">isinstance(frame.columns</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
        <span class="s0">return </span><span class="s1">_stack_multi_columns(frame</span><span class="s0">, </span><span class="s1">level_num=level_num</span><span class="s0">, </span><span class="s1">dropna=dropna)</span>
    <span class="s0">elif </span><span class="s1">isinstance(frame.index</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
        <span class="s1">new_levels = list(frame.index.levels)</span>
        <span class="s1">new_codes = [lab.repeat(K) </span><span class="s0">for </span><span class="s1">lab </span><span class="s0">in </span><span class="s1">frame.index.codes]</span>

        <span class="s1">clev</span><span class="s0">, </span><span class="s1">clab = factorize(frame.columns)</span>
        <span class="s1">new_levels.append(clev)</span>
        <span class="s1">new_codes.append(np.tile(clab</span><span class="s0">, </span><span class="s1">N).ravel())</span>

        <span class="s1">new_names = list(frame.index.names)</span>
        <span class="s1">new_names.append(frame.columns.name)</span>
        <span class="s1">new_index = MultiIndex(</span>
            <span class="s1">levels=new_levels</span><span class="s0">, </span><span class="s1">codes=new_codes</span><span class="s0">, </span><span class="s1">names=new_names</span><span class="s0">, </span><span class="s1">verify_integrity=</span><span class="s0">False</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">levels</span><span class="s0">, </span><span class="s1">(ilab</span><span class="s0">, </span><span class="s1">clab) = zip(*map(factorize</span><span class="s0">, </span><span class="s1">(frame.index</span><span class="s0">, </span><span class="s1">frame.columns)))</span>
        <span class="s1">codes = ilab.repeat(K)</span><span class="s0">, </span><span class="s1">np.tile(clab</span><span class="s0">, </span><span class="s1">N).ravel()</span>
        <span class="s1">new_index = MultiIndex(</span>
            <span class="s1">levels=levels</span><span class="s0">,</span>
            <span class="s1">codes=codes</span><span class="s0">,</span>
            <span class="s1">names=[frame.index.name</span><span class="s0">, </span><span class="s1">frame.columns.name]</span><span class="s0">,</span>
            <span class="s1">verify_integrity=</span><span class="s0">False,</span>
        <span class="s1">)</span>

    <span class="s0">if not </span><span class="s1">frame.empty </span><span class="s0">and </span><span class="s1">frame._is_homogeneous_type:</span>
        <span class="s4"># For homogeneous EAs, frame._values will coerce to object. So</span>
        <span class="s4"># we concatenate instead.</span>
        <span class="s1">dtypes = list(frame.dtypes._values)</span>
        <span class="s1">dtype = dtypes[</span><span class="s3">0</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">is_extension_array_dtype(dtype):</span>
            <span class="s1">arr = dtype.construct_array_type()</span>
            <span class="s1">new_values = arr._concat_same_type(</span>
                <span class="s1">[col._values </span><span class="s0">for </span><span class="s1">_</span><span class="s0">, </span><span class="s1">col </span><span class="s0">in </span><span class="s1">frame.items()]</span>
            <span class="s1">)</span>
            <span class="s1">new_values = _reorder_for_extension_array_stack(new_values</span><span class="s0">, </span><span class="s1">N</span><span class="s0">, </span><span class="s1">K)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># homogeneous, non-EA</span>
            <span class="s1">new_values = frame._values.ravel()</span>

    <span class="s0">else</span><span class="s1">:</span>
        <span class="s4"># non-homogeneous</span>
        <span class="s1">new_values = frame._values.ravel()</span>

    <span class="s0">if </span><span class="s1">dropna:</span>
        <span class="s1">mask = notna(new_values)</span>
        <span class="s1">new_values = new_values[mask]</span>
        <span class="s1">new_index = new_index[mask]</span>

    <span class="s0">return </span><span class="s1">frame._constructor_sliced(new_values</span><span class="s0">, </span><span class="s1">index=new_index)</span>


<span class="s0">def </span><span class="s1">stack_multiple(frame</span><span class="s0">, </span><span class="s1">level</span><span class="s0">, </span><span class="s1">dropna=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s4"># If all passed levels match up to column names, no</span>
    <span class="s4"># ambiguity about what to do</span>
    <span class="s0">if </span><span class="s1">all(lev </span><span class="s0">in </span><span class="s1">frame.columns.names </span><span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">level):</span>
        <span class="s1">result = frame</span>
        <span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">level:</span>
            <span class="s1">result = stack(result</span><span class="s0">, </span><span class="s1">lev</span><span class="s0">, </span><span class="s1">dropna=dropna)</span>

    <span class="s4"># Otherwise, level numbers may change as each successive level is stacked</span>
    <span class="s0">elif </span><span class="s1">all(isinstance(lev</span><span class="s0">, </span><span class="s1">int) </span><span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">level):</span>
        <span class="s4"># As each stack is done, the level numbers decrease, so we need</span>
        <span class="s4">#  to account for that when level is a sequence of ints</span>
        <span class="s1">result = frame</span>
        <span class="s4"># _get_level_number() checks level numbers are in range and converts</span>
        <span class="s4"># negative numbers to positive</span>
        <span class="s1">level = [frame.columns._get_level_number(lev) </span><span class="s0">for </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">level]</span>

        <span class="s4"># Can't iterate directly through level as we might need to change</span>
        <span class="s4"># values as we go</span>
        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(len(level)):</span>
            <span class="s1">lev = level[index]</span>
            <span class="s1">result = stack(result</span><span class="s0">, </span><span class="s1">lev</span><span class="s0">, </span><span class="s1">dropna=dropna)</span>
            <span class="s4"># Decrement all level numbers greater than current, as these</span>
            <span class="s4"># have now shifted down by one</span>
            <span class="s1">updated_level = []</span>
            <span class="s0">for </span><span class="s1">other </span><span class="s0">in </span><span class="s1">level:</span>
                <span class="s0">if </span><span class="s1">other &gt; lev:</span>
                    <span class="s1">updated_level.append(other - </span><span class="s3">1</span><span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">updated_level.append(other)</span>
            <span class="s1">level = updated_level</span>

    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s5">&quot;level should contain all level names or all level &quot;</span>
            <span class="s5">&quot;numbers, not a mixture of the two.&quot;</span>
        <span class="s1">)</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">_stack_multi_column_index(columns: MultiIndex) -&gt; MultiIndex:</span>
    <span class="s2">&quot;&quot;&quot;Creates a MultiIndex from the first N-1 levels of this MultiIndex.&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">len(columns.levels) &lt;= </span><span class="s3">2</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">columns.levels[</span><span class="s3">0</span><span class="s1">]._rename(name=columns.names[</span><span class="s3">0</span><span class="s1">])</span>

    <span class="s1">levs = [</span>
        <span class="s1">[lev[c] </span><span class="s0">if </span><span class="s1">c &gt;= </span><span class="s3">0 </span><span class="s0">else None for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">codes]</span>
        <span class="s0">for </span><span class="s1">lev</span><span class="s0">, </span><span class="s1">codes </span><span class="s0">in </span><span class="s1">zip(columns.levels[:-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">columns.codes[:-</span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">]</span>

    <span class="s4"># Remove duplicate tuples in the MultiIndex.</span>
    <span class="s1">tuples = zip(*levs)</span>
    <span class="s1">unique_tuples = (key </span><span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">itertools.groupby(tuples))</span>
    <span class="s1">new_levs = zip(*unique_tuples)</span>

    <span class="s4"># The dtype of each level must be explicitly set to avoid inferring the wrong type.</span>
    <span class="s4"># See GH-36991.</span>
    <span class="s0">return </span><span class="s1">MultiIndex.from_arrays(</span>
        <span class="s1">[</span>
            <span class="s4"># Not all indices can accept None values.</span>
            <span class="s1">Index(new_lev</span><span class="s0">, </span><span class="s1">dtype=lev.dtype) </span><span class="s0">if None not in </span><span class="s1">new_lev </span><span class="s0">else </span><span class="s1">new_lev</span>
            <span class="s0">for </span><span class="s1">new_lev</span><span class="s0">, </span><span class="s1">lev </span><span class="s0">in </span><span class="s1">zip(new_levs</span><span class="s0">, </span><span class="s1">columns.levels)</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">names=columns.names[:-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_stack_multi_columns(frame</span><span class="s0">, </span><span class="s1">level_num=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dropna=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s0">def </span><span class="s1">_convert_level_number(level_num: int</span><span class="s0">, </span><span class="s1">columns):</span>
        <span class="s2">&quot;&quot;&quot; 
        Logic for converting the level number to something we can safely pass 
        to swaplevel. 
 
        If `level_num` matches a column name return the name from 
        position `level_num`, otherwise return `level_num`. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">level_num </span><span class="s0">in </span><span class="s1">columns.names:</span>
            <span class="s0">return </span><span class="s1">columns.names[level_num]</span>

        <span class="s0">return </span><span class="s1">level_num</span>

    <span class="s1">this = frame.copy()</span>

    <span class="s4"># this makes life much simpler</span>
    <span class="s0">if </span><span class="s1">level_num != frame.columns.nlevels - </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s4"># roll levels to put selected level at end</span>
        <span class="s1">roll_columns = this.columns</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(level_num</span><span class="s0">, </span><span class="s1">frame.columns.nlevels - </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s4"># Need to check if the ints conflict with level names</span>
            <span class="s1">lev1 = _convert_level_number(i</span><span class="s0">, </span><span class="s1">roll_columns)</span>
            <span class="s1">lev2 = _convert_level_number(i + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">roll_columns)</span>
            <span class="s1">roll_columns = roll_columns.swaplevel(lev1</span><span class="s0">, </span><span class="s1">lev2)</span>
        <span class="s1">this.columns = roll_columns</span>

    <span class="s0">if not </span><span class="s1">this.columns._is_lexsorted():</span>
        <span class="s4"># Workaround the edge case where 0 is one of the column names,</span>
        <span class="s4"># which interferes with trying to sort based on the first</span>
        <span class="s4"># level</span>
        <span class="s1">level_to_sort = _convert_level_number(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">this.columns)</span>
        <span class="s1">this = this.sort_index(level=level_to_sort</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">new_columns = _stack_multi_column_index(this.columns)</span>

    <span class="s4"># time to ravel the values</span>
    <span class="s1">new_data = {}</span>
    <span class="s1">level_vals = this.columns.levels[-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">level_codes = sorted(set(this.columns.codes[-</span><span class="s3">1</span><span class="s1">]))</span>
    <span class="s1">level_vals_nan = level_vals.insert(len(level_vals)</span><span class="s0">, None</span><span class="s1">)</span>

    <span class="s1">level_vals_used = np.take(level_vals_nan</span><span class="s0">, </span><span class="s1">level_codes)</span>
    <span class="s1">levsize = len(level_codes)</span>
    <span class="s1">drop_cols = []</span>
    <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">new_columns:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">loc = this.columns.get_loc(key)</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s1">drop_cols.append(key)</span>
            <span class="s0">continue</span>

        <span class="s4"># can make more efficient?</span>
        <span class="s4"># we almost always return a slice</span>
        <span class="s4"># but if unsorted can get a boolean</span>
        <span class="s4"># indexer</span>
        <span class="s0">if not </span><span class="s1">isinstance(loc</span><span class="s0">, </span><span class="s1">slice):</span>
            <span class="s1">slice_len = len(loc)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">slice_len = loc.stop - loc.start</span>

        <span class="s0">if </span><span class="s1">slice_len != levsize:</span>
            <span class="s1">chunk = this.loc[:</span><span class="s0">, </span><span class="s1">this.columns[loc]]</span>
            <span class="s1">chunk.columns = level_vals_nan.take(chunk.columns.codes[-</span><span class="s3">1</span><span class="s1">])</span>
            <span class="s1">value_slice = chunk.reindex(columns=level_vals_used).values</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">frame._is_homogeneous_type </span><span class="s0">and </span><span class="s1">is_extension_array_dtype(</span>
                <span class="s1">frame.dtypes.iloc[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">):</span>
                <span class="s4"># TODO(EA2D): won't need special case, can go through .values</span>
                <span class="s4">#  paths below (might change to ._values)</span>
                <span class="s1">dtype = this[this.columns[loc]].dtypes.iloc[</span><span class="s3">0</span><span class="s1">]</span>
                <span class="s1">subset = this[this.columns[loc]]</span>

                <span class="s1">value_slice = dtype.construct_array_type()._concat_same_type(</span>
                    <span class="s1">[x._values </span><span class="s0">for </span><span class="s1">_</span><span class="s0">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">subset.items()]</span>
                <span class="s1">)</span>
                <span class="s1">N</span><span class="s0">, </span><span class="s1">K = subset.shape</span>
                <span class="s1">idx = np.arange(N * K).reshape(K</span><span class="s0">, </span><span class="s1">N).T.ravel()</span>
                <span class="s1">value_slice = value_slice.take(idx)</span>

            <span class="s0">elif </span><span class="s1">frame._is_mixed_type:</span>
                <span class="s1">value_slice = this[this.columns[loc]].values</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">value_slice = this.values[:</span><span class="s0">, </span><span class="s1">loc]</span>

        <span class="s0">if </span><span class="s1">value_slice.ndim &gt; </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s4"># i.e. not extension</span>
            <span class="s1">value_slice = value_slice.ravel()</span>

        <span class="s1">new_data[key] = value_slice</span>

    <span class="s0">if </span><span class="s1">len(drop_cols) &gt; </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">new_columns = new_columns.difference(drop_cols)</span>

    <span class="s1">N = len(this)</span>

    <span class="s0">if </span><span class="s1">isinstance(this.index</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
        <span class="s1">new_levels = list(this.index.levels)</span>
        <span class="s1">new_names = list(this.index.names)</span>
        <span class="s1">new_codes = [lab.repeat(levsize) </span><span class="s0">for </span><span class="s1">lab </span><span class="s0">in </span><span class="s1">this.index.codes]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">old_codes</span><span class="s0">, </span><span class="s1">old_levels = factorize_from_iterable(this.index)</span>
        <span class="s1">new_levels = [old_levels]</span>
        <span class="s1">new_codes = [old_codes.repeat(levsize)]</span>
        <span class="s1">new_names = [this.index.name]  </span><span class="s4"># something better?</span>

    <span class="s1">new_levels.append(level_vals)</span>
    <span class="s1">new_codes.append(np.tile(level_codes</span><span class="s0">, </span><span class="s1">N))</span>
    <span class="s1">new_names.append(frame.columns.names[level_num])</span>

    <span class="s1">new_index = MultiIndex(</span>
        <span class="s1">levels=new_levels</span><span class="s0">, </span><span class="s1">codes=new_codes</span><span class="s0">, </span><span class="s1">names=new_names</span><span class="s0">, </span><span class="s1">verify_integrity=</span><span class="s0">False</span>
    <span class="s1">)</span>

    <span class="s1">result = frame._constructor(new_data</span><span class="s0">, </span><span class="s1">index=new_index</span><span class="s0">, </span><span class="s1">columns=new_columns)</span>

    <span class="s4"># more efficient way to go about this? can do the whole masking biz but</span>
    <span class="s4"># will only save a small amount of time...</span>
    <span class="s0">if </span><span class="s1">dropna:</span>
        <span class="s1">result = result.dropna(axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">how=</span><span class="s5">&quot;all&quot;</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">get_dummies(</span>
    <span class="s1">data</span><span class="s0">,</span>
    <span class="s1">prefix=</span><span class="s0">None,</span>
    <span class="s1">prefix_sep=</span><span class="s5">&quot;_&quot;</span><span class="s0">,</span>
    <span class="s1">dummy_na: bool = </span><span class="s0">False,</span>
    <span class="s1">columns=</span><span class="s0">None,</span>
    <span class="s1">sparse: bool = </span><span class="s0">False,</span>
    <span class="s1">drop_first: bool = </span><span class="s0">False,</span>
    <span class="s1">dtype: Dtype | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
<span class="s1">) -&gt; DataFrame:</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert categorical variable into dummy/indicator variables. 
 
    Parameters 
    ---------- 
    data : array-like, Series, or DataFrame 
        Data of which to get dummy indicators. 
    prefix : str, list of str, or dict of str, default None 
        String to append DataFrame column names. 
        Pass a list with length equal to the number of columns 
        when calling get_dummies on a DataFrame. Alternatively, `prefix` 
        can be a dictionary mapping column names to prefixes. 
    prefix_sep : str, default '_' 
        If appending prefix, separator/delimiter to use. Or pass a 
        list or dictionary as with `prefix`. 
    dummy_na : bool, default False 
        Add a column to indicate NaNs, if False NaNs are ignored. 
    columns : list-like, default None 
        Column names in the DataFrame to be encoded. 
        If `columns` is None then all the columns with 
        `object` or `category` dtype will be converted. 
    sparse : bool, default False 
        Whether the dummy-encoded columns should be backed by 
        a :class:`SparseArray` (True) or a regular NumPy array (False). 
    drop_first : bool, default False 
        Whether to get k-1 dummies out of k categorical levels by removing the 
        first level. 
    dtype : dtype, default np.uint8 
        Data type for new columns. Only a single dtype is allowed. 
 
    Returns 
    ------- 
    DataFrame 
        Dummy-coded data. 
 
    See Also 
    -------- 
    Series.str.get_dummies : Convert Series to dummy codes. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; s = pd.Series(list('abca')) 
 
    &gt;&gt;&gt; pd.get_dummies(s) 
       a  b  c 
    0  1  0  0 
    1  0  1  0 
    2  0  0  1 
    3  1  0  0 
 
    &gt;&gt;&gt; s1 = ['a', 'b', np.nan] 
 
    &gt;&gt;&gt; pd.get_dummies(s1) 
       a  b 
    0  1  0 
    1  0  1 
    2  0  0 
 
    &gt;&gt;&gt; pd.get_dummies(s1, dummy_na=True) 
       a  b  NaN 
    0  1  0    0 
    1  0  1    0 
    2  0  0    1 
 
    &gt;&gt;&gt; df = pd.DataFrame({'A': ['a', 'b', 'a'], 'B': ['b', 'a', 'c'], 
    ...                    'C': [1, 2, 3]}) 
 
    &gt;&gt;&gt; pd.get_dummies(df, prefix=['col1', 'col2']) 
       C  col1_a  col1_b  col2_a  col2_b  col2_c 
    0  1       1       0       0       1       0 
    1  2       0       1       1       0       0 
    2  3       1       0       0       0       1 
 
    &gt;&gt;&gt; pd.get_dummies(pd.Series(list('abcaa'))) 
       a  b  c 
    0  1  0  0 
    1  0  1  0 
    2  0  0  1 
    3  1  0  0 
    4  1  0  0 
 
    &gt;&gt;&gt; pd.get_dummies(pd.Series(list('abcaa')), drop_first=True) 
       b  c 
    0  0  0 
    1  1  0 
    2  0  1 
    3  0  0 
    4  0  0 
 
    &gt;&gt;&gt; pd.get_dummies(pd.Series(list('abc')), dtype=float) 
         a    b    c 
    0  1.0  0.0  0.0 
    1  0.0  1.0  0.0 
    2  0.0  0.0  1.0 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">pandas.core.reshape.concat </span><span class="s0">import </span><span class="s1">concat</span>

    <span class="s1">dtypes_to_encode = [</span><span class="s5">&quot;object&quot;</span><span class="s0">, </span><span class="s5">&quot;category&quot;</span><span class="s1">]</span>

    <span class="s0">if </span><span class="s1">isinstance(data</span><span class="s0">, </span><span class="s1">DataFrame):</span>
        <span class="s4"># determine columns being encoded</span>
        <span class="s0">if </span><span class="s1">columns </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">data_to_encode = data.select_dtypes(include=dtypes_to_encode)</span>
        <span class="s0">elif not </span><span class="s1">is_list_like(columns):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;Input must be a list-like for parameter `columns`&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">data_to_encode = data[columns]</span>

        <span class="s4"># validate prefixes and separator to avoid silently dropping cols</span>
        <span class="s0">def </span><span class="s1">check_len(item</span><span class="s0">, </span><span class="s1">name):</span>

            <span class="s0">if </span><span class="s1">is_list_like(item):</span>
                <span class="s0">if not </span><span class="s1">len(item) == data_to_encode.shape[</span><span class="s3">1</span><span class="s1">]:</span>
                    <span class="s1">len_msg = (</span>
                        <span class="s5">f&quot;Length of '</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s5">' (</span><span class="s0">{</span><span class="s1">len(item)</span><span class="s0">}</span><span class="s5">) did not match the &quot;</span>
                        <span class="s5">&quot;length of the columns being encoded &quot;</span>
                        <span class="s5">f&quot;(</span><span class="s0">{</span><span class="s1">data_to_encode.shape[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">}</span><span class="s5">).&quot;</span>
                    <span class="s1">)</span>
                    <span class="s0">raise </span><span class="s1">ValueError(len_msg)</span>

        <span class="s1">check_len(prefix</span><span class="s0">, </span><span class="s5">&quot;prefix&quot;</span><span class="s1">)</span>
        <span class="s1">check_len(prefix_sep</span><span class="s0">, </span><span class="s5">&quot;prefix_sep&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">isinstance(prefix</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">prefix = itertools.cycle([prefix])</span>
        <span class="s0">if </span><span class="s1">isinstance(prefix</span><span class="s0">, </span><span class="s1">dict):</span>
            <span class="s1">prefix = [prefix[col] </span><span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">data_to_encode.columns]</span>

        <span class="s0">if </span><span class="s1">prefix </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">prefix = data_to_encode.columns</span>

        <span class="s4"># validate separators</span>
        <span class="s0">if </span><span class="s1">isinstance(prefix_sep</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">prefix_sep = itertools.cycle([prefix_sep])</span>
        <span class="s0">elif </span><span class="s1">isinstance(prefix_sep</span><span class="s0">, </span><span class="s1">dict):</span>
            <span class="s1">prefix_sep = [prefix_sep[col] </span><span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">data_to_encode.columns]</span>

        <span class="s1">with_dummies: list[DataFrame]</span>
        <span class="s0">if </span><span class="s1">data_to_encode.shape == data.shape:</span>
            <span class="s4"># Encoding the entire df, do not prepend any dropped columns</span>
            <span class="s1">with_dummies = []</span>
        <span class="s0">elif </span><span class="s1">columns </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s4"># Encoding only cols specified in columns. Get all cols not in</span>
            <span class="s4"># columns to prepend to result.</span>
            <span class="s1">with_dummies = [data.drop(columns</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># Encoding only object and category dtype columns. Get remaining</span>
            <span class="s4"># columns to prepend to result.</span>
            <span class="s1">with_dummies = [data.select_dtypes(exclude=dtypes_to_encode)]</span>

        <span class="s0">for </span><span class="s1">(col</span><span class="s0">, </span><span class="s1">pre</span><span class="s0">, </span><span class="s1">sep) </span><span class="s0">in </span><span class="s1">zip(data_to_encode.items()</span><span class="s0">, </span><span class="s1">prefix</span><span class="s0">, </span><span class="s1">prefix_sep):</span>
            <span class="s4"># col is (column_name, column), use just column data here</span>
            <span class="s1">dummy = _get_dummies_1d(</span>
                <span class="s1">col[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">prefix=pre</span><span class="s0">,</span>
                <span class="s1">prefix_sep=sep</span><span class="s0">,</span>
                <span class="s1">dummy_na=dummy_na</span><span class="s0">,</span>
                <span class="s1">sparse=sparse</span><span class="s0">,</span>
                <span class="s1">drop_first=drop_first</span><span class="s0">,</span>
                <span class="s1">dtype=dtype</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">with_dummies.append(dummy)</span>
        <span class="s1">result = concat(with_dummies</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result = _get_dummies_1d(</span>
            <span class="s1">data</span><span class="s0">,</span>
            <span class="s1">prefix</span><span class="s0">,</span>
            <span class="s1">prefix_sep</span><span class="s0">,</span>
            <span class="s1">dummy_na</span><span class="s0">,</span>
            <span class="s1">sparse=sparse</span><span class="s0">,</span>
            <span class="s1">drop_first=drop_first</span><span class="s0">,</span>
            <span class="s1">dtype=dtype</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">_get_dummies_1d(</span>
    <span class="s1">data</span><span class="s0">,</span>
    <span class="s1">prefix</span><span class="s0">,</span>
    <span class="s1">prefix_sep=</span><span class="s5">&quot;_&quot;</span><span class="s0">,</span>
    <span class="s1">dummy_na: bool = </span><span class="s0">False,</span>
    <span class="s1">sparse: bool = </span><span class="s0">False,</span>
    <span class="s1">drop_first: bool = </span><span class="s0">False,</span>
    <span class="s1">dtype: Dtype | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
<span class="s1">) -&gt; DataFrame:</span>
    <span class="s0">from </span><span class="s1">pandas.core.reshape.concat </span><span class="s0">import </span><span class="s1">concat</span>

    <span class="s4"># Series avoids inconsistent NaN handling</span>
    <span class="s1">codes</span><span class="s0">, </span><span class="s1">levels = factorize_from_iterable(Series(data))</span>

    <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">dtype = np.dtype(np.uint8)</span>
    <span class="s4"># error: Argument 1 to &quot;dtype&quot; has incompatible type &quot;Union[ExtensionDtype, str,</span>
    <span class="s4"># dtype[Any], Type[object]]&quot;; expected &quot;Type[Any]&quot;</span>
    <span class="s1">dtype = np.dtype(dtype)  </span><span class="s4"># type: ignore[arg-type]</span>

    <span class="s0">if </span><span class="s1">is_object_dtype(dtype):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;dtype=object is not a valid dtype for get_dummies&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_empty_frame(data) -&gt; DataFrame:</span>
        <span class="s1">index: Index | np.ndarray</span>
        <span class="s0">if </span><span class="s1">isinstance(data</span><span class="s0">, </span><span class="s1">Series):</span>
            <span class="s1">index = data.index</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">index = Index(range(len(data)))</span>
        <span class="s0">return </span><span class="s1">DataFrame(index=index)</span>

    <span class="s4"># if all NaN</span>
    <span class="s0">if not </span><span class="s1">dummy_na </span><span class="s0">and </span><span class="s1">len(levels) == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">get_empty_frame(data)</span>

    <span class="s1">codes = codes.copy()</span>
    <span class="s0">if </span><span class="s1">dummy_na:</span>
        <span class="s1">codes[codes == -</span><span class="s3">1</span><span class="s1">] = len(levels)</span>
        <span class="s1">levels = levels.insert(len(levels)</span><span class="s0">, </span><span class="s1">np.nan)</span>

    <span class="s4"># if dummy_na, we just fake a nan level. drop_first will drop it again</span>
    <span class="s0">if </span><span class="s1">drop_first </span><span class="s0">and </span><span class="s1">len(levels) == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">get_empty_frame(data)</span>

    <span class="s1">number_of_cols = len(levels)</span>

    <span class="s0">if </span><span class="s1">prefix </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">dummy_cols = levels</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">dummy_cols = Index([</span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">prefix</span><span class="s0">}{</span><span class="s1">prefix_sep</span><span class="s0">}{</span><span class="s1">level</span><span class="s0">}</span><span class="s5">&quot; </span><span class="s0">for </span><span class="s1">level </span><span class="s0">in </span><span class="s1">levels])</span>

    <span class="s1">index: Index | </span><span class="s0">None</span>
    <span class="s0">if </span><span class="s1">isinstance(data</span><span class="s0">, </span><span class="s1">Series):</span>
        <span class="s1">index = data.index</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">index = </span><span class="s0">None</span>

    <span class="s0">if </span><span class="s1">sparse:</span>

        <span class="s1">fill_value: bool | float | int</span>
        <span class="s0">if </span><span class="s1">is_integer_dtype(dtype):</span>
            <span class="s1">fill_value = </span><span class="s3">0</span>
        <span class="s0">elif </span><span class="s1">dtype == np.dtype(bool):</span>
            <span class="s1">fill_value = </span><span class="s0">False</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">fill_value = </span><span class="s3">0.0</span>

        <span class="s1">sparse_series = []</span>
        <span class="s1">N = len(data)</span>
        <span class="s1">sp_indices: list[list] = [[] </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(len(dummy_cols))]</span>
        <span class="s1">mask = codes != -</span><span class="s3">1</span>
        <span class="s1">codes = codes[mask]</span>
        <span class="s1">n_idx = np.arange(N)[mask]</span>

        <span class="s0">for </span><span class="s1">ndx</span><span class="s0">, </span><span class="s1">code </span><span class="s0">in </span><span class="s1">zip(n_idx</span><span class="s0">, </span><span class="s1">codes):</span>
            <span class="s1">sp_indices[code].append(ndx)</span>

        <span class="s0">if </span><span class="s1">drop_first:</span>
            <span class="s4"># remove first categorical level to avoid perfect collinearity</span>
            <span class="s4"># GH12042</span>
            <span class="s1">sp_indices = sp_indices[</span><span class="s3">1</span><span class="s1">:]</span>
            <span class="s1">dummy_cols = dummy_cols[</span><span class="s3">1</span><span class="s1">:]</span>
        <span class="s0">for </span><span class="s1">col</span><span class="s0">, </span><span class="s1">ixs </span><span class="s0">in </span><span class="s1">zip(dummy_cols</span><span class="s0">, </span><span class="s1">sp_indices):</span>
            <span class="s1">sarr = SparseArray(</span>
                <span class="s1">np.ones(len(ixs)</span><span class="s0">, </span><span class="s1">dtype=dtype)</span><span class="s0">,</span>
                <span class="s1">sparse_index=IntIndex(N</span><span class="s0">, </span><span class="s1">ixs)</span><span class="s0">,</span>
                <span class="s1">fill_value=fill_value</span><span class="s0">,</span>
                <span class="s1">dtype=dtype</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">sparse_series.append(Series(data=sarr</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">name=col))</span>

        <span class="s0">return </span><span class="s1">concat(sparse_series</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">else</span><span class="s1">:</span>
        <span class="s4"># take on axis=1 + transpose to ensure ndarray layout is column-major</span>
        <span class="s1">dummy_mat = np.eye(number_of_cols</span><span class="s0">, </span><span class="s1">dtype=dtype).take(codes</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">).T</span>

        <span class="s0">if not </span><span class="s1">dummy_na:</span>
            <span class="s4"># reset NaN GH4446</span>
            <span class="s1">dummy_mat[codes == -</span><span class="s3">1</span><span class="s1">] = </span><span class="s3">0</span>

        <span class="s0">if </span><span class="s1">drop_first:</span>
            <span class="s4"># remove first GH12042</span>
            <span class="s1">dummy_mat = dummy_mat[:</span><span class="s0">, </span><span class="s3">1</span><span class="s1">:]</span>
            <span class="s1">dummy_cols = dummy_cols[</span><span class="s3">1</span><span class="s1">:]</span>
        <span class="s0">return </span><span class="s1">DataFrame(dummy_mat</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">columns=dummy_cols)</span>


<span class="s0">def </span><span class="s1">_reorder_for_extension_array_stack(</span>
    <span class="s1">arr: ExtensionArray</span><span class="s0">, </span><span class="s1">n_rows: int</span><span class="s0">, </span><span class="s1">n_columns: int</span>
<span class="s1">) -&gt; ExtensionArray:</span>
    <span class="s2">&quot;&quot;&quot; 
    Re-orders the values when stacking multiple extension-arrays. 
 
    The indirect stacking method used for EAs requires a followup 
    take to get the order correct. 
 
    Parameters 
    ---------- 
    arr : ExtensionArray 
    n_rows, n_columns : int 
        The number of rows and columns in the original DataFrame. 
 
    Returns 
    ------- 
    taken : ExtensionArray 
        The original `arr` with elements re-ordered appropriately 
 
    Examples 
    -------- 
    &gt;&gt;&gt; arr = np.array(['a', 'b', 'c', 'd', 'e', 'f']) 
    &gt;&gt;&gt; _reorder_for_extension_array_stack(arr, 2, 3) 
    array(['a', 'c', 'e', 'b', 'd', 'f'], dtype='&lt;U1') 
 
    &gt;&gt;&gt; _reorder_for_extension_array_stack(arr, 3, 2) 
    array(['a', 'd', 'b', 'e', 'c', 'f'], dtype='&lt;U1') 
    &quot;&quot;&quot;</span>
    <span class="s4"># final take to get the order correct.</span>
    <span class="s4"># idx is an indexer like</span>
    <span class="s4"># [c0r0, c1r0, c2r0, ...,</span>
    <span class="s4">#  c0r1, c1r1, c2r1, ...]</span>
    <span class="s1">idx = np.arange(n_rows * n_columns).reshape(n_columns</span><span class="s0">, </span><span class="s1">n_rows).T.ravel()</span>
    <span class="s0">return </span><span class="s1">arr.take(idx)</span>
</pre>
</body>
</html>