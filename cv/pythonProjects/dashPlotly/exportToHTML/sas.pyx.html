<html>
<head>
<title>sas.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sas.pyx</font>
</center></td></tr></table>
<pre><span class="s0"># cython: profile=False</span>
<span class="s0"># cython: boundscheck=False, initializedcheck=False</span>
<span class="s0">from cython import Py_ssize_t</span>
<span class="s0">import numpy as np</span>

<span class="s0">import pandas.io.sas.sas_constants as const</span>

<span class="s0">ctypedef signed long long   int64_t</span>
<span class="s0">ctypedef unsigned char      uint8_t</span>
<span class="s0">ctypedef unsigned short     uint16_t</span>

<span class="s0"># rle_decompress decompresses data using a Run Length Encoding</span>
<span class="s0"># algorithm.  It is partially documented here:</span>
<span class="s0">#</span>
<span class="s0"># https://cran.r-project.org/package=sas7bdat/vignettes/sas7bdat.pdf</span>
<span class="s0">cdef const uint8_t[:] rle_decompress(int result_length, const uint8_t[:] inbuff):</span>

    <span class="s0">cdef:</span>
        <span class="s0">uint8_t control_byte, x</span>
        <span class="s0">uint8_t[:] result = np.zeros(result_length, np.uint8)</span>
        <span class="s0">int rpos = 0</span>
        <span class="s0">int i, nbytes, end_of_first_byte</span>
        <span class="s0">Py_ssize_t ipos = 0, length = len(inbuff)</span>

    <span class="s0">while ipos &lt; length:</span>
        <span class="s0">control_byte = inbuff[ipos] &amp; 0xF0</span>
        <span class="s0">end_of_first_byte = &lt;int&gt;(inbuff[ipos] &amp; 0x0F)</span>
        <span class="s0">ipos += 1</span>

        <span class="s0">if control_byte == 0x00:</span>
            <span class="s0">if end_of_first_byte != 0:</span>
                <span class="s0">raise ValueError(&quot;Unexpected non-zero end_of_first_byte&quot;)</span>
            <span class="s0">nbytes = &lt;int&gt;(inbuff[ipos]) + 64</span>
            <span class="s0">ipos += 1</span>
            <span class="s0">for _ in range(nbytes):</span>
                <span class="s0">result[rpos] = inbuff[ipos]</span>
                <span class="s0">rpos += 1</span>
                <span class="s0">ipos += 1</span>
        <span class="s0">elif control_byte == 0x40:</span>
            <span class="s0"># not documented</span>
            <span class="s0">nbytes = end_of_first_byte * 16</span>
            <span class="s0">nbytes += &lt;int&gt;(inbuff[ipos])</span>
            <span class="s0">ipos += 1</span>
            <span class="s0">for _ in range(nbytes):</span>
                <span class="s0">result[rpos] = inbuff[ipos]</span>
                <span class="s0">rpos += 1</span>
            <span class="s0">ipos += 1</span>
        <span class="s0">elif control_byte == 0x60:</span>
            <span class="s0">nbytes = end_of_first_byte * 256 + &lt;int&gt;(inbuff[ipos]) + 17</span>
            <span class="s0">ipos += 1</span>
            <span class="s0">for _ in range(nbytes):</span>
                <span class="s0">result[rpos] = 0x20</span>
                <span class="s0">rpos += 1</span>
        <span class="s0">elif control_byte == 0x70:</span>
            <span class="s0">nbytes = end_of_first_byte * 256 + &lt;int&gt;(inbuff[ipos]) + 17</span>
            <span class="s0">ipos += 1</span>
            <span class="s0">for _ in range(nbytes):</span>
                <span class="s0">result[rpos] = 0x00</span>
                <span class="s0">rpos += 1</span>
        <span class="s0">elif control_byte == 0x80:</span>
            <span class="s0">nbytes = end_of_first_byte + 1</span>
            <span class="s0">for i in range(nbytes):</span>
                <span class="s0">result[rpos] = inbuff[ipos + i]</span>
                <span class="s0">rpos += 1</span>
            <span class="s0">ipos += nbytes</span>
        <span class="s0">elif control_byte == 0x90:</span>
            <span class="s0">nbytes = end_of_first_byte + 17</span>
            <span class="s0">for i in range(nbytes):</span>
                <span class="s0">result[rpos] = inbuff[ipos + i]</span>
                <span class="s0">rpos += 1</span>
            <span class="s0">ipos += nbytes</span>
        <span class="s0">elif control_byte == 0xA0:</span>
            <span class="s0">nbytes = end_of_first_byte + 33</span>
            <span class="s0">for i in range(nbytes):</span>
                <span class="s0">result[rpos] = inbuff[ipos + i]</span>
                <span class="s0">rpos += 1</span>
            <span class="s0">ipos += nbytes</span>
        <span class="s0">elif control_byte == 0xB0:</span>
            <span class="s0">nbytes = end_of_first_byte + 49</span>
            <span class="s0">for i in range(nbytes):</span>
                <span class="s0">result[rpos] = inbuff[ipos + i]</span>
                <span class="s0">rpos += 1</span>
            <span class="s0">ipos += nbytes</span>
        <span class="s0">elif control_byte == 0xC0:</span>
            <span class="s0">nbytes = end_of_first_byte + 3</span>
            <span class="s0">x = inbuff[ipos]</span>
            <span class="s0">ipos += 1</span>
            <span class="s0">for _ in range(nbytes):</span>
                <span class="s0">result[rpos] = x</span>
                <span class="s0">rpos += 1</span>
        <span class="s0">elif control_byte == 0xD0:</span>
            <span class="s0">nbytes = end_of_first_byte + 2</span>
            <span class="s0">for _ in range(nbytes):</span>
                <span class="s0">result[rpos] = 0x40</span>
                <span class="s0">rpos += 1</span>
        <span class="s0">elif control_byte == 0xE0:</span>
            <span class="s0">nbytes = end_of_first_byte + 2</span>
            <span class="s0">for _ in range(nbytes):</span>
                <span class="s0">result[rpos] = 0x20</span>
                <span class="s0">rpos += 1</span>
        <span class="s0">elif control_byte == 0xF0:</span>
            <span class="s0">nbytes = end_of_first_byte + 2</span>
            <span class="s0">for _ in range(nbytes):</span>
                <span class="s0">result[rpos] = 0x00</span>
                <span class="s0">rpos += 1</span>
        <span class="s0">else:</span>
            <span class="s0">raise ValueError(f&quot;unknown control byte: {control_byte}&quot;)</span>

    <span class="s0"># In py37 cython/clang sees `len(outbuff)` as size_t and not Py_ssize_t</span>
    <span class="s0">if &lt;Py_ssize_t&gt;len(result) != &lt;Py_ssize_t&gt;result_length:</span>
        <span class="s0">raise ValueError(f&quot;RLE: {len(result)} != {result_length}&quot;)</span>

    <span class="s0">return np.asarray(result)</span>


<span class="s0"># rdc_decompress decompresses data using the Ross Data Compression algorithm:</span>
<span class="s0">#</span>
<span class="s0"># http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/CUJ/1992/9210/ross/ross.htm</span>
<span class="s0">cdef const uint8_t[:] rdc_decompress(int result_length, const uint8_t[:] inbuff):</span>

    <span class="s0">cdef:</span>
        <span class="s0">uint8_t cmd</span>
        <span class="s0">uint16_t ctrl_bits = 0, ctrl_mask = 0, ofs, cnt</span>
        <span class="s0">int rpos = 0, k</span>
        <span class="s0">uint8_t[:] outbuff = np.zeros(result_length, dtype=np.uint8)</span>
        <span class="s0">Py_ssize_t ipos = 0, length = len(inbuff)</span>

    <span class="s0">ii = -1</span>

    <span class="s0">while ipos &lt; length:</span>
        <span class="s0">ii += 1</span>
        <span class="s0">ctrl_mask = ctrl_mask &gt;&gt; 1</span>
        <span class="s0">if ctrl_mask == 0:</span>
            <span class="s0">ctrl_bits = ((&lt;uint16_t&gt;inbuff[ipos] &lt;&lt; 8) +</span>
                         <span class="s0">&lt;uint16_t&gt;inbuff[ipos + 1])</span>
            <span class="s0">ipos += 2</span>
            <span class="s0">ctrl_mask = 0x8000</span>

        <span class="s0">if ctrl_bits &amp; ctrl_mask == 0:</span>
            <span class="s0">outbuff[rpos] = inbuff[ipos]</span>
            <span class="s0">ipos += 1</span>
            <span class="s0">rpos += 1</span>
            <span class="s0">continue</span>

        <span class="s0">cmd = (inbuff[ipos] &gt;&gt; 4) &amp; 0x0F</span>
        <span class="s0">cnt = &lt;uint16_t&gt;(inbuff[ipos] &amp; 0x0F)</span>
        <span class="s0">ipos += 1</span>

        <span class="s0"># short RLE</span>
        <span class="s0">if cmd == 0:</span>
            <span class="s0">cnt += 3</span>
            <span class="s0">for k in range(cnt):</span>
                <span class="s0">outbuff[rpos + k] = inbuff[ipos]</span>
            <span class="s0">rpos += cnt</span>
            <span class="s0">ipos += 1</span>

        <span class="s0"># long RLE</span>
        <span class="s0">elif cmd == 1:</span>
            <span class="s0">cnt += &lt;uint16_t&gt;inbuff[ipos] &lt;&lt; 4</span>
            <span class="s0">cnt += 19</span>
            <span class="s0">ipos += 1</span>
            <span class="s0">for k in range(cnt):</span>
                <span class="s0">outbuff[rpos + k] = inbuff[ipos]</span>
            <span class="s0">rpos += cnt</span>
            <span class="s0">ipos += 1</span>

        <span class="s0"># long pattern</span>
        <span class="s0">elif cmd == 2:</span>
            <span class="s0">ofs = cnt + 3</span>
            <span class="s0">ofs += &lt;uint16_t&gt;inbuff[ipos] &lt;&lt; 4</span>
            <span class="s0">ipos += 1</span>
            <span class="s0">cnt = &lt;uint16_t&gt;inbuff[ipos]</span>
            <span class="s0">ipos += 1</span>
            <span class="s0">cnt += 16</span>
            <span class="s0">for k in range(cnt):</span>
                <span class="s0">outbuff[rpos + k] = outbuff[rpos - &lt;int&gt;ofs + k]</span>
            <span class="s0">rpos += cnt</span>

        <span class="s0"># short pattern</span>
        <span class="s0">elif (cmd &gt;= 3) &amp; (cmd &lt;= 15):</span>
            <span class="s0">ofs = cnt + 3</span>
            <span class="s0">ofs += &lt;uint16_t&gt;inbuff[ipos] &lt;&lt; 4</span>
            <span class="s0">ipos += 1</span>
            <span class="s0">for k in range(cmd):</span>
                <span class="s0">outbuff[rpos + k] = outbuff[rpos - &lt;int&gt;ofs + k]</span>
            <span class="s0">rpos += cmd</span>

        <span class="s0">else:</span>
            <span class="s0">raise ValueError(&quot;unknown RDC command&quot;)</span>

    <span class="s0"># In py37 cython/clang sees `len(outbuff)` as size_t and not Py_ssize_t</span>
    <span class="s0">if &lt;Py_ssize_t&gt;len(outbuff) != &lt;Py_ssize_t&gt;result_length:</span>
        <span class="s0">raise ValueError(f&quot;RDC: {len(outbuff)} != {result_length}\n&quot;)</span>

    <span class="s0">return np.asarray(outbuff)</span>


<span class="s0">cdef enum ColumnTypes:</span>
    <span class="s0">column_type_decimal = 1</span>
    <span class="s0">column_type_string = 2</span>


<span class="s0"># type the page_data types</span>
<span class="s0">cdef:</span>
    <span class="s0">int page_meta_type = const.page_meta_type</span>
    <span class="s0">int page_mix_types_0 = const.page_mix_types[0]</span>
    <span class="s0">int page_mix_types_1 = const.page_mix_types[1]</span>
    <span class="s0">int page_data_type = const.page_data_type</span>
    <span class="s0">int subheader_pointers_offset = const.subheader_pointers_offset</span>


<span class="s0">cdef class Parser:</span>

    <span class="s0">cdef:</span>
        <span class="s0">int column_count</span>
        <span class="s0">int64_t[:] lengths</span>
        <span class="s0">int64_t[:] offsets</span>
        <span class="s0">int64_t[:] column_types</span>
        <span class="s0">uint8_t[:, :] byte_chunk</span>
        <span class="s0">object[:, :] string_chunk</span>
        <span class="s0">char *cached_page</span>
        <span class="s0">int current_row_on_page_index</span>
        <span class="s0">int current_page_block_count</span>
        <span class="s0">int current_page_data_subheader_pointers_len</span>
        <span class="s0">int current_page_subheaders_count</span>
        <span class="s0">int current_row_in_chunk_index</span>
        <span class="s0">int current_row_in_file_index</span>
        <span class="s0">int header_length</span>
        <span class="s0">int row_length</span>
        <span class="s0">int bit_offset</span>
        <span class="s0">int subheader_pointer_length</span>
        <span class="s0">int current_page_type</span>
        <span class="s0">bint is_little_endian</span>
        <span class="s0">const uint8_t[:] (*decompress)(int result_length, const uint8_t[:] inbuff)</span>
        <span class="s0">object parser</span>

    <span class="s0">def __init__(self, object parser):</span>
        <span class="s0">cdef:</span>
            <span class="s0">int j</span>
            <span class="s0">char[:] column_types</span>

        <span class="s0">self.parser = parser</span>
        <span class="s0">self.header_length = self.parser.header_length</span>
        <span class="s0">self.column_count = parser.column_count</span>
        <span class="s0">self.lengths = parser.column_data_lengths()</span>
        <span class="s0">self.offsets = parser.column_data_offsets()</span>
        <span class="s0">self.byte_chunk = parser._byte_chunk</span>
        <span class="s0">self.string_chunk = parser._string_chunk</span>
        <span class="s0">self.row_length = parser.row_length</span>
        <span class="s0">self.bit_offset = self.parser._page_bit_offset</span>
        <span class="s0">self.subheader_pointer_length = self.parser._subheader_pointer_length</span>
        <span class="s0">self.is_little_endian = parser.byte_order == &quot;&lt;&quot;</span>
        <span class="s0">self.column_types = np.empty(self.column_count, dtype='int64')</span>

        <span class="s0"># page indicators</span>
        <span class="s0">self.update_next_page()</span>

        <span class="s0">column_types = parser.column_types()</span>

        <span class="s0"># map column types</span>
        <span class="s0">for j in range(self.column_count):</span>
            <span class="s0">if column_types[j] == b'd':</span>
                <span class="s0">self.column_types[j] = column_type_decimal</span>
            <span class="s0">elif column_types[j] == b's':</span>
                <span class="s0">self.column_types[j] = column_type_string</span>
            <span class="s0">else:</span>
                <span class="s0">raise ValueError(f&quot;unknown column type: {self.parser.columns[j].ctype}&quot;)</span>

        <span class="s0"># compression</span>
        <span class="s0">if parser.compression == const.rle_compression:</span>
            <span class="s0">self.decompress = rle_decompress</span>
        <span class="s0">elif parser.compression == const.rdc_compression:</span>
            <span class="s0">self.decompress = rdc_decompress</span>
        <span class="s0">else:</span>
            <span class="s0">self.decompress = NULL</span>

        <span class="s0"># update to current state of the parser</span>
        <span class="s0">self.current_row_in_chunk_index = parser._current_row_in_chunk_index</span>
        <span class="s0">self.current_row_in_file_index = parser._current_row_in_file_index</span>
        <span class="s0">self.current_row_on_page_index = parser._current_row_on_page_index</span>

    <span class="s0">def read(self, int nrows):</span>
        <span class="s0">cdef:</span>
            <span class="s0">bint done</span>
            <span class="s0">int i</span>

        <span class="s0">for _ in range(nrows):</span>
            <span class="s0">done = self.readline()</span>
            <span class="s0">if done:</span>
                <span class="s0">break</span>

        <span class="s0"># update the parser</span>
        <span class="s0">self.parser._current_row_on_page_index = self.current_row_on_page_index</span>
        <span class="s0">self.parser._current_row_in_chunk_index = self.current_row_in_chunk_index</span>
        <span class="s0">self.parser._current_row_in_file_index = self.current_row_in_file_index</span>

    <span class="s0">cdef bint read_next_page(self):</span>
        <span class="s0">cdef done</span>

        <span class="s0">done = self.parser._read_next_page()</span>
        <span class="s0">if done:</span>
            <span class="s0">self.cached_page = NULL</span>
        <span class="s0">else:</span>
            <span class="s0">self.update_next_page()</span>
        <span class="s0">return done</span>

    <span class="s0">cdef update_next_page(self):</span>
        <span class="s0"># update data for the current page</span>

        <span class="s0">self.cached_page = &lt;char *&gt;self.parser._cached_page</span>
        <span class="s0">self.current_row_on_page_index = 0</span>
        <span class="s0">self.current_page_type = self.parser._current_page_type</span>
        <span class="s0">self.current_page_block_count = self.parser._current_page_block_count</span>
        <span class="s0">self.current_page_data_subheader_pointers_len = len(</span>
            <span class="s0">self.parser._current_page_data_subheader_pointers</span>
        <span class="s0">)</span>
        <span class="s0">self.current_page_subheaders_count = self.parser._current_page_subheaders_count</span>

    <span class="s0">cdef readline(self):</span>

        <span class="s0">cdef:</span>
            <span class="s0">int offset, bit_offset, align_correction</span>
            <span class="s0">int subheader_pointer_length, mn</span>
            <span class="s0">bint done, flag</span>

        <span class="s0">bit_offset = self.bit_offset</span>
        <span class="s0">subheader_pointer_length = self.subheader_pointer_length</span>

        <span class="s0"># If there is no page, go to the end of the header and read a page.</span>
        <span class="s0">if self.cached_page == NULL:</span>
            <span class="s0">self.parser._path_or_buf.seek(self.header_length)</span>
            <span class="s0">done = self.read_next_page()</span>
            <span class="s0">if done:</span>
                <span class="s0">return True</span>

        <span class="s0"># Loop until a data row is read</span>
        <span class="s0">while True:</span>
            <span class="s0">if self.current_page_type == page_meta_type:</span>
                <span class="s0">flag = self.current_row_on_page_index &gt;=\</span>
                    <span class="s0">self.current_page_data_subheader_pointers_len</span>
                <span class="s0">if flag:</span>
                    <span class="s0">done = self.read_next_page()</span>
                    <span class="s0">if done:</span>
                        <span class="s0">return True</span>
                    <span class="s0">continue</span>
                <span class="s0">current_subheader_pointer = (</span>
                    <span class="s0">self.parser._current_page_data_subheader_pointers[</span>
                        <span class="s0">self.current_row_on_page_index])</span>
                <span class="s0">self.process_byte_array_with_data(</span>
                    <span class="s0">current_subheader_pointer.offset,</span>
                    <span class="s0">current_subheader_pointer.length)</span>
                <span class="s0">return False</span>
            <span class="s0">elif (self.current_page_type == page_mix_types_0 or</span>
                    <span class="s0">self.current_page_type == page_mix_types_1):</span>
                <span class="s0">align_correction = (</span>
                    <span class="s0">bit_offset</span>
                    <span class="s0">+ subheader_pointers_offset</span>
                    <span class="s0">+ self.current_page_subheaders_count * subheader_pointer_length</span>
                <span class="s0">)</span>
                <span class="s0">align_correction = align_correction % 8</span>
                <span class="s0">offset = bit_offset + align_correction</span>
                <span class="s0">offset += subheader_pointers_offset</span>
                <span class="s0">offset += self.current_page_subheaders_count * subheader_pointer_length</span>
                <span class="s0">offset += self.current_row_on_page_index * self.row_length</span>
                <span class="s0">self.process_byte_array_with_data(offset, self.row_length)</span>
                <span class="s0">mn = min(self.parser.row_count, self.parser._mix_page_row_count)</span>
                <span class="s0">if self.current_row_on_page_index == mn:</span>
                    <span class="s0">done = self.read_next_page()</span>
                    <span class="s0">if done:</span>
                        <span class="s0">return True</span>
                <span class="s0">return False</span>
            <span class="s0">elif self.current_page_type &amp; page_data_type == page_data_type:</span>
                <span class="s0">self.process_byte_array_with_data(</span>
                    <span class="s0">bit_offset</span>
                    <span class="s0">+ subheader_pointers_offset</span>
                    <span class="s0">+ self.current_row_on_page_index * self.row_length,</span>
                    <span class="s0">self.row_length,</span>
                <span class="s0">)</span>
                <span class="s0">flag = self.current_row_on_page_index == self.current_page_block_count</span>
                <span class="s0">if flag:</span>
                    <span class="s0">done = self.read_next_page()</span>
                    <span class="s0">if done:</span>
                        <span class="s0">return True</span>
                <span class="s0">return False</span>
            <span class="s0">else:</span>
                <span class="s0">raise ValueError(f&quot;unknown page type: {self.current_page_type}&quot;)</span>

    <span class="s0">cdef void process_byte_array_with_data(self, int offset, int length):</span>

        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t j</span>
            <span class="s0">int s, k, m, jb, js, current_row</span>
            <span class="s0">int64_t lngt, start, ct</span>
            <span class="s0">const uint8_t[:] source</span>
            <span class="s0">int64_t[:] column_types</span>
            <span class="s0">int64_t[:] lengths</span>
            <span class="s0">int64_t[:] offsets</span>
            <span class="s0">uint8_t[:, :] byte_chunk</span>
            <span class="s0">object[:, :] string_chunk</span>

        <span class="s0">source = np.frombuffer(</span>
            <span class="s0">self.cached_page[offset:offset + length], dtype=np.uint8)</span>

        <span class="s0">if self.decompress != NULL and (length &lt; self.row_length):</span>
            <span class="s0">source = self.decompress(self.row_length, source)</span>

        <span class="s0">current_row = self.current_row_in_chunk_index</span>
        <span class="s0">column_types = self.column_types</span>
        <span class="s0">lengths = self.lengths</span>
        <span class="s0">offsets = self.offsets</span>
        <span class="s0">byte_chunk = self.byte_chunk</span>
        <span class="s0">string_chunk = self.string_chunk</span>
        <span class="s0">s = 8 * self.current_row_in_chunk_index</span>
        <span class="s0">js = 0</span>
        <span class="s0">jb = 0</span>
        <span class="s0">for j in range(self.column_count):</span>
            <span class="s0">lngt = lengths[j]</span>
            <span class="s0">if lngt == 0:</span>
                <span class="s0">break</span>
            <span class="s0">start = offsets[j]</span>
            <span class="s0">ct = column_types[j]</span>
            <span class="s0">if ct == column_type_decimal:</span>
                <span class="s0"># decimal</span>
                <span class="s0">if self.is_little_endian:</span>
                    <span class="s0">m = s + 8 - lngt</span>
                <span class="s0">else:</span>
                    <span class="s0">m = s</span>
                <span class="s0">for k in range(lngt):</span>
                    <span class="s0">byte_chunk[jb, m + k] = source[start + k]</span>
                <span class="s0">jb += 1</span>
            <span class="s0">elif column_types[j] == column_type_string:</span>
                <span class="s0"># string</span>
                <span class="s0">string_chunk[js, current_row] = np.array(source[start:(</span>
                    <span class="s0">start + lngt)]).tobytes().rstrip(b&quot;\x00 &quot;)</span>
                <span class="s0">js += 1</span>

        <span class="s0">self.current_row_on_page_index += 1</span>
        <span class="s0">self.current_row_in_chunk_index += 1</span>
        <span class="s0">self.current_row_in_file_index += 1</span>
</pre>
</body>
</html>