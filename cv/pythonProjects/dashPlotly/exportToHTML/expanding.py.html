<html>
<head>
<title>expanding.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
expanding.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">textwrap </span><span class="s0">import </span><span class="s1">dedent</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s0">,</span>
    <span class="s1">Any</span><span class="s0">,</span>
    <span class="s1">Callable</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Axis</span><span class="s0">,</span>
    <span class="s1">WindowingRankType</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">DataFrame</span><span class="s0">, </span><span class="s1">Series</span>
    <span class="s0">from </span><span class="s1">pandas.core.generic </span><span class="s0">import </span><span class="s1">NDFrame</span>

<span class="s0">from </span><span class="s1">pandas.compat.numpy </span><span class="s0">import </span><span class="s1">function </span><span class="s0">as </span><span class="s1">nv</span>
<span class="s0">from </span><span class="s1">pandas.util._decorators </span><span class="s0">import </span><span class="s1">doc</span>

<span class="s0">from </span><span class="s1">pandas.core.indexers.objects </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">BaseIndexer</span><span class="s0">,</span>
    <span class="s1">ExpandingIndexer</span><span class="s0">,</span>
    <span class="s1">GroupbyIndexer</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.window.doc </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">_shared_docs</span><span class="s0">,</span>
    <span class="s1">args_compat</span><span class="s0">,</span>
    <span class="s1">create_section_header</span><span class="s0">,</span>
    <span class="s1">kwargs_compat</span><span class="s0">,</span>
    <span class="s1">numba_notes</span><span class="s0">,</span>
    <span class="s1">template_header</span><span class="s0">,</span>
    <span class="s1">template_returns</span><span class="s0">,</span>
    <span class="s1">template_see_also</span><span class="s0">,</span>
    <span class="s1">window_agg_numba_parameters</span><span class="s0">,</span>
    <span class="s1">window_apply_parameters</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.window.rolling </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">BaseWindowGroupby</span><span class="s0">,</span>
    <span class="s1">RollingAndExpandingMixin</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s0">class </span><span class="s1">Expanding(RollingAndExpandingMixin):</span>
    <span class="s2">&quot;&quot;&quot; 
    Provide expanding window calculations. 
 
    Parameters 
    ---------- 
    min_periods : int, default 1 
        Minimum number of observations in window required to have a value; 
        otherwise, result is ``np.nan``. 
 
    center : bool, default False 
        If False, set the window labels as the right edge of the window index. 
 
        If True, set the window labels as the center of the window index. 
 
        .. deprecated:: 1.1.0 
 
    axis : int or str, default 0 
        If ``0`` or ``'index'``, roll across the rows. 
 
        If ``1`` or ``'columns'``, roll across the columns. 
 
    method : str {'single', 'table'}, default 'single' 
        Execute the rolling operation per single column or row (``'single'``) 
        or over the entire object (``'table'``). 
 
        This argument is only implemented when specifying ``engine='numba'`` 
        in the method call. 
 
        .. versionadded:: 1.3.0 
 
    Returns 
    ------- 
    ``Expanding`` subclass 
 
    See Also 
    -------- 
    rolling : Provides rolling window calculations. 
    ewm : Provides exponential weighted functions. 
 
    Notes 
    ----- 
    See :ref:`Windowing Operations &lt;window.expanding&gt;` for further usage details 
    and examples. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; df = pd.DataFrame({&quot;B&quot;: [0, 1, 2, np.nan, 4]}) 
    &gt;&gt;&gt; df 
         B 
    0  0.0 
    1  1.0 
    2  2.0 
    3  NaN 
    4  4.0 
 
    **min_periods** 
 
    Expanding sum with 1 vs 3 observations needed to calculate a value. 
 
    &gt;&gt;&gt; df.expanding(1).sum() 
         B 
    0  0.0 
    1  1.0 
    2  3.0 
    3  3.0 
    4  7.0 
    &gt;&gt;&gt; df.expanding(3).sum() 
         B 
    0  NaN 
    1  NaN 
    2  3.0 
    3  3.0 
    4  7.0 
    &quot;&quot;&quot;</span>

    <span class="s1">_attributes: list[str] = [</span><span class="s3">&quot;min_periods&quot;</span><span class="s0">, </span><span class="s3">&quot;center&quot;</span><span class="s0">, </span><span class="s3">&quot;axis&quot;</span><span class="s0">, </span><span class="s3">&quot;method&quot;</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">obj: NDFrame</span><span class="s0">,</span>
        <span class="s1">min_periods: int = </span><span class="s4">1</span><span class="s0">,</span>
        <span class="s1">center=</span><span class="s0">None,</span>
        <span class="s1">axis: Axis = </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s1">method: str = </span><span class="s3">&quot;single&quot;</span><span class="s0">,</span>
        <span class="s1">selection=</span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">obj=obj</span><span class="s0">,</span>
            <span class="s1">min_periods=min_periods</span><span class="s0">,</span>
            <span class="s1">center=center</span><span class="s0">,</span>
            <span class="s1">axis=axis</span><span class="s0">,</span>
            <span class="s1">method=method</span><span class="s0">,</span>
            <span class="s1">selection=selection</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_get_window_indexer(self) -&gt; BaseIndexer:</span>
        <span class="s2">&quot;&quot;&quot; 
        Return an indexer class that will compute the window start and end bounds 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">ExpandingIndexer()</span>

    <span class="s1">@doc(</span>
        <span class="s1">_shared_docs[</span><span class="s3">&quot;aggregate&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">see_also=dedent(</span>
            <span class="s3">&quot;&quot;&quot; 
        See Also 
        -------- 
        pandas.DataFrame.aggregate : Similar DataFrame method. 
        pandas.Series.aggregate : Similar Series method. 
        &quot;&quot;&quot;</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">examples=dedent(</span>
            <span class="s3">&quot;&quot;&quot; 
        Examples 
        -------- 
        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, 2, 3], &quot;B&quot;: [4, 5, 6], &quot;C&quot;: [7, 8, 9]}) 
        &gt;&gt;&gt; df 
           A  B  C 
        0  1  4  7 
        1  2  5  8 
        2  3  6  9 
 
        &gt;&gt;&gt; df.ewm(alpha=0.5).mean() 
                  A         B         C 
        0  1.000000  4.000000  7.000000 
        1  1.666667  4.666667  7.666667 
        2  2.428571  5.428571  8.428571 
        &quot;&quot;&quot;</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">klass=</span><span class="s3">&quot;Series/Dataframe&quot;</span><span class="s0">,</span>
        <span class="s1">axis=</span><span class="s3">&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">aggregate(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">super().aggregate(func</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s1">agg = aggregate</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Returns&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_returns</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;See Also&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_see_also[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">window_method=</span><span class="s3">&quot;expanding&quot;</span><span class="s0">,</span>
        <span class="s1">aggregation_description=</span><span class="s3">&quot;count of non NaN observations&quot;</span><span class="s0">,</span>
        <span class="s1">agg_method=</span><span class="s3">&quot;count&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">count(self):</span>
        <span class="s0">return </span><span class="s1">super().count()</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">window_apply_parameters</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Returns&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_returns</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;See Also&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_see_also[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">window_method=</span><span class="s3">&quot;expanding&quot;</span><span class="s0">,</span>
        <span class="s1">aggregation_description=</span><span class="s3">&quot;custom aggregation function&quot;</span><span class="s0">,</span>
        <span class="s1">agg_method=</span><span class="s3">&quot;apply&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">apply(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">func: Callable[...</span><span class="s0">, </span><span class="s1">Any]</span><span class="s0">,</span>
        <span class="s1">raw: bool = </span><span class="s0">False,</span>
        <span class="s1">engine: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s0">, </span><span class="s1">bool] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">args: tuple[Any</span><span class="s0">, </span><span class="s1">...] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">kwargs: dict[str</span><span class="s0">, </span><span class="s1">Any] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s0">return </span><span class="s1">super().apply(</span>
            <span class="s1">func</span><span class="s0">,</span>
            <span class="s1">raw=raw</span><span class="s0">,</span>
            <span class="s1">engine=engine</span><span class="s0">,</span>
            <span class="s1">engine_kwargs=engine_kwargs</span><span class="s0">,</span>
            <span class="s1">args=args</span><span class="s0">,</span>
            <span class="s1">kwargs=kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">args_compat</span><span class="s0">,</span>
        <span class="s1">window_agg_numba_parameters()</span><span class="s0">,</span>
        <span class="s1">kwargs_compat</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Returns&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_returns</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;See Also&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_see_also</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Notes&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">numba_notes[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">window_method=</span><span class="s3">&quot;expanding&quot;</span><span class="s0">,</span>
        <span class="s1">aggregation_description=</span><span class="s3">&quot;sum&quot;</span><span class="s0">,</span>
        <span class="s1">agg_method=</span><span class="s3">&quot;sum&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">sum(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">*args</span><span class="s0">,</span>
        <span class="s1">engine: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s0">, </span><span class="s1">bool] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_expanding_func(</span><span class="s3">&quot;sum&quot;</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s0">return </span><span class="s1">super().sum(*args</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">engine_kwargs=engine_kwargs</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">args_compat</span><span class="s0">,</span>
        <span class="s1">window_agg_numba_parameters()</span><span class="s0">,</span>
        <span class="s1">kwargs_compat</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Returns&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_returns</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;See Also&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_see_also</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Notes&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">numba_notes[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">window_method=</span><span class="s3">&quot;expanding&quot;</span><span class="s0">,</span>
        <span class="s1">aggregation_description=</span><span class="s3">&quot;maximum&quot;</span><span class="s0">,</span>
        <span class="s1">agg_method=</span><span class="s3">&quot;max&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">max(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">*args</span><span class="s0">,</span>
        <span class="s1">engine: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s0">, </span><span class="s1">bool] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_expanding_func(</span><span class="s3">&quot;max&quot;</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s0">return </span><span class="s1">super().max(*args</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">engine_kwargs=engine_kwargs</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">args_compat</span><span class="s0">,</span>
        <span class="s1">window_agg_numba_parameters()</span><span class="s0">,</span>
        <span class="s1">kwargs_compat</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Returns&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_returns</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;See Also&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_see_also</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Notes&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">numba_notes[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">window_method=</span><span class="s3">&quot;expanding&quot;</span><span class="s0">,</span>
        <span class="s1">aggregation_description=</span><span class="s3">&quot;minimum&quot;</span><span class="s0">,</span>
        <span class="s1">agg_method=</span><span class="s3">&quot;min&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">min(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">*args</span><span class="s0">,</span>
        <span class="s1">engine: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s0">, </span><span class="s1">bool] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_expanding_func(</span><span class="s3">&quot;min&quot;</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s0">return </span><span class="s1">super().min(*args</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">engine_kwargs=engine_kwargs</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">args_compat</span><span class="s0">,</span>
        <span class="s1">window_agg_numba_parameters()</span><span class="s0">,</span>
        <span class="s1">kwargs_compat</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Returns&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_returns</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;See Also&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_see_also</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Notes&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">numba_notes[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">window_method=</span><span class="s3">&quot;expanding&quot;</span><span class="s0">,</span>
        <span class="s1">aggregation_description=</span><span class="s3">&quot;mean&quot;</span><span class="s0">,</span>
        <span class="s1">agg_method=</span><span class="s3">&quot;mean&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">mean(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">*args</span><span class="s0">,</span>
        <span class="s1">engine: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s0">, </span><span class="s1">bool] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_expanding_func(</span><span class="s3">&quot;mean&quot;</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s0">return </span><span class="s1">super().mean(*args</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">engine_kwargs=engine_kwargs</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">window_agg_numba_parameters()</span><span class="s0">,</span>
        <span class="s1">kwargs_compat</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Returns&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_returns</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;See Also&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_see_also</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Notes&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">numba_notes[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">window_method=</span><span class="s3">&quot;expanding&quot;</span><span class="s0">,</span>
        <span class="s1">aggregation_description=</span><span class="s3">&quot;median&quot;</span><span class="s0">,</span>
        <span class="s1">agg_method=</span><span class="s3">&quot;median&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">median(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">engine: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s0">, </span><span class="s1">bool] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s0">return </span><span class="s1">super().median(engine=engine</span><span class="s0">, </span><span class="s1">engine_kwargs=engine_kwargs</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dedent(</span>
            <span class="s3">&quot;&quot;&quot; 
        ddof : int, default 1 
            Delta Degrees of Freedom.  The divisor used in calculations 
            is ``N - ddof``, where ``N`` represents the number of elements.</span><span class="s0">\n</span>
        <span class="s3">&quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">args_compat</span><span class="s0">,</span>
        <span class="s1">window_agg_numba_parameters(</span><span class="s3">&quot;1.4&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">kwargs_compat</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Returns&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_returns</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;See Also&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s3">&quot;numpy.std : Equivalent method for NumPy array.</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">,</span>
        <span class="s1">template_see_also</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Notes&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dedent(</span>
            <span class="s3">&quot;&quot;&quot; 
        The default ``ddof`` of 1 used in :meth:`Series.std` is different 
        than the default ``ddof`` of 0 in :func:`numpy.std`. 
 
        A minimum of one period is required for the rolling calculation.</span><span class="s0">\n</span>
        <span class="s3">&quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Examples&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dedent(</span>
            <span class="s3">&quot;&quot;&quot; 
        &gt;&gt;&gt; s = pd.Series([5, 5, 6, 7, 5, 5, 5]) 
 
        &gt;&gt;&gt; s.expanding(3).std() 
        0         NaN 
        1         NaN 
        2    0.577350 
        3    0.957427 
        4    0.894427 
        5    0.836660 
        6    0.786796 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">window_method=</span><span class="s3">&quot;expanding&quot;</span><span class="s0">,</span>
        <span class="s1">aggregation_description=</span><span class="s3">&quot;standard deviation&quot;</span><span class="s0">,</span>
        <span class="s1">agg_method=</span><span class="s3">&quot;std&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">std(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">ddof: int = </span><span class="s4">1</span><span class="s0">,</span>
        <span class="s1">*args</span><span class="s0">,</span>
        <span class="s1">engine: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s0">, </span><span class="s1">bool] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_expanding_func(</span><span class="s3">&quot;std&quot;</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s0">return </span><span class="s1">super().std(</span>
            <span class="s1">ddof=ddof</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">engine_kwargs=engine_kwargs</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dedent(</span>
            <span class="s3">&quot;&quot;&quot; 
        ddof : int, default 1 
            Delta Degrees of Freedom.  The divisor used in calculations 
            is ``N - ddof``, where ``N`` represents the number of elements.</span><span class="s0">\n</span>
        <span class="s3">&quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">args_compat</span><span class="s0">,</span>
        <span class="s1">window_agg_numba_parameters(</span><span class="s3">&quot;1.4&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">kwargs_compat</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Returns&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_returns</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;See Also&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s3">&quot;numpy.var : Equivalent method for NumPy array.</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">,</span>
        <span class="s1">template_see_also</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Notes&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dedent(</span>
            <span class="s3">&quot;&quot;&quot; 
        The default ``ddof`` of 1 used in :meth:`Series.var` is different 
        than the default ``ddof`` of 0 in :func:`numpy.var`. 
 
        A minimum of one period is required for the rolling calculation.</span><span class="s0">\n</span>
        <span class="s3">&quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Examples&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dedent(</span>
            <span class="s3">&quot;&quot;&quot; 
        &gt;&gt;&gt; s = pd.Series([5, 5, 6, 7, 5, 5, 5]) 
 
        &gt;&gt;&gt; s.expanding(3).var() 
        0         NaN 
        1         NaN 
        2    0.333333 
        3    0.916667 
        4    0.800000 
        5    0.700000 
        6    0.619048 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">window_method=</span><span class="s3">&quot;expanding&quot;</span><span class="s0">,</span>
        <span class="s1">aggregation_description=</span><span class="s3">&quot;variance&quot;</span><span class="s0">,</span>
        <span class="s1">agg_method=</span><span class="s3">&quot;var&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">var(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">ddof: int = </span><span class="s4">1</span><span class="s0">,</span>
        <span class="s1">*args</span><span class="s0">,</span>
        <span class="s1">engine: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s0">, </span><span class="s1">bool] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_expanding_func(</span><span class="s3">&quot;var&quot;</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s0">return </span><span class="s1">super().var(</span>
            <span class="s1">ddof=ddof</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">engine_kwargs=engine_kwargs</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dedent(</span>
            <span class="s3">&quot;&quot;&quot; 
        ddof : int, default 1 
            Delta Degrees of Freedom.  The divisor used in calculations 
            is ``N - ddof``, where ``N`` represents the number of elements.</span><span class="s0">\n</span>
        <span class="s3">&quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">args_compat</span><span class="s0">,</span>
        <span class="s1">kwargs_compat</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Returns&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_returns</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;See Also&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_see_also</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Notes&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s3">&quot;A minimum of one period is required for the calculation.</span><span class="s0">\n\n</span><span class="s3">&quot;</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Examples&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dedent(</span>
            <span class="s3">&quot;&quot;&quot; 
        &gt;&gt;&gt; s = pd.Series([0, 1, 2, 3]) 
 
        &gt;&gt;&gt; s.expanding().sem() 
        0         NaN 
        1    0.707107 
        2    0.707107 
        3    0.745356 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">window_method=</span><span class="s3">&quot;expanding&quot;</span><span class="s0">,</span>
        <span class="s1">aggregation_description=</span><span class="s3">&quot;standard error of mean&quot;</span><span class="s0">,</span>
        <span class="s1">agg_method=</span><span class="s3">&quot;sem&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">sem(self</span><span class="s0">, </span><span class="s1">ddof: int = </span><span class="s4">1</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">super().sem(ddof=ddof</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">kwargs_compat</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Returns&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_returns</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;See Also&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s3">&quot;scipy.stats.skew : Third moment of a probability density.</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">,</span>
        <span class="s1">template_see_also</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Notes&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s3">&quot;A minimum of three periods is required for the rolling calculation.</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">,</span>
        <span class="s1">window_method=</span><span class="s3">&quot;expanding&quot;</span><span class="s0">,</span>
        <span class="s1">aggregation_description=</span><span class="s3">&quot;unbiased skewness&quot;</span><span class="s0">,</span>
        <span class="s1">agg_method=</span><span class="s3">&quot;skew&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">skew(self</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">super().skew(**kwargs)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">kwargs_compat</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Returns&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_returns</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;See Also&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s3">&quot;scipy.stats.kurtosis : Reference SciPy method.</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">,</span>
        <span class="s1">template_see_also</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Notes&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s3">&quot;A minimum of four periods is required for the calculation.</span><span class="s0">\n\n</span><span class="s3">&quot;</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Examples&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dedent(</span>
            <span class="s3">&quot;&quot;&quot; 
        The example below will show a rolling calculation with a window size of 
        four matching the equivalent function call using `scipy.stats`. 
 
        &gt;&gt;&gt; arr = [1, 2, 3, 4, 999] 
        &gt;&gt;&gt; import scipy.stats 
        &gt;&gt;&gt; print(f&quot;{{scipy.stats.kurtosis(arr[:-1], bias=False):.6f}}&quot;) 
        -1.200000 
        &gt;&gt;&gt; print(f&quot;{{scipy.stats.kurtosis(arr, bias=False):.6f}}&quot;) 
        4.999874 
        &gt;&gt;&gt; s = pd.Series(arr) 
        &gt;&gt;&gt; s.expanding(4).kurt() 
        0         NaN 
        1         NaN 
        2         NaN 
        3   -1.200000 
        4    4.999874 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">window_method=</span><span class="s3">&quot;expanding&quot;</span><span class="s0">,</span>
        <span class="s1">aggregation_description=</span><span class="s3">&quot;Fisher's definition of kurtosis without bias&quot;</span><span class="s0">,</span>
        <span class="s1">agg_method=</span><span class="s3">&quot;kurt&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">kurt(self</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">super().kurt(**kwargs)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dedent(</span>
            <span class="s3">&quot;&quot;&quot; 
        quantile : float 
            Quantile to compute. 0 &lt;= quantile &lt;= 1. 
        interpolation : {{'linear', 'lower', 'higher', 'midpoint', 'nearest'}} 
            This optional parameter specifies the interpolation method to use, 
            when the desired quantile lies between two data points `i` and `j`: 
 
                * linear: `i + (j - i) * fraction`, where `fraction` is the 
                  fractional part of the index surrounded by `i` and `j`. 
                * lower: `i`. 
                * higher: `j`. 
                * nearest: `i` or `j` whichever is nearest. 
                * midpoint: (`i` + `j`) / 2. 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">kwargs_compat</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Returns&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_returns</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;See Also&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_see_also[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">window_method=</span><span class="s3">&quot;expanding&quot;</span><span class="s0">,</span>
        <span class="s1">aggregation_description=</span><span class="s3">&quot;quantile&quot;</span><span class="s0">,</span>
        <span class="s1">agg_method=</span><span class="s3">&quot;quantile&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">quantile(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">quantile: float</span><span class="s0">,</span>
        <span class="s1">interpolation: str = </span><span class="s3">&quot;linear&quot;</span><span class="s0">,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s0">return </span><span class="s1">super().quantile(</span>
            <span class="s1">quantile=quantile</span><span class="s0">,</span>
            <span class="s1">interpolation=interpolation</span><span class="s0">,</span>
            <span class="s1">**kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s0">,</span>
        <span class="s3">&quot;.. versionadded:: 1.4.0 </span><span class="s0">\n\n</span><span class="s3">&quot;</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dedent(</span>
            <span class="s3">&quot;&quot;&quot; 
        method : {{'average', 'min', 'max'}}, default 'average' 
            How to rank the group of records that have the same value (i.e. ties): 
 
            * average: average rank of the group 
            * min: lowest rank in the group 
            * max: highest rank in the group 
 
        ascending : bool, default True 
            Whether or not the elements should be ranked in ascending order. 
        pct : bool, default False 
            Whether or not to display the returned rankings in percentile 
            form. 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">kwargs_compat</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Returns&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_returns</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;See Also&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_see_also</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Examples&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dedent(</span>
            <span class="s3">&quot;&quot;&quot; 
        &gt;&gt;&gt; s = pd.Series([1, 4, 2, 3, 5, 3]) 
        &gt;&gt;&gt; s.expanding().rank() 
        0    1.0 
        1    2.0 
        2    2.0 
        3    3.0 
        4    5.0 
        5    3.5 
        dtype: float64 
 
        &gt;&gt;&gt; s.expanding().rank(method=&quot;max&quot;) 
        0    1.0 
        1    2.0 
        2    2.0 
        3    3.0 
        4    5.0 
        5    4.0 
        dtype: float64 
 
        &gt;&gt;&gt; s.expanding().rank(method=&quot;min&quot;) 
        0    1.0 
        1    2.0 
        2    2.0 
        3    3.0 
        4    5.0 
        5    3.0 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">window_method=</span><span class="s3">&quot;expanding&quot;</span><span class="s0">,</span>
        <span class="s1">aggregation_description=</span><span class="s3">&quot;rank&quot;</span><span class="s0">,</span>
        <span class="s1">agg_method=</span><span class="s3">&quot;rank&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">rank(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">method: WindowingRankType = </span><span class="s3">&quot;average&quot;</span><span class="s0">,</span>
        <span class="s1">ascending: bool = </span><span class="s0">True,</span>
        <span class="s1">pct: bool = </span><span class="s0">False,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s0">return </span><span class="s1">super().rank(</span>
            <span class="s1">method=method</span><span class="s0">,</span>
            <span class="s1">ascending=ascending</span><span class="s0">,</span>
            <span class="s1">pct=pct</span><span class="s0">,</span>
            <span class="s1">**kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dedent(</span>
            <span class="s3">&quot;&quot;&quot; 
        other : Series or DataFrame, optional 
            If not supplied then will default to self and produce pairwise 
            output. 
        pairwise : bool, default None 
            If False then only matching columns between self and other will be 
            used and the output will be a DataFrame. 
            If True then all pairwise combinations will be calculated and the 
            output will be a MultiIndexed DataFrame in the case of DataFrame 
            inputs. In the case of missing elements, only complete pairwise 
            observations will be used. 
        ddof : int, default 1 
            Delta Degrees of Freedom.  The divisor used in calculations 
            is ``N - ddof``, where ``N`` represents the number of elements. 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">kwargs_compat</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Returns&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_returns</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;See Also&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_see_also[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">window_method=</span><span class="s3">&quot;expanding&quot;</span><span class="s0">,</span>
        <span class="s1">aggregation_description=</span><span class="s3">&quot;sample covariance&quot;</span><span class="s0">,</span>
        <span class="s1">agg_method=</span><span class="s3">&quot;cov&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">cov(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">other: DataFrame | Series | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">pairwise: bool | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">ddof: int = </span><span class="s4">1</span><span class="s0">,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s0">return </span><span class="s1">super().cov(other=other</span><span class="s0">, </span><span class="s1">pairwise=pairwise</span><span class="s0">, </span><span class="s1">ddof=ddof</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dedent(</span>
            <span class="s3">&quot;&quot;&quot; 
        other : Series or DataFrame, optional 
            If not supplied then will default to self and produce pairwise 
            output. 
        pairwise : bool, default None 
            If False then only matching columns between self and other will be 
            used and the output will be a DataFrame. 
            If True then all pairwise combinations will be calculated and the 
            output will be a MultiIndexed DataFrame in the case of DataFrame 
            inputs. In the case of missing elements, only complete pairwise 
            observations will be used. 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">kwargs_compat</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Returns&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_returns</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;See Also&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dedent(</span>
            <span class="s3">&quot;&quot;&quot; 
        cov : Similar method to calculate covariance. 
        numpy.corrcoef : NumPy Pearson's correlation calculation. 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">template_see_also</span><span class="s0">,</span>
        <span class="s1">create_section_header(</span><span class="s3">&quot;Notes&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dedent(</span>
            <span class="s3">&quot;&quot;&quot; 
        This function uses Pearson's definition of correlation 
        (https://en.wikipedia.org/wiki/Pearson_correlation_coefficient). 
 
        When `other` is not specified, the output will be self correlation (e.g. 
        all 1's), except for :class:`~pandas.DataFrame` inputs with `pairwise` 
        set to `True`. 
 
        Function will return ``NaN`` for correlations of equal valued sequences; 
        this is the result of a 0/0 division error. 
 
        When `pairwise` is set to `False`, only matching columns between `self` and 
        `other` will be used. 
 
        When `pairwise` is set to `True`, the output will be a MultiIndex DataFrame 
        with the original index on the first level, and the `other` DataFrame 
        columns on the second level. 
 
        In the case of missing elements, only complete pairwise observations 
        will be used. 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">window_method=</span><span class="s3">&quot;expanding&quot;</span><span class="s0">,</span>
        <span class="s1">aggregation_description=</span><span class="s3">&quot;correlation&quot;</span><span class="s0">,</span>
        <span class="s1">agg_method=</span><span class="s3">&quot;corr&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">corr(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">other: DataFrame | Series | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">pairwise: bool | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">ddof: int = </span><span class="s4">1</span><span class="s0">,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s0">return </span><span class="s1">super().corr(other=other</span><span class="s0">, </span><span class="s1">pairwise=pairwise</span><span class="s0">, </span><span class="s1">ddof=ddof</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s0">class </span><span class="s1">ExpandingGroupby(BaseWindowGroupby</span><span class="s0">, </span><span class="s1">Expanding):</span>
    <span class="s2">&quot;&quot;&quot; 
    Provide a expanding groupby implementation. 
    &quot;&quot;&quot;</span>

    <span class="s1">_attributes = Expanding._attributes + BaseWindowGroupby._attributes</span>

    <span class="s0">def </span><span class="s1">_get_window_indexer(self) -&gt; GroupbyIndexer:</span>
        <span class="s2">&quot;&quot;&quot; 
        Return an indexer class that will compute the window start and end bounds 
 
        Returns 
        ------- 
        GroupbyIndexer 
        &quot;&quot;&quot;</span>
        <span class="s1">window_indexer = GroupbyIndexer(</span>
            <span class="s1">groupby_indices=self._grouper.indices</span><span class="s0">,</span>
            <span class="s1">window_indexer=ExpandingIndexer</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">window_indexer</span>
</pre>
</body>
</html>