<html>
<head>
<title>setup_common.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
setup_common.py</font>
</center></td></tr></table>
<pre><span class="s0"># Code common to build tools</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">import </span><span class="s1">textwrap</span>

<span class="s2">from </span><span class="s1">numpy.distutils.misc_util </span><span class="s2">import </span><span class="s1">mingw32</span>


<span class="s0">#-------------------</span>
<span class="s0"># Versioning support</span>
<span class="s0">#-------------------</span>
<span class="s0"># How to change C_API_VERSION ?</span>
<span class="s0">#   - increase C_API_VERSION value</span>
<span class="s0">#   - record the hash for the new C API with the cversions.py script</span>
<span class="s0">#   and add the hash to cversions.txt</span>
<span class="s0"># The hash values are used to remind developers when the C API number was not</span>
<span class="s0"># updated - generates a MismatchCAPIWarning warning which is turned into an</span>
<span class="s0"># exception for released version.</span>

<span class="s0"># Binary compatibility version number. This number is increased whenever the</span>
<span class="s0"># C-API is changed such that binary compatibility is broken, i.e. whenever a</span>
<span class="s0"># recompile of extension modules is needed.</span>
<span class="s1">C_ABI_VERSION = </span><span class="s3">0x01000009</span>

<span class="s0"># Minor API version.  This number is increased whenever a change is made to the</span>
<span class="s0"># C-API -- whether it breaks binary compatibility or not.  Some changes, such</span>
<span class="s0"># as adding a function pointer to the end of the function table, can be made</span>
<span class="s0"># without breaking binary compatibility.  In this case, only the C_API_VERSION</span>
<span class="s0"># (*not* C_ABI_VERSION) would be increased.  Whenever binary compatibility is</span>
<span class="s0"># broken, both C_API_VERSION and C_ABI_VERSION should be increased.</span>
<span class="s0">#</span>
<span class="s0"># 0x00000008 - 1.7.x</span>
<span class="s0"># 0x00000009 - 1.8.x</span>
<span class="s0"># 0x00000009 - 1.9.x</span>
<span class="s0"># 0x0000000a - 1.10.x</span>
<span class="s0"># 0x0000000a - 1.11.x</span>
<span class="s0"># 0x0000000a - 1.12.x</span>
<span class="s0"># 0x0000000b - 1.13.x</span>
<span class="s0"># 0x0000000c - 1.14.x</span>
<span class="s0"># 0x0000000c - 1.15.x</span>
<span class="s0"># 0x0000000d - 1.16.x</span>
<span class="s0"># 0x0000000d - 1.19.x</span>
<span class="s0"># 0x0000000e - 1.20.x</span>
<span class="s0"># 0x0000000e - 1.21.x</span>
<span class="s0"># 0x0000000f - 1.22.x</span>
<span class="s1">C_API_VERSION = </span><span class="s3">0x0000000f</span>

<span class="s2">class </span><span class="s1">MismatchCAPIWarning(Warning):</span>
    <span class="s2">pass</span>

<span class="s2">def </span><span class="s1">is_released(config):</span>
    <span class="s4">&quot;&quot;&quot;Return True if a released version of numpy is detected.&quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">distutils.version </span><span class="s2">import </span><span class="s1">LooseVersion</span>

    <span class="s1">v = config.get_version(</span><span class="s5">'../_version.py'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">v </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Could not get version&quot;</span><span class="s1">)</span>
    <span class="s1">pv = LooseVersion(vstring=v).version</span>
    <span class="s2">if </span><span class="s1">len(pv) &gt; </span><span class="s3">3</span><span class="s1">:</span>
        <span class="s2">return False</span>
    <span class="s2">return True</span>

<span class="s2">def </span><span class="s1">get_api_versions(apiversion</span><span class="s2">, </span><span class="s1">codegen_dir):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return current C API checksum and the recorded checksum. 
 
    Return current C API checksum and the recorded checksum for the given 
    version of the C API version. 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># Compute the hash of the current API as defined in the .txt files in</span>
    <span class="s0"># code_generators</span>
    <span class="s1">sys.path.insert(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">codegen_dir)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">m = __import__(</span><span class="s5">'genapi'</span><span class="s1">)</span>
        <span class="s1">numpy_api = __import__(</span><span class="s5">'numpy_api'</span><span class="s1">)</span>
        <span class="s1">curapi_hash = m.fullapi_hash(numpy_api.full_api)</span>
        <span class="s1">apis_hash = m.get_versions_hash()</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s2">del </span><span class="s1">sys.path[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s2">return </span><span class="s1">curapi_hash</span><span class="s2">, </span><span class="s1">apis_hash[apiversion]</span>

<span class="s2">def </span><span class="s1">check_api_version(apiversion</span><span class="s2">, </span><span class="s1">codegen_dir):</span>
    <span class="s4">&quot;&quot;&quot;Emits a MismatchCAPIWarning if the C API version needs updating.&quot;&quot;&quot;</span>
    <span class="s1">curapi_hash</span><span class="s2">, </span><span class="s1">api_hash = get_api_versions(apiversion</span><span class="s2">, </span><span class="s1">codegen_dir)</span>

    <span class="s0"># If different hash, it means that the api .txt files in</span>
    <span class="s0"># codegen_dir have been updated without the API version being</span>
    <span class="s0"># updated. Any modification in those .txt files should be reflected</span>
    <span class="s0"># in the api and eventually abi versions.</span>
    <span class="s0"># To compute the checksum of the current API, use numpy/core/cversions.py</span>
    <span class="s2">if not </span><span class="s1">curapi_hash == api_hash:</span>
        <span class="s1">msg = (</span><span class="s5">&quot;API mismatch detected, the C API version &quot;</span>
               <span class="s5">&quot;numbers have to be updated. Current C api version is %d, &quot;</span>
               <span class="s5">&quot;with checksum %s, but recorded checksum for C API version %d &quot;</span>
               <span class="s5">&quot;in core/codegen_dir/cversions.txt is %s. If functions were &quot;</span>
               <span class="s5">&quot;added in the C API, you have to update C_API_VERSION in %s.&quot;</span>
               <span class="s1">)</span>
        <span class="s1">warnings.warn(msg % (apiversion</span><span class="s2">, </span><span class="s1">curapi_hash</span><span class="s2">, </span><span class="s1">apiversion</span><span class="s2">, </span><span class="s1">api_hash</span><span class="s2">,</span>
                             <span class="s1">__file__)</span><span class="s2">,</span>
                      <span class="s1">MismatchCAPIWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s3">2</span><span class="s1">)</span>
<span class="s0"># Mandatory functions: if not found, fail the build</span>
<span class="s1">MANDATORY_FUNCS = [</span><span class="s5">&quot;sin&quot;</span><span class="s2">, </span><span class="s5">&quot;cos&quot;</span><span class="s2">, </span><span class="s5">&quot;tan&quot;</span><span class="s2">, </span><span class="s5">&quot;sinh&quot;</span><span class="s2">, </span><span class="s5">&quot;cosh&quot;</span><span class="s2">, </span><span class="s5">&quot;tanh&quot;</span><span class="s2">, </span><span class="s5">&quot;fabs&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;floor&quot;</span><span class="s2">, </span><span class="s5">&quot;ceil&quot;</span><span class="s2">, </span><span class="s5">&quot;sqrt&quot;</span><span class="s2">, </span><span class="s5">&quot;log10&quot;</span><span class="s2">, </span><span class="s5">&quot;log&quot;</span><span class="s2">, </span><span class="s5">&quot;exp&quot;</span><span class="s2">, </span><span class="s5">&quot;asin&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;acos&quot;</span><span class="s2">, </span><span class="s5">&quot;atan&quot;</span><span class="s2">, </span><span class="s5">&quot;fmod&quot;</span><span class="s2">, </span><span class="s5">'modf'</span><span class="s2">, </span><span class="s5">'frexp'</span><span class="s2">, </span><span class="s5">'ldexp'</span><span class="s1">]</span>

<span class="s0"># Standard functions which may not be available and for which we have a</span>
<span class="s0"># replacement implementation. Note that some of these are C99 functions.</span>
<span class="s1">OPTIONAL_STDFUNCS = [</span><span class="s5">&quot;expm1&quot;</span><span class="s2">, </span><span class="s5">&quot;log1p&quot;</span><span class="s2">, </span><span class="s5">&quot;acosh&quot;</span><span class="s2">, </span><span class="s5">&quot;asinh&quot;</span><span class="s2">, </span><span class="s5">&quot;atanh&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;rint&quot;</span><span class="s2">, </span><span class="s5">&quot;trunc&quot;</span><span class="s2">, </span><span class="s5">&quot;exp2&quot;</span><span class="s2">, </span><span class="s5">&quot;log2&quot;</span><span class="s2">, </span><span class="s5">&quot;hypot&quot;</span><span class="s2">, </span><span class="s5">&quot;atan2&quot;</span><span class="s2">, </span><span class="s5">&quot;pow&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;copysign&quot;</span><span class="s2">, </span><span class="s5">&quot;nextafter&quot;</span><span class="s2">, </span><span class="s5">&quot;ftello&quot;</span><span class="s2">, </span><span class="s5">&quot;fseeko&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;strtoll&quot;</span><span class="s2">, </span><span class="s5">&quot;strtoull&quot;</span><span class="s2">, </span><span class="s5">&quot;cbrt&quot;</span><span class="s2">, </span><span class="s5">&quot;strtold_l&quot;</span><span class="s2">, </span><span class="s5">&quot;fallocate&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;backtrace&quot;</span><span class="s2">, </span><span class="s5">&quot;madvise&quot;</span><span class="s1">]</span>


<span class="s1">OPTIONAL_HEADERS = [</span>
<span class="s0"># sse headers only enabled automatically on amd64/x32 builds</span>
                <span class="s5">&quot;xmmintrin.h&quot;</span><span class="s2">,  </span><span class="s0"># SSE</span>
                <span class="s5">&quot;emmintrin.h&quot;</span><span class="s2">,  </span><span class="s0"># SSE2</span>
                <span class="s5">&quot;immintrin.h&quot;</span><span class="s2">,  </span><span class="s0"># AVX</span>
                <span class="s5">&quot;features.h&quot;</span><span class="s2">,  </span><span class="s0"># for glibc version linux</span>
                <span class="s5">&quot;xlocale.h&quot;</span><span class="s2">,  </span><span class="s0"># see GH#8367</span>
                <span class="s5">&quot;dlfcn.h&quot;</span><span class="s2">, </span><span class="s0"># dladdr</span>
                <span class="s5">&quot;sys/mman.h&quot;</span><span class="s2">, </span><span class="s0">#madvise</span>
<span class="s1">]</span>

<span class="s0"># optional gcc compiler builtins and their call arguments and optional a</span>
<span class="s0"># required header and definition name (HAVE_ prepended)</span>
<span class="s0"># call arguments are required as the compiler will do strict signature checking</span>
<span class="s1">OPTIONAL_INTRINSICS = [(</span><span class="s5">&quot;__builtin_isnan&quot;</span><span class="s2">, </span><span class="s5">'5.'</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">(</span><span class="s5">&quot;__builtin_isinf&quot;</span><span class="s2">, </span><span class="s5">'5.'</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">(</span><span class="s5">&quot;__builtin_isfinite&quot;</span><span class="s2">, </span><span class="s5">'5.'</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">(</span><span class="s5">&quot;__builtin_bswap32&quot;</span><span class="s2">, </span><span class="s5">'5u'</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">(</span><span class="s5">&quot;__builtin_bswap64&quot;</span><span class="s2">, </span><span class="s5">'5u'</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">(</span><span class="s5">&quot;__builtin_expect&quot;</span><span class="s2">, </span><span class="s5">'5, 0'</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">(</span><span class="s5">&quot;__builtin_mul_overflow&quot;</span><span class="s2">, </span><span class="s5">'5, 5, (int*)5'</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s0"># MMX only needed for icc, but some clangs don't have it</span>
                       <span class="s1">(</span><span class="s5">&quot;_m_from_int64&quot;</span><span class="s2">, </span><span class="s5">'0'</span><span class="s2">, </span><span class="s5">&quot;emmintrin.h&quot;</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">(</span><span class="s5">&quot;_mm_load_ps&quot;</span><span class="s2">, </span><span class="s5">'(float*)0'</span><span class="s2">, </span><span class="s5">&quot;xmmintrin.h&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># SSE</span>
                       <span class="s1">(</span><span class="s5">&quot;_mm_prefetch&quot;</span><span class="s2">, </span><span class="s5">'(float*)0, _MM_HINT_NTA'</span><span class="s2">,</span>
                        <span class="s5">&quot;xmmintrin.h&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># SSE</span>
                       <span class="s1">(</span><span class="s5">&quot;_mm_load_pd&quot;</span><span class="s2">, </span><span class="s5">'(double*)0'</span><span class="s2">, </span><span class="s5">&quot;emmintrin.h&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># SSE2</span>
                       <span class="s1">(</span><span class="s5">&quot;__builtin_prefetch&quot;</span><span class="s2">, </span><span class="s5">&quot;(float*)0, 0, 3&quot;</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s0"># check that the linker can handle avx</span>
                       <span class="s1">(</span><span class="s5">&quot;__asm__ volatile&quot;</span><span class="s2">, </span><span class="s5">'&quot;vpand %xmm1, %xmm2, %xmm3&quot;'</span><span class="s2">,</span>
                        <span class="s5">&quot;stdio.h&quot;</span><span class="s2">, </span><span class="s5">&quot;LINK_AVX&quot;</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">(</span><span class="s5">&quot;__asm__ volatile&quot;</span><span class="s2">, </span><span class="s5">'&quot;vpand %ymm1, %ymm2, %ymm3&quot;'</span><span class="s2">,</span>
                        <span class="s5">&quot;stdio.h&quot;</span><span class="s2">, </span><span class="s5">&quot;LINK_AVX2&quot;</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">(</span><span class="s5">&quot;__asm__ volatile&quot;</span><span class="s2">, </span><span class="s5">'&quot;vpaddd %zmm1, %zmm2, %zmm3&quot;'</span><span class="s2">,</span>
                        <span class="s5">&quot;stdio.h&quot;</span><span class="s2">, </span><span class="s5">&quot;LINK_AVX512F&quot;</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">(</span><span class="s5">&quot;__asm__ volatile&quot;</span><span class="s2">, </span><span class="s5">'&quot;vfpclasspd $0x40, %zmm15, %k6</span><span class="s2">\\</span><span class="s5">n&quot;</span><span class="s2">\ 
                                             </span><span class="s5">&quot;vmovdqu8 %xmm0, %xmm1</span><span class="s2">\\</span><span class="s5">n&quot;</span><span class="s2">\ 
                                             </span><span class="s5">&quot;vpbroadcastmb2q %k0, %xmm0</span><span class="s2">\\</span><span class="s5">n&quot;'</span><span class="s2">,</span>
                        <span class="s5">&quot;stdio.h&quot;</span><span class="s2">, </span><span class="s5">&quot;LINK_AVX512_SKX&quot;</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">(</span><span class="s5">&quot;__asm__ volatile&quot;</span><span class="s2">, </span><span class="s5">'&quot;xgetbv&quot;'</span><span class="s2">, </span><span class="s5">&quot;stdio.h&quot;</span><span class="s2">, </span><span class="s5">&quot;XGETBV&quot;</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">]</span>

<span class="s0"># function attributes</span>
<span class="s0"># tested via &quot;int %s %s(void *);&quot; % (attribute, name)</span>
<span class="s0"># function name will be converted to HAVE_&lt;upper-case-name&gt; preprocessor macro</span>
<span class="s1">OPTIONAL_FUNCTION_ATTRIBUTES = [(</span><span class="s5">'__attribute__((optimize(&quot;unroll-loops&quot;)))'</span><span class="s2">,</span>
                                <span class="s5">'attribute_optimize_unroll_loops'</span><span class="s1">)</span><span class="s2">,</span>
                                <span class="s1">(</span><span class="s5">'__attribute__((optimize(&quot;O3&quot;)))'</span><span class="s2">,</span>
                                 <span class="s5">'attribute_optimize_opt_3'</span><span class="s1">)</span><span class="s2">,</span>
                                <span class="s1">(</span><span class="s5">'__attribute__((nonnull (1)))'</span><span class="s2">,</span>
                                 <span class="s5">'attribute_nonnull'</span><span class="s1">)</span><span class="s2">,</span>
                                <span class="s1">(</span><span class="s5">'__attribute__((target (&quot;avx&quot;)))'</span><span class="s2">,</span>
                                 <span class="s5">'attribute_target_avx'</span><span class="s1">)</span><span class="s2">,</span>
                                <span class="s1">(</span><span class="s5">'__attribute__((target (&quot;avx2&quot;)))'</span><span class="s2">,</span>
                                 <span class="s5">'attribute_target_avx2'</span><span class="s1">)</span><span class="s2">,</span>
                                <span class="s1">(</span><span class="s5">'__attribute__((target (&quot;avx512f&quot;)))'</span><span class="s2">,</span>
                                 <span class="s5">'attribute_target_avx512f'</span><span class="s1">)</span><span class="s2">,</span>
                                <span class="s1">(</span><span class="s5">'__attribute__((target (&quot;avx512f,avx512dq,avx512bw,avx512vl,avx512cd&quot;)))'</span><span class="s2">,</span>
                                 <span class="s5">'attribute_target_avx512_skx'</span><span class="s1">)</span><span class="s2">,</span>
                                <span class="s1">]</span>

<span class="s0"># function attributes with intrinsics</span>
<span class="s0"># To ensure your compiler can compile avx intrinsics with just the attributes</span>
<span class="s0"># gcc 4.8.4 support attributes but not with intrisics</span>
<span class="s0"># tested via &quot;#include&lt;%s&gt; int %s %s(void *){code; return 0;};&quot; % (header, attribute, name, code)</span>
<span class="s0"># function name will be converted to HAVE_&lt;upper-case-name&gt; preprocessor macro</span>
<span class="s0"># The _mm512_castps_si512 instruction is specific check for AVX-512F support</span>
<span class="s0"># in gcc-4.9 which is missing a subset of intrinsics. See</span>
<span class="s0"># https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61878</span>
<span class="s1">OPTIONAL_FUNCTION_ATTRIBUTES_WITH_INTRINSICS = [(</span><span class="s5">'__attribute__((target(&quot;avx2,fma&quot;)))'</span><span class="s2">,</span>
                                <span class="s5">'attribute_target_avx2_with_intrinsics'</span><span class="s2">,</span>
                                <span class="s5">'__m256 temp = _mm256_set1_ps(1.0); temp = </span><span class="s2">\ 
                                </span><span class="s5">_mm256_fmadd_ps(temp, temp, temp)'</span><span class="s2">,</span>
                                <span class="s5">'immintrin.h'</span><span class="s1">)</span><span class="s2">,</span>
                                <span class="s1">(</span><span class="s5">'__attribute__((target(&quot;avx512f&quot;)))'</span><span class="s2">,</span>
                                <span class="s5">'attribute_target_avx512f_with_intrinsics'</span><span class="s2">,</span>
                                <span class="s5">'__m512i temp = _mm512_castps_si512(_mm512_set1_ps(1.0))'</span><span class="s2">,</span>
                                <span class="s5">'immintrin.h'</span><span class="s1">)</span><span class="s2">,</span>
                                <span class="s1">(</span><span class="s5">'__attribute__((target (&quot;avx512f,avx512dq,avx512bw,avx512vl,avx512cd&quot;)))'</span><span class="s2">,</span>
                                <span class="s5">'attribute_target_avx512_skx_with_intrinsics'</span><span class="s2">,</span>
                                <span class="s5">'__mmask8 temp = _mm512_fpclass_pd_mask(_mm512_set1_pd(1.0), 0x01);</span><span class="s2">\ 
                                </span><span class="s5">__m512i unused_temp = </span><span class="s2">\ 
                                    </span><span class="s5">_mm512_castps_si512(_mm512_set1_ps(1.0));</span><span class="s2">\ 
                                </span><span class="s5">_mm_mask_storeu_epi8(NULL, 0xFF, _mm_broadcastmb_epi64(temp))'</span><span class="s2">,</span>
                                <span class="s5">'immintrin.h'</span><span class="s1">)</span><span class="s2">,</span>
                                <span class="s1">]</span>

<span class="s0"># variable attributes tested via &quot;int %s a&quot; % attribute</span>
<span class="s1">OPTIONAL_VARIABLE_ATTRIBUTES = [</span><span class="s5">&quot;__thread&quot;</span><span class="s2">, </span><span class="s5">&quot;__declspec(thread)&quot;</span><span class="s1">]</span>

<span class="s0"># Subset of OPTIONAL_STDFUNCS which may already have HAVE_* defined by Python.h</span>
<span class="s1">OPTIONAL_STDFUNCS_MAYBE = [</span>
    <span class="s5">&quot;expm1&quot;</span><span class="s2">, </span><span class="s5">&quot;log1p&quot;</span><span class="s2">, </span><span class="s5">&quot;acosh&quot;</span><span class="s2">, </span><span class="s5">&quot;atanh&quot;</span><span class="s2">, </span><span class="s5">&quot;asinh&quot;</span><span class="s2">, </span><span class="s5">&quot;hypot&quot;</span><span class="s2">, </span><span class="s5">&quot;copysign&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;ftello&quot;</span><span class="s2">, </span><span class="s5">&quot;fseeko&quot;</span>
    <span class="s1">]</span>

<span class="s0"># C99 functions: float and long double versions</span>
<span class="s1">C99_FUNCS = [</span>
    <span class="s5">&quot;sin&quot;</span><span class="s2">, </span><span class="s5">&quot;cos&quot;</span><span class="s2">, </span><span class="s5">&quot;tan&quot;</span><span class="s2">, </span><span class="s5">&quot;sinh&quot;</span><span class="s2">, </span><span class="s5">&quot;cosh&quot;</span><span class="s2">, </span><span class="s5">&quot;tanh&quot;</span><span class="s2">, </span><span class="s5">&quot;fabs&quot;</span><span class="s2">, </span><span class="s5">&quot;floor&quot;</span><span class="s2">, </span><span class="s5">&quot;ceil&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;rint&quot;</span><span class="s2">, </span><span class="s5">&quot;trunc&quot;</span><span class="s2">, </span><span class="s5">&quot;sqrt&quot;</span><span class="s2">, </span><span class="s5">&quot;log10&quot;</span><span class="s2">, </span><span class="s5">&quot;log&quot;</span><span class="s2">, </span><span class="s5">&quot;log1p&quot;</span><span class="s2">, </span><span class="s5">&quot;exp&quot;</span><span class="s2">, </span><span class="s5">&quot;expm1&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;asin&quot;</span><span class="s2">, </span><span class="s5">&quot;acos&quot;</span><span class="s2">, </span><span class="s5">&quot;atan&quot;</span><span class="s2">, </span><span class="s5">&quot;asinh&quot;</span><span class="s2">, </span><span class="s5">&quot;acosh&quot;</span><span class="s2">, </span><span class="s5">&quot;atanh&quot;</span><span class="s2">, </span><span class="s5">&quot;hypot&quot;</span><span class="s2">, </span><span class="s5">&quot;atan2&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;pow&quot;</span><span class="s2">, </span><span class="s5">&quot;fmod&quot;</span><span class="s2">, </span><span class="s5">&quot;modf&quot;</span><span class="s2">, </span><span class="s5">'frexp'</span><span class="s2">, </span><span class="s5">'ldexp'</span><span class="s2">, </span><span class="s5">&quot;exp2&quot;</span><span class="s2">, </span><span class="s5">&quot;log2&quot;</span><span class="s2">, </span><span class="s5">&quot;copysign&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;nextafter&quot;</span><span class="s2">, </span><span class="s5">&quot;cbrt&quot;</span>
    <span class="s1">]</span>
<span class="s1">C99_FUNCS_SINGLE = [f + </span><span class="s5">'f' </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">C99_FUNCS]</span>
<span class="s1">C99_FUNCS_EXTENDED = [f + </span><span class="s5">'l' </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">C99_FUNCS]</span>
<span class="s1">C99_COMPLEX_TYPES = [</span>
    <span class="s5">'complex double'</span><span class="s2">, </span><span class="s5">'complex float'</span><span class="s2">, </span><span class="s5">'complex long double'</span>
    <span class="s1">]</span>
<span class="s1">C99_COMPLEX_FUNCS = [</span>
    <span class="s5">&quot;cabs&quot;</span><span class="s2">, </span><span class="s5">&quot;cacos&quot;</span><span class="s2">, </span><span class="s5">&quot;cacosh&quot;</span><span class="s2">, </span><span class="s5">&quot;carg&quot;</span><span class="s2">, </span><span class="s5">&quot;casin&quot;</span><span class="s2">, </span><span class="s5">&quot;casinh&quot;</span><span class="s2">, </span><span class="s5">&quot;catan&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;catanh&quot;</span><span class="s2">, </span><span class="s5">&quot;ccos&quot;</span><span class="s2">, </span><span class="s5">&quot;ccosh&quot;</span><span class="s2">, </span><span class="s5">&quot;cexp&quot;</span><span class="s2">, </span><span class="s5">&quot;cimag&quot;</span><span class="s2">, </span><span class="s5">&quot;clog&quot;</span><span class="s2">, </span><span class="s5">&quot;conj&quot;</span><span class="s2">, </span><span class="s5">&quot;cpow&quot;</span><span class="s2">,</span>
    <span class="s5">&quot;cproj&quot;</span><span class="s2">, </span><span class="s5">&quot;creal&quot;</span><span class="s2">, </span><span class="s5">&quot;csin&quot;</span><span class="s2">, </span><span class="s5">&quot;csinh&quot;</span><span class="s2">, </span><span class="s5">&quot;csqrt&quot;</span><span class="s2">, </span><span class="s5">&quot;ctan&quot;</span><span class="s2">, </span><span class="s5">&quot;ctanh&quot;</span>
    <span class="s1">]</span>

<span class="s2">def </span><span class="s1">fname2def(name):</span>
    <span class="s2">return </span><span class="s5">&quot;HAVE_%s&quot; </span><span class="s1">% name.upper()</span>

<span class="s2">def </span><span class="s1">sym2def(symbol):</span>
    <span class="s1">define = symbol.replace(</span><span class="s5">' '</span><span class="s2">, </span><span class="s5">''</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">define.upper()</span>

<span class="s2">def </span><span class="s1">type2def(symbol):</span>
    <span class="s1">define = symbol.replace(</span><span class="s5">' '</span><span class="s2">, </span><span class="s5">'_'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">define.upper()</span>

<span class="s0"># Code to detect long double representation taken from MPFR m4 macro</span>
<span class="s2">def </span><span class="s1">check_long_double_representation(cmd):</span>
    <span class="s1">cmd._check_compiler()</span>
    <span class="s1">body = LONG_DOUBLE_REPRESENTATION_SRC % {</span><span class="s5">'type'</span><span class="s1">: </span><span class="s5">'long double'</span><span class="s1">}</span>

    <span class="s0"># Disable whole program optimization (the default on vs2015, with python 3.5+)</span>
    <span class="s0"># which generates intermediary object files and prevents checking the</span>
    <span class="s0"># float representation.</span>
    <span class="s2">if </span><span class="s1">sys.platform == </span><span class="s5">&quot;win32&quot; </span><span class="s2">and not </span><span class="s1">mingw32():</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">cmd.compiler.compile_options.remove(</span><span class="s5">&quot;/GL&quot;</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">(AttributeError</span><span class="s2">, </span><span class="s1">ValueError):</span>
            <span class="s2">pass</span>

    <span class="s0"># Disable multi-file interprocedural optimization in the Intel compiler on Linux</span>
    <span class="s0"># which generates intermediary object files and prevents checking the</span>
    <span class="s0"># float representation.</span>
    <span class="s2">elif </span><span class="s1">(sys.platform != </span><span class="s5">&quot;win32&quot;</span>
            <span class="s2">and </span><span class="s1">cmd.compiler.compiler_type.startswith(</span><span class="s5">'intel'</span><span class="s1">)</span>
            <span class="s2">and </span><span class="s5">'-ipo' </span><span class="s2">in </span><span class="s1">cmd.compiler.cc_exe):</span>
        <span class="s1">newcompiler = cmd.compiler.cc_exe.replace(</span><span class="s5">' -ipo'</span><span class="s2">, </span><span class="s5">''</span><span class="s1">)</span>
        <span class="s1">cmd.compiler.set_executables(</span>
            <span class="s1">compiler=newcompiler</span><span class="s2">,</span>
            <span class="s1">compiler_so=newcompiler</span><span class="s2">,</span>
            <span class="s1">compiler_cxx=newcompiler</span><span class="s2">,</span>
            <span class="s1">linker_exe=newcompiler</span><span class="s2">,</span>
            <span class="s1">linker_so=newcompiler + </span><span class="s5">' -shared'</span>
        <span class="s1">)</span>

    <span class="s0"># We need to use _compile because we need the object filename</span>
    <span class="s1">src</span><span class="s2">, </span><span class="s1">obj = cmd._compile(body</span><span class="s2">, None, None, </span><span class="s5">'c'</span><span class="s1">)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">ltype = long_double_representation(pyod(obj))</span>
        <span class="s2">return </span><span class="s1">ltype</span>
    <span class="s2">except </span><span class="s1">ValueError:</span>
        <span class="s0"># try linking to support CC=&quot;gcc -flto&quot; or icc -ipo</span>
        <span class="s0"># struct needs to be volatile so it isn't optimized away</span>
        <span class="s0"># additionally &quot;clang -flto&quot; requires the foo struct to be used</span>
        <span class="s1">body = body.replace(</span><span class="s5">'struct'</span><span class="s2">, </span><span class="s5">'volatile struct'</span><span class="s1">)</span>
        <span class="s1">body += </span><span class="s5">&quot;int main(void) { return foo.before[0]; }</span><span class="s2">\n</span><span class="s5">&quot;</span>
        <span class="s1">src</span><span class="s2">, </span><span class="s1">obj = cmd._compile(body</span><span class="s2">, None, None, </span><span class="s5">'c'</span><span class="s1">)</span>
        <span class="s1">cmd.temp_files.append(</span><span class="s5">&quot;_configtest&quot;</span><span class="s1">)</span>
        <span class="s1">cmd.compiler.link_executable([obj]</span><span class="s2">, </span><span class="s5">&quot;_configtest&quot;</span><span class="s1">)</span>
        <span class="s1">ltype = long_double_representation(pyod(</span><span class="s5">&quot;_configtest&quot;</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">ltype</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">cmd._clean()</span>

<span class="s1">LONG_DOUBLE_REPRESENTATION_SRC = </span><span class="s5">r&quot;&quot;&quot; 
/* &quot;before&quot; is 16 bytes to ensure there's no padding between it and &quot;x&quot;. 
 *    We're not expecting any &quot;long double&quot; bigger than 16 bytes or with 
 *       alignment requirements stricter than 16 bytes.  */ 
typedef %(type)s test_type; 
 
struct { 
        char         before[16]; 
        test_type    x; 
        char         after[8]; 
} foo = { 
        { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', 
          '\001', '\043', '\105', '\147', '\211', '\253', '\315', '\357' }, 
        -123456789.0, 
        { '\376', '\334', '\272', '\230', '\166', '\124', '\062', '\020' } 
}; 
&quot;&quot;&quot;</span>

<span class="s2">def </span><span class="s1">pyod(filename):</span>
    <span class="s4">&quot;&quot;&quot;Python implementation of the od UNIX utility (od -b, more exactly). 
 
    Parameters 
    ---------- 
    filename : str 
        name of the file to get the dump from. 
 
    Returns 
    ------- 
    out : seq 
        list of lines of od output 
 
    Notes 
    ----- 
    We only implement enough to get the necessary information for long double 
    representation, this is not intended as a compatible replacement for od. 
    &quot;&quot;&quot;</span>
    <span class="s1">out = []</span>
    <span class="s2">with </span><span class="s1">open(filename</span><span class="s2">, </span><span class="s5">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fid:</span>
        <span class="s1">yo2 = [oct(o)[</span><span class="s3">2</span><span class="s1">:] </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">fid.read()]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">len(yo2)</span><span class="s2">, </span><span class="s3">16</span><span class="s1">):</span>
        <span class="s1">line = [</span><span class="s5">'%07d' </span><span class="s1">% int(oct(i)[</span><span class="s3">2</span><span class="s1">:])]</span>
        <span class="s1">line.extend([</span><span class="s5">'%03d' </span><span class="s1">% int(c) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">yo2[i:i+</span><span class="s3">16</span><span class="s1">]])</span>
        <span class="s1">out.append(</span><span class="s5">&quot; &quot;</span><span class="s1">.join(line))</span>
    <span class="s2">return </span><span class="s1">out</span>


<span class="s1">_BEFORE_SEQ = [</span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">,</span>
              <span class="s5">'001'</span><span class="s2">, </span><span class="s5">'043'</span><span class="s2">, </span><span class="s5">'105'</span><span class="s2">, </span><span class="s5">'147'</span><span class="s2">, </span><span class="s5">'211'</span><span class="s2">, </span><span class="s5">'253'</span><span class="s2">, </span><span class="s5">'315'</span><span class="s2">, </span><span class="s5">'357'</span><span class="s1">]</span>
<span class="s1">_AFTER_SEQ = [</span><span class="s5">'376'</span><span class="s2">, </span><span class="s5">'334'</span><span class="s2">, </span><span class="s5">'272'</span><span class="s2">, </span><span class="s5">'230'</span><span class="s2">, </span><span class="s5">'166'</span><span class="s2">, </span><span class="s5">'124'</span><span class="s2">, </span><span class="s5">'062'</span><span class="s2">, </span><span class="s5">'020'</span><span class="s1">]</span>

<span class="s1">_IEEE_DOUBLE_BE = [</span><span class="s5">'301'</span><span class="s2">, </span><span class="s5">'235'</span><span class="s2">, </span><span class="s5">'157'</span><span class="s2">, </span><span class="s5">'064'</span><span class="s2">, </span><span class="s5">'124'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s1">]</span>
<span class="s1">_IEEE_DOUBLE_LE = _IEEE_DOUBLE_BE[::-</span><span class="s3">1</span><span class="s1">]</span>
<span class="s1">_INTEL_EXTENDED_12B = [</span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'240'</span><span class="s2">, </span><span class="s5">'242'</span><span class="s2">, </span><span class="s5">'171'</span><span class="s2">, </span><span class="s5">'353'</span><span class="s2">,</span>
                       <span class="s5">'031'</span><span class="s2">, </span><span class="s5">'300'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s1">]</span>
<span class="s1">_INTEL_EXTENDED_16B = [</span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'240'</span><span class="s2">, </span><span class="s5">'242'</span><span class="s2">, </span><span class="s5">'171'</span><span class="s2">, </span><span class="s5">'353'</span><span class="s2">,</span>
                       <span class="s5">'031'</span><span class="s2">, </span><span class="s5">'300'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s1">]</span>
<span class="s1">_MOTOROLA_EXTENDED_12B = [</span><span class="s5">'300'</span><span class="s2">, </span><span class="s5">'031'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'353'</span><span class="s2">, </span><span class="s5">'171'</span><span class="s2">,</span>
                          <span class="s5">'242'</span><span class="s2">, </span><span class="s5">'240'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s1">]</span>
<span class="s1">_IEEE_QUAD_PREC_BE = [</span><span class="s5">'300'</span><span class="s2">, </span><span class="s5">'031'</span><span class="s2">, </span><span class="s5">'326'</span><span class="s2">, </span><span class="s5">'363'</span><span class="s2">, </span><span class="s5">'105'</span><span class="s2">, </span><span class="s5">'100'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">,</span>
                      <span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s1">]</span>
<span class="s1">_IEEE_QUAD_PREC_LE = _IEEE_QUAD_PREC_BE[::-</span><span class="s3">1</span><span class="s1">]</span>
<span class="s1">_IBM_DOUBLE_DOUBLE_BE = ([</span><span class="s5">'301'</span><span class="s2">, </span><span class="s5">'235'</span><span class="s2">, </span><span class="s5">'157'</span><span class="s2">, </span><span class="s5">'064'</span><span class="s2">, </span><span class="s5">'124'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s1">] +</span>
                     <span class="s1">[</span><span class="s5">'000'</span><span class="s1">] * </span><span class="s3">8</span><span class="s1">)</span>
<span class="s1">_IBM_DOUBLE_DOUBLE_LE = ([</span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'000'</span><span class="s2">, </span><span class="s5">'124'</span><span class="s2">, </span><span class="s5">'064'</span><span class="s2">, </span><span class="s5">'157'</span><span class="s2">, </span><span class="s5">'235'</span><span class="s2">, </span><span class="s5">'301'</span><span class="s1">] +</span>
                     <span class="s1">[</span><span class="s5">'000'</span><span class="s1">] * </span><span class="s3">8</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">long_double_representation(lines):</span>
    <span class="s4">&quot;&quot;&quot;Given a binary dump as given by GNU od -b, look for long double 
    representation.&quot;&quot;&quot;</span>

    <span class="s0"># Read contains a list of 32 items, each item is a byte (in octal</span>
    <span class="s0"># representation, as a string). We 'slide' over the output until read is of</span>
    <span class="s0"># the form before_seq + content + after_sequence, where content is the long double</span>
    <span class="s0"># representation:</span>
    <span class="s0">#  - content is 12 bytes: 80 bits Intel representation</span>
    <span class="s0">#  - content is 16 bytes: 80 bits Intel representation (64 bits) or quad precision</span>
    <span class="s0">#  - content is 8 bytes: same as double (not implemented yet)</span>
    <span class="s1">read = [</span><span class="s5">''</span><span class="s1">] * </span><span class="s3">32</span>
    <span class="s1">saw = </span><span class="s2">None</span>
    <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines:</span>
        <span class="s0"># we skip the first word, as od -b output an index at the beginning of</span>
        <span class="s0"># each line</span>
        <span class="s2">for </span><span class="s1">w </span><span class="s2">in </span><span class="s1">line.split()[</span><span class="s3">1</span><span class="s1">:]:</span>
            <span class="s1">read.pop(</span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">read.append(w)</span>

            <span class="s0"># If the end of read is equal to the after_sequence, read contains</span>
            <span class="s0"># the long double</span>
            <span class="s2">if </span><span class="s1">read[-</span><span class="s3">8</span><span class="s1">:] == _AFTER_SEQ:</span>
                <span class="s1">saw = copy.copy(read)</span>
                <span class="s0"># if the content was 12 bytes, we only have 32 - 8 - 12 = 12</span>
                <span class="s0"># &quot;before&quot; bytes. In other words the first 4 &quot;before&quot; bytes went</span>
                <span class="s0"># past the sliding window.</span>
                <span class="s2">if </span><span class="s1">read[:</span><span class="s3">12</span><span class="s1">] == _BEFORE_SEQ[</span><span class="s3">4</span><span class="s1">:]:</span>
                    <span class="s2">if </span><span class="s1">read[</span><span class="s3">12</span><span class="s1">:-</span><span class="s3">8</span><span class="s1">] == _INTEL_EXTENDED_12B:</span>
                        <span class="s2">return </span><span class="s5">'INTEL_EXTENDED_12_BYTES_LE'</span>
                    <span class="s2">if </span><span class="s1">read[</span><span class="s3">12</span><span class="s1">:-</span><span class="s3">8</span><span class="s1">] == _MOTOROLA_EXTENDED_12B:</span>
                        <span class="s2">return </span><span class="s5">'MOTOROLA_EXTENDED_12_BYTES_BE'</span>
                <span class="s0"># if the content was 16 bytes, we are left with 32-8-16 = 16</span>
                <span class="s0"># &quot;before&quot; bytes, so 8 went past the sliding window.</span>
                <span class="s2">elif </span><span class="s1">read[:</span><span class="s3">8</span><span class="s1">] == _BEFORE_SEQ[</span><span class="s3">8</span><span class="s1">:]:</span>
                    <span class="s2">if </span><span class="s1">read[</span><span class="s3">8</span><span class="s1">:-</span><span class="s3">8</span><span class="s1">] == _INTEL_EXTENDED_16B:</span>
                        <span class="s2">return </span><span class="s5">'INTEL_EXTENDED_16_BYTES_LE'</span>
                    <span class="s2">elif </span><span class="s1">read[</span><span class="s3">8</span><span class="s1">:-</span><span class="s3">8</span><span class="s1">] == _IEEE_QUAD_PREC_BE:</span>
                        <span class="s2">return </span><span class="s5">'IEEE_QUAD_BE'</span>
                    <span class="s2">elif </span><span class="s1">read[</span><span class="s3">8</span><span class="s1">:-</span><span class="s3">8</span><span class="s1">] == _IEEE_QUAD_PREC_LE:</span>
                        <span class="s2">return </span><span class="s5">'IEEE_QUAD_LE'</span>
                    <span class="s2">elif </span><span class="s1">read[</span><span class="s3">8</span><span class="s1">:-</span><span class="s3">8</span><span class="s1">] == _IBM_DOUBLE_DOUBLE_LE:</span>
                        <span class="s2">return </span><span class="s5">'IBM_DOUBLE_DOUBLE_LE'</span>
                    <span class="s2">elif </span><span class="s1">read[</span><span class="s3">8</span><span class="s1">:-</span><span class="s3">8</span><span class="s1">] == _IBM_DOUBLE_DOUBLE_BE:</span>
                        <span class="s2">return </span><span class="s5">'IBM_DOUBLE_DOUBLE_BE'</span>
                <span class="s0"># if the content was 8 bytes, left with 32-8-8 = 16 bytes</span>
                <span class="s2">elif </span><span class="s1">read[:</span><span class="s3">16</span><span class="s1">] == _BEFORE_SEQ:</span>
                    <span class="s2">if </span><span class="s1">read[</span><span class="s3">16</span><span class="s1">:-</span><span class="s3">8</span><span class="s1">] == _IEEE_DOUBLE_LE:</span>
                        <span class="s2">return </span><span class="s5">'IEEE_DOUBLE_LE'</span>
                    <span class="s2">elif </span><span class="s1">read[</span><span class="s3">16</span><span class="s1">:-</span><span class="s3">8</span><span class="s1">] == _IEEE_DOUBLE_BE:</span>
                        <span class="s2">return </span><span class="s5">'IEEE_DOUBLE_BE'</span>

    <span class="s2">if </span><span class="s1">saw </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Unrecognized format (%s)&quot; </span><span class="s1">% saw)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s0"># We never detected the after_sequence</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Could not lock sequences (%s)&quot; </span><span class="s1">% saw)</span>


<span class="s2">def </span><span class="s1">check_for_right_shift_internal_compiler_error(cmd):</span>
    <span class="s4">&quot;&quot;&quot; 
    On our arm CI, this fails with an internal compilation error 
 
    The failure looks like the following, and can be reproduced on ARM64 GCC 5.4: 
 
        &lt;source&gt;: In function 'right_shift': 
        &lt;source&gt;:4:20: internal compiler error: in expand_shift_1, at expmed.c:2349 
               ip1[i] = ip1[i] &gt;&gt; in2; 
                      ^ 
        Please submit a full bug report, 
        with preprocessed source if appropriate. 
        See &lt;http://gcc.gnu.org/bugs.html&gt; for instructions. 
        Compiler returned: 1 
 
    This function returns True if this compiler bug is present, and we need to 
    turn off optimization for the function 
    &quot;&quot;&quot;</span>
    <span class="s1">cmd._check_compiler()</span>
    <span class="s1">has_optimize = cmd.try_compile(textwrap.dedent(</span><span class="s5">&quot;&quot;&quot;</span><span class="s2">\ 
        </span><span class="s5">__attribute__((optimize(&quot;O3&quot;))) void right_shift() {} 
        &quot;&quot;&quot;</span><span class="s1">)</span><span class="s2">, None, None</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">has_optimize:</span>
        <span class="s2">return False</span>

    <span class="s1">no_err = cmd.try_compile(textwrap.dedent(</span><span class="s5">&quot;&quot;&quot;</span><span class="s2">\ 
        </span><span class="s5">typedef long the_type;  /* fails also for unsigned and long long */ 
        __attribute__((optimize(&quot;O3&quot;))) void right_shift(the_type in2, the_type *ip1, int n) { 
            for (int i = 0; i &lt; n; i++) { 
                if (in2 &lt; (the_type)sizeof(the_type) * 8) { 
                    ip1[i] = ip1[i] &gt;&gt; in2; 
                } 
            } 
        } 
        &quot;&quot;&quot;</span><span class="s1">)</span><span class="s2">, None, None</span><span class="s1">)</span>
    <span class="s2">return not </span><span class="s1">no_err</span>
</pre>
</body>
</html>