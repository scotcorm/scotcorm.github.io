<html>
<head>
<title>parser.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
parser.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Parse tokens from the lexer into nodes for the compiler.&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">typing</span>
<span class="s2">import </span><span class="s1">typing </span><span class="s2">as </span><span class="s1">t</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">nodes</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">TemplateAssertionError</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">TemplateSyntaxError</span>
<span class="s2">from </span><span class="s1">.lexer </span><span class="s2">import </span><span class="s1">describe_token</span>
<span class="s2">from </span><span class="s1">.lexer </span><span class="s2">import </span><span class="s1">describe_token_expr</span>

<span class="s2">if </span><span class="s1">t.TYPE_CHECKING:</span>
    <span class="s2">import </span><span class="s1">typing_extensions </span><span class="s2">as </span><span class="s1">te</span>
    <span class="s2">from </span><span class="s1">.environment </span><span class="s2">import </span><span class="s1">Environment</span>

<span class="s1">_ImportInclude = t.TypeVar(</span><span class="s3">&quot;_ImportInclude&quot;</span><span class="s2">, </span><span class="s1">nodes.Import</span><span class="s2">, </span><span class="s1">nodes.Include)</span>
<span class="s1">_MacroCall = t.TypeVar(</span><span class="s3">&quot;_MacroCall&quot;</span><span class="s2">, </span><span class="s1">nodes.Macro</span><span class="s2">, </span><span class="s1">nodes.CallBlock)</span>

<span class="s1">_statement_keywords = frozenset(</span>
    <span class="s1">[</span>
        <span class="s3">&quot;for&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;if&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;block&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;extends&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;print&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;macro&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;include&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;from&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;import&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;set&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;with&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;autoescape&quot;</span><span class="s2">,</span>
    <span class="s1">]</span>
<span class="s1">)</span>
<span class="s1">_compare_operators = frozenset([</span><span class="s3">&quot;eq&quot;</span><span class="s2">, </span><span class="s3">&quot;ne&quot;</span><span class="s2">, </span><span class="s3">&quot;lt&quot;</span><span class="s2">, </span><span class="s3">&quot;lteq&quot;</span><span class="s2">, </span><span class="s3">&quot;gt&quot;</span><span class="s2">, </span><span class="s3">&quot;gteq&quot;</span><span class="s1">])</span>

<span class="s1">_math_nodes: t.Dict[str</span><span class="s2">, </span><span class="s1">t.Type[nodes.Expr]] = {</span>
    <span class="s3">&quot;add&quot;</span><span class="s1">: nodes.Add</span><span class="s2">,</span>
    <span class="s3">&quot;sub&quot;</span><span class="s1">: nodes.Sub</span><span class="s2">,</span>
    <span class="s3">&quot;mul&quot;</span><span class="s1">: nodes.Mul</span><span class="s2">,</span>
    <span class="s3">&quot;div&quot;</span><span class="s1">: nodes.Div</span><span class="s2">,</span>
    <span class="s3">&quot;floordiv&quot;</span><span class="s1">: nodes.FloorDiv</span><span class="s2">,</span>
    <span class="s3">&quot;mod&quot;</span><span class="s1">: nodes.Mod</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s2">class </span><span class="s1">Parser:</span>
    <span class="s0">&quot;&quot;&quot;This is the central parsing class Jinja uses.  It's passed to 
    extensions and can be used to parse expressions or statements. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">environment: </span><span class="s3">&quot;Environment&quot;</span><span class="s2">,</span>
        <span class="s1">source: str</span><span class="s2">,</span>
        <span class="s1">name: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">filename: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">state: t.Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.environment = environment</span>
        <span class="s1">self.stream = environment._tokenize(source</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">state)</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.filename = filename</span>
        <span class="s1">self.closed = </span><span class="s2">False</span>
        <span class="s1">self.extensions: t.Dict[</span>
            <span class="s1">str</span><span class="s2">, </span><span class="s1">t.Callable[[</span><span class="s3">&quot;Parser&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">t.Union[nodes.Node</span><span class="s2">, </span><span class="s1">t.List[nodes.Node]]]</span>
        <span class="s1">] = {}</span>
        <span class="s2">for </span><span class="s1">extension </span><span class="s2">in </span><span class="s1">environment.iter_extensions():</span>
            <span class="s2">for </span><span class="s1">tag </span><span class="s2">in </span><span class="s1">extension.tags:</span>
                <span class="s1">self.extensions[tag] = extension.parse</span>
        <span class="s1">self._last_identifier = </span><span class="s4">0</span>
        <span class="s1">self._tag_stack: t.List[str] = []</span>
        <span class="s1">self._end_token_stack: t.List[t.Tuple[str</span><span class="s2">, </span><span class="s1">...]] = []</span>

    <span class="s2">def </span><span class="s1">fail(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">msg: str</span><span class="s2">,</span>
        <span class="s1">lineno: t.Optional[int] = </span><span class="s2">None,</span>
        <span class="s1">exc: t.Type[TemplateSyntaxError] = TemplateSyntaxError</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;te.NoReturn&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Convenience method that raises `exc` with the message, passed 
        line number or last line number as well as the current name and 
        filename. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">lineno </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">lineno = self.stream.current.lineno</span>
        <span class="s2">raise </span><span class="s1">exc(msg</span><span class="s2">, </span><span class="s1">lineno</span><span class="s2">, </span><span class="s1">self.name</span><span class="s2">, </span><span class="s1">self.filename)</span>

    <span class="s2">def </span><span class="s1">_fail_ut_eof(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">name: t.Optional[str]</span><span class="s2">,</span>
        <span class="s1">end_token_stack: t.List[t.Tuple[str</span><span class="s2">, </span><span class="s1">...]]</span><span class="s2">,</span>
        <span class="s1">lineno: t.Optional[int]</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;te.NoReturn&quot;</span><span class="s1">:</span>
        <span class="s1">expected: t.Set[str] = set()</span>
        <span class="s2">for </span><span class="s1">exprs </span><span class="s2">in </span><span class="s1">end_token_stack:</span>
            <span class="s1">expected.update(map(describe_token_expr</span><span class="s2">, </span><span class="s1">exprs))</span>
        <span class="s2">if </span><span class="s1">end_token_stack:</span>
            <span class="s1">currently_looking: t.Optional[str] = </span><span class="s3">&quot; or &quot;</span><span class="s1">.join(</span>
                <span class="s1">map(repr</span><span class="s2">, </span><span class="s1">map(describe_token_expr</span><span class="s2">, </span><span class="s1">end_token_stack[-</span><span class="s4">1</span><span class="s1">]))</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">currently_looking = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">message = [</span><span class="s3">&quot;Unexpected end of template.&quot;</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">message = [</span><span class="s3">f&quot;Encountered unknown tag </span><span class="s2">{</span><span class="s1">name</span><span class="s2">!r}</span><span class="s3">.&quot;</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">currently_looking:</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">is not None and </span><span class="s1">name </span><span class="s2">in </span><span class="s1">expected:</span>
                <span class="s1">message.append(</span>
                    <span class="s3">&quot;You probably made a nesting mistake. Jinja is expecting this tag,&quot;</span>
                    <span class="s3">f&quot; but currently looking for </span><span class="s2">{</span><span class="s1">currently_looking</span><span class="s2">}</span><span class="s3">.&quot;</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">message.append(</span>
                    <span class="s3">f&quot;Jinja was looking for the following tags: </span><span class="s2">{</span><span class="s1">currently_looking</span><span class="s2">}</span><span class="s3">.&quot;</span>
                <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self._tag_stack:</span>
            <span class="s1">message.append(</span>
                <span class="s3">&quot;The innermost block that needs to be closed is&quot;</span>
                <span class="s3">f&quot; </span><span class="s2">{</span><span class="s1">self._tag_stack[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">!r}</span><span class="s3">.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self.fail(</span><span class="s3">&quot; &quot;</span><span class="s1">.join(message)</span><span class="s2">, </span><span class="s1">lineno)</span>

    <span class="s2">def </span><span class="s1">fail_unknown_tag(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">lineno: t.Optional[int] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;te.NoReturn&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Called if the parser encounters an unknown tag.  Tries to fail 
        with a human readable error message that could help to identify 
        the problem. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._fail_ut_eof(name</span><span class="s2">, </span><span class="s1">self._end_token_stack</span><span class="s2">, </span><span class="s1">lineno)</span>

    <span class="s2">def </span><span class="s1">fail_eof(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">end_tokens: t.Optional[t.Tuple[str</span><span class="s2">, </span><span class="s1">...]] = </span><span class="s2">None,</span>
        <span class="s1">lineno: t.Optional[int] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;te.NoReturn&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Like fail_unknown_tag but for end of template situations.&quot;&quot;&quot;</span>
        <span class="s1">stack = list(self._end_token_stack)</span>
        <span class="s2">if </span><span class="s1">end_tokens </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">stack.append(end_tokens)</span>
        <span class="s1">self._fail_ut_eof(</span><span class="s2">None, </span><span class="s1">stack</span><span class="s2">, </span><span class="s1">lineno)</span>

    <span class="s2">def </span><span class="s1">is_tuple_end(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">extra_end_rules: t.Optional[t.Tuple[str</span><span class="s2">, </span><span class="s1">...]] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Are we at the end of a tuple?&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.stream.current.type </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;variable_end&quot;</span><span class="s2">, </span><span class="s3">&quot;block_end&quot;</span><span class="s2">, </span><span class="s3">&quot;rparen&quot;</span><span class="s1">):</span>
            <span class="s2">return True</span>
        <span class="s2">elif </span><span class="s1">extra_end_rules </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.stream.current.test_any(extra_end_rules)  </span><span class="s5"># type: ignore</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">free_identifier(self</span><span class="s2">, </span><span class="s1">lineno: t.Optional[int] = </span><span class="s2">None</span><span class="s1">) -&gt; nodes.InternalName:</span>
        <span class="s0">&quot;&quot;&quot;Return a new free identifier as :class:`~jinja2.nodes.InternalName`.&quot;&quot;&quot;</span>
        <span class="s1">self._last_identifier += </span><span class="s4">1</span>
        <span class="s1">rv = object.__new__(nodes.InternalName)</span>
        <span class="s1">nodes.Node.__init__(rv</span><span class="s2">, </span><span class="s3">f&quot;fi</span><span class="s2">{</span><span class="s1">self._last_identifier</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>
        <span class="s2">return </span><span class="s1">rv  </span><span class="s5"># type: ignore</span>

    <span class="s2">def </span><span class="s1">parse_statement(self) -&gt; t.Union[nodes.Node</span><span class="s2">, </span><span class="s1">t.List[nodes.Node]]:</span>
        <span class="s0">&quot;&quot;&quot;Parse a single statement.&quot;&quot;&quot;</span>
        <span class="s1">token = self.stream.current</span>
        <span class="s2">if </span><span class="s1">token.type != </span><span class="s3">&quot;name&quot;</span><span class="s1">:</span>
            <span class="s1">self.fail(</span><span class="s3">&quot;tag name expected&quot;</span><span class="s2">, </span><span class="s1">token.lineno)</span>
        <span class="s1">self._tag_stack.append(token.value)</span>
        <span class="s1">pop_tag = </span><span class="s2">True</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">token.value </span><span class="s2">in </span><span class="s1">_statement_keywords:</span>
                <span class="s1">f = getattr(self</span><span class="s2">, </span><span class="s3">f&quot;parse_</span><span class="s2">{</span><span class="s1">self.stream.current.value</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
                <span class="s2">return </span><span class="s1">f()  </span><span class="s5"># type: ignore</span>
            <span class="s2">if </span><span class="s1">token.value == </span><span class="s3">&quot;call&quot;</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.parse_call_block()</span>
            <span class="s2">if </span><span class="s1">token.value == </span><span class="s3">&quot;filter&quot;</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.parse_filter_block()</span>
            <span class="s1">ext = self.extensions.get(token.value)</span>
            <span class="s2">if </span><span class="s1">ext </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">ext(self)</span>

            <span class="s5"># did not work out, remove the token we pushed by accident</span>
            <span class="s5"># from the stack so that the unknown tag fail function can</span>
            <span class="s5"># produce a proper error message.</span>
            <span class="s1">self._tag_stack.pop()</span>
            <span class="s1">pop_tag = </span><span class="s2">False</span>
            <span class="s1">self.fail_unknown_tag(token.value</span><span class="s2">, </span><span class="s1">token.lineno)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">pop_tag:</span>
                <span class="s1">self._tag_stack.pop()</span>

    <span class="s2">def </span><span class="s1">parse_statements(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">end_tokens: t.Tuple[str</span><span class="s2">, </span><span class="s1">...]</span><span class="s2">, </span><span class="s1">drop_needle: bool = </span><span class="s2">False</span>
    <span class="s1">) -&gt; t.List[nodes.Node]:</span>
        <span class="s0">&quot;&quot;&quot;Parse multiple statements into a list until one of the end tokens 
        is reached.  This is used to parse the body of statements as it also 
        parses template data if appropriate.  The parser checks first if the 
        current token is a colon and skips it if there is one.  Then it checks 
        for the block end and parses until if one of the `end_tokens` is 
        reached.  Per default the active token in the stream at the end of 
        the call is the matched end token.  If this is not wanted `drop_needle` 
        can be set to `True` and the end token is removed. 
        &quot;&quot;&quot;</span>
        <span class="s5"># the first token may be a colon for python compatibility</span>
        <span class="s1">self.stream.skip_if(</span><span class="s3">&quot;colon&quot;</span><span class="s1">)</span>

        <span class="s5"># in the future it would be possible to add whole code sections</span>
        <span class="s5"># by adding some sort of end of statement token and parsing those here.</span>
        <span class="s1">self.stream.expect(</span><span class="s3">&quot;block_end&quot;</span><span class="s1">)</span>
        <span class="s1">result = self.subparse(end_tokens)</span>

        <span class="s5"># we reached the end of the template too early, the subparser</span>
        <span class="s5"># does not check for this, so we do that now</span>
        <span class="s2">if </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;eof&quot;</span><span class="s1">:</span>
            <span class="s1">self.fail_eof(end_tokens)</span>

        <span class="s2">if </span><span class="s1">drop_needle:</span>
            <span class="s1">next(self.stream)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">parse_set(self) -&gt; t.Union[nodes.Assign</span><span class="s2">, </span><span class="s1">nodes.AssignBlock]:</span>
        <span class="s0">&quot;&quot;&quot;Parse an assign statement.&quot;&quot;&quot;</span>
        <span class="s1">lineno = next(self.stream).lineno</span>
        <span class="s1">target = self.parse_assign_target(with_namespace=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.stream.skip_if(</span><span class="s3">&quot;assign&quot;</span><span class="s1">):</span>
            <span class="s1">expr = self.parse_tuple()</span>
            <span class="s2">return </span><span class="s1">nodes.Assign(target</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>
        <span class="s1">filter_node = self.parse_filter(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">body = self.parse_statements((</span><span class="s3">&quot;name:endset&quot;</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">drop_needle=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">nodes.AssignBlock(target</span><span class="s2">, </span><span class="s1">filter_node</span><span class="s2">, </span><span class="s1">body</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>

    <span class="s2">def </span><span class="s1">parse_for(self) -&gt; nodes.For:</span>
        <span class="s0">&quot;&quot;&quot;Parse a for loop.&quot;&quot;&quot;</span>
        <span class="s1">lineno = self.stream.expect(</span><span class="s3">&quot;name:for&quot;</span><span class="s1">).lineno</span>
        <span class="s1">target = self.parse_assign_target(extra_end_rules=(</span><span class="s3">&quot;name:in&quot;</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">self.stream.expect(</span><span class="s3">&quot;name:in&quot;</span><span class="s1">)</span>
        <span class="s1">iter = self.parse_tuple(</span>
            <span class="s1">with_condexpr=</span><span class="s2">False, </span><span class="s1">extra_end_rules=(</span><span class="s3">&quot;name:recursive&quot;</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">test = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">self.stream.skip_if(</span><span class="s3">&quot;name:if&quot;</span><span class="s1">):</span>
            <span class="s1">test = self.parse_expression()</span>
        <span class="s1">recursive = self.stream.skip_if(</span><span class="s3">&quot;name:recursive&quot;</span><span class="s1">)</span>
        <span class="s1">body = self.parse_statements((</span><span class="s3">&quot;name:endfor&quot;</span><span class="s2">, </span><span class="s3">&quot;name:else&quot;</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">next(self.stream).value == </span><span class="s3">&quot;endfor&quot;</span><span class="s1">:</span>
            <span class="s1">else_ = []</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">else_ = self.parse_statements((</span><span class="s3">&quot;name:endfor&quot;</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">drop_needle=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">nodes.For(target</span><span class="s2">, </span><span class="s1">iter</span><span class="s2">, </span><span class="s1">body</span><span class="s2">, </span><span class="s1">else_</span><span class="s2">, </span><span class="s1">test</span><span class="s2">, </span><span class="s1">recursive</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>

    <span class="s2">def </span><span class="s1">parse_if(self) -&gt; nodes.If:</span>
        <span class="s0">&quot;&quot;&quot;Parse an if construct.&quot;&quot;&quot;</span>
        <span class="s1">node = result = nodes.If(lineno=self.stream.expect(</span><span class="s3">&quot;name:if&quot;</span><span class="s1">).lineno)</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">node.test = self.parse_tuple(with_condexpr=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">node.body = self.parse_statements((</span><span class="s3">&quot;name:elif&quot;</span><span class="s2">, </span><span class="s3">&quot;name:else&quot;</span><span class="s2">, </span><span class="s3">&quot;name:endif&quot;</span><span class="s1">))</span>
            <span class="s1">node.elif_ = []</span>
            <span class="s1">node.else_ = []</span>
            <span class="s1">token = next(self.stream)</span>
            <span class="s2">if </span><span class="s1">token.test(</span><span class="s3">&quot;name:elif&quot;</span><span class="s1">):</span>
                <span class="s1">node = nodes.If(lineno=self.stream.current.lineno)</span>
                <span class="s1">result.elif_.append(node)</span>
                <span class="s2">continue</span>
            <span class="s2">elif </span><span class="s1">token.test(</span><span class="s3">&quot;name:else&quot;</span><span class="s1">):</span>
                <span class="s1">result.else_ = self.parse_statements((</span><span class="s3">&quot;name:endif&quot;</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">drop_needle=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">break</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">parse_with(self) -&gt; nodes.With:</span>
        <span class="s1">node = nodes.With(lineno=next(self.stream).lineno)</span>
        <span class="s1">targets: t.List[nodes.Expr] = []</span>
        <span class="s1">values: t.List[nodes.Expr] = []</span>
        <span class="s2">while </span><span class="s1">self.stream.current.type != </span><span class="s3">&quot;block_end&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">targets:</span>
                <span class="s1">self.stream.expect(</span><span class="s3">&quot;comma&quot;</span><span class="s1">)</span>
            <span class="s1">target = self.parse_assign_target()</span>
            <span class="s1">target.set_ctx(</span><span class="s3">&quot;param&quot;</span><span class="s1">)</span>
            <span class="s1">targets.append(target)</span>
            <span class="s1">self.stream.expect(</span><span class="s3">&quot;assign&quot;</span><span class="s1">)</span>
            <span class="s1">values.append(self.parse_expression())</span>
        <span class="s1">node.targets = targets</span>
        <span class="s1">node.values = values</span>
        <span class="s1">node.body = self.parse_statements((</span><span class="s3">&quot;name:endwith&quot;</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">drop_needle=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">parse_autoescape(self) -&gt; nodes.Scope:</span>
        <span class="s1">node = nodes.ScopedEvalContextModifier(lineno=next(self.stream).lineno)</span>
        <span class="s1">node.options = [nodes.Keyword(</span><span class="s3">&quot;autoescape&quot;</span><span class="s2">, </span><span class="s1">self.parse_expression())]</span>
        <span class="s1">node.body = self.parse_statements((</span><span class="s3">&quot;name:endautoescape&quot;</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">drop_needle=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">nodes.Scope([node])</span>

    <span class="s2">def </span><span class="s1">parse_block(self) -&gt; nodes.Block:</span>
        <span class="s1">node = nodes.Block(lineno=next(self.stream).lineno)</span>
        <span class="s1">node.name = self.stream.expect(</span><span class="s3">&quot;name&quot;</span><span class="s1">).value</span>
        <span class="s1">node.scoped = self.stream.skip_if(</span><span class="s3">&quot;name:scoped&quot;</span><span class="s1">)</span>
        <span class="s1">node.required = self.stream.skip_if(</span><span class="s3">&quot;name:required&quot;</span><span class="s1">)</span>

        <span class="s5"># common problem people encounter when switching from django</span>
        <span class="s5"># to jinja.  we do not support hyphens in block names, so let's</span>
        <span class="s5"># raise a nicer error message in that case.</span>
        <span class="s2">if </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;sub&quot;</span><span class="s1">:</span>
            <span class="s1">self.fail(</span>
                <span class="s3">&quot;Block names in Jinja have to be valid Python identifiers and may not&quot;</span>
                <span class="s3">&quot; contain hyphens, use an underscore instead.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">node.body = self.parse_statements((</span><span class="s3">&quot;name:endblock&quot;</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">drop_needle=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s5"># enforce that required blocks only contain whitespace or comments</span>
        <span class="s5"># by asserting that the body, if not empty, is just TemplateData nodes</span>
        <span class="s5"># with whitespace data</span>
        <span class="s2">if </span><span class="s1">node.required </span><span class="s2">and not </span><span class="s1">all(</span>
            <span class="s1">isinstance(child</span><span class="s2">, </span><span class="s1">nodes.TemplateData) </span><span class="s2">and </span><span class="s1">child.data.isspace()</span>
            <span class="s2">for </span><span class="s1">body </span><span class="s2">in </span><span class="s1">node.body</span>
            <span class="s2">for </span><span class="s1">child </span><span class="s2">in </span><span class="s1">body.nodes  </span><span class="s5"># type: ignore</span>
        <span class="s1">):</span>
            <span class="s1">self.fail(</span><span class="s3">&quot;Required blocks can only contain comments or whitespace&quot;</span><span class="s1">)</span>

        <span class="s1">self.stream.skip_if(</span><span class="s3">&quot;name:&quot; </span><span class="s1">+ node.name)</span>
        <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">parse_extends(self) -&gt; nodes.Extends:</span>
        <span class="s1">node = nodes.Extends(lineno=next(self.stream).lineno)</span>
        <span class="s1">node.template = self.parse_expression()</span>
        <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">parse_import_context(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">node: _ImportInclude</span><span class="s2">, </span><span class="s1">default: bool</span>
    <span class="s1">) -&gt; _ImportInclude:</span>
        <span class="s2">if </span><span class="s1">self.stream.current.test_any(</span>
            <span class="s3">&quot;name:with&quot;</span><span class="s2">, </span><span class="s3">&quot;name:without&quot;</span>
        <span class="s1">) </span><span class="s2">and </span><span class="s1">self.stream.look().test(</span><span class="s3">&quot;name:context&quot;</span><span class="s1">):</span>
            <span class="s1">node.with_context = next(self.stream).value == </span><span class="s3">&quot;with&quot;</span>
            <span class="s1">self.stream.skip()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">node.with_context = default</span>
        <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">parse_include(self) -&gt; nodes.Include:</span>
        <span class="s1">node = nodes.Include(lineno=next(self.stream).lineno)</span>
        <span class="s1">node.template = self.parse_expression()</span>
        <span class="s2">if </span><span class="s1">self.stream.current.test(</span><span class="s3">&quot;name:ignore&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">self.stream.look().test(</span>
            <span class="s3">&quot;name:missing&quot;</span>
        <span class="s1">):</span>
            <span class="s1">node.ignore_missing = </span><span class="s2">True</span>
            <span class="s1">self.stream.skip(</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">node.ignore_missing = </span><span class="s2">False</span>
        <span class="s2">return </span><span class="s1">self.parse_import_context(node</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">parse_import(self) -&gt; nodes.Import:</span>
        <span class="s1">node = nodes.Import(lineno=next(self.stream).lineno)</span>
        <span class="s1">node.template = self.parse_expression()</span>
        <span class="s1">self.stream.expect(</span><span class="s3">&quot;name:as&quot;</span><span class="s1">)</span>
        <span class="s1">node.target = self.parse_assign_target(name_only=</span><span class="s2">True</span><span class="s1">).name</span>
        <span class="s2">return </span><span class="s1">self.parse_import_context(node</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">parse_from(self) -&gt; nodes.FromImport:</span>
        <span class="s1">node = nodes.FromImport(lineno=next(self.stream).lineno)</span>
        <span class="s1">node.template = self.parse_expression()</span>
        <span class="s1">self.stream.expect(</span><span class="s3">&quot;name:import&quot;</span><span class="s1">)</span>
        <span class="s1">node.names = []</span>

        <span class="s2">def </span><span class="s1">parse_context() -&gt; bool:</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">self.stream.current.value</span>
                <span class="s2">in </span><span class="s1">{</span>
                    <span class="s3">&quot;with&quot;</span><span class="s2">,</span>
                    <span class="s3">&quot;without&quot;</span><span class="s2">,</span>
                <span class="s1">}</span>
                <span class="s2">and </span><span class="s1">self.stream.look().test(</span><span class="s3">&quot;name:context&quot;</span><span class="s1">)</span>
            <span class="s1">):</span>
                <span class="s1">node.with_context = next(self.stream).value == </span><span class="s3">&quot;with&quot;</span>
                <span class="s1">self.stream.skip()</span>
                <span class="s2">return True</span>
            <span class="s2">return False</span>

        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">node.names:</span>
                <span class="s1">self.stream.expect(</span><span class="s3">&quot;comma&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;name&quot;</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">parse_context():</span>
                    <span class="s2">break</span>
                <span class="s1">target = self.parse_assign_target(name_only=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">target.name.startswith(</span><span class="s3">&quot;_&quot;</span><span class="s1">):</span>
                    <span class="s1">self.fail(</span>
                        <span class="s3">&quot;names starting with an underline can not be imported&quot;</span><span class="s2">,</span>
                        <span class="s1">target.lineno</span><span class="s2">,</span>
                        <span class="s1">exc=TemplateAssertionError</span><span class="s2">,</span>
                    <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">self.stream.skip_if(</span><span class="s3">&quot;name:as&quot;</span><span class="s1">):</span>
                    <span class="s1">alias = self.parse_assign_target(name_only=</span><span class="s2">True</span><span class="s1">)</span>
                    <span class="s1">node.names.append((target.name</span><span class="s2">, </span><span class="s1">alias.name))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">node.names.append(target.name)</span>
                <span class="s2">if </span><span class="s1">parse_context() </span><span class="s2">or </span><span class="s1">self.stream.current.type != </span><span class="s3">&quot;comma&quot;</span><span class="s1">:</span>
                    <span class="s2">break</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.stream.expect(</span><span class="s3">&quot;name&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">hasattr(node</span><span class="s2">, </span><span class="s3">&quot;with_context&quot;</span><span class="s1">):</span>
            <span class="s1">node.with_context = </span><span class="s2">False</span>
        <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">parse_signature(self</span><span class="s2">, </span><span class="s1">node: _MacroCall) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">args = node.args = []</span>
        <span class="s1">defaults = node.defaults = []</span>
        <span class="s1">self.stream.expect(</span><span class="s3">&quot;lparen&quot;</span><span class="s1">)</span>
        <span class="s2">while </span><span class="s1">self.stream.current.type != </span><span class="s3">&quot;rparen&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">args:</span>
                <span class="s1">self.stream.expect(</span><span class="s3">&quot;comma&quot;</span><span class="s1">)</span>
            <span class="s1">arg = self.parse_assign_target(name_only=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">arg.set_ctx(</span><span class="s3">&quot;param&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.stream.skip_if(</span><span class="s3">&quot;assign&quot;</span><span class="s1">):</span>
                <span class="s1">defaults.append(self.parse_expression())</span>
            <span class="s2">elif </span><span class="s1">defaults:</span>
                <span class="s1">self.fail(</span><span class="s3">&quot;non-default argument follows default argument&quot;</span><span class="s1">)</span>
            <span class="s1">args.append(arg)</span>
        <span class="s1">self.stream.expect(</span><span class="s3">&quot;rparen&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">parse_call_block(self) -&gt; nodes.CallBlock:</span>
        <span class="s1">node = nodes.CallBlock(lineno=next(self.stream).lineno)</span>
        <span class="s2">if </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;lparen&quot;</span><span class="s1">:</span>
            <span class="s1">self.parse_signature(node)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">node.args = []</span>
            <span class="s1">node.defaults = []</span>

        <span class="s1">call_node = self.parse_expression()</span>
        <span class="s2">if not </span><span class="s1">isinstance(call_node</span><span class="s2">, </span><span class="s1">nodes.Call):</span>
            <span class="s1">self.fail(</span><span class="s3">&quot;expected call&quot;</span><span class="s2">, </span><span class="s1">node.lineno)</span>
        <span class="s1">node.call = call_node</span>
        <span class="s1">node.body = self.parse_statements((</span><span class="s3">&quot;name:endcall&quot;</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">drop_needle=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">parse_filter_block(self) -&gt; nodes.FilterBlock:</span>
        <span class="s1">node = nodes.FilterBlock(lineno=next(self.stream).lineno)</span>
        <span class="s1">node.filter = self.parse_filter(</span><span class="s2">None, </span><span class="s1">start_inline=</span><span class="s2">True</span><span class="s1">)  </span><span class="s5"># type: ignore</span>
        <span class="s1">node.body = self.parse_statements((</span><span class="s3">&quot;name:endfilter&quot;</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">drop_needle=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">parse_macro(self) -&gt; nodes.Macro:</span>
        <span class="s1">node = nodes.Macro(lineno=next(self.stream).lineno)</span>
        <span class="s1">node.name = self.parse_assign_target(name_only=</span><span class="s2">True</span><span class="s1">).name</span>
        <span class="s1">self.parse_signature(node)</span>
        <span class="s1">node.body = self.parse_statements((</span><span class="s3">&quot;name:endmacro&quot;</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">drop_needle=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">parse_print(self) -&gt; nodes.Output:</span>
        <span class="s1">node = nodes.Output(lineno=next(self.stream).lineno)</span>
        <span class="s1">node.nodes = []</span>
        <span class="s2">while </span><span class="s1">self.stream.current.type != </span><span class="s3">&quot;block_end&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">node.nodes:</span>
                <span class="s1">self.stream.expect(</span><span class="s3">&quot;comma&quot;</span><span class="s1">)</span>
            <span class="s1">node.nodes.append(self.parse_expression())</span>
        <span class="s2">return </span><span class="s1">node</span>

    <span class="s1">@typing.overload</span>
    <span class="s2">def </span><span class="s1">parse_assign_target(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">with_tuple: bool = ...</span><span class="s2">, </span><span class="s1">name_only: </span><span class="s3">&quot;te.Literal[True]&quot; </span><span class="s1">= ...</span>
    <span class="s1">) -&gt; nodes.Name:</span>
        <span class="s1">...</span>

    <span class="s1">@typing.overload</span>
    <span class="s2">def </span><span class="s1">parse_assign_target(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">with_tuple: bool = </span><span class="s2">True,</span>
        <span class="s1">name_only: bool = </span><span class="s2">False,</span>
        <span class="s1">extra_end_rules: t.Optional[t.Tuple[str</span><span class="s2">, </span><span class="s1">...]] = </span><span class="s2">None,</span>
        <span class="s1">with_namespace: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; t.Union[nodes.NSRef</span><span class="s2">, </span><span class="s1">nodes.Name</span><span class="s2">, </span><span class="s1">nodes.Tuple]:</span>
        <span class="s1">...</span>

    <span class="s2">def </span><span class="s1">parse_assign_target(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">with_tuple: bool = </span><span class="s2">True,</span>
        <span class="s1">name_only: bool = </span><span class="s2">False,</span>
        <span class="s1">extra_end_rules: t.Optional[t.Tuple[str</span><span class="s2">, </span><span class="s1">...]] = </span><span class="s2">None,</span>
        <span class="s1">with_namespace: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; t.Union[nodes.NSRef</span><span class="s2">, </span><span class="s1">nodes.Name</span><span class="s2">, </span><span class="s1">nodes.Tuple]:</span>
        <span class="s0">&quot;&quot;&quot;Parse an assignment target.  As Jinja allows assignments to 
        tuples, this function can parse all allowed assignment targets.  Per 
        default assignments to tuples are parsed, that can be disable however 
        by setting `with_tuple` to `False`.  If only assignments to names are 
        wanted `name_only` can be set to `True`.  The `extra_end_rules` 
        parameter is forwarded to the tuple parsing function.  If 
        `with_namespace` is enabled, a namespace assignment may be parsed. 
        &quot;&quot;&quot;</span>
        <span class="s1">target: nodes.Expr</span>

        <span class="s2">if </span><span class="s1">with_namespace </span><span class="s2">and </span><span class="s1">self.stream.look().type == </span><span class="s3">&quot;dot&quot;</span><span class="s1">:</span>
            <span class="s1">token = self.stream.expect(</span><span class="s3">&quot;name&quot;</span><span class="s1">)</span>
            <span class="s1">next(self.stream)  </span><span class="s5"># dot</span>
            <span class="s1">attr = self.stream.expect(</span><span class="s3">&quot;name&quot;</span><span class="s1">)</span>
            <span class="s1">target = nodes.NSRef(token.value</span><span class="s2">, </span><span class="s1">attr.value</span><span class="s2">, </span><span class="s1">lineno=token.lineno)</span>
        <span class="s2">elif </span><span class="s1">name_only:</span>
            <span class="s1">token = self.stream.expect(</span><span class="s3">&quot;name&quot;</span><span class="s1">)</span>
            <span class="s1">target = nodes.Name(token.value</span><span class="s2">, </span><span class="s3">&quot;store&quot;</span><span class="s2">, </span><span class="s1">lineno=token.lineno)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">with_tuple:</span>
                <span class="s1">target = self.parse_tuple(</span>
                    <span class="s1">simplified=</span><span class="s2">True, </span><span class="s1">extra_end_rules=extra_end_rules</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">target = self.parse_primary()</span>

            <span class="s1">target.set_ctx(</span><span class="s3">&quot;store&quot;</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">target.can_assign():</span>
            <span class="s1">self.fail(</span>
                <span class="s3">f&quot;can't assign to </span><span class="s2">{</span><span class="s1">type(target).__name__.lower()</span><span class="s2">!r}</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">target.lineno</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">target  </span><span class="s5"># type: ignore</span>

    <span class="s2">def </span><span class="s1">parse_expression(self</span><span class="s2">, </span><span class="s1">with_condexpr: bool = </span><span class="s2">True</span><span class="s1">) -&gt; nodes.Expr:</span>
        <span class="s0">&quot;&quot;&quot;Parse an expression.  Per default all expressions are parsed, if 
        the optional `with_condexpr` parameter is set to `False` conditional 
        expressions are not parsed. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">with_condexpr:</span>
            <span class="s2">return </span><span class="s1">self.parse_condexpr()</span>
        <span class="s2">return </span><span class="s1">self.parse_or()</span>

    <span class="s2">def </span><span class="s1">parse_condexpr(self) -&gt; nodes.Expr:</span>
        <span class="s1">lineno = self.stream.current.lineno</span>
        <span class="s1">expr1 = self.parse_or()</span>
        <span class="s1">expr3: t.Optional[nodes.Expr]</span>

        <span class="s2">while </span><span class="s1">self.stream.skip_if(</span><span class="s3">&quot;name:if&quot;</span><span class="s1">):</span>
            <span class="s1">expr2 = self.parse_or()</span>
            <span class="s2">if </span><span class="s1">self.stream.skip_if(</span><span class="s3">&quot;name:else&quot;</span><span class="s1">):</span>
                <span class="s1">expr3 = self.parse_condexpr()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">expr3 = </span><span class="s2">None</span>
            <span class="s1">expr1 = nodes.CondExpr(expr2</span><span class="s2">, </span><span class="s1">expr1</span><span class="s2">, </span><span class="s1">expr3</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>
            <span class="s1">lineno = self.stream.current.lineno</span>
        <span class="s2">return </span><span class="s1">expr1</span>

    <span class="s2">def </span><span class="s1">parse_or(self) -&gt; nodes.Expr:</span>
        <span class="s1">lineno = self.stream.current.lineno</span>
        <span class="s1">left = self.parse_and()</span>
        <span class="s2">while </span><span class="s1">self.stream.skip_if(</span><span class="s3">&quot;name:or&quot;</span><span class="s1">):</span>
            <span class="s1">right = self.parse_and()</span>
            <span class="s1">left = nodes.Or(left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>
            <span class="s1">lineno = self.stream.current.lineno</span>
        <span class="s2">return </span><span class="s1">left</span>

    <span class="s2">def </span><span class="s1">parse_and(self) -&gt; nodes.Expr:</span>
        <span class="s1">lineno = self.stream.current.lineno</span>
        <span class="s1">left = self.parse_not()</span>
        <span class="s2">while </span><span class="s1">self.stream.skip_if(</span><span class="s3">&quot;name:and&quot;</span><span class="s1">):</span>
            <span class="s1">right = self.parse_not()</span>
            <span class="s1">left = nodes.And(left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>
            <span class="s1">lineno = self.stream.current.lineno</span>
        <span class="s2">return </span><span class="s1">left</span>

    <span class="s2">def </span><span class="s1">parse_not(self) -&gt; nodes.Expr:</span>
        <span class="s2">if </span><span class="s1">self.stream.current.test(</span><span class="s3">&quot;name:not&quot;</span><span class="s1">):</span>
            <span class="s1">lineno = next(self.stream).lineno</span>
            <span class="s2">return </span><span class="s1">nodes.Not(self.parse_not()</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>
        <span class="s2">return </span><span class="s1">self.parse_compare()</span>

    <span class="s2">def </span><span class="s1">parse_compare(self) -&gt; nodes.Expr:</span>
        <span class="s1">lineno = self.stream.current.lineno</span>
        <span class="s1">expr = self.parse_math1()</span>
        <span class="s1">ops = []</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">token_type = self.stream.current.type</span>
            <span class="s2">if </span><span class="s1">token_type </span><span class="s2">in </span><span class="s1">_compare_operators:</span>
                <span class="s1">next(self.stream)</span>
                <span class="s1">ops.append(nodes.Operand(token_type</span><span class="s2">, </span><span class="s1">self.parse_math1()))</span>
            <span class="s2">elif </span><span class="s1">self.stream.skip_if(</span><span class="s3">&quot;name:in&quot;</span><span class="s1">):</span>
                <span class="s1">ops.append(nodes.Operand(</span><span class="s3">&quot;in&quot;</span><span class="s2">, </span><span class="s1">self.parse_math1()))</span>
            <span class="s2">elif </span><span class="s1">self.stream.current.test(</span><span class="s3">&quot;name:not&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">self.stream.look().test(</span>
                <span class="s3">&quot;name:in&quot;</span>
            <span class="s1">):</span>
                <span class="s1">self.stream.skip(</span><span class="s4">2</span><span class="s1">)</span>
                <span class="s1">ops.append(nodes.Operand(</span><span class="s3">&quot;notin&quot;</span><span class="s2">, </span><span class="s1">self.parse_math1()))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">break</span>
            <span class="s1">lineno = self.stream.current.lineno</span>
        <span class="s2">if not </span><span class="s1">ops:</span>
            <span class="s2">return </span><span class="s1">expr</span>
        <span class="s2">return </span><span class="s1">nodes.Compare(expr</span><span class="s2">, </span><span class="s1">ops</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>

    <span class="s2">def </span><span class="s1">parse_math1(self) -&gt; nodes.Expr:</span>
        <span class="s1">lineno = self.stream.current.lineno</span>
        <span class="s1">left = self.parse_concat()</span>
        <span class="s2">while </span><span class="s1">self.stream.current.type </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;add&quot;</span><span class="s2">, </span><span class="s3">&quot;sub&quot;</span><span class="s1">):</span>
            <span class="s1">cls = _math_nodes[self.stream.current.type]</span>
            <span class="s1">next(self.stream)</span>
            <span class="s1">right = self.parse_concat()</span>
            <span class="s1">left = cls(left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>
            <span class="s1">lineno = self.stream.current.lineno</span>
        <span class="s2">return </span><span class="s1">left</span>

    <span class="s2">def </span><span class="s1">parse_concat(self) -&gt; nodes.Expr:</span>
        <span class="s1">lineno = self.stream.current.lineno</span>
        <span class="s1">args = [self.parse_math2()]</span>
        <span class="s2">while </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;tilde&quot;</span><span class="s1">:</span>
            <span class="s1">next(self.stream)</span>
            <span class="s1">args.append(self.parse_math2())</span>
        <span class="s2">if </span><span class="s1">len(args) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">args[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">nodes.Concat(args</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>

    <span class="s2">def </span><span class="s1">parse_math2(self) -&gt; nodes.Expr:</span>
        <span class="s1">lineno = self.stream.current.lineno</span>
        <span class="s1">left = self.parse_pow()</span>
        <span class="s2">while </span><span class="s1">self.stream.current.type </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;mul&quot;</span><span class="s2">, </span><span class="s3">&quot;div&quot;</span><span class="s2">, </span><span class="s3">&quot;floordiv&quot;</span><span class="s2">, </span><span class="s3">&quot;mod&quot;</span><span class="s1">):</span>
            <span class="s1">cls = _math_nodes[self.stream.current.type]</span>
            <span class="s1">next(self.stream)</span>
            <span class="s1">right = self.parse_pow()</span>
            <span class="s1">left = cls(left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>
            <span class="s1">lineno = self.stream.current.lineno</span>
        <span class="s2">return </span><span class="s1">left</span>

    <span class="s2">def </span><span class="s1">parse_pow(self) -&gt; nodes.Expr:</span>
        <span class="s1">lineno = self.stream.current.lineno</span>
        <span class="s1">left = self.parse_unary()</span>
        <span class="s2">while </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;pow&quot;</span><span class="s1">:</span>
            <span class="s1">next(self.stream)</span>
            <span class="s1">right = self.parse_unary()</span>
            <span class="s1">left = nodes.Pow(left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>
            <span class="s1">lineno = self.stream.current.lineno</span>
        <span class="s2">return </span><span class="s1">left</span>

    <span class="s2">def </span><span class="s1">parse_unary(self</span><span class="s2">, </span><span class="s1">with_filter: bool = </span><span class="s2">True</span><span class="s1">) -&gt; nodes.Expr:</span>
        <span class="s1">token_type = self.stream.current.type</span>
        <span class="s1">lineno = self.stream.current.lineno</span>
        <span class="s1">node: nodes.Expr</span>

        <span class="s2">if </span><span class="s1">token_type == </span><span class="s3">&quot;sub&quot;</span><span class="s1">:</span>
            <span class="s1">next(self.stream)</span>
            <span class="s1">node = nodes.Neg(self.parse_unary(</span><span class="s2">False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>
        <span class="s2">elif </span><span class="s1">token_type == </span><span class="s3">&quot;add&quot;</span><span class="s1">:</span>
            <span class="s1">next(self.stream)</span>
            <span class="s1">node = nodes.Pos(self.parse_unary(</span><span class="s2">False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">node = self.parse_primary()</span>
        <span class="s1">node = self.parse_postfix(node)</span>
        <span class="s2">if </span><span class="s1">with_filter:</span>
            <span class="s1">node = self.parse_filter_expr(node)</span>
        <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">parse_primary(self) -&gt; nodes.Expr:</span>
        <span class="s1">token = self.stream.current</span>
        <span class="s1">node: nodes.Expr</span>
        <span class="s2">if </span><span class="s1">token.type == </span><span class="s3">&quot;name&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">token.value </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;true&quot;</span><span class="s2">, </span><span class="s3">&quot;false&quot;</span><span class="s2">, </span><span class="s3">&quot;True&quot;</span><span class="s2">, </span><span class="s3">&quot;False&quot;</span><span class="s1">):</span>
                <span class="s1">node = nodes.Const(token.value </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;true&quot;</span><span class="s2">, </span><span class="s3">&quot;True&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">lineno=token.lineno)</span>
            <span class="s2">elif </span><span class="s1">token.value </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;none&quot;</span><span class="s2">, </span><span class="s3">&quot;None&quot;</span><span class="s1">):</span>
                <span class="s1">node = nodes.Const(</span><span class="s2">None, </span><span class="s1">lineno=token.lineno)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">node = nodes.Name(token.value</span><span class="s2">, </span><span class="s3">&quot;load&quot;</span><span class="s2">, </span><span class="s1">lineno=token.lineno)</span>
            <span class="s1">next(self.stream)</span>
        <span class="s2">elif </span><span class="s1">token.type == </span><span class="s3">&quot;string&quot;</span><span class="s1">:</span>
            <span class="s1">next(self.stream)</span>
            <span class="s1">buf = [token.value]</span>
            <span class="s1">lineno = token.lineno</span>
            <span class="s2">while </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;string&quot;</span><span class="s1">:</span>
                <span class="s1">buf.append(self.stream.current.value)</span>
                <span class="s1">next(self.stream)</span>
            <span class="s1">node = nodes.Const(</span><span class="s3">&quot;&quot;</span><span class="s1">.join(buf)</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>
        <span class="s2">elif </span><span class="s1">token.type </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;integer&quot;</span><span class="s2">, </span><span class="s3">&quot;float&quot;</span><span class="s1">):</span>
            <span class="s1">next(self.stream)</span>
            <span class="s1">node = nodes.Const(token.value</span><span class="s2">, </span><span class="s1">lineno=token.lineno)</span>
        <span class="s2">elif </span><span class="s1">token.type == </span><span class="s3">&quot;lparen&quot;</span><span class="s1">:</span>
            <span class="s1">next(self.stream)</span>
            <span class="s1">node = self.parse_tuple(explicit_parentheses=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">self.stream.expect(</span><span class="s3">&quot;rparen&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">token.type == </span><span class="s3">&quot;lbracket&quot;</span><span class="s1">:</span>
            <span class="s1">node = self.parse_list()</span>
        <span class="s2">elif </span><span class="s1">token.type == </span><span class="s3">&quot;lbrace&quot;</span><span class="s1">:</span>
            <span class="s1">node = self.parse_dict()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.fail(</span><span class="s3">f&quot;unexpected </span><span class="s2">{</span><span class="s1">describe_token(token)</span><span class="s2">!r}</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">token.lineno)</span>
        <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">parse_tuple(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">simplified: bool = </span><span class="s2">False,</span>
        <span class="s1">with_condexpr: bool = </span><span class="s2">True,</span>
        <span class="s1">extra_end_rules: t.Optional[t.Tuple[str</span><span class="s2">, </span><span class="s1">...]] = </span><span class="s2">None,</span>
        <span class="s1">explicit_parentheses: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; t.Union[nodes.Tuple</span><span class="s2">, </span><span class="s1">nodes.Expr]:</span>
        <span class="s0">&quot;&quot;&quot;Works like `parse_expression` but if multiple expressions are 
        delimited by a comma a :class:`~jinja2.nodes.Tuple` node is created. 
        This method could also return a regular expression instead of a tuple 
        if no commas where found. 
 
        The default parsing mode is a full tuple.  If `simplified` is `True` 
        only names and literals are parsed.  The `no_condexpr` parameter is 
        forwarded to :meth:`parse_expression`. 
 
        Because tuples do not require delimiters and may end in a bogus comma 
        an extra hint is needed that marks the end of a tuple.  For example 
        for loops support tuples between `for` and `in`.  In that case the 
        `extra_end_rules` is set to ``['name:in']``. 
 
        `explicit_parentheses` is true if the parsing was triggered by an 
        expression in parentheses.  This is used to figure out if an empty 
        tuple is a valid expression or not. 
        &quot;&quot;&quot;</span>
        <span class="s1">lineno = self.stream.current.lineno</span>
        <span class="s2">if </span><span class="s1">simplified:</span>
            <span class="s1">parse = self.parse_primary</span>
        <span class="s2">elif </span><span class="s1">with_condexpr:</span>
            <span class="s1">parse = self.parse_expression</span>
        <span class="s2">else</span><span class="s1">:</span>

            <span class="s2">def </span><span class="s1">parse() -&gt; nodes.Expr:</span>
                <span class="s2">return </span><span class="s1">self.parse_expression(with_condexpr=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">args: t.List[nodes.Expr] = []</span>
        <span class="s1">is_tuple = </span><span class="s2">False</span>

        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">args:</span>
                <span class="s1">self.stream.expect(</span><span class="s3">&quot;comma&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.is_tuple_end(extra_end_rules):</span>
                <span class="s2">break</span>
            <span class="s1">args.append(parse())</span>
            <span class="s2">if </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;comma&quot;</span><span class="s1">:</span>
                <span class="s1">is_tuple = </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">break</span>
            <span class="s1">lineno = self.stream.current.lineno</span>

        <span class="s2">if not </span><span class="s1">is_tuple:</span>
            <span class="s2">if </span><span class="s1">args:</span>
                <span class="s2">return </span><span class="s1">args[</span><span class="s4">0</span><span class="s1">]</span>

            <span class="s5"># if we don't have explicit parentheses, an empty tuple is</span>
            <span class="s5"># not a valid expression.  This would mean nothing (literally</span>
            <span class="s5"># nothing) in the spot of an expression would be an empty</span>
            <span class="s5"># tuple.</span>
            <span class="s2">if not </span><span class="s1">explicit_parentheses:</span>
                <span class="s1">self.fail(</span>
                    <span class="s3">&quot;Expected an expression,&quot;</span>
                    <span class="s3">f&quot; got </span><span class="s2">{</span><span class="s1">describe_token(self.stream.current)</span><span class="s2">!r}</span><span class="s3">&quot;</span>
                <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">nodes.Tuple(args</span><span class="s2">, </span><span class="s3">&quot;load&quot;</span><span class="s2">, </span><span class="s1">lineno=lineno)</span>

    <span class="s2">def </span><span class="s1">parse_list(self) -&gt; nodes.List:</span>
        <span class="s1">token = self.stream.expect(</span><span class="s3">&quot;lbracket&quot;</span><span class="s1">)</span>
        <span class="s1">items: t.List[nodes.Expr] = []</span>
        <span class="s2">while </span><span class="s1">self.stream.current.type != </span><span class="s3">&quot;rbracket&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">items:</span>
                <span class="s1">self.stream.expect(</span><span class="s3">&quot;comma&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;rbracket&quot;</span><span class="s1">:</span>
                <span class="s2">break</span>
            <span class="s1">items.append(self.parse_expression())</span>
        <span class="s1">self.stream.expect(</span><span class="s3">&quot;rbracket&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">nodes.List(items</span><span class="s2">, </span><span class="s1">lineno=token.lineno)</span>

    <span class="s2">def </span><span class="s1">parse_dict(self) -&gt; nodes.Dict:</span>
        <span class="s1">token = self.stream.expect(</span><span class="s3">&quot;lbrace&quot;</span><span class="s1">)</span>
        <span class="s1">items: t.List[nodes.Pair] = []</span>
        <span class="s2">while </span><span class="s1">self.stream.current.type != </span><span class="s3">&quot;rbrace&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">items:</span>
                <span class="s1">self.stream.expect(</span><span class="s3">&quot;comma&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;rbrace&quot;</span><span class="s1">:</span>
                <span class="s2">break</span>
            <span class="s1">key = self.parse_expression()</span>
            <span class="s1">self.stream.expect(</span><span class="s3">&quot;colon&quot;</span><span class="s1">)</span>
            <span class="s1">value = self.parse_expression()</span>
            <span class="s1">items.append(nodes.Pair(key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">lineno=key.lineno))</span>
        <span class="s1">self.stream.expect(</span><span class="s3">&quot;rbrace&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">nodes.Dict(items</span><span class="s2">, </span><span class="s1">lineno=token.lineno)</span>

    <span class="s2">def </span><span class="s1">parse_postfix(self</span><span class="s2">, </span><span class="s1">node: nodes.Expr) -&gt; nodes.Expr:</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">token_type = self.stream.current.type</span>
            <span class="s2">if </span><span class="s1">token_type == </span><span class="s3">&quot;dot&quot; </span><span class="s2">or </span><span class="s1">token_type == </span><span class="s3">&quot;lbracket&quot;</span><span class="s1">:</span>
                <span class="s1">node = self.parse_subscript(node)</span>
            <span class="s5"># calls are valid both after postfix expressions (getattr</span>
            <span class="s5"># and getitem) as well as filters and tests</span>
            <span class="s2">elif </span><span class="s1">token_type == </span><span class="s3">&quot;lparen&quot;</span><span class="s1">:</span>
                <span class="s1">node = self.parse_call(node)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">break</span>
        <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">parse_filter_expr(self</span><span class="s2">, </span><span class="s1">node: nodes.Expr) -&gt; nodes.Expr:</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">token_type = self.stream.current.type</span>
            <span class="s2">if </span><span class="s1">token_type == </span><span class="s3">&quot;pipe&quot;</span><span class="s1">:</span>
                <span class="s1">node = self.parse_filter(node)  </span><span class="s5"># type: ignore</span>
            <span class="s2">elif </span><span class="s1">token_type == </span><span class="s3">&quot;name&quot; </span><span class="s2">and </span><span class="s1">self.stream.current.value == </span><span class="s3">&quot;is&quot;</span><span class="s1">:</span>
                <span class="s1">node = self.parse_test(node)</span>
            <span class="s5"># calls are valid both after postfix expressions (getattr</span>
            <span class="s5"># and getitem) as well as filters and tests</span>
            <span class="s2">elif </span><span class="s1">token_type == </span><span class="s3">&quot;lparen&quot;</span><span class="s1">:</span>
                <span class="s1">node = self.parse_call(node)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">break</span>
        <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">parse_subscript(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">node: nodes.Expr</span>
    <span class="s1">) -&gt; t.Union[nodes.Getattr</span><span class="s2">, </span><span class="s1">nodes.Getitem]:</span>
        <span class="s1">token = next(self.stream)</span>
        <span class="s1">arg: nodes.Expr</span>

        <span class="s2">if </span><span class="s1">token.type == </span><span class="s3">&quot;dot&quot;</span><span class="s1">:</span>
            <span class="s1">attr_token = self.stream.current</span>
            <span class="s1">next(self.stream)</span>
            <span class="s2">if </span><span class="s1">attr_token.type == </span><span class="s3">&quot;name&quot;</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">nodes.Getattr(</span>
                    <span class="s1">node</span><span class="s2">, </span><span class="s1">attr_token.value</span><span class="s2">, </span><span class="s3">&quot;load&quot;</span><span class="s2">, </span><span class="s1">lineno=token.lineno</span>
                <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">attr_token.type != </span><span class="s3">&quot;integer&quot;</span><span class="s1">:</span>
                <span class="s1">self.fail(</span><span class="s3">&quot;expected name or number&quot;</span><span class="s2">, </span><span class="s1">attr_token.lineno)</span>
            <span class="s1">arg = nodes.Const(attr_token.value</span><span class="s2">, </span><span class="s1">lineno=attr_token.lineno)</span>
            <span class="s2">return </span><span class="s1">nodes.Getitem(node</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s3">&quot;load&quot;</span><span class="s2">, </span><span class="s1">lineno=token.lineno)</span>
        <span class="s2">if </span><span class="s1">token.type == </span><span class="s3">&quot;lbracket&quot;</span><span class="s1">:</span>
            <span class="s1">args: t.List[nodes.Expr] = []</span>
            <span class="s2">while </span><span class="s1">self.stream.current.type != </span><span class="s3">&quot;rbracket&quot;</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">args:</span>
                    <span class="s1">self.stream.expect(</span><span class="s3">&quot;comma&quot;</span><span class="s1">)</span>
                <span class="s1">args.append(self.parse_subscribed())</span>
            <span class="s1">self.stream.expect(</span><span class="s3">&quot;rbracket&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">len(args) == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">arg = args[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">arg = nodes.Tuple(args</span><span class="s2">, </span><span class="s3">&quot;load&quot;</span><span class="s2">, </span><span class="s1">lineno=token.lineno)</span>
            <span class="s2">return </span><span class="s1">nodes.Getitem(node</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s3">&quot;load&quot;</span><span class="s2">, </span><span class="s1">lineno=token.lineno)</span>
        <span class="s1">self.fail(</span><span class="s3">&quot;expected subscript expression&quot;</span><span class="s2">, </span><span class="s1">token.lineno)</span>

    <span class="s2">def </span><span class="s1">parse_subscribed(self) -&gt; nodes.Expr:</span>
        <span class="s1">lineno = self.stream.current.lineno</span>
        <span class="s1">args: t.List[t.Optional[nodes.Expr]]</span>

        <span class="s2">if </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;colon&quot;</span><span class="s1">:</span>
            <span class="s1">next(self.stream)</span>
            <span class="s1">args = [</span><span class="s2">None</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">node = self.parse_expression()</span>
            <span class="s2">if </span><span class="s1">self.stream.current.type != </span><span class="s3">&quot;colon&quot;</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">node</span>
            <span class="s1">next(self.stream)</span>
            <span class="s1">args = [node]</span>

        <span class="s2">if </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;colon&quot;</span><span class="s1">:</span>
            <span class="s1">args.append(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">self.stream.current.type </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">&quot;rbracket&quot;</span><span class="s2">, </span><span class="s3">&quot;comma&quot;</span><span class="s1">):</span>
            <span class="s1">args.append(self.parse_expression())</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">args.append(</span><span class="s2">None</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;colon&quot;</span><span class="s1">:</span>
            <span class="s1">next(self.stream)</span>
            <span class="s2">if </span><span class="s1">self.stream.current.type </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">&quot;rbracket&quot;</span><span class="s2">, </span><span class="s3">&quot;comma&quot;</span><span class="s1">):</span>
                <span class="s1">args.append(self.parse_expression())</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">args.append(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">args.append(</span><span class="s2">None</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">nodes.Slice(lineno=lineno</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">parse_call_args(self) -&gt; t.Tuple:</span>
        <span class="s1">token = self.stream.expect(</span><span class="s3">&quot;lparen&quot;</span><span class="s1">)</span>
        <span class="s1">args = []</span>
        <span class="s1">kwargs = []</span>
        <span class="s1">dyn_args = </span><span class="s2">None</span>
        <span class="s1">dyn_kwargs = </span><span class="s2">None</span>
        <span class="s1">require_comma = </span><span class="s2">False</span>

        <span class="s2">def </span><span class="s1">ensure(expr: bool) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">expr:</span>
                <span class="s1">self.fail(</span><span class="s3">&quot;invalid syntax for function call expression&quot;</span><span class="s2">, </span><span class="s1">token.lineno)</span>

        <span class="s2">while </span><span class="s1">self.stream.current.type != </span><span class="s3">&quot;rparen&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">require_comma:</span>
                <span class="s1">self.stream.expect(</span><span class="s3">&quot;comma&quot;</span><span class="s1">)</span>

                <span class="s5"># support for trailing comma</span>
                <span class="s2">if </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;rparen&quot;</span><span class="s1">:</span>
                    <span class="s2">break</span>

            <span class="s2">if </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;mul&quot;</span><span class="s1">:</span>
                <span class="s1">ensure(dyn_args </span><span class="s2">is None and </span><span class="s1">dyn_kwargs </span><span class="s2">is None</span><span class="s1">)</span>
                <span class="s1">next(self.stream)</span>
                <span class="s1">dyn_args = self.parse_expression()</span>
            <span class="s2">elif </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;pow&quot;</span><span class="s1">:</span>
                <span class="s1">ensure(dyn_kwargs </span><span class="s2">is None</span><span class="s1">)</span>
                <span class="s1">next(self.stream)</span>
                <span class="s1">dyn_kwargs = self.parse_expression()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">self.stream.current.type == </span><span class="s3">&quot;name&quot;</span>
                    <span class="s2">and </span><span class="s1">self.stream.look().type == </span><span class="s3">&quot;assign&quot;</span>
                <span class="s1">):</span>
                    <span class="s5"># Parsing a kwarg</span>
                    <span class="s1">ensure(dyn_kwargs </span><span class="s2">is None</span><span class="s1">)</span>
                    <span class="s1">key = self.stream.current.value</span>
                    <span class="s1">self.stream.skip(</span><span class="s4">2</span><span class="s1">)</span>
                    <span class="s1">value = self.parse_expression()</span>
                    <span class="s1">kwargs.append(nodes.Keyword(key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">lineno=value.lineno))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s5"># Parsing an arg</span>
                    <span class="s1">ensure(dyn_args </span><span class="s2">is None and </span><span class="s1">dyn_kwargs </span><span class="s2">is None and not </span><span class="s1">kwargs)</span>
                    <span class="s1">args.append(self.parse_expression())</span>

            <span class="s1">require_comma = </span><span class="s2">True</span>

        <span class="s1">self.stream.expect(</span><span class="s3">&quot;rparen&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">dyn_args</span><span class="s2">, </span><span class="s1">dyn_kwargs</span>

    <span class="s2">def </span><span class="s1">parse_call(self</span><span class="s2">, </span><span class="s1">node: nodes.Expr) -&gt; nodes.Call:</span>
        <span class="s5"># The lparen will be expected in parse_call_args, but the lineno</span>
        <span class="s5"># needs to be recorded before the stream is advanced.</span>
        <span class="s1">token = self.stream.current</span>
        <span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">dyn_args</span><span class="s2">, </span><span class="s1">dyn_kwargs = self.parse_call_args()</span>
        <span class="s2">return </span><span class="s1">nodes.Call(node</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">dyn_args</span><span class="s2">, </span><span class="s1">dyn_kwargs</span><span class="s2">, </span><span class="s1">lineno=token.lineno)</span>

    <span class="s2">def </span><span class="s1">parse_filter(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">node: t.Optional[nodes.Expr]</span><span class="s2">, </span><span class="s1">start_inline: bool = </span><span class="s2">False</span>
    <span class="s1">) -&gt; t.Optional[nodes.Expr]:</span>
        <span class="s2">while </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;pipe&quot; </span><span class="s2">or </span><span class="s1">start_inline:</span>
            <span class="s2">if not </span><span class="s1">start_inline:</span>
                <span class="s1">next(self.stream)</span>
            <span class="s1">token = self.stream.expect(</span><span class="s3">&quot;name&quot;</span><span class="s1">)</span>
            <span class="s1">name = token.value</span>
            <span class="s2">while </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;dot&quot;</span><span class="s1">:</span>
                <span class="s1">next(self.stream)</span>
                <span class="s1">name += </span><span class="s3">&quot;.&quot; </span><span class="s1">+ self.stream.expect(</span><span class="s3">&quot;name&quot;</span><span class="s1">).value</span>
            <span class="s2">if </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;lparen&quot;</span><span class="s1">:</span>
                <span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">dyn_args</span><span class="s2">, </span><span class="s1">dyn_kwargs = self.parse_call_args()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">args = []</span>
                <span class="s1">kwargs = []</span>
                <span class="s1">dyn_args = dyn_kwargs = </span><span class="s2">None</span>
            <span class="s1">node = nodes.Filter(</span>
                <span class="s1">node</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">dyn_args</span><span class="s2">, </span><span class="s1">dyn_kwargs</span><span class="s2">, </span><span class="s1">lineno=token.lineno</span>
            <span class="s1">)</span>
            <span class="s1">start_inline = </span><span class="s2">False</span>
        <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">parse_test(self</span><span class="s2">, </span><span class="s1">node: nodes.Expr) -&gt; nodes.Expr:</span>
        <span class="s1">token = next(self.stream)</span>
        <span class="s2">if </span><span class="s1">self.stream.current.test(</span><span class="s3">&quot;name:not&quot;</span><span class="s1">):</span>
            <span class="s1">next(self.stream)</span>
            <span class="s1">negated = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">negated = </span><span class="s2">False</span>
        <span class="s1">name = self.stream.expect(</span><span class="s3">&quot;name&quot;</span><span class="s1">).value</span>
        <span class="s2">while </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;dot&quot;</span><span class="s1">:</span>
            <span class="s1">next(self.stream)</span>
            <span class="s1">name += </span><span class="s3">&quot;.&quot; </span><span class="s1">+ self.stream.expect(</span><span class="s3">&quot;name&quot;</span><span class="s1">).value</span>
        <span class="s1">dyn_args = dyn_kwargs = </span><span class="s2">None</span>
        <span class="s1">kwargs = []</span>
        <span class="s2">if </span><span class="s1">self.stream.current.type == </span><span class="s3">&quot;lparen&quot;</span><span class="s1">:</span>
            <span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">dyn_args</span><span class="s2">, </span><span class="s1">dyn_kwargs = self.parse_call_args()</span>
        <span class="s2">elif </span><span class="s1">(</span>
            <span class="s1">self.stream.current.type</span>
            <span class="s2">in </span><span class="s1">{</span>
                <span class="s3">&quot;name&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;string&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;integer&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;float&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;lparen&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;lbracket&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;lbrace&quot;</span><span class="s2">,</span>
            <span class="s1">}</span>
            <span class="s2">and not </span><span class="s1">self.stream.current.test_any(</span><span class="s3">&quot;name:else&quot;</span><span class="s2">, </span><span class="s3">&quot;name:or&quot;</span><span class="s2">, </span><span class="s3">&quot;name:and&quot;</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s2">if </span><span class="s1">self.stream.current.test(</span><span class="s3">&quot;name:is&quot;</span><span class="s1">):</span>
                <span class="s1">self.fail(</span><span class="s3">&quot;You cannot chain multiple tests with is&quot;</span><span class="s1">)</span>
            <span class="s1">arg_node = self.parse_primary()</span>
            <span class="s1">arg_node = self.parse_postfix(arg_node)</span>
            <span class="s1">args = [arg_node]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">args = []</span>
        <span class="s1">node = nodes.Test(</span>
            <span class="s1">node</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">dyn_args</span><span class="s2">, </span><span class="s1">dyn_kwargs</span><span class="s2">, </span><span class="s1">lineno=token.lineno</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">negated:</span>
            <span class="s1">node = nodes.Not(node</span><span class="s2">, </span><span class="s1">lineno=token.lineno)</span>
        <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">subparse(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">end_tokens: t.Optional[t.Tuple[str</span><span class="s2">, </span><span class="s1">...]] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; t.List[nodes.Node]:</span>
        <span class="s1">body: t.List[nodes.Node] = []</span>
        <span class="s1">data_buffer: t.List[nodes.Node] = []</span>
        <span class="s1">add_data = data_buffer.append</span>

        <span class="s2">if </span><span class="s1">end_tokens </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._end_token_stack.append(end_tokens)</span>

        <span class="s2">def </span><span class="s1">flush_data() -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">data_buffer:</span>
                <span class="s1">lineno = data_buffer[</span><span class="s4">0</span><span class="s1">].lineno</span>
                <span class="s1">body.append(nodes.Output(data_buffer[:]</span><span class="s2">, </span><span class="s1">lineno=lineno))</span>
                <span class="s2">del </span><span class="s1">data_buffer[:]</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">while </span><span class="s1">self.stream:</span>
                <span class="s1">token = self.stream.current</span>
                <span class="s2">if </span><span class="s1">token.type == </span><span class="s3">&quot;data&quot;</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">token.value:</span>
                        <span class="s1">add_data(nodes.TemplateData(token.value</span><span class="s2">, </span><span class="s1">lineno=token.lineno))</span>
                    <span class="s1">next(self.stream)</span>
                <span class="s2">elif </span><span class="s1">token.type == </span><span class="s3">&quot;variable_begin&quot;</span><span class="s1">:</span>
                    <span class="s1">next(self.stream)</span>
                    <span class="s1">add_data(self.parse_tuple(with_condexpr=</span><span class="s2">True</span><span class="s1">))</span>
                    <span class="s1">self.stream.expect(</span><span class="s3">&quot;variable_end&quot;</span><span class="s1">)</span>
                <span class="s2">elif </span><span class="s1">token.type == </span><span class="s3">&quot;block_begin&quot;</span><span class="s1">:</span>
                    <span class="s1">flush_data()</span>
                    <span class="s1">next(self.stream)</span>
                    <span class="s2">if </span><span class="s1">end_tokens </span><span class="s2">is not None and </span><span class="s1">self.stream.current.test_any(</span>
                        <span class="s1">*end_tokens</span>
                    <span class="s1">):</span>
                        <span class="s2">return </span><span class="s1">body</span>
                    <span class="s1">rv = self.parse_statement()</span>
                    <span class="s2">if </span><span class="s1">isinstance(rv</span><span class="s2">, </span><span class="s1">list):</span>
                        <span class="s1">body.extend(rv)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">body.append(rv)</span>
                    <span class="s1">self.stream.expect(</span><span class="s3">&quot;block_end&quot;</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">AssertionError(</span><span class="s3">&quot;internal parsing error&quot;</span><span class="s1">)</span>

            <span class="s1">flush_data()</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">end_tokens </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self._end_token_stack.pop()</span>
        <span class="s2">return </span><span class="s1">body</span>

    <span class="s2">def </span><span class="s1">parse(self) -&gt; nodes.Template:</span>
        <span class="s0">&quot;&quot;&quot;Parse the whole template into a `Template` node.&quot;&quot;&quot;</span>
        <span class="s1">result = nodes.Template(self.subparse()</span><span class="s2">, </span><span class="s1">lineno=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">result.set_environment(self.environment)</span>
        <span class="s2">return </span><span class="s1">result</span>
</pre>
</body>
</html>