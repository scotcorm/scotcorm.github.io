<html>
<head>
<title>test_datetime64.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_datetime64.py</font>
</center></td></tr></table>
<pre><span class="s0"># Arithmetic tests for DataFrame/Series/Index/Array classes that should</span>
<span class="s0"># behave identically.</span>
<span class="s0"># Specifically for datetime64 and datetime64tz dtypes</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">datetime</span><span class="s2">,</span>
    <span class="s1">time</span><span class="s2">,</span>
    <span class="s1">timedelta</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">product</span><span class="s2">,</span>
    <span class="s1">starmap</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">import </span><span class="s1">pytz</span>

<span class="s2">from </span><span class="s1">pandas._libs.tslibs.conversion </span><span class="s2">import </span><span class="s1">localize_pydatetime</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs.offsets </span><span class="s2">import </span><span class="s1">shift_months</span>
<span class="s2">from </span><span class="s1">pandas.errors </span><span class="s2">import </span><span class="s1">PerformanceWarning</span>

<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DateOffset</span><span class="s2">,</span>
    <span class="s1">DatetimeIndex</span><span class="s2">,</span>
    <span class="s1">NaT</span><span class="s2">,</span>
    <span class="s1">Period</span><span class="s2">,</span>
    <span class="s1">Series</span><span class="s2">,</span>
    <span class="s1">Timedelta</span><span class="s2">,</span>
    <span class="s1">TimedeltaIndex</span><span class="s2">,</span>
    <span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">date_range</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas._testing </span><span class="s2">as </span><span class="s1">tm</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DatetimeArray</span><span class="s2">,</span>
    <span class="s1">TimedeltaArray</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.ops </span><span class="s2">import </span><span class="s1">roperator</span>
<span class="s2">from </span><span class="s1">pandas.tests.arithmetic.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">assert_cannot_add</span><span class="s2">,</span>
    <span class="s1">assert_invalid_addsub_type</span><span class="s2">,</span>
    <span class="s1">assert_invalid_comparison</span><span class="s2">,</span>
    <span class="s1">get_upcast_box</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s0"># ------------------------------------------------------------------</span>
<span class="s0"># Comparisons</span>


<span class="s2">class </span><span class="s1">TestDatetime64ArrayLikeComparisons:</span>
    <span class="s0"># Comparison tests for datetime64 vectors fully parametrized over</span>
    <span class="s0">#  DataFrame/Series/DatetimeIndex/DatetimeArray.  Ideally all comparison</span>
    <span class="s0">#  tests will eventually end up here.</span>

    <span class="s2">def </span><span class="s1">test_compare_zerodim(self</span><span class="s2">, </span><span class="s1">tz_naive_fixture</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># Test comparison with zero-dimensional array is unboxed</span>
        <span class="s1">tz = tz_naive_fixture</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">dti = date_range(</span><span class="s3">&quot;20130101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">tz=tz)</span>

        <span class="s1">other = np.array(dti.to_numpy()[</span><span class="s4">0</span><span class="s1">])</span>

        <span class="s1">dtarr = tm.box_expected(dti</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">xbox = get_upcast_box(dtarr</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">result = dtarr &lt;= other</span>
        <span class="s1">expected = np.array([</span><span class="s2">True, False, False</span><span class="s1">])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;other&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s3">&quot;foo&quot;</span><span class="s2">,</span>
            <span class="s1">-</span><span class="s4">1</span><span class="s2">,</span>
            <span class="s4">99</span><span class="s2">,</span>
            <span class="s4">4.0</span><span class="s2">,</span>
            <span class="s1">object()</span><span class="s2">,</span>
            <span class="s1">timedelta(days=</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s0"># GH#19800, GH#19301 datetime.date comparison raises to</span>
            <span class="s0">#  match DatetimeIndex/Timestamp.  This also matches the behavior</span>
            <span class="s0">#  of stdlib datetime.datetime</span>
            <span class="s1">datetime(</span><span class="s4">2001</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">).date()</span><span class="s2">,</span>
            <span class="s0"># GH#19301 None and NaN are *not* cast to NaT for comparisons</span>
            <span class="s2">None,</span>
            <span class="s1">np.nan</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dt64arr_cmp_scalar_invalid(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">tz_naive_fixture</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#22074, GH#15966</span>
        <span class="s1">tz = tz_naive_fixture</span>

        <span class="s1">rng = date_range(</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">dtarr = tm.box_expected(rng</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">assert_invalid_comparison(dtarr</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">box_with_array)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;other&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s0"># GH#4968 invalid date/int comparisons</span>
            <span class="s1">list(range(</span><span class="s4">10</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">np.arange(</span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">np.arange(</span><span class="s4">10</span><span class="s1">).astype(np.float32)</span><span class="s2">,</span>
            <span class="s1">np.arange(</span><span class="s4">10</span><span class="s1">).astype(object)</span><span class="s2">,</span>
            <span class="s1">pd.timedelta_range(</span><span class="s3">&quot;1ns&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">).array</span><span class="s2">,</span>
            <span class="s1">np.array(pd.timedelta_range(</span><span class="s3">&quot;1ns&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">list(pd.timedelta_range(</span><span class="s3">&quot;1ns&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">pd.timedelta_range(</span><span class="s3">&quot;1 Day&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">).astype(object)</span><span class="s2">,</span>
            <span class="s1">pd.period_range(</span><span class="s3">&quot;1971-01-01&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">).array</span><span class="s2">,</span>
            <span class="s1">pd.period_range(</span><span class="s3">&quot;1971-01-01&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">).astype(object)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dt64arr_cmp_arraylike_invalid(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">tz_naive_fixture</span><span class="s2">, </span><span class="s1">box_with_array</span>
    <span class="s1">):</span>
        <span class="s1">tz = tz_naive_fixture</span>

        <span class="s1">dta = date_range(</span><span class="s3">&quot;1970-01-01&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;ns&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">tz=tz)._data</span>
        <span class="s1">obj = tm.box_expected(dta</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">assert_invalid_comparison(obj</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">box_with_array)</span>

    <span class="s2">def </span><span class="s1">test_dt64arr_cmp_mixed_invalid(self</span><span class="s2">, </span><span class="s1">tz_naive_fixture):</span>
        <span class="s1">tz = tz_naive_fixture</span>

        <span class="s1">dta = date_range(</span><span class="s3">&quot;1970-01-01&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;h&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">tz=tz)._data</span>

        <span class="s1">other = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">dta[</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Timedelta(days=</span><span class="s4">1</span><span class="s1">)])</span>
        <span class="s1">result = dta == other</span>
        <span class="s1">expected = np.array([</span><span class="s2">False, False, False, True, False</span><span class="s1">])</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = dta != other</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">~expected)</span>

        <span class="s1">msg = </span><span class="s3">&quot;Invalid comparison between|Cannot compare type|not supported between&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dta &lt; other</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dta &gt; other</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dta &lt;= other</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dta &gt;= other</span>

    <span class="s2">def </span><span class="s1">test_dt64arr_nat_comparison(self</span><span class="s2">, </span><span class="s1">tz_naive_fixture</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#22242, GH#22163 DataFrame considered NaT == ts incorrectly</span>
        <span class="s1">tz = tz_naive_fixture</span>
        <span class="s1">box = box_with_array</span>

        <span class="s1">ts = Timestamp(</span><span class="s3">&quot;2021-01-01&quot;</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">ser = Series([ts</span><span class="s2">, </span><span class="s1">NaT])</span>

        <span class="s1">obj = tm.box_expected(ser</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">xbox = get_upcast_box(obj</span><span class="s2">, </span><span class="s1">ts</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">expected = Series([</span><span class="s2">True, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.bool_)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>

        <span class="s1">result = obj == ts</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestDatetime64SeriesComparison:</span>
    <span class="s0"># TODO: moved from tests.series.test_operators; needs cleanup</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;pair&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s1">[Timestamp(</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2011-01-03&quot;</span><span class="s1">)]</span><span class="s2">,</span>
                <span class="s1">[NaT</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2011-01-03&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">[Timedelta(</span><span class="s3">&quot;1 days&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">Timedelta(</span><span class="s3">&quot;3 days&quot;</span><span class="s1">)]</span><span class="s2">,</span>
                <span class="s1">[NaT</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">Timedelta(</span><span class="s3">&quot;3 days&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">[Period(</span><span class="s3">&quot;2011-01&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;M&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">Period(</span><span class="s3">&quot;2011-03&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;M&quot;</span><span class="s1">)]</span><span class="s2">,</span>
                <span class="s1">[NaT</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">Period(</span><span class="s3">&quot;2011-03&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;M&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;reverse&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s1">object])</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;op, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(operator.eq</span><span class="s2">, </span><span class="s1">Series([</span><span class="s2">False, False, True</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s1">(operator.ne</span><span class="s2">, </span><span class="s1">Series([</span><span class="s2">True, True, False</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s1">(operator.lt</span><span class="s2">, </span><span class="s1">Series([</span><span class="s2">False, False, False</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s1">(operator.gt</span><span class="s2">, </span><span class="s1">Series([</span><span class="s2">False, False, False</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s1">(operator.ge</span><span class="s2">, </span><span class="s1">Series([</span><span class="s2">False, False, True</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s1">(operator.le</span><span class="s2">, </span><span class="s1">Series([</span><span class="s2">False, False, True</span><span class="s1">]))</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_nat_comparisons(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">,</span>
        <span class="s1">index_or_series</span><span class="s2">,</span>
        <span class="s1">reverse</span><span class="s2">,</span>
        <span class="s1">pair</span><span class="s2">,</span>
        <span class="s1">op</span><span class="s2">,</span>
        <span class="s1">expected</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">box = index_or_series</span>
        <span class="s1">l</span><span class="s2">, </span><span class="s1">r = pair</span>
        <span class="s2">if </span><span class="s1">reverse:</span>
            <span class="s0"># add lhs / rhs switched data</span>
            <span class="s1">l</span><span class="s2">, </span><span class="s1">r = r</span><span class="s2">, </span><span class="s1">l</span>

        <span class="s1">left = Series(l</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">right = box(r</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

        <span class="s1">result = op(left</span><span class="s2">, </span><span class="s1">right)</span>

        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;data&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2011-01-03&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">[Timedelta(</span><span class="s3">&quot;1 days&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">Timedelta(</span><span class="s3">&quot;3 days&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">[Period(</span><span class="s3">&quot;2011-01&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;M&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">Period(</span><span class="s3">&quot;2011-03&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;M&quot;</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s1">object])</span>
    <span class="s2">def </span><span class="s1">test_nat_comparisons_scalar(self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">box = box_with_array</span>

        <span class="s1">left = Series(data</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">left = tm.box_expected(left</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">xbox = get_upcast_box(left</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">expected = [</span><span class="s2">False, False, False</span><span class="s1">]</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s2">if </span><span class="s1">box </span><span class="s2">is </span><span class="s1">pd.array </span><span class="s2">and </span><span class="s1">dtype </span><span class="s2">is </span><span class="s1">object:</span>
            <span class="s1">expected = pd.array(expected</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;bool&quot;</span><span class="s1">)</span>

        <span class="s1">tm.assert_equal(left == NaT</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_equal(NaT == left</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">expected = [</span><span class="s2">True, True, True</span><span class="s1">]</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s2">if </span><span class="s1">box </span><span class="s2">is </span><span class="s1">pd.array </span><span class="s2">and </span><span class="s1">dtype </span><span class="s2">is </span><span class="s1">object:</span>
            <span class="s1">expected = pd.array(expected</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;bool&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_equal(left != NaT</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_equal(NaT != left</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">expected = [</span><span class="s2">False, False, False</span><span class="s1">]</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s2">if </span><span class="s1">box </span><span class="s2">is </span><span class="s1">pd.array </span><span class="s2">and </span><span class="s1">dtype </span><span class="s2">is </span><span class="s1">object:</span>
            <span class="s1">expected = pd.array(expected</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;bool&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_equal(left &lt; NaT</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_equal(NaT &gt; left</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_equal(left &lt;= NaT</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_equal(NaT &gt;= left</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">tm.assert_equal(left &gt; NaT</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_equal(NaT &lt; left</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_equal(left &gt;= NaT</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_equal(NaT &lt;= left</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;val&quot;</span><span class="s2">, </span><span class="s1">[datetime(</span><span class="s4">2000</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s4">2000</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_series_comparison_scalars(self</span><span class="s2">, </span><span class="s1">val):</span>
        <span class="s1">series = Series(date_range(</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">))</span>

        <span class="s1">result = series &gt; val</span>
        <span class="s1">expected = Series([x &gt; val </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">series])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;left,right&quot;</span><span class="s2">, </span><span class="s1">[(</span><span class="s3">&quot;lt&quot;</span><span class="s2">, </span><span class="s3">&quot;gt&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;le&quot;</span><span class="s2">, </span><span class="s3">&quot;ge&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;eq&quot;</span><span class="s2">, </span><span class="s3">&quot;eq&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;ne&quot;</span><span class="s2">, </span><span class="s3">&quot;ne&quot;</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_timestamp_compare_series(self</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right):</span>
        <span class="s0"># see gh-4982</span>
        <span class="s0"># Make sure we can compare Timestamps on the right AND left hand side.</span>
        <span class="s1">ser = Series(date_range(</span><span class="s3">&quot;20010101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;dates&quot;</span><span class="s1">)</span>
        <span class="s1">s_nat = ser.copy(deep=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">ser[</span><span class="s4">0</span><span class="s1">] = Timestamp(</span><span class="s3">&quot;nat&quot;</span><span class="s1">)</span>
        <span class="s1">ser[</span><span class="s4">3</span><span class="s1">] = Timestamp(</span><span class="s3">&quot;nat&quot;</span><span class="s1">)</span>

        <span class="s1">left_f = getattr(operator</span><span class="s2">, </span><span class="s1">left)</span>
        <span class="s1">right_f = getattr(operator</span><span class="s2">, </span><span class="s1">right)</span>

        <span class="s0"># No NaT</span>
        <span class="s1">expected = left_f(ser</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20010109&quot;</span><span class="s1">))</span>
        <span class="s1">result = right_f(Timestamp(</span><span class="s3">&quot;20010109&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ser)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># NaT</span>
        <span class="s1">expected = left_f(ser</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;nat&quot;</span><span class="s1">))</span>
        <span class="s1">result = right_f(Timestamp(</span><span class="s3">&quot;nat&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ser)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># Compare to Timestamp with series containing NaT</span>
        <span class="s1">expected = left_f(s_nat</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20010109&quot;</span><span class="s1">))</span>
        <span class="s1">result = right_f(Timestamp(</span><span class="s3">&quot;20010109&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">s_nat)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># Compare to NaT with series containing NaT</span>
        <span class="s1">expected = left_f(s_nat</span><span class="s2">, </span><span class="s1">NaT)</span>
        <span class="s1">result = right_f(NaT</span><span class="s2">, </span><span class="s1">s_nat)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dt64arr_timestamp_equality(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#11034</span>

        <span class="s1">ser = Series([Timestamp(</span><span class="s3">&quot;2000-01-29 01:59:00&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-30&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT])</span>
        <span class="s1">ser = tm.box_expected(ser</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">xbox = get_upcast_box(ser</span><span class="s2">, </span><span class="s1">ser</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">result = ser != ser</span>
        <span class="s1">expected = tm.box_expected([</span><span class="s2">False, False, True</span><span class="s1">]</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">warn = FutureWarning </span><span class="s2">if </span><span class="s1">box_with_array </span><span class="s2">is </span><span class="s1">pd.DataFrame </span><span class="s2">else None</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(warn):</span>
            <span class="s0"># alignment for frame vs series comparisons deprecated</span>
            <span class="s1">result = ser != ser[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">expected = tm.box_expected([</span><span class="s2">False, True, True</span><span class="s1">]</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(warn):</span>
            <span class="s0"># alignment for frame vs series comparisons deprecated</span>
            <span class="s1">result = ser != ser[</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">expected = tm.box_expected([</span><span class="s2">True, True, True</span><span class="s1">]</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = ser == ser</span>
        <span class="s1">expected = tm.box_expected([</span><span class="s2">True, True, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(warn):</span>
            <span class="s0"># alignment for frame vs series comparisons deprecated</span>
            <span class="s1">result = ser == ser[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">expected = tm.box_expected([</span><span class="s2">True, False, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(warn):</span>
            <span class="s0"># alignment for frame vs series comparisons deprecated</span>
            <span class="s1">result = ser == ser[</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">expected = tm.box_expected([</span><span class="s2">False, False, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;datetimelike&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;20130101&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">datetime(</span><span class="s4">2013</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;2013-01-01T00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;op,expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(operator.lt</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False, False, False</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">(operator.le</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, True, False, False</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">(operator.eq</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True, False, False</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">(operator.gt</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, False, False, True</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dt64_compare_datetime_scalar(self</span><span class="s2">, </span><span class="s1">datetimelike</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s0"># GH#17965, test for ability to compare datetime64[ns] columns</span>
        <span class="s0">#  to datetimelike</span>
        <span class="s1">ser = Series(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20120101&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20130101&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">np.nan</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20130103&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">name=</span><span class="s3">&quot;A&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">result = op(ser</span><span class="s2">, </span><span class="s1">datetimelike)</span>
        <span class="s1">expected = Series(expected</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestDatetimeIndexComparisons:</span>

    <span class="s0"># TODO: moved from tests.indexes.test_base; parametrize and de-duplicate</span>
    <span class="s2">def </span><span class="s1">test_comparators(self</span><span class="s2">, </span><span class="s1">comparison_op):</span>
        <span class="s1">index = tm.makeDateIndex(</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">element = index[len(index) // </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">element = Timestamp(element).to_datetime64()</span>

        <span class="s1">arr = np.array(index)</span>
        <span class="s1">arr_result = comparison_op(arr</span><span class="s2">, </span><span class="s1">element)</span>
        <span class="s1">index_result = comparison_op(index</span><span class="s2">, </span><span class="s1">element)</span>

        <span class="s2">assert </span><span class="s1">isinstance(index_result</span><span class="s2">, </span><span class="s1">np.ndarray)</span>
        <span class="s1">tm.assert_numpy_array_equal(arr_result</span><span class="s2">, </span><span class="s1">index_result)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;other&quot;</span><span class="s2">,</span>
        <span class="s1">[datetime(</span><span class="s4">2016</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2016-01-01&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.datetime64(</span><span class="s3">&quot;2016-01-01&quot;</span><span class="s1">)]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dti_cmp_datetimelike(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">tz_naive_fixture):</span>
        <span class="s1">tz = tz_naive_fixture</span>
        <span class="s1">dti = date_range(</span><span class="s3">&quot;2016-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s2">if </span><span class="s1">tz </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">np.datetime64):</span>
                <span class="s0"># no tzaware version available</span>
                <span class="s2">return</span>
            <span class="s1">other = localize_pydatetime(other</span><span class="s2">, </span><span class="s1">dti.tzinfo)</span>

        <span class="s1">result = dti == other</span>
        <span class="s1">expected = np.array([</span><span class="s2">True, False</span><span class="s1">])</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = dti &gt; other</span>
        <span class="s1">expected = np.array([</span><span class="s2">False, True</span><span class="s1">])</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = dti &gt;= other</span>
        <span class="s1">expected = np.array([</span><span class="s2">True, True</span><span class="s1">])</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = dti &lt; other</span>
        <span class="s1">expected = np.array([</span><span class="s2">False, False</span><span class="s1">])</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = dti &lt;= other</span>
        <span class="s1">expected = np.array([</span><span class="s2">True, False</span><span class="s1">])</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s1">object])</span>
    <span class="s2">def </span><span class="s1">test_dti_cmp_nat(self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">box_with_array):</span>

        <span class="s1">left = DatetimeIndex([Timestamp(</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2011-01-03&quot;</span><span class="s1">)])</span>
        <span class="s1">right = DatetimeIndex([NaT</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2011-01-03&quot;</span><span class="s1">)])</span>

        <span class="s1">left = tm.box_expected(left</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">right = tm.box_expected(right</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">xbox = get_upcast_box(left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs = left</span><span class="s2">, </span><span class="s1">right</span>
        <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is </span><span class="s1">object:</span>
            <span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs = left.astype(object)</span><span class="s2">, </span><span class="s1">right.astype(object)</span>

        <span class="s1">result = rhs == lhs</span>
        <span class="s1">expected = np.array([</span><span class="s2">False, False, True</span><span class="s1">])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = lhs != rhs</span>
        <span class="s1">expected = np.array([</span><span class="s2">True, True, False</span><span class="s1">])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">expected = np.array([</span><span class="s2">False, False, False</span><span class="s1">])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s1">tm.assert_equal(lhs == NaT</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_equal(NaT == rhs</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">expected = np.array([</span><span class="s2">True, True, True</span><span class="s1">])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s1">tm.assert_equal(lhs != NaT</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_equal(NaT != lhs</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">expected = np.array([</span><span class="s2">False, False, False</span><span class="s1">])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s1">tm.assert_equal(lhs &lt; NaT</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_equal(NaT &gt; lhs</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dti_cmp_nat_behaves_like_float_cmp_nan(self):</span>
        <span class="s1">fidx1 = pd.Index([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">5.0</span><span class="s2">, </span><span class="s4">7.0</span><span class="s1">])</span>
        <span class="s1">fidx2 = pd.Index([</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">6.0</span><span class="s2">, </span><span class="s4">7.0</span><span class="s1">])</span>

        <span class="s1">didx1 = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;2014-01-01&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s3">&quot;2014-03-01&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s3">&quot;2014-05-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2014-07-01&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">didx2 = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;2014-02-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2014-03-01&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s3">&quot;2014-06-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2014-07-01&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">darr = np.array(</span>
            <span class="s1">[</span>
                <span class="s1">np.datetime64(</span><span class="s3">&quot;2014-02-01 00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">np.datetime64(</span><span class="s3">&quot;2014-03-01 00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">np.datetime64(</span><span class="s3">&quot;nat&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">np.datetime64(</span><span class="s3">&quot;nat&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">np.datetime64(</span><span class="s3">&quot;2014-06-01 00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">np.datetime64(</span><span class="s3">&quot;2014-07-01 00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>

        <span class="s1">cases = [(fidx1</span><span class="s2">, </span><span class="s1">fidx2)</span><span class="s2">, </span><span class="s1">(didx1</span><span class="s2">, </span><span class="s1">didx2)</span><span class="s2">, </span><span class="s1">(didx1</span><span class="s2">, </span><span class="s1">darr)]</span>

        <span class="s0"># Check pd.NaT is handles as the same as np.nan</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s2">for </span><span class="s1">idx1</span><span class="s2">, </span><span class="s1">idx2 </span><span class="s2">in </span><span class="s1">cases:</span>

                <span class="s1">result = idx1 &lt; idx2</span>
                <span class="s1">expected = np.array([</span><span class="s2">True, False, False, False, True, False</span><span class="s1">])</span>
                <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

                <span class="s1">result = idx2 &gt; idx1</span>
                <span class="s1">expected = np.array([</span><span class="s2">True, False, False, False, True, False</span><span class="s1">])</span>
                <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

                <span class="s1">result = idx1 &lt;= idx2</span>
                <span class="s1">expected = np.array([</span><span class="s2">True, False, False, False, True, True</span><span class="s1">])</span>
                <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

                <span class="s1">result = idx2 &gt;= idx1</span>
                <span class="s1">expected = np.array([</span><span class="s2">True, False, False, False, True, True</span><span class="s1">])</span>
                <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

                <span class="s1">result = idx1 == idx2</span>
                <span class="s1">expected = np.array([</span><span class="s2">False, False, False, False, False, True</span><span class="s1">])</span>
                <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

                <span class="s1">result = idx1 != idx2</span>
                <span class="s1">expected = np.array([</span><span class="s2">True, True, True, True, True, False</span><span class="s1">])</span>
                <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s2">for </span><span class="s1">idx1</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">[(fidx1</span><span class="s2">, </span><span class="s1">np.nan)</span><span class="s2">, </span><span class="s1">(didx1</span><span class="s2">, </span><span class="s1">NaT)]:</span>
                <span class="s1">result = idx1 &lt; val</span>
                <span class="s1">expected = np.array([</span><span class="s2">False, False, False, False, False, False</span><span class="s1">])</span>
                <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
                <span class="s1">result = idx1 &gt; val</span>
                <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

                <span class="s1">result = idx1 &lt;= val</span>
                <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
                <span class="s1">result = idx1 &gt;= val</span>
                <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

                <span class="s1">result = idx1 == val</span>
                <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

                <span class="s1">result = idx1 != val</span>
                <span class="s1">expected = np.array([</span><span class="s2">True, True, True, True, True, True</span><span class="s1">])</span>
                <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># Check pd.NaT is handles as the same as np.nan</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s2">for </span><span class="s1">idx1</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">[(fidx1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(didx1</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s4">2014</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))]:</span>
                <span class="s1">result = idx1 &lt; val</span>
                <span class="s1">expected = np.array([</span><span class="s2">True, False, False, False, False, False</span><span class="s1">])</span>
                <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
                <span class="s1">result = idx1 &gt; val</span>
                <span class="s1">expected = np.array([</span><span class="s2">False, False, False, False, True, True</span><span class="s1">])</span>
                <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

                <span class="s1">result = idx1 &lt;= val</span>
                <span class="s1">expected = np.array([</span><span class="s2">True, False, True, False, False, False</span><span class="s1">])</span>
                <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
                <span class="s1">result = idx1 &gt;= val</span>
                <span class="s1">expected = np.array([</span><span class="s2">False, False, True, False, True, True</span><span class="s1">])</span>
                <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

                <span class="s1">result = idx1 == val</span>
                <span class="s1">expected = np.array([</span><span class="s2">False, False, True, False, False, False</span><span class="s1">])</span>
                <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

                <span class="s1">result = idx1 != val</span>
                <span class="s1">expected = np.array([</span><span class="s2">True, True, False, True, True, True</span><span class="s1">])</span>
                <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_comparison_tzawareness_compat(self</span><span class="s2">, </span><span class="s1">comparison_op</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#18162</span>
        <span class="s1">op = comparison_op</span>
        <span class="s1">box = box_with_array</span>

        <span class="s1">dr = date_range(</span><span class="s3">&quot;2016-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">dz = dr.tz_localize(</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)</span>

        <span class="s1">dr = tm.box_expected(dr</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">dz = tm.box_expected(dz</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s2">if </span><span class="s1">box </span><span class="s2">is </span><span class="s1">pd.DataFrame:</span>
            <span class="s1">tolist = </span><span class="s2">lambda </span><span class="s1">x: x.astype(object).values.tolist()[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tolist = list</span>

        <span class="s2">if </span><span class="s1">op </span><span class="s2">not in </span><span class="s1">[operator.eq</span><span class="s2">, </span><span class="s1">operator.ne]:</span>
            <span class="s1">msg = (</span>
                <span class="s3">r&quot;Invalid comparison between dtype=datetime64\[ns.*\] &quot;</span>
                <span class="s3">&quot;and (Timestamp|DatetimeArray|list|ndarray)&quot;</span>
            <span class="s1">)</span>
            <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">op(dr</span><span class="s2">, </span><span class="s1">dz)</span>

            <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">op(dr</span><span class="s2">, </span><span class="s1">tolist(dz))</span>
            <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">op(dr</span><span class="s2">, </span><span class="s1">np.array(tolist(dz)</span><span class="s2">, </span><span class="s1">dtype=object))</span>
            <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">op(dz</span><span class="s2">, </span><span class="s1">dr)</span>

            <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">op(dz</span><span class="s2">, </span><span class="s1">tolist(dr))</span>
            <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">op(dz</span><span class="s2">, </span><span class="s1">np.array(tolist(dr)</span><span class="s2">, </span><span class="s1">dtype=object))</span>

        <span class="s0"># The aware==aware and naive==naive comparisons should *not* raise</span>
        <span class="s2">assert </span><span class="s1">np.all(dr == dr)</span>
        <span class="s2">assert </span><span class="s1">np.all(dr == tolist(dr))</span>
        <span class="s2">assert </span><span class="s1">np.all(tolist(dr) == dr)</span>
        <span class="s2">assert </span><span class="s1">np.all(np.array(tolist(dr)</span><span class="s2">, </span><span class="s1">dtype=object) == dr)</span>
        <span class="s2">assert </span><span class="s1">np.all(dr == np.array(tolist(dr)</span><span class="s2">, </span><span class="s1">dtype=object))</span>

        <span class="s2">assert </span><span class="s1">np.all(dz == dz)</span>
        <span class="s2">assert </span><span class="s1">np.all(dz == tolist(dz))</span>
        <span class="s2">assert </span><span class="s1">np.all(tolist(dz) == dz)</span>
        <span class="s2">assert </span><span class="s1">np.all(np.array(tolist(dz)</span><span class="s2">, </span><span class="s1">dtype=object) == dz)</span>
        <span class="s2">assert </span><span class="s1">np.all(dz == np.array(tolist(dz)</span><span class="s2">, </span><span class="s1">dtype=object))</span>

    <span class="s2">def </span><span class="s1">test_comparison_tzawareness_compat_scalars(self</span><span class="s2">, </span><span class="s1">comparison_op</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#18162</span>
        <span class="s1">op = comparison_op</span>

        <span class="s1">dr = date_range(</span><span class="s3">&quot;2016-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">dz = dr.tz_localize(</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)</span>

        <span class="s1">dr = tm.box_expected(dr</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">dz = tm.box_expected(dz</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s0"># Check comparisons against scalar Timestamps</span>
        <span class="s1">ts = Timestamp(</span><span class="s3">&quot;2000-03-14 01:59&quot;</span><span class="s1">)</span>
        <span class="s1">ts_tz = Timestamp(</span><span class="s3">&quot;2000-03-14 01:59&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;Europe/Amsterdam&quot;</span><span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">np.all(dr &gt; ts)</span>
        <span class="s1">msg = </span><span class="s3">r&quot;Invalid comparison between dtype=datetime64\[ns.*\] and Timestamp&quot;</span>
        <span class="s2">if </span><span class="s1">op </span><span class="s2">not in </span><span class="s1">[operator.eq</span><span class="s2">, </span><span class="s1">operator.ne]:</span>
            <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">op(dr</span><span class="s2">, </span><span class="s1">ts_tz)</span>

        <span class="s2">assert </span><span class="s1">np.all(dz &gt; ts_tz)</span>
        <span class="s2">if </span><span class="s1">op </span><span class="s2">not in </span><span class="s1">[operator.eq</span><span class="s2">, </span><span class="s1">operator.ne]:</span>
            <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">op(dz</span><span class="s2">, </span><span class="s1">ts)</span>

        <span class="s2">if </span><span class="s1">op </span><span class="s2">not in </span><span class="s1">[operator.eq</span><span class="s2">, </span><span class="s1">operator.ne]:</span>
            <span class="s0"># GH#12601: Check comparison against Timestamps and DatetimeIndex</span>
            <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">op(ts</span><span class="s2">, </span><span class="s1">dz)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;other&quot;</span><span class="s2">,</span>
        <span class="s1">[datetime(</span><span class="s4">2016</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2016-01-01&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.datetime64(</span><span class="s3">&quot;2016-01-01&quot;</span><span class="s1">)]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s0"># Bug in NumPy? https://github.com/numpy/numpy/issues/13841</span>
    <span class="s0"># Raising in __eq__ will fallback to NumPy, which warns, fails,</span>
    <span class="s0"># then re-raises the original exception. So we just need to ignore.</span>
    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">&quot;ignore:elementwise comp:DeprecationWarning&quot;</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">&quot;ignore:Converting timezone-aware:FutureWarning&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_scalar_comparison_tzawareness(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">comparison_op</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">tz_aware_fixture</span><span class="s2">, </span><span class="s1">box_with_array</span>
    <span class="s1">):</span>
        <span class="s1">op = comparison_op</span>
        <span class="s1">tz = tz_aware_fixture</span>
        <span class="s1">dti = date_range(</span><span class="s3">&quot;2016-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">tz=tz)</span>

        <span class="s1">dtarr = tm.box_expected(dti</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">xbox = get_upcast_box(dtarr</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">op </span><span class="s2">in </span><span class="s1">[operator.eq</span><span class="s2">, </span><span class="s1">operator.ne]:</span>
            <span class="s1">exbool = op </span><span class="s2">is </span><span class="s1">operator.ne</span>
            <span class="s1">expected = np.array([exbool</span><span class="s2">, </span><span class="s1">exbool]</span><span class="s2">, </span><span class="s1">dtype=bool)</span>
            <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>

            <span class="s1">result = op(dtarr</span><span class="s2">, </span><span class="s1">other)</span>
            <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

            <span class="s1">result = op(other</span><span class="s2">, </span><span class="s1">dtarr)</span>
            <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">msg = (</span>
                <span class="s3">r&quot;Invalid comparison between dtype=datetime64\[ns, .*\] &quot;</span>
                <span class="s3">f&quot;and </span><span class="s2">{</span><span class="s1">type(other).__name__</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s1">)</span>
            <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">op(dtarr</span><span class="s2">, </span><span class="s1">other)</span>
            <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">op(other</span><span class="s2">, </span><span class="s1">dtarr)</span>

    <span class="s2">def </span><span class="s1">test_nat_comparison_tzawareness(self</span><span class="s2">, </span><span class="s1">comparison_op):</span>
        <span class="s0"># GH#19276</span>
        <span class="s0"># tzaware DatetimeIndex should not raise when compared to NaT</span>
        <span class="s1">op = comparison_op</span>

        <span class="s1">dti = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;2014-01-01&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s3">&quot;2014-03-01&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s3">&quot;2014-05-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2014-07-01&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">expected = np.array([op == operator.ne] * len(dti))</span>
        <span class="s1">result = op(dti</span><span class="s2">, </span><span class="s1">NaT)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = op(dti.tz_localize(</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dti_cmp_str(self</span><span class="s2">, </span><span class="s1">tz_naive_fixture):</span>
        <span class="s0"># GH#22074</span>
        <span class="s0"># regardless of tz, we expect these comparisons are valid</span>
        <span class="s1">tz = tz_naive_fixture</span>
        <span class="s1">rng = date_range(</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">other = </span><span class="s3">&quot;1/1/2000&quot;</span>

        <span class="s1">result = rng == other</span>
        <span class="s1">expected = np.array([</span><span class="s2">True</span><span class="s1">] + [</span><span class="s2">False</span><span class="s1">] * </span><span class="s4">9</span><span class="s1">)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = rng != other</span>
        <span class="s1">expected = np.array([</span><span class="s2">False</span><span class="s1">] + [</span><span class="s2">True</span><span class="s1">] * </span><span class="s4">9</span><span class="s1">)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = rng &lt; other</span>
        <span class="s1">expected = np.array([</span><span class="s2">False</span><span class="s1">] * </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = rng &lt;= other</span>
        <span class="s1">expected = np.array([</span><span class="s2">True</span><span class="s1">] + [</span><span class="s2">False</span><span class="s1">] * </span><span class="s4">9</span><span class="s1">)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = rng &gt; other</span>
        <span class="s1">expected = np.array([</span><span class="s2">False</span><span class="s1">] + [</span><span class="s2">True</span><span class="s1">] * </span><span class="s4">9</span><span class="s1">)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = rng &gt;= other</span>
        <span class="s1">expected = np.array([</span><span class="s2">True</span><span class="s1">] * </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dti_cmp_list(self):</span>
        <span class="s1">rng = date_range(</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">)</span>

        <span class="s1">result = rng == list(rng)</span>
        <span class="s1">expected = rng == rng</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;other&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">pd.timedelta_range(</span><span class="s3">&quot;1D&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pd.timedelta_range(</span><span class="s3">&quot;1D&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">).to_series()</span><span class="s2">,</span>
            <span class="s1">pd.timedelta_range(</span><span class="s3">&quot;1D&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">).asi8.view(</span><span class="s3">&quot;m8[ns]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">ids=</span><span class="s2">lambda </span><span class="s1">x: type(x).__name__</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dti_cmp_tdi_tzawareness(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0"># GH#22074</span>
        <span class="s0"># reversion test that we _don't_ call _assert_tzawareness_compat</span>
        <span class="s0"># when comparing against TimedeltaIndex</span>
        <span class="s1">dti = date_range(</span><span class="s3">&quot;2000-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;Asia/Tokyo&quot;</span><span class="s1">)</span>

        <span class="s1">result = dti == other</span>
        <span class="s1">expected = np.array([</span><span class="s2">False</span><span class="s1">] * </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = dti != other</span>
        <span class="s1">expected = np.array([</span><span class="s2">True</span><span class="s1">] * </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">msg = </span><span class="s3">&quot;Invalid comparison between&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dti &lt; other</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dti &lt;= other</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dti &gt; other</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dti &gt;= other</span>

    <span class="s2">def </span><span class="s1">test_dti_cmp_object_dtype(self):</span>
        <span class="s0"># GH#22074</span>
        <span class="s1">dti = date_range(</span><span class="s3">&quot;2000-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;Asia/Tokyo&quot;</span><span class="s1">)</span>

        <span class="s1">other = dti.astype(</span><span class="s3">&quot;O&quot;</span><span class="s1">)</span>

        <span class="s1">result = dti == other</span>
        <span class="s1">expected = np.array([</span><span class="s2">True</span><span class="s1">] * </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">other = dti.tz_localize(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">result = dti != other</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">other = np.array(list(dti[:</span><span class="s4">5</span><span class="s1">]) + [Timedelta(days=</span><span class="s4">1</span><span class="s1">)] * </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">result = dti == other</span>
        <span class="s1">expected = np.array([</span><span class="s2">True</span><span class="s1">] * </span><span class="s4">5 </span><span class="s1">+ [</span><span class="s2">False</span><span class="s1">] * </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">msg = </span><span class="s3">&quot;&gt;=' not supported between instances of 'Timestamp' and 'Timedelta'&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dti &gt;= other</span>


<span class="s0"># ------------------------------------------------------------------</span>
<span class="s0"># Arithmetic</span>


<span class="s2">class </span><span class="s1">TestDatetime64Arithmetic:</span>
    <span class="s0"># This class is intended for &quot;finished&quot; tests that are fully parametrized</span>
    <span class="s0">#  over DataFrame/Series/Index/DatetimeArray</span>

    <span class="s0"># -------------------------------------------------------------</span>
    <span class="s0"># Addition/Subtraction of timedelta-like</span>

    <span class="s1">@pytest.mark.arm_slow</span>
    <span class="s2">def </span><span class="s1">test_dt64arr_add_timedeltalike_scalar(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">tz_naive_fixture</span><span class="s2">, </span><span class="s1">two_hours</span><span class="s2">, </span><span class="s1">box_with_array</span>
    <span class="s1">):</span>
        <span class="s0"># GH#22005, GH#22163 check DataFrame doesn't raise TypeError</span>
        <span class="s1">tz = tz_naive_fixture</span>

        <span class="s1">rng = date_range(</span><span class="s3">&quot;2000-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-02-01&quot;</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">expected = date_range(</span><span class="s3">&quot;2000-01-01 02:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-02-01 02:00&quot;</span><span class="s2">, </span><span class="s1">tz=tz)</span>

        <span class="s1">rng = tm.box_expected(rng</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = rng + two_hours</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = two_hours + rng</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">rng += two_hours</span>
        <span class="s1">tm.assert_equal(rng</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dt64arr_sub_timedeltalike_scalar(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">tz_naive_fixture</span><span class="s2">, </span><span class="s1">two_hours</span><span class="s2">, </span><span class="s1">box_with_array</span>
    <span class="s1">):</span>
        <span class="s1">tz = tz_naive_fixture</span>

        <span class="s1">rng = date_range(</span><span class="s3">&quot;2000-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-02-01&quot;</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">expected = date_range(</span><span class="s3">&quot;1999-12-31 22:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-01-31 22:00&quot;</span><span class="s2">, </span><span class="s1">tz=tz)</span>

        <span class="s1">rng = tm.box_expected(rng</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = rng - two_hours</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">rng -= two_hours</span>
        <span class="s1">tm.assert_equal(rng</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dt64_array_sub_dt_with_different_timezone(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">t1 = date_range(</span><span class="s3">&quot;20130101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">).tz_localize(</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s1">t1 = tm.box_expected(t1</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">t2 = Timestamp(</span><span class="s3">&quot;20130101&quot;</span><span class="s1">).tz_localize(</span><span class="s3">&quot;CET&quot;</span><span class="s1">)</span>
        <span class="s1">tnaive = Timestamp(</span><span class="s4">20130101</span><span class="s1">)</span>

        <span class="s1">result = t1 - t2</span>
        <span class="s1">expected = TimedeltaIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;0 days 06:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;1 days 06:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2 days 06:00:00&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = t2 - t1</span>
        <span class="s1">expected = TimedeltaIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;-1 days +18:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;-2 days +18:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;-3 days +18:00:00&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">msg = </span><span class="s3">&quot;Cannot subtract tz-naive and tz-aware datetime-like objects&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">t1 - tnaive</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tnaive - t1</span>

    <span class="s2">def </span><span class="s1">test_dt64_array_sub_dt64_array_with_different_timezone(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">t1 = date_range(</span><span class="s3">&quot;20130101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">).tz_localize(</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s1">t1 = tm.box_expected(t1</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">t2 = date_range(</span><span class="s3">&quot;20130101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">).tz_localize(</span><span class="s3">&quot;CET&quot;</span><span class="s1">)</span>
        <span class="s1">t2 = tm.box_expected(t2</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">tnaive = date_range(</span><span class="s3">&quot;20130101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s1">result = t1 - t2</span>
        <span class="s1">expected = TimedeltaIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;0 days 06:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;0 days 06:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;0 days 06:00:00&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = t2 - t1</span>
        <span class="s1">expected = TimedeltaIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;-1 days +18:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;-1 days +18:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;-1 days +18:00:00&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">msg = </span><span class="s3">&quot;Cannot subtract tz-naive and tz-aware datetime-like objects&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">t1 - tnaive</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tnaive - t1</span>

    <span class="s2">def </span><span class="s1">test_dt64arr_add_sub_td64_nat(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">tz_naive_fixture):</span>
        <span class="s0"># GH#23320 special handling for timedelta64(&quot;NaT&quot;)</span>
        <span class="s1">tz = tz_naive_fixture</span>

        <span class="s1">dti = date_range(</span><span class="s3">&quot;1994-04-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">9</span><span class="s2">, </span><span class="s1">tz=tz</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;QS&quot;</span><span class="s1">)</span>
        <span class="s1">other = np.timedelta64(</span><span class="s3">&quot;NaT&quot;</span><span class="s1">)</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;NaT&quot;</span><span class="s1">] * </span><span class="s4">9</span><span class="s2">, </span><span class="s1">tz=tz)</span>

        <span class="s1">obj = tm.box_expected(dti</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = obj + other</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">result = other + obj</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">result = obj - other</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">msg = </span><span class="s3">&quot;cannot subtract&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">other - obj</span>

    <span class="s2">def </span><span class="s1">test_dt64arr_add_sub_td64ndarray(self</span><span class="s2">, </span><span class="s1">tz_naive_fixture</span><span class="s2">, </span><span class="s1">box_with_array):</span>

        <span class="s1">tz = tz_naive_fixture</span>
        <span class="s1">dti = date_range(</span><span class="s3">&quot;2016-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">tdi = TimedeltaIndex([</span><span class="s3">&quot;-1 Day&quot;</span><span class="s2">, </span><span class="s3">&quot;-1 Day&quot;</span><span class="s2">, </span><span class="s3">&quot;-1 Day&quot;</span><span class="s1">])</span>
        <span class="s1">tdarr = tdi.values</span>

        <span class="s1">expected = date_range(</span><span class="s3">&quot;2015-12-31&quot;</span><span class="s2">, </span><span class="s3">&quot;2016-01-02&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">tz=tz)</span>

        <span class="s1">dtarr = tm.box_expected(dti</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = dtarr + tdarr</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">result = tdarr + dtarr</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">expected = date_range(</span><span class="s3">&quot;2016-01-02&quot;</span><span class="s2">, </span><span class="s3">&quot;2016-01-04&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = dtarr - tdarr</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">msg = </span><span class="s3">&quot;cannot subtract|(bad|unsupported) operand type for unary&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tdarr - dtarr</span>

    <span class="s0"># -----------------------------------------------------------------</span>
    <span class="s0"># Subtraction of datetime-like scalars</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;ts&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-01&quot;</span><span class="s1">).to_pydatetime()</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-01&quot;</span><span class="s1">).to_datetime64()</span><span class="s2">,</span>
            <span class="s0"># GH#7996, GH#22163 ensure non-nano datetime64 is converted to nano</span>
            <span class="s0">#  for DataFrame operation</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;2013-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dt64arr_sub_dtscalar(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">ts):</span>
        <span class="s0"># GH#8554, GH#22163 DataFrame op should _not_ return dt64 dtype</span>
        <span class="s1">idx = date_range(</span><span class="s3">&quot;2013-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">)._with_freq(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">idx = tm.box_expected(idx</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">expected = TimedeltaIndex([</span><span class="s3">&quot;0 Days&quot;</span><span class="s2">, </span><span class="s3">&quot;1 Day&quot;</span><span class="s2">, </span><span class="s3">&quot;2 Days&quot;</span><span class="s1">])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = idx - ts</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = ts - idx</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">-expected)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">-expected)</span>

    <span class="s2">def </span><span class="s1">test_dt64arr_sub_timestamp_tzaware(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">ser = date_range(</span><span class="s3">&quot;2014-03-17&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s1">ser = ser._with_freq(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">ts = ser[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s1">ser = tm.box_expected(ser</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">delta_series = Series([np.timedelta64(</span><span class="s4">0</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.timedelta64(</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">)])</span>
        <span class="s1">expected = tm.box_expected(delta_series</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">tm.assert_equal(ser - ts</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_equal(ts - ser</span><span class="s2">, </span><span class="s1">-expected)</span>

    <span class="s2">def </span><span class="s1">test_dt64arr_sub_NaT(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#18808</span>
        <span class="s1">dti = DatetimeIndex([NaT</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;19900315&quot;</span><span class="s1">)])</span>
        <span class="s1">ser = tm.box_expected(dti</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = ser - NaT</span>
        <span class="s1">expected = Series([NaT</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">dti_tz = dti.tz_localize(</span><span class="s3">&quot;Asia/Tokyo&quot;</span><span class="s1">)</span>
        <span class="s1">ser_tz = tm.box_expected(dti_tz</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = ser_tz - NaT</span>
        <span class="s1">expected = Series([NaT</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s0"># -------------------------------------------------------------</span>
    <span class="s0"># Subtraction of datetime-like array-like</span>

    <span class="s2">def </span><span class="s1">test_dt64arr_sub_dt64object_array(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">tz_naive_fixture):</span>
        <span class="s1">dti = date_range(</span><span class="s3">&quot;2016-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">tz=tz_naive_fixture)</span>
        <span class="s1">expected = dti - dti</span>

        <span class="s1">obj = tm.box_expected(dti</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">result = obj - obj.astype(object)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dt64arr_naive_sub_dt64ndarray(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">dti = date_range(</span><span class="s3">&quot;2016-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">dt64vals = dti.values</span>

        <span class="s1">dtarr = tm.box_expected(dti</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">expected = dtarr - dtarr</span>
        <span class="s1">result = dtarr - dt64vals</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">result = dt64vals - dtarr</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dt64arr_aware_sub_dt64ndarray_raises(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">tz_aware_fixture</span><span class="s2">, </span><span class="s1">box_with_array</span>
    <span class="s1">):</span>

        <span class="s1">tz = tz_aware_fixture</span>
        <span class="s1">dti = date_range(</span><span class="s3">&quot;2016-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">dt64vals = dti.values</span>

        <span class="s1">dtarr = tm.box_expected(dti</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">msg = </span><span class="s3">&quot;Cannot subtract tz-naive and tz-aware datetime&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dtarr - dt64vals</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dt64vals - dtarr</span>

    <span class="s0"># -------------------------------------------------------------</span>
    <span class="s0"># Addition of datetime-like others (invalid)</span>

    <span class="s2">def </span><span class="s1">test_dt64arr_add_dtlike_raises(self</span><span class="s2">, </span><span class="s1">tz_naive_fixture</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#22163 ensure DataFrame doesn't cast Timestamp to i8</span>
        <span class="s0"># GH#9631</span>
        <span class="s1">tz = tz_naive_fixture</span>

        <span class="s1">dti = date_range(</span><span class="s3">&quot;2016-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s2">if </span><span class="s1">tz </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">dti2 = dti.tz_localize(</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dti2 = dti.tz_localize(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">dtarr = tm.box_expected(dti</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">assert_cannot_add(dtarr</span><span class="s2">, </span><span class="s1">dti.values)</span>
        <span class="s1">assert_cannot_add(dtarr</span><span class="s2">, </span><span class="s1">dti)</span>
        <span class="s1">assert_cannot_add(dtarr</span><span class="s2">, </span><span class="s1">dtarr)</span>
        <span class="s1">assert_cannot_add(dtarr</span><span class="s2">, </span><span class="s1">dti[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">assert_cannot_add(dtarr</span><span class="s2">, </span><span class="s1">dti[</span><span class="s4">0</span><span class="s1">].to_pydatetime())</span>
        <span class="s1">assert_cannot_add(dtarr</span><span class="s2">, </span><span class="s1">dti[</span><span class="s4">0</span><span class="s1">].to_datetime64())</span>
        <span class="s1">assert_cannot_add(dtarr</span><span class="s2">, </span><span class="s1">dti2[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">assert_cannot_add(dtarr</span><span class="s2">, </span><span class="s1">dti2[</span><span class="s4">0</span><span class="s1">].to_pydatetime())</span>
        <span class="s1">assert_cannot_add(dtarr</span><span class="s2">, </span><span class="s1">np.datetime64(</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">))</span>

    <span class="s0"># -------------------------------------------------------------</span>
    <span class="s0"># Other Invalid Addition/Subtraction</span>

    <span class="s0"># Note: freq here includes both Tick and non-Tick offsets; this is</span>
    <span class="s0">#  relevant because historically integer-addition was allowed if we had</span>
    <span class="s0">#  a freq.</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;freq&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;H&quot;</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s3">&quot;W&quot;</span><span class="s2">, </span><span class="s3">&quot;M&quot;</span><span class="s2">, </span><span class="s3">&quot;MS&quot;</span><span class="s2">, </span><span class="s3">&quot;Q&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s2">, None</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;uint8&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_dt64arr_addsub_intlike(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">freq</span><span class="s2">, </span><span class="s1">tz_naive_fixture</span>
    <span class="s1">):</span>
        <span class="s0"># GH#19959, GH#19123, GH#19012</span>
        <span class="s1">tz = tz_naive_fixture</span>
        <span class="s2">if </span><span class="s1">box_with_array </span><span class="s2">is </span><span class="s1">pd.DataFrame:</span>
            <span class="s0"># alignment headaches</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">freq </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">dti = DatetimeIndex([</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;2017-04-05 06:07:08&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dti = date_range(</span><span class="s3">&quot;2016-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">freq=freq</span><span class="s2">, </span><span class="s1">tz=tz)</span>

        <span class="s1">obj = box_with_array(dti)</span>
        <span class="s1">other = np.array([</span><span class="s4">4</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

        <span class="s1">msg = </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s3">&quot;Addition/subtraction of integers&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;cannot subtract DatetimeArray from&quot;</span><span class="s2">,</span>
                <span class="s0"># IntegerArray</span>
                <span class="s3">&quot;can only perform ops with numeric values&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;unsupported operand type.*Categorical&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">assert_invalid_addsub_type(obj</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">msg)</span>
        <span class="s1">assert_invalid_addsub_type(obj</span><span class="s2">, </span><span class="s1">np.int64(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">msg)</span>
        <span class="s1">assert_invalid_addsub_type(obj</span><span class="s2">, </span><span class="s1">np.array(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">dtype=np.int64)</span><span class="s2">, </span><span class="s1">msg)</span>
        <span class="s1">assert_invalid_addsub_type(obj</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">msg)</span>
        <span class="s1">assert_invalid_addsub_type(obj</span><span class="s2">, </span><span class="s1">np.array(other)</span><span class="s2">, </span><span class="s1">msg)</span>
        <span class="s1">assert_invalid_addsub_type(obj</span><span class="s2">, </span><span class="s1">pd.array(other)</span><span class="s2">, </span><span class="s1">msg)</span>
        <span class="s1">assert_invalid_addsub_type(obj</span><span class="s2">, </span><span class="s1">pd.Categorical(other)</span><span class="s2">, </span><span class="s1">msg)</span>
        <span class="s1">assert_invalid_addsub_type(obj</span><span class="s2">, </span><span class="s1">pd.Index(other)</span><span class="s2">, </span><span class="s1">msg)</span>
        <span class="s1">assert_invalid_addsub_type(obj</span><span class="s2">, </span><span class="s1">pd.core.indexes.api.NumericIndex(other)</span><span class="s2">, </span><span class="s1">msg)</span>
        <span class="s1">assert_invalid_addsub_type(obj</span><span class="s2">, </span><span class="s1">Series(other)</span><span class="s2">, </span><span class="s1">msg)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;other&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s4">3.14</span><span class="s2">,</span>
            <span class="s1">np.array([</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s0"># GH#13078 datetime +/- Period is invalid</span>
            <span class="s1">Period(</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;D&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s0"># https://github.com/pandas-dev/pandas/issues/10329</span>
            <span class="s1">time(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dti_freq&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;D&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_dt64arr_add_sub_invalid(self</span><span class="s2">, </span><span class="s1">dti_freq</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">dti = DatetimeIndex([</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-01-02&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">freq=dti_freq)</span>
        <span class="s1">dtarr = tm.box_expected(dti</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">msg = </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s3">&quot;unsupported operand type&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;cannot (add|subtract)&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;cannot use operands with types&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;ufunc '?(add|subtract)'? cannot use operands with types&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;Concatenation operation is not implemented for NumPy arrays&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">assert_invalid_addsub_type(dtarr</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">msg)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;pi_freq&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s3">&quot;W&quot;</span><span class="s2">, </span><span class="s3">&quot;Q&quot;</span><span class="s2">, </span><span class="s3">&quot;H&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dti_freq&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;D&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_dt64arr_add_sub_parr(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">dti_freq</span><span class="s2">, </span><span class="s1">pi_freq</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">box_with_array2</span>
    <span class="s1">):</span>
        <span class="s0"># GH#20049 subtracting PeriodIndex should raise TypeError</span>
        <span class="s1">dti = DatetimeIndex([</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-01-02&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">freq=dti_freq)</span>
        <span class="s1">pi = dti.to_period(pi_freq)</span>

        <span class="s1">dtarr = tm.box_expected(dti</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">parr = tm.box_expected(pi</span><span class="s2">, </span><span class="s1">box_with_array2)</span>
        <span class="s1">msg = </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s3">&quot;cannot (add|subtract)&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;unsupported operand&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;descriptor.*requires&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;ufunc.*cannot use operands&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">assert_invalid_addsub_type(dtarr</span><span class="s2">, </span><span class="s1">parr</span><span class="s2">, </span><span class="s1">msg)</span>

    <span class="s2">def </span><span class="s1">test_dt64arr_addsub_time_objects_raises(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">tz_naive_fixture):</span>
        <span class="s0"># https://github.com/pandas-dev/pandas/issues/10329</span>

        <span class="s1">tz = tz_naive_fixture</span>

        <span class="s1">obj1 = date_range(</span><span class="s3">&quot;2012-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">obj2 = [time(i</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">)]</span>

        <span class="s1">obj1 = tm.box_expected(obj1</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">obj2 = tm.box_expected(obj2</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">msg = </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s3">&quot;unsupported operand&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;cannot subtract DatetimeArray from ndarray&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>

        <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">):</span>
            <span class="s0"># pandas.errors.PerformanceWarning: Non-vectorized DateOffset being</span>
            <span class="s0"># applied to Series or DatetimeIndex</span>
            <span class="s0"># we aren't testing that here, so ignore.</span>
            <span class="s1">warnings.simplefilter(</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">PerformanceWarning)</span>

            <span class="s1">assert_invalid_addsub_type(obj1</span><span class="s2">, </span><span class="s1">obj2</span><span class="s2">, </span><span class="s1">msg=msg)</span>

    <span class="s0"># -------------------------------------------------------------</span>
    <span class="s0"># Other invalid operations</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;dt64_series&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">Series([Timestamp(</span><span class="s3">&quot;19900315&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;19900315&quot;</span><span class="s1">)])</span><span class="s2">,</span>
            <span class="s1">Series([NaT</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;19900315&quot;</span><span class="s1">)])</span><span class="s2">,</span>
            <span class="s1">Series([NaT</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;one&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">np.array(</span><span class="s4">1</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_dt64_mul_div_numeric_invalid(self</span><span class="s2">, </span><span class="s1">one</span><span class="s2">, </span><span class="s1">dt64_series</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">obj = tm.box_expected(dt64_series</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">msg = </span><span class="s3">&quot;cannot perform .* with this index type&quot;</span>

        <span class="s0"># multiplication</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">obj * one</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">one * obj</span>

        <span class="s0"># division</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">obj / one</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">one / obj</span>


<span class="s2">class </span><span class="s1">TestDatetime64DateOffsetArithmetic:</span>

    <span class="s0"># -------------------------------------------------------------</span>
    <span class="s0"># Tick DateOffsets</span>

    <span class="s0"># TODO: parametrize over timezone?</span>
    <span class="s2">def </span><span class="s1">test_dt64arr_series_add_tick_DateOffset(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#4532</span>
        <span class="s0"># operate with pd.offsets</span>
        <span class="s1">ser = Series([Timestamp(</span><span class="s3">&quot;20130101 9:01&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20130101 9:02&quot;</span><span class="s1">)])</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;20130101 9:01:05&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20130101 9:02:05&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>

        <span class="s1">ser = tm.box_expected(ser</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = ser + pd.offsets.Second(</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result2 = pd.offsets.Second(</span><span class="s4">5</span><span class="s1">) + ser</span>
        <span class="s1">tm.assert_equal(result2</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dt64arr_series_sub_tick_DateOffset(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#4532</span>
        <span class="s0"># operate with pd.offsets</span>
        <span class="s1">ser = Series([Timestamp(</span><span class="s3">&quot;20130101 9:01&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20130101 9:02&quot;</span><span class="s1">)])</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;20130101 9:00:55&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20130101 9:01:55&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>

        <span class="s1">ser = tm.box_expected(ser</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = ser - pd.offsets.Second(</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result2 = -pd.offsets.Second(</span><span class="s4">5</span><span class="s1">) + ser</span>
        <span class="s1">tm.assert_equal(result2</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">msg = </span><span class="s3">&quot;(bad|unsupported) operand type for unary&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">pd.offsets.Second(</span><span class="s4">5</span><span class="s1">) - ser</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;cls_name&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;Day&quot;</span><span class="s2">, </span><span class="s3">&quot;Hour&quot;</span><span class="s2">, </span><span class="s3">&quot;Minute&quot;</span><span class="s2">, </span><span class="s3">&quot;Second&quot;</span><span class="s2">, </span><span class="s3">&quot;Milli&quot;</span><span class="s2">, </span><span class="s3">&quot;Micro&quot;</span><span class="s2">, </span><span class="s3">&quot;Nano&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dt64arr_add_sub_tick_DateOffset_smoke(self</span><span class="s2">, </span><span class="s1">cls_name</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#4532</span>
        <span class="s0"># smoke tests for valid DateOffsets</span>
        <span class="s1">ser = Series([Timestamp(</span><span class="s3">&quot;20130101 9:01&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20130101 9:02&quot;</span><span class="s1">)])</span>
        <span class="s1">ser = tm.box_expected(ser</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">offset_cls = getattr(pd.offsets</span><span class="s2">, </span><span class="s1">cls_name)</span>
        <span class="s1">ser + offset_cls(</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">offset_cls(</span><span class="s4">5</span><span class="s1">) + ser</span>
        <span class="s1">ser - offset_cls(</span><span class="s4">5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_dti_add_tick_tzaware(self</span><span class="s2">, </span><span class="s1">tz_aware_fixture</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#21610, GH#22163 ensure DataFrame doesn't return object-dtype</span>
        <span class="s1">tz = tz_aware_fixture</span>
        <span class="s2">if </span><span class="s1">tz == </span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">:</span>
            <span class="s1">dates = date_range(</span><span class="s3">&quot;2012-11-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">tz=tz)</span>
            <span class="s1">offset = dates + pd.offsets.Hour(</span><span class="s4">5</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">dates[</span><span class="s4">0</span><span class="s1">] + pd.offsets.Hour(</span><span class="s4">5</span><span class="s1">) == offset[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s1">dates = date_range(</span><span class="s3">&quot;2010-11-01 00:00&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">tz=tz</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;H&quot;</span><span class="s1">)</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;2010-11-01 05:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2010-11-01 06:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2010-11-01 07:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">freq=</span><span class="s3">&quot;H&quot;</span><span class="s2">,</span>
            <span class="s1">tz=tz</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">dates = tm.box_expected(dates</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s2">for </span><span class="s1">scalar </span><span class="s2">in </span><span class="s1">[pd.offsets.Hour(</span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.timedelta64(</span><span class="s4">5</span><span class="s2">, </span><span class="s3">&quot;h&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">timedelta(hours=</span><span class="s4">5</span><span class="s1">)]:</span>
            <span class="s1">offset = dates + scalar</span>
            <span class="s1">tm.assert_equal(offset</span><span class="s2">, </span><span class="s1">expected)</span>
            <span class="s1">offset = scalar + dates</span>
            <span class="s1">tm.assert_equal(offset</span><span class="s2">, </span><span class="s1">expected)</span>

            <span class="s1">roundtrip = offset - scalar</span>
            <span class="s1">tm.assert_equal(roundtrip</span><span class="s2">, </span><span class="s1">dates)</span>

            <span class="s1">msg = </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(</span>
                <span class="s1">[</span><span class="s3">&quot;bad operand type for unary -&quot;</span><span class="s2">, </span><span class="s3">&quot;cannot subtract DatetimeArray&quot;</span><span class="s1">]</span>
            <span class="s1">)</span>
            <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">scalar - dates</span>

    <span class="s0"># -------------------------------------------------------------</span>
    <span class="s0"># RelativeDelta DateOffsets</span>

    <span class="s2">def </span><span class="s1">test_dt64arr_add_sub_relativedelta_offsets(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#10699</span>
        <span class="s1">vec = DatetimeIndex(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-05 00:15:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-31 00:23:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-03-31&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-02-29&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-12-31&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-05-15&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2001-06-15&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">vec = tm.box_expected(vec</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">vec_items = vec.iloc[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">if </span><span class="s1">box_with_array </span><span class="s2">is </span><span class="s1">pd.DataFrame </span><span class="s2">else </span><span class="s1">vec</span>

        <span class="s0"># DateOffset relativedelta fastpath</span>
        <span class="s1">relative_kwargs = [</span>
            <span class="s1">(</span><span class="s3">&quot;years&quot;</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;months&quot;</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;days&quot;</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;hours&quot;</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;minutes&quot;</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;seconds&quot;</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;microseconds&quot;</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(unit</span><span class="s2">, </span><span class="s1">value) </span><span class="s2">in </span><span class="s1">enumerate(relative_kwargs):</span>
            <span class="s1">off = DateOffset(**{unit: value})</span>

            <span class="s1">expected = DatetimeIndex([x + off </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">vec_items])</span>
            <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>
            <span class="s1">tm.assert_equal(expected</span><span class="s2">, </span><span class="s1">vec + off)</span>

            <span class="s1">expected = DatetimeIndex([x - off </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">vec_items])</span>
            <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>
            <span class="s1">tm.assert_equal(expected</span><span class="s2">, </span><span class="s1">vec - off)</span>

            <span class="s1">off = DateOffset(**dict(relative_kwargs[: i + </span><span class="s4">1</span><span class="s1">]))</span>

            <span class="s1">expected = DatetimeIndex([x + off </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">vec_items])</span>
            <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>
            <span class="s1">tm.assert_equal(expected</span><span class="s2">, </span><span class="s1">vec + off)</span>

            <span class="s1">expected = DatetimeIndex([x - off </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">vec_items])</span>
            <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>
            <span class="s1">tm.assert_equal(expected</span><span class="s2">, </span><span class="s1">vec - off)</span>
            <span class="s1">msg = </span><span class="s3">&quot;(bad|unsupported) operand type for unary&quot;</span>
            <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">off - vec</span>

    <span class="s0"># -------------------------------------------------------------</span>
    <span class="s0"># Non-Tick, Non-RelativeDelta DateOffsets</span>

    <span class="s0"># TODO: redundant with test_dt64arr_add_sub_DateOffset?  that includes</span>
    <span class="s0">#  tz-aware cases which this does not</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;cls_and_kwargs&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s3">&quot;YearBegin&quot;</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;YearBegin&quot;</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;month&quot;</span><span class="s1">: </span><span class="s4">5</span><span class="s1">})</span><span class="s2">,</span>
            <span class="s3">&quot;YearEnd&quot;</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;YearEnd&quot;</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;month&quot;</span><span class="s1">: </span><span class="s4">5</span><span class="s1">})</span><span class="s2">,</span>
            <span class="s3">&quot;MonthBegin&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;MonthEnd&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;SemiMonthEnd&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;SemiMonthBegin&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Week&quot;</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;Week&quot;</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;weekday&quot;</span><span class="s1">: </span><span class="s4">3</span><span class="s1">})</span><span class="s2">,</span>
            <span class="s3">&quot;Week&quot;</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;Week&quot;</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;weekday&quot;</span><span class="s1">: </span><span class="s4">6</span><span class="s1">})</span><span class="s2">,</span>
            <span class="s3">&quot;BusinessDay&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;BDay&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;QuarterEnd&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;QuarterBegin&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;CustomBusinessDay&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;CDay&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;CBMonthEnd&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;CBMonthBegin&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;BMonthBegin&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;BMonthEnd&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;BusinessHour&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;BYearBegin&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;BYearEnd&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;BQuarterBegin&quot;</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;LastWeekOfMonth&quot;</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;weekday&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s1">})</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s3">&quot;FY5253Quarter&quot;</span><span class="s2">,</span>
                <span class="s1">{</span>
                    <span class="s3">&quot;qtr_with_extra_week&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s2">,</span>
                    <span class="s3">&quot;startingMonth&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s2">,</span>
                    <span class="s3">&quot;weekday&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s2">,</span>
                    <span class="s3">&quot;variation&quot;</span><span class="s1">: </span><span class="s3">&quot;nearest&quot;</span><span class="s2">,</span>
                <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;FY5253&quot;</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;weekday&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s2">, </span><span class="s3">&quot;startingMonth&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s2">, </span><span class="s3">&quot;variation&quot;</span><span class="s1">: </span><span class="s3">&quot;nearest&quot;</span><span class="s1">})</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;WeekOfMonth&quot;</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;weekday&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s2">, </span><span class="s3">&quot;week&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s1">})</span><span class="s2">,</span>
            <span class="s3">&quot;Easter&quot;</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;DateOffset&quot;</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;day&quot;</span><span class="s1">: </span><span class="s4">4</span><span class="s1">})</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;DateOffset&quot;</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;month&quot;</span><span class="s1">: </span><span class="s4">5</span><span class="s1">})</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;normalize&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;n&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">5</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_dt64arr_add_sub_DateOffsets(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">normalize</span><span class="s2">, </span><span class="s1">cls_and_kwargs</span>
    <span class="s1">):</span>
        <span class="s0"># GH#10699</span>
        <span class="s0"># assert vectorized operation matches pointwise operations</span>

        <span class="s2">if </span><span class="s1">isinstance(cls_and_kwargs</span><span class="s2">, </span><span class="s1">tuple):</span>
            <span class="s0"># If cls_name param is a tuple, then 2nd entry is kwargs for</span>
            <span class="s0"># the offset constructor</span>
            <span class="s1">cls_name</span><span class="s2">, </span><span class="s1">kwargs = cls_and_kwargs</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cls_name = cls_and_kwargs</span>
            <span class="s1">kwargs = {}</span>

        <span class="s2">if </span><span class="s1">n == </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">cls_name </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">&quot;WeekOfMonth&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;LastWeekOfMonth&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;FY5253Quarter&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;FY5253&quot;</span><span class="s2">,</span>
        <span class="s1">]:</span>
            <span class="s0"># passing n = 0 is invalid for these offset classes</span>
            <span class="s2">return</span>

        <span class="s1">vec = DatetimeIndex(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-05 00:15:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-31 00:23:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-03-31&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-02-29&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-12-31&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-05-15&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2001-06-15&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">vec = tm.box_expected(vec</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">vec_items = vec.iloc[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">if </span><span class="s1">box_with_array </span><span class="s2">is </span><span class="s1">pd.DataFrame </span><span class="s2">else </span><span class="s1">vec</span>

        <span class="s1">offset_cls = getattr(pd.offsets</span><span class="s2">, </span><span class="s1">cls_name)</span>

        <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">):</span>
            <span class="s0"># pandas.errors.PerformanceWarning: Non-vectorized DateOffset being</span>
            <span class="s0"># applied to Series or DatetimeIndex</span>
            <span class="s0"># we aren't testing that here, so ignore.</span>
            <span class="s1">warnings.simplefilter(</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">PerformanceWarning)</span>

            <span class="s1">offset = offset_cls(n</span><span class="s2">, </span><span class="s1">normalize=normalize</span><span class="s2">, </span><span class="s1">**kwargs)</span>

            <span class="s1">expected = DatetimeIndex([x + offset </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">vec_items])</span>
            <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>
            <span class="s1">tm.assert_equal(expected</span><span class="s2">, </span><span class="s1">vec + offset)</span>

            <span class="s1">expected = DatetimeIndex([x - offset </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">vec_items])</span>
            <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>
            <span class="s1">tm.assert_equal(expected</span><span class="s2">, </span><span class="s1">vec - offset)</span>

            <span class="s1">expected = DatetimeIndex([offset + x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">vec_items])</span>
            <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>
            <span class="s1">tm.assert_equal(expected</span><span class="s2">, </span><span class="s1">offset + vec)</span>
            <span class="s1">msg = </span><span class="s3">&quot;(bad|unsupported) operand type for unary&quot;</span>
            <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">offset - vec</span>

    <span class="s2">def </span><span class="s1">test_dt64arr_add_sub_DateOffset(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#10699</span>
        <span class="s1">s = date_range(</span><span class="s3">&quot;2000-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-01-31&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;a&quot;</span><span class="s1">)</span>
        <span class="s1">s = tm.box_expected(s</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">result = s + DateOffset(years=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">result2 = DateOffset(years=</span><span class="s4">1</span><span class="s1">) + s</span>
        <span class="s1">exp = date_range(</span><span class="s3">&quot;2001-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2001-01-31&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;a&quot;</span><span class="s1">)._with_freq(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">exp = tm.box_expected(exp</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
        <span class="s1">tm.assert_equal(result2</span><span class="s2">, </span><span class="s1">exp)</span>

        <span class="s1">result = s - DateOffset(years=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">exp = date_range(</span><span class="s3">&quot;1999-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;1999-01-31&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;a&quot;</span><span class="s1">)._with_freq(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">exp = tm.box_expected(exp</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>

        <span class="s1">s = DatetimeIndex(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-15 00:15:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Central&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-02-15&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Central&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">name=</span><span class="s3">&quot;a&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">s = tm.box_expected(s</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">result = s + pd.offsets.Day()</span>
        <span class="s1">result2 = pd.offsets.Day() + s</span>
        <span class="s1">exp = DatetimeIndex(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-16 00:15:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Central&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-02-16&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Central&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">name=</span><span class="s3">&quot;a&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">exp = tm.box_expected(exp</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
        <span class="s1">tm.assert_equal(result2</span><span class="s2">, </span><span class="s1">exp)</span>

        <span class="s1">s = DatetimeIndex(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-15 00:15:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Central&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-02-15&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Central&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">name=</span><span class="s3">&quot;a&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">s = tm.box_expected(s</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">result = s + pd.offsets.MonthEnd()</span>
        <span class="s1">result2 = pd.offsets.MonthEnd() + s</span>
        <span class="s1">exp = DatetimeIndex(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-31 00:15:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Central&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-02-29&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Central&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">name=</span><span class="s3">&quot;a&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">exp = tm.box_expected(exp</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
        <span class="s1">tm.assert_equal(result2</span><span class="s2">, </span><span class="s1">exp)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;other&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">np.array([pd.offsets.MonthEnd()</span><span class="s2">, </span><span class="s1">pd.offsets.Day(n=</span><span class="s4">2</span><span class="s1">)])</span><span class="s2">,</span>
            <span class="s1">np.array([pd.offsets.DateOffset(years=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">pd.offsets.MonthEnd()])</span><span class="s2">,</span>
            <span class="s1">np.array(  </span><span class="s0"># matching offsets</span>
                <span class="s1">[pd.offsets.DateOffset(years=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">pd.offsets.DateOffset(years=</span><span class="s4">1</span><span class="s1">)]</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;op&quot;</span><span class="s2">, </span><span class="s1">[operator.add</span><span class="s2">, </span><span class="s1">roperator.radd</span><span class="s2">, </span><span class="s1">operator.sub])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;box_other&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_dt64arr_add_sub_offset_array(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">tz_naive_fixture</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">box_other</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">other</span>
    <span class="s1">):</span>
        <span class="s0"># GH#18849</span>
        <span class="s0"># GH#10699 array of offsets</span>

        <span class="s1">tz = tz_naive_fixture</span>
        <span class="s1">dti = date_range(</span><span class="s3">&quot;2017-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">dtarr = tm.box_expected(dti</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">other = np.array([pd.offsets.MonthEnd()</span><span class="s2">, </span><span class="s1">pd.offsets.Day(n=</span><span class="s4">2</span><span class="s1">)])</span>
        <span class="s1">expected = DatetimeIndex([op(dti[n]</span><span class="s2">, </span><span class="s1">other[n]) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(len(dti))])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s2">if </span><span class="s1">box_other:</span>
            <span class="s1">other = tm.box_expected(other</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">res = op(dtarr</span><span class="s2">, </span><span class="s1">other)</span>

        <span class="s1">tm.assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;op, offset, exp, exp_freq&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s3">&quot;__add__&quot;</span><span class="s2">,</span>
                <span class="s1">DateOffset(months=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">days=</span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">[</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2014-04-11&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2015-04-11&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2016-04-11&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2017-04-11&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">]</span><span class="s2">,</span>
                <span class="s2">None,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s3">&quot;__add__&quot;</span><span class="s2">,</span>
                <span class="s1">DateOffset(months=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">[</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2014-04-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2015-04-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2016-04-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2017-04-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;AS-APR&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s3">&quot;__sub__&quot;</span><span class="s2">,</span>
                <span class="s1">DateOffset(months=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">days=</span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">[</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2013-09-21&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2014-09-21&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2015-09-21&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2016-09-21&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">]</span><span class="s2">,</span>
                <span class="s2">None,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s3">&quot;__sub__&quot;</span><span class="s2">,</span>
                <span class="s1">DateOffset(months=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">[</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2013-10-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2014-10-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2015-10-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2016-10-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;AS-OCT&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dti_add_sub_nonzero_mth_offset(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">exp</span><span class="s2">, </span><span class="s1">exp_freq</span><span class="s2">, </span><span class="s1">tz_aware_fixture</span><span class="s2">, </span><span class="s1">box_with_array</span>
    <span class="s1">):</span>
        <span class="s0"># GH 26258</span>
        <span class="s1">tz = tz_aware_fixture</span>
        <span class="s1">date = date_range(start=</span><span class="s3">&quot;01 Jan 2014&quot;</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">&quot;01 Jan 2017&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;AS&quot;</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">date = tm.box_expected(date</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">mth = getattr(date</span><span class="s2">, </span><span class="s1">op)</span>
        <span class="s1">result = mth(offset)</span>

        <span class="s1">expected = DatetimeIndex(exp</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestDatetime64OverflowHandling:</span>
    <span class="s0"># TODO: box + de-duplicate</span>

    <span class="s2">def </span><span class="s1">test_dt64_overflow_masking(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#25317</span>
        <span class="s1">left = Series([Timestamp(</span><span class="s3">&quot;1969-12-31&quot;</span><span class="s1">)])</span>
        <span class="s1">right = Series([NaT])</span>

        <span class="s1">left = tm.box_expected(left</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">right = tm.box_expected(right</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">expected = TimedeltaIndex([NaT])</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = left - right</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dt64_series_arith_overflow(self):</span>
        <span class="s0"># GH#12534, fixed by GH#19024</span>
        <span class="s1">dt = Timestamp(</span><span class="s3">&quot;1700-01-31&quot;</span><span class="s1">)</span>
        <span class="s1">td = Timedelta(</span><span class="s3">&quot;20000 Days&quot;</span><span class="s1">)</span>
        <span class="s1">dti = date_range(</span><span class="s3">&quot;1949-09-30&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;100Y&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">ser = Series(dti)</span>
        <span class="s1">msg = </span><span class="s3">&quot;Overflow in int64 addition&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OverflowError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">ser - dt</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OverflowError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dt - ser</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OverflowError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">ser + td</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OverflowError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">td + ser</span>

        <span class="s1">ser.iloc[-</span><span class="s4">1</span><span class="s1">] = NaT</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[</span><span class="s3">&quot;2004-10-03&quot;</span><span class="s2">, </span><span class="s3">&quot;2104-10-04&quot;</span><span class="s2">, </span><span class="s3">&quot;2204-10-04&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span>
        <span class="s1">)</span>
        <span class="s1">res = ser + td</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">res = td + ser</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">ser.iloc[</span><span class="s4">1</span><span class="s1">:] = NaT</span>
        <span class="s1">expected = Series([</span><span class="s3">&quot;91279 Days&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">res = ser - dt</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">res = dt - ser</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s2">, </span><span class="s1">-expected)</span>

    <span class="s2">def </span><span class="s1">test_datetimeindex_sub_timestamp_overflow(self):</span>
        <span class="s1">dtimax = pd.to_datetime([</span><span class="s3">&quot;2021-12-28 17:19&quot;</span><span class="s2">, </span><span class="s1">Timestamp.max])</span>
        <span class="s1">dtimin = pd.to_datetime([</span><span class="s3">&quot;2021-12-28 17:19&quot;</span><span class="s2">, </span><span class="s1">Timestamp.min])</span>

        <span class="s1">tsneg = Timestamp(</span><span class="s3">&quot;1950-01-01&quot;</span><span class="s1">)</span>
        <span class="s1">ts_neg_variants = [</span>
            <span class="s1">tsneg</span><span class="s2">,</span>
            <span class="s1">tsneg.to_pydatetime()</span><span class="s2">,</span>
            <span class="s1">tsneg.to_datetime64().astype(</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">tsneg.to_datetime64().astype(</span><span class="s3">&quot;datetime64[D]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>

        <span class="s1">tspos = Timestamp(</span><span class="s3">&quot;1980-01-01&quot;</span><span class="s1">)</span>
        <span class="s1">ts_pos_variants = [</span>
            <span class="s1">tspos</span><span class="s2">,</span>
            <span class="s1">tspos.to_pydatetime()</span><span class="s2">,</span>
            <span class="s1">tspos.to_datetime64().astype(</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">tspos.to_datetime64().astype(</span><span class="s3">&quot;datetime64[D]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">msg = </span><span class="s3">&quot;Overflow in int64 addition&quot;</span>
        <span class="s2">for </span><span class="s1">variant </span><span class="s2">in </span><span class="s1">ts_neg_variants:</span>
            <span class="s2">with </span><span class="s1">pytest.raises(OverflowError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">dtimax - variant</span>

        <span class="s1">expected = Timestamp.max.value - tspos.value</span>
        <span class="s2">for </span><span class="s1">variant </span><span class="s2">in </span><span class="s1">ts_pos_variants:</span>
            <span class="s1">res = dtimax - variant</span>
            <span class="s2">assert </span><span class="s1">res[</span><span class="s4">1</span><span class="s1">].value == expected</span>

        <span class="s1">expected = Timestamp.min.value - tsneg.value</span>
        <span class="s2">for </span><span class="s1">variant </span><span class="s2">in </span><span class="s1">ts_neg_variants:</span>
            <span class="s1">res = dtimin - variant</span>
            <span class="s2">assert </span><span class="s1">res[</span><span class="s4">1</span><span class="s1">].value == expected</span>

        <span class="s2">for </span><span class="s1">variant </span><span class="s2">in </span><span class="s1">ts_pos_variants:</span>
            <span class="s2">with </span><span class="s1">pytest.raises(OverflowError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">dtimin - variant</span>

    <span class="s2">def </span><span class="s1">test_datetimeindex_sub_datetimeindex_overflow(self):</span>
        <span class="s0"># GH#22492, GH#22508</span>
        <span class="s1">dtimax = pd.to_datetime([</span><span class="s3">&quot;2021-12-28 17:19&quot;</span><span class="s2">, </span><span class="s1">Timestamp.max])</span>
        <span class="s1">dtimin = pd.to_datetime([</span><span class="s3">&quot;2021-12-28 17:19&quot;</span><span class="s2">, </span><span class="s1">Timestamp.min])</span>

        <span class="s1">ts_neg = pd.to_datetime([</span><span class="s3">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;1950-01-01&quot;</span><span class="s1">])</span>
        <span class="s1">ts_pos = pd.to_datetime([</span><span class="s3">&quot;1980-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;1980-01-01&quot;</span><span class="s1">])</span>

        <span class="s0"># General tests</span>
        <span class="s1">expected = Timestamp.max.value - ts_pos[</span><span class="s4">1</span><span class="s1">].value</span>
        <span class="s1">result = dtimax - ts_pos</span>
        <span class="s2">assert </span><span class="s1">result[</span><span class="s4">1</span><span class="s1">].value == expected</span>

        <span class="s1">expected = Timestamp.min.value - ts_neg[</span><span class="s4">1</span><span class="s1">].value</span>
        <span class="s1">result = dtimin - ts_neg</span>
        <span class="s2">assert </span><span class="s1">result[</span><span class="s4">1</span><span class="s1">].value == expected</span>
        <span class="s1">msg = </span><span class="s3">&quot;Overflow in int64 addition&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OverflowError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dtimax - ts_neg</span>

        <span class="s2">with </span><span class="s1">pytest.raises(OverflowError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dtimin - ts_pos</span>

        <span class="s0"># Edge cases</span>
        <span class="s1">tmin = pd.to_datetime([Timestamp.min])</span>
        <span class="s1">t1 = tmin + Timedelta.max + Timedelta(</span><span class="s3">&quot;1us&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OverflowError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">t1 - tmin</span>

        <span class="s1">tmax = pd.to_datetime([Timestamp.max])</span>
        <span class="s1">t2 = tmax + Timedelta.min - Timedelta(</span><span class="s3">&quot;1us&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OverflowError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tmax - t2</span>


<span class="s2">class </span><span class="s1">TestTimestampSeriesArithmetic:</span>
    <span class="s2">def </span><span class="s1">test_empty_series_add_sub(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#13844</span>
        <span class="s1">a = Series(dtype=</span><span class="s3">&quot;M8[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">b = Series(dtype=</span><span class="s3">&quot;m8[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">a = box_with_array(a)</span>
        <span class="s1">b = box_with_array(b)</span>
        <span class="s1">tm.assert_equal(a</span><span class="s2">, </span><span class="s1">a + b)</span>
        <span class="s1">tm.assert_equal(a</span><span class="s2">, </span><span class="s1">a - b)</span>
        <span class="s1">tm.assert_equal(a</span><span class="s2">, </span><span class="s1">b + a)</span>
        <span class="s1">msg = </span><span class="s3">&quot;cannot subtract&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">b - a</span>

    <span class="s2">def </span><span class="s1">test_operators_datetimelike(self):</span>

        <span class="s0"># ## timedelta64 ###</span>
        <span class="s1">td1 = Series([timedelta(minutes=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">seconds=</span><span class="s4">3</span><span class="s1">)] * </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">td1.iloc[</span><span class="s4">2</span><span class="s1">] = np.nan</span>

        <span class="s0"># ## datetime64 ###</span>
        <span class="s1">dt1 = Series(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20111230&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20120101&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20120103&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">dt1.iloc[</span><span class="s4">2</span><span class="s1">] = np.nan</span>
        <span class="s1">dt2 = Series(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20111231&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20120102&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20120104&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">dt1 - dt2</span>
        <span class="s1">dt2 - dt1</span>

        <span class="s0"># datetime64 with timetimedelta</span>
        <span class="s1">dt1 + td1</span>
        <span class="s1">td1 + dt1</span>
        <span class="s1">dt1 - td1</span>

        <span class="s0"># timetimedelta with datetime64</span>
        <span class="s1">td1 + dt1</span>
        <span class="s1">dt1 + td1</span>

    <span class="s2">def </span><span class="s1">test_dt64ser_sub_datetime_dtype(self):</span>
        <span class="s1">ts = Timestamp(datetime(</span><span class="s4">1993</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">00</span><span class="s1">))</span>
        <span class="s1">dt = datetime(</span><span class="s4">1993</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">22</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">30</span><span class="s1">)</span>
        <span class="s1">ser = Series([ts])</span>
        <span class="s1">result = pd.to_timedelta(np.abs(ser - dt))</span>
        <span class="s2">assert </span><span class="s1">result.dtype == </span><span class="s3">&quot;timedelta64[ns]&quot;</span>

    <span class="s0"># -------------------------------------------------------------</span>
    <span class="s0"># TODO: This next block of tests came from tests.series.test_operators,</span>
    <span class="s0"># needs to be de-duplicated and parametrized over `box` classes</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;left, right, op_fail&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span>
                <span class="s1">[Timestamp(</span><span class="s3">&quot;20111230&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20120101&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">,</span>
                <span class="s1">[Timestamp(</span><span class="s3">&quot;20111231&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20120102&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20120104&quot;</span><span class="s1">)]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s3">&quot;__sub__&quot;</span><span class="s2">, </span><span class="s3">&quot;__rsub__&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s1">[Timestamp(</span><span class="s3">&quot;20111230&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20120101&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">,</span>
                <span class="s1">[timedelta(minutes=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">seconds=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">timedelta(minutes=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">seconds=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s3">&quot;__add__&quot;</span><span class="s2">, </span><span class="s3">&quot;__radd__&quot;</span><span class="s2">, </span><span class="s3">&quot;__sub__&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s1">[</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;20111230&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;20111230&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">NaT</span><span class="s2">,</span>
                <span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[timedelta(minutes=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">seconds=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">timedelta(minutes=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">seconds=</span><span class="s4">3</span><span class="s1">)]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s3">&quot;__add__&quot;</span><span class="s2">, </span><span class="s3">&quot;__radd__&quot;</span><span class="s2">, </span><span class="s3">&quot;__sub__&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_operators_datetimelike_invalid(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">op_fail</span><span class="s2">, </span><span class="s1">all_arithmetic_operators</span>
    <span class="s1">):</span>
        <span class="s0"># these are all TypeError ops</span>
        <span class="s1">op_str = all_arithmetic_operators</span>
        <span class="s1">arg1 = Series(left)</span>
        <span class="s1">arg2 = Series(right)</span>
        <span class="s0"># check that we are getting a TypeError</span>
        <span class="s0"># with 'operate' (from core/ops.py) for the ops that are not</span>
        <span class="s0"># defined</span>
        <span class="s1">op = getattr(arg1</span><span class="s2">, </span><span class="s1">op_str</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s0"># Previously, _validate_for_numeric_binop in core/indexes/base.py</span>
        <span class="s0"># did this for us.</span>
        <span class="s2">if </span><span class="s1">op_str </span><span class="s2">not in </span><span class="s1">op_fail:</span>
            <span class="s2">with </span><span class="s1">pytest.raises(</span>
                <span class="s1">TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;operate|[cC]annot|unsupported operand&quot;</span>
            <span class="s1">):</span>
                <span class="s1">op(arg2)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># Smoke test</span>
            <span class="s1">op(arg2)</span>

    <span class="s2">def </span><span class="s1">test_sub_single_tz(self):</span>
        <span class="s0"># GH#12290</span>
        <span class="s1">s1 = Series([Timestamp(</span><span class="s3">&quot;2016-02-10&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;America/Sao_Paulo&quot;</span><span class="s1">)])</span>
        <span class="s1">s2 = Series([Timestamp(</span><span class="s3">&quot;2016-02-08&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;America/Sao_Paulo&quot;</span><span class="s1">)])</span>
        <span class="s1">result = s1 - s2</span>
        <span class="s1">expected = Series([Timedelta(</span><span class="s3">&quot;2days&quot;</span><span class="s1">)])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">result = s2 - s1</span>
        <span class="s1">expected = Series([Timedelta(</span><span class="s3">&quot;-2days&quot;</span><span class="s1">)])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dt64tz_series_sub_dtitz(self):</span>
        <span class="s0"># GH#19071 subtracting tzaware DatetimeIndex from tzaware Series</span>
        <span class="s0"># (with same tz) raises, fixed by #19024</span>
        <span class="s1">dti = date_range(</span><span class="s3">&quot;1999-09-30&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)</span>
        <span class="s1">ser = Series(dti)</span>
        <span class="s1">expected = Series(TimedeltaIndex([</span><span class="s3">&quot;0days&quot;</span><span class="s1">] * </span><span class="s4">10</span><span class="s1">))</span>

        <span class="s1">res = dti - ser</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">res = ser - dti</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_sub_datetime_compat(self):</span>
        <span class="s0"># see GH#14088</span>
        <span class="s1">s = Series([datetime(</span><span class="s4">2016</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">23</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s1">tzinfo=pytz.utc)</span><span class="s2">, </span><span class="s1">NaT])</span>
        <span class="s1">dt = datetime(</span><span class="s4">2016</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">22</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s1">tzinfo=pytz.utc)</span>
        <span class="s1">exp = Series([Timedelta(</span><span class="s3">&quot;1 days&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT])</span>
        <span class="s1">tm.assert_series_equal(s - dt</span><span class="s2">, </span><span class="s1">exp)</span>
        <span class="s1">tm.assert_series_equal(s - Timestamp(dt)</span><span class="s2">, </span><span class="s1">exp)</span>

    <span class="s2">def </span><span class="s1">test_dt64_series_add_mixed_tick_DateOffset(self):</span>
        <span class="s0"># GH#4532</span>
        <span class="s0"># operate with pd.offsets</span>
        <span class="s1">s = Series([Timestamp(</span><span class="s3">&quot;20130101 9:01&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20130101 9:02&quot;</span><span class="s1">)])</span>

        <span class="s1">result = s + pd.offsets.Milli(</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">result2 = pd.offsets.Milli(</span><span class="s4">5</span><span class="s1">) + s</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;20130101 9:01:00.005&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20130101 9:02:00.005&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_series_equal(result2</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = s + pd.offsets.Minute(</span><span class="s4">5</span><span class="s1">) + pd.offsets.Milli(</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;20130101 9:06:00.005&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20130101 9:07:00.005&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_datetime64_ops_nat(self):</span>
        <span class="s0"># GH#11349</span>
        <span class="s1">datetime_series = Series([NaT</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;19900315&quot;</span><span class="s1">)])</span>
        <span class="s1">nat_series_dtype_timestamp = Series([NaT</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">single_nat_dtype_datetime = Series([NaT]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span>

        <span class="s0"># subtraction</span>
        <span class="s1">tm.assert_series_equal(-NaT + datetime_series</span><span class="s2">, </span><span class="s1">nat_series_dtype_timestamp)</span>
        <span class="s1">msg = </span><span class="s3">&quot;bad operand type for unary -: 'DatetimeArray'&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">-single_nat_dtype_datetime + datetime_series</span>

        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">-NaT + nat_series_dtype_timestamp</span><span class="s2">, </span><span class="s1">nat_series_dtype_timestamp</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">-single_nat_dtype_datetime + nat_series_dtype_timestamp</span>

        <span class="s0"># addition</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">nat_series_dtype_timestamp + NaT</span><span class="s2">, </span><span class="s1">nat_series_dtype_timestamp</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">NaT + nat_series_dtype_timestamp</span><span class="s2">, </span><span class="s1">nat_series_dtype_timestamp</span>
        <span class="s1">)</span>

        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">nat_series_dtype_timestamp + NaT</span><span class="s2">, </span><span class="s1">nat_series_dtype_timestamp</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">NaT + nat_series_dtype_timestamp</span><span class="s2">, </span><span class="s1">nat_series_dtype_timestamp</span>
        <span class="s1">)</span>

    <span class="s0"># -------------------------------------------------------------</span>
    <span class="s0"># Timezone-Centric Tests</span>

    <span class="s2">def </span><span class="s1">test_operators_datetimelike_with_timezones(self):</span>
        <span class="s1">tz = </span><span class="s3">&quot;US/Eastern&quot;</span>
        <span class="s1">dt1 = Series(date_range(</span><span class="s3">&quot;2000-01-01 09:00:00&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">tz=tz)</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">dt2 = dt1.copy()</span>
        <span class="s1">dt2.iloc[</span><span class="s4">2</span><span class="s1">] = np.nan</span>

        <span class="s1">td1 = Series(pd.timedelta_range(</span><span class="s3">&quot;1 days 1 min&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;H&quot;</span><span class="s1">))</span>
        <span class="s1">td2 = td1.copy()</span>
        <span class="s1">td2.iloc[</span><span class="s4">1</span><span class="s1">] = np.nan</span>
        <span class="s2">assert </span><span class="s1">td2._values.freq </span><span class="s2">is None</span>

        <span class="s1">result = dt1 + td1[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">exp = (dt1.dt.tz_localize(</span><span class="s2">None</span><span class="s1">) + td1[</span><span class="s4">0</span><span class="s1">]).dt.tz_localize(tz)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>

        <span class="s1">result = dt2 + td2[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">exp = (dt2.dt.tz_localize(</span><span class="s2">None</span><span class="s1">) + td2[</span><span class="s4">0</span><span class="s1">]).dt.tz_localize(tz)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>

        <span class="s0"># odd numpy behavior with scalar timedeltas</span>
        <span class="s1">result = td1[</span><span class="s4">0</span><span class="s1">] + dt1</span>
        <span class="s1">exp = (dt1.dt.tz_localize(</span><span class="s2">None</span><span class="s1">) + td1[</span><span class="s4">0</span><span class="s1">]).dt.tz_localize(tz)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>

        <span class="s1">result = td2[</span><span class="s4">0</span><span class="s1">] + dt2</span>
        <span class="s1">exp = (dt2.dt.tz_localize(</span><span class="s2">None</span><span class="s1">) + td2[</span><span class="s4">0</span><span class="s1">]).dt.tz_localize(tz)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>

        <span class="s1">result = dt1 - td1[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">exp = (dt1.dt.tz_localize(</span><span class="s2">None</span><span class="s1">) - td1[</span><span class="s4">0</span><span class="s1">]).dt.tz_localize(tz)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
        <span class="s1">msg = </span><span class="s3">&quot;(bad|unsupported) operand type for unary&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">td1[</span><span class="s4">0</span><span class="s1">] - dt1</span>

        <span class="s1">result = dt2 - td2[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">exp = (dt2.dt.tz_localize(</span><span class="s2">None</span><span class="s1">) - td2[</span><span class="s4">0</span><span class="s1">]).dt.tz_localize(tz)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">td2[</span><span class="s4">0</span><span class="s1">] - dt2</span>

        <span class="s1">result = dt1 + td1</span>
        <span class="s1">exp = (dt1.dt.tz_localize(</span><span class="s2">None</span><span class="s1">) + td1).dt.tz_localize(tz)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>

        <span class="s1">result = dt2 + td2</span>
        <span class="s1">exp = (dt2.dt.tz_localize(</span><span class="s2">None</span><span class="s1">) + td2).dt.tz_localize(tz)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>

        <span class="s1">result = dt1 - td1</span>
        <span class="s1">exp = (dt1.dt.tz_localize(</span><span class="s2">None</span><span class="s1">) - td1).dt.tz_localize(tz)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>

        <span class="s1">result = dt2 - td2</span>
        <span class="s1">exp = (dt2.dt.tz_localize(</span><span class="s2">None</span><span class="s1">) - td2).dt.tz_localize(tz)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
        <span class="s1">msg = </span><span class="s3">&quot;cannot (add|subtract)&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">td1 - dt1</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">td2 - dt2</span>


<span class="s2">class </span><span class="s1">TestDatetimeIndexArithmetic:</span>
    <span class="s0"># -------------------------------------------------------------</span>
    <span class="s0"># Binary operations DatetimeIndex and TimedeltaIndex/array</span>

    <span class="s2">def </span><span class="s1">test_dti_add_tdi(self</span><span class="s2">, </span><span class="s1">tz_naive_fixture):</span>
        <span class="s0"># GH#17558</span>
        <span class="s1">tz = tz_naive_fixture</span>
        <span class="s1">dti = DatetimeIndex([Timestamp(</span><span class="s3">&quot;2017-01-01&quot;</span><span class="s2">, </span><span class="s1">tz=tz)] * </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">tdi = pd.timedelta_range(</span><span class="s3">&quot;0 days&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">expected = date_range(</span><span class="s3">&quot;2017-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">expected = expected._with_freq(</span><span class="s2">None</span><span class="s1">)</span>

        <span class="s0"># add with TimdeltaIndex</span>
        <span class="s1">result = dti + tdi</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = tdi + dti</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># add with timedelta64 array</span>
        <span class="s1">result = dti + tdi.values</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = tdi.values + dti</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dti_iadd_tdi(self</span><span class="s2">, </span><span class="s1">tz_naive_fixture):</span>
        <span class="s0"># GH#17558</span>
        <span class="s1">tz = tz_naive_fixture</span>
        <span class="s1">dti = DatetimeIndex([Timestamp(</span><span class="s3">&quot;2017-01-01&quot;</span><span class="s2">, </span><span class="s1">tz=tz)] * </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">tdi = pd.timedelta_range(</span><span class="s3">&quot;0 days&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">expected = date_range(</span><span class="s3">&quot;2017-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">expected = expected._with_freq(</span><span class="s2">None</span><span class="s1">)</span>

        <span class="s0"># iadd with TimdeltaIndex</span>
        <span class="s1">result = DatetimeIndex([Timestamp(</span><span class="s3">&quot;2017-01-01&quot;</span><span class="s2">, </span><span class="s1">tz=tz)] * </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">result += tdi</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = pd.timedelta_range(</span><span class="s3">&quot;0 days&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">result += dti</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># iadd with timedelta64 array</span>
        <span class="s1">result = DatetimeIndex([Timestamp(</span><span class="s3">&quot;2017-01-01&quot;</span><span class="s2">, </span><span class="s1">tz=tz)] * </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">result += tdi.values</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = pd.timedelta_range(</span><span class="s3">&quot;0 days&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">result += dti</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dti_sub_tdi(self</span><span class="s2">, </span><span class="s1">tz_naive_fixture):</span>
        <span class="s0"># GH#17558</span>
        <span class="s1">tz = tz_naive_fixture</span>
        <span class="s1">dti = DatetimeIndex([Timestamp(</span><span class="s3">&quot;2017-01-01&quot;</span><span class="s2">, </span><span class="s1">tz=tz)] * </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">tdi = pd.timedelta_range(</span><span class="s3">&quot;0 days&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">expected = date_range(</span><span class="s3">&quot;2017-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">tz=tz</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;-1D&quot;</span><span class="s1">)</span>
        <span class="s1">expected = expected._with_freq(</span><span class="s2">None</span><span class="s1">)</span>

        <span class="s0"># sub with TimedeltaIndex</span>
        <span class="s1">result = dti - tdi</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">msg = </span><span class="s3">&quot;cannot subtract .*TimedeltaArray&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tdi - dti</span>

        <span class="s0"># sub with timedelta64 array</span>
        <span class="s1">result = dti - tdi.values</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">msg = </span><span class="s3">&quot;cannot subtract a datelike from a TimedeltaArray&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tdi.values - dti</span>

    <span class="s2">def </span><span class="s1">test_dti_isub_tdi(self</span><span class="s2">, </span><span class="s1">tz_naive_fixture):</span>
        <span class="s0"># GH#17558</span>
        <span class="s1">tz = tz_naive_fixture</span>
        <span class="s1">dti = DatetimeIndex([Timestamp(</span><span class="s3">&quot;2017-01-01&quot;</span><span class="s2">, </span><span class="s1">tz=tz)] * </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">tdi = pd.timedelta_range(</span><span class="s3">&quot;0 days&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">expected = date_range(</span><span class="s3">&quot;2017-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">tz=tz</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;-1D&quot;</span><span class="s1">)</span>
        <span class="s1">expected = expected._with_freq(</span><span class="s2">None</span><span class="s1">)</span>

        <span class="s0"># isub with TimedeltaIndex</span>
        <span class="s1">result = DatetimeIndex([Timestamp(</span><span class="s3">&quot;2017-01-01&quot;</span><span class="s2">, </span><span class="s1">tz=tz)] * </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">result -= tdi</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># DTA.__isub__ GH#43904</span>
        <span class="s1">dta = dti._data.copy()</span>
        <span class="s1">dta -= tdi</span>
        <span class="s1">tm.assert_datetime_array_equal(dta</span><span class="s2">, </span><span class="s1">expected._data)</span>

        <span class="s1">out = dti._data.copy()</span>
        <span class="s1">np.subtract(out</span><span class="s2">, </span><span class="s1">tdi</span><span class="s2">, </span><span class="s1">out=out)</span>
        <span class="s1">tm.assert_datetime_array_equal(out</span><span class="s2">, </span><span class="s1">expected._data)</span>

        <span class="s1">msg = </span><span class="s3">&quot;cannot subtract a datelike from a TimedeltaArray&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tdi -= dti</span>

        <span class="s0"># isub with timedelta64 array</span>
        <span class="s1">result = DatetimeIndex([Timestamp(</span><span class="s3">&quot;2017-01-01&quot;</span><span class="s2">, </span><span class="s1">tz=tz)] * </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">result -= tdi.values</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tdi.values -= dti</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tdi._values -= dti</span>

    <span class="s0"># -------------------------------------------------------------</span>
    <span class="s0"># Binary Operations DatetimeIndex and datetime-like</span>
    <span class="s0"># TODO: A couple other tests belong in this section.  Move them in</span>
    <span class="s0"># A PR where there isn't already a giant diff.</span>

    <span class="s0"># -------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">test_dta_add_sub_index(self</span><span class="s2">, </span><span class="s1">tz_naive_fixture):</span>
        <span class="s0"># Check that DatetimeArray defers to Index classes</span>
        <span class="s1">dti = date_range(</span><span class="s3">&quot;20130101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">tz=tz_naive_fixture)</span>
        <span class="s1">dta = dti.array</span>
        <span class="s1">result = dta - dti</span>
        <span class="s1">expected = dti - dti</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">tdi = result</span>
        <span class="s1">result = dta + tdi</span>
        <span class="s1">expected = dti + tdi</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = dta - tdi</span>
        <span class="s1">expected = dti - tdi</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_sub_dti_dti(self):</span>
        <span class="s0"># previously performed setop (deprecated in 0.16.0), now changed to</span>
        <span class="s0"># return subtraction -&gt; TimeDeltaIndex (GH ...)</span>

        <span class="s1">dti = date_range(</span><span class="s3">&quot;20130101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">dti_tz = date_range(</span><span class="s3">&quot;20130101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">).tz_localize(</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s1">expected = TimedeltaIndex([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>

        <span class="s1">result = dti - dti</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = dti_tz - dti_tz</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">msg = </span><span class="s3">&quot;Cannot subtract tz-naive and tz-aware datetime-like objects&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dti_tz - dti</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dti - dti_tz</span>

        <span class="s0"># isub</span>
        <span class="s1">dti -= dti</span>
        <span class="s1">tm.assert_index_equal(dti</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># different length raises ValueError</span>
        <span class="s1">dti1 = date_range(</span><span class="s3">&quot;20130101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">dti2 = date_range(</span><span class="s3">&quot;20130101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">msg = </span><span class="s3">&quot;cannot add indices of unequal length&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">dti1 - dti2</span>

        <span class="s0"># NaN propagation</span>
        <span class="s1">dti1 = DatetimeIndex([</span><span class="s3">&quot;2012-01-01&quot;</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">&quot;2012-01-03&quot;</span><span class="s1">])</span>
        <span class="s1">dti2 = DatetimeIndex([</span><span class="s3">&quot;2012-01-02&quot;</span><span class="s2">, </span><span class="s3">&quot;2012-01-03&quot;</span><span class="s2">, </span><span class="s1">np.nan])</span>
        <span class="s1">expected = TimedeltaIndex([</span><span class="s3">&quot;1 days&quot;</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan])</span>
        <span class="s1">result = dti2 - dti1</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s0"># -------------------------------------------------------------------</span>
    <span class="s0"># TODO: Most of this block is moved from series or frame tests, needs</span>
    <span class="s0"># cleanup, box-parametrization, and de-duplication</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;op&quot;</span><span class="s2">, </span><span class="s1">[operator.add</span><span class="s2">, </span><span class="s1">operator.sub])</span>
    <span class="s2">def </span><span class="s1">test_timedelta64_equal_timedelta_supported_ops(self</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">ser = Series(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20130301&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20130228 23:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20130228 22:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20130228 21:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">obj = box_with_array(ser)</span>

        <span class="s1">intervals = [</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s3">&quot;h&quot;</span><span class="s2">, </span><span class="s3">&quot;m&quot;</span><span class="s2">, </span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s3">&quot;us&quot;</span><span class="s1">]</span>

        <span class="s2">def </span><span class="s1">timedelta64(*args):</span>
            <span class="s0"># see casting notes in NumPy gh-12927</span>
            <span class="s2">return </span><span class="s1">np.sum(list(starmap(np.timedelta64</span><span class="s2">, </span><span class="s1">zip(args</span><span class="s2">, </span><span class="s1">intervals))))</span>

        <span class="s2">for </span><span class="s1">d</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">us </span><span class="s2">in </span><span class="s1">product(*([range(</span><span class="s4">2</span><span class="s1">)] * </span><span class="s4">5</span><span class="s1">)):</span>
            <span class="s1">nptd = timedelta64(d</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">us)</span>
            <span class="s1">pytd = timedelta(days=d</span><span class="s2">, </span><span class="s1">hours=h</span><span class="s2">, </span><span class="s1">minutes=m</span><span class="s2">, </span><span class="s1">seconds=s</span><span class="s2">, </span><span class="s1">microseconds=us)</span>
            <span class="s1">lhs = op(obj</span><span class="s2">, </span><span class="s1">nptd)</span>
            <span class="s1">rhs = op(obj</span><span class="s2">, </span><span class="s1">pytd)</span>

            <span class="s1">tm.assert_equal(lhs</span><span class="s2">, </span><span class="s1">rhs)</span>

    <span class="s2">def </span><span class="s1">test_ops_nat_mixed_datetime64_timedelta64(self):</span>
        <span class="s0"># GH#11349</span>
        <span class="s1">timedelta_series = Series([NaT</span><span class="s2">, </span><span class="s1">Timedelta(</span><span class="s3">&quot;1s&quot;</span><span class="s1">)])</span>
        <span class="s1">datetime_series = Series([NaT</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;19900315&quot;</span><span class="s1">)])</span>
        <span class="s1">nat_series_dtype_timedelta = Series([NaT</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">nat_series_dtype_timestamp = Series([NaT</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">single_nat_dtype_datetime = Series([NaT]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">single_nat_dtype_timedelta = Series([NaT]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>

        <span class="s0"># subtraction</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">datetime_series - single_nat_dtype_datetime</span><span class="s2">, </span><span class="s1">nat_series_dtype_timedelta</span>
        <span class="s1">)</span>

        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">datetime_series - single_nat_dtype_timedelta</span><span class="s2">, </span><span class="s1">nat_series_dtype_timestamp</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">-single_nat_dtype_timedelta + datetime_series</span><span class="s2">, </span><span class="s1">nat_series_dtype_timestamp</span>
        <span class="s1">)</span>

        <span class="s0"># without a Series wrapping the NaT, it is ambiguous</span>
        <span class="s0"># whether it is a datetime64 or timedelta64</span>
        <span class="s0"># defaults to interpreting it as timedelta64</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">nat_series_dtype_timestamp - single_nat_dtype_datetime</span><span class="s2">,</span>
            <span class="s1">nat_series_dtype_timedelta</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">nat_series_dtype_timestamp - single_nat_dtype_timedelta</span><span class="s2">,</span>
            <span class="s1">nat_series_dtype_timestamp</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">-single_nat_dtype_timedelta + nat_series_dtype_timestamp</span><span class="s2">,</span>
            <span class="s1">nat_series_dtype_timestamp</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">msg = </span><span class="s3">&quot;cannot subtract a datelike&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">timedelta_series - single_nat_dtype_datetime</span>

        <span class="s0"># addition</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">nat_series_dtype_timestamp + single_nat_dtype_timedelta</span><span class="s2">,</span>
            <span class="s1">nat_series_dtype_timestamp</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">single_nat_dtype_timedelta + nat_series_dtype_timestamp</span><span class="s2">,</span>
            <span class="s1">nat_series_dtype_timestamp</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">nat_series_dtype_timestamp + single_nat_dtype_timedelta</span><span class="s2">,</span>
            <span class="s1">nat_series_dtype_timestamp</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">single_nat_dtype_timedelta + nat_series_dtype_timestamp</span><span class="s2">,</span>
            <span class="s1">nat_series_dtype_timestamp</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">nat_series_dtype_timedelta + single_nat_dtype_datetime</span><span class="s2">,</span>
            <span class="s1">nat_series_dtype_timestamp</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">single_nat_dtype_datetime + nat_series_dtype_timedelta</span><span class="s2">,</span>
            <span class="s1">nat_series_dtype_timestamp</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ufunc_coercions(self):</span>
        <span class="s1">idx = date_range(</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;2D&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;x&quot;</span><span class="s1">)</span>

        <span class="s1">delta = np.timedelta64(</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">)</span>
        <span class="s1">exp = date_range(</span><span class="s3">&quot;2011-01-02&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;2D&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">[idx + delta</span><span class="s2">, </span><span class="s1">np.add(idx</span><span class="s2">, </span><span class="s1">delta)]:</span>
            <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">DatetimeIndex)</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
            <span class="s2">assert </span><span class="s1">result.freq == </span><span class="s3">&quot;2D&quot;</span>

        <span class="s1">exp = date_range(</span><span class="s3">&quot;2010-12-31&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;2D&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;x&quot;</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">[idx - delta</span><span class="s2">, </span><span class="s1">np.subtract(idx</span><span class="s2">, </span><span class="s1">delta)]:</span>
            <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">DatetimeIndex)</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
            <span class="s2">assert </span><span class="s1">result.freq == </span><span class="s3">&quot;2D&quot;</span>

        <span class="s0"># When adding/subtracting an ndarray (which has no .freq), the result</span>
        <span class="s0">#  does not infer freq</span>
        <span class="s1">idx = idx._with_freq(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">delta = np.array(</span>
            <span class="s1">[np.timedelta64(</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.timedelta64(</span><span class="s4">2</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.timedelta64(</span><span class="s4">3</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">exp = DatetimeIndex([</span><span class="s3">&quot;2011-01-02&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-01-05&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-01-08&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;x&quot;</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">[idx + delta</span><span class="s2">, </span><span class="s1">np.add(idx</span><span class="s2">, </span><span class="s1">delta)]:</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
            <span class="s2">assert </span><span class="s1">result.freq == exp.freq</span>

        <span class="s1">exp = DatetimeIndex([</span><span class="s3">&quot;2010-12-31&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-01-02&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">[idx - delta</span><span class="s2">, </span><span class="s1">np.subtract(idx</span><span class="s2">, </span><span class="s1">delta)]:</span>
            <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">DatetimeIndex)</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>
            <span class="s2">assert </span><span class="s1">result.freq == exp.freq</span>

    <span class="s2">def </span><span class="s1">test_dti_add_series(self</span><span class="s2">, </span><span class="s1">tz_naive_fixture</span><span class="s2">, </span><span class="s1">names):</span>
        <span class="s0"># GH#13905</span>
        <span class="s1">tz = tz_naive_fixture</span>
        <span class="s1">index = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;2016-06-28 05:30&quot;</span><span class="s2">, </span><span class="s3">&quot;2016-06-28 05:31&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tz=tz</span><span class="s2">, </span><span class="s1">name=names[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">ser = Series([Timedelta(seconds=</span><span class="s4">5</span><span class="s1">)] * </span><span class="s4">2</span><span class="s2">, </span><span class="s1">index=index</span><span class="s2">, </span><span class="s1">name=names[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">expected = Series(index + Timedelta(seconds=</span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">index=index</span><span class="s2">, </span><span class="s1">name=names[</span><span class="s4">2</span><span class="s1">])</span>

        <span class="s0"># passing name arg isn't enough when names[2] is None</span>
        <span class="s1">expected.name = names[</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">expected.dtype == index.dtype</span>
        <span class="s1">result = ser + index</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">result2 = index + ser</span>
        <span class="s1">tm.assert_series_equal(result2</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">expected = index + Timedelta(seconds=</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">result3 = ser.values + index</span>
        <span class="s1">tm.assert_index_equal(result3</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">result4 = index + ser.values</span>
        <span class="s1">tm.assert_index_equal(result4</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;op&quot;</span><span class="s2">, </span><span class="s1">[operator.add</span><span class="s2">, </span><span class="s1">roperator.radd</span><span class="s2">, </span><span class="s1">operator.sub])</span>
    <span class="s2">def </span><span class="s1">test_dti_addsub_offset_arraylike(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">tz_naive_fixture</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">index_or_series</span>
    <span class="s1">):</span>
        <span class="s0"># GH#18849, GH#19744</span>
        <span class="s1">other_box = index_or_series</span>

        <span class="s1">tz = tz_naive_fixture</span>
        <span class="s1">dti = date_range(</span><span class="s3">&quot;2017-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">tz=tz</span><span class="s2">, </span><span class="s1">name=names[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">other = other_box([pd.offsets.MonthEnd()</span><span class="s2">, </span><span class="s1">pd.offsets.Day(n=</span><span class="s4">2</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">name=names[</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s1">xbox = get_upcast_box(dti</span><span class="s2">, </span><span class="s1">other)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">res = op(dti</span><span class="s2">, </span><span class="s1">other)</span>

        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[op(dti[n]</span><span class="s2">, </span><span class="s1">other[n]) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(len(dti))]</span><span class="s2">, </span><span class="s1">name=names[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;infer&quot;</span>
        <span class="s1">)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>
        <span class="s1">tm.assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;other_box&quot;</span><span class="s2">, </span><span class="s1">[pd.Index</span><span class="s2">, </span><span class="s1">np.array])</span>
    <span class="s2">def </span><span class="s1">test_dti_addsub_object_arraylike(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">tz_naive_fixture</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">other_box</span>
    <span class="s1">):</span>
        <span class="s1">tz = tz_naive_fixture</span>

        <span class="s1">dti = date_range(</span><span class="s3">&quot;2017-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">dtarr = tm.box_expected(dti</span><span class="s2">, </span><span class="s1">box_with_array)</span>
        <span class="s1">other = other_box([pd.offsets.MonthEnd()</span><span class="s2">, </span><span class="s1">Timedelta(days=</span><span class="s4">4</span><span class="s1">)])</span>
        <span class="s1">xbox = get_upcast_box(dtarr</span><span class="s2">, </span><span class="s1">other)</span>

        <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;2017-01-31&quot;</span><span class="s2">, </span><span class="s3">&quot;2017-01-06&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tz=tz_naive_fixture)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">result = dtarr + other</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;2016-12-31&quot;</span><span class="s2">, </span><span class="s3">&quot;2016-12-29&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tz=tz_naive_fixture)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">result = dtarr - other</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;years&quot;</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;months&quot;</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_shift_months(years</span><span class="s2">, </span><span class="s1">months):</span>
    <span class="s1">dti = DatetimeIndex(</span>
        <span class="s1">[</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-05 00:15:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-31 00:23:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2000-02-29&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2000-12-31&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">actual = DatetimeIndex(shift_months(dti.asi8</span><span class="s2">, </span><span class="s1">years * </span><span class="s4">12 </span><span class="s1">+ months))</span>

    <span class="s1">raw = [x + pd.offsets.DateOffset(years=years</span><span class="s2">, </span><span class="s1">months=months) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dti]</span>
    <span class="s1">expected = DatetimeIndex(raw)</span>
    <span class="s1">tm.assert_index_equal(actual</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_dt64arr_addsub_object_dtype_2d():</span>
    <span class="s0"># block-wise DataFrame operations will require operating on 2D</span>
    <span class="s0">#  DatetimeArray/TimedeltaArray, so check that specifically.</span>
    <span class="s1">dti = date_range(</span><span class="s3">&quot;1994-02-13&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;2W&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">dta = dti._data.reshape((</span><span class="s4">4</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>

    <span class="s1">other = np.array([[pd.offsets.Day(n)] </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s1">)])</span>
    <span class="s2">assert </span><span class="s1">other.shape == dta.shape</span>

    <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
        <span class="s1">result = dta + other</span>
    <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
        <span class="s1">expected = (dta[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] + other[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]).reshape(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">DatetimeArray)</span>
    <span class="s2">assert </span><span class="s1">result.freq </span><span class="s2">is None</span>
    <span class="s1">tm.assert_numpy_array_equal(result._data</span><span class="s2">, </span><span class="s1">expected._data)</span>

    <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
        <span class="s0"># Case where we expect to get a TimedeltaArray back</span>
        <span class="s1">result2 = dta - dta.astype(object)</span>

    <span class="s2">assert </span><span class="s1">isinstance(result2</span><span class="s2">, </span><span class="s1">TimedeltaArray)</span>
    <span class="s2">assert </span><span class="s1">result2.shape == (</span><span class="s4">4</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">result2.freq </span><span class="s2">is None</span>
    <span class="s2">assert </span><span class="s1">(result2.asi8 == </span><span class="s4">0</span><span class="s1">).all()</span>
</pre>
</body>
</html>