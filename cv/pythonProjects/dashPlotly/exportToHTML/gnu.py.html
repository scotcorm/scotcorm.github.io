<html>
<head>
<title>gnu.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
gnu.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">import </span><span class="s1">platform</span>
<span class="s0">import </span><span class="s1">tempfile</span>
<span class="s0">import </span><span class="s1">hashlib</span>
<span class="s0">import </span><span class="s1">base64</span>
<span class="s0">import </span><span class="s1">subprocess</span>
<span class="s0">from </span><span class="s1">subprocess </span><span class="s0">import </span><span class="s1">Popen</span><span class="s0">, </span><span class="s1">PIPE</span><span class="s0">, </span><span class="s1">STDOUT</span>
<span class="s0">from </span><span class="s1">numpy.distutils.exec_command </span><span class="s0">import </span><span class="s1">filepath_from_subprocess_output</span>
<span class="s0">from </span><span class="s1">numpy.distutils.fcompiler </span><span class="s0">import </span><span class="s1">FCompiler</span>
<span class="s0">from </span><span class="s1">distutils.version </span><span class="s0">import </span><span class="s1">LooseVersion</span>

<span class="s1">compilers = [</span><span class="s2">'GnuFCompiler'</span><span class="s0">, </span><span class="s2">'Gnu95FCompiler'</span><span class="s1">]</span>

<span class="s1">TARGET_R = re.compile(</span><span class="s2">r&quot;Target: ([a-zA-Z0-9_\-]*)&quot;</span><span class="s1">)</span>

<span class="s3"># XXX: handle cross compilation</span>


<span class="s0">def </span><span class="s1">is_win64():</span>
    <span class="s0">return </span><span class="s1">sys.platform == </span><span class="s2">&quot;win32&quot; </span><span class="s0">and </span><span class="s1">platform.architecture()[</span><span class="s4">0</span><span class="s1">] == </span><span class="s2">&quot;64bit&quot;</span>


<span class="s0">class </span><span class="s1">GnuFCompiler(FCompiler):</span>
    <span class="s1">compiler_type = </span><span class="s2">'gnu'</span>
    <span class="s1">compiler_aliases = (</span><span class="s2">'g77'</span><span class="s0">, </span><span class="s1">)</span>
    <span class="s1">description = </span><span class="s2">'GNU Fortran 77 compiler'</span>

    <span class="s0">def </span><span class="s1">gnu_version_match(self</span><span class="s0">, </span><span class="s1">version_string):</span>
        <span class="s5">&quot;&quot;&quot;Handle the different versions of GNU fortran compilers&quot;&quot;&quot;</span>
        <span class="s3"># Strip warning(s) that may be emitted by gfortran</span>
        <span class="s0">while </span><span class="s1">version_string.startswith(</span><span class="s2">'gfortran: warning'</span><span class="s1">):</span>
            <span class="s1">version_string =\</span>
                <span class="s1">version_string[version_string.find(</span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">) + </span><span class="s4">1</span><span class="s1">:].strip()</span>

        <span class="s3"># Gfortran versions from after 2010 will output a simple string</span>
        <span class="s3"># (usually &quot;x.y&quot;, &quot;x.y.z&quot; or &quot;x.y.z-q&quot;) for ``-dumpversion``; older</span>
        <span class="s3"># gfortrans may still return long version strings (``-dumpversion`` was</span>
        <span class="s3"># an alias for ``--version``)</span>
        <span class="s0">if </span><span class="s1">len(version_string) &lt;= </span><span class="s4">20</span><span class="s1">:</span>
            <span class="s3"># Try to find a valid version string</span>
            <span class="s1">m = re.search(</span><span class="s2">r'([0-9.]+)'</span><span class="s0">, </span><span class="s1">version_string)</span>
            <span class="s0">if </span><span class="s1">m:</span>
                <span class="s3"># g77 provides a longer version string that starts with GNU</span>
                <span class="s3"># Fortran</span>
                <span class="s0">if </span><span class="s1">version_string.startswith(</span><span class="s2">'GNU Fortran'</span><span class="s1">):</span>
                    <span class="s0">return </span><span class="s1">(</span><span class="s2">'g77'</span><span class="s0">, </span><span class="s1">m.group(</span><span class="s4">1</span><span class="s1">))</span>

                <span class="s3"># gfortran only outputs a version string such as #.#.#, so check</span>
                <span class="s3"># if the match is at the start of the string</span>
                <span class="s0">elif </span><span class="s1">m.start() == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">(</span><span class="s2">'gfortran'</span><span class="s0">, </span><span class="s1">m.group(</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># Output probably from --version, try harder:</span>
            <span class="s1">m = re.search(</span><span class="s2">r'GNU Fortran\s+95.*?([0-9-.]+)'</span><span class="s0">, </span><span class="s1">version_string)</span>
            <span class="s0">if </span><span class="s1">m:</span>
                <span class="s0">return </span><span class="s1">(</span><span class="s2">'gfortran'</span><span class="s0">, </span><span class="s1">m.group(</span><span class="s4">1</span><span class="s1">))</span>
            <span class="s1">m = re.search(</span>
                <span class="s2">r'GNU Fortran.*?\-?([0-9-.]+\.[0-9-.]+)'</span><span class="s0">, </span><span class="s1">version_string)</span>
            <span class="s0">if </span><span class="s1">m:</span>
                <span class="s1">v = m.group(</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">v.startswith(</span><span class="s2">'0'</span><span class="s1">) </span><span class="s0">or </span><span class="s1">v.startswith(</span><span class="s2">'2'</span><span class="s1">) </span><span class="s0">or </span><span class="s1">v.startswith(</span><span class="s2">'3'</span><span class="s1">):</span>
                    <span class="s3"># the '0' is for early g77's</span>
                    <span class="s0">return </span><span class="s1">(</span><span class="s2">'g77'</span><span class="s0">, </span><span class="s1">v)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s3"># at some point in the 4.x series, the ' 95' was dropped</span>
                    <span class="s3"># from the version string</span>
                    <span class="s0">return </span><span class="s1">(</span><span class="s2">'gfortran'</span><span class="s0">, </span><span class="s1">v)</span>

        <span class="s3"># If still nothing, raise an error to make the problem easy to find.</span>
        <span class="s1">err = </span><span class="s2">'A valid Fortran version was not found in this string:</span><span class="s0">\n</span><span class="s2">'</span>
        <span class="s0">raise </span><span class="s1">ValueError(err + version_string)</span>

    <span class="s0">def </span><span class="s1">version_match(self</span><span class="s0">, </span><span class="s1">version_string):</span>
        <span class="s1">v = self.gnu_version_match(version_string)</span>
        <span class="s0">if not </span><span class="s1">v </span><span class="s0">or </span><span class="s1">v[</span><span class="s4">0</span><span class="s1">] != </span><span class="s2">'g77'</span><span class="s1">:</span>
            <span class="s0">return None</span>
        <span class="s0">return </span><span class="s1">v[</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">possible_executables = [</span><span class="s2">'g77'</span><span class="s0">, </span><span class="s2">'f77'</span><span class="s1">]</span>
    <span class="s1">executables = {</span>
        <span class="s2">'version_cmd'  </span><span class="s1">: [</span><span class="s0">None, </span><span class="s2">&quot;-dumpversion&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s2">'compiler_f77' </span><span class="s1">: [</span><span class="s0">None, </span><span class="s2">&quot;-g&quot;</span><span class="s0">, </span><span class="s2">&quot;-Wall&quot;</span><span class="s0">, </span><span class="s2">&quot;-fno-second-underscore&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s2">'compiler_f90' </span><span class="s1">: </span><span class="s0">None,  </span><span class="s3"># Use --fcompiler=gnu95 for f90 codes</span>
        <span class="s2">'compiler_fix' </span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s2">'linker_so'    </span><span class="s1">: [</span><span class="s0">None, </span><span class="s2">&quot;-g&quot;</span><span class="s0">, </span><span class="s2">&quot;-Wall&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s2">'archiver'     </span><span class="s1">: [</span><span class="s2">&quot;ar&quot;</span><span class="s0">, </span><span class="s2">&quot;-cr&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s2">'ranlib'       </span><span class="s1">: [</span><span class="s2">&quot;ranlib&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s2">'linker_exe'   </span><span class="s1">: [</span><span class="s0">None, </span><span class="s2">&quot;-g&quot;</span><span class="s0">, </span><span class="s2">&quot;-Wall&quot;</span><span class="s1">]</span>
    <span class="s1">}</span>
    <span class="s1">module_dir_switch = </span><span class="s0">None</span>
    <span class="s1">module_include_switch = </span><span class="s0">None</span>

    <span class="s3"># Cygwin: f771: warning: -fPIC ignored for target (all code is</span>
    <span class="s3"># position independent)</span>
    <span class="s0">if </span><span class="s1">os.name != </span><span class="s2">'nt' </span><span class="s0">and </span><span class="s1">sys.platform != </span><span class="s2">'cygwin'</span><span class="s1">:</span>
        <span class="s1">pic_flags = [</span><span class="s2">'-fPIC'</span><span class="s1">]</span>

    <span class="s3"># use -mno-cygwin for g77 when Python is not Cygwin-Python</span>
    <span class="s0">if </span><span class="s1">sys.platform == </span><span class="s2">'win32'</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'version_cmd'</span><span class="s0">, </span><span class="s2">'compiler_f77'</span><span class="s0">, </span><span class="s2">'linker_so'</span><span class="s0">, </span><span class="s2">'linker_exe'</span><span class="s1">]:</span>
            <span class="s1">executables[key].append(</span><span class="s2">'-mno-cygwin'</span><span class="s1">)</span>

    <span class="s1">g2c = </span><span class="s2">'g2c'</span>
    <span class="s1">suggested_f90_compiler = </span><span class="s2">'gnu95'</span>

    <span class="s0">def </span><span class="s1">get_flags_linker_so(self):</span>
        <span class="s1">opt = self.linker_so[</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s0">if </span><span class="s1">sys.platform == </span><span class="s2">'darwin'</span><span class="s1">:</span>
            <span class="s1">target = os.environ.get(</span><span class="s2">'MACOSX_DEPLOYMENT_TARGET'</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s3"># If MACOSX_DEPLOYMENT_TARGET is set, we simply trust the value</span>
            <span class="s3"># and leave it alone.  But, distutils will complain if the</span>
            <span class="s3"># environment's value is different from the one in the Python</span>
            <span class="s3"># Makefile used to build Python.  We let distutils handle this</span>
            <span class="s3"># error checking.</span>
            <span class="s0">if not </span><span class="s1">target:</span>
                <span class="s3"># If MACOSX_DEPLOYMENT_TARGET is not set in the environment,</span>
                <span class="s3"># we try to get it first from sysconfig and then</span>
                <span class="s3"># fall back to setting it to 10.9 This is a reasonable default</span>
                <span class="s3"># even when using the official Python dist and those derived</span>
                <span class="s3"># from it.</span>
                <span class="s0">import </span><span class="s1">sysconfig</span>
                <span class="s1">target = sysconfig.get_config_var(</span><span class="s2">'MACOSX_DEPLOYMENT_TARGET'</span><span class="s1">)</span>
                <span class="s0">if not </span><span class="s1">target:</span>
                    <span class="s1">target = </span><span class="s2">'10.9'</span>
                    <span class="s1">s = </span><span class="s2">f'Env. variable MACOSX_DEPLOYMENT_TARGET set to </span><span class="s0">{</span><span class="s1">target</span><span class="s0">}</span><span class="s2">'</span>
                    <span class="s1">warnings.warn(s</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
                <span class="s1">os.environ[</span><span class="s2">'MACOSX_DEPLOYMENT_TARGET'</span><span class="s1">] = str(target)</span>
            <span class="s1">opt.extend([</span><span class="s2">'-undefined'</span><span class="s0">, </span><span class="s2">'dynamic_lookup'</span><span class="s0">, </span><span class="s2">'-bundle'</span><span class="s1">])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">opt.append(</span><span class="s2">&quot;-shared&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">sys.platform.startswith(</span><span class="s2">'sunos'</span><span class="s1">):</span>
            <span class="s3"># SunOS often has dynamically loaded symbols defined in the</span>
            <span class="s3"># static library libg2c.a  The linker doesn't like this.  To</span>
            <span class="s3"># ignore the problem, use the -mimpure-text flag.  It isn't</span>
            <span class="s3"># the safest thing, but seems to work. 'man gcc' says:</span>
            <span class="s3"># &quot;.. Instead of using -mimpure-text, you should compile all</span>
            <span class="s3">#  source code with -fpic or -fPIC.&quot;</span>
            <span class="s1">opt.append(</span><span class="s2">'-mimpure-text'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">opt</span>

    <span class="s0">def </span><span class="s1">get_libgcc_dir(self):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">output = subprocess.check_output(self.compiler_f77 +</span>
                                            <span class="s1">[</span><span class="s2">'-print-libgcc-file-name'</span><span class="s1">])</span>
        <span class="s0">except </span><span class="s1">(OSError</span><span class="s0">, </span><span class="s1">subprocess.CalledProcessError):</span>
            <span class="s0">pass</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">output = filepath_from_subprocess_output(output)</span>
            <span class="s0">return </span><span class="s1">os.path.dirname(output)</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">get_libgfortran_dir(self):</span>
        <span class="s0">if </span><span class="s1">sys.platform[:</span><span class="s4">5</span><span class="s1">] == </span><span class="s2">'linux'</span><span class="s1">:</span>
            <span class="s1">libgfortran_name = </span><span class="s2">'libgfortran.so'</span>
        <span class="s0">elif </span><span class="s1">sys.platform == </span><span class="s2">'darwin'</span><span class="s1">:</span>
            <span class="s1">libgfortran_name = </span><span class="s2">'libgfortran.dylib'</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">libgfortran_name = </span><span class="s0">None</span>

        <span class="s1">libgfortran_dir = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">libgfortran_name:</span>
            <span class="s1">find_lib_arg = [</span><span class="s2">'-print-file-name={0}'</span><span class="s1">.format(libgfortran_name)]</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">output = subprocess.check_output(</span>
                                       <span class="s1">self.compiler_f77 + find_lib_arg)</span>
            <span class="s0">except </span><span class="s1">(OSError</span><span class="s0">, </span><span class="s1">subprocess.CalledProcessError):</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">output = filepath_from_subprocess_output(output)</span>
                <span class="s1">libgfortran_dir = os.path.dirname(output)</span>
        <span class="s0">return </span><span class="s1">libgfortran_dir</span>

    <span class="s0">def </span><span class="s1">get_library_dirs(self):</span>
        <span class="s1">opt = []</span>
        <span class="s0">if </span><span class="s1">sys.platform[:</span><span class="s4">5</span><span class="s1">] != </span><span class="s2">'linux'</span><span class="s1">:</span>
            <span class="s1">d = self.get_libgcc_dir()</span>
            <span class="s0">if </span><span class="s1">d:</span>
                <span class="s3"># if windows and not cygwin, libg2c lies in a different folder</span>
                <span class="s0">if </span><span class="s1">sys.platform == </span><span class="s2">'win32' </span><span class="s0">and not </span><span class="s1">d.startswith(</span><span class="s2">'/usr/lib'</span><span class="s1">):</span>
                    <span class="s1">d = os.path.normpath(d)</span>
                    <span class="s1">path = os.path.join(d</span><span class="s0">, </span><span class="s2">&quot;lib%s.a&quot; </span><span class="s1">% self.g2c)</span>
                    <span class="s0">if not </span><span class="s1">os.path.exists(path):</span>
                        <span class="s1">root = os.path.join(d</span><span class="s0">, </span><span class="s1">*((os.pardir</span><span class="s0">, </span><span class="s1">) * </span><span class="s4">4</span><span class="s1">))</span>
                        <span class="s1">d2 = os.path.abspath(os.path.join(root</span><span class="s0">, </span><span class="s2">'lib'</span><span class="s1">))</span>
                        <span class="s1">path = os.path.join(d2</span><span class="s0">, </span><span class="s2">&quot;lib%s.a&quot; </span><span class="s1">% self.g2c)</span>
                        <span class="s0">if </span><span class="s1">os.path.exists(path):</span>
                            <span class="s1">opt.append(d2)</span>
                <span class="s1">opt.append(d)</span>
        <span class="s3"># For Macports / Linux, libgfortran and libgcc are not co-located</span>
        <span class="s1">lib_gfortran_dir = self.get_libgfortran_dir()</span>
        <span class="s0">if </span><span class="s1">lib_gfortran_dir:</span>
            <span class="s1">opt.append(lib_gfortran_dir)</span>
        <span class="s0">return </span><span class="s1">opt</span>

    <span class="s0">def </span><span class="s1">get_libraries(self):</span>
        <span class="s1">opt = []</span>
        <span class="s1">d = self.get_libgcc_dir()</span>
        <span class="s0">if </span><span class="s1">d </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">g2c = self.g2c + </span><span class="s2">'-pic'</span>
            <span class="s1">f = self.static_lib_format % (g2c</span><span class="s0">, </span><span class="s1">self.static_lib_extension)</span>
            <span class="s0">if not </span><span class="s1">os.path.isfile(os.path.join(d</span><span class="s0">, </span><span class="s1">f)):</span>
                <span class="s1">g2c = self.g2c</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">g2c = self.g2c</span>

        <span class="s0">if </span><span class="s1">g2c </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">opt.append(g2c)</span>
        <span class="s1">c_compiler = self.c_compiler</span>
        <span class="s0">if </span><span class="s1">sys.platform == </span><span class="s2">'win32' </span><span class="s0">and </span><span class="s1">c_compiler </span><span class="s0">and </span><span class="s1">\</span>
                <span class="s1">c_compiler.compiler_type == </span><span class="s2">'msvc'</span><span class="s1">:</span>
            <span class="s1">opt.append(</span><span class="s2">'gcc'</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">sys.platform == </span><span class="s2">'darwin'</span><span class="s1">:</span>
            <span class="s1">opt.append(</span><span class="s2">'cc_dynamic'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">opt</span>

    <span class="s0">def </span><span class="s1">get_flags_debug(self):</span>
        <span class="s0">return </span><span class="s1">[</span><span class="s2">'-g'</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">get_flags_opt(self):</span>
        <span class="s1">v = self.get_version()</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">and </span><span class="s1">v &lt;= </span><span class="s2">'3.3.3'</span><span class="s1">:</span>
            <span class="s3"># With this compiler version building Fortran BLAS/LAPACK</span>
            <span class="s3"># with -O3 caused failures in lib.lapack heevr,syevr tests.</span>
            <span class="s1">opt = [</span><span class="s2">'-O2'</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">opt = [</span><span class="s2">'-O3'</span><span class="s1">]</span>
        <span class="s1">opt.append(</span><span class="s2">'-funroll-loops'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">opt</span>

    <span class="s0">def </span><span class="s1">_c_arch_flags(self):</span>
        <span class="s5">&quot;&quot;&quot; Return detected arch flags from CFLAGS &quot;&quot;&quot;</span>
        <span class="s0">import </span><span class="s1">sysconfig</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">cflags = sysconfig.get_config_vars()[</span><span class="s2">'CFLAGS'</span><span class="s1">]</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">return </span><span class="s1">[]</span>
        <span class="s1">arch_re = re.compile(</span><span class="s2">r&quot;-arch\s+(\w+)&quot;</span><span class="s1">)</span>
        <span class="s1">arch_flags = []</span>
        <span class="s0">for </span><span class="s1">arch </span><span class="s0">in </span><span class="s1">arch_re.findall(cflags):</span>
            <span class="s1">arch_flags += [</span><span class="s2">'-arch'</span><span class="s0">, </span><span class="s1">arch]</span>
        <span class="s0">return </span><span class="s1">arch_flags</span>

    <span class="s0">def </span><span class="s1">get_flags_arch(self):</span>
        <span class="s0">return </span><span class="s1">[]</span>

    <span class="s0">def </span><span class="s1">runtime_library_dir_option(self</span><span class="s0">, </span><span class="s1">dir):</span>
        <span class="s0">if </span><span class="s1">sys.platform == </span><span class="s2">'win32' </span><span class="s0">or </span><span class="s1">sys.platform == </span><span class="s2">'cygwin'</span><span class="s1">:</span>
            <span class="s3"># Linux/Solaris/Unix support RPATH, Windows does not</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span>

        <span class="s3"># TODO: could use -Xlinker here, if it's supported</span>
        <span class="s0">assert </span><span class="s2">&quot;,&quot; </span><span class="s0">not in </span><span class="s1">dir</span>

        <span class="s0">if </span><span class="s1">sys.platform == </span><span class="s2">'darwin'</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s2">f'-Wl,-rpath,</span><span class="s0">{</span><span class="s1">dir</span><span class="s0">}</span><span class="s2">'</span>
        <span class="s0">elif </span><span class="s1">sys.platform[:</span><span class="s4">3</span><span class="s1">] == </span><span class="s2">'aix'</span><span class="s1">:</span>
            <span class="s3"># AIX RPATH is called LIBPATH</span>
            <span class="s0">return </span><span class="s2">f'-Wl,-blibpath:</span><span class="s0">{</span><span class="s1">dir</span><span class="s0">}</span><span class="s2">'</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s2">f'-Wl,-rpath=</span><span class="s0">{</span><span class="s1">dir</span><span class="s0">}</span><span class="s2">'</span>


<span class="s0">class </span><span class="s1">Gnu95FCompiler(GnuFCompiler):</span>
    <span class="s1">compiler_type = </span><span class="s2">'gnu95'</span>
    <span class="s1">compiler_aliases = (</span><span class="s2">'gfortran'</span><span class="s0">, </span><span class="s1">)</span>
    <span class="s1">description = </span><span class="s2">'GNU Fortran 95 compiler'</span>

    <span class="s0">def </span><span class="s1">version_match(self</span><span class="s0">, </span><span class="s1">version_string):</span>
        <span class="s1">v = self.gnu_version_match(version_string)</span>
        <span class="s0">if not </span><span class="s1">v </span><span class="s0">or </span><span class="s1">v[</span><span class="s4">0</span><span class="s1">] != </span><span class="s2">'gfortran'</span><span class="s1">:</span>
            <span class="s0">return None</span>
        <span class="s1">v = v[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">LooseVersion(v) &gt;= </span><span class="s2">&quot;4&quot;</span><span class="s1">:</span>
            <span class="s3"># gcc-4 series releases do not support -mno-cygwin option</span>
            <span class="s0">pass</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># use -mno-cygwin flag for gfortran when Python is not</span>
            <span class="s3"># Cygwin-Python</span>
            <span class="s0">if </span><span class="s1">sys.platform == </span><span class="s2">'win32'</span><span class="s1">:</span>
                <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">[</span>
                        <span class="s2">'version_cmd'</span><span class="s0">, </span><span class="s2">'compiler_f77'</span><span class="s0">, </span><span class="s2">'compiler_f90'</span><span class="s0">,</span>
                        <span class="s2">'compiler_fix'</span><span class="s0">, </span><span class="s2">'linker_so'</span><span class="s0">, </span><span class="s2">'linker_exe'</span>
                <span class="s1">]:</span>
                    <span class="s1">self.executables[key].append(</span><span class="s2">'-mno-cygwin'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">v</span>

    <span class="s1">possible_executables = [</span><span class="s2">'gfortran'</span><span class="s0">, </span><span class="s2">'f95'</span><span class="s1">]</span>
    <span class="s1">executables = {</span>
        <span class="s2">'version_cmd'  </span><span class="s1">: [</span><span class="s2">&quot;&lt;F90&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;-dumpversion&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s2">'compiler_f77' </span><span class="s1">: [</span><span class="s0">None, </span><span class="s2">&quot;-Wall&quot;</span><span class="s0">, </span><span class="s2">&quot;-g&quot;</span><span class="s0">, </span><span class="s2">&quot;-ffixed-form&quot;</span><span class="s0">,</span>
                          <span class="s2">&quot;-fno-second-underscore&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s2">'compiler_f90' </span><span class="s1">: [</span><span class="s0">None, </span><span class="s2">&quot;-Wall&quot;</span><span class="s0">, </span><span class="s2">&quot;-g&quot;</span><span class="s0">,</span>
                          <span class="s2">&quot;-fno-second-underscore&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s2">'compiler_fix' </span><span class="s1">: [</span><span class="s0">None, </span><span class="s2">&quot;-Wall&quot;</span><span class="s0">,  </span><span class="s2">&quot;-g&quot;</span><span class="s0">,</span><span class="s2">&quot;-ffixed-form&quot;</span><span class="s0">,</span>
                          <span class="s2">&quot;-fno-second-underscore&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s2">'linker_so'    </span><span class="s1">: [</span><span class="s2">&quot;&lt;F90&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;-Wall&quot;</span><span class="s0">, </span><span class="s2">&quot;-g&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s2">'archiver'     </span><span class="s1">: [</span><span class="s2">&quot;ar&quot;</span><span class="s0">, </span><span class="s2">&quot;-cr&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s2">'ranlib'       </span><span class="s1">: [</span><span class="s2">&quot;ranlib&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s2">'linker_exe'   </span><span class="s1">: [</span><span class="s0">None, </span><span class="s2">&quot;-Wall&quot;</span><span class="s1">]</span>
    <span class="s1">}</span>

    <span class="s1">module_dir_switch = </span><span class="s2">'-J'</span>
    <span class="s1">module_include_switch = </span><span class="s2">'-I'</span>

    <span class="s0">if </span><span class="s1">sys.platform[:</span><span class="s4">3</span><span class="s1">] == </span><span class="s2">'aix'</span><span class="s1">:</span>
        <span class="s1">executables[</span><span class="s2">'linker_so'</span><span class="s1">].append(</span><span class="s2">'-lpthread'</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">platform.architecture()[</span><span class="s4">0</span><span class="s1">][:</span><span class="s4">2</span><span class="s1">] == </span><span class="s2">'64'</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'compiler_f77'</span><span class="s0">, </span><span class="s2">'compiler_f90'</span><span class="s0">,</span><span class="s2">'compiler_fix'</span><span class="s0">,</span><span class="s2">'linker_so'</span><span class="s0">, </span><span class="s2">'linker_exe'</span><span class="s1">]:</span>
                <span class="s1">executables[key].append(</span><span class="s2">'-maix64'</span><span class="s1">)</span>

    <span class="s1">g2c = </span><span class="s2">'gfortran'</span>

    <span class="s0">def </span><span class="s1">_universal_flags(self</span><span class="s0">, </span><span class="s1">cmd):</span>
        <span class="s5">&quot;&quot;&quot;Return a list of -arch flags for every supported architecture.&quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">sys.platform == </span><span class="s2">'darwin'</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">[]</span>
        <span class="s1">arch_flags = []</span>
        <span class="s3"># get arches the C compiler gets.</span>
        <span class="s1">c_archs = self._c_arch_flags()</span>
        <span class="s0">if </span><span class="s2">&quot;i386&quot; </span><span class="s0">in </span><span class="s1">c_archs:</span>
            <span class="s1">c_archs[c_archs.index(</span><span class="s2">&quot;i386&quot;</span><span class="s1">)] = </span><span class="s2">&quot;i686&quot;</span>
        <span class="s3"># check the arches the Fortran compiler supports, and compare with</span>
        <span class="s3"># arch flags from C compiler</span>
        <span class="s0">for </span><span class="s1">arch </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;ppc&quot;</span><span class="s0">, </span><span class="s2">&quot;i686&quot;</span><span class="s0">, </span><span class="s2">&quot;x86_64&quot;</span><span class="s0">, </span><span class="s2">&quot;ppc64&quot;</span><span class="s1">]:</span>
            <span class="s0">if </span><span class="s1">_can_target(cmd</span><span class="s0">, </span><span class="s1">arch) </span><span class="s0">and </span><span class="s1">arch </span><span class="s0">in </span><span class="s1">c_archs:</span>
                <span class="s1">arch_flags.extend([</span><span class="s2">&quot;-arch&quot;</span><span class="s0">, </span><span class="s1">arch])</span>
        <span class="s0">return </span><span class="s1">arch_flags</span>

    <span class="s0">def </span><span class="s1">get_flags(self):</span>
        <span class="s1">flags = GnuFCompiler.get_flags(self)</span>
        <span class="s1">arch_flags = self._universal_flags(self.compiler_f90)</span>
        <span class="s0">if </span><span class="s1">arch_flags:</span>
            <span class="s1">flags[:</span><span class="s4">0</span><span class="s1">] = arch_flags</span>
        <span class="s0">return </span><span class="s1">flags</span>

    <span class="s0">def </span><span class="s1">get_flags_linker_so(self):</span>
        <span class="s1">flags = GnuFCompiler.get_flags_linker_so(self)</span>
        <span class="s1">arch_flags = self._universal_flags(self.linker_so)</span>
        <span class="s0">if </span><span class="s1">arch_flags:</span>
            <span class="s1">flags[:</span><span class="s4">0</span><span class="s1">] = arch_flags</span>
        <span class="s0">return </span><span class="s1">flags</span>

    <span class="s0">def </span><span class="s1">get_library_dirs(self):</span>
        <span class="s1">opt = GnuFCompiler.get_library_dirs(self)</span>
        <span class="s0">if </span><span class="s1">sys.platform == </span><span class="s2">'win32'</span><span class="s1">:</span>
            <span class="s1">c_compiler = self.c_compiler</span>
            <span class="s0">if </span><span class="s1">c_compiler </span><span class="s0">and </span><span class="s1">c_compiler.compiler_type == </span><span class="s2">&quot;msvc&quot;</span><span class="s1">:</span>
                <span class="s1">target = self.get_target()</span>
                <span class="s0">if </span><span class="s1">target:</span>
                    <span class="s1">d = os.path.normpath(self.get_libgcc_dir())</span>
                    <span class="s1">root = os.path.join(d</span><span class="s0">, </span><span class="s1">*((os.pardir</span><span class="s0">, </span><span class="s1">) * </span><span class="s4">4</span><span class="s1">))</span>
                    <span class="s1">path = os.path.join(root</span><span class="s0">, </span><span class="s2">&quot;lib&quot;</span><span class="s1">)</span>
                    <span class="s1">mingwdir = os.path.normpath(path)</span>
                    <span class="s0">if </span><span class="s1">os.path.exists(os.path.join(mingwdir</span><span class="s0">, </span><span class="s2">&quot;libmingwex.a&quot;</span><span class="s1">)):</span>
                        <span class="s1">opt.append(mingwdir)</span>
        <span class="s3"># For Macports / Linux, libgfortran and libgcc are not co-located</span>
        <span class="s1">lib_gfortran_dir = self.get_libgfortran_dir()</span>
        <span class="s0">if </span><span class="s1">lib_gfortran_dir:</span>
            <span class="s1">opt.append(lib_gfortran_dir)</span>
        <span class="s0">return </span><span class="s1">opt</span>

    <span class="s0">def </span><span class="s1">get_libraries(self):</span>
        <span class="s1">opt = GnuFCompiler.get_libraries(self)</span>
        <span class="s0">if </span><span class="s1">sys.platform == </span><span class="s2">'darwin'</span><span class="s1">:</span>
            <span class="s1">opt.remove(</span><span class="s2">'cc_dynamic'</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">sys.platform == </span><span class="s2">'win32'</span><span class="s1">:</span>
            <span class="s1">c_compiler = self.c_compiler</span>
            <span class="s0">if </span><span class="s1">c_compiler </span><span class="s0">and </span><span class="s1">c_compiler.compiler_type == </span><span class="s2">&quot;msvc&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s2">&quot;gcc&quot; </span><span class="s0">in </span><span class="s1">opt:</span>
                    <span class="s1">i = opt.index(</span><span class="s2">&quot;gcc&quot;</span><span class="s1">)</span>
                    <span class="s1">opt.insert(i + </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;mingwex&quot;</span><span class="s1">)</span>
                    <span class="s1">opt.insert(i + </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;mingw32&quot;</span><span class="s1">)</span>
            <span class="s1">c_compiler = self.c_compiler</span>
            <span class="s0">if </span><span class="s1">c_compiler </span><span class="s0">and </span><span class="s1">c_compiler.compiler_type == </span><span class="s2">&quot;msvc&quot;</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">[]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">pass</span>
        <span class="s0">return </span><span class="s1">opt</span>

    <span class="s0">def </span><span class="s1">get_target(self):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">output = subprocess.check_output(self.compiler_f77 + [</span><span class="s2">'-v'</span><span class="s1">])</span>
        <span class="s0">except </span><span class="s1">(OSError</span><span class="s0">, </span><span class="s1">subprocess.CalledProcessError):</span>
            <span class="s0">pass</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">output = filepath_from_subprocess_output(output)</span>
            <span class="s1">m = TARGET_R.search(output)</span>
            <span class="s0">if </span><span class="s1">m:</span>
                <span class="s0">return </span><span class="s1">m.group(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s2">&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">_hash_files(self</span><span class="s0">, </span><span class="s1">filenames):</span>
        <span class="s1">h = hashlib.sha1()</span>
        <span class="s0">for </span><span class="s1">fn </span><span class="s0">in </span><span class="s1">filenames:</span>
            <span class="s0">with </span><span class="s1">open(fn</span><span class="s0">, </span><span class="s2">'rb'</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
                <span class="s0">while True</span><span class="s1">:</span>
                    <span class="s1">block = f.read(</span><span class="s4">131072</span><span class="s1">)</span>
                    <span class="s0">if not </span><span class="s1">block:</span>
                        <span class="s0">break</span>
                    <span class="s1">h.update(block)</span>
        <span class="s1">text = base64.b32encode(h.digest())</span>
        <span class="s1">text = text.decode(</span><span class="s2">'ascii'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">text.rstrip(</span><span class="s2">'='</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_link_wrapper_lib(self</span><span class="s0">, </span><span class="s1">objects</span><span class="s0">, </span><span class="s1">output_dir</span><span class="s0">, </span><span class="s1">extra_dll_dir</span><span class="s0">,</span>
                          <span class="s1">chained_dlls</span><span class="s0">, </span><span class="s1">is_archive):</span>
        <span class="s5">&quot;&quot;&quot;Create a wrapper shared library for the given objects 
 
        Return an MSVC-compatible lib 
        &quot;&quot;&quot;</span>

        <span class="s1">c_compiler = self.c_compiler</span>
        <span class="s0">if </span><span class="s1">c_compiler.compiler_type != </span><span class="s2">&quot;msvc&quot;</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;This method only supports MSVC&quot;</span><span class="s1">)</span>

        <span class="s1">object_hash = self._hash_files(list(objects) + list(chained_dlls))</span>

        <span class="s0">if </span><span class="s1">is_win64():</span>
            <span class="s1">tag = </span><span class="s2">'win_amd64'</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">tag = </span><span class="s2">'win32'</span>

        <span class="s1">basename = </span><span class="s2">'lib' </span><span class="s1">+ os.path.splitext(</span>
            <span class="s1">os.path.basename(objects[</span><span class="s4">0</span><span class="s1">]))[</span><span class="s4">0</span><span class="s1">][:</span><span class="s4">8</span><span class="s1">]</span>
        <span class="s1">root_name = basename + </span><span class="s2">'.' </span><span class="s1">+ object_hash + </span><span class="s2">'.gfortran-' </span><span class="s1">+ tag</span>
        <span class="s1">dll_name = root_name + </span><span class="s2">'.dll'</span>
        <span class="s1">def_name = root_name + </span><span class="s2">'.def'</span>
        <span class="s1">lib_name = root_name + </span><span class="s2">'.lib'</span>
        <span class="s1">dll_path = os.path.join(extra_dll_dir</span><span class="s0">, </span><span class="s1">dll_name)</span>
        <span class="s1">def_path = os.path.join(output_dir</span><span class="s0">, </span><span class="s1">def_name)</span>
        <span class="s1">lib_path = os.path.join(output_dir</span><span class="s0">, </span><span class="s1">lib_name)</span>

        <span class="s0">if </span><span class="s1">os.path.isfile(lib_path):</span>
            <span class="s3"># Nothing to do</span>
            <span class="s0">return </span><span class="s1">lib_path</span><span class="s0">, </span><span class="s1">dll_path</span>

        <span class="s0">if </span><span class="s1">is_archive:</span>
            <span class="s1">objects = ([</span><span class="s2">&quot;-Wl,--whole-archive&quot;</span><span class="s1">] + list(objects) +</span>
                       <span class="s1">[</span><span class="s2">&quot;-Wl,--no-whole-archive&quot;</span><span class="s1">])</span>
        <span class="s1">self.link_shared_object(</span>
            <span class="s1">objects</span><span class="s0">,</span>
            <span class="s1">dll_name</span><span class="s0">,</span>
            <span class="s1">output_dir=extra_dll_dir</span><span class="s0">,</span>
            <span class="s1">extra_postargs=list(chained_dlls) + [</span>
                <span class="s2">'-Wl,--allow-multiple-definition'</span><span class="s0">,</span>
                <span class="s2">'-Wl,--output-def,' </span><span class="s1">+ def_path</span><span class="s0">,</span>
                <span class="s2">'-Wl,--export-all-symbols'</span><span class="s0">,</span>
                <span class="s2">'-Wl,--enable-auto-import'</span><span class="s0">,</span>
                <span class="s2">'-static'</span><span class="s0">,</span>
                <span class="s2">'-mlong-double-64'</span><span class="s0">,</span>
            <span class="s1">])</span>

        <span class="s3"># No PowerPC!</span>
        <span class="s0">if </span><span class="s1">is_win64():</span>
            <span class="s1">specifier = </span><span class="s2">'/MACHINE:X64'</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">specifier = </span><span class="s2">'/MACHINE:X86'</span>

        <span class="s3"># MSVC specific code</span>
        <span class="s1">lib_args = [</span><span class="s2">'/def:' </span><span class="s1">+ def_path</span><span class="s0">, </span><span class="s2">'/OUT:' </span><span class="s1">+ lib_path</span><span class="s0">, </span><span class="s1">specifier]</span>
        <span class="s0">if not </span><span class="s1">c_compiler.initialized:</span>
            <span class="s1">c_compiler.initialize()</span>
        <span class="s1">c_compiler.spawn([c_compiler.lib] + lib_args)</span>

        <span class="s0">return </span><span class="s1">lib_path</span><span class="s0">, </span><span class="s1">dll_path</span>

    <span class="s0">def </span><span class="s1">can_ccompiler_link(self</span><span class="s0">, </span><span class="s1">compiler):</span>
        <span class="s3"># MSVC cannot link objects compiled by GNU fortran</span>
        <span class="s0">return </span><span class="s1">compiler.compiler_type </span><span class="s0">not in </span><span class="s1">(</span><span class="s2">&quot;msvc&quot;</span><span class="s0">, </span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">wrap_unlinkable_objects(self</span><span class="s0">, </span><span class="s1">objects</span><span class="s0">, </span><span class="s1">output_dir</span><span class="s0">, </span><span class="s1">extra_dll_dir):</span>
        <span class="s5">&quot;&quot;&quot; 
        Convert a set of object files that are not compatible with the default 
        linker, to a file that is compatible. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.c_compiler.compiler_type == </span><span class="s2">&quot;msvc&quot;</span><span class="s1">:</span>
            <span class="s3"># Compile a DLL and return the lib for the DLL as</span>
            <span class="s3"># the object. Also keep track of previous DLLs that</span>
            <span class="s3"># we have compiled so that we can link against them.</span>

            <span class="s3"># If there are .a archives, assume they are self-contained</span>
            <span class="s3"># static libraries, and build separate DLLs for each</span>
            <span class="s1">archives = []</span>
            <span class="s1">plain_objects = []</span>
            <span class="s0">for </span><span class="s1">obj </span><span class="s0">in </span><span class="s1">objects:</span>
                <span class="s0">if </span><span class="s1">obj.lower().endswith(</span><span class="s2">'.a'</span><span class="s1">):</span>
                    <span class="s1">archives.append(obj)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">plain_objects.append(obj)</span>

            <span class="s1">chained_libs = []</span>
            <span class="s1">chained_dlls = []</span>
            <span class="s0">for </span><span class="s1">archive </span><span class="s0">in </span><span class="s1">archives[::-</span><span class="s4">1</span><span class="s1">]:</span>
                <span class="s1">lib</span><span class="s0">, </span><span class="s1">dll = self._link_wrapper_lib(</span>
                    <span class="s1">[archive]</span><span class="s0">,</span>
                    <span class="s1">output_dir</span><span class="s0">,</span>
                    <span class="s1">extra_dll_dir</span><span class="s0">,</span>
                    <span class="s1">chained_dlls=chained_dlls</span><span class="s0">,</span>
                    <span class="s1">is_archive=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s1">chained_libs.insert(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">lib)</span>
                <span class="s1">chained_dlls.insert(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">dll)</span>

            <span class="s0">if not </span><span class="s1">plain_objects:</span>
                <span class="s0">return </span><span class="s1">chained_libs</span>

            <span class="s1">lib</span><span class="s0">, </span><span class="s1">dll = self._link_wrapper_lib(</span>
                <span class="s1">plain_objects</span><span class="s0">,</span>
                <span class="s1">output_dir</span><span class="s0">,</span>
                <span class="s1">extra_dll_dir</span><span class="s0">,</span>
                <span class="s1">chained_dlls=chained_dlls</span><span class="s0">,</span>
                <span class="s1">is_archive=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">[lib] + chained_libs</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Unsupported C compiler&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_can_target(cmd</span><span class="s0">, </span><span class="s1">arch):</span>
    <span class="s5">&quot;&quot;&quot;Return true if the architecture supports the -arch flag&quot;&quot;&quot;</span>
    <span class="s1">newcmd = cmd[:]</span>
    <span class="s1">fid</span><span class="s0">, </span><span class="s1">filename = tempfile.mkstemp(suffix=</span><span class="s2">&quot;.f&quot;</span><span class="s1">)</span>
    <span class="s1">os.close(fid)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">d = os.path.dirname(filename)</span>
        <span class="s1">output = os.path.splitext(filename)[</span><span class="s4">0</span><span class="s1">] + </span><span class="s2">&quot;.o&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">newcmd.extend([</span><span class="s2">&quot;-arch&quot;</span><span class="s0">, </span><span class="s1">arch</span><span class="s0">, </span><span class="s2">&quot;-c&quot;</span><span class="s0">, </span><span class="s1">filename])</span>
            <span class="s1">p = Popen(newcmd</span><span class="s0">, </span><span class="s1">stderr=STDOUT</span><span class="s0">, </span><span class="s1">stdout=PIPE</span><span class="s0">, </span><span class="s1">cwd=d)</span>
            <span class="s1">p.communicate()</span>
            <span class="s0">return </span><span class="s1">p.returncode == </span><span class="s4">0</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">os.path.exists(output):</span>
                <span class="s1">os.remove(output)</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s1">os.remove(filename)</span>


<span class="s0">if </span><span class="s1">__name__ == </span><span class="s2">'__main__'</span><span class="s1">:</span>
    <span class="s0">from </span><span class="s1">distutils </span><span class="s0">import </span><span class="s1">log</span>
    <span class="s0">from </span><span class="s1">numpy.distutils </span><span class="s0">import </span><span class="s1">customized_fcompiler</span>
    <span class="s1">log.set_verbosity(</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s1">print(customized_fcompiler(</span><span class="s2">'gnu'</span><span class="s1">).get_version())</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">print(customized_fcompiler(</span><span class="s2">'g95'</span><span class="s1">).get_version())</span>
    <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s1">print(e)</span>
</pre>
</body>
</html>