<html>
<head>
<title>renderer.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
renderer.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Renderer Module 
 
This module defines the PlotlyRenderer class and a single function, 
fig_to_plotly, which is intended to be the main way that user's will interact 
with the matplotlylib package. 
 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">absolute_import</span>

<span class="s2">import </span><span class="s1">six</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">plotly.graph_objs </span><span class="s2">as </span><span class="s1">go</span>
<span class="s2">from </span><span class="s1">plotly.matplotlylib.mplexporter </span><span class="s2">import </span><span class="s1">Renderer</span>
<span class="s2">from </span><span class="s1">plotly.matplotlylib </span><span class="s2">import </span><span class="s1">mpltools</span>


<span class="s3"># Warning format</span>
<span class="s2">def </span><span class="s1">warning_on_one_line(msg</span><span class="s2">, </span><span class="s1">category</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">lineno</span><span class="s2">, </span><span class="s1">file=</span><span class="s2">None, </span><span class="s1">line=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s4">&quot;%s:%s: %s:</span><span class="s2">\n\n</span><span class="s4">%s</span><span class="s2">\n\n</span><span class="s4">&quot; </span><span class="s1">% (filename</span><span class="s2">, </span><span class="s1">lineno</span><span class="s2">, </span><span class="s1">category.__name__</span><span class="s2">, </span><span class="s1">msg)</span>


<span class="s1">warnings.formatwarning = warning_on_one_line</span>


<span class="s2">class </span><span class="s1">PlotlyRenderer(Renderer):</span>
    <span class="s0">&quot;&quot;&quot;A renderer class inheriting from base for rendering mpl plots in plotly. 
 
    A renderer class to be used with an exporter for rendering matplotlib 
    plots in Plotly. This module defines the PlotlyRenderer class which handles 
    the creation of the JSON structures that get sent to plotly. 
 
    All class attributes available are defined in __init__(). 
 
    Basic Usage: 
 
    # (mpl code) # 
    fig = gcf() 
    renderer = PlotlyRenderer(fig) 
    exporter = Exporter(renderer) 
    exporter.run(fig)  # ... et voila 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s0">&quot;&quot;&quot;Initialize PlotlyRenderer obj. 
 
        PlotlyRenderer obj is called on by an Exporter object to draw 
        matplotlib objects like figures, axes, text, etc. 
 
        All class attributes are listed here in the __init__ method. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.plotly_fig = go.Figure()</span>
        <span class="s1">self.mpl_fig = </span><span class="s2">None</span>
        <span class="s1">self.current_mpl_ax = </span><span class="s2">None</span>
        <span class="s1">self.bar_containers = </span><span class="s2">None</span>
        <span class="s1">self.current_bars = []</span>
        <span class="s1">self.axis_ct = </span><span class="s5">0</span>
        <span class="s1">self.x_is_mpl_date = </span><span class="s2">False</span>
        <span class="s1">self.mpl_x_bounds = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self.mpl_y_bounds = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self.msg = </span><span class="s4">&quot;Initialized PlotlyRenderer</span><span class="s2">\n</span><span class="s4">&quot;</span>

    <span class="s2">def </span><span class="s1">open_figure(self</span><span class="s2">, </span><span class="s1">fig</span><span class="s2">, </span><span class="s1">props):</span>
        <span class="s0">&quot;&quot;&quot;Creates a new figure by beginning to fill out layout dict. 
 
        The 'autosize' key is set to false so that the figure will mirror 
        sizes set by mpl. The 'hovermode' key controls what shows up when you 
        mouse around a figure in plotly, it's set to show the 'closest' point. 
 
        Positional agurments: 
        fig -- a matplotlib.figure.Figure object. 
        props.keys(): [ 
            'figwidth', 
            'figheight', 
            'dpi' 
            ] 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msg += </span><span class="s4">&quot;Opening figure</span><span class="s2">\n</span><span class="s4">&quot;</span>
        <span class="s1">self.mpl_fig = fig</span>
        <span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">] = go.Layout(</span>
            <span class="s1">width=int(props[</span><span class="s4">&quot;figwidth&quot;</span><span class="s1">] * props[</span><span class="s4">&quot;dpi&quot;</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">height=int(props[</span><span class="s4">&quot;figheight&quot;</span><span class="s1">] * props[</span><span class="s4">&quot;dpi&quot;</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">autosize=</span><span class="s2">False,</span>
            <span class="s1">hovermode=</span><span class="s4">&quot;closest&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.mpl_x_bounds</span><span class="s2">, </span><span class="s1">self.mpl_y_bounds = mpltools.get_axes_bounds(fig)</span>
        <span class="s1">margin = go.layout.Margin(</span>
            <span class="s1">l=int(self.mpl_x_bounds[</span><span class="s5">0</span><span class="s1">] * self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;width&quot;</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">r=int((</span><span class="s5">1 </span><span class="s1">- self.mpl_x_bounds[</span><span class="s5">1</span><span class="s1">]) * self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;width&quot;</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">t=int((</span><span class="s5">1 </span><span class="s1">- self.mpl_y_bounds[</span><span class="s5">1</span><span class="s1">]) * self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;height&quot;</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">b=int(self.mpl_y_bounds[</span><span class="s5">0</span><span class="s1">] * self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;height&quot;</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">pad=</span><span class="s5">0</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;margin&quot;</span><span class="s1">] = margin</span>

    <span class="s2">def </span><span class="s1">close_figure(self</span><span class="s2">, </span><span class="s1">fig):</span>
        <span class="s0">&quot;&quot;&quot;Closes figure by cleaning up data and layout dictionaries. 
 
        The PlotlyRenderer's job is to create an appropriate set of data and 
        layout dictionaries. When the figure is closed, some cleanup and 
        repair is necessary. This method removes inappropriate dictionary 
        entries, freeing up Plotly to use defaults and best judgements to 
        complete the entries. This method is called by an Exporter object. 
 
        Positional arguments: 
        fig -- a matplotlib.figure.Figure object. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;showlegend&quot;</span><span class="s1">] = </span><span class="s2">False</span>
        <span class="s1">self.msg += </span><span class="s4">&quot;Closing figure</span><span class="s2">\n</span><span class="s4">&quot;</span>

    <span class="s2">def </span><span class="s1">open_axes(self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">props):</span>
        <span class="s0">&quot;&quot;&quot;Setup a new axes object (subplot in plotly). 
 
        Plotly stores information about subplots in different 'xaxis' and 
        'yaxis' objects which are numbered. These are just dictionaries 
        included in the layout dictionary. This function takes information 
        from the Exporter, fills in appropriate dictionary entries, 
        and updates the layout dictionary. PlotlyRenderer keeps track of the 
        number of plots by incrementing the axis_ct attribute. 
 
        Setting the proper plot domain in plotly is a bit tricky. Refer to 
        the documentation for mpltools.convert_x_domain and 
        mpltools.convert_y_domain. 
 
        Positional arguments: 
        ax -- an mpl axes object. This will become a subplot in plotly. 
        props.keys() -- [ 
            'axesbg',           (background color for axes obj) 
            'axesbgalpha',      (alpha, or opacity for background) 
            'bounds',           ((x0, y0, width, height) for axes) 
            'dynamic',          (zoom/pan-able?) 
            'axes',             (list: [xaxis, yaxis]) 
            'xscale',           (log, linear, or date) 
            'yscale', 
            'xlim',             (range limits for x) 
            'ylim', 
            'xdomain'           (xdomain=xlim, unless it's a date) 
            'ydomain' 
            ] 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msg += </span><span class="s4">&quot;  Opening axes</span><span class="s2">\n</span><span class="s4">&quot;</span>
        <span class="s1">self.current_mpl_ax = ax</span>
        <span class="s1">self.bar_containers = [</span>
            <span class="s1">c</span>
            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">ax.containers  </span><span class="s3"># empty is OK</span>
            <span class="s2">if </span><span class="s1">c.__class__.__name__ == </span><span class="s4">&quot;BarContainer&quot;</span>
        <span class="s1">]</span>
        <span class="s1">self.current_bars = []</span>
        <span class="s1">self.axis_ct += </span><span class="s5">1</span>
        <span class="s3"># set defaults in axes</span>
        <span class="s1">xaxis = go.layout.XAxis(</span>
            <span class="s1">anchor=</span><span class="s4">&quot;y{0}&quot;</span><span class="s1">.format(self.axis_ct)</span><span class="s2">, </span><span class="s1">zeroline=</span><span class="s2">False, </span><span class="s1">ticks=</span><span class="s4">&quot;inside&quot;</span>
        <span class="s1">)</span>
        <span class="s1">yaxis = go.layout.YAxis(</span>
            <span class="s1">anchor=</span><span class="s4">&quot;x{0}&quot;</span><span class="s1">.format(self.axis_ct)</span><span class="s2">, </span><span class="s1">zeroline=</span><span class="s2">False, </span><span class="s1">ticks=</span><span class="s4">&quot;inside&quot;</span>
        <span class="s1">)</span>
        <span class="s3"># update defaults with things set in mpl</span>
        <span class="s1">mpl_xaxis</span><span class="s2">, </span><span class="s1">mpl_yaxis = mpltools.prep_xy_axis(</span>
            <span class="s1">ax=ax</span><span class="s2">, </span><span class="s1">props=props</span><span class="s2">, </span><span class="s1">x_bounds=self.mpl_x_bounds</span><span class="s2">, </span><span class="s1">y_bounds=self.mpl_y_bounds</span>
        <span class="s1">)</span>
        <span class="s1">xaxis.update(mpl_xaxis)</span>
        <span class="s1">yaxis.update(mpl_yaxis)</span>
        <span class="s1">bottom_spine = mpltools.get_spine_visible(ax</span><span class="s2">, </span><span class="s4">&quot;bottom&quot;</span><span class="s1">)</span>
        <span class="s1">top_spine = mpltools.get_spine_visible(ax</span><span class="s2">, </span><span class="s4">&quot;top&quot;</span><span class="s1">)</span>
        <span class="s1">left_spine = mpltools.get_spine_visible(ax</span><span class="s2">, </span><span class="s4">&quot;left&quot;</span><span class="s1">)</span>
        <span class="s1">right_spine = mpltools.get_spine_visible(ax</span><span class="s2">, </span><span class="s4">&quot;right&quot;</span><span class="s1">)</span>
        <span class="s1">xaxis[</span><span class="s4">&quot;mirror&quot;</span><span class="s1">] = mpltools.get_axis_mirror(bottom_spine</span><span class="s2">, </span><span class="s1">top_spine)</span>
        <span class="s1">yaxis[</span><span class="s4">&quot;mirror&quot;</span><span class="s1">] = mpltools.get_axis_mirror(left_spine</span><span class="s2">, </span><span class="s1">right_spine)</span>
        <span class="s1">xaxis[</span><span class="s4">&quot;showline&quot;</span><span class="s1">] = bottom_spine</span>
        <span class="s1">yaxis[</span><span class="s4">&quot;showline&quot;</span><span class="s1">] = top_spine</span>

        <span class="s3"># put axes in our figure</span>
        <span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;xaxis{0}&quot;</span><span class="s1">.format(self.axis_ct)] = xaxis</span>
        <span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;yaxis{0}&quot;</span><span class="s1">.format(self.axis_ct)] = yaxis</span>

        <span class="s3"># let all subsequent dates be handled properly if required</span>

        <span class="s2">if </span><span class="s4">&quot;type&quot; </span><span class="s2">in </span><span class="s1">dir(xaxis) </span><span class="s2">and </span><span class="s1">xaxis[</span><span class="s4">&quot;type&quot;</span><span class="s1">] == </span><span class="s4">&quot;date&quot;</span><span class="s1">:</span>
            <span class="s1">self.x_is_mpl_date = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">close_axes(self</span><span class="s2">, </span><span class="s1">ax):</span>
        <span class="s0">&quot;&quot;&quot;Close the axes object and clean up. 
 
        Bars from bar charts are given to PlotlyRenderer one-by-one, 
        thus they need to be taken care of at the close of each axes object. 
        The self.current_bars variable should be empty unless a bar 
        chart has been created. 
 
        Positional arguments: 
        ax -- an mpl axes object, not required at this time. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.draw_bars(self.current_bars)</span>
        <span class="s1">self.msg += </span><span class="s4">&quot;  Closing axes</span><span class="s2">\n</span><span class="s4">&quot;</span>
        <span class="s1">self.x_is_mpl_date = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">draw_bars(self</span><span class="s2">, </span><span class="s1">bars):</span>

        <span class="s3"># sort bars according to bar containers</span>
        <span class="s1">mpl_traces = []</span>
        <span class="s2">for </span><span class="s1">container </span><span class="s2">in </span><span class="s1">self.bar_containers:</span>
            <span class="s1">mpl_traces.append(</span>
                <span class="s1">[</span>
                    <span class="s1">bar_props</span>
                    <span class="s2">for </span><span class="s1">bar_props </span><span class="s2">in </span><span class="s1">self.current_bars</span>
                    <span class="s2">if </span><span class="s1">bar_props[</span><span class="s4">&quot;mplobj&quot;</span><span class="s1">] </span><span class="s2">in </span><span class="s1">container</span>
                <span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s2">for </span><span class="s1">trace </span><span class="s2">in </span><span class="s1">mpl_traces:</span>
            <span class="s1">self.draw_bar(trace)</span>

    <span class="s2">def </span><span class="s1">draw_bar(self</span><span class="s2">, </span><span class="s1">coll):</span>
        <span class="s0">&quot;&quot;&quot;Draw a collection of similar patches as a bar chart. 
 
        After bars are sorted, an appropriate data dictionary must be created 
        to tell plotly about this data. Just like draw_line or draw_markers, 
        draw_bar translates patch/path information into something plotly 
        understands. 
 
        Positional arguments: 
        patch_coll -- a collection of patches to be drawn as a bar chart. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">tol = </span><span class="s5">1e-10</span>
        <span class="s1">trace = [mpltools.make_bar(**bar_props) </span><span class="s2">for </span><span class="s1">bar_props </span><span class="s2">in </span><span class="s1">coll]</span>
        <span class="s1">widths = [bar_props[</span><span class="s4">&quot;x1&quot;</span><span class="s1">] - bar_props[</span><span class="s4">&quot;x0&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">bar_props </span><span class="s2">in </span><span class="s1">trace]</span>
        <span class="s1">heights = [bar_props[</span><span class="s4">&quot;y1&quot;</span><span class="s1">] - bar_props[</span><span class="s4">&quot;y0&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">bar_props </span><span class="s2">in </span><span class="s1">trace]</span>
        <span class="s1">vertical = abs(sum(widths[</span><span class="s5">0</span><span class="s1">] - widths[iii] </span><span class="s2">for </span><span class="s1">iii </span><span class="s2">in </span><span class="s1">range(len(widths)))) &lt; tol</span>
        <span class="s1">horizontal = (</span>
            <span class="s1">abs(sum(heights[</span><span class="s5">0</span><span class="s1">] - heights[iii] </span><span class="s2">for </span><span class="s1">iii </span><span class="s2">in </span><span class="s1">range(len(heights)))) &lt; tol</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">vertical </span><span class="s2">and </span><span class="s1">horizontal:</span>
            <span class="s3"># Check for monotonic x. Can't both be true!</span>
            <span class="s1">x_zeros = [bar_props[</span><span class="s4">&quot;x0&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">bar_props </span><span class="s2">in </span><span class="s1">trace]</span>
            <span class="s2">if </span><span class="s1">all(</span>
                <span class="s1">(x_zeros[iii + </span><span class="s5">1</span><span class="s1">] &gt; x_zeros[iii] </span><span class="s2">for </span><span class="s1">iii </span><span class="s2">in </span><span class="s1">range(len(x_zeros[:-</span><span class="s5">1</span><span class="s1">])))</span>
            <span class="s1">):</span>
                <span class="s1">orientation = </span><span class="s4">&quot;v&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">orientation = </span><span class="s4">&quot;h&quot;</span>
        <span class="s2">elif </span><span class="s1">vertical:</span>
            <span class="s1">orientation = </span><span class="s4">&quot;v&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">orientation = </span><span class="s4">&quot;h&quot;</span>
        <span class="s2">if </span><span class="s1">orientation == </span><span class="s4">&quot;v&quot;</span><span class="s1">:</span>
            <span class="s1">self.msg += </span><span class="s4">&quot;    Attempting to draw a vertical bar chart</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s1">old_heights = [bar_props[</span><span class="s4">&quot;y1&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">bar_props </span><span class="s2">in </span><span class="s1">trace]</span>
            <span class="s2">for </span><span class="s1">bar </span><span class="s2">in </span><span class="s1">trace:</span>
                <span class="s1">bar[</span><span class="s4">&quot;y0&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">bar[</span><span class="s4">&quot;y1&quot;</span><span class="s1">] = </span><span class="s5">0</span><span class="s2">, </span><span class="s1">bar[</span><span class="s4">&quot;y1&quot;</span><span class="s1">] - bar[</span><span class="s4">&quot;y0&quot;</span><span class="s1">]</span>
            <span class="s1">new_heights = [bar_props[</span><span class="s4">&quot;y1&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">bar_props </span><span class="s2">in </span><span class="s1">trace]</span>
            <span class="s3"># check if we're stacked or not...</span>
            <span class="s2">for </span><span class="s1">old</span><span class="s2">, </span><span class="s1">new </span><span class="s2">in </span><span class="s1">zip(old_heights</span><span class="s2">, </span><span class="s1">new_heights):</span>
                <span class="s2">if </span><span class="s1">abs(old - new) &gt; tol:</span>
                    <span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;barmode&quot;</span><span class="s1">] = </span><span class="s4">&quot;stack&quot;</span>
                    <span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;hovermode&quot;</span><span class="s1">] = </span><span class="s4">&quot;x&quot;</span>
            <span class="s1">x = [bar[</span><span class="s4">&quot;x0&quot;</span><span class="s1">] + (bar[</span><span class="s4">&quot;x1&quot;</span><span class="s1">] - bar[</span><span class="s4">&quot;x0&quot;</span><span class="s1">]) / </span><span class="s5">2 </span><span class="s2">for </span><span class="s1">bar </span><span class="s2">in </span><span class="s1">trace]</span>
            <span class="s1">y = [bar[</span><span class="s4">&quot;y1&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">bar </span><span class="s2">in </span><span class="s1">trace]</span>
            <span class="s1">bar_gap = mpltools.get_bar_gap(</span>
                <span class="s1">[bar[</span><span class="s4">&quot;x0&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">bar </span><span class="s2">in </span><span class="s1">trace]</span><span class="s2">, </span><span class="s1">[bar[</span><span class="s4">&quot;x1&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">bar </span><span class="s2">in </span><span class="s1">trace]</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.x_is_mpl_date:</span>
                <span class="s1">x = [bar[</span><span class="s4">&quot;x0&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">bar </span><span class="s2">in </span><span class="s1">trace]</span>
                <span class="s1">formatter = (</span>
                    <span class="s1">self.current_mpl_ax.get_xaxis()</span>
                    <span class="s1">.get_major_formatter()</span>
                    <span class="s1">.__class__.__name__</span>
                <span class="s1">)</span>
                <span class="s1">x = mpltools.mpl_dates_to_datestrings(x</span><span class="s2">, </span><span class="s1">formatter)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.msg += </span><span class="s4">&quot;    Attempting to draw a horizontal bar chart</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s1">old_rights = [bar_props[</span><span class="s4">&quot;x1&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">bar_props </span><span class="s2">in </span><span class="s1">trace]</span>
            <span class="s2">for </span><span class="s1">bar </span><span class="s2">in </span><span class="s1">trace:</span>
                <span class="s1">bar[</span><span class="s4">&quot;x0&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">bar[</span><span class="s4">&quot;x1&quot;</span><span class="s1">] = </span><span class="s5">0</span><span class="s2">, </span><span class="s1">bar[</span><span class="s4">&quot;x1&quot;</span><span class="s1">] - bar[</span><span class="s4">&quot;x0&quot;</span><span class="s1">]</span>
            <span class="s1">new_rights = [bar_props[</span><span class="s4">&quot;x1&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">bar_props </span><span class="s2">in </span><span class="s1">trace]</span>
            <span class="s3"># check if we're stacked or not...</span>
            <span class="s2">for </span><span class="s1">old</span><span class="s2">, </span><span class="s1">new </span><span class="s2">in </span><span class="s1">zip(old_rights</span><span class="s2">, </span><span class="s1">new_rights):</span>
                <span class="s2">if </span><span class="s1">abs(old - new) &gt; tol:</span>
                    <span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;barmode&quot;</span><span class="s1">] = </span><span class="s4">&quot;stack&quot;</span>
                    <span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;hovermode&quot;</span><span class="s1">] = </span><span class="s4">&quot;y&quot;</span>
            <span class="s1">x = [bar[</span><span class="s4">&quot;x1&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">bar </span><span class="s2">in </span><span class="s1">trace]</span>
            <span class="s1">y = [bar[</span><span class="s4">&quot;y0&quot;</span><span class="s1">] + (bar[</span><span class="s4">&quot;y1&quot;</span><span class="s1">] - bar[</span><span class="s4">&quot;y0&quot;</span><span class="s1">]) / </span><span class="s5">2 </span><span class="s2">for </span><span class="s1">bar </span><span class="s2">in </span><span class="s1">trace]</span>
            <span class="s1">bar_gap = mpltools.get_bar_gap(</span>
                <span class="s1">[bar[</span><span class="s4">&quot;y0&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">bar </span><span class="s2">in </span><span class="s1">trace]</span><span class="s2">, </span><span class="s1">[bar[</span><span class="s4">&quot;y1&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">bar </span><span class="s2">in </span><span class="s1">trace]</span>
            <span class="s1">)</span>
        <span class="s1">bar = go.Bar(</span>
            <span class="s1">orientation=orientation</span><span class="s2">,</span>
            <span class="s1">x=x</span><span class="s2">,</span>
            <span class="s1">y=y</span><span class="s2">,</span>
            <span class="s1">xaxis=</span><span class="s4">&quot;x{0}&quot;</span><span class="s1">.format(self.axis_ct)</span><span class="s2">,</span>
            <span class="s1">yaxis=</span><span class="s4">&quot;y{0}&quot;</span><span class="s1">.format(self.axis_ct)</span><span class="s2">,</span>
            <span class="s1">opacity=trace[</span><span class="s5">0</span><span class="s1">][</span><span class="s4">&quot;alpha&quot;</span><span class="s1">]</span><span class="s2">,  </span><span class="s3"># TODO: get all alphas if array?</span>
            <span class="s1">marker=go.bar.Marker(</span>
                <span class="s1">color=trace[</span><span class="s5">0</span><span class="s1">][</span><span class="s4">&quot;facecolor&quot;</span><span class="s1">]</span><span class="s2">,  </span><span class="s3"># TODO: get all</span>
                <span class="s1">line=dict(width=trace[</span><span class="s5">0</span><span class="s1">][</span><span class="s4">&quot;edgewidth&quot;</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)  </span><span class="s3"># TODO ditto</span>
        <span class="s2">if </span><span class="s1">len(bar[</span><span class="s4">&quot;x&quot;</span><span class="s1">]) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">self.msg += </span><span class="s4">&quot;    Heck yeah, I drew that bar chart</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s1">self.plotly_fig.add_trace(bar)</span><span class="s2">,</span>
            <span class="s2">if </span><span class="s1">bar_gap </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;bargap&quot;</span><span class="s1">] = bar_gap</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.msg += </span><span class="s4">&quot;    Bar chart not drawn</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s1">warnings.warn(</span>
                <span class="s4">&quot;found box chart data with length &lt;= 1, &quot;</span>
                <span class="s4">&quot;assuming data redundancy, not plotting.&quot;</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">draw_legend_shapes(self</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">**props):</span>
        <span class="s0">&quot;&quot;&quot;Create a shape that matches lines or markers in legends. 
 
        Main issue is that path for circles do not render, so we have to use 'circle' 
        instead of 'path'. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">single_mode </span><span class="s2">in </span><span class="s1">mode.split(</span><span class="s4">&quot;+&quot;</span><span class="s1">):</span>
            <span class="s1">x = props[</span><span class="s4">&quot;data&quot;</span><span class="s1">][</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">y = props[</span><span class="s4">&quot;data&quot;</span><span class="s1">][</span><span class="s5">0</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">single_mode == </span><span class="s4">&quot;markers&quot; </span><span class="s2">and </span><span class="s1">props.get(</span><span class="s4">&quot;markerstyle&quot;</span><span class="s1">):</span>
                <span class="s1">size = shape.pop(</span><span class="s4">&quot;size&quot;</span><span class="s2">, </span><span class="s5">6</span><span class="s1">)</span>
                <span class="s1">symbol = shape.pop(</span><span class="s4">&quot;symbol&quot;</span><span class="s1">)</span>
                <span class="s3"># aligning to &quot;center&quot;</span>
                <span class="s1">x0 = </span><span class="s5">0</span>
                <span class="s1">y0 = </span><span class="s5">0</span>
                <span class="s1">x1 = size</span>
                <span class="s1">y1 = size</span>
                <span class="s1">markerpath = props[</span><span class="s4">&quot;markerstyle&quot;</span><span class="s1">].get(</span><span class="s4">&quot;markerpath&quot;</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">markerpath </span><span class="s2">is None and </span><span class="s1">symbol != </span><span class="s4">&quot;circle&quot;</span><span class="s1">:</span>
                    <span class="s1">self.msg += (</span>
                        <span class="s4">&quot;not sure how to handle this marker without a valid path</span><span class="s2">\n</span><span class="s4">&quot;</span>
                    <span class="s1">)</span>
                    <span class="s2">return</span>
                <span class="s3"># marker path to SVG path conversion</span>
                <span class="s1">path = </span><span class="s4">&quot; &quot;</span><span class="s1">.join(</span>
                    <span class="s1">[</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">a</span><span class="s2">} {</span><span class="s1">t[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">}</span><span class="s4">,</span><span class="s2">{</span><span class="s1">t[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">}</span><span class="s4">&quot; </span><span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">t </span><span class="s2">in </span><span class="s1">zip(markerpath[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">markerpath[</span><span class="s5">0</span><span class="s1">])]</span>
                <span class="s1">)</span>

                <span class="s2">if </span><span class="s1">symbol == </span><span class="s4">&quot;circle&quot;</span><span class="s1">:</span>
                    <span class="s3"># symbols like . and o in matplotlib, use circle</span>
                    <span class="s3"># plotly also maps many other markers to circle, such as 1,8 and p</span>
                    <span class="s1">path = </span><span class="s2">None</span>
                    <span class="s1">shape_type = </span><span class="s4">&quot;circle&quot;</span>
                    <span class="s1">x0 = -size / </span><span class="s5">2</span>
                    <span class="s1">y0 = size / </span><span class="s5">2</span>
                    <span class="s1">x1 = size / </span><span class="s5">2</span>
                    <span class="s1">y1 = size + size / </span><span class="s5">2</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s3"># triangles, star etc</span>
                    <span class="s1">shape_type = </span><span class="s4">&quot;path&quot;</span>
                <span class="s1">legend_shape = go.layout.Shape(</span>
                    <span class="s1">type=shape_type</span><span class="s2">,</span>
                    <span class="s1">xref=</span><span class="s4">&quot;paper&quot;</span><span class="s2">,</span>
                    <span class="s1">yref=</span><span class="s4">&quot;paper&quot;</span><span class="s2">,</span>
                    <span class="s1">x0=x0</span><span class="s2">,</span>
                    <span class="s1">y0=y0</span><span class="s2">,</span>
                    <span class="s1">x1=x1</span><span class="s2">,</span>
                    <span class="s1">y1=y1</span><span class="s2">,</span>
                    <span class="s1">xsizemode=</span><span class="s4">&quot;pixel&quot;</span><span class="s2">,</span>
                    <span class="s1">ysizemode=</span><span class="s4">&quot;pixel&quot;</span><span class="s2">,</span>
                    <span class="s1">xanchor=x</span><span class="s2">,</span>
                    <span class="s1">yanchor=y</span><span class="s2">,</span>
                    <span class="s1">path=path</span><span class="s2">,</span>
                    <span class="s1">**shape</span><span class="s2">,</span>
                <span class="s1">)</span>

            <span class="s2">elif </span><span class="s1">single_mode == </span><span class="s4">&quot;lines&quot;</span><span class="s1">:</span>
                <span class="s1">mode = </span><span class="s4">&quot;line&quot;</span>
                <span class="s1">x1 = props[</span><span class="s4">&quot;data&quot;</span><span class="s1">][</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s1">y1 = props[</span><span class="s4">&quot;data&quot;</span><span class="s1">][</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]</span>

                <span class="s1">legend_shape = go.layout.Shape(</span>
                    <span class="s1">type=mode</span><span class="s2">,</span>
                    <span class="s1">xref=</span><span class="s4">&quot;paper&quot;</span><span class="s2">,</span>
                    <span class="s1">yref=</span><span class="s4">&quot;paper&quot;</span><span class="s2">,</span>
                    <span class="s1">x0=x</span><span class="s2">,</span>
                    <span class="s1">y0=y + </span><span class="s5">0.02</span><span class="s2">,</span>
                    <span class="s1">x1=x1</span><span class="s2">,</span>
                    <span class="s1">y1=y1 + </span><span class="s5">0.02</span><span class="s2">,</span>
                    <span class="s1">**shape</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.msg += </span><span class="s4">&quot;not sure how to handle this element</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s2">return</span>
            <span class="s1">self.plotly_fig.add_shape(legend_shape)</span>
            <span class="s1">self.msg += </span><span class="s4">&quot;    Heck yeah, I drew that shape</span><span class="s2">\n</span><span class="s4">&quot;</span>

    <span class="s2">def </span><span class="s1">draw_marked_line(self</span><span class="s2">, </span><span class="s1">**props):</span>
        <span class="s0">&quot;&quot;&quot;Create a data dict for a line obj. 
 
        This will draw 'lines', 'markers', or 'lines+markers'. For legend elements, 
        this will use layout.shapes, so they can be positioned with paper refs. 
 
        props.keys() -- [ 
        'coordinates',  ('data', 'axes', 'figure', or 'display') 
        'data',         (a list of xy pairs) 
        'mplobj',       (the matplotlib.lines.Line2D obj being rendered) 
        'label',        (the name of the Line2D obj being rendered) 
        'linestyle',    (linestyle dict, can be None, see below) 
        'markerstyle',  (markerstyle dict, can be None, see below) 
        ] 
 
        props['linestyle'].keys() -- [ 
        'alpha',        (opacity of Line2D obj) 
        'color',        (color of the line if it exists, not the marker) 
        'linewidth', 
        'dasharray',    (code for linestyle, see DASH_MAP in mpltools.py) 
        'zorder',       (viewing precedence when stacked with other objects) 
        ] 
 
        props['markerstyle'].keys() -- [ 
        'alpha',        (opacity of Line2D obj) 
        'marker',       (the mpl marker symbol, see SYMBOL_MAP in mpltools.py) 
        'facecolor',    (color of the marker face) 
        'edgecolor',    (color of the marker edge) 
        'edgewidth',    (width of marker edge) 
        'markerpath',   (an SVG path for drawing the specified marker) 
        'zorder',       (viewing precedence when stacked with other objects) 
        ] 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msg += </span><span class="s4">&quot;    Attempting to draw a line &quot;</span>
        <span class="s1">line</span><span class="s2">, </span><span class="s1">marker</span><span class="s2">, </span><span class="s1">shape = {}</span><span class="s2">, </span><span class="s1">{}</span><span class="s2">, </span><span class="s1">{}</span>
        <span class="s2">if </span><span class="s1">props[</span><span class="s4">&quot;linestyle&quot;</span><span class="s1">] </span><span class="s2">and </span><span class="s1">props[</span><span class="s4">&quot;markerstyle&quot;</span><span class="s1">]:</span>
            <span class="s1">self.msg += </span><span class="s4">&quot;... with both lines+markers</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s1">mode = </span><span class="s4">&quot;lines+markers&quot;</span>
        <span class="s2">elif </span><span class="s1">props[</span><span class="s4">&quot;linestyle&quot;</span><span class="s1">]:</span>
            <span class="s1">self.msg += </span><span class="s4">&quot;... with just lines</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s1">mode = </span><span class="s4">&quot;lines&quot;</span>
        <span class="s2">elif </span><span class="s1">props[</span><span class="s4">&quot;markerstyle&quot;</span><span class="s1">]:</span>
            <span class="s1">self.msg += </span><span class="s4">&quot;... with just markers</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s1">mode = </span><span class="s4">&quot;markers&quot;</span>
        <span class="s2">if </span><span class="s1">props[</span><span class="s4">&quot;linestyle&quot;</span><span class="s1">]:</span>
            <span class="s1">color = mpltools.merge_color_and_opacity(</span>
                <span class="s1">props[</span><span class="s4">&quot;linestyle&quot;</span><span class="s1">][</span><span class="s4">&quot;color&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">props[</span><span class="s4">&quot;linestyle&quot;</span><span class="s1">][</span><span class="s4">&quot;alpha&quot;</span><span class="s1">]</span>
            <span class="s1">)</span>

            <span class="s2">if </span><span class="s1">props[</span><span class="s4">&quot;coordinates&quot;</span><span class="s1">] == </span><span class="s4">&quot;data&quot;</span><span class="s1">:</span>
                <span class="s1">line = go.scatter.Line(</span>
                    <span class="s1">color=color</span><span class="s2">,</span>
                    <span class="s1">width=props[</span><span class="s4">&quot;linestyle&quot;</span><span class="s1">][</span><span class="s4">&quot;linewidth&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">dash=mpltools.convert_dash(props[</span><span class="s4">&quot;linestyle&quot;</span><span class="s1">][</span><span class="s4">&quot;dasharray&quot;</span><span class="s1">])</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">shape = dict(</span>
                    <span class="s1">line=dict(</span>
                        <span class="s1">color=color</span><span class="s2">,</span>
                        <span class="s1">width=props[</span><span class="s4">&quot;linestyle&quot;</span><span class="s1">][</span><span class="s4">&quot;linewidth&quot;</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">dash=mpltools.convert_dash(props[</span><span class="s4">&quot;linestyle&quot;</span><span class="s1">][</span><span class="s4">&quot;dasharray&quot;</span><span class="s1">])</span><span class="s2">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">props[</span><span class="s4">&quot;markerstyle&quot;</span><span class="s1">]:</span>
            <span class="s2">if </span><span class="s1">props[</span><span class="s4">&quot;coordinates&quot;</span><span class="s1">] == </span><span class="s4">&quot;data&quot;</span><span class="s1">:</span>
                <span class="s1">marker = go.scatter.Marker(</span>
                    <span class="s1">opacity=props[</span><span class="s4">&quot;markerstyle&quot;</span><span class="s1">][</span><span class="s4">&quot;alpha&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">color=props[</span><span class="s4">&quot;markerstyle&quot;</span><span class="s1">][</span><span class="s4">&quot;facecolor&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">symbol=mpltools.convert_symbol(props[</span><span class="s4">&quot;markerstyle&quot;</span><span class="s1">][</span><span class="s4">&quot;marker&quot;</span><span class="s1">])</span><span class="s2">,</span>
                    <span class="s1">size=props[</span><span class="s4">&quot;markerstyle&quot;</span><span class="s1">][</span><span class="s4">&quot;markersize&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">line=dict(</span>
                        <span class="s1">color=props[</span><span class="s4">&quot;markerstyle&quot;</span><span class="s1">][</span><span class="s4">&quot;edgecolor&quot;</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">width=props[</span><span class="s4">&quot;markerstyle&quot;</span><span class="s1">][</span><span class="s4">&quot;edgewidth&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">shape = dict(</span>
                    <span class="s1">opacity=props[</span><span class="s4">&quot;markerstyle&quot;</span><span class="s1">][</span><span class="s4">&quot;alpha&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">fillcolor=props[</span><span class="s4">&quot;markerstyle&quot;</span><span class="s1">][</span><span class="s4">&quot;facecolor&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">symbol=mpltools.convert_symbol(props[</span><span class="s4">&quot;markerstyle&quot;</span><span class="s1">][</span><span class="s4">&quot;marker&quot;</span><span class="s1">])</span><span class="s2">,</span>
                    <span class="s1">size=props[</span><span class="s4">&quot;markerstyle&quot;</span><span class="s1">][</span><span class="s4">&quot;markersize&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">line=dict(</span>
                        <span class="s1">color=props[</span><span class="s4">&quot;markerstyle&quot;</span><span class="s1">][</span><span class="s4">&quot;edgecolor&quot;</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">width=props[</span><span class="s4">&quot;markerstyle&quot;</span><span class="s1">][</span><span class="s4">&quot;edgewidth&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">props[</span><span class="s4">&quot;coordinates&quot;</span><span class="s1">] == </span><span class="s4">&quot;data&quot;</span><span class="s1">:</span>
            <span class="s1">marked_line = go.Scatter(</span>
                <span class="s1">mode=mode</span><span class="s2">,</span>
                <span class="s1">name=(</span>
                    <span class="s1">str(props[</span><span class="s4">&quot;label&quot;</span><span class="s1">])</span>
                    <span class="s2">if </span><span class="s1">isinstance(props[</span><span class="s4">&quot;label&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">six.string_types)</span>
                    <span class="s2">else </span><span class="s1">props[</span><span class="s4">&quot;label&quot;</span><span class="s1">]</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">x=[xy_pair[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">xy_pair </span><span class="s2">in </span><span class="s1">props[</span><span class="s4">&quot;data&quot;</span><span class="s1">]]</span><span class="s2">,</span>
                <span class="s1">y=[xy_pair[</span><span class="s5">1</span><span class="s1">] </span><span class="s2">for </span><span class="s1">xy_pair </span><span class="s2">in </span><span class="s1">props[</span><span class="s4">&quot;data&quot;</span><span class="s1">]]</span><span class="s2">,</span>
                <span class="s1">xaxis=</span><span class="s4">&quot;x{0}&quot;</span><span class="s1">.format(self.axis_ct)</span><span class="s2">,</span>
                <span class="s1">yaxis=</span><span class="s4">&quot;y{0}&quot;</span><span class="s1">.format(self.axis_ct)</span><span class="s2">,</span>
                <span class="s1">line=line</span><span class="s2">,</span>
                <span class="s1">marker=marker</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.x_is_mpl_date:</span>
                <span class="s1">formatter = (</span>
                    <span class="s1">self.current_mpl_ax.get_xaxis()</span>
                    <span class="s1">.get_major_formatter()</span>
                    <span class="s1">.__class__.__name__</span>
                <span class="s1">)</span>
                <span class="s1">marked_line[</span><span class="s4">&quot;x&quot;</span><span class="s1">] = mpltools.mpl_dates_to_datestrings(</span>
                    <span class="s1">marked_line[</span><span class="s4">&quot;x&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">formatter</span>
                <span class="s1">)</span>
            <span class="s1">self.plotly_fig.add_trace(marked_line)</span><span class="s2">,</span>
            <span class="s1">self.msg += </span><span class="s4">&quot;    Heck yeah, I drew that line</span><span class="s2">\n</span><span class="s4">&quot;</span>
        <span class="s2">elif </span><span class="s1">props[</span><span class="s4">&quot;coordinates&quot;</span><span class="s1">] == </span><span class="s4">&quot;axes&quot;</span><span class="s1">:</span>
            <span class="s3"># dealing with legend graphical elements</span>
            <span class="s1">self.draw_legend_shapes(mode=mode</span><span class="s2">, </span><span class="s1">shape=shape</span><span class="s2">, </span><span class="s1">**props)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.msg += </span><span class="s4">&quot;    Line didn't have 'data' coordinates, &quot; &quot;not drawing</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s1">warnings.warn(</span>
                <span class="s4">&quot;Bummer! Plotly can currently only draw Line2D &quot;</span>
                <span class="s4">&quot;objects from matplotlib that are in 'data' &quot;</span>
                <span class="s4">&quot;coordinates!&quot;</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">draw_image(self</span><span class="s2">, </span><span class="s1">**props):</span>
        <span class="s0">&quot;&quot;&quot;Draw image. 
 
        Not implemented yet! 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msg += </span><span class="s4">&quot;    Attempting to draw image</span><span class="s2">\n</span><span class="s4">&quot;</span>
        <span class="s1">self.msg += </span><span class="s4">&quot;    Not drawing image</span><span class="s2">\n</span><span class="s4">&quot;</span>
        <span class="s1">warnings.warn(</span>
            <span class="s4">&quot;Aw. Snap! You're gonna have to hold off on &quot;</span>
            <span class="s4">&quot;the selfies for now. Plotly can't import &quot;</span>
            <span class="s4">&quot;images from matplotlib yet!&quot;</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">draw_path_collection(self</span><span class="s2">, </span><span class="s1">**props):</span>
        <span class="s0">&quot;&quot;&quot;Add a path collection to data list as a scatter plot. 
 
        Current implementation defaults such collections as scatter plots. 
        Matplotlib supports collections that have many of the same parameters 
        in common like color, size, path, etc. However, they needn't all be 
        the same. Plotly does not currently support such functionality and 
        therefore, the style for the first object is taken and used to define 
        the remaining paths in the collection. 
 
        props.keys() -- [ 
        'paths',                (structure: [vertices, path_code]) 
        'path_coordinates',     ('data', 'axes', 'figure', or 'display') 
        'path_transforms',      (mpl transform, including Affine2D matrix) 
        'offsets',              (offset from axes, helpful if in 'data') 
        'offset_coordinates',   ('data', 'axes', 'figure', or 'display') 
        'offset_order', 
        'styles',               (style dict, see below) 
        'mplobj'                (the collection obj being drawn) 
        ] 
 
        props['styles'].keys() -- [ 
        'linewidth',            (one or more linewidths) 
        'facecolor',            (one or more facecolors for path) 
        'edgecolor',            (one or more edgecolors for path) 
        'alpha',                (one or more opacites for path) 
        'zorder',               (precedence when stacked) 
        ] 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msg += </span><span class="s4">&quot;    Attempting to draw a path collection</span><span class="s2">\n</span><span class="s4">&quot;</span>
        <span class="s2">if </span><span class="s1">props[</span><span class="s4">&quot;offset_coordinates&quot;</span><span class="s1">] == </span><span class="s4">&quot;data&quot;</span><span class="s1">:</span>
            <span class="s1">markerstyle = mpltools.get_markerstyle_from_collection(props)</span>
            <span class="s1">scatter_props = {</span>
                <span class="s4">&quot;coordinates&quot;</span><span class="s1">: </span><span class="s4">&quot;data&quot;</span><span class="s2">,</span>
                <span class="s4">&quot;data&quot;</span><span class="s1">: props[</span><span class="s4">&quot;offsets&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s4">&quot;label&quot;</span><span class="s1">: </span><span class="s2">None,</span>
                <span class="s4">&quot;markerstyle&quot;</span><span class="s1">: markerstyle</span><span class="s2">,</span>
                <span class="s4">&quot;linestyle&quot;</span><span class="s1">: </span><span class="s2">None,</span>
            <span class="s1">}</span>
            <span class="s1">self.msg += </span><span class="s4">&quot;    Drawing path collection as markers</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s1">self.draw_marked_line(**scatter_props)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.msg += </span><span class="s4">&quot;    Path collection not linked to 'data', &quot; &quot;not drawing</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s1">warnings.warn(</span>
                <span class="s4">&quot;Dang! That path collection is out of this &quot;</span>
                <span class="s4">&quot;world. I totally don't know what to do with &quot;</span>
                <span class="s4">&quot;it yet! Plotly can only import path &quot;</span>
                <span class="s4">&quot;collections linked to 'data' coordinates&quot;</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">draw_path(self</span><span class="s2">, </span><span class="s1">**props):</span>
        <span class="s0">&quot;&quot;&quot;Draw path, currently only attempts to draw bar charts. 
 
        This function attempts to sort a given path into a collection of 
        horizontal or vertical bar charts. Most of the actual code takes 
        place in functions from mpltools.py. 
 
        props.keys() -- [ 
        'data',         (a list of verticies for the path) 
        'coordinates',  ('data', 'axes', 'figure', or 'display') 
        'pathcodes',    (code for the path, structure: ['M', 'L', 'Z', etc.]) 
        'style',        (style dict, see below) 
        'mplobj'        (the mpl path object) 
        ] 
 
        props['style'].keys() -- [ 
        'alpha',        (opacity of path obj) 
        'edgecolor', 
        'facecolor', 
        'edgewidth', 
        'dasharray',    (style for path's enclosing line) 
        'zorder'        (precedence of obj when stacked) 
        ] 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msg += </span><span class="s4">&quot;    Attempting to draw a path</span><span class="s2">\n</span><span class="s4">&quot;</span>
        <span class="s1">is_bar = mpltools.is_bar(self.current_mpl_ax.containers</span><span class="s2">, </span><span class="s1">**props)</span>
        <span class="s2">if </span><span class="s1">is_bar:</span>
            <span class="s1">self.current_bars += [props]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.msg += </span><span class="s4">&quot;    This path isn't a bar, not drawing</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s1">warnings.warn(</span>
                <span class="s4">&quot;I found a path object that I don't think is part &quot;</span>
                <span class="s4">&quot;of a bar chart. Ignoring.&quot;</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">draw_text(self</span><span class="s2">, </span><span class="s1">**props):</span>
        <span class="s0">&quot;&quot;&quot;Create an annotation dict for a text obj. 
 
        Currently, plotly uses either 'page' or 'data' to reference 
        annotation locations. These refer to 'display' and 'data', 
        respectively for the 'coordinates' key used in the Exporter. 
        Appropriate measures are taken to transform text locations to 
        reference one of these two options. 
 
        props.keys() -- [ 
        'text',         (actual content string, not the text obj) 
        'position',     (an x, y pair, not an mpl Bbox) 
        'coordinates',  ('data', 'axes', 'figure', 'display') 
        'text_type',    ('title', 'xlabel', or 'ylabel') 
        'style',        (style dict, see below) 
        'mplobj'        (actual mpl text object) 
        ] 
 
        props['style'].keys() -- [ 
        'alpha',        (opacity of text) 
        'fontsize',     (size in points of text) 
        'color',        (hex color) 
        'halign',       (horizontal alignment, 'left', 'center', or 'right') 
        'valign',       (vertical alignment, 'baseline', 'center', or 'top') 
        'rotation', 
        'zorder',       (precedence of text when stacked with other objs) 
        ] 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msg += </span><span class="s4">&quot;    Attempting to draw an mpl text object</span><span class="s2">\n</span><span class="s4">&quot;</span>
        <span class="s2">if not </span><span class="s1">mpltools.check_corners(props[</span><span class="s4">&quot;mplobj&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.mpl_fig):</span>
            <span class="s1">warnings.warn(</span>
                <span class="s4">&quot;Looks like the annotation(s) you are trying </span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;to draw lies/lay outside the given figure size.</span><span class="s2">\n\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;Therefore, the resulting Plotly figure may not be </span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;large enough to view the full text. To adjust </span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;the size of the figure, use the 'width' and </span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;'height' keys in the Layout object. Alternatively,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;use the Margin object to adjust the figure's margins.&quot;</span>
            <span class="s1">)</span>
        <span class="s1">align = props[</span><span class="s4">&quot;mplobj&quot;</span><span class="s1">]._multialignment</span>
        <span class="s2">if not </span><span class="s1">align:</span>
            <span class="s1">align = props[</span><span class="s4">&quot;style&quot;</span><span class="s1">][</span><span class="s4">&quot;halign&quot;</span><span class="s1">]  </span><span class="s3"># mpl default</span>
        <span class="s2">if </span><span class="s4">&quot;annotations&quot; </span><span class="s2">not in </span><span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">]:</span>
            <span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;annotations&quot;</span><span class="s1">] = []</span>
        <span class="s2">if </span><span class="s1">props[</span><span class="s4">&quot;text_type&quot;</span><span class="s1">] == </span><span class="s4">&quot;xlabel&quot;</span><span class="s1">:</span>
            <span class="s1">self.msg += </span><span class="s4">&quot;      Text object is an xlabel</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s1">self.draw_xlabel(**props)</span>
        <span class="s2">elif </span><span class="s1">props[</span><span class="s4">&quot;text_type&quot;</span><span class="s1">] == </span><span class="s4">&quot;ylabel&quot;</span><span class="s1">:</span>
            <span class="s1">self.msg += </span><span class="s4">&quot;      Text object is a ylabel</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s1">self.draw_ylabel(**props)</span>
        <span class="s2">elif </span><span class="s1">props[</span><span class="s4">&quot;text_type&quot;</span><span class="s1">] == </span><span class="s4">&quot;title&quot;</span><span class="s1">:</span>
            <span class="s1">self.msg += </span><span class="s4">&quot;      Text object is a title</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s1">self.draw_title(**props)</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s3"># just a regular text annotation...</span>
            <span class="s1">self.msg += </span><span class="s4">&quot;      Text object is a normal annotation</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s2">if </span><span class="s1">props[</span><span class="s4">&quot;coordinates&quot;</span><span class="s1">] != </span><span class="s4">&quot;data&quot;</span><span class="s1">:</span>
                <span class="s1">self.msg += (</span>
                    <span class="s4">&quot;        Text object isn't linked to 'data' &quot; &quot;coordinates</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s1">)</span>
                <span class="s1">x_px</span><span class="s2">, </span><span class="s1">y_px = (</span>
                    <span class="s1">props[</span><span class="s4">&quot;mplobj&quot;</span><span class="s1">].get_transform().transform(props[</span><span class="s4">&quot;position&quot;</span><span class="s1">])</span>
                <span class="s1">)</span>
                <span class="s1">x</span><span class="s2">, </span><span class="s1">y = mpltools.display_to_paper(x_px</span><span class="s2">, </span><span class="s1">y_px</span><span class="s2">, </span><span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">])</span>
                <span class="s1">xref = </span><span class="s4">&quot;paper&quot;</span>
                <span class="s1">yref = </span><span class="s4">&quot;paper&quot;</span>
                <span class="s1">xanchor = props[</span><span class="s4">&quot;style&quot;</span><span class="s1">][</span><span class="s4">&quot;halign&quot;</span><span class="s1">]  </span><span class="s3"># no difference here!</span>
                <span class="s1">yanchor = mpltools.convert_va(props[</span><span class="s4">&quot;style&quot;</span><span class="s1">][</span><span class="s4">&quot;valign&quot;</span><span class="s1">])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.msg += </span><span class="s4">&quot;        Text object is linked to 'data' &quot; &quot;coordinates</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s1">x</span><span class="s2">, </span><span class="s1">y = props[</span><span class="s4">&quot;position&quot;</span><span class="s1">]</span>
                <span class="s1">axis_ct = self.axis_ct</span>
                <span class="s1">xaxis = self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;xaxis{0}&quot;</span><span class="s1">.format(axis_ct)]</span>
                <span class="s1">yaxis = self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;yaxis{0}&quot;</span><span class="s1">.format(axis_ct)]</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">xaxis[</span><span class="s4">&quot;range&quot;</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] &lt; x &lt; xaxis[</span><span class="s4">&quot;range&quot;</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]</span>
                    <span class="s2">and </span><span class="s1">yaxis[</span><span class="s4">&quot;range&quot;</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] &lt; y &lt; yaxis[</span><span class="s4">&quot;range&quot;</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">):</span>
                    <span class="s1">xref = </span><span class="s4">&quot;x{0}&quot;</span><span class="s1">.format(self.axis_ct)</span>
                    <span class="s1">yref = </span><span class="s4">&quot;y{0}&quot;</span><span class="s1">.format(self.axis_ct)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self.msg += (</span>
                        <span class="s4">&quot;            Text object is outside &quot;</span>
                        <span class="s4">&quot;plotting area, making 'paper' reference.</span><span class="s2">\n</span><span class="s4">&quot;</span>
                    <span class="s1">)</span>
                    <span class="s1">x_px</span><span class="s2">, </span><span class="s1">y_px = (</span>
                        <span class="s1">props[</span><span class="s4">&quot;mplobj&quot;</span><span class="s1">].get_transform().transform(props[</span><span class="s4">&quot;position&quot;</span><span class="s1">])</span>
                    <span class="s1">)</span>
                    <span class="s1">x</span><span class="s2">, </span><span class="s1">y = mpltools.display_to_paper(</span>
                        <span class="s1">x_px</span><span class="s2">, </span><span class="s1">y_px</span><span class="s2">, </span><span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">]</span>
                    <span class="s1">)</span>
                    <span class="s1">xref = </span><span class="s4">&quot;paper&quot;</span>
                    <span class="s1">yref = </span><span class="s4">&quot;paper&quot;</span>
                <span class="s1">xanchor = props[</span><span class="s4">&quot;style&quot;</span><span class="s1">][</span><span class="s4">&quot;halign&quot;</span><span class="s1">]  </span><span class="s3"># no difference here!</span>
                <span class="s1">yanchor = mpltools.convert_va(props[</span><span class="s4">&quot;style&quot;</span><span class="s1">][</span><span class="s4">&quot;valign&quot;</span><span class="s1">])</span>
            <span class="s1">annotation = go.layout.Annotation(</span>
                <span class="s1">text=(</span>
                    <span class="s1">str(props[</span><span class="s4">&quot;text&quot;</span><span class="s1">])</span>
                    <span class="s2">if </span><span class="s1">isinstance(props[</span><span class="s4">&quot;text&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">six.string_types)</span>
                    <span class="s2">else </span><span class="s1">props[</span><span class="s4">&quot;text&quot;</span><span class="s1">]</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">opacity=props[</span><span class="s4">&quot;style&quot;</span><span class="s1">][</span><span class="s4">&quot;alpha&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">x=x</span><span class="s2">,</span>
                <span class="s1">y=y</span><span class="s2">,</span>
                <span class="s1">xref=xref</span><span class="s2">,</span>
                <span class="s1">yref=yref</span><span class="s2">,</span>
                <span class="s1">align=align</span><span class="s2">,</span>
                <span class="s1">xanchor=xanchor</span><span class="s2">,</span>
                <span class="s1">yanchor=yanchor</span><span class="s2">,</span>
                <span class="s1">showarrow=</span><span class="s2">False,  </span><span class="s3"># change this later?</span>
                <span class="s1">font=go.layout.annotation.Font(</span>
                    <span class="s1">color=props[</span><span class="s4">&quot;style&quot;</span><span class="s1">][</span><span class="s4">&quot;color&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">size=props[</span><span class="s4">&quot;style&quot;</span><span class="s1">][</span><span class="s4">&quot;fontsize&quot;</span><span class="s1">]</span>
                <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;annotations&quot;</span><span class="s1">] += (annotation</span><span class="s2">,</span><span class="s1">)</span>
            <span class="s1">self.msg += </span><span class="s4">&quot;    Heck, yeah I drew that annotation</span><span class="s2">\n</span><span class="s4">&quot;</span>

    <span class="s2">def </span><span class="s1">draw_title(self</span><span class="s2">, </span><span class="s1">**props):</span>
        <span class="s0">&quot;&quot;&quot;Add a title to the current subplot in layout dictionary. 
 
        If there exists more than a single plot in the figure, titles revert 
        to 'page'-referenced annotations. 
 
        props.keys() -- [ 
        'text',         (actual content string, not the text obj) 
        'position',     (an x, y pair, not an mpl Bbox) 
        'coordinates',  ('data', 'axes', 'figure', 'display') 
        'text_type',    ('title', 'xlabel', or 'ylabel') 
        'style',        (style dict, see below) 
        'mplobj'        (actual mpl text object) 
        ] 
 
        props['style'].keys() -- [ 
        'alpha',        (opacity of text) 
        'fontsize',     (size in points of text) 
        'color',        (hex color) 
        'halign',       (horizontal alignment, 'left', 'center', or 'right') 
        'valign',       (vertical alignment, 'baseline', 'center', or 'top') 
        'rotation', 
        'zorder',       (precedence of text when stacked with other objs) 
        ] 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msg += </span><span class="s4">&quot;        Attempting to draw a title</span><span class="s2">\n</span><span class="s4">&quot;</span>
        <span class="s2">if </span><span class="s1">len(self.mpl_fig.axes) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">self.msg += (</span>
                <span class="s4">&quot;          More than one subplot, adding title as &quot; &quot;annotation</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s1">)</span>
            <span class="s1">x_px</span><span class="s2">, </span><span class="s1">y_px = props[</span><span class="s4">&quot;mplobj&quot;</span><span class="s1">].get_transform().transform(props[</span><span class="s4">&quot;position&quot;</span><span class="s1">])</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y = mpltools.display_to_paper(x_px</span><span class="s2">, </span><span class="s1">y_px</span><span class="s2">, </span><span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">])</span>
            <span class="s1">annotation = go.layout.Annotation(</span>
                <span class="s1">text=props[</span><span class="s4">&quot;text&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">font=go.layout.annotation.Font(</span>
                    <span class="s1">color=props[</span><span class="s4">&quot;style&quot;</span><span class="s1">][</span><span class="s4">&quot;color&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">size=props[</span><span class="s4">&quot;style&quot;</span><span class="s1">][</span><span class="s4">&quot;fontsize&quot;</span><span class="s1">]</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">xref=</span><span class="s4">&quot;paper&quot;</span><span class="s2">,</span>
                <span class="s1">yref=</span><span class="s4">&quot;paper&quot;</span><span class="s2">,</span>
                <span class="s1">x=x</span><span class="s2">,</span>
                <span class="s1">y=y</span><span class="s2">,</span>
                <span class="s1">xanchor=</span><span class="s4">&quot;center&quot;</span><span class="s2">,</span>
                <span class="s1">yanchor=</span><span class="s4">&quot;bottom&quot;</span><span class="s2">,</span>
                <span class="s1">showarrow=</span><span class="s2">False,  </span><span class="s3"># no arrow for a title!</span>
            <span class="s1">)</span>
            <span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;annotations&quot;</span><span class="s1">] += (annotation</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.msg += (</span>
                <span class="s4">&quot;          Only one subplot found, adding as a &quot; &quot;plotly title</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s1">)</span>
            <span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;title&quot;</span><span class="s1">] = props[</span><span class="s4">&quot;text&quot;</span><span class="s1">]</span>
            <span class="s1">titlefont = dict(</span>
                <span class="s1">size=props[</span><span class="s4">&quot;style&quot;</span><span class="s1">][</span><span class="s4">&quot;fontsize&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">color=props[</span><span class="s4">&quot;style&quot;</span><span class="s1">][</span><span class="s4">&quot;color&quot;</span><span class="s1">]</span>
            <span class="s1">)</span>
            <span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][</span><span class="s4">&quot;titlefont&quot;</span><span class="s1">] = titlefont</span>

    <span class="s2">def </span><span class="s1">draw_xlabel(self</span><span class="s2">, </span><span class="s1">**props):</span>
        <span class="s0">&quot;&quot;&quot;Add an xaxis label to the current subplot in layout dictionary. 
 
        props.keys() -- [ 
        'text',         (actual content string, not the text obj) 
        'position',     (an x, y pair, not an mpl Bbox) 
        'coordinates',  ('data', 'axes', 'figure', 'display') 
        'text_type',    ('title', 'xlabel', or 'ylabel') 
        'style',        (style dict, see below) 
        'mplobj'        (actual mpl text object) 
        ] 
 
        props['style'].keys() -- [ 
        'alpha',        (opacity of text) 
        'fontsize',     (size in points of text) 
        'color',        (hex color) 
        'halign',       (horizontal alignment, 'left', 'center', or 'right') 
        'valign',       (vertical alignment, 'baseline', 'center', or 'top') 
        'rotation', 
        'zorder',       (precedence of text when stacked with other objs) 
        ] 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msg += </span><span class="s4">&quot;        Adding xlabel</span><span class="s2">\n</span><span class="s4">&quot;</span>
        <span class="s1">axis_key = </span><span class="s4">&quot;xaxis{0}&quot;</span><span class="s1">.format(self.axis_ct)</span>
        <span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][axis_key][</span><span class="s4">&quot;title&quot;</span><span class="s1">] = str(props[</span><span class="s4">&quot;text&quot;</span><span class="s1">])</span>
        <span class="s1">titlefont = dict(size=props[</span><span class="s4">&quot;style&quot;</span><span class="s1">][</span><span class="s4">&quot;fontsize&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">color=props[</span><span class="s4">&quot;style&quot;</span><span class="s1">][</span><span class="s4">&quot;color&quot;</span><span class="s1">])</span>
        <span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][axis_key][</span><span class="s4">&quot;titlefont&quot;</span><span class="s1">] = titlefont</span>

    <span class="s2">def </span><span class="s1">draw_ylabel(self</span><span class="s2">, </span><span class="s1">**props):</span>
        <span class="s0">&quot;&quot;&quot;Add a yaxis label to the current subplot in layout dictionary. 
 
        props.keys() -- [ 
        'text',         (actual content string, not the text obj) 
        'position',     (an x, y pair, not an mpl Bbox) 
        'coordinates',  ('data', 'axes', 'figure', 'display') 
        'text_type',    ('title', 'xlabel', or 'ylabel') 
        'style',        (style dict, see below) 
        'mplobj'        (actual mpl text object) 
        ] 
 
        props['style'].keys() -- [ 
        'alpha',        (opacity of text) 
        'fontsize',     (size in points of text) 
        'color',        (hex color) 
        'halign',       (horizontal alignment, 'left', 'center', or 'right') 
        'valign',       (vertical alignment, 'baseline', 'center', or 'top') 
        'rotation', 
        'zorder',       (precedence of text when stacked with other objs) 
        ] 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msg += </span><span class="s4">&quot;        Adding ylabel</span><span class="s2">\n</span><span class="s4">&quot;</span>
        <span class="s1">axis_key = </span><span class="s4">&quot;yaxis{0}&quot;</span><span class="s1">.format(self.axis_ct)</span>
        <span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][axis_key][</span><span class="s4">&quot;title&quot;</span><span class="s1">] = props[</span><span class="s4">&quot;text&quot;</span><span class="s1">]</span>
        <span class="s1">titlefont = dict(size=props[</span><span class="s4">&quot;style&quot;</span><span class="s1">][</span><span class="s4">&quot;fontsize&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">color=props[</span><span class="s4">&quot;style&quot;</span><span class="s1">][</span><span class="s4">&quot;color&quot;</span><span class="s1">])</span>
        <span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][axis_key][</span><span class="s4">&quot;titlefont&quot;</span><span class="s1">] = titlefont</span>

    <span class="s2">def </span><span class="s1">resize(self):</span>
        <span class="s0">&quot;&quot;&quot;Revert figure layout to allow plotly to resize. 
 
        By default, PlotlyRenderer tries its hardest to precisely mimic an 
        mpl figure. However, plotly is pretty good with aesthetics. By 
        running PlotlyRenderer.resize(), layout parameters are deleted. This 
        lets plotly choose them instead of mpl. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msg += </span><span class="s4">&quot;Resizing figure, deleting keys from layout</span><span class="s2">\n</span><span class="s4">&quot;</span>
        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;width&quot;</span><span class="s2">, </span><span class="s4">&quot;height&quot;</span><span class="s2">, </span><span class="s4">&quot;autosize&quot;</span><span class="s2">, </span><span class="s4">&quot;margin&quot;</span><span class="s1">]:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">del </span><span class="s1">self.plotly_fig[</span><span class="s4">&quot;layout&quot;</span><span class="s1">][key]</span>
            <span class="s2">except </span><span class="s1">(KeyError</span><span class="s2">, </span><span class="s1">AttributeError):</span>
                <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">strip_style(self):</span>
        <span class="s1">self.msg += </span><span class="s4">&quot;Stripping mpl style is no longer supported</span><span class="s2">\n</span><span class="s4">&quot;</span>
</pre>
</body>
</html>