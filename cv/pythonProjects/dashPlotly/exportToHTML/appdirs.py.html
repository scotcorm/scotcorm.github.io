<html>
<head>
<title>appdirs.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6897bb;}
.s4 { color: #cc7832;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
appdirs.py</font>
</center></td></tr></table>
<pre><span class="s0">#!/usr/bin/env python</span>
<span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s0"># Copyright (c) 2005-2010 ActiveState Software Inc.</span>
<span class="s0"># Copyright (c) 2013 Eddy Petri»ôor</span>

<span class="s2">&quot;&quot;&quot;Utilities for determining application-specific dirs. 
 
See &lt;http://github.com/ActiveState/appdirs&gt; for details and usage. 
&quot;&quot;&quot;</span>
<span class="s0"># Dev Notes:</span>
<span class="s0"># - MSDN on where to store app data files:</span>
<span class="s0">#   http://support.microsoft.com/default.aspx?scid=kb;en-us;310294#XSLTH3194121123120121120120</span>
<span class="s0"># - Mac OS X: http://developer.apple.com/documentation/MacOSX/Conceptual/BPFileSystem/index.html</span>
<span class="s0"># - XDG spec for Un*x: http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html</span>

<span class="s1">__version_info__ = (</span><span class="s3">1</span><span class="s4">, </span><span class="s3">4</span><span class="s4">, </span><span class="s3">3</span><span class="s1">)</span>
<span class="s1">__version__ = </span><span class="s5">'.'</span><span class="s1">.join(map(str</span><span class="s4">, </span><span class="s1">__version_info__))</span>


<span class="s4">import </span><span class="s1">sys</span>
<span class="s4">import </span><span class="s1">os</span>

<span class="s1">PY3 = sys.version_info[</span><span class="s3">0</span><span class="s1">] == </span><span class="s3">3</span>

<span class="s4">if </span><span class="s1">PY3:</span>
    <span class="s1">unicode = str</span>

<span class="s4">if </span><span class="s1">sys.platform.startswith(</span><span class="s5">'java'</span><span class="s1">):</span>
    <span class="s4">import </span><span class="s1">platform</span>
    <span class="s1">os_name = platform.java_ver()[</span><span class="s3">3</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s4">if </span><span class="s1">os_name.startswith(</span><span class="s5">'Windows'</span><span class="s1">): </span><span class="s0"># &quot;Windows XP&quot;, &quot;Windows 7&quot;, etc.</span>
        <span class="s1">system = </span><span class="s5">'win32'</span>
    <span class="s4">elif </span><span class="s1">os_name.startswith(</span><span class="s5">'Mac'</span><span class="s1">): </span><span class="s0"># &quot;Mac OS X&quot;, etc.</span>
        <span class="s1">system = </span><span class="s5">'darwin'</span>
    <span class="s4">else</span><span class="s1">: </span><span class="s0"># &quot;Linux&quot;, &quot;SunOS&quot;, &quot;FreeBSD&quot;, etc.</span>
        <span class="s0"># Setting this to &quot;linux2&quot; is not ideal, but only Windows or Mac</span>
        <span class="s0"># are actually checked for and the rest of the module expects</span>
        <span class="s0"># *sys.platform* style strings.</span>
        <span class="s1">system = </span><span class="s5">'linux2'</span>
<span class="s4">else</span><span class="s1">:</span>
    <span class="s1">system = sys.platform</span>



<span class="s4">def </span><span class="s1">user_data_dir(appname=</span><span class="s4">None, </span><span class="s1">appauthor=</span><span class="s4">None, </span><span class="s1">version=</span><span class="s4">None, </span><span class="s1">roaming=</span><span class="s4">False</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Return full path to the user-specific data dir for this application. 
 
        &quot;appname&quot; is the name of application. 
            If None, just the system directory is returned. 
        &quot;appauthor&quot; (only used on Windows) is the name of the 
            appauthor or distributing body for this application. Typically 
            it is the owning company name. This falls back to appname. You may 
            pass False to disable it. 
        &quot;version&quot; is an optional version path element to append to the 
            path. You might want to use this if you want multiple versions 
            of your app to be able to run independently. If used, this 
            would typically be &quot;&lt;major&gt;.&lt;minor&gt;&quot;. 
            Only applied when appname is present. 
        &quot;roaming&quot; (boolean, default False) can be set True to use the Windows 
            roaming appdata directory. That means that for users on a Windows 
            network setup for roaming profiles, this user data will be 
            sync'd on login. See 
            &lt;http://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx&gt; 
            for a discussion of issues. 
 
    Typical user data directories are: 
        Mac OS X:               ~/Library/Application Support/&lt;AppName&gt; 
        Unix:                   ~/.local/share/&lt;AppName&gt;    # or in $XDG_DATA_HOME, if defined 
        Win XP (not roaming):   C:\Documents and Settings\&lt;username&gt;\Application Data\&lt;AppAuthor&gt;\&lt;AppName&gt; 
        Win XP (roaming):       C:\Documents and Settings\&lt;username&gt;\Local Settings\Application Data\&lt;AppAuthor&gt;\&lt;AppName&gt; 
        Win 7  (not roaming):   C:\Users\&lt;username&gt;\AppData\Local\&lt;AppAuthor&gt;\&lt;AppName&gt; 
        Win 7  (roaming):       C:\Users\&lt;username&gt;\AppData\Roaming\&lt;AppAuthor&gt;\&lt;AppName&gt; 
 
    For Unix, we follow the XDG spec and support $XDG_DATA_HOME. 
    That means, by default &quot;~/.local/share/&lt;AppName&gt;&quot;. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">system == </span><span class="s5">&quot;win32&quot;</span><span class="s1">:</span>
        <span class="s4">if </span><span class="s1">appauthor </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">appauthor = appname</span>
        <span class="s1">const = roaming </span><span class="s4">and </span><span class="s5">&quot;CSIDL_APPDATA&quot; </span><span class="s4">or </span><span class="s5">&quot;CSIDL_LOCAL_APPDATA&quot;</span>
        <span class="s1">path = os.path.normpath(_get_win_folder(const))</span>
        <span class="s4">if </span><span class="s1">appname:</span>
            <span class="s4">if </span><span class="s1">appauthor </span><span class="s4">is not False</span><span class="s1">:</span>
                <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">appauthor</span><span class="s4">, </span><span class="s1">appname)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">appname)</span>
    <span class="s4">elif </span><span class="s1">system == </span><span class="s5">'darwin'</span><span class="s1">:</span>
        <span class="s1">path = os.path.expanduser(</span><span class="s5">'~/Library/Application Support/'</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">appname:</span>
            <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">appname)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">path = os.getenv(</span><span class="s5">'XDG_DATA_HOME'</span><span class="s4">, </span><span class="s1">os.path.expanduser(</span><span class="s5">&quot;~/.local/share&quot;</span><span class="s1">))</span>
        <span class="s4">if </span><span class="s1">appname:</span>
            <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">appname)</span>
    <span class="s4">if </span><span class="s1">appname </span><span class="s4">and </span><span class="s1">version:</span>
        <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">version)</span>
    <span class="s4">return </span><span class="s1">path</span>


<span class="s4">def </span><span class="s1">site_data_dir(appname=</span><span class="s4">None, </span><span class="s1">appauthor=</span><span class="s4">None, </span><span class="s1">version=</span><span class="s4">None, </span><span class="s1">multipath=</span><span class="s4">False</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Return full path to the user-shared data dir for this application. 
 
        &quot;appname&quot; is the name of application. 
            If None, just the system directory is returned. 
        &quot;appauthor&quot; (only used on Windows) is the name of the 
            appauthor or distributing body for this application. Typically 
            it is the owning company name. This falls back to appname. You may 
            pass False to disable it. 
        &quot;version&quot; is an optional version path element to append to the 
            path. You might want to use this if you want multiple versions 
            of your app to be able to run independently. If used, this 
            would typically be &quot;&lt;major&gt;.&lt;minor&gt;&quot;. 
            Only applied when appname is present. 
        &quot;multipath&quot; is an optional parameter only applicable to *nix 
            which indicates that the entire list of data dirs should be 
            returned. By default, the first item from XDG_DATA_DIRS is 
            returned, or '/usr/local/share/&lt;AppName&gt;', 
            if XDG_DATA_DIRS is not set 
 
    Typical site data directories are: 
        Mac OS X:   /Library/Application Support/&lt;AppName&gt; 
        Unix:       /usr/local/share/&lt;AppName&gt; or /usr/share/&lt;AppName&gt; 
        Win XP:     C:\Documents and Settings\All Users\Application Data\&lt;AppAuthor&gt;\&lt;AppName&gt; 
        Vista:      (Fail! &quot;C:\ProgramData&quot; is a hidden *system* directory on Vista.) 
        Win 7:      C:\ProgramData\&lt;AppAuthor&gt;\&lt;AppName&gt;   # Hidden, but writeable on Win 7. 
 
    For Unix, this is using the $XDG_DATA_DIRS[0] default. 
 
    WARNING: Do not use this on Windows. See the Vista-Fail note above for why. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">system == </span><span class="s5">&quot;win32&quot;</span><span class="s1">:</span>
        <span class="s4">if </span><span class="s1">appauthor </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">appauthor = appname</span>
        <span class="s1">path = os.path.normpath(_get_win_folder(</span><span class="s5">&quot;CSIDL_COMMON_APPDATA&quot;</span><span class="s1">))</span>
        <span class="s4">if </span><span class="s1">appname:</span>
            <span class="s4">if </span><span class="s1">appauthor </span><span class="s4">is not False</span><span class="s1">:</span>
                <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">appauthor</span><span class="s4">, </span><span class="s1">appname)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">appname)</span>
    <span class="s4">elif </span><span class="s1">system == </span><span class="s5">'darwin'</span><span class="s1">:</span>
        <span class="s1">path = os.path.expanduser(</span><span class="s5">'/Library/Application Support'</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">appname:</span>
            <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">appname)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s0"># XDG default for $XDG_DATA_DIRS</span>
        <span class="s0"># only first, if multipath is False</span>
        <span class="s1">path = os.getenv(</span><span class="s5">'XDG_DATA_DIRS'</span><span class="s4">,</span>
                         <span class="s1">os.pathsep.join([</span><span class="s5">'/usr/local/share'</span><span class="s4">, </span><span class="s5">'/usr/share'</span><span class="s1">]))</span>
        <span class="s1">pathlist = [os.path.expanduser(x.rstrip(os.sep)) </span><span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">path.split(os.pathsep)]</span>
        <span class="s4">if </span><span class="s1">appname:</span>
            <span class="s4">if </span><span class="s1">version:</span>
                <span class="s1">appname = os.path.join(appname</span><span class="s4">, </span><span class="s1">version)</span>
            <span class="s1">pathlist = [os.sep.join([x</span><span class="s4">, </span><span class="s1">appname]) </span><span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">pathlist]</span>

        <span class="s4">if </span><span class="s1">multipath:</span>
            <span class="s1">path = os.pathsep.join(pathlist)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">path = pathlist[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s4">return </span><span class="s1">path</span>

    <span class="s4">if </span><span class="s1">appname </span><span class="s4">and </span><span class="s1">version:</span>
        <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">version)</span>
    <span class="s4">return </span><span class="s1">path</span>


<span class="s4">def </span><span class="s1">user_config_dir(appname=</span><span class="s4">None, </span><span class="s1">appauthor=</span><span class="s4">None, </span><span class="s1">version=</span><span class="s4">None, </span><span class="s1">roaming=</span><span class="s4">False</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Return full path to the user-specific config dir for this application. 
 
        &quot;appname&quot; is the name of application. 
            If None, just the system directory is returned. 
        &quot;appauthor&quot; (only used on Windows) is the name of the 
            appauthor or distributing body for this application. Typically 
            it is the owning company name. This falls back to appname. You may 
            pass False to disable it. 
        &quot;version&quot; is an optional version path element to append to the 
            path. You might want to use this if you want multiple versions 
            of your app to be able to run independently. If used, this 
            would typically be &quot;&lt;major&gt;.&lt;minor&gt;&quot;. 
            Only applied when appname is present. 
        &quot;roaming&quot; (boolean, default False) can be set True to use the Windows 
            roaming appdata directory. That means that for users on a Windows 
            network setup for roaming profiles, this user data will be 
            sync'd on login. See 
            &lt;http://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx&gt; 
            for a discussion of issues. 
 
    Typical user config directories are: 
        Mac OS X:               same as user_data_dir 
        Unix:                   ~/.config/&lt;AppName&gt;     # or in $XDG_CONFIG_HOME, if defined 
        Win *:                  same as user_data_dir 
 
    For Unix, we follow the XDG spec and support $XDG_CONFIG_HOME. 
    That means, by default &quot;~/.config/&lt;AppName&gt;&quot;. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">system </span><span class="s4">in </span><span class="s1">[</span><span class="s5">&quot;win32&quot;</span><span class="s4">, </span><span class="s5">&quot;darwin&quot;</span><span class="s1">]:</span>
        <span class="s1">path = user_data_dir(appname</span><span class="s4">, </span><span class="s1">appauthor</span><span class="s4">, None, </span><span class="s1">roaming)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">path = os.getenv(</span><span class="s5">'XDG_CONFIG_HOME'</span><span class="s4">, </span><span class="s1">os.path.expanduser(</span><span class="s5">&quot;~/.config&quot;</span><span class="s1">))</span>
        <span class="s4">if </span><span class="s1">appname:</span>
            <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">appname)</span>
    <span class="s4">if </span><span class="s1">appname </span><span class="s4">and </span><span class="s1">version:</span>
        <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">version)</span>
    <span class="s4">return </span><span class="s1">path</span>


<span class="s4">def </span><span class="s1">site_config_dir(appname=</span><span class="s4">None, </span><span class="s1">appauthor=</span><span class="s4">None, </span><span class="s1">version=</span><span class="s4">None, </span><span class="s1">multipath=</span><span class="s4">False</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Return full path to the user-shared data dir for this application. 
 
        &quot;appname&quot; is the name of application. 
            If None, just the system directory is returned. 
        &quot;appauthor&quot; (only used on Windows) is the name of the 
            appauthor or distributing body for this application. Typically 
            it is the owning company name. This falls back to appname. You may 
            pass False to disable it. 
        &quot;version&quot; is an optional version path element to append to the 
            path. You might want to use this if you want multiple versions 
            of your app to be able to run independently. If used, this 
            would typically be &quot;&lt;major&gt;.&lt;minor&gt;&quot;. 
            Only applied when appname is present. 
        &quot;multipath&quot; is an optional parameter only applicable to *nix 
            which indicates that the entire list of config dirs should be 
            returned. By default, the first item from XDG_CONFIG_DIRS is 
            returned, or '/etc/xdg/&lt;AppName&gt;', if XDG_CONFIG_DIRS is not set 
 
    Typical site config directories are: 
        Mac OS X:   same as site_data_dir 
        Unix:       /etc/xdg/&lt;AppName&gt; or $XDG_CONFIG_DIRS[i]/&lt;AppName&gt; for each value in 
                    $XDG_CONFIG_DIRS 
        Win *:      same as site_data_dir 
        Vista:      (Fail! &quot;C:\ProgramData&quot; is a hidden *system* directory on Vista.) 
 
    For Unix, this is using the $XDG_CONFIG_DIRS[0] default, if multipath=False 
 
    WARNING: Do not use this on Windows. See the Vista-Fail note above for why. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">system </span><span class="s4">in </span><span class="s1">[</span><span class="s5">&quot;win32&quot;</span><span class="s4">, </span><span class="s5">&quot;darwin&quot;</span><span class="s1">]:</span>
        <span class="s1">path = site_data_dir(appname</span><span class="s4">, </span><span class="s1">appauthor)</span>
        <span class="s4">if </span><span class="s1">appname </span><span class="s4">and </span><span class="s1">version:</span>
            <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">version)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s0"># XDG default for $XDG_CONFIG_DIRS</span>
        <span class="s0"># only first, if multipath is False</span>
        <span class="s1">path = os.getenv(</span><span class="s5">'XDG_CONFIG_DIRS'</span><span class="s4">, </span><span class="s5">'/etc/xdg'</span><span class="s1">)</span>
        <span class="s1">pathlist = [os.path.expanduser(x.rstrip(os.sep)) </span><span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">path.split(os.pathsep)]</span>
        <span class="s4">if </span><span class="s1">appname:</span>
            <span class="s4">if </span><span class="s1">version:</span>
                <span class="s1">appname = os.path.join(appname</span><span class="s4">, </span><span class="s1">version)</span>
            <span class="s1">pathlist = [os.sep.join([x</span><span class="s4">, </span><span class="s1">appname]) </span><span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">pathlist]</span>

        <span class="s4">if </span><span class="s1">multipath:</span>
            <span class="s1">path = os.pathsep.join(pathlist)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">path = pathlist[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s4">return </span><span class="s1">path</span>


<span class="s4">def </span><span class="s1">user_cache_dir(appname=</span><span class="s4">None, </span><span class="s1">appauthor=</span><span class="s4">None, </span><span class="s1">version=</span><span class="s4">None, </span><span class="s1">opinion=</span><span class="s4">True</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Return full path to the user-specific cache dir for this application. 
 
        &quot;appname&quot; is the name of application. 
            If None, just the system directory is returned. 
        &quot;appauthor&quot; (only used on Windows) is the name of the 
            appauthor or distributing body for this application. Typically 
            it is the owning company name. This falls back to appname. You may 
            pass False to disable it. 
        &quot;version&quot; is an optional version path element to append to the 
            path. You might want to use this if you want multiple versions 
            of your app to be able to run independently. If used, this 
            would typically be &quot;&lt;major&gt;.&lt;minor&gt;&quot;. 
            Only applied when appname is present. 
        &quot;opinion&quot; (boolean) can be False to disable the appending of 
            &quot;Cache&quot; to the base app data dir for Windows. See 
            discussion below. 
 
    Typical user cache directories are: 
        Mac OS X:   ~/Library/Caches/&lt;AppName&gt; 
        Unix:       ~/.cache/&lt;AppName&gt; (XDG default) 
        Win XP:     C:\Documents and Settings\&lt;username&gt;\Local Settings\Application Data\&lt;AppAuthor&gt;\&lt;AppName&gt;\Cache 
        Vista:      C:\Users\&lt;username&gt;\AppData\Local\&lt;AppAuthor&gt;\&lt;AppName&gt;\Cache 
 
    On Windows the only suggestion in the MSDN docs is that local settings go in 
    the `CSIDL_LOCAL_APPDATA` directory. This is identical to the non-roaming 
    app data dir (the default returned by `user_data_dir` above). Apps typically 
    put cache data somewhere *under* the given dir here. Some examples: 
        ...\Mozilla\Firefox\Profiles\&lt;ProfileName&gt;\Cache 
        ...\Acme\SuperApp\Cache\1.0 
    OPINION: This function appends &quot;Cache&quot; to the `CSIDL_LOCAL_APPDATA` value. 
    This can be disabled with the `opinion=False` option. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">system == </span><span class="s5">&quot;win32&quot;</span><span class="s1">:</span>
        <span class="s4">if </span><span class="s1">appauthor </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">appauthor = appname</span>
        <span class="s1">path = os.path.normpath(_get_win_folder(</span><span class="s5">&quot;CSIDL_LOCAL_APPDATA&quot;</span><span class="s1">))</span>
        <span class="s4">if </span><span class="s1">appname:</span>
            <span class="s4">if </span><span class="s1">appauthor </span><span class="s4">is not False</span><span class="s1">:</span>
                <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">appauthor</span><span class="s4">, </span><span class="s1">appname)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">appname)</span>
            <span class="s4">if </span><span class="s1">opinion:</span>
                <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s5">&quot;Cache&quot;</span><span class="s1">)</span>
    <span class="s4">elif </span><span class="s1">system == </span><span class="s5">'darwin'</span><span class="s1">:</span>
        <span class="s1">path = os.path.expanduser(</span><span class="s5">'~/Library/Caches'</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">appname:</span>
            <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">appname)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">path = os.getenv(</span><span class="s5">'XDG_CACHE_HOME'</span><span class="s4">, </span><span class="s1">os.path.expanduser(</span><span class="s5">'~/.cache'</span><span class="s1">))</span>
        <span class="s4">if </span><span class="s1">appname:</span>
            <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">appname)</span>
    <span class="s4">if </span><span class="s1">appname </span><span class="s4">and </span><span class="s1">version:</span>
        <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">version)</span>
    <span class="s4">return </span><span class="s1">path</span>


<span class="s4">def </span><span class="s1">user_state_dir(appname=</span><span class="s4">None, </span><span class="s1">appauthor=</span><span class="s4">None, </span><span class="s1">version=</span><span class="s4">None, </span><span class="s1">roaming=</span><span class="s4">False</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Return full path to the user-specific state dir for this application. 
 
        &quot;appname&quot; is the name of application. 
            If None, just the system directory is returned. 
        &quot;appauthor&quot; (only used on Windows) is the name of the 
            appauthor or distributing body for this application. Typically 
            it is the owning company name. This falls back to appname. You may 
            pass False to disable it. 
        &quot;version&quot; is an optional version path element to append to the 
            path. You might want to use this if you want multiple versions 
            of your app to be able to run independently. If used, this 
            would typically be &quot;&lt;major&gt;.&lt;minor&gt;&quot;. 
            Only applied when appname is present. 
        &quot;roaming&quot; (boolean, default False) can be set True to use the Windows 
            roaming appdata directory. That means that for users on a Windows 
            network setup for roaming profiles, this user data will be 
            sync'd on login. See 
            &lt;http://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx&gt; 
            for a discussion of issues. 
 
    Typical user state directories are: 
        Mac OS X:  same as user_data_dir 
        Unix:      ~/.local/state/&lt;AppName&gt;   # or in $XDG_STATE_HOME, if defined 
        Win *:     same as user_data_dir 
 
    For Unix, we follow this Debian proposal &lt;https://wiki.debian.org/XDGBaseDirectorySpecification#state&gt; 
    to extend the XDG spec and support $XDG_STATE_HOME. 
 
    That means, by default &quot;~/.local/state/&lt;AppName&gt;&quot;. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">system </span><span class="s4">in </span><span class="s1">[</span><span class="s5">&quot;win32&quot;</span><span class="s4">, </span><span class="s5">&quot;darwin&quot;</span><span class="s1">]:</span>
        <span class="s1">path = user_data_dir(appname</span><span class="s4">, </span><span class="s1">appauthor</span><span class="s4">, None, </span><span class="s1">roaming)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">path = os.getenv(</span><span class="s5">'XDG_STATE_HOME'</span><span class="s4">, </span><span class="s1">os.path.expanduser(</span><span class="s5">&quot;~/.local/state&quot;</span><span class="s1">))</span>
        <span class="s4">if </span><span class="s1">appname:</span>
            <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">appname)</span>
    <span class="s4">if </span><span class="s1">appname </span><span class="s4">and </span><span class="s1">version:</span>
        <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">version)</span>
    <span class="s4">return </span><span class="s1">path</span>


<span class="s4">def </span><span class="s1">user_log_dir(appname=</span><span class="s4">None, </span><span class="s1">appauthor=</span><span class="s4">None, </span><span class="s1">version=</span><span class="s4">None, </span><span class="s1">opinion=</span><span class="s4">True</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Return full path to the user-specific log dir for this application. 
 
        &quot;appname&quot; is the name of application. 
            If None, just the system directory is returned. 
        &quot;appauthor&quot; (only used on Windows) is the name of the 
            appauthor or distributing body for this application. Typically 
            it is the owning company name. This falls back to appname. You may 
            pass False to disable it. 
        &quot;version&quot; is an optional version path element to append to the 
            path. You might want to use this if you want multiple versions 
            of your app to be able to run independently. If used, this 
            would typically be &quot;&lt;major&gt;.&lt;minor&gt;&quot;. 
            Only applied when appname is present. 
        &quot;opinion&quot; (boolean) can be False to disable the appending of 
            &quot;Logs&quot; to the base app data dir for Windows, and &quot;log&quot; to the 
            base cache dir for Unix. See discussion below. 
 
    Typical user log directories are: 
        Mac OS X:   ~/Library/Logs/&lt;AppName&gt; 
        Unix:       ~/.cache/&lt;AppName&gt;/log  # or under $XDG_CACHE_HOME if defined 
        Win XP:     C:\Documents and Settings\&lt;username&gt;\Local Settings\Application Data\&lt;AppAuthor&gt;\&lt;AppName&gt;\Logs 
        Vista:      C:\Users\&lt;username&gt;\AppData\Local\&lt;AppAuthor&gt;\&lt;AppName&gt;\Logs 
 
    On Windows the only suggestion in the MSDN docs is that local settings 
    go in the `CSIDL_LOCAL_APPDATA` directory. (Note: I'm interested in 
    examples of what some windows apps use for a logs dir.) 
 
    OPINION: This function appends &quot;Logs&quot; to the `CSIDL_LOCAL_APPDATA` 
    value for Windows and appends &quot;log&quot; to the user cache dir for Unix. 
    This can be disabled with the `opinion=False` option. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">system == </span><span class="s5">&quot;darwin&quot;</span><span class="s1">:</span>
        <span class="s1">path = os.path.join(</span>
            <span class="s1">os.path.expanduser(</span><span class="s5">'~/Library/Logs'</span><span class="s1">)</span><span class="s4">,</span>
            <span class="s1">appname)</span>
    <span class="s4">elif </span><span class="s1">system == </span><span class="s5">&quot;win32&quot;</span><span class="s1">:</span>
        <span class="s1">path = user_data_dir(appname</span><span class="s4">, </span><span class="s1">appauthor</span><span class="s4">, </span><span class="s1">version)</span>
        <span class="s1">version = </span><span class="s4">False</span>
        <span class="s4">if </span><span class="s1">opinion:</span>
            <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s5">&quot;Logs&quot;</span><span class="s1">)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">path = user_cache_dir(appname</span><span class="s4">, </span><span class="s1">appauthor</span><span class="s4">, </span><span class="s1">version)</span>
        <span class="s1">version = </span><span class="s4">False</span>
        <span class="s4">if </span><span class="s1">opinion:</span>
            <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s5">&quot;log&quot;</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">appname </span><span class="s4">and </span><span class="s1">version:</span>
        <span class="s1">path = os.path.join(path</span><span class="s4">, </span><span class="s1">version)</span>
    <span class="s4">return </span><span class="s1">path</span>


<span class="s4">class </span><span class="s1">AppDirs(object):</span>
    <span class="s2">&quot;&quot;&quot;Convenience wrapper for getting application dirs.&quot;&quot;&quot;</span>
    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">appname=</span><span class="s4">None, </span><span class="s1">appauthor=</span><span class="s4">None, </span><span class="s1">version=</span><span class="s4">None,</span>
            <span class="s1">roaming=</span><span class="s4">False, </span><span class="s1">multipath=</span><span class="s4">False</span><span class="s1">):</span>
        <span class="s1">self.appname = appname</span>
        <span class="s1">self.appauthor = appauthor</span>
        <span class="s1">self.version = version</span>
        <span class="s1">self.roaming = roaming</span>
        <span class="s1">self.multipath = multipath</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">user_data_dir(self):</span>
        <span class="s4">return </span><span class="s1">user_data_dir(self.appname</span><span class="s4">, </span><span class="s1">self.appauthor</span><span class="s4">,</span>
                             <span class="s1">version=self.version</span><span class="s4">, </span><span class="s1">roaming=self.roaming)</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">site_data_dir(self):</span>
        <span class="s4">return </span><span class="s1">site_data_dir(self.appname</span><span class="s4">, </span><span class="s1">self.appauthor</span><span class="s4">,</span>
                             <span class="s1">version=self.version</span><span class="s4">, </span><span class="s1">multipath=self.multipath)</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">user_config_dir(self):</span>
        <span class="s4">return </span><span class="s1">user_config_dir(self.appname</span><span class="s4">, </span><span class="s1">self.appauthor</span><span class="s4">,</span>
                               <span class="s1">version=self.version</span><span class="s4">, </span><span class="s1">roaming=self.roaming)</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">site_config_dir(self):</span>
        <span class="s4">return </span><span class="s1">site_config_dir(self.appname</span><span class="s4">, </span><span class="s1">self.appauthor</span><span class="s4">,</span>
                             <span class="s1">version=self.version</span><span class="s4">, </span><span class="s1">multipath=self.multipath)</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">user_cache_dir(self):</span>
        <span class="s4">return </span><span class="s1">user_cache_dir(self.appname</span><span class="s4">, </span><span class="s1">self.appauthor</span><span class="s4">,</span>
                              <span class="s1">version=self.version)</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">user_state_dir(self):</span>
        <span class="s4">return </span><span class="s1">user_state_dir(self.appname</span><span class="s4">, </span><span class="s1">self.appauthor</span><span class="s4">,</span>
                              <span class="s1">version=self.version)</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">user_log_dir(self):</span>
        <span class="s4">return </span><span class="s1">user_log_dir(self.appname</span><span class="s4">, </span><span class="s1">self.appauthor</span><span class="s4">,</span>
                            <span class="s1">version=self.version)</span>


<span class="s0">#---- internal support stuff</span>

<span class="s4">def </span><span class="s1">_get_win_folder_from_registry(csidl_name):</span>
    <span class="s2">&quot;&quot;&quot;This is a fallback technique at best. I'm not sure if using the 
    registry for this guarantees us the correct answer for all CSIDL_* 
    names. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">PY3:</span>
      <span class="s4">import </span><span class="s1">winreg </span><span class="s4">as </span><span class="s1">_winreg</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s4">import </span><span class="s1">_winreg</span>

    <span class="s1">shell_folder_name = {</span>
        <span class="s5">&quot;CSIDL_APPDATA&quot;</span><span class="s1">: </span><span class="s5">&quot;AppData&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;CSIDL_COMMON_APPDATA&quot;</span><span class="s1">: </span><span class="s5">&quot;Common AppData&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;CSIDL_LOCAL_APPDATA&quot;</span><span class="s1">: </span><span class="s5">&quot;Local AppData&quot;</span><span class="s4">,</span>
    <span class="s1">}[csidl_name]</span>

    <span class="s1">key = _winreg.OpenKey(</span>
        <span class="s1">_winreg.HKEY_CURRENT_USER</span><span class="s4">,</span>
        <span class="s5">r&quot;Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders&quot;</span>
    <span class="s1">)</span>
    <span class="s1">dir</span><span class="s4">, </span><span class="s1">type = _winreg.QueryValueEx(key</span><span class="s4">, </span><span class="s1">shell_folder_name)</span>
    <span class="s4">return </span><span class="s1">dir</span>


<span class="s4">def </span><span class="s1">_get_win_folder_with_pywin32(csidl_name):</span>
    <span class="s4">from </span><span class="s1">win32com.shell </span><span class="s4">import </span><span class="s1">shellcon</span><span class="s4">, </span><span class="s1">shell</span>
    <span class="s1">dir = shell.SHGetFolderPath(</span><span class="s3">0</span><span class="s4">, </span><span class="s1">getattr(shellcon</span><span class="s4">, </span><span class="s1">csidl_name)</span><span class="s4">, </span><span class="s3">0</span><span class="s4">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s0"># Try to make this a unicode path because SHGetFolderPath does</span>
    <span class="s0"># not return unicode strings when there is unicode data in the</span>
    <span class="s0"># path.</span>
    <span class="s4">try</span><span class="s1">:</span>
        <span class="s1">dir = unicode(dir)</span>

        <span class="s0"># Downgrade to short path name if have highbit chars. See</span>
        <span class="s0"># &lt;http://bugs.activestate.com/show_bug.cgi?id=85099&gt;.</span>
        <span class="s1">has_high_char = </span><span class="s4">False</span>
        <span class="s4">for </span><span class="s1">c </span><span class="s4">in </span><span class="s1">dir:</span>
            <span class="s4">if </span><span class="s1">ord(c) &gt; </span><span class="s3">255</span><span class="s1">:</span>
                <span class="s1">has_high_char = </span><span class="s4">True</span>
                <span class="s4">break</span>
        <span class="s4">if </span><span class="s1">has_high_char:</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s4">import </span><span class="s1">win32api</span>
                <span class="s1">dir = win32api.GetShortPathName(dir)</span>
            <span class="s4">except </span><span class="s1">ImportError:</span>
                <span class="s4">pass</span>
    <span class="s4">except </span><span class="s1">UnicodeError:</span>
        <span class="s4">pass</span>
    <span class="s4">return </span><span class="s1">dir</span>


<span class="s4">def </span><span class="s1">_get_win_folder_with_ctypes(csidl_name):</span>
    <span class="s4">import </span><span class="s1">ctypes</span>

    <span class="s1">csidl_const = {</span>
        <span class="s5">&quot;CSIDL_APPDATA&quot;</span><span class="s1">: </span><span class="s3">26</span><span class="s4">,</span>
        <span class="s5">&quot;CSIDL_COMMON_APPDATA&quot;</span><span class="s1">: </span><span class="s3">35</span><span class="s4">,</span>
        <span class="s5">&quot;CSIDL_LOCAL_APPDATA&quot;</span><span class="s1">: </span><span class="s3">28</span><span class="s4">,</span>
    <span class="s1">}[csidl_name]</span>

    <span class="s1">buf = ctypes.create_unicode_buffer(</span><span class="s3">1024</span><span class="s1">)</span>
    <span class="s1">ctypes.windll.shell32.SHGetFolderPathW(</span><span class="s4">None, </span><span class="s1">csidl_const</span><span class="s4">, None, </span><span class="s3">0</span><span class="s4">, </span><span class="s1">buf)</span>

    <span class="s0"># Downgrade to short path name if have highbit chars. See</span>
    <span class="s0"># &lt;http://bugs.activestate.com/show_bug.cgi?id=85099&gt;.</span>
    <span class="s1">has_high_char = </span><span class="s4">False</span>
    <span class="s4">for </span><span class="s1">c </span><span class="s4">in </span><span class="s1">buf:</span>
        <span class="s4">if </span><span class="s1">ord(c) &gt; </span><span class="s3">255</span><span class="s1">:</span>
            <span class="s1">has_high_char = </span><span class="s4">True</span>
            <span class="s4">break</span>
    <span class="s4">if </span><span class="s1">has_high_char:</span>
        <span class="s1">buf2 = ctypes.create_unicode_buffer(</span><span class="s3">1024</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">ctypes.windll.kernel32.GetShortPathNameW(buf.value</span><span class="s4">, </span><span class="s1">buf2</span><span class="s4">, </span><span class="s3">1024</span><span class="s1">):</span>
            <span class="s1">buf = buf2</span>

    <span class="s4">return </span><span class="s1">buf.value</span>

<span class="s4">def </span><span class="s1">_get_win_folder_with_jna(csidl_name):</span>
    <span class="s4">import </span><span class="s1">array</span>
    <span class="s4">from </span><span class="s1">com.sun </span><span class="s4">import </span><span class="s1">jna</span>
    <span class="s4">from </span><span class="s1">com.sun.jna.platform </span><span class="s4">import </span><span class="s1">win32</span>

    <span class="s1">buf_size = win32.WinDef.MAX_PATH * </span><span class="s3">2</span>
    <span class="s1">buf = array.zeros(</span><span class="s5">'c'</span><span class="s4">, </span><span class="s1">buf_size)</span>
    <span class="s1">shell = win32.Shell32.INSTANCE</span>
    <span class="s1">shell.SHGetFolderPath(</span><span class="s4">None, </span><span class="s1">getattr(win32.ShlObj</span><span class="s4">, </span><span class="s1">csidl_name)</span><span class="s4">, None, </span><span class="s1">win32.ShlObj.SHGFP_TYPE_CURRENT</span><span class="s4">, </span><span class="s1">buf)</span>
    <span class="s1">dir = jna.Native.toString(buf.tostring()).rstrip(</span><span class="s5">&quot;</span><span class="s4">\0</span><span class="s5">&quot;</span><span class="s1">)</span>

    <span class="s0"># Downgrade to short path name if have highbit chars. See</span>
    <span class="s0"># &lt;http://bugs.activestate.com/show_bug.cgi?id=85099&gt;.</span>
    <span class="s1">has_high_char = </span><span class="s4">False</span>
    <span class="s4">for </span><span class="s1">c </span><span class="s4">in </span><span class="s1">dir:</span>
        <span class="s4">if </span><span class="s1">ord(c) &gt; </span><span class="s3">255</span><span class="s1">:</span>
            <span class="s1">has_high_char = </span><span class="s4">True</span>
            <span class="s4">break</span>
    <span class="s4">if </span><span class="s1">has_high_char:</span>
        <span class="s1">buf = array.zeros(</span><span class="s5">'c'</span><span class="s4">, </span><span class="s1">buf_size)</span>
        <span class="s1">kernel = win32.Kernel32.INSTANCE</span>
        <span class="s4">if </span><span class="s1">kernel.GetShortPathName(dir</span><span class="s4">, </span><span class="s1">buf</span><span class="s4">, </span><span class="s1">buf_size):</span>
            <span class="s1">dir = jna.Native.toString(buf.tostring()).rstrip(</span><span class="s5">&quot;</span><span class="s4">\0</span><span class="s5">&quot;</span><span class="s1">)</span>

    <span class="s4">return </span><span class="s1">dir</span>

<span class="s4">if </span><span class="s1">system == </span><span class="s5">&quot;win32&quot;</span><span class="s1">:</span>
    <span class="s4">try</span><span class="s1">:</span>
        <span class="s4">import </span><span class="s1">win32com.shell</span>
        <span class="s1">_get_win_folder = _get_win_folder_with_pywin32</span>
    <span class="s4">except </span><span class="s1">ImportError:</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s4">from </span><span class="s1">ctypes </span><span class="s4">import </span><span class="s1">windll</span>
            <span class="s1">_get_win_folder = _get_win_folder_with_ctypes</span>
        <span class="s4">except </span><span class="s1">ImportError:</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s4">import </span><span class="s1">com.sun.jna</span>
                <span class="s1">_get_win_folder = _get_win_folder_with_jna</span>
            <span class="s4">except </span><span class="s1">ImportError:</span>
                <span class="s1">_get_win_folder = _get_win_folder_from_registry</span>


<span class="s0">#---- self test code</span>

<span class="s4">if </span><span class="s1">__name__ == </span><span class="s5">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s1">appname = </span><span class="s5">&quot;MyApp&quot;</span>
    <span class="s1">appauthor = </span><span class="s5">&quot;MyCompany&quot;</span>

    <span class="s1">props = (</span><span class="s5">&quot;user_data_dir&quot;</span><span class="s4">,</span>
             <span class="s5">&quot;user_config_dir&quot;</span><span class="s4">,</span>
             <span class="s5">&quot;user_cache_dir&quot;</span><span class="s4">,</span>
             <span class="s5">&quot;user_state_dir&quot;</span><span class="s4">,</span>
             <span class="s5">&quot;user_log_dir&quot;</span><span class="s4">,</span>
             <span class="s5">&quot;site_data_dir&quot;</span><span class="s4">,</span>
             <span class="s5">&quot;site_config_dir&quot;</span><span class="s1">)</span>

    <span class="s1">print(</span><span class="s5">&quot;-- app dirs %s --&quot; </span><span class="s1">% __version__)</span>

    <span class="s1">print(</span><span class="s5">&quot;-- app dirs (with optional 'version')&quot;</span><span class="s1">)</span>
    <span class="s1">dirs = AppDirs(appname</span><span class="s4">, </span><span class="s1">appauthor</span><span class="s4">, </span><span class="s1">version=</span><span class="s5">&quot;1.0&quot;</span><span class="s1">)</span>
    <span class="s4">for </span><span class="s1">prop </span><span class="s4">in </span><span class="s1">props:</span>
        <span class="s1">print(</span><span class="s5">&quot;%s: %s&quot; </span><span class="s1">% (prop</span><span class="s4">, </span><span class="s1">getattr(dirs</span><span class="s4">, </span><span class="s1">prop)))</span>

    <span class="s1">print(</span><span class="s5">&quot;</span><span class="s4">\n</span><span class="s5">-- app dirs (without optional 'version')&quot;</span><span class="s1">)</span>
    <span class="s1">dirs = AppDirs(appname</span><span class="s4">, </span><span class="s1">appauthor)</span>
    <span class="s4">for </span><span class="s1">prop </span><span class="s4">in </span><span class="s1">props:</span>
        <span class="s1">print(</span><span class="s5">&quot;%s: %s&quot; </span><span class="s1">% (prop</span><span class="s4">, </span><span class="s1">getattr(dirs</span><span class="s4">, </span><span class="s1">prop)))</span>

    <span class="s1">print(</span><span class="s5">&quot;</span><span class="s4">\n</span><span class="s5">-- app dirs (without optional 'appauthor')&quot;</span><span class="s1">)</span>
    <span class="s1">dirs = AppDirs(appname)</span>
    <span class="s4">for </span><span class="s1">prop </span><span class="s4">in </span><span class="s1">props:</span>
        <span class="s1">print(</span><span class="s5">&quot;%s: %s&quot; </span><span class="s1">% (prop</span><span class="s4">, </span><span class="s1">getattr(dirs</span><span class="s4">, </span><span class="s1">prop)))</span>

    <span class="s1">print(</span><span class="s5">&quot;</span><span class="s4">\n</span><span class="s5">-- app dirs (with disabled 'appauthor')&quot;</span><span class="s1">)</span>
    <span class="s1">dirs = AppDirs(appname</span><span class="s4">, </span><span class="s1">appauthor=</span><span class="s4">False</span><span class="s1">)</span>
    <span class="s4">for </span><span class="s1">prop </span><span class="s4">in </span><span class="s1">props:</span>
        <span class="s1">print(</span><span class="s5">&quot;%s: %s&quot; </span><span class="s1">% (prop</span><span class="s4">, </span><span class="s1">getattr(dirs</span><span class="s4">, </span><span class="s1">prop)))</span>
</pre>
</body>
</html>