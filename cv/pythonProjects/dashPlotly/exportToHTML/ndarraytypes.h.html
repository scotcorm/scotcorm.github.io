<html>
<head>
<title>ndarraytypes.h</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #0f9795;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ndarraytypes.h</font>
</center></td></tr></table>
<pre><span class="s0">#ifndef </span><span class="s1">NUMPY_CORE_INCLUDE_NUMPY_NDARRAYTYPES_H_</span>
<span class="s0">#define </span><span class="s1">NUMPY_CORE_INCLUDE_NUMPY_NDARRAYTYPES_H_</span>

<span class="s0">#include </span><span class="s2">&quot;npy_common.h&quot;</span>
<span class="s0">#include </span><span class="s2">&quot;npy_endian.h&quot;</span>
<span class="s0">#include </span><span class="s2">&quot;npy_cpu.h&quot;</span>
<span class="s0">#include </span><span class="s2">&quot;utils.h&quot;</span>

<span class="s0">#define </span><span class="s1">NPY_NO_EXPORT NPY_VISIBILITY_HIDDEN</span>

<span class="s3">/* Only use thread if configured in config and python supports it */</span>
<span class="s0">#if </span><span class="s1">defined WITH_THREAD &amp;&amp; !NPY_NO_SMP</span>
        <span class="s0">#define </span><span class="s1">NPY_ALLOW_THREADS </span><span class="s4">1</span>
<span class="s0">#else</span>
        <span class="s0">#define </span><span class="s1">NPY_ALLOW_THREADS </span><span class="s4">0</span>
<span class="s0">#endif</span>

<span class="s0">#ifndef </span><span class="s1">__has_extension</span>
<span class="s0">#define </span><span class="s1">__has_extension(x) </span><span class="s4">0</span>
<span class="s0">#endif</span>

<span class="s0">#if </span><span class="s1">!defined(_NPY_NO_DEPRECATIONS) &amp;&amp; \</span>
    <span class="s1">((defined(__GNUC__)&amp;&amp; __GNUC__ &gt;= </span><span class="s4">6</span><span class="s1">) || \</span>
     <span class="s1">__has_extension(attribute_deprecated_with_message))</span>
<span class="s0">#define </span><span class="s1">NPY_ATTR_DEPRECATE(text) __attribute__ ((deprecated (text)))</span>
<span class="s0">#else</span>
<span class="s0">#define </span><span class="s1">NPY_ATTR_DEPRECATE(text)</span>
<span class="s0">#endif</span>

<span class="s3">/* 
 * There are several places in the code where an array of dimensions 
 * is allocated statically.  This is the size of that static 
 * allocation. 
 * 
 * The array creation itself could have arbitrary dimensions but all 
 * the places where static allocation is used would need to be changed 
 * to dynamic (including inside of several structures) 
 */</span>

<span class="s0">#define </span><span class="s1">NPY_MAXDIMS </span><span class="s4">32</span>
<span class="s0">#define </span><span class="s1">NPY_MAXARGS </span><span class="s4">32</span>

<span class="s3">/* Used for Converter Functions &quot;O&amp;&quot; code in ParseTuple */</span>
<span class="s0">#define </span><span class="s1">NPY_FAIL </span><span class="s4">0</span>
<span class="s0">#define </span><span class="s1">NPY_SUCCEED </span><span class="s4">1</span>

<span class="s3">/* 
 * Binary compatibility version number.  This number is increased 
 * whenever the C-API is changed such that binary compatibility is 
 * broken, i.e. whenever a recompile of extension modules is needed. 
 */</span>
<span class="s0">#define </span><span class="s1">NPY_VERSION NPY_ABI_VERSION</span>

<span class="s3">/* 
 * Minor API version.  This number is increased whenever a change is 
 * made to the C-API -- whether it breaks binary compatibility or not. 
 * Some changes, such as adding a function pointer to the end of the 
 * function table, can be made without breaking binary compatibility. 
 * In this case, only the NPY_FEATURE_VERSION (*not* NPY_VERSION) 
 * would be increased.  Whenever binary compatibility is broken, both 
 * NPY_VERSION and NPY_FEATURE_VERSION should be increased. 
 */</span>
<span class="s0">#define </span><span class="s1">NPY_FEATURE_VERSION NPY_API_VERSION</span>

<span class="s0">enum </span><span class="s1">NPY_TYPES {    NPY_BOOL=</span><span class="s4">0</span><span class="s1">,</span>
                    <span class="s1">NPY_BYTE, NPY_UBYTE,</span>
                    <span class="s1">NPY_SHORT, NPY_USHORT,</span>
                    <span class="s1">NPY_INT, NPY_UINT,</span>
                    <span class="s1">NPY_LONG, NPY_ULONG,</span>
                    <span class="s1">NPY_LONGLONG, NPY_ULONGLONG,</span>
                    <span class="s1">NPY_FLOAT, NPY_DOUBLE, NPY_LONGDOUBLE,</span>
                    <span class="s1">NPY_CFLOAT, NPY_CDOUBLE, NPY_CLONGDOUBLE,</span>
                    <span class="s1">NPY_OBJECT=</span><span class="s4">17</span><span class="s1">,</span>
                    <span class="s1">NPY_STRING, NPY_UNICODE,</span>
                    <span class="s1">NPY_VOID,</span>
                    <span class="s3">/* 
                     * New 1.6 types appended, may be integrated 
                     * into the above in 2.0. 
                     */</span>
                    <span class="s1">NPY_DATETIME, NPY_TIMEDELTA, NPY_HALF,</span>

                    <span class="s1">NPY_NTYPES,</span>
                    <span class="s1">NPY_NOTYPE,</span>
                    <span class="s1">NPY_CHAR NPY_ATTR_DEPRECATE(</span><span class="s2">&quot;Use NPY_STRING&quot;</span><span class="s1">),</span>
                    <span class="s1">NPY_USERDEF=</span><span class="s4">256</span><span class="s1">,  </span><span class="s3">/* leave room for characters */</span>

                    <span class="s3">/* The number of types not including the new 1.6 types */</span>
                    <span class="s1">NPY_NTYPES_ABI_COMPATIBLE=</span><span class="s4">21</span>
<span class="s1">};</span>
<span class="s0">#ifdef </span><span class="s1">_MSC_VER</span>
<span class="s1">#pragma deprecated(NPY_CHAR)</span>
<span class="s0">#endif</span>

<span class="s3">/* basetype array priority */</span>
<span class="s0">#define </span><span class="s1">NPY_PRIORITY </span><span class="s4">0.0</span>

<span class="s3">/* default subtype priority */</span>
<span class="s0">#define </span><span class="s1">NPY_SUBTYPE_PRIORITY </span><span class="s4">1.0</span>

<span class="s3">/* default scalar priority */</span>
<span class="s0">#define </span><span class="s1">NPY_SCALAR_PRIORITY -</span><span class="s4">1000000.0</span>

<span class="s3">/* How many floating point types are there (excluding half) */</span>
<span class="s0">#define </span><span class="s1">NPY_NUM_FLOATTYPE </span><span class="s4">3</span>

<span class="s3">/* 
 * These characters correspond to the array type and the struct 
 * module 
 */</span>

<span class="s0">enum </span><span class="s1">NPY_TYPECHAR {</span>
        <span class="s1">NPY_BOOLLTR = </span><span class="s2">'?'</span><span class="s1">,</span>
        <span class="s1">NPY_BYTELTR = </span><span class="s2">'b'</span><span class="s1">,</span>
        <span class="s1">NPY_UBYTELTR = </span><span class="s2">'B'</span><span class="s1">,</span>
        <span class="s1">NPY_SHORTLTR = </span><span class="s2">'h'</span><span class="s1">,</span>
        <span class="s1">NPY_USHORTLTR = </span><span class="s2">'H'</span><span class="s1">,</span>
        <span class="s1">NPY_INTLTR = </span><span class="s2">'i'</span><span class="s1">,</span>
        <span class="s1">NPY_UINTLTR = </span><span class="s2">'I'</span><span class="s1">,</span>
        <span class="s1">NPY_LONGLTR = </span><span class="s2">'l'</span><span class="s1">,</span>
        <span class="s1">NPY_ULONGLTR = </span><span class="s2">'L'</span><span class="s1">,</span>
        <span class="s1">NPY_LONGLONGLTR = </span><span class="s2">'q'</span><span class="s1">,</span>
        <span class="s1">NPY_ULONGLONGLTR = </span><span class="s2">'Q'</span><span class="s1">,</span>
        <span class="s1">NPY_HALFLTR = </span><span class="s2">'e'</span><span class="s1">,</span>
        <span class="s1">NPY_FLOATLTR = </span><span class="s2">'f'</span><span class="s1">,</span>
        <span class="s1">NPY_DOUBLELTR = </span><span class="s2">'d'</span><span class="s1">,</span>
        <span class="s1">NPY_LONGDOUBLELTR = </span><span class="s2">'g'</span><span class="s1">,</span>
        <span class="s1">NPY_CFLOATLTR = </span><span class="s2">'F'</span><span class="s1">,</span>
        <span class="s1">NPY_CDOUBLELTR = </span><span class="s2">'D'</span><span class="s1">,</span>
        <span class="s1">NPY_CLONGDOUBLELTR = </span><span class="s2">'G'</span><span class="s1">,</span>
        <span class="s1">NPY_OBJECTLTR = </span><span class="s2">'O'</span><span class="s1">,</span>
        <span class="s1">NPY_STRINGLTR = </span><span class="s2">'S'</span><span class="s1">,</span>
        <span class="s1">NPY_STRINGLTR2 = </span><span class="s2">'a'</span><span class="s1">,</span>
        <span class="s1">NPY_UNICODELTR = </span><span class="s2">'U'</span><span class="s1">,</span>
        <span class="s1">NPY_VOIDLTR = </span><span class="s2">'V'</span><span class="s1">,</span>
        <span class="s1">NPY_DATETIMELTR = </span><span class="s2">'M'</span><span class="s1">,</span>
        <span class="s1">NPY_TIMEDELTALTR = </span><span class="s2">'m'</span><span class="s1">,</span>
        <span class="s1">NPY_CHARLTR = </span><span class="s2">'c'</span><span class="s1">,</span>

        <span class="s3">/* 
         * No Descriptor, just a define -- this let's 
         * Python users specify an array of integers 
         * large enough to hold a pointer on the 
         * platform 
         */</span>
        <span class="s1">NPY_INTPLTR = </span><span class="s2">'p'</span><span class="s1">,</span>
        <span class="s1">NPY_UINTPLTR = </span><span class="s2">'P'</span><span class="s1">,</span>

        <span class="s3">/* 
         * These are for dtype 'kinds', not dtype 'typecodes' 
         * as the above are for. 
         */</span>
        <span class="s1">NPY_GENBOOLLTR =</span><span class="s2">'b'</span><span class="s1">,</span>
        <span class="s1">NPY_SIGNEDLTR = </span><span class="s2">'i'</span><span class="s1">,</span>
        <span class="s1">NPY_UNSIGNEDLTR = </span><span class="s2">'u'</span><span class="s1">,</span>
        <span class="s1">NPY_FLOATINGLTR = </span><span class="s2">'f'</span><span class="s1">,</span>
        <span class="s1">NPY_COMPLEXLTR = </span><span class="s2">'c'</span>
<span class="s1">};</span>

<span class="s3">/* 
 * Changing this may break Numpy API compatibility 
 * due to changing offsets in PyArray_ArrFuncs, so be 
 * careful. Here we have reused the mergesort slot for 
 * any kind of stable sort, the actual implementation will 
 * depend on the data type. 
 */</span>
<span class="s0">typedef enum </span><span class="s1">{</span>
        <span class="s1">NPY_QUICKSORT=</span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">NPY_HEAPSORT=</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">NPY_MERGESORT=</span><span class="s4">2</span><span class="s1">,</span>
        <span class="s1">NPY_STABLESORT=</span><span class="s4">2</span><span class="s1">,</span>
<span class="s1">} NPY_SORTKIND;</span>
<span class="s0">#define </span><span class="s1">NPY_NSORTS (NPY_STABLESORT + </span><span class="s4">1</span><span class="s1">)</span>


<span class="s0">typedef enum </span><span class="s1">{</span>
        <span class="s1">NPY_INTROSELECT=</span><span class="s4">0</span>
<span class="s1">} NPY_SELECTKIND;</span>
<span class="s0">#define </span><span class="s1">NPY_NSELECTS (NPY_INTROSELECT + </span><span class="s4">1</span><span class="s1">)</span>


<span class="s0">typedef enum </span><span class="s1">{</span>
        <span class="s1">NPY_SEARCHLEFT=</span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">NPY_SEARCHRIGHT=</span><span class="s4">1</span>
<span class="s1">} NPY_SEARCHSIDE;</span>
<span class="s0">#define </span><span class="s1">NPY_NSEARCHSIDES (NPY_SEARCHRIGHT + </span><span class="s4">1</span><span class="s1">)</span>


<span class="s0">typedef enum </span><span class="s1">{</span>
        <span class="s1">NPY_NOSCALAR=-</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">NPY_BOOL_SCALAR,</span>
        <span class="s1">NPY_INTPOS_SCALAR,</span>
        <span class="s1">NPY_INTNEG_SCALAR,</span>
        <span class="s1">NPY_FLOAT_SCALAR,</span>
        <span class="s1">NPY_COMPLEX_SCALAR,</span>
        <span class="s1">NPY_OBJECT_SCALAR</span>
<span class="s1">} NPY_SCALARKIND;</span>
<span class="s0">#define </span><span class="s1">NPY_NSCALARKINDS (NPY_OBJECT_SCALAR + </span><span class="s4">1</span><span class="s1">)</span>

<span class="s3">/* For specifying array memory layout or iteration order */</span>
<span class="s0">typedef enum </span><span class="s1">{</span>
        <span class="s3">/* Fortran order if inputs are all Fortran, C otherwise */</span>
        <span class="s1">NPY_ANYORDER=-</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s3">/* C order */</span>
        <span class="s1">NPY_CORDER=</span><span class="s4">0</span><span class="s1">,</span>
        <span class="s3">/* Fortran order */</span>
        <span class="s1">NPY_FORTRANORDER=</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s3">/* An order as close to the inputs as possible */</span>
        <span class="s1">NPY_KEEPORDER=</span><span class="s4">2</span>
<span class="s1">} NPY_ORDER;</span>

<span class="s3">/* For specifying allowed casting in operations which support it */</span>
<span class="s0">typedef enum </span><span class="s1">{</span>
        <span class="s1">_NPY_ERROR_OCCURRED_IN_CAST = -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s3">/* Only allow identical types */</span>
        <span class="s1">NPY_NO_CASTING=</span><span class="s4">0</span><span class="s1">,</span>
        <span class="s3">/* Allow identical and byte swapped types */</span>
        <span class="s1">NPY_EQUIV_CASTING=</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s3">/* Only allow safe casts */</span>
        <span class="s1">NPY_SAFE_CASTING=</span><span class="s4">2</span><span class="s1">,</span>
        <span class="s3">/* Allow safe casts or casts within the same kind */</span>
        <span class="s1">NPY_SAME_KIND_CASTING=</span><span class="s4">3</span><span class="s1">,</span>
        <span class="s3">/* Allow any casts */</span>
        <span class="s1">NPY_UNSAFE_CASTING=</span><span class="s4">4</span><span class="s1">,</span>
        <span class="s3">/* 
         * Flag to allow signalling that a cast is a view, this flag is not 
         * valid when requesting a cast of specific safety. 
         * _NPY_CAST_IS_VIEW|NPY_EQUIV_CASTING means the same as NPY_NO_CASTING. 
         */</span>
        <span class="s3">// TODO-DTYPES: Needs to be documented.</span>
        <span class="s1">_NPY_CAST_IS_VIEW = </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">16</span><span class="s1">,</span>
<span class="s1">} NPY_CASTING;</span>

<span class="s0">typedef enum </span><span class="s1">{</span>
        <span class="s1">NPY_CLIP=</span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">NPY_WRAP=</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">NPY_RAISE=</span><span class="s4">2</span>
<span class="s1">} NPY_CLIPMODE;</span>

<span class="s0">typedef enum </span><span class="s1">{</span>
        <span class="s1">NPY_VALID=</span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">NPY_SAME=</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">NPY_FULL=</span><span class="s4">2</span>
<span class="s1">} NPY_CORRELATEMODE;</span>

<span class="s3">/* The special not-a-time (NaT) value */</span>
<span class="s0">#define </span><span class="s1">NPY_DATETIME_NAT NPY_MIN_INT64</span>

<span class="s3">/* 
 * Upper bound on the length of a DATETIME ISO 8601 string 
 *   YEAR: 21 (64-bit year) 
 *   MONTH: 3 
 *   DAY: 3 
 *   HOURS: 3 
 *   MINUTES: 3 
 *   SECONDS: 3 
 *   ATTOSECONDS: 1 + 3*6 
 *   TIMEZONE: 5 
 *   NULL TERMINATOR: 1 
 */</span>
<span class="s0">#define </span><span class="s1">NPY_DATETIME_MAX_ISO8601_STRLEN (</span><span class="s4">21 </span><span class="s1">+ </span><span class="s4">3</span><span class="s1">*</span><span class="s4">5 </span><span class="s1">+ </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">3</span><span class="s1">*</span><span class="s4">6 </span><span class="s1">+ </span><span class="s4">6 </span><span class="s1">+ </span><span class="s4">1</span><span class="s1">)</span>

<span class="s3">/* The FR in the unit names stands for frequency */</span>
<span class="s0">typedef enum </span><span class="s1">{</span>
        <span class="s3">/* Force signed enum type, must be -1 for code compatibility */</span>
        <span class="s1">NPY_FR_ERROR = -</span><span class="s4">1</span><span class="s1">,      </span><span class="s3">/* error or undetermined */</span>

        <span class="s3">/* Start of valid units */</span>
        <span class="s1">NPY_FR_Y = </span><span class="s4">0</span><span class="s1">,           </span><span class="s3">/* Years */</span>
        <span class="s1">NPY_FR_M = </span><span class="s4">1</span><span class="s1">,           </span><span class="s3">/* Months */</span>
        <span class="s1">NPY_FR_W = </span><span class="s4">2</span><span class="s1">,           </span><span class="s3">/* Weeks */</span>
        <span class="s3">/* Gap where 1.6 NPY_FR_B (value 3) was */</span>
        <span class="s1">NPY_FR_D = </span><span class="s4">4</span><span class="s1">,           </span><span class="s3">/* Days */</span>
        <span class="s1">NPY_FR_h = </span><span class="s4">5</span><span class="s1">,           </span><span class="s3">/* hours */</span>
        <span class="s1">NPY_FR_m = </span><span class="s4">6</span><span class="s1">,           </span><span class="s3">/* minutes */</span>
        <span class="s1">NPY_FR_s = </span><span class="s4">7</span><span class="s1">,           </span><span class="s3">/* seconds */</span>
        <span class="s1">NPY_FR_ms = </span><span class="s4">8</span><span class="s1">,          </span><span class="s3">/* milliseconds */</span>
        <span class="s1">NPY_FR_us = </span><span class="s4">9</span><span class="s1">,          </span><span class="s3">/* microseconds */</span>
        <span class="s1">NPY_FR_ns = </span><span class="s4">10</span><span class="s1">,         </span><span class="s3">/* nanoseconds */</span>
        <span class="s1">NPY_FR_ps = </span><span class="s4">11</span><span class="s1">,         </span><span class="s3">/* picoseconds */</span>
        <span class="s1">NPY_FR_fs = </span><span class="s4">12</span><span class="s1">,         </span><span class="s3">/* femtoseconds */</span>
        <span class="s1">NPY_FR_as = </span><span class="s4">13</span><span class="s1">,         </span><span class="s3">/* attoseconds */</span>
        <span class="s1">NPY_FR_GENERIC = </span><span class="s4">14     </span><span class="s3">/* unbound units, can convert to anything */</span>
<span class="s1">} NPY_DATETIMEUNIT;</span>

<span class="s3">/* 
 * NOTE: With the NPY_FR_B gap for 1.6 ABI compatibility, NPY_DATETIME_NUMUNITS 
 * is technically one more than the actual number of units. 
 */</span>
<span class="s0">#define </span><span class="s1">NPY_DATETIME_NUMUNITS (NPY_FR_GENERIC + </span><span class="s4">1</span><span class="s1">)</span>
<span class="s0">#define </span><span class="s1">NPY_DATETIME_DEFAULTUNIT NPY_FR_GENERIC</span>

<span class="s3">/* 
 * Business day conventions for mapping invalid business 
 * days to valid business days. 
 */</span>
<span class="s0">typedef enum </span><span class="s1">{</span>
    <span class="s3">/* Go forward in time to the following business day. */</span>
    <span class="s1">NPY_BUSDAY_FORWARD,</span>
    <span class="s1">NPY_BUSDAY_FOLLOWING = NPY_BUSDAY_FORWARD,</span>
    <span class="s3">/* Go backward in time to the preceding business day. */</span>
    <span class="s1">NPY_BUSDAY_BACKWARD,</span>
    <span class="s1">NPY_BUSDAY_PRECEDING = NPY_BUSDAY_BACKWARD,</span>
    <span class="s3">/* 
     * Go forward in time to the following business day, unless it 
     * crosses a month boundary, in which case go backward 
     */</span>
    <span class="s1">NPY_BUSDAY_MODIFIEDFOLLOWING,</span>
    <span class="s3">/* 
     * Go backward in time to the preceding business day, unless it 
     * crosses a month boundary, in which case go forward. 
     */</span>
    <span class="s1">NPY_BUSDAY_MODIFIEDPRECEDING,</span>
    <span class="s3">/* Produce a NaT for non-business days. */</span>
    <span class="s1">NPY_BUSDAY_NAT,</span>
    <span class="s3">/* Raise an exception for non-business days. */</span>
    <span class="s1">NPY_BUSDAY_RAISE</span>
<span class="s1">} NPY_BUSDAY_ROLL;</span>

<span class="s3">/************************************************************ 
 * NumPy Auxiliary Data for inner loops, sort functions, etc. 
 ************************************************************/</span>

<span class="s3">/* 
 * When creating an auxiliary data struct, this should always appear 
 * as the first member, like this: 
 * 
 * typedef struct { 
 *     NpyAuxData base; 
 *     double constant; 
 * } constant_multiplier_aux_data; 
 */</span>
<span class="s0">typedef struct </span><span class="s1">NpyAuxData_tag NpyAuxData;</span>

<span class="s3">/* Function pointers for freeing or cloning auxiliary data */</span>
<span class="s0">typedef void </span><span class="s1">(NpyAuxData_FreeFunc) (NpyAuxData *);</span>
<span class="s0">typedef </span><span class="s1">NpyAuxData *(NpyAuxData_CloneFunc) (NpyAuxData *);</span>

<span class="s0">struct </span><span class="s1">NpyAuxData_tag {</span>
    <span class="s1">NpyAuxData_FreeFunc *free;</span>
    <span class="s1">NpyAuxData_CloneFunc *clone;</span>
    <span class="s3">/* To allow for a bit of expansion without breaking the ABI */</span>
    <span class="s0">void </span><span class="s1">*reserved[</span><span class="s4">2</span><span class="s1">];</span>
<span class="s1">};</span>

<span class="s3">/* Macros to use for freeing and cloning auxiliary data */</span>
<span class="s0">#define </span><span class="s1">NPY_AUXDATA_FREE(auxdata) \</span>
    <span class="s0">do </span><span class="s1">{ \</span>
        <span class="s0">if </span><span class="s1">((auxdata) != NULL) { \</span>
            <span class="s1">(auxdata)</span><span class="s5">-&gt;</span><span class="s1">free(auxdata); \</span>
        <span class="s1">} \</span>
    <span class="s1">} </span><span class="s0">while</span><span class="s1">(</span><span class="s4">0</span><span class="s1">)</span>
<span class="s0">#define </span><span class="s1">NPY_AUXDATA_CLONE(auxdata) \</span>
    <span class="s1">((auxdata)</span><span class="s5">-&gt;</span><span class="s1">clone(auxdata))</span>

<span class="s0">#define </span><span class="s1">NPY_ERR(str) fprintf(stderr, #str); fflush(stderr);</span>
<span class="s0">#define </span><span class="s1">NPY_ERR2(str) fprintf(stderr, str); fflush(stderr);</span>

<span class="s3">/* 
* Macros to define how array, and dimension/strides data is 
* allocated. These should be made private 
*/</span>

<span class="s0">#define </span><span class="s1">NPY_USE_PYMEM </span><span class="s4">1</span>


<span class="s0">#if </span><span class="s1">NPY_USE_PYMEM == </span><span class="s4">1</span>
<span class="s3">/* use the Raw versions which are safe to call with the GIL released */</span>
<span class="s0">#define </span><span class="s1">PyArray_malloc PyMem_RawMalloc</span>
<span class="s0">#define </span><span class="s1">PyArray_free PyMem_RawFree</span>
<span class="s0">#define </span><span class="s1">PyArray_realloc PyMem_RawRealloc</span>
<span class="s0">#else</span>
<span class="s0">#define </span><span class="s1">PyArray_malloc malloc</span>
<span class="s0">#define </span><span class="s1">PyArray_free free</span>
<span class="s0">#define </span><span class="s1">PyArray_realloc realloc</span>
<span class="s0">#endif</span>

<span class="s3">/* Dimensions and strides */</span>
<span class="s0">#define </span><span class="s1">PyDimMem_NEW(size)                                         \</span>
    <span class="s1">((npy_intp *)PyArray_malloc(size*</span><span class="s0">sizeof</span><span class="s1">(npy_intp)))</span>

<span class="s0">#define </span><span class="s1">PyDimMem_FREE(ptr) PyArray_free(ptr)</span>

<span class="s0">#define </span><span class="s1">PyDimMem_RENEW(ptr,size)                                   \</span>
        <span class="s1">((npy_intp *)PyArray_realloc(ptr,size*</span><span class="s0">sizeof</span><span class="s1">(npy_intp)))</span>

<span class="s3">/* forward declaration */</span>
<span class="s0">struct </span><span class="s1">_PyArray_Descr;</span>

<span class="s3">/* These must deal with unaligned and swapped data if necessary */</span>
<span class="s0">typedef </span><span class="s1">PyObject * (PyArray_GetItemFunc) (</span><span class="s0">void </span><span class="s1">*, </span><span class="s0">void </span><span class="s1">*);</span>
<span class="s0">typedef int </span><span class="s1">(PyArray_SetItemFunc)(PyObject *, </span><span class="s0">void </span><span class="s1">*, </span><span class="s0">void </span><span class="s1">*);</span>

<span class="s0">typedef void </span><span class="s1">(PyArray_CopySwapNFunc)(</span><span class="s0">void </span><span class="s1">*, npy_intp, </span><span class="s0">void </span><span class="s1">*, npy_intp,</span>
                                     <span class="s1">npy_intp, </span><span class="s0">int</span><span class="s1">, </span><span class="s0">void </span><span class="s1">*);</span>

<span class="s0">typedef void </span><span class="s1">(PyArray_CopySwapFunc)(</span><span class="s0">void </span><span class="s1">*, </span><span class="s0">void </span><span class="s1">*, </span><span class="s0">int</span><span class="s1">, </span><span class="s0">void </span><span class="s1">*);</span>
<span class="s0">typedef </span><span class="s1">npy_bool (PyArray_NonzeroFunc)(</span><span class="s0">void </span><span class="s1">*, </span><span class="s0">void </span><span class="s1">*);</span>


<span class="s3">/* 
 * These assume aligned and notswapped data -- a buffer will be used 
 * before or contiguous data will be obtained 
 */</span>

<span class="s0">typedef int </span><span class="s1">(PyArray_CompareFunc)(</span><span class="s0">const void </span><span class="s1">*, </span><span class="s0">const void </span><span class="s1">*, </span><span class="s0">void </span><span class="s1">*);</span>
<span class="s0">typedef int </span><span class="s1">(PyArray_ArgFunc)(</span><span class="s0">void</span><span class="s1">*, npy_intp, npy_intp*, </span><span class="s0">void </span><span class="s1">*);</span>

<span class="s0">typedef void </span><span class="s1">(PyArray_DotFunc)(</span><span class="s0">void </span><span class="s1">*, npy_intp, </span><span class="s0">void </span><span class="s1">*, npy_intp, </span><span class="s0">void </span><span class="s1">*,</span>
                               <span class="s1">npy_intp, </span><span class="s0">void </span><span class="s1">*);</span>

<span class="s0">typedef void </span><span class="s1">(PyArray_VectorUnaryFunc)(</span><span class="s0">void </span><span class="s1">*, </span><span class="s0">void </span><span class="s1">*, npy_intp, </span><span class="s0">void </span><span class="s1">*,</span>
                                       <span class="s0">void </span><span class="s1">*);</span>

<span class="s3">/* 
 * XXX the ignore argument should be removed next time the API version 
 * is bumped. It used to be the separator. 
 */</span>
<span class="s0">typedef int </span><span class="s1">(PyArray_ScanFunc)(FILE *fp, </span><span class="s0">void </span><span class="s1">*dptr,</span>
                               <span class="s0">char </span><span class="s1">*ignore, </span><span class="s0">struct </span><span class="s1">_PyArray_Descr *);</span>
<span class="s0">typedef int </span><span class="s1">(PyArray_FromStrFunc)(</span><span class="s0">char </span><span class="s1">*s, </span><span class="s0">void </span><span class="s1">*dptr, </span><span class="s0">char </span><span class="s1">**endptr,</span>
                                  <span class="s0">struct </span><span class="s1">_PyArray_Descr *);</span>

<span class="s0">typedef int </span><span class="s1">(PyArray_FillFunc)(</span><span class="s0">void </span><span class="s1">*, npy_intp, </span><span class="s0">void </span><span class="s1">*);</span>

<span class="s0">typedef int </span><span class="s1">(PyArray_SortFunc)(</span><span class="s0">void </span><span class="s1">*, npy_intp, </span><span class="s0">void </span><span class="s1">*);</span>
<span class="s0">typedef int </span><span class="s1">(PyArray_ArgSortFunc)(</span><span class="s0">void </span><span class="s1">*, npy_intp *, npy_intp, </span><span class="s0">void </span><span class="s1">*);</span>
<span class="s0">typedef int </span><span class="s1">(PyArray_PartitionFunc)(</span><span class="s0">void </span><span class="s1">*, npy_intp, npy_intp,</span>
                                    <span class="s1">npy_intp *, npy_intp *,</span>
                                    <span class="s0">void </span><span class="s1">*);</span>
<span class="s0">typedef int </span><span class="s1">(PyArray_ArgPartitionFunc)(</span><span class="s0">void </span><span class="s1">*, npy_intp *, npy_intp, npy_intp,</span>
                                       <span class="s1">npy_intp *, npy_intp *,</span>
                                       <span class="s0">void </span><span class="s1">*);</span>

<span class="s0">typedef int </span><span class="s1">(PyArray_FillWithScalarFunc)(</span><span class="s0">void </span><span class="s1">*, npy_intp, </span><span class="s0">void </span><span class="s1">*, </span><span class="s0">void </span><span class="s1">*);</span>

<span class="s0">typedef int </span><span class="s1">(PyArray_ScalarKindFunc)(</span><span class="s0">void </span><span class="s1">*);</span>

<span class="s0">typedef void </span><span class="s1">(PyArray_FastClipFunc)(</span><span class="s0">void </span><span class="s1">*in, npy_intp n_in, </span><span class="s0">void </span><span class="s1">*min,</span>
                                    <span class="s0">void </span><span class="s1">*max, </span><span class="s0">void </span><span class="s1">*out);</span>
<span class="s0">typedef void </span><span class="s1">(PyArray_FastPutmaskFunc)(</span><span class="s0">void </span><span class="s1">*in, </span><span class="s0">void </span><span class="s1">*mask, npy_intp n_in,</span>
                                       <span class="s0">void </span><span class="s1">*values, npy_intp nv);</span>
<span class="s0">typedef int  </span><span class="s1">(PyArray_FastTakeFunc)(</span><span class="s0">void </span><span class="s1">*dest, </span><span class="s0">void </span><span class="s1">*src, npy_intp *indarray,</span>
                                       <span class="s1">npy_intp nindarray, npy_intp n_outer,</span>
                                       <span class="s1">npy_intp m_middle, npy_intp nelem,</span>
                                       <span class="s1">NPY_CLIPMODE clipmode);</span>

<span class="s0">typedef struct </span><span class="s1">{</span>
        <span class="s1">npy_intp *ptr;</span>
        <span class="s0">int </span><span class="s1">len;</span>
<span class="s1">} PyArray_Dims;</span>

<span class="s0">typedef struct </span><span class="s1">{</span>
        <span class="s3">/* 
         * Functions to cast to most other standard types 
         * Can have some NULL entries. The types 
         * DATETIME, TIMEDELTA, and HALF go into the castdict 
         * even though they are built-in. 
         */</span>
        <span class="s1">PyArray_VectorUnaryFunc *cast[NPY_NTYPES_ABI_COMPATIBLE];</span>

        <span class="s3">/* The next four functions *cannot* be NULL */</span>

        <span class="s3">/* 
         * Functions to get and set items with standard Python types 
         * -- not array scalars 
         */</span>
        <span class="s1">PyArray_GetItemFunc *getitem;</span>
        <span class="s1">PyArray_SetItemFunc *setitem;</span>

        <span class="s3">/* 
         * Copy and/or swap data.  Memory areas may not overlap 
         * Use memmove first if they might 
         */</span>
        <span class="s1">PyArray_CopySwapNFunc *copyswapn;</span>
        <span class="s1">PyArray_CopySwapFunc *copyswap;</span>

        <span class="s3">/* 
         * Function to compare items 
         * Can be NULL 
         */</span>
        <span class="s1">PyArray_CompareFunc *compare;</span>

        <span class="s3">/* 
         * Function to select largest 
         * Can be NULL 
         */</span>
        <span class="s1">PyArray_ArgFunc *argmax;</span>

        <span class="s3">/* 
         * Function to compute dot product 
         * Can be NULL 
         */</span>
        <span class="s1">PyArray_DotFunc *dotfunc;</span>

        <span class="s3">/* 
         * Function to scan an ASCII file and 
         * place a single value plus possible separator 
         * Can be NULL 
         */</span>
        <span class="s1">PyArray_ScanFunc *scanfunc;</span>

        <span class="s3">/* 
         * Function to read a single value from a string 
         * and adjust the pointer; Can be NULL 
         */</span>
        <span class="s1">PyArray_FromStrFunc *fromstr;</span>

        <span class="s3">/* 
         * Function to determine if data is zero or not 
         * If NULL a default version is 
         * used at Registration time. 
         */</span>
        <span class="s1">PyArray_NonzeroFunc *nonzero;</span>

        <span class="s3">/* 
         * Used for arange. Should return 0 on success 
         * and -1 on failure. 
         * Can be NULL. 
         */</span>
        <span class="s1">PyArray_FillFunc *fill;</span>

        <span class="s3">/* 
         * Function to fill arrays with scalar values 
         * Can be NULL 
         */</span>
        <span class="s1">PyArray_FillWithScalarFunc *fillwithscalar;</span>

        <span class="s3">/* 
         * Sorting functions 
         * Can be NULL 
         */</span>
        <span class="s1">PyArray_SortFunc *sort[NPY_NSORTS];</span>
        <span class="s1">PyArray_ArgSortFunc *argsort[NPY_NSORTS];</span>

        <span class="s3">/* 
         * Dictionary of additional casting functions 
         * PyArray_VectorUnaryFuncs 
         * which can be populated to support casting 
         * to other registered types. Can be NULL 
         */</span>
        <span class="s1">PyObject *castdict;</span>

        <span class="s3">/* 
         * Functions useful for generalizing 
         * the casting rules. 
         * Can be NULL; 
         */</span>
        <span class="s1">PyArray_ScalarKindFunc *scalarkind;</span>
        <span class="s0">int </span><span class="s1">**cancastscalarkindto;</span>
        <span class="s0">int </span><span class="s1">*cancastto;</span>

        <span class="s1">PyArray_FastClipFunc *fastclip;</span>
        <span class="s1">PyArray_FastPutmaskFunc *fastputmask;</span>
        <span class="s1">PyArray_FastTakeFunc *fasttake;</span>

        <span class="s3">/* 
         * Function to select smallest 
         * Can be NULL 
         */</span>
        <span class="s1">PyArray_ArgFunc *argmin;</span>

<span class="s1">} PyArray_ArrFuncs;</span>

<span class="s3">/* The item must be reference counted when it is inserted or extracted. */</span>
<span class="s0">#define </span><span class="s1">NPY_ITEM_REFCOUNT   </span><span class="s4">0x01</span>
<span class="s3">/* Same as needing REFCOUNT */</span>
<span class="s0">#define </span><span class="s1">NPY_ITEM_HASOBJECT  </span><span class="s4">0x01</span>
<span class="s3">/* Convert to list for pickling */</span>
<span class="s0">#define </span><span class="s1">NPY_LIST_PICKLE     </span><span class="s4">0x02</span>
<span class="s3">/* The item is a POINTER  */</span>
<span class="s0">#define </span><span class="s1">NPY_ITEM_IS_POINTER </span><span class="s4">0x04</span>
<span class="s3">/* memory needs to be initialized for this data-type */</span>
<span class="s0">#define </span><span class="s1">NPY_NEEDS_INIT      </span><span class="s4">0x08</span>
<span class="s3">/* operations need Python C-API so don't give-up thread. */</span>
<span class="s0">#define </span><span class="s1">NPY_NEEDS_PYAPI     </span><span class="s4">0x10</span>
<span class="s3">/* Use f.getitem when extracting elements of this data-type */</span>
<span class="s0">#define </span><span class="s1">NPY_USE_GETITEM     </span><span class="s4">0x20</span>
<span class="s3">/* Use f.setitem when setting creating 0-d array from this data-type.*/</span>
<span class="s0">#define </span><span class="s1">NPY_USE_SETITEM     </span><span class="s4">0x40</span>
<span class="s3">/* A sticky flag specifically for structured arrays */</span>
<span class="s0">#define </span><span class="s1">NPY_ALIGNED_STRUCT  </span><span class="s4">0x80</span>

<span class="s3">/* 
 *These are inherited for global data-type if any data-types in the 
 * field have them 
 */</span>
<span class="s0">#define </span><span class="s1">NPY_FROM_FIELDS    (NPY_NEEDS_INIT | NPY_LIST_PICKLE | \</span>
                            <span class="s1">NPY_ITEM_REFCOUNT | NPY_NEEDS_PYAPI)</span>

<span class="s0">#define </span><span class="s1">NPY_OBJECT_DTYPE_FLAGS (NPY_LIST_PICKLE | NPY_USE_GETITEM | \</span>
                                <span class="s1">NPY_ITEM_IS_POINTER | NPY_ITEM_REFCOUNT | \</span>
                                <span class="s1">NPY_NEEDS_INIT | NPY_NEEDS_PYAPI)</span>

<span class="s0">#define </span><span class="s1">PyDataType_FLAGCHK(dtype, flag) \</span>
        <span class="s1">(((dtype)</span><span class="s5">-&gt;</span><span class="s1">flags &amp; (flag)) == (flag))</span>

<span class="s0">#define </span><span class="s1">PyDataType_REFCHK(dtype) \</span>
        <span class="s1">PyDataType_FLAGCHK(dtype, NPY_ITEM_REFCOUNT)</span>

<span class="s0">typedef struct </span><span class="s1">_PyArray_Descr {</span>
        <span class="s1">PyObject_HEAD</span>
        <span class="s3">/* 
         * the type object representing an 
         * instance of this type -- should not 
         * be two type_numbers with the same type 
         * object. 
         */</span>
        <span class="s1">PyTypeObject *typeobj;</span>
        <span class="s3">/* kind for this type */</span>
        <span class="s0">char </span><span class="s1">kind;</span>
        <span class="s3">/* unique-character representing this type */</span>
        <span class="s0">char </span><span class="s1">type;</span>
        <span class="s3">/* 
         * '&gt;' (big), '&lt;' (little), '|' 
         * (not-applicable), or '=' (native). 
         */</span>
        <span class="s0">char </span><span class="s1">byteorder;</span>
        <span class="s3">/* flags describing data type */</span>
        <span class="s0">char </span><span class="s1">flags;</span>
        <span class="s3">/* number representing this type */</span>
        <span class="s0">int </span><span class="s1">type_num;</span>
        <span class="s3">/* element size (itemsize) for this type */</span>
        <span class="s0">int </span><span class="s1">elsize;</span>
        <span class="s3">/* alignment needed for this type */</span>
        <span class="s0">int </span><span class="s1">alignment;</span>
        <span class="s3">/* 
         * Non-NULL if this type is 
         * is an array (C-contiguous) 
         * of some other type 
         */</span>
        <span class="s0">struct </span><span class="s1">_arr_descr *subarray;</span>
        <span class="s3">/* 
         * The fields dictionary for this type 
         * For statically defined descr this 
         * is always Py_None 
         */</span>
        <span class="s1">PyObject *fields;</span>
        <span class="s3">/* 
         * An ordered tuple of field names or NULL 
         * if no fields are defined 
         */</span>
        <span class="s1">PyObject *names;</span>
        <span class="s3">/* 
         * a table of functions specific for each 
         * basic data descriptor 
         */</span>
        <span class="s1">PyArray_ArrFuncs *f;</span>
        <span class="s3">/* Metadata about this dtype */</span>
        <span class="s1">PyObject *metadata;</span>
        <span class="s3">/* 
         * Metadata specific to the C implementation 
         * of the particular dtype. This was added 
         * for NumPy 1.7.0. 
         */</span>
        <span class="s1">NpyAuxData *c_metadata;</span>
        <span class="s3">/* Cached hash value (-1 if not yet computed). 
         * This was added for NumPy 2.0.0. 
         */</span>
        <span class="s1">npy_hash_t hash;</span>
<span class="s1">} PyArray_Descr;</span>

<span class="s0">typedef struct </span><span class="s1">_arr_descr {</span>
        <span class="s1">PyArray_Descr *base;</span>
        <span class="s1">PyObject *shape;       </span><span class="s3">/* a tuple */</span>
<span class="s1">} PyArray_ArrayDescr;</span>

<span class="s3">/* 
 * Memory handler structure for array data. 
 */</span>
<span class="s3">/* The declaration of free differs from PyMemAllocatorEx */</span>
<span class="s0">typedef struct </span><span class="s1">{</span>
    <span class="s0">void </span><span class="s1">*ctx;</span>
    <span class="s0">void</span><span class="s1">* (*malloc) (</span><span class="s0">void </span><span class="s1">*ctx, size_t size);</span>
    <span class="s0">void</span><span class="s1">* (*calloc) (</span><span class="s0">void </span><span class="s1">*ctx, size_t nelem, size_t elsize);</span>
    <span class="s0">void</span><span class="s1">* (*realloc) (</span><span class="s0">void </span><span class="s1">*ctx, </span><span class="s0">void </span><span class="s1">*ptr, size_t new_size);</span>
    <span class="s0">void </span><span class="s1">(*free) (</span><span class="s0">void </span><span class="s1">*ctx, </span><span class="s0">void </span><span class="s1">*ptr, size_t size);</span>
    <span class="s3">/* 
     * This is the end of the version=1 struct. Only add new fields after 
     * this line 
     */</span>
<span class="s1">} PyDataMemAllocator;</span>

<span class="s0">typedef struct </span><span class="s1">{</span>
    <span class="s0">char </span><span class="s1">name[</span><span class="s4">127</span><span class="s1">];  </span><span class="s3">/* multiple of 64 to keep the struct aligned */</span>
    <span class="s1">uint8_t version; </span><span class="s3">/* currently 1 */</span>
    <span class="s1">PyDataMemAllocator allocator;</span>
<span class="s1">} PyDataMem_Handler;</span>


<span class="s3">/* 
 * The main array object structure. 
 * 
 * It has been recommended to use the inline functions defined below 
 * (PyArray_DATA and friends) to access fields here for a number of 
 * releases. Direct access to the members themselves is deprecated. 
 * To ensure that your code does not use deprecated access, 
 * #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION 
 * (or NPY_1_8_API_VERSION or higher as required). 
 */</span>
<span class="s3">/* This struct will be moved to a private header in a future release */</span>
<span class="s0">typedef struct </span><span class="s1">tagPyArrayObject_fields {</span>
    <span class="s1">PyObject_HEAD</span>
    <span class="s3">/* Pointer to the raw data buffer */</span>
    <span class="s0">char </span><span class="s1">*data;</span>
    <span class="s3">/* The number of dimensions, also called 'ndim' */</span>
    <span class="s0">int </span><span class="s1">nd;</span>
    <span class="s3">/* The size in each dimension, also called 'shape' */</span>
    <span class="s1">npy_intp *dimensions;</span>
    <span class="s3">/* 
     * Number of bytes to jump to get to the 
     * next element in each dimension 
     */</span>
    <span class="s1">npy_intp *strides;</span>
    <span class="s3">/* 
     * This object is decref'd upon 
     * deletion of array. Except in the 
     * case of WRITEBACKIFCOPY which has 
     * special handling. 
     * 
     * For views it points to the original 
     * array, collapsed so no chains of 
     * views occur. 
     * 
     * For creation from buffer object it 
     * points to an object that should be 
     * decref'd on deletion 
     * 
     * For WRITEBACKIFCOPY flag this is an 
     * array to-be-updated upon calling 
     * PyArray_ResolveWritebackIfCopy 
     */</span>
    <span class="s1">PyObject *base;</span>
    <span class="s3">/* Pointer to type structure */</span>
    <span class="s1">PyArray_Descr *descr;</span>
    <span class="s3">/* Flags describing array -- see below */</span>
    <span class="s0">int </span><span class="s1">flags;</span>
    <span class="s3">/* For weak references */</span>
    <span class="s1">PyObject *weakreflist;</span>
    <span class="s0">void </span><span class="s1">*_buffer_info;  </span><span class="s3">/* private buffer info, tagged to allow warning */</span>
    <span class="s3">/* 
     * For malloc/calloc/realloc/free per object 
     */</span>
    <span class="s1">PyObject *mem_handler;</span>
<span class="s1">} PyArrayObject_fields;</span>

<span class="s3">/* 
 * To hide the implementation details, we only expose 
 * the Python struct HEAD. 
 */</span>
<span class="s0">#if </span><span class="s1">!defined(NPY_NO_DEPRECATED_API) || \</span>
    <span class="s1">(NPY_NO_DEPRECATED_API &lt; NPY_1_7_API_VERSION)</span>
<span class="s3">/* 
 * Can't put this in npy_deprecated_api.h like the others. 
 * PyArrayObject field access is deprecated as of NumPy 1.7. 
 */</span>
<span class="s0">typedef </span><span class="s1">PyArrayObject_fields PyArrayObject;</span>
<span class="s0">#else</span>
<span class="s0">typedef struct </span><span class="s1">tagPyArrayObject {</span>
        <span class="s1">PyObject_HEAD</span>
<span class="s1">} PyArrayObject;</span>
<span class="s0">#endif</span>

<span class="s3">/* 
 * Removed 2020-Nov-25, NumPy 1.20 
 * #define NPY_SIZEOF_PYARRAYOBJECT (sizeof(PyArrayObject_fields)) 
 * 
 * The above macro was removed as it gave a false sense of a stable ABI 
 * with respect to the structures size.  If you require a runtime constant, 
 * you can use `PyArray_Type.tp_basicsize` instead.  Otherwise, please 
 * see the PyArrayObject documentation or ask the NumPy developers for 
 * information on how to correctly replace the macro in a way that is 
 * compatible with multiple NumPy versions. 
 */</span>


<span class="s3">/* Array Flags Object */</span>
<span class="s0">typedef struct </span><span class="s1">PyArrayFlagsObject {</span>
        <span class="s1">PyObject_HEAD</span>
        <span class="s1">PyObject *arr;</span>
        <span class="s0">int </span><span class="s1">flags;</span>
<span class="s1">} PyArrayFlagsObject;</span>

<span class="s3">/* Mirrors buffer object to ptr */</span>

<span class="s0">typedef struct </span><span class="s1">{</span>
        <span class="s1">PyObject_HEAD</span>
        <span class="s1">PyObject *base;</span>
        <span class="s0">void </span><span class="s1">*ptr;</span>
        <span class="s1">npy_intp len;</span>
        <span class="s0">int </span><span class="s1">flags;</span>
<span class="s1">} PyArray_Chunk;</span>

<span class="s0">typedef struct </span><span class="s1">{</span>
    <span class="s1">NPY_DATETIMEUNIT base;</span>
    <span class="s0">int </span><span class="s1">num;</span>
<span class="s1">} PyArray_DatetimeMetaData;</span>

<span class="s0">typedef struct </span><span class="s1">{</span>
    <span class="s1">NpyAuxData base;</span>
    <span class="s1">PyArray_DatetimeMetaData meta;</span>
<span class="s1">} PyArray_DatetimeDTypeMetaData;</span>

<span class="s3">/* 
 * This structure contains an exploded view of a date-time value. 
 * NaT is represented by year == NPY_DATETIME_NAT. 
 */</span>
<span class="s0">typedef struct </span><span class="s1">{</span>
        <span class="s1">npy_int64 year;</span>
        <span class="s1">npy_int32 month, day, hour, min, sec, us, ps, as;</span>
<span class="s1">} npy_datetimestruct;</span>

<span class="s3">/* This is not used internally. */</span>
<span class="s0">typedef struct </span><span class="s1">{</span>
        <span class="s1">npy_int64 day;</span>
        <span class="s1">npy_int32 sec, us, ps, as;</span>
<span class="s1">} npy_timedeltastruct;</span>

<span class="s0">typedef int </span><span class="s1">(PyArray_FinalizeFunc)(PyArrayObject *, PyObject *);</span>

<span class="s3">/* 
 * Means c-style contiguous (last index varies the fastest). The data 
 * elements right after each other. 
 * 
 * This flag may be requested in constructor functions. 
 * This flag may be tested for in PyArray_FLAGS(arr). 
 */</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_C_CONTIGUOUS    </span><span class="s4">0x0001</span>

<span class="s3">/* 
 * Set if array is a contiguous Fortran array: the first index varies 
 * the fastest in memory (strides array is reverse of C-contiguous 
 * array) 
 * 
 * This flag may be requested in constructor functions. 
 * This flag may be tested for in PyArray_FLAGS(arr). 
 */</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_F_CONTIGUOUS    </span><span class="s4">0x0002</span>

<span class="s3">/* 
 * Note: all 0-d arrays are C_CONTIGUOUS and F_CONTIGUOUS. If a 
 * 1-d array is C_CONTIGUOUS it is also F_CONTIGUOUS. Arrays with 
 * more then one dimension can be C_CONTIGUOUS and F_CONTIGUOUS 
 * at the same time if they have either zero or one element. 
 * If NPY_RELAXED_STRIDES_CHECKING is set, a higher dimensional 
 * array is always C_CONTIGUOUS and F_CONTIGUOUS if it has zero elements 
 * and the array is contiguous if ndarray.squeeze() is contiguous. 
 * I.e. dimensions for which `ndarray.shape[dimension] == 1` are 
 * ignored. 
 */</span>

<span class="s3">/* 
 * If set, the array owns the data: it will be free'd when the array 
 * is deleted. 
 * 
 * This flag may be tested for in PyArray_FLAGS(arr). 
 */</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_OWNDATA         </span><span class="s4">0x0004</span>

<span class="s3">/* 
 * An array never has the next four set; they're only used as parameter 
 * flags to the various FromAny functions 
 * 
 * This flag may be requested in constructor functions. 
 */</span>

<span class="s3">/* Cause a cast to occur regardless of whether or not it is safe. */</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_FORCECAST       </span><span class="s4">0x0010</span>

<span class="s3">/* 
 * Always copy the array. Returned arrays are always CONTIGUOUS, 
 * ALIGNED, and WRITEABLE. See also: NPY_ARRAY_ENSURENOCOPY = 0x4000. 
 * 
 * This flag may be requested in constructor functions. 
 */</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_ENSURECOPY      </span><span class="s4">0x0020</span>

<span class="s3">/* 
 * Make sure the returned array is a base-class ndarray 
 * 
 * This flag may be requested in constructor functions. 
 */</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_ENSUREARRAY     </span><span class="s4">0x0040</span>

<span class="s0">#if </span><span class="s1">defined(NPY_INTERNAL_BUILD) &amp;&amp; NPY_INTERNAL_BUILD</span>
    <span class="s3">/* 
     * Dual use of the ENSUREARRAY flag, to indicate that this was converted 
     * from a python float, int, or complex. 
     * An array using this flag must be a temporary array that can never 
     * leave the C internals of NumPy.  Even if it does, ENSUREARRAY is 
     * absolutely safe to abuse, since it already is a base class array :). 
     */</span>
    <span class="s0">#define </span><span class="s1">_NPY_ARRAY_WAS_PYSCALAR   </span><span class="s4">0x0040</span>
<span class="s0">#endif  </span><span class="s3">/* NPY_INTERNAL_BUILD */</span>

<span class="s3">/* 
 * Make sure that the strides are in units of the element size Needed 
 * for some operations with record-arrays. 
 * 
 * This flag may be requested in constructor functions. 
 */</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_ELEMENTSTRIDES  </span><span class="s4">0x0080</span>

<span class="s3">/* 
 * Array data is aligned on the appropriate memory address for the type 
 * stored according to how the compiler would align things (e.g., an 
 * array of integers (4 bytes each) starts on a memory address that's 
 * a multiple of 4) 
 * 
 * This flag may be requested in constructor functions. 
 * This flag may be tested for in PyArray_FLAGS(arr). 
 */</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_ALIGNED         </span><span class="s4">0x0100</span>

<span class="s3">/* 
 * Array data has the native endianness 
 * 
 * This flag may be requested in constructor functions. 
 */</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_NOTSWAPPED      </span><span class="s4">0x0200</span>

<span class="s3">/* 
 * Array data is writeable 
 * 
 * This flag may be requested in constructor functions. 
 * This flag may be tested for in PyArray_FLAGS(arr). 
 */</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_WRITEABLE       </span><span class="s4">0x0400</span>

<span class="s3">/* 
 * If this flag is set, then base contains a pointer to an array of 
 * the same size that should be updated with the current contents of 
 * this array when PyArray_ResolveWritebackIfCopy is called. 
 * 
 * This flag may be requested in constructor functions. 
 * This flag may be tested for in PyArray_FLAGS(arr). 
 */</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_UPDATEIFCOPY    </span><span class="s4">0x1000 </span><span class="s3">/* Deprecated in 1.14 */</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_WRITEBACKIFCOPY </span><span class="s4">0x2000</span>

<span class="s3">/* 
 * No copy may be made while converting from an object/array (result is a view) 
 * 
 * This flag may be requested in constructor functions. 
 */</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_ENSURENOCOPY </span><span class="s4">0x4000</span>

<span class="s3">/* 
 * NOTE: there are also internal flags defined in multiarray/arrayobject.h, 
 * which start at bit 31 and work down. 
 */</span>

<span class="s0">#define </span><span class="s1">NPY_ARRAY_BEHAVED      (NPY_ARRAY_ALIGNED | \</span>
                                <span class="s1">NPY_ARRAY_WRITEABLE)</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_BEHAVED_NS   (NPY_ARRAY_ALIGNED | \</span>
                                <span class="s1">NPY_ARRAY_WRITEABLE | \</span>
                                <span class="s1">NPY_ARRAY_NOTSWAPPED)</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_CARRAY       (NPY_ARRAY_C_CONTIGUOUS | \</span>
                                <span class="s1">NPY_ARRAY_BEHAVED)</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_CARRAY_RO    (NPY_ARRAY_C_CONTIGUOUS | \</span>
                                <span class="s1">NPY_ARRAY_ALIGNED)</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_FARRAY       (NPY_ARRAY_F_CONTIGUOUS | \</span>
                                <span class="s1">NPY_ARRAY_BEHAVED)</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_FARRAY_RO    (NPY_ARRAY_F_CONTIGUOUS | \</span>
                                <span class="s1">NPY_ARRAY_ALIGNED)</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_DEFAULT      (NPY_ARRAY_CARRAY)</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_IN_ARRAY     (NPY_ARRAY_CARRAY_RO)</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_OUT_ARRAY    (NPY_ARRAY_CARRAY)</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_INOUT_ARRAY  (NPY_ARRAY_CARRAY | \</span>
                                <span class="s1">NPY_ARRAY_UPDATEIFCOPY)</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_INOUT_ARRAY2 (NPY_ARRAY_CARRAY | \</span>
                                <span class="s1">NPY_ARRAY_WRITEBACKIFCOPY)</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_IN_FARRAY    (NPY_ARRAY_FARRAY_RO)</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_OUT_FARRAY   (NPY_ARRAY_FARRAY)</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_INOUT_FARRAY (NPY_ARRAY_FARRAY | \</span>
                                <span class="s1">NPY_ARRAY_UPDATEIFCOPY)</span>
<span class="s0">#define </span><span class="s1">NPY_ARRAY_INOUT_FARRAY2 (NPY_ARRAY_FARRAY | \</span>
                                <span class="s1">NPY_ARRAY_WRITEBACKIFCOPY)</span>

<span class="s0">#define </span><span class="s1">NPY_ARRAY_UPDATE_ALL   (NPY_ARRAY_C_CONTIGUOUS | \</span>
                                <span class="s1">NPY_ARRAY_F_CONTIGUOUS | \</span>
                                <span class="s1">NPY_ARRAY_ALIGNED)</span>

<span class="s3">/* This flag is for the array interface, not PyArrayObject */</span>
<span class="s0">#define </span><span class="s1">NPY_ARR_HAS_DESCR  </span><span class="s4">0x0800</span>




<span class="s3">/* 
 * Size of internal buffers used for alignment Make BUFSIZE a multiple 
 * of sizeof(npy_cdouble) -- usually 16 so that ufunc buffers are aligned 
 */</span>
<span class="s0">#define </span><span class="s1">NPY_MIN_BUFSIZE ((</span><span class="s0">int</span><span class="s1">)</span><span class="s0">sizeof</span><span class="s1">(npy_cdouble))</span>
<span class="s0">#define </span><span class="s1">NPY_MAX_BUFSIZE (((</span><span class="s0">int</span><span class="s1">)</span><span class="s0">sizeof</span><span class="s1">(npy_cdouble))*</span><span class="s4">1000000</span><span class="s1">)</span>
<span class="s0">#define </span><span class="s1">NPY_BUFSIZE </span><span class="s4">8192</span>
<span class="s3">/* buffer stress test size: */</span>
<span class="s3">/*#define NPY_BUFSIZE 17*/</span>

<span class="s0">#define </span><span class="s1">PyArray_MAX(a,b) (((a)&gt;(b))?(a):(b))</span>
<span class="s0">#define </span><span class="s1">PyArray_MIN(a,b) (((a)&lt;(b))?(a):(b))</span>
<span class="s0">#define </span><span class="s1">PyArray_CLT(p,q) ((((p).real==(q).real) ? ((p).imag &lt; (q).imag) : \</span>
                               <span class="s1">((p).real &lt; (q).real)))</span>
<span class="s0">#define </span><span class="s1">PyArray_CGT(p,q) ((((p).real==(q).real) ? ((p).imag &gt; (q).imag) : \</span>
                               <span class="s1">((p).real &gt; (q).real)))</span>
<span class="s0">#define </span><span class="s1">PyArray_CLE(p,q) ((((p).real==(q).real) ? ((p).imag &lt;= (q).imag) : \</span>
                               <span class="s1">((p).real &lt;= (q).real)))</span>
<span class="s0">#define </span><span class="s1">PyArray_CGE(p,q) ((((p).real==(q).real) ? ((p).imag &gt;= (q).imag) : \</span>
                               <span class="s1">((p).real &gt;= (q).real)))</span>
<span class="s0">#define </span><span class="s1">PyArray_CEQ(p,q) (((p).real==(q).real) &amp;&amp; ((p).imag == (q).imag))</span>
<span class="s0">#define </span><span class="s1">PyArray_CNE(p,q) (((p).real!=(q).real) || ((p).imag != (q).imag))</span>

<span class="s3">/* 
 * C API: consists of Macros and functions.  The MACROS are defined 
 * here. 
 */</span>


<span class="s0">#define </span><span class="s1">PyArray_ISCONTIGUOUS(m) PyArray_CHKFLAGS((m), NPY_ARRAY_C_CONTIGUOUS)</span>
<span class="s0">#define </span><span class="s1">PyArray_ISWRITEABLE(m) PyArray_CHKFLAGS((m), NPY_ARRAY_WRITEABLE)</span>
<span class="s0">#define </span><span class="s1">PyArray_ISALIGNED(m) PyArray_CHKFLAGS((m), NPY_ARRAY_ALIGNED)</span>

<span class="s0">#define </span><span class="s1">PyArray_IS_C_CONTIGUOUS(m) PyArray_CHKFLAGS((m), NPY_ARRAY_C_CONTIGUOUS)</span>
<span class="s0">#define </span><span class="s1">PyArray_IS_F_CONTIGUOUS(m) PyArray_CHKFLAGS((m), NPY_ARRAY_F_CONTIGUOUS)</span>

<span class="s3">/* the variable is used in some places, so always define it */</span>
<span class="s0">#define </span><span class="s1">NPY_BEGIN_THREADS_DEF PyThreadState *_save=NULL;</span>
<span class="s0">#if </span><span class="s1">NPY_ALLOW_THREADS</span>
<span class="s0">#define </span><span class="s1">NPY_BEGIN_ALLOW_THREADS Py_BEGIN_ALLOW_THREADS</span>
<span class="s0">#define </span><span class="s1">NPY_END_ALLOW_THREADS Py_END_ALLOW_THREADS</span>
<span class="s0">#define </span><span class="s1">NPY_BEGIN_THREADS </span><span class="s0">do </span><span class="s1">{_save = PyEval_SaveThread();} </span><span class="s0">while </span><span class="s1">(</span><span class="s4">0</span><span class="s1">);</span>
<span class="s0">#define </span><span class="s1">NPY_END_THREADS   </span><span class="s0">do </span><span class="s1">{ </span><span class="s0">if </span><span class="s1">(_save) \</span>
                <span class="s1">{ PyEval_RestoreThread(_save); _save = NULL;} } </span><span class="s0">while </span><span class="s1">(</span><span class="s4">0</span><span class="s1">);</span>
<span class="s0">#define </span><span class="s1">NPY_BEGIN_THREADS_THRESHOLDED(loop_size) </span><span class="s0">do </span><span class="s1">{ </span><span class="s0">if </span><span class="s1">((loop_size) &gt; </span><span class="s4">500</span><span class="s1">) \</span>
                <span class="s1">{ _save = PyEval_SaveThread();} } </span><span class="s0">while </span><span class="s1">(</span><span class="s4">0</span><span class="s1">);</span>

<span class="s0">#define </span><span class="s1">NPY_BEGIN_THREADS_DESCR(dtype) \</span>
        <span class="s0">do </span><span class="s1">{</span><span class="s0">if </span><span class="s1">(!(PyDataType_FLAGCHK((dtype), NPY_NEEDS_PYAPI))) \</span>
                <span class="s1">NPY_BEGIN_THREADS;} </span><span class="s0">while </span><span class="s1">(</span><span class="s4">0</span><span class="s1">);</span>

<span class="s0">#define </span><span class="s1">NPY_END_THREADS_DESCR(dtype) \</span>
        <span class="s0">do </span><span class="s1">{</span><span class="s0">if </span><span class="s1">(!(PyDataType_FLAGCHK((dtype), NPY_NEEDS_PYAPI))) \</span>
                <span class="s1">NPY_END_THREADS; } </span><span class="s0">while </span><span class="s1">(</span><span class="s4">0</span><span class="s1">);</span>

<span class="s0">#define </span><span class="s1">NPY_ALLOW_C_API_DEF  PyGILState_STATE __save__;</span>
<span class="s0">#define </span><span class="s1">NPY_ALLOW_C_API      </span><span class="s0">do </span><span class="s1">{__save__ = PyGILState_Ensure();} </span><span class="s0">while </span><span class="s1">(</span><span class="s4">0</span><span class="s1">);</span>
<span class="s0">#define </span><span class="s1">NPY_DISABLE_C_API    </span><span class="s0">do </span><span class="s1">{PyGILState_Release(__save__);} </span><span class="s0">while </span><span class="s1">(</span><span class="s4">0</span><span class="s1">);</span>
<span class="s0">#else</span>
<span class="s0">#define </span><span class="s1">NPY_BEGIN_ALLOW_THREADS</span>
<span class="s0">#define </span><span class="s1">NPY_END_ALLOW_THREADS</span>
<span class="s0">#define </span><span class="s1">NPY_BEGIN_THREADS</span>
<span class="s0">#define </span><span class="s1">NPY_END_THREADS</span>
<span class="s0">#define </span><span class="s1">NPY_BEGIN_THREADS_THRESHOLDED(loop_size)</span>
<span class="s0">#define </span><span class="s1">NPY_BEGIN_THREADS_DESCR(dtype)</span>
<span class="s0">#define </span><span class="s1">NPY_END_THREADS_DESCR(dtype)</span>
<span class="s0">#define </span><span class="s1">NPY_ALLOW_C_API_DEF</span>
<span class="s0">#define </span><span class="s1">NPY_ALLOW_C_API</span>
<span class="s0">#define </span><span class="s1">NPY_DISABLE_C_API</span>
<span class="s0">#endif</span>

<span class="s3">/********************************** 
 * The nditer object, added in 1.6 
 **********************************/</span>

<span class="s3">/* The actual structure of the iterator is an internal detail */</span>
<span class="s0">typedef struct </span><span class="s1">NpyIter_InternalOnly NpyIter;</span>

<span class="s3">/* Iterator function pointers that may be specialized */</span>
<span class="s0">typedef int </span><span class="s1">(NpyIter_IterNextFunc)(NpyIter *iter);</span>
<span class="s0">typedef void </span><span class="s1">(NpyIter_GetMultiIndexFunc)(NpyIter *iter,</span>
                                      <span class="s1">npy_intp *outcoords);</span>

<span class="s3">/*** Global flags that may be passed to the iterator constructors ***/</span>

<span class="s3">/* Track an index representing C order */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_C_INDEX                    </span><span class="s4">0x00000001</span>
<span class="s3">/* Track an index representing Fortran order */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_F_INDEX                    </span><span class="s4">0x00000002</span>
<span class="s3">/* Track a multi-index */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_MULTI_INDEX                </span><span class="s4">0x00000004</span>
<span class="s3">/* User code external to the iterator does the 1-dimensional innermost loop */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_EXTERNAL_LOOP              </span><span class="s4">0x00000008</span>
<span class="s3">/* Convert all the operands to a common data type */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_COMMON_DTYPE               </span><span class="s4">0x00000010</span>
<span class="s3">/* Operands may hold references, requiring API access during iteration */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_REFS_OK                    </span><span class="s4">0x00000020</span>
<span class="s3">/* Zero-sized operands should be permitted, iteration checks IterSize for 0 */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_ZEROSIZE_OK                </span><span class="s4">0x00000040</span>
<span class="s3">/* Permits reductions (size-0 stride with dimension size &gt; 1) */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_REDUCE_OK                  </span><span class="s4">0x00000080</span>
<span class="s3">/* Enables sub-range iteration */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_RANGED                     </span><span class="s4">0x00000100</span>
<span class="s3">/* Enables buffering */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_BUFFERED                   </span><span class="s4">0x00000200</span>
<span class="s3">/* When buffering is enabled, grows the inner loop if possible */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_GROWINNER                  </span><span class="s4">0x00000400</span>
<span class="s3">/* Delay allocation of buffers until first Reset* call */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_DELAY_BUFALLOC             </span><span class="s4">0x00000800</span>
<span class="s3">/* When NPY_KEEPORDER is specified, disable reversing negative-stride axes */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_DONT_NEGATE_STRIDES        </span><span class="s4">0x00001000</span>
<span class="s3">/* 
 * If output operands overlap with other operands (based on heuristics that 
 * has false positives but no false negatives), make temporary copies to 
 * eliminate overlap. 
 */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_COPY_IF_OVERLAP            </span><span class="s4">0x00002000</span>

<span class="s3">/*** Per-operand flags that may be passed to the iterator constructors ***/</span>

<span class="s3">/* The operand will be read from and written to */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_READWRITE                  </span><span class="s4">0x00010000</span>
<span class="s3">/* The operand will only be read from */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_READONLY                   </span><span class="s4">0x00020000</span>
<span class="s3">/* The operand will only be written to */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_WRITEONLY                  </span><span class="s4">0x00040000</span>
<span class="s3">/* The operand's data must be in native byte order */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_NBO                        </span><span class="s4">0x00080000</span>
<span class="s3">/* The operand's data must be aligned */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_ALIGNED                    </span><span class="s4">0x00100000</span>
<span class="s3">/* The operand's data must be contiguous (within the inner loop) */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_CONTIG                     </span><span class="s4">0x00200000</span>
<span class="s3">/* The operand may be copied to satisfy requirements */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_COPY                       </span><span class="s4">0x00400000</span>
<span class="s3">/* The operand may be copied with WRITEBACKIFCOPY to satisfy requirements */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_UPDATEIFCOPY               </span><span class="s4">0x00800000</span>
<span class="s3">/* Allocate the operand if it is NULL */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_ALLOCATE                   </span><span class="s4">0x01000000</span>
<span class="s3">/* If an operand is allocated, don't use any subtype */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_NO_SUBTYPE                 </span><span class="s4">0x02000000</span>
<span class="s3">/* This is a virtual array slot, operand is NULL but temporary data is there */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_VIRTUAL                    </span><span class="s4">0x04000000</span>
<span class="s3">/* Require that the dimension match the iterator dimensions exactly */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_NO_BROADCAST               </span><span class="s4">0x08000000</span>
<span class="s3">/* A mask is being used on this array, affects buffer -&gt; array copy */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_WRITEMASKED                </span><span class="s4">0x10000000</span>
<span class="s3">/* This array is the mask for all WRITEMASKED operands */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_ARRAYMASK                  </span><span class="s4">0x20000000</span>
<span class="s3">/* Assume iterator order data access for COPY_IF_OVERLAP */</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE </span><span class="s4">0x40000000</span>

<span class="s0">#define </span><span class="s1">NPY_ITER_GLOBAL_FLAGS               </span><span class="s4">0x0000ffff</span>
<span class="s0">#define </span><span class="s1">NPY_ITER_PER_OP_FLAGS               </span><span class="s4">0xffff0000</span>


<span class="s3">/***************************** 
 * Basic iterator object 
 *****************************/</span>

<span class="s3">/* FWD declaration */</span>
<span class="s0">typedef struct </span><span class="s1">PyArrayIterObject_tag PyArrayIterObject;</span>

<span class="s3">/* 
 * type of the function which translates a set of coordinates to a 
 * pointer to the data 
 */</span>
<span class="s0">typedef char</span><span class="s1">* (*npy_iter_get_dataptr_t)(</span>
        <span class="s1">PyArrayIterObject* iter, </span><span class="s0">const </span><span class="s1">npy_intp*);</span>

<span class="s0">struct </span><span class="s1">PyArrayIterObject_tag {</span>
        <span class="s1">PyObject_HEAD</span>
        <span class="s0">int               </span><span class="s1">nd_m1;            </span><span class="s3">/* number of dimensions - 1 */</span>
        <span class="s1">npy_intp          index, size;</span>
        <span class="s1">npy_intp          coordinates[NPY_MAXDIMS];</span><span class="s3">/* N-dimensional loop */</span>
        <span class="s1">npy_intp          dims_m1[NPY_MAXDIMS];    </span><span class="s3">/* ao-&gt;dimensions - 1 */</span>
        <span class="s1">npy_intp          strides[NPY_MAXDIMS];    </span><span class="s3">/* ao-&gt;strides or fake */</span>
        <span class="s1">npy_intp          backstrides[NPY_MAXDIMS];</span><span class="s3">/* how far to jump back */</span>
        <span class="s1">npy_intp          factors[NPY_MAXDIMS];     </span><span class="s3">/* shape factors */</span>
        <span class="s1">PyArrayObject     *ao;</span>
        <span class="s0">char              </span><span class="s1">*dataptr;        </span><span class="s3">/* pointer to current item*/</span>
        <span class="s1">npy_bool          contiguous;</span>

        <span class="s1">npy_intp          bounds[NPY_MAXDIMS][</span><span class="s4">2</span><span class="s1">];</span>
        <span class="s1">npy_intp          limits[NPY_MAXDIMS][</span><span class="s4">2</span><span class="s1">];</span>
        <span class="s1">npy_intp          limits_sizes[NPY_MAXDIMS];</span>
        <span class="s1">npy_iter_get_dataptr_t translate;</span>
<span class="s1">} ;</span>


<span class="s3">/* Iterator API */</span>
<span class="s0">#define </span><span class="s1">PyArrayIter_Check(op) PyObject_TypeCheck((op), &amp;PyArrayIter_Type)</span>

<span class="s0">#define </span><span class="s1">_PyAIT(it) ((PyArrayIterObject *)(it))</span>
<span class="s0">#define </span><span class="s1">PyArray_ITER_RESET(it) </span><span class="s0">do </span><span class="s1">{ \</span>
        <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">index = </span><span class="s4">0</span><span class="s1">; \</span>
        <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">dataptr = PyArray_BYTES(_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">ao); \</span>
        <span class="s1">memset(_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">coordinates, </span><span class="s4">0</span><span class="s1">, \</span>
               <span class="s1">(_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">nd_m1+</span><span class="s4">1</span><span class="s1">)*</span><span class="s0">sizeof</span><span class="s1">(npy_intp)); \</span>
<span class="s1">} </span><span class="s0">while </span><span class="s1">(</span><span class="s4">0</span><span class="s1">)</span>

<span class="s0">#define </span><span class="s1">_PyArray_ITER_NEXT1(it) </span><span class="s0">do </span><span class="s1">{ \</span>
        <span class="s1">(it)</span><span class="s5">-&gt;</span><span class="s1">dataptr += _PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">strides[</span><span class="s4">0</span><span class="s1">]; \</span>
        <span class="s1">(it)</span><span class="s5">-&gt;</span><span class="s1">coordinates[</span><span class="s4">0</span><span class="s1">]++; \</span>
<span class="s1">} </span><span class="s0">while </span><span class="s1">(</span><span class="s4">0</span><span class="s1">)</span>

<span class="s0">#define </span><span class="s1">_PyArray_ITER_NEXT2(it) </span><span class="s0">do </span><span class="s1">{ \</span>
        <span class="s0">if </span><span class="s1">((it)</span><span class="s5">-&gt;</span><span class="s1">coordinates[</span><span class="s4">1</span><span class="s1">] &lt; (it)</span><span class="s5">-&gt;</span><span class="s1">dims_m1[</span><span class="s4">1</span><span class="s1">]) { \</span>
                <span class="s1">(it)</span><span class="s5">-&gt;</span><span class="s1">coordinates[</span><span class="s4">1</span><span class="s1">]++; \</span>
                <span class="s1">(it)</span><span class="s5">-&gt;</span><span class="s1">dataptr += (it)</span><span class="s5">-&gt;</span><span class="s1">strides[</span><span class="s4">1</span><span class="s1">]; \</span>
        <span class="s1">} \</span>
        <span class="s0">else </span><span class="s1">{ \</span>
                <span class="s1">(it)</span><span class="s5">-&gt;</span><span class="s1">coordinates[</span><span class="s4">1</span><span class="s1">] = </span><span class="s4">0</span><span class="s1">; \</span>
                <span class="s1">(it)</span><span class="s5">-&gt;</span><span class="s1">coordinates[</span><span class="s4">0</span><span class="s1">]++; \</span>
                <span class="s1">(it)</span><span class="s5">-&gt;</span><span class="s1">dataptr += (it)</span><span class="s5">-&gt;</span><span class="s1">strides[</span><span class="s4">0</span><span class="s1">] - \</span>
                        <span class="s1">(it)</span><span class="s5">-&gt;</span><span class="s1">backstrides[</span><span class="s4">1</span><span class="s1">]; \</span>
        <span class="s1">} \</span>
<span class="s1">} </span><span class="s0">while </span><span class="s1">(</span><span class="s4">0</span><span class="s1">)</span>

<span class="s0">#define </span><span class="s1">PyArray_ITER_NEXT(it) </span><span class="s0">do </span><span class="s1">{ \</span>
        <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">index++; \</span>
        <span class="s0">if </span><span class="s1">(_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">nd_m1 == </span><span class="s4">0</span><span class="s1">) { \</span>
                <span class="s1">_PyArray_ITER_NEXT1(_PyAIT(it)); \</span>
        <span class="s1">} \</span>
        <span class="s0">else if </span><span class="s1">(_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">contiguous) \</span>
                <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">dataptr += PyArray_DESCR(_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">ao)</span><span class="s5">-&gt;</span><span class="s1">elsize; \</span>
        <span class="s0">else if </span><span class="s1">(_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">nd_m1 == </span><span class="s4">1</span><span class="s1">) { \</span>
                <span class="s1">_PyArray_ITER_NEXT2(_PyAIT(it)); \</span>
        <span class="s1">} \</span>
        <span class="s0">else </span><span class="s1">{ \</span>
                <span class="s0">int </span><span class="s1">__npy_i; \</span>
                <span class="s0">for </span><span class="s1">(__npy_i=_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">nd_m1; __npy_i &gt;= </span><span class="s4">0</span><span class="s1">; __npy_i--) { \</span>
                        <span class="s0">if </span><span class="s1">(_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">coordinates[__npy_i] &lt; \</span>
                            <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">dims_m1[__npy_i]) { \</span>
                                <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">coordinates[__npy_i]++; \</span>
                                <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">dataptr += \</span>
                                        <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">strides[__npy_i]; \</span>
                                <span class="s0">break</span><span class="s1">; \</span>
                        <span class="s1">} \</span>
                        <span class="s0">else </span><span class="s1">{ \</span>
                                <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">coordinates[__npy_i] = </span><span class="s4">0</span><span class="s1">; \</span>
                                <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">dataptr -= \</span>
                                        <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">backstrides[__npy_i]; \</span>
                        <span class="s1">} \</span>
                <span class="s1">} \</span>
        <span class="s1">} \</span>
<span class="s1">} </span><span class="s0">while </span><span class="s1">(</span><span class="s4">0</span><span class="s1">)</span>

<span class="s0">#define </span><span class="s1">PyArray_ITER_GOTO(it, destination) </span><span class="s0">do </span><span class="s1">{ \</span>
        <span class="s0">int </span><span class="s1">__npy_i; \</span>
        <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">index = </span><span class="s4">0</span><span class="s1">; \</span>
        <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">dataptr = PyArray_BYTES(_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">ao); \</span>
        <span class="s0">for </span><span class="s1">(__npy_i = _PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">nd_m1; __npy_i&gt;=</span><span class="s4">0</span><span class="s1">; __npy_i--) { \</span>
                <span class="s0">if </span><span class="s1">(destination[__npy_i] &lt; </span><span class="s4">0</span><span class="s1">) { \</span>
                        <span class="s1">destination[__npy_i] += \</span>
                                <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">dims_m1[__npy_i]+</span><span class="s4">1</span><span class="s1">; \</span>
                <span class="s1">} \</span>
                <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">dataptr += destination[__npy_i] * \</span>
                        <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">strides[__npy_i]; \</span>
                <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">coordinates[__npy_i] = \</span>
                        <span class="s1">destination[__npy_i]; \</span>
                <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">index += destination[__npy_i] * \</span>
                        <span class="s1">( __npy_i==_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">nd_m1 ? </span><span class="s4">1 </span><span class="s1">: \</span>
                          <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">dims_m1[__npy_i+</span><span class="s4">1</span><span class="s1">]+</span><span class="s4">1</span><span class="s1">) ; \</span>
        <span class="s1">} \</span>
<span class="s1">} </span><span class="s0">while </span><span class="s1">(</span><span class="s4">0</span><span class="s1">)</span>

<span class="s0">#define </span><span class="s1">PyArray_ITER_GOTO1D(it, ind) </span><span class="s0">do </span><span class="s1">{ \</span>
        <span class="s0">int </span><span class="s1">__npy_i; \</span>
        <span class="s1">npy_intp __npy_ind = (npy_intp)(ind); \</span>
        <span class="s0">if </span><span class="s1">(__npy_ind &lt; </span><span class="s4">0</span><span class="s1">) __npy_ind += _PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">size; \</span>
        <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">index = __npy_ind; \</span>
        <span class="s0">if </span><span class="s1">(_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">nd_m1 == </span><span class="s4">0</span><span class="s1">) { \</span>
                <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">dataptr = PyArray_BYTES(_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">ao) + \</span>
                        <span class="s1">__npy_ind * _PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">strides[</span><span class="s4">0</span><span class="s1">]; \</span>
        <span class="s1">} \</span>
        <span class="s0">else if </span><span class="s1">(_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">contiguous) \</span>
                <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">dataptr = PyArray_BYTES(_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">ao) + \</span>
                        <span class="s1">__npy_ind * PyArray_DESCR(_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">ao)</span><span class="s5">-&gt;</span><span class="s1">elsize; \</span>
        <span class="s0">else </span><span class="s1">{ \</span>
                <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">dataptr = PyArray_BYTES(_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">ao); \</span>
                <span class="s0">for </span><span class="s1">(__npy_i = </span><span class="s4">0</span><span class="s1">; __npy_i&lt;=_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">nd_m1; \</span>
                     <span class="s1">__npy_i++) { \</span>
                        <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">coordinates[__npy_i] = \</span>
                                <span class="s1">(__npy_ind / _PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">factors[__npy_i]); \</span>
                        <span class="s1">_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">dataptr += \</span>
                                <span class="s1">(__npy_ind / _PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">factors[__npy_i]) \</span>
                                <span class="s1">* _PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">strides[__npy_i]; \</span>
                        <span class="s1">__npy_ind %= _PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">factors[__npy_i]; \</span>
                <span class="s1">} \</span>
        <span class="s1">} \</span>
<span class="s1">} </span><span class="s0">while </span><span class="s1">(</span><span class="s4">0</span><span class="s1">)</span>

<span class="s0">#define </span><span class="s1">PyArray_ITER_DATA(it) ((</span><span class="s0">void </span><span class="s1">*)(_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">dataptr))</span>

<span class="s0">#define </span><span class="s1">PyArray_ITER_NOTDONE(it) (_PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">index &lt; _PyAIT(it)</span><span class="s5">-&gt;</span><span class="s1">size)</span>


<span class="s3">/* 
 * Any object passed to PyArray_Broadcast must be binary compatible 
 * with this structure. 
 */</span>

<span class="s0">typedef struct </span><span class="s1">{</span>
        <span class="s1">PyObject_HEAD</span>
        <span class="s0">int                  </span><span class="s1">numiter;                 </span><span class="s3">/* number of iters */</span>
        <span class="s1">npy_intp             size;                    </span><span class="s3">/* broadcasted size */</span>
        <span class="s1">npy_intp             index;                   </span><span class="s3">/* current index */</span>
        <span class="s0">int                  </span><span class="s1">nd;                      </span><span class="s3">/* number of dims */</span>
        <span class="s1">npy_intp             dimensions[NPY_MAXDIMS]; </span><span class="s3">/* dimensions */</span>
        <span class="s1">PyArrayIterObject    *iters[NPY_MAXARGS];     </span><span class="s3">/* iterators */</span>
<span class="s1">} PyArrayMultiIterObject;</span>

<span class="s0">#define </span><span class="s1">_PyMIT(m) ((PyArrayMultiIterObject *)(m))</span>
<span class="s0">#define </span><span class="s1">PyArray_MultiIter_RESET(multi) </span><span class="s0">do </span><span class="s1">{                                   \</span>
        <span class="s0">int </span><span class="s1">__npy_mi;                                                         \</span>
        <span class="s1">_PyMIT(multi)</span><span class="s5">-&gt;</span><span class="s1">index = </span><span class="s4">0</span><span class="s1">;                                             \</span>
        <span class="s0">for </span><span class="s1">(__npy_mi=</span><span class="s4">0</span><span class="s1">; __npy_mi &lt; _PyMIT(multi)</span><span class="s5">-&gt;</span><span class="s1">numiter;  __npy_mi++) {    \</span>
                <span class="s1">PyArray_ITER_RESET(_PyMIT(multi)</span><span class="s5">-&gt;</span><span class="s1">iters[__npy_mi]);           \</span>
        <span class="s1">}                                                                     \</span>
<span class="s1">} </span><span class="s0">while </span><span class="s1">(</span><span class="s4">0</span><span class="s1">)</span>

<span class="s0">#define </span><span class="s1">PyArray_MultiIter_NEXT(multi) </span><span class="s0">do </span><span class="s1">{                                    \</span>
        <span class="s0">int </span><span class="s1">__npy_mi;                                                         \</span>
        <span class="s1">_PyMIT(multi)</span><span class="s5">-&gt;</span><span class="s1">index++;                                               \</span>
        <span class="s0">for </span><span class="s1">(__npy_mi=</span><span class="s4">0</span><span class="s1">; __npy_mi &lt; _PyMIT(multi)</span><span class="s5">-&gt;</span><span class="s1">numiter;   __npy_mi++) {   \</span>
                <span class="s1">PyArray_ITER_NEXT(_PyMIT(multi)</span><span class="s5">-&gt;</span><span class="s1">iters[__npy_mi]);            \</span>
        <span class="s1">}                                                                     \</span>
<span class="s1">} </span><span class="s0">while </span><span class="s1">(</span><span class="s4">0</span><span class="s1">)</span>

<span class="s0">#define </span><span class="s1">PyArray_MultiIter_GOTO(multi, dest) </span><span class="s0">do </span><span class="s1">{                            \</span>
        <span class="s0">int </span><span class="s1">__npy_mi;                                                       \</span>
        <span class="s0">for </span><span class="s1">(__npy_mi=</span><span class="s4">0</span><span class="s1">; __npy_mi &lt; _PyMIT(multi)</span><span class="s5">-&gt;</span><span class="s1">numiter; __npy_mi++) {   \</span>
                <span class="s1">PyArray_ITER_GOTO(_PyMIT(multi)</span><span class="s5">-&gt;</span><span class="s1">iters[__npy_mi], dest);    \</span>
        <span class="s1">}                                                                   \</span>
        <span class="s1">_PyMIT(multi)</span><span class="s5">-&gt;</span><span class="s1">index = _PyMIT(multi)</span><span class="s5">-&gt;</span><span class="s1">iters[</span><span class="s4">0</span><span class="s1">]</span><span class="s5">-&gt;</span><span class="s1">index;              \</span>
<span class="s1">} </span><span class="s0">while </span><span class="s1">(</span><span class="s4">0</span><span class="s1">)</span>

<span class="s0">#define </span><span class="s1">PyArray_MultiIter_GOTO1D(multi, ind) </span><span class="s0">do </span><span class="s1">{                          \</span>
        <span class="s0">int </span><span class="s1">__npy_mi;                                                      \</span>
        <span class="s0">for </span><span class="s1">(__npy_mi=</span><span class="s4">0</span><span class="s1">; __npy_mi &lt; _PyMIT(multi)</span><span class="s5">-&gt;</span><span class="s1">numiter; __npy_mi++) {  \</span>
                <span class="s1">PyArray_ITER_GOTO1D(_PyMIT(multi)</span><span class="s5">-&gt;</span><span class="s1">iters[__npy_mi], ind);  \</span>
        <span class="s1">}                                                                  \</span>
        <span class="s1">_PyMIT(multi)</span><span class="s5">-&gt;</span><span class="s1">index = _PyMIT(multi)</span><span class="s5">-&gt;</span><span class="s1">iters[</span><span class="s4">0</span><span class="s1">]</span><span class="s5">-&gt;</span><span class="s1">index;             \</span>
<span class="s1">} </span><span class="s0">while </span><span class="s1">(</span><span class="s4">0</span><span class="s1">)</span>

<span class="s0">#define </span><span class="s1">PyArray_MultiIter_DATA(multi, i)                \</span>
        <span class="s1">((</span><span class="s0">void </span><span class="s1">*)(_PyMIT(multi)</span><span class="s5">-&gt;</span><span class="s1">iters[i]</span><span class="s5">-&gt;</span><span class="s1">dataptr))</span>

<span class="s0">#define </span><span class="s1">PyArray_MultiIter_NEXTi(multi, i)               \</span>
        <span class="s1">PyArray_ITER_NEXT(_PyMIT(multi)</span><span class="s5">-&gt;</span><span class="s1">iters[i])</span>

<span class="s0">#define </span><span class="s1">PyArray_MultiIter_NOTDONE(multi)                \</span>
        <span class="s1">(_PyMIT(multi)</span><span class="s5">-&gt;</span><span class="s1">index &lt; _PyMIT(multi)</span><span class="s5">-&gt;</span><span class="s1">size)</span>

<span class="s3">/* 
 * Store the information needed for fancy-indexing over an array. The 
 * fields are slightly unordered to keep consec, dataptr and subspace 
 * where they were originally. 
 */</span>
<span class="s0">typedef struct </span><span class="s1">{</span>
        <span class="s1">PyObject_HEAD</span>
        <span class="s3">/* 
         * Multi-iterator portion --- needs to be present in this 
         * order to work with PyArray_Broadcast 
         */</span>

        <span class="s0">int                   </span><span class="s1">numiter;                 </span><span class="s3">/* number of index-array 
                                                          iterators */</span>
        <span class="s1">npy_intp              size;                    </span><span class="s3">/* size of broadcasted 
                                                          result */</span>
        <span class="s1">npy_intp              index;                   </span><span class="s3">/* current index */</span>
        <span class="s0">int                   </span><span class="s1">nd;                      </span><span class="s3">/* number of dims */</span>
        <span class="s1">npy_intp              dimensions[NPY_MAXDIMS]; </span><span class="s3">/* dimensions */</span>
        <span class="s1">NpyIter               *outer;                  </span><span class="s3">/* index objects 
                                                          iterator */</span>
        <span class="s0">void                  </span><span class="s1">*unused[NPY_MAXDIMS - </span><span class="s4">2</span><span class="s1">];</span>
        <span class="s1">PyArrayObject         *array;</span>
        <span class="s3">/* Flat iterator for the indexed array. For compatibility solely. */</span>
        <span class="s1">PyArrayIterObject     *ait;</span>

        <span class="s3">/* 
         * Subspace array. For binary compatibility (was an iterator, 
         * but only the check for NULL should be used). 
         */</span>
        <span class="s1">PyArrayObject         *subspace;</span>

        <span class="s3">/* 
         * if subspace iteration, then this is the array of axes in 
         * the underlying array represented by the index objects 
         */</span>
        <span class="s0">int                   </span><span class="s1">iteraxes[NPY_MAXDIMS];</span>
        <span class="s1">npy_intp              fancy_strides[NPY_MAXDIMS];</span>

        <span class="s3">/* pointer when all fancy indices are 0 */</span>
        <span class="s0">char                  </span><span class="s1">*baseoffset;</span>

        <span class="s3">/* 
         * after binding consec denotes at which axis the fancy axes 
         * are inserted. 
         */</span>
        <span class="s0">int                   </span><span class="s1">consec;</span>
        <span class="s0">char                  </span><span class="s1">*dataptr;</span>

        <span class="s0">int                   </span><span class="s1">nd_fancy;</span>
        <span class="s1">npy_intp              fancy_dims[NPY_MAXDIMS];</span>

        <span class="s3">/* Whether the iterator (any of the iterators) requires API */</span>
        <span class="s0">int                   </span><span class="s1">needs_api;</span>

        <span class="s3">/* 
         * Extra op information. 
         */</span>
        <span class="s1">PyArrayObject         *extra_op;</span>
        <span class="s1">PyArray_Descr         *extra_op_dtype;         </span><span class="s3">/* desired dtype */</span>
        <span class="s1">npy_uint32            *extra_op_flags;         </span><span class="s3">/* Iterator flags */</span>

        <span class="s1">NpyIter               *extra_op_iter;</span>
        <span class="s1">NpyIter_IterNextFunc  *extra_op_next;</span>
        <span class="s0">char                  </span><span class="s1">**extra_op_ptrs;</span>

        <span class="s3">/* 
         * Information about the iteration state. 
         */</span>
        <span class="s1">NpyIter_IterNextFunc  *outer_next;</span>
        <span class="s0">char                  </span><span class="s1">**outer_ptrs;</span>
        <span class="s1">npy_intp              *outer_strides;</span>

        <span class="s3">/* 
         * Information about the subspace iterator. 
         */</span>
        <span class="s1">NpyIter               *subspace_iter;</span>
        <span class="s1">NpyIter_IterNextFunc  *subspace_next;</span>
        <span class="s0">char                  </span><span class="s1">**subspace_ptrs;</span>
        <span class="s1">npy_intp              *subspace_strides;</span>

        <span class="s3">/* Count for the external loop (which ever it is) for API iteration */</span>
        <span class="s1">npy_intp              iter_count;</span>

<span class="s1">} PyArrayMapIterObject;</span>

<span class="s0">enum </span><span class="s1">{</span>
    <span class="s1">NPY_NEIGHBORHOOD_ITER_ZERO_PADDING,</span>
    <span class="s1">NPY_NEIGHBORHOOD_ITER_ONE_PADDING,</span>
    <span class="s1">NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING,</span>
    <span class="s1">NPY_NEIGHBORHOOD_ITER_CIRCULAR_PADDING,</span>
    <span class="s1">NPY_NEIGHBORHOOD_ITER_MIRROR_PADDING</span>
<span class="s1">};</span>

<span class="s0">typedef struct </span><span class="s1">{</span>
    <span class="s1">PyObject_HEAD</span>

    <span class="s3">/* 
     * PyArrayIterObject part: keep this in this exact order 
     */</span>
    <span class="s0">int               </span><span class="s1">nd_m1;            </span><span class="s3">/* number of dimensions - 1 */</span>
    <span class="s1">npy_intp          index, size;</span>
    <span class="s1">npy_intp          coordinates[NPY_MAXDIMS];</span><span class="s3">/* N-dimensional loop */</span>
    <span class="s1">npy_intp          dims_m1[NPY_MAXDIMS];    </span><span class="s3">/* ao-&gt;dimensions - 1 */</span>
    <span class="s1">npy_intp          strides[NPY_MAXDIMS];    </span><span class="s3">/* ao-&gt;strides or fake */</span>
    <span class="s1">npy_intp          backstrides[NPY_MAXDIMS];</span><span class="s3">/* how far to jump back */</span>
    <span class="s1">npy_intp          factors[NPY_MAXDIMS];     </span><span class="s3">/* shape factors */</span>
    <span class="s1">PyArrayObject     *ao;</span>
    <span class="s0">char              </span><span class="s1">*dataptr;        </span><span class="s3">/* pointer to current item*/</span>
    <span class="s1">npy_bool          contiguous;</span>

    <span class="s1">npy_intp          bounds[NPY_MAXDIMS][</span><span class="s4">2</span><span class="s1">];</span>
    <span class="s1">npy_intp          limits[NPY_MAXDIMS][</span><span class="s4">2</span><span class="s1">];</span>
    <span class="s1">npy_intp          limits_sizes[NPY_MAXDIMS];</span>
    <span class="s1">npy_iter_get_dataptr_t translate;</span>

    <span class="s3">/* 
     * New members 
     */</span>
    <span class="s1">npy_intp nd;</span>

    <span class="s3">/* Dimensions is the dimension of the array */</span>
    <span class="s1">npy_intp dimensions[NPY_MAXDIMS];</span>

    <span class="s3">/* 
     * Neighborhood points coordinates are computed relatively to the 
     * point pointed by _internal_iter 
     */</span>
    <span class="s1">PyArrayIterObject* _internal_iter;</span>
    <span class="s3">/* 
     * To keep a reference to the representation of the constant value 
     * for constant padding 
     */</span>
    <span class="s0">char</span><span class="s1">* constant;</span>

    <span class="s0">int </span><span class="s1">mode;</span>
<span class="s1">} PyArrayNeighborhoodIterObject;</span>

<span class="s3">/* 
 * Neighborhood iterator API 
 */</span>

<span class="s3">/* General: those work for any mode */</span>
<span class="s0">static </span><span class="s1">NPY_INLINE </span><span class="s0">int</span>
<span class="s1">PyArrayNeighborhoodIter_Reset(PyArrayNeighborhoodIterObject* iter);</span>
<span class="s0">static </span><span class="s1">NPY_INLINE </span><span class="s0">int</span>
<span class="s1">PyArrayNeighborhoodIter_Next(PyArrayNeighborhoodIterObject* iter);</span>
<span class="s0">#if </span><span class="s4">0</span>
<span class="s0">static </span><span class="s1">NPY_INLINE </span><span class="s0">int</span>
<span class="s1">PyArrayNeighborhoodIter_Next2D(PyArrayNeighborhoodIterObject* iter);</span>
<span class="s0">#endif</span>

<span class="s3">/* 
 * Include inline implementations - functions defined there are not 
 * considered public API 
 */</span>
<span class="s0">#define </span><span class="s1">NUMPY_CORE_INCLUDE_NUMPY__NEIGHBORHOOD_IMP_H_</span>
<span class="s0">#include </span><span class="s2">&quot;_neighborhood_iterator_imp.h&quot;</span>
<span class="s0">#undef </span><span class="s1">NUMPY_CORE_INCLUDE_NUMPY__NEIGHBORHOOD_IMP_H_</span>



<span class="s3">/* The default array type */</span>
<span class="s0">#define </span><span class="s1">NPY_DEFAULT_TYPE NPY_DOUBLE</span>

<span class="s3">/* 
 * All sorts of useful ways to look into a PyArrayObject. It is recommended 
 * to use PyArrayObject * objects instead of always casting from PyObject *, 
 * for improved type checking. 
 * 
 * In many cases here the macro versions of the accessors are deprecated, 
 * but can't be immediately changed to inline functions because the 
 * preexisting macros accept PyObject * and do automatic casts. Inline 
 * functions accepting PyArrayObject * provides for some compile-time 
 * checking of correctness when working with these objects in C. 
 */</span>

<span class="s0">#define </span><span class="s1">PyArray_ISONESEGMENT(m) (PyArray_CHKFLAGS(m, NPY_ARRAY_C_CONTIGUOUS) || \</span>
                                 <span class="s1">PyArray_CHKFLAGS(m, NPY_ARRAY_F_CONTIGUOUS))</span>

<span class="s0">#define </span><span class="s1">PyArray_ISFORTRAN(m) (PyArray_CHKFLAGS(m, NPY_ARRAY_F_CONTIGUOUS) &amp;&amp; \</span>
                             <span class="s1">(!PyArray_CHKFLAGS(m, NPY_ARRAY_C_CONTIGUOUS)))</span>

<span class="s0">#define </span><span class="s1">PyArray_FORTRAN_IF(m) ((PyArray_CHKFLAGS(m, NPY_ARRAY_F_CONTIGUOUS) ? \</span>
                               <span class="s1">NPY_ARRAY_F_CONTIGUOUS : </span><span class="s4">0</span><span class="s1">))</span>

<span class="s0">#if </span><span class="s1">(defined(NPY_NO_DEPRECATED_API) &amp;&amp; (NPY_1_7_API_VERSION &lt;= NPY_NO_DEPRECATED_API))</span>
<span class="s3">/* 
 * Changing access macros into functions, to allow for future hiding 
 * of the internal memory layout. This later hiding will allow the 2.x series 
 * to change the internal representation of arrays without affecting 
 * ABI compatibility. 
 */</span>

<span class="s0">static </span><span class="s1">NPY_INLINE </span><span class="s0">int</span>
<span class="s1">PyArray_NDIM(</span><span class="s0">const </span><span class="s1">PyArrayObject *arr)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">((PyArrayObject_fields *)arr)</span><span class="s5">-&gt;</span><span class="s1">nd;</span>
<span class="s1">}</span>

<span class="s0">static </span><span class="s1">NPY_INLINE </span><span class="s0">void </span><span class="s1">*</span>
<span class="s1">PyArray_DATA(PyArrayObject *arr)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">((PyArrayObject_fields *)arr)</span><span class="s5">-&gt;</span><span class="s1">data;</span>
<span class="s1">}</span>

<span class="s0">static </span><span class="s1">NPY_INLINE </span><span class="s0">char </span><span class="s1">*</span>
<span class="s1">PyArray_BYTES(PyArrayObject *arr)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">((PyArrayObject_fields *)arr)</span><span class="s5">-&gt;</span><span class="s1">data;</span>
<span class="s1">}</span>

<span class="s0">static </span><span class="s1">NPY_INLINE npy_intp *</span>
<span class="s1">PyArray_DIMS(PyArrayObject *arr)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">((PyArrayObject_fields *)arr)</span><span class="s5">-&gt;</span><span class="s1">dimensions;</span>
<span class="s1">}</span>

<span class="s0">static </span><span class="s1">NPY_INLINE npy_intp *</span>
<span class="s1">PyArray_STRIDES(PyArrayObject *arr)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">((PyArrayObject_fields *)arr)</span><span class="s5">-&gt;</span><span class="s1">strides;</span>
<span class="s1">}</span>

<span class="s0">static </span><span class="s1">NPY_INLINE npy_intp</span>
<span class="s1">PyArray_DIM(</span><span class="s0">const </span><span class="s1">PyArrayObject *arr, </span><span class="s0">int </span><span class="s1">idim)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">((PyArrayObject_fields *)arr)</span><span class="s5">-&gt;</span><span class="s1">dimensions[idim];</span>
<span class="s1">}</span>

<span class="s0">static </span><span class="s1">NPY_INLINE npy_intp</span>
<span class="s1">PyArray_STRIDE(</span><span class="s0">const </span><span class="s1">PyArrayObject *arr, </span><span class="s0">int </span><span class="s1">istride)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">((PyArrayObject_fields *)arr)</span><span class="s5">-&gt;</span><span class="s1">strides[istride];</span>
<span class="s1">}</span>

<span class="s0">static </span><span class="s1">NPY_INLINE NPY_RETURNS_BORROWED_REF PyObject *</span>
<span class="s1">PyArray_BASE(PyArrayObject *arr)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">((PyArrayObject_fields *)arr)</span><span class="s5">-&gt;</span><span class="s1">base;</span>
<span class="s1">}</span>

<span class="s0">static </span><span class="s1">NPY_INLINE NPY_RETURNS_BORROWED_REF PyArray_Descr *</span>
<span class="s1">PyArray_DESCR(PyArrayObject *arr)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">((PyArrayObject_fields *)arr)</span><span class="s5">-&gt;</span><span class="s1">descr;</span>
<span class="s1">}</span>

<span class="s0">static </span><span class="s1">NPY_INLINE </span><span class="s0">int</span>
<span class="s1">PyArray_FLAGS(</span><span class="s0">const </span><span class="s1">PyArrayObject *arr)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">((PyArrayObject_fields *)arr)</span><span class="s5">-&gt;</span><span class="s1">flags;</span>
<span class="s1">}</span>

<span class="s0">static </span><span class="s1">NPY_INLINE npy_intp</span>
<span class="s1">PyArray_ITEMSIZE(</span><span class="s0">const </span><span class="s1">PyArrayObject *arr)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">((PyArrayObject_fields *)arr)</span><span class="s5">-&gt;</span><span class="s1">descr</span><span class="s5">-&gt;</span><span class="s1">elsize;</span>
<span class="s1">}</span>

<span class="s0">static </span><span class="s1">NPY_INLINE </span><span class="s0">int</span>
<span class="s1">PyArray_TYPE(</span><span class="s0">const </span><span class="s1">PyArrayObject *arr)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">((PyArrayObject_fields *)arr)</span><span class="s5">-&gt;</span><span class="s1">descr</span><span class="s5">-&gt;</span><span class="s1">type_num;</span>
<span class="s1">}</span>

<span class="s0">static </span><span class="s1">NPY_INLINE </span><span class="s0">int</span>
<span class="s1">PyArray_CHKFLAGS(</span><span class="s0">const </span><span class="s1">PyArrayObject *arr, </span><span class="s0">int </span><span class="s1">flags)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">(PyArray_FLAGS(arr) &amp; flags) == flags;</span>
<span class="s1">}</span>

<span class="s0">static </span><span class="s1">NPY_INLINE PyObject *</span>
<span class="s1">PyArray_GETITEM(</span><span class="s0">const </span><span class="s1">PyArrayObject *arr, </span><span class="s0">const char </span><span class="s1">*itemptr)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">((PyArrayObject_fields *)arr)</span><span class="s5">-&gt;</span><span class="s1">descr</span><span class="s5">-&gt;</span><span class="s1">f</span><span class="s5">-&gt;</span><span class="s1">getitem(</span>
                                        <span class="s1">(</span><span class="s0">void </span><span class="s1">*)itemptr, (PyArrayObject *)arr);</span>
<span class="s1">}</span>

<span class="s3">/* 
 * SETITEM should only be used if it is known that the value is a scalar 
 * and of a type understood by the arrays dtype. 
 * Use `PyArray_Pack` if the value may be of a different dtype. 
 */</span>
<span class="s0">static </span><span class="s1">NPY_INLINE </span><span class="s0">int</span>
<span class="s1">PyArray_SETITEM(PyArrayObject *arr, </span><span class="s0">char </span><span class="s1">*itemptr, PyObject *v)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">((PyArrayObject_fields *)arr)</span><span class="s5">-&gt;</span><span class="s1">descr</span><span class="s5">-&gt;</span><span class="s1">f</span><span class="s5">-&gt;</span><span class="s1">setitem(v, itemptr, arr);</span>
<span class="s1">}</span>

<span class="s0">#else</span>

<span class="s3">/* These macros are deprecated as of NumPy 1.7. */</span>
<span class="s0">#define </span><span class="s1">PyArray_NDIM(obj) (((PyArrayObject_fields *)(obj))</span><span class="s5">-&gt;</span><span class="s1">nd)</span>
<span class="s0">#define </span><span class="s1">PyArray_BYTES(obj) (((PyArrayObject_fields *)(obj))</span><span class="s5">-&gt;</span><span class="s1">data)</span>
<span class="s0">#define </span><span class="s1">PyArray_DATA(obj) ((</span><span class="s0">void </span><span class="s1">*)((PyArrayObject_fields *)(obj))</span><span class="s5">-&gt;</span><span class="s1">data)</span>
<span class="s0">#define </span><span class="s1">PyArray_DIMS(obj) (((PyArrayObject_fields *)(obj))</span><span class="s5">-&gt;</span><span class="s1">dimensions)</span>
<span class="s0">#define </span><span class="s1">PyArray_STRIDES(obj) (((PyArrayObject_fields *)(obj))</span><span class="s5">-&gt;</span><span class="s1">strides)</span>
<span class="s0">#define </span><span class="s1">PyArray_DIM(obj,n) (PyArray_DIMS(obj)[n])</span>
<span class="s0">#define </span><span class="s1">PyArray_STRIDE(obj,n) (PyArray_STRIDES(obj)[n])</span>
<span class="s0">#define </span><span class="s1">PyArray_BASE(obj) (((PyArrayObject_fields *)(obj))</span><span class="s5">-&gt;</span><span class="s1">base)</span>
<span class="s0">#define </span><span class="s1">PyArray_DESCR(obj) (((PyArrayObject_fields *)(obj))</span><span class="s5">-&gt;</span><span class="s1">descr)</span>
<span class="s0">#define </span><span class="s1">PyArray_FLAGS(obj) (((PyArrayObject_fields *)(obj))</span><span class="s5">-&gt;</span><span class="s1">flags)</span>
<span class="s0">#define </span><span class="s1">PyArray_CHKFLAGS(m, FLAGS) \</span>
        <span class="s1">((((PyArrayObject_fields *)(m))</span><span class="s5">-&gt;</span><span class="s1">flags &amp; (FLAGS)) == (FLAGS))</span>
<span class="s0">#define </span><span class="s1">PyArray_ITEMSIZE(obj) \</span>
                    <span class="s1">(((PyArrayObject_fields *)(obj))</span><span class="s5">-&gt;</span><span class="s1">descr</span><span class="s5">-&gt;</span><span class="s1">elsize)</span>
<span class="s0">#define </span><span class="s1">PyArray_TYPE(obj) \</span>
                    <span class="s1">(((PyArrayObject_fields *)(obj))</span><span class="s5">-&gt;</span><span class="s1">descr</span><span class="s5">-&gt;</span><span class="s1">type_num)</span>
<span class="s0">#define </span><span class="s1">PyArray_GETITEM(obj,itemptr) \</span>
        <span class="s1">PyArray_DESCR(obj)</span><span class="s5">-&gt;</span><span class="s1">f</span><span class="s5">-&gt;</span><span class="s1">getitem((</span><span class="s0">char </span><span class="s1">*)(itemptr), \</span>
                                     <span class="s1">(PyArrayObject *)(obj))</span>

<span class="s0">#define </span><span class="s1">PyArray_SETITEM(obj,itemptr,v) \</span>
        <span class="s1">PyArray_DESCR(obj)</span><span class="s5">-&gt;</span><span class="s1">f</span><span class="s5">-&gt;</span><span class="s1">setitem((PyObject *)(v), \</span>
                                     <span class="s1">(</span><span class="s0">char </span><span class="s1">*)(itemptr), \</span>
                                     <span class="s1">(PyArrayObject *)(obj))</span>
<span class="s0">#endif</span>

<span class="s0">static </span><span class="s1">NPY_INLINE PyArray_Descr *</span>
<span class="s1">PyArray_DTYPE(PyArrayObject *arr)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">((PyArrayObject_fields *)arr)</span><span class="s5">-&gt;</span><span class="s1">descr;</span>
<span class="s1">}</span>

<span class="s0">static </span><span class="s1">NPY_INLINE npy_intp *</span>
<span class="s1">PyArray_SHAPE(PyArrayObject *arr)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">((PyArrayObject_fields *)arr)</span><span class="s5">-&gt;</span><span class="s1">dimensions;</span>
<span class="s1">}</span>

<span class="s3">/* 
 * Enables the specified array flags. Does no checking, 
 * assumes you know what you're doing. 
 */</span>
<span class="s0">static </span><span class="s1">NPY_INLINE </span><span class="s0">void</span>
<span class="s1">PyArray_ENABLEFLAGS(PyArrayObject *arr, </span><span class="s0">int </span><span class="s1">flags)</span>
<span class="s1">{</span>
    <span class="s1">((PyArrayObject_fields *)arr)</span><span class="s5">-&gt;</span><span class="s1">flags |= flags;</span>
<span class="s1">}</span>

<span class="s3">/* 
 * Clears the specified array flags. Does no checking, 
 * assumes you know what you're doing. 
 */</span>
<span class="s0">static </span><span class="s1">NPY_INLINE </span><span class="s0">void</span>
<span class="s1">PyArray_CLEARFLAGS(PyArrayObject *arr, </span><span class="s0">int </span><span class="s1">flags)</span>
<span class="s1">{</span>
    <span class="s1">((PyArrayObject_fields *)arr)</span><span class="s5">-&gt;</span><span class="s1">flags &amp;= ~flags;</span>
<span class="s1">}</span>

<span class="s0">static </span><span class="s1">NPY_INLINE NPY_RETURNS_BORROWED_REF PyObject *</span>
<span class="s1">PyArray_HANDLER(PyArrayObject *arr)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">((PyArrayObject_fields *)arr)</span><span class="s5">-&gt;</span><span class="s1">mem_handler;</span>
<span class="s1">}</span>

<span class="s0">#define </span><span class="s1">PyTypeNum_ISBOOL(type) ((type) == NPY_BOOL)</span>

<span class="s0">#define </span><span class="s1">PyTypeNum_ISUNSIGNED(type) (((type) == NPY_UBYTE) ||   \</span>
                                 <span class="s1">((type) == NPY_USHORT) ||     \</span>
                                 <span class="s1">((type) == NPY_UINT) ||       \</span>
                                 <span class="s1">((type) == NPY_ULONG) ||      \</span>
                                 <span class="s1">((type) == NPY_ULONGLONG))</span>

<span class="s0">#define </span><span class="s1">PyTypeNum_ISSIGNED(type) (((type) == NPY_BYTE) ||      \</span>
                               <span class="s1">((type) == NPY_SHORT) ||        \</span>
                               <span class="s1">((type) == NPY_INT) ||          \</span>
                               <span class="s1">((type) == NPY_LONG) ||         \</span>
                               <span class="s1">((type) == NPY_LONGLONG))</span>

<span class="s0">#define </span><span class="s1">PyTypeNum_ISINTEGER(type) (((type) &gt;= NPY_BYTE) &amp;&amp;     \</span>
                                <span class="s1">((type) &lt;= NPY_ULONGLONG))</span>

<span class="s0">#define </span><span class="s1">PyTypeNum_ISFLOAT(type) ((((type) &gt;= NPY_FLOAT) &amp;&amp; \</span>
                              <span class="s1">((type) &lt;= NPY_LONGDOUBLE)) || \</span>
                              <span class="s1">((type) == NPY_HALF))</span>

<span class="s0">#define </span><span class="s1">PyTypeNum_ISNUMBER(type) (((type) &lt;= NPY_CLONGDOUBLE) || \</span>
                                  <span class="s1">((type) == NPY_HALF))</span>

<span class="s0">#define </span><span class="s1">PyTypeNum_ISSTRING(type) (((type) == NPY_STRING) ||    \</span>
                                  <span class="s1">((type) == NPY_UNICODE))</span>

<span class="s0">#define </span><span class="s1">PyTypeNum_ISCOMPLEX(type) (((type) &gt;= NPY_CFLOAT) &amp;&amp;   \</span>
                                <span class="s1">((type) &lt;= NPY_CLONGDOUBLE))</span>

<span class="s0">#define </span><span class="s1">PyTypeNum_ISPYTHON(type) (((type) == NPY_LONG) ||      \</span>
                                  <span class="s1">((type) == NPY_DOUBLE) ||    \</span>
                                  <span class="s1">((type) == NPY_CDOUBLE) ||   \</span>
                                  <span class="s1">((type) == NPY_BOOL) ||      \</span>
                                  <span class="s1">((type) == NPY_OBJECT ))</span>

<span class="s0">#define </span><span class="s1">PyTypeNum_ISFLEXIBLE(type) (((type) &gt;=NPY_STRING) &amp;&amp;  \</span>
                                    <span class="s1">((type) &lt;=NPY_VOID))</span>

<span class="s0">#define </span><span class="s1">PyTypeNum_ISDATETIME(type) (((type) &gt;=NPY_DATETIME) &amp;&amp;  \</span>
                                    <span class="s1">((type) &lt;=NPY_TIMEDELTA))</span>

<span class="s0">#define </span><span class="s1">PyTypeNum_ISUSERDEF(type) (((type) &gt;= NPY_USERDEF) &amp;&amp; \</span>
                                   <span class="s1">((type) &lt; NPY_USERDEF+     \</span>
                                    <span class="s1">NPY_NUMUSERTYPES))</span>

<span class="s0">#define </span><span class="s1">PyTypeNum_ISEXTENDED(type) (PyTypeNum_ISFLEXIBLE(type) ||  \</span>
                                    <span class="s1">PyTypeNum_ISUSERDEF(type))</span>

<span class="s0">#define </span><span class="s1">PyTypeNum_ISOBJECT(type) ((type) == NPY_OBJECT)</span>


<span class="s0">#define </span><span class="s1">PyDataType_ISBOOL(obj) PyTypeNum_ISBOOL(((PyArray_Descr*)(obj))</span><span class="s5">-&gt;</span><span class="s1">type_num)</span>
<span class="s0">#define </span><span class="s1">PyDataType_ISUNSIGNED(obj) PyTypeNum_ISUNSIGNED(((PyArray_Descr*)(obj))</span><span class="s5">-&gt;</span><span class="s1">type_num)</span>
<span class="s0">#define </span><span class="s1">PyDataType_ISSIGNED(obj) PyTypeNum_ISSIGNED(((PyArray_Descr*)(obj))</span><span class="s5">-&gt;</span><span class="s1">type_num)</span>
<span class="s0">#define </span><span class="s1">PyDataType_ISINTEGER(obj) PyTypeNum_ISINTEGER(((PyArray_Descr*)(obj))</span><span class="s5">-&gt;</span><span class="s1">type_num )</span>
<span class="s0">#define </span><span class="s1">PyDataType_ISFLOAT(obj) PyTypeNum_ISFLOAT(((PyArray_Descr*)(obj))</span><span class="s5">-&gt;</span><span class="s1">type_num)</span>
<span class="s0">#define </span><span class="s1">PyDataType_ISNUMBER(obj) PyTypeNum_ISNUMBER(((PyArray_Descr*)(obj))</span><span class="s5">-&gt;</span><span class="s1">type_num)</span>
<span class="s0">#define </span><span class="s1">PyDataType_ISSTRING(obj) PyTypeNum_ISSTRING(((PyArray_Descr*)(obj))</span><span class="s5">-&gt;</span><span class="s1">type_num)</span>
<span class="s0">#define </span><span class="s1">PyDataType_ISCOMPLEX(obj) PyTypeNum_ISCOMPLEX(((PyArray_Descr*)(obj))</span><span class="s5">-&gt;</span><span class="s1">type_num)</span>
<span class="s0">#define </span><span class="s1">PyDataType_ISPYTHON(obj) PyTypeNum_ISPYTHON(((PyArray_Descr*)(obj))</span><span class="s5">-&gt;</span><span class="s1">type_num)</span>
<span class="s0">#define </span><span class="s1">PyDataType_ISFLEXIBLE(obj) PyTypeNum_ISFLEXIBLE(((PyArray_Descr*)(obj))</span><span class="s5">-&gt;</span><span class="s1">type_num)</span>
<span class="s0">#define </span><span class="s1">PyDataType_ISDATETIME(obj) PyTypeNum_ISDATETIME(((PyArray_Descr*)(obj))</span><span class="s5">-&gt;</span><span class="s1">type_num)</span>
<span class="s0">#define </span><span class="s1">PyDataType_ISUSERDEF(obj) PyTypeNum_ISUSERDEF(((PyArray_Descr*)(obj))</span><span class="s5">-&gt;</span><span class="s1">type_num)</span>
<span class="s0">#define </span><span class="s1">PyDataType_ISEXTENDED(obj) PyTypeNum_ISEXTENDED(((PyArray_Descr*)(obj))</span><span class="s5">-&gt;</span><span class="s1">type_num)</span>
<span class="s0">#define </span><span class="s1">PyDataType_ISOBJECT(obj) PyTypeNum_ISOBJECT(((PyArray_Descr*)(obj))</span><span class="s5">-&gt;</span><span class="s1">type_num)</span>
<span class="s0">#define </span><span class="s1">PyDataType_HASFIELDS(obj) (((PyArray_Descr *)(obj))</span><span class="s5">-&gt;</span><span class="s1">names != NULL)</span>
<span class="s0">#define </span><span class="s1">PyDataType_HASSUBARRAY(dtype) ((dtype)</span><span class="s5">-&gt;</span><span class="s1">subarray != NULL)</span>
<span class="s0">#define </span><span class="s1">PyDataType_ISUNSIZED(dtype) ((dtype)</span><span class="s5">-&gt;</span><span class="s1">elsize == </span><span class="s4">0 </span><span class="s1">&amp;&amp; \</span>
                                      <span class="s1">!PyDataType_HASFIELDS(dtype))</span>
<span class="s0">#define </span><span class="s1">PyDataType_MAKEUNSIZED(dtype) ((dtype)</span><span class="s5">-&gt;</span><span class="s1">elsize = </span><span class="s4">0</span><span class="s1">)</span>

<span class="s0">#define </span><span class="s1">PyArray_ISBOOL(obj) PyTypeNum_ISBOOL(PyArray_TYPE(obj))</span>
<span class="s0">#define </span><span class="s1">PyArray_ISUNSIGNED(obj) PyTypeNum_ISUNSIGNED(PyArray_TYPE(obj))</span>
<span class="s0">#define </span><span class="s1">PyArray_ISSIGNED(obj) PyTypeNum_ISSIGNED(PyArray_TYPE(obj))</span>
<span class="s0">#define </span><span class="s1">PyArray_ISINTEGER(obj) PyTypeNum_ISINTEGER(PyArray_TYPE(obj))</span>
<span class="s0">#define </span><span class="s1">PyArray_ISFLOAT(obj) PyTypeNum_ISFLOAT(PyArray_TYPE(obj))</span>
<span class="s0">#define </span><span class="s1">PyArray_ISNUMBER(obj) PyTypeNum_ISNUMBER(PyArray_TYPE(obj))</span>
<span class="s0">#define </span><span class="s1">PyArray_ISSTRING(obj) PyTypeNum_ISSTRING(PyArray_TYPE(obj))</span>
<span class="s0">#define </span><span class="s1">PyArray_ISCOMPLEX(obj) PyTypeNum_ISCOMPLEX(PyArray_TYPE(obj))</span>
<span class="s0">#define </span><span class="s1">PyArray_ISPYTHON(obj) PyTypeNum_ISPYTHON(PyArray_TYPE(obj))</span>
<span class="s0">#define </span><span class="s1">PyArray_ISFLEXIBLE(obj) PyTypeNum_ISFLEXIBLE(PyArray_TYPE(obj))</span>
<span class="s0">#define </span><span class="s1">PyArray_ISDATETIME(obj) PyTypeNum_ISDATETIME(PyArray_TYPE(obj))</span>
<span class="s0">#define </span><span class="s1">PyArray_ISUSERDEF(obj) PyTypeNum_ISUSERDEF(PyArray_TYPE(obj))</span>
<span class="s0">#define </span><span class="s1">PyArray_ISEXTENDED(obj) PyTypeNum_ISEXTENDED(PyArray_TYPE(obj))</span>
<span class="s0">#define </span><span class="s1">PyArray_ISOBJECT(obj) PyTypeNum_ISOBJECT(PyArray_TYPE(obj))</span>
<span class="s0">#define </span><span class="s1">PyArray_HASFIELDS(obj) PyDataType_HASFIELDS(PyArray_DESCR(obj))</span>

    <span class="s3">/* 
     * FIXME: This should check for a flag on the data-type that 
     * states whether or not it is variable length.  Because the 
     * ISFLEXIBLE check is hard-coded to the built-in data-types. 
     */</span>
<span class="s0">#define </span><span class="s1">PyArray_ISVARIABLE(obj) PyTypeNum_ISFLEXIBLE(PyArray_TYPE(obj))</span>

<span class="s0">#define </span><span class="s1">PyArray_SAFEALIGNEDCOPY(obj) (PyArray_ISALIGNED(obj) &amp;&amp; !PyArray_ISVARIABLE(obj))</span>


<span class="s0">#define </span><span class="s1">NPY_LITTLE </span><span class="s2">'&lt;'</span>
<span class="s0">#define </span><span class="s1">NPY_BIG </span><span class="s2">'&gt;'</span>
<span class="s0">#define </span><span class="s1">NPY_NATIVE </span><span class="s2">'='</span>
<span class="s0">#define </span><span class="s1">NPY_SWAP </span><span class="s2">'s'</span>
<span class="s0">#define </span><span class="s1">NPY_IGNORE </span><span class="s2">'|'</span>

<span class="s0">#if </span><span class="s1">NPY_BYTE_ORDER == NPY_BIG_ENDIAN</span>
<span class="s0">#define </span><span class="s1">NPY_NATBYTE NPY_BIG</span>
<span class="s0">#define </span><span class="s1">NPY_OPPBYTE NPY_LITTLE</span>
<span class="s0">#else</span>
<span class="s0">#define </span><span class="s1">NPY_NATBYTE NPY_LITTLE</span>
<span class="s0">#define </span><span class="s1">NPY_OPPBYTE NPY_BIG</span>
<span class="s0">#endif</span>

<span class="s0">#define </span><span class="s1">PyArray_ISNBO(arg) ((arg) != NPY_OPPBYTE)</span>
<span class="s0">#define </span><span class="s1">PyArray_IsNativeByteOrder PyArray_ISNBO</span>
<span class="s0">#define </span><span class="s1">PyArray_ISNOTSWAPPED(m) PyArray_ISNBO(PyArray_DESCR(m)</span><span class="s5">-&gt;</span><span class="s1">byteorder)</span>
<span class="s0">#define </span><span class="s1">PyArray_ISBYTESWAPPED(m) (!PyArray_ISNOTSWAPPED(m))</span>

<span class="s0">#define </span><span class="s1">PyArray_FLAGSWAP(m, flags) (PyArray_CHKFLAGS(m, flags) &amp;&amp;       \</span>
                                    <span class="s1">PyArray_ISNOTSWAPPED(m))</span>

<span class="s0">#define </span><span class="s1">PyArray_ISCARRAY(m) PyArray_FLAGSWAP(m, NPY_ARRAY_CARRAY)</span>
<span class="s0">#define </span><span class="s1">PyArray_ISCARRAY_RO(m) PyArray_FLAGSWAP(m, NPY_ARRAY_CARRAY_RO)</span>
<span class="s0">#define </span><span class="s1">PyArray_ISFARRAY(m) PyArray_FLAGSWAP(m, NPY_ARRAY_FARRAY)</span>
<span class="s0">#define </span><span class="s1">PyArray_ISFARRAY_RO(m) PyArray_FLAGSWAP(m, NPY_ARRAY_FARRAY_RO)</span>
<span class="s0">#define </span><span class="s1">PyArray_ISBEHAVED(m) PyArray_FLAGSWAP(m, NPY_ARRAY_BEHAVED)</span>
<span class="s0">#define </span><span class="s1">PyArray_ISBEHAVED_RO(m) PyArray_FLAGSWAP(m, NPY_ARRAY_ALIGNED)</span>


<span class="s0">#define </span><span class="s1">PyDataType_ISNOTSWAPPED(d) PyArray_ISNBO(((PyArray_Descr *)(d))</span><span class="s5">-&gt;</span><span class="s1">byteorder)</span>
<span class="s0">#define </span><span class="s1">PyDataType_ISBYTESWAPPED(d) (!PyDataType_ISNOTSWAPPED(d))</span>

<span class="s3">/************************************************************ 
 * A struct used by PyArray_CreateSortedStridePerm, new in 1.7. 
 ************************************************************/</span>

<span class="s0">typedef struct </span><span class="s1">{</span>
    <span class="s1">npy_intp perm, stride;</span>
<span class="s1">} npy_stride_sort_item;</span>

<span class="s3">/************************************************************ 
 * This is the form of the struct that's stored in the 
 * PyCapsule returned by an array's __array_struct__ attribute. See 
 * https://docs.scipy.org/doc/numpy/reference/arrays.interface.html for the full 
 * documentation. 
 ************************************************************/</span>
<span class="s0">typedef struct </span><span class="s1">{</span>
    <span class="s0">int </span><span class="s1">two;              </span><span class="s3">/* 
                           * contains the integer 2 as a sanity 
                           * check 
                           */</span>

    <span class="s0">int </span><span class="s1">nd;               </span><span class="s3">/* number of dimensions */</span>

    <span class="s0">char </span><span class="s1">typekind;        </span><span class="s3">/* 
                           * kind in array --- character code of 
                           * typestr 
                           */</span>

    <span class="s0">int </span><span class="s1">itemsize;         </span><span class="s3">/* size of each element */</span>

    <span class="s0">int </span><span class="s1">flags;            </span><span class="s3">/* 
                           * how should be data interpreted. Valid 
                           * flags are CONTIGUOUS (1), F_CONTIGUOUS (2), 
                           * ALIGNED (0x100), NOTSWAPPED (0x200), and 
                           * WRITEABLE (0x400).  ARR_HAS_DESCR (0x800) 
                           * states that arrdescr field is present in 
                           * structure 
                           */</span>

    <span class="s1">npy_intp *shape;       </span><span class="s3">/* 
                            * A length-nd array of shape 
                            * information 
                            */</span>

    <span class="s1">npy_intp *strides;    </span><span class="s3">/* A length-nd array of stride information */</span>

    <span class="s0">void </span><span class="s1">*data;           </span><span class="s3">/* A pointer to the first element of the array */</span>

    <span class="s1">PyObject *descr;      </span><span class="s3">/* 
                           * A list of fields or NULL (ignored if flags 
                           * does not have ARR_HAS_DESCR flag set) 
                           */</span>
<span class="s1">} PyArrayInterface;</span>

<span class="s3">/* 
 * This is a function for hooking into the PyDataMem_NEW/FREE/RENEW functions. 
 * See the documentation for PyDataMem_SetEventHook. 
 */</span>
<span class="s0">typedef void </span><span class="s1">(PyDataMem_EventHookFunc)(</span><span class="s0">void </span><span class="s1">*inp, </span><span class="s0">void </span><span class="s1">*outp, size_t size,</span>
                                       <span class="s0">void </span><span class="s1">*user_data);</span>


<span class="s3">/* 
 * PyArray_DTypeMeta related definitions. 
 * 
 * As of now, this API is preliminary and will be extended as necessary. 
 */</span>
<span class="s0">#if </span><span class="s1">defined(NPY_INTERNAL_BUILD) &amp;&amp; NPY_INTERNAL_BUILD</span>
    <span class="s3">/* 
     * The Structures defined in this block are currently considered 
     * private API and may change without warning! 
     * Part of this (at least the size) is exepcted to be public API without 
     * further modifications. 
     */</span>
    <span class="s3">/* TODO: Make this definition public in the API, as soon as its settled */</span>
    <span class="s1">NPY_NO_EXPORT </span><span class="s0">extern </span><span class="s1">PyTypeObject PyArrayDTypeMeta_Type;</span>

    <span class="s3">/* 
     * While NumPy DTypes would not need to be heap types the plan is to 
     * make DTypes available in Python at which point they will be heap types. 
     * Since we also wish to add fields to the DType class, this looks like 
     * a typical instance definition, but with PyHeapTypeObject instead of 
     * only the PyObject_HEAD. 
     * This must only be exposed very extremely careful consideration, since 
     * it is a fairly complex construct which may be better to allow 
     * refactoring of. 
     */</span>
    <span class="s0">typedef struct </span><span class="s1">{</span>
        <span class="s1">PyHeapTypeObject super;</span>

        <span class="s3">/* 
         * Most DTypes will have a singleton default instance, for the 
         * parametric legacy DTypes (bytes, string, void, datetime) this 
         * may be a pointer to the *prototype* instance? 
         */</span>
        <span class="s1">PyArray_Descr *singleton;</span>
        <span class="s3">/* Copy of the legacy DTypes type number, usually invalid. */</span>
        <span class="s0">int </span><span class="s1">type_num;</span>

        <span class="s3">/* The type object of the scalar instances (may be NULL?) */</span>
        <span class="s1">PyTypeObject *scalar_type;</span>
        <span class="s3">/* 
         * DType flags to signal legacy, parametric, or 
         * abstract.  But plenty of space for additional information/flags. 
         */</span>
        <span class="s1">npy_uint64 flags;</span>

        <span class="s3">/* 
         * Use indirection in order to allow a fixed size for this struct. 
         * A stable ABI size makes creating a static DType less painful 
         * while also ensuring flexibility for all opaque API (with one 
         * indirection due the pointer lookup). 
         */</span>
        <span class="s0">void </span><span class="s1">*dt_slots;</span>
        <span class="s0">void </span><span class="s1">*reserved[</span><span class="s4">3</span><span class="s1">];</span>
    <span class="s1">} PyArray_DTypeMeta;</span>

<span class="s0">#endif  </span><span class="s3">/* NPY_INTERNAL_BUILD */</span>


<span class="s3">/* 
 * Use the keyword NPY_DEPRECATED_INCLUDES to ensure that the header files 
 * npy_*_*_deprecated_api.h are only included from here and nowhere else. 
 */</span>
<span class="s0">#ifdef </span><span class="s1">NPY_DEPRECATED_INCLUDES</span>
<span class="s0">#error </span><span class="s2">&quot;Do not use the reserved keyword NPY_DEPRECATED_INCLUDES.&quot;</span>
<span class="s0">#endif</span>
<span class="s0">#define </span><span class="s1">NPY_DEPRECATED_INCLUDES</span>
<span class="s0">#if </span><span class="s1">!defined(NPY_NO_DEPRECATED_API) || \</span>
    <span class="s1">(NPY_NO_DEPRECATED_API &lt; NPY_1_7_API_VERSION)</span>
<span class="s0">#include </span><span class="s2">&quot;npy_1_7_deprecated_api.h&quot;</span>
<span class="s0">#endif</span>
<span class="s3">/* 
 * There is no file npy_1_8_deprecated_api.h since there are no additional 
 * deprecated API features in NumPy 1.8. 
 * 
 * Note to maintainers: insert code like the following in future NumPy 
 * versions. 
 * 
 * #if !defined(NPY_NO_DEPRECATED_API) || \ 
 *     (NPY_NO_DEPRECATED_API &lt; NPY_1_9_API_VERSION) 
 * #include &quot;npy_1_9_deprecated_api.h&quot; 
 * #endif 
 */</span>
<span class="s0">#undef </span><span class="s1">NPY_DEPRECATED_INCLUDES</span>

<span class="s0">#endif  </span><span class="s3">/* NUMPY_CORE_INCLUDE_NUMPY_NDARRAYTYPES_H_ */</span>
</pre>
</body>
</html>