<html>
<head>
<title>sdist.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sdist.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;distutils.command.sdist 
 
Implements the Distutils 'sdist' command (create a source distribution).&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">glob </span><span class="s2">import </span><span class="s1">glob</span>
<span class="s2">from </span><span class="s1">warnings </span><span class="s2">import </span><span class="s1">warn</span>

<span class="s2">from </span><span class="s1">distutils.core </span><span class="s2">import </span><span class="s1">Command</span>
<span class="s2">from </span><span class="s1">distutils </span><span class="s2">import </span><span class="s1">dir_util</span>
<span class="s2">from </span><span class="s1">distutils </span><span class="s2">import </span><span class="s1">file_util</span>
<span class="s2">from </span><span class="s1">distutils </span><span class="s2">import </span><span class="s1">archive_util</span>
<span class="s2">from </span><span class="s1">distutils.text_file </span><span class="s2">import </span><span class="s1">TextFile</span>
<span class="s2">from </span><span class="s1">distutils.filelist </span><span class="s2">import </span><span class="s1">FileList</span>
<span class="s2">from </span><span class="s1">distutils </span><span class="s2">import </span><span class="s1">log</span>
<span class="s2">from </span><span class="s1">distutils.util </span><span class="s2">import </span><span class="s1">convert_path</span>
<span class="s2">from </span><span class="s1">distutils.errors </span><span class="s2">import </span><span class="s1">DistutilsTemplateError</span><span class="s2">, </span><span class="s1">DistutilsOptionError</span>


<span class="s2">def </span><span class="s1">show_formats():</span>
    <span class="s0">&quot;&quot;&quot;Print all possible values for the 'formats' option (used by 
    the &quot;--help-formats&quot; command-line option). 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">distutils.fancy_getopt </span><span class="s2">import </span><span class="s1">FancyGetopt</span>
    <span class="s2">from </span><span class="s1">distutils.archive_util </span><span class="s2">import </span><span class="s1">ARCHIVE_FORMATS</span>
    <span class="s1">formats = []</span>
    <span class="s2">for </span><span class="s1">format </span><span class="s2">in </span><span class="s1">ARCHIVE_FORMATS.keys():</span>
        <span class="s1">formats.append((</span><span class="s3">&quot;formats=&quot; </span><span class="s1">+ format</span><span class="s2">, None,</span>
                        <span class="s1">ARCHIVE_FORMATS[format][</span><span class="s4">2</span><span class="s1">]))</span>
    <span class="s1">formats.sort()</span>
    <span class="s1">FancyGetopt(formats).print_help(</span>
        <span class="s3">&quot;List of available source distribution formats:&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">sdist(Command):</span>

    <span class="s1">description = </span><span class="s3">&quot;create a source distribution (tarball, zip file, etc.)&quot;</span>

    <span class="s2">def </span><span class="s1">checking_metadata(self):</span>
        <span class="s0">&quot;&quot;&quot;Callable used for the check sub-command. 
 
        Placed here so user_options can view it&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.metadata_check</span>

    <span class="s1">user_options = [</span>
        <span class="s1">(</span><span class="s3">'template='</span><span class="s2">, </span><span class="s3">'t'</span><span class="s2">,</span>
         <span class="s3">&quot;name of manifest template file [default: MANIFEST.in]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'manifest='</span><span class="s2">, </span><span class="s3">'m'</span><span class="s2">,</span>
         <span class="s3">&quot;name of manifest file [default: MANIFEST]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'use-defaults'</span><span class="s2">, None,</span>
         <span class="s3">&quot;include the default file set in the manifest &quot;</span>
         <span class="s3">&quot;[default; disable with --no-defaults]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'no-defaults'</span><span class="s2">, None,</span>
         <span class="s3">&quot;don't include the default file set&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'prune'</span><span class="s2">, None,</span>
         <span class="s3">&quot;specifically exclude files/directories that should not be &quot;</span>
         <span class="s3">&quot;distributed (build tree, RCS/CVS dirs, etc.) &quot;</span>
         <span class="s3">&quot;[default; disable with --no-prune]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'no-prune'</span><span class="s2">, None,</span>
         <span class="s3">&quot;don't automatically exclude anything&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'manifest-only'</span><span class="s2">, </span><span class="s3">'o'</span><span class="s2">,</span>
         <span class="s3">&quot;just regenerate the manifest and then stop &quot;</span>
         <span class="s3">&quot;(implies --force-manifest)&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'force-manifest'</span><span class="s2">, </span><span class="s3">'f'</span><span class="s2">,</span>
         <span class="s3">&quot;forcibly regenerate the manifest and carry on as usual. &quot;</span>
         <span class="s3">&quot;Deprecated: now the manifest is always regenerated.&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'formats='</span><span class="s2">, None,</span>
         <span class="s3">&quot;formats for source distribution (comma-separated list)&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'keep-temp'</span><span class="s2">, </span><span class="s3">'k'</span><span class="s2">,</span>
         <span class="s3">&quot;keep the distribution tree around after creating &quot; </span><span class="s1">+</span>
         <span class="s3">&quot;archive file(s)&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'dist-dir='</span><span class="s2">, </span><span class="s3">'d'</span><span class="s2">,</span>
         <span class="s3">&quot;directory to put the source distribution archive(s) in &quot;</span>
         <span class="s3">&quot;[default: dist]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'metadata-check'</span><span class="s2">, None,</span>
         <span class="s3">&quot;Ensure that all required elements of meta-data &quot;</span>
         <span class="s3">&quot;are supplied. Warn if any missing. [default]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'owner='</span><span class="s2">, </span><span class="s3">'u'</span><span class="s2">,</span>
         <span class="s3">&quot;Owner name used when creating a tar file [default: current user]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'group='</span><span class="s2">, </span><span class="s3">'g'</span><span class="s2">,</span>
         <span class="s3">&quot;Group name used when creating a tar file [default: current group]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>

    <span class="s1">boolean_options = [</span><span class="s3">'use-defaults'</span><span class="s2">, </span><span class="s3">'prune'</span><span class="s2">,</span>
                       <span class="s3">'manifest-only'</span><span class="s2">, </span><span class="s3">'force-manifest'</span><span class="s2">,</span>
                       <span class="s3">'keep-temp'</span><span class="s2">, </span><span class="s3">'metadata-check'</span><span class="s1">]</span>

    <span class="s1">help_options = [</span>
        <span class="s1">(</span><span class="s3">'help-formats'</span><span class="s2">, None,</span>
         <span class="s3">&quot;list available distribution formats&quot;</span><span class="s2">, </span><span class="s1">show_formats)</span><span class="s2">,</span>
        <span class="s1">]</span>

    <span class="s1">negative_opt = {</span><span class="s3">'no-defaults'</span><span class="s1">: </span><span class="s3">'use-defaults'</span><span class="s2">,</span>
                    <span class="s3">'no-prune'</span><span class="s1">: </span><span class="s3">'prune' </span><span class="s1">}</span>

    <span class="s1">sub_commands = [(</span><span class="s3">'check'</span><span class="s2">, </span><span class="s1">checking_metadata)]</span>

    <span class="s1">READMES = (</span><span class="s3">'README'</span><span class="s2">, </span><span class="s3">'README.txt'</span><span class="s2">, </span><span class="s3">'README.rst'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">initialize_options(self):</span>
        <span class="s5"># 'template' and 'manifest' are, respectively, the names of</span>
        <span class="s5"># the manifest template and manifest file.</span>
        <span class="s1">self.template = </span><span class="s2">None</span>
        <span class="s1">self.manifest = </span><span class="s2">None</span>

        <span class="s5"># 'use_defaults': if true, we will include the default file set</span>
        <span class="s5"># in the manifest</span>
        <span class="s1">self.use_defaults = </span><span class="s4">1</span>
        <span class="s1">self.prune = </span><span class="s4">1</span>

        <span class="s1">self.manifest_only = </span><span class="s4">0</span>
        <span class="s1">self.force_manifest = </span><span class="s4">0</span>

        <span class="s1">self.formats = [</span><span class="s3">'gztar'</span><span class="s1">]</span>
        <span class="s1">self.keep_temp = </span><span class="s4">0</span>
        <span class="s1">self.dist_dir = </span><span class="s2">None</span>

        <span class="s1">self.archive_files = </span><span class="s2">None</span>
        <span class="s1">self.metadata_check = </span><span class="s4">1</span>
        <span class="s1">self.owner = </span><span class="s2">None</span>
        <span class="s1">self.group = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">finalize_options(self):</span>
        <span class="s2">if </span><span class="s1">self.manifest </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.manifest = </span><span class="s3">&quot;MANIFEST&quot;</span>
        <span class="s2">if </span><span class="s1">self.template </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.template = </span><span class="s3">&quot;MANIFEST.in&quot;</span>

        <span class="s1">self.ensure_string_list(</span><span class="s3">'formats'</span><span class="s1">)</span>

        <span class="s1">bad_format = archive_util.check_archive_formats(self.formats)</span>
        <span class="s2">if </span><span class="s1">bad_format:</span>
            <span class="s2">raise </span><span class="s1">DistutilsOptionError(</span>
                  <span class="s3">&quot;unknown archive format '%s'&quot; </span><span class="s1">% bad_format)</span>

        <span class="s2">if </span><span class="s1">self.dist_dir </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.dist_dir = </span><span class="s3">&quot;dist&quot;</span>

    <span class="s2">def </span><span class="s1">run(self):</span>
        <span class="s5"># 'filelist' contains the list of files that will make up the</span>
        <span class="s5"># manifest</span>
        <span class="s1">self.filelist = FileList()</span>

        <span class="s5"># Run sub commands</span>
        <span class="s2">for </span><span class="s1">cmd_name </span><span class="s2">in </span><span class="s1">self.get_sub_commands():</span>
            <span class="s1">self.run_command(cmd_name)</span>

        <span class="s5"># Do whatever it takes to get the list of files to process</span>
        <span class="s5"># (process the manifest template, read an existing manifest,</span>
        <span class="s5"># whatever).  File list is accumulated in 'self.filelist'.</span>
        <span class="s1">self.get_file_list()</span>

        <span class="s5"># If user just wanted us to regenerate the manifest, stop now.</span>
        <span class="s2">if </span><span class="s1">self.manifest_only:</span>
            <span class="s2">return</span>

        <span class="s5"># Otherwise, go ahead and create the source distribution tarball,</span>
        <span class="s5"># or zipfile, or whatever.</span>
        <span class="s1">self.make_distribution()</span>

    <span class="s2">def </span><span class="s1">check_metadata(self):</span>
        <span class="s0">&quot;&quot;&quot;Deprecated API.&quot;&quot;&quot;</span>
        <span class="s1">warn(</span><span class="s3">&quot;distutils.command.sdist.check_metadata is deprecated, </span><span class="s2">\ 
              </span><span class="s3">use the check command instead&quot;</span><span class="s2">, </span><span class="s1">PendingDeprecationWarning)</span>
        <span class="s1">check = self.distribution.get_command_obj(</span><span class="s3">'check'</span><span class="s1">)</span>
        <span class="s1">check.ensure_finalized()</span>
        <span class="s1">check.run()</span>

    <span class="s2">def </span><span class="s1">get_file_list(self):</span>
        <span class="s0">&quot;&quot;&quot;Figure out the list of files to include in the source 
        distribution, and put it in 'self.filelist'.  This might involve 
        reading the manifest template (and writing the manifest), or just 
        reading the manifest, or just using the default file set -- it all 
        depends on the user's options. 
        &quot;&quot;&quot;</span>
        <span class="s5"># new behavior when using a template:</span>
        <span class="s5"># the file list is recalculated every time because</span>
        <span class="s5"># even if MANIFEST.in or setup.py are not changed</span>
        <span class="s5"># the user might have added some files in the tree that</span>
        <span class="s5"># need to be included.</span>
        <span class="s5">#</span>
        <span class="s5">#  This makes --force the default and only behavior with templates.</span>
        <span class="s1">template_exists = os.path.isfile(self.template)</span>
        <span class="s2">if not </span><span class="s1">template_exists </span><span class="s2">and </span><span class="s1">self._manifest_is_not_generated():</span>
            <span class="s1">self.read_manifest()</span>
            <span class="s1">self.filelist.sort()</span>
            <span class="s1">self.filelist.remove_duplicates()</span>
            <span class="s2">return</span>

        <span class="s2">if not </span><span class="s1">template_exists:</span>
            <span class="s1">self.warn((</span><span class="s3">&quot;manifest template '%s' does not exist &quot; </span><span class="s1">+</span>
                        <span class="s3">&quot;(using default file list)&quot;</span><span class="s1">) %</span>
                        <span class="s1">self.template)</span>
        <span class="s1">self.filelist.findall()</span>

        <span class="s2">if </span><span class="s1">self.use_defaults:</span>
            <span class="s1">self.add_defaults()</span>

        <span class="s2">if </span><span class="s1">template_exists:</span>
            <span class="s1">self.read_template()</span>

        <span class="s2">if </span><span class="s1">self.prune:</span>
            <span class="s1">self.prune_file_list()</span>

        <span class="s1">self.filelist.sort()</span>
        <span class="s1">self.filelist.remove_duplicates()</span>
        <span class="s1">self.write_manifest()</span>

    <span class="s2">def </span><span class="s1">add_defaults(self):</span>
        <span class="s0">&quot;&quot;&quot;Add all the default files to self.filelist: 
          - README or README.txt 
          - setup.py 
          - test/test*.py 
          - all pure Python modules mentioned in setup script 
          - all files pointed by package_data (build_py) 
          - all files defined in data_files. 
          - all files defined as scripts. 
          - all C sources listed as part of extensions or C libraries 
            in the setup script (doesn't catch C headers!) 
        Warns if (README or README.txt) or setup.py are missing; everything 
        else is optional. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._add_defaults_standards()</span>
        <span class="s1">self._add_defaults_optional()</span>
        <span class="s1">self._add_defaults_python()</span>
        <span class="s1">self._add_defaults_data_files()</span>
        <span class="s1">self._add_defaults_ext()</span>
        <span class="s1">self._add_defaults_c_libs()</span>
        <span class="s1">self._add_defaults_scripts()</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_cs_path_exists(fspath):</span>
        <span class="s0">&quot;&quot;&quot; 
        Case-sensitive path existence check 
 
        &gt;&gt;&gt; sdist._cs_path_exists(__file__) 
        True 
        &gt;&gt;&gt; sdist._cs_path_exists(__file__.upper()) 
        False 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">os.path.exists(fspath):</span>
            <span class="s2">return False</span>
        <span class="s5"># make absolute so we always have a directory</span>
        <span class="s1">abspath = os.path.abspath(fspath)</span>
        <span class="s1">directory</span><span class="s2">, </span><span class="s1">filename = os.path.split(abspath)</span>
        <span class="s2">return </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">os.listdir(directory)</span>

    <span class="s2">def </span><span class="s1">_add_defaults_standards(self):</span>
        <span class="s1">standards = [self.READMES</span><span class="s2">, </span><span class="s1">self.distribution.script_name]</span>
        <span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">standards:</span>
            <span class="s2">if </span><span class="s1">isinstance(fn</span><span class="s2">, </span><span class="s1">tuple):</span>
                <span class="s1">alts = fn</span>
                <span class="s1">got_it = </span><span class="s2">False</span>
                <span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">alts:</span>
                    <span class="s2">if </span><span class="s1">self._cs_path_exists(fn):</span>
                        <span class="s1">got_it = </span><span class="s2">True</span>
                        <span class="s1">self.filelist.append(fn)</span>
                        <span class="s2">break</span>

                <span class="s2">if not </span><span class="s1">got_it:</span>
                    <span class="s1">self.warn(</span><span class="s3">&quot;standard file not found: should have one of &quot; </span><span class="s1">+</span>
                              <span class="s3">', '</span><span class="s1">.join(alts))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">self._cs_path_exists(fn):</span>
                    <span class="s1">self.filelist.append(fn)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self.warn(</span><span class="s3">&quot;standard file '%s' not found&quot; </span><span class="s1">% fn)</span>

    <span class="s2">def </span><span class="s1">_add_defaults_optional(self):</span>
        <span class="s1">optional = [</span><span class="s3">'test/test*.py'</span><span class="s2">, </span><span class="s3">'setup.cfg'</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">pattern </span><span class="s2">in </span><span class="s1">optional:</span>
            <span class="s1">files = filter(os.path.isfile</span><span class="s2">, </span><span class="s1">glob(pattern))</span>
            <span class="s1">self.filelist.extend(files)</span>

    <span class="s2">def </span><span class="s1">_add_defaults_python(self):</span>
        <span class="s5"># build_py is used to get:</span>
        <span class="s5">#  - python modules</span>
        <span class="s5">#  - files defined in package_data</span>
        <span class="s1">build_py = self.get_finalized_command(</span><span class="s3">'build_py'</span><span class="s1">)</span>

        <span class="s5"># getting python files</span>
        <span class="s2">if </span><span class="s1">self.distribution.has_pure_modules():</span>
            <span class="s1">self.filelist.extend(build_py.get_source_files())</span>

        <span class="s5"># getting package_data files</span>
        <span class="s5"># (computed in build_py.data_files by build_py.finalize_options)</span>
        <span class="s2">for </span><span class="s1">pkg</span><span class="s2">, </span><span class="s1">src_dir</span><span class="s2">, </span><span class="s1">build_dir</span><span class="s2">, </span><span class="s1">filenames </span><span class="s2">in </span><span class="s1">build_py.data_files:</span>
            <span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">filenames:</span>
                <span class="s1">self.filelist.append(os.path.join(src_dir</span><span class="s2">, </span><span class="s1">filename))</span>

    <span class="s2">def </span><span class="s1">_add_defaults_data_files(self):</span>
        <span class="s5"># getting distribution.data_files</span>
        <span class="s2">if </span><span class="s1">self.distribution.has_data_files():</span>
            <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">self.distribution.data_files:</span>
                <span class="s2">if </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">str):</span>
                    <span class="s5"># plain file</span>
                    <span class="s1">item = convert_path(item)</span>
                    <span class="s2">if </span><span class="s1">os.path.isfile(item):</span>
                        <span class="s1">self.filelist.append(item)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s5"># a (dirname, filenames) tuple</span>
                    <span class="s1">dirname</span><span class="s2">, </span><span class="s1">filenames = item</span>
                    <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">filenames:</span>
                        <span class="s1">f = convert_path(f)</span>
                        <span class="s2">if </span><span class="s1">os.path.isfile(f):</span>
                            <span class="s1">self.filelist.append(f)</span>

    <span class="s2">def </span><span class="s1">_add_defaults_ext(self):</span>
        <span class="s2">if </span><span class="s1">self.distribution.has_ext_modules():</span>
            <span class="s1">build_ext = self.get_finalized_command(</span><span class="s3">'build_ext'</span><span class="s1">)</span>
            <span class="s1">self.filelist.extend(build_ext.get_source_files())</span>

    <span class="s2">def </span><span class="s1">_add_defaults_c_libs(self):</span>
        <span class="s2">if </span><span class="s1">self.distribution.has_c_libraries():</span>
            <span class="s1">build_clib = self.get_finalized_command(</span><span class="s3">'build_clib'</span><span class="s1">)</span>
            <span class="s1">self.filelist.extend(build_clib.get_source_files())</span>

    <span class="s2">def </span><span class="s1">_add_defaults_scripts(self):</span>
        <span class="s2">if </span><span class="s1">self.distribution.has_scripts():</span>
            <span class="s1">build_scripts = self.get_finalized_command(</span><span class="s3">'build_scripts'</span><span class="s1">)</span>
            <span class="s1">self.filelist.extend(build_scripts.get_source_files())</span>

    <span class="s2">def </span><span class="s1">read_template(self):</span>
        <span class="s0">&quot;&quot;&quot;Read and parse manifest template file named by self.template. 
 
        (usually &quot;MANIFEST.in&quot;) The parsing and processing is done by 
        'self.filelist', which updates itself accordingly. 
        &quot;&quot;&quot;</span>
        <span class="s1">log.info(</span><span class="s3">&quot;reading manifest template '%s'&quot;</span><span class="s2">, </span><span class="s1">self.template)</span>
        <span class="s1">template = TextFile(self.template</span><span class="s2">, </span><span class="s1">strip_comments=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">skip_blanks=</span><span class="s4">1</span><span class="s2">,</span>
                            <span class="s1">join_lines=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">lstrip_ws=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">rstrip_ws=</span><span class="s4">1</span><span class="s2">,</span>
                            <span class="s1">collapse_join=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">while True</span><span class="s1">:</span>
                <span class="s1">line = template.readline()</span>
                <span class="s2">if </span><span class="s1">line </span><span class="s2">is None</span><span class="s1">:            </span><span class="s5"># end of file</span>
                    <span class="s2">break</span>

                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">self.filelist.process_template_line(line)</span>
                <span class="s5"># the call above can raise a DistutilsTemplateError for</span>
                <span class="s5"># malformed lines, or a ValueError from the lower-level</span>
                <span class="s5"># convert_path function</span>
                <span class="s2">except </span><span class="s1">(DistutilsTemplateError</span><span class="s2">, </span><span class="s1">ValueError) </span><span class="s2">as </span><span class="s1">msg:</span>
                    <span class="s1">self.warn(</span><span class="s3">&quot;%s, line %d: %s&quot; </span><span class="s1">% (template.filename</span><span class="s2">,</span>
                                                   <span class="s1">template.current_line</span><span class="s2">,</span>
                                                   <span class="s1">msg))</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">template.close()</span>

    <span class="s2">def </span><span class="s1">prune_file_list(self):</span>
        <span class="s0">&quot;&quot;&quot;Prune off branches that might slip into the file list as created 
        by 'read_template()', but really don't belong there: 
          * the build tree (typically &quot;build&quot;) 
          * the release tree itself (only an issue if we ran &quot;sdist&quot; 
            previously with --keep-temp, or it aborted) 
          * any RCS, CVS, .svn, .hg, .git, .bzr, _darcs directories 
        &quot;&quot;&quot;</span>
        <span class="s1">build = self.get_finalized_command(</span><span class="s3">'build'</span><span class="s1">)</span>
        <span class="s1">base_dir = self.distribution.get_fullname()</span>

        <span class="s1">self.filelist.exclude_pattern(</span><span class="s2">None, </span><span class="s1">prefix=build.build_base)</span>
        <span class="s1">self.filelist.exclude_pattern(</span><span class="s2">None, </span><span class="s1">prefix=base_dir)</span>

        <span class="s2">if </span><span class="s1">sys.platform == </span><span class="s3">'win32'</span><span class="s1">:</span>
            <span class="s1">seps = </span><span class="s3">r'/|\\'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">seps = </span><span class="s3">'/'</span>

        <span class="s1">vcs_dirs = [</span><span class="s3">'RCS'</span><span class="s2">, </span><span class="s3">'CVS'</span><span class="s2">, </span><span class="s3">r'\.svn'</span><span class="s2">, </span><span class="s3">r'\.hg'</span><span class="s2">, </span><span class="s3">r'\.git'</span><span class="s2">, </span><span class="s3">r'\.bzr'</span><span class="s2">,</span>
                    <span class="s3">'_darcs'</span><span class="s1">]</span>
        <span class="s1">vcs_ptrn = </span><span class="s3">r'(^|%s)(%s)(%s).*' </span><span class="s1">% (seps</span><span class="s2">, </span><span class="s3">'|'</span><span class="s1">.join(vcs_dirs)</span><span class="s2">, </span><span class="s1">seps)</span>
        <span class="s1">self.filelist.exclude_pattern(vcs_ptrn</span><span class="s2">, </span><span class="s1">is_regex=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">write_manifest(self):</span>
        <span class="s0">&quot;&quot;&quot;Write the file list in 'self.filelist' (presumably as filled in 
        by 'add_defaults()' and 'read_template()') to the manifest file 
        named by 'self.manifest'. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._manifest_is_not_generated():</span>
            <span class="s1">log.info(</span><span class="s3">&quot;not writing to manually maintained &quot;</span>
                     <span class="s3">&quot;manifest file '%s'&quot; </span><span class="s1">% self.manifest)</span>
            <span class="s2">return</span>

        <span class="s1">content = self.filelist.files[:]</span>
        <span class="s1">content.insert(</span><span class="s4">0</span><span class="s2">, </span><span class="s3">'# file GENERATED by distutils, do NOT edit'</span><span class="s1">)</span>
        <span class="s1">self.execute(file_util.write_file</span><span class="s2">, </span><span class="s1">(self.manifest</span><span class="s2">, </span><span class="s1">content)</span><span class="s2">,</span>
                     <span class="s3">&quot;writing manifest file '%s'&quot; </span><span class="s1">% self.manifest)</span>

    <span class="s2">def </span><span class="s1">_manifest_is_not_generated(self):</span>
        <span class="s5"># check for special comment used in 3.1.3 and higher</span>
        <span class="s2">if not </span><span class="s1">os.path.isfile(self.manifest):</span>
            <span class="s2">return False</span>

        <span class="s1">fp = open(self.manifest)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">first_line = fp.readline()</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">fp.close()</span>
        <span class="s2">return </span><span class="s1">first_line != </span><span class="s3">'# file GENERATED by distutils, do NOT edit</span><span class="s2">\n</span><span class="s3">'</span>

    <span class="s2">def </span><span class="s1">read_manifest(self):</span>
        <span class="s0">&quot;&quot;&quot;Read the manifest file (named by 'self.manifest') and use it to 
        fill in 'self.filelist', the list of files to include in the source 
        distribution. 
        &quot;&quot;&quot;</span>
        <span class="s1">log.info(</span><span class="s3">&quot;reading manifest file '%s'&quot;</span><span class="s2">, </span><span class="s1">self.manifest)</span>
        <span class="s2">with </span><span class="s1">open(self.manifest) </span><span class="s2">as </span><span class="s1">manifest:</span>
            <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">manifest:</span>
                <span class="s5"># ignore comments and blank lines</span>
                <span class="s1">line = line.strip()</span>
                <span class="s2">if </span><span class="s1">line.startswith(</span><span class="s3">'#'</span><span class="s1">) </span><span class="s2">or not </span><span class="s1">line:</span>
                    <span class="s2">continue</span>
                <span class="s1">self.filelist.append(line)</span>

    <span class="s2">def </span><span class="s1">make_release_tree(self</span><span class="s2">, </span><span class="s1">base_dir</span><span class="s2">, </span><span class="s1">files):</span>
        <span class="s0">&quot;&quot;&quot;Create the directory tree that will become the source 
        distribution archive.  All directories implied by the filenames in 
        'files' are created under 'base_dir', and then we hard link or copy 
        (if hard linking is unavailable) those files into place. 
        Essentially, this duplicates the developer's source tree, but in a 
        directory named after the distribution, containing only the files 
        to be distributed. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Create all the directories under 'base_dir' necessary to</span>
        <span class="s5"># put 'files' there; the 'mkpath()' is just so we don't die</span>
        <span class="s5"># if the manifest happens to be empty.</span>
        <span class="s1">self.mkpath(base_dir)</span>
        <span class="s1">dir_util.create_tree(base_dir</span><span class="s2">, </span><span class="s1">files</span><span class="s2">, </span><span class="s1">dry_run=self.dry_run)</span>

        <span class="s5"># And walk over the list of files, either making a hard link (if</span>
        <span class="s5"># os.link exists) to each one that doesn't already exist in its</span>
        <span class="s5"># corresponding location under 'base_dir', or copying each file</span>
        <span class="s5"># that's out-of-date in 'base_dir'.  (Usually, all files will be</span>
        <span class="s5"># out-of-date, because by default we blow away 'base_dir' when</span>
        <span class="s5"># we're done making the distribution archives.)</span>

        <span class="s2">if </span><span class="s1">hasattr(os</span><span class="s2">, </span><span class="s3">'link'</span><span class="s1">):        </span><span class="s5"># can make hard links on this system</span>
            <span class="s1">link = </span><span class="s3">'hard'</span>
            <span class="s1">msg = </span><span class="s3">&quot;making hard links in %s...&quot; </span><span class="s1">% base_dir</span>
        <span class="s2">else</span><span class="s1">:                           </span><span class="s5"># nope, have to copy</span>
            <span class="s1">link = </span><span class="s2">None</span>
            <span class="s1">msg = </span><span class="s3">&quot;copying files to %s...&quot; </span><span class="s1">% base_dir</span>

        <span class="s2">if not </span><span class="s1">files:</span>
            <span class="s1">log.warn(</span><span class="s3">&quot;no files to distribute -- empty manifest?&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">log.info(msg)</span>
        <span class="s2">for </span><span class="s1">file </span><span class="s2">in </span><span class="s1">files:</span>
            <span class="s2">if not </span><span class="s1">os.path.isfile(file):</span>
                <span class="s1">log.warn(</span><span class="s3">&quot;'%s' not a regular file -- skipping&quot;</span><span class="s2">, </span><span class="s1">file)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">dest = os.path.join(base_dir</span><span class="s2">, </span><span class="s1">file)</span>
                <span class="s1">self.copy_file(file</span><span class="s2">, </span><span class="s1">dest</span><span class="s2">, </span><span class="s1">link=link)</span>

        <span class="s1">self.distribution.metadata.write_pkg_info(base_dir)</span>

    <span class="s2">def </span><span class="s1">make_distribution(self):</span>
        <span class="s0">&quot;&quot;&quot;Create the source distribution(s).  First, we create the release 
        tree with 'make_release_tree()'; then, we create all required 
        archive files (according to 'self.formats') from the release tree. 
        Finally, we clean up by blowing away the release tree (unless 
        'self.keep_temp' is true).  The list of archive files created is 
        stored so it can be retrieved later by 'get_archive_files()'. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Don't warn about missing meta-data here -- should be (and is!)</span>
        <span class="s5"># done elsewhere.</span>
        <span class="s1">base_dir = self.distribution.get_fullname()</span>
        <span class="s1">base_name = os.path.join(self.dist_dir</span><span class="s2">, </span><span class="s1">base_dir)</span>

        <span class="s1">self.make_release_tree(base_dir</span><span class="s2">, </span><span class="s1">self.filelist.files)</span>
        <span class="s1">archive_files = []              </span><span class="s5"># remember names of files we create</span>
        <span class="s5"># tar archive must be created last to avoid overwrite and remove</span>
        <span class="s2">if </span><span class="s3">'tar' </span><span class="s2">in </span><span class="s1">self.formats:</span>
            <span class="s1">self.formats.append(self.formats.pop(self.formats.index(</span><span class="s3">'tar'</span><span class="s1">)))</span>

        <span class="s2">for </span><span class="s1">fmt </span><span class="s2">in </span><span class="s1">self.formats:</span>
            <span class="s1">file = self.make_archive(base_name</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">base_dir=base_dir</span><span class="s2">,</span>
                                     <span class="s1">owner=self.owner</span><span class="s2">, </span><span class="s1">group=self.group)</span>
            <span class="s1">archive_files.append(file)</span>
            <span class="s1">self.distribution.dist_files.append((</span><span class="s3">'sdist'</span><span class="s2">, </span><span class="s3">''</span><span class="s2">, </span><span class="s1">file))</span>

        <span class="s1">self.archive_files = archive_files</span>

        <span class="s2">if not </span><span class="s1">self.keep_temp:</span>
            <span class="s1">dir_util.remove_tree(base_dir</span><span class="s2">, </span><span class="s1">dry_run=self.dry_run)</span>

    <span class="s2">def </span><span class="s1">get_archive_files(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the list of archive files created when the command 
        was run, or None if the command hasn't run yet. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.archive_files</span>
</pre>
</body>
</html>