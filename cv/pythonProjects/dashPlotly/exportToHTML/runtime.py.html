<html>
<head>
<title>runtime.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
runtime.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;The runtime functions and state used by compiled templates.&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">typing </span><span class="s2">as </span><span class="s1">t</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">abc</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">chain</span>

<span class="s2">from </span><span class="s1">markupsafe </span><span class="s2">import </span><span class="s1">escape  </span><span class="s3"># noqa: F401</span>
<span class="s2">from </span><span class="s1">markupsafe </span><span class="s2">import </span><span class="s1">Markup</span>
<span class="s2">from </span><span class="s1">markupsafe </span><span class="s2">import </span><span class="s1">soft_str</span>

<span class="s2">from </span><span class="s1">.async_utils </span><span class="s2">import </span><span class="s1">auto_aiter</span>
<span class="s2">from </span><span class="s1">.async_utils </span><span class="s2">import </span><span class="s1">auto_await  </span><span class="s3"># noqa: F401</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">TemplateNotFound  </span><span class="s3"># noqa: F401</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">TemplateRuntimeError  </span><span class="s3"># noqa: F401</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">UndefinedError</span>
<span class="s2">from </span><span class="s1">.nodes </span><span class="s2">import </span><span class="s1">EvalContext</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">_PassArg</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">concat</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">internalcode</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">missing</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">Namespace  </span><span class="s3"># noqa: F401</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">object_type_repr</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">pass_eval_context</span>

<span class="s1">V = t.TypeVar(</span><span class="s4">&quot;V&quot;</span><span class="s1">)</span>
<span class="s1">F = t.TypeVar(</span><span class="s4">&quot;F&quot;</span><span class="s2">, </span><span class="s1">bound=t.Callable[...</span><span class="s2">, </span><span class="s1">t.Any])</span>

<span class="s2">if </span><span class="s1">t.TYPE_CHECKING:</span>
    <span class="s2">import </span><span class="s1">logging</span>
    <span class="s2">import </span><span class="s1">typing_extensions </span><span class="s2">as </span><span class="s1">te</span>
    <span class="s2">from </span><span class="s1">.environment </span><span class="s2">import </span><span class="s1">Environment</span>

    <span class="s2">class </span><span class="s1">LoopRenderFunc(te.Protocol):</span>
        <span class="s2">def </span><span class="s1">__call__(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">reciter: t.Iterable[V]</span><span class="s2">,</span>
            <span class="s1">loop_render_func: </span><span class="s4">&quot;LoopRenderFunc&quot;</span><span class="s2">,</span>
            <span class="s1">depth: int = </span><span class="s5">0</span><span class="s2">,</span>
        <span class="s1">) -&gt; str:</span>
            <span class="s1">...</span>


<span class="s3"># these variables are exported to the template runtime</span>
<span class="s1">exported = [</span>
    <span class="s4">&quot;LoopContext&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;TemplateReference&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;Macro&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;Markup&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;TemplateRuntimeError&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;missing&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;concat&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;escape&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;markup_join&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;str_join&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;identity&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;TemplateNotFound&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;Namespace&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;Undefined&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;internalcode&quot;</span><span class="s2">,</span>
<span class="s1">]</span>
<span class="s1">async_exported = [</span>
    <span class="s4">&quot;AsyncLoopContext&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;auto_aiter&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;auto_await&quot;</span><span class="s2">,</span>
<span class="s1">]</span>


<span class="s2">def </span><span class="s1">identity(x: V) -&gt; V:</span>
    <span class="s0">&quot;&quot;&quot;Returns its argument. Useful for certain things in the 
    environment. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">x</span>


<span class="s2">def </span><span class="s1">markup_join(seq: t.Iterable[t.Any]) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Concatenation that escapes if necessary and converts to string.&quot;&quot;&quot;</span>
    <span class="s1">buf = []</span>
    <span class="s1">iterator = map(soft_str</span><span class="s2">, </span><span class="s1">seq)</span>
    <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">iterator:</span>
        <span class="s1">buf.append(arg)</span>
        <span class="s2">if </span><span class="s1">hasattr(arg</span><span class="s2">, </span><span class="s4">&quot;__html__&quot;</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">Markup(</span><span class="s4">&quot;&quot;</span><span class="s1">).join(chain(buf</span><span class="s2">, </span><span class="s1">iterator))</span>
    <span class="s2">return </span><span class="s1">concat(buf)</span>


<span class="s2">def </span><span class="s1">str_join(seq: t.Iterable[t.Any]) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Simple args to string conversion and concatenation.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">concat(map(str</span><span class="s2">, </span><span class="s1">seq))</span>


<span class="s2">def </span><span class="s1">unicode_join(seq: t.Iterable[t.Any]) -&gt; str:</span>
    <span class="s2">import </span><span class="s1">warnings</span>

    <span class="s1">warnings.warn(</span>
        <span class="s4">&quot;This template must be recompiled with at least Jinja 3.0, or&quot;</span>
        <span class="s4">&quot; it will fail in Jinja 3.1.&quot;</span><span class="s2">,</span>
        <span class="s1">DeprecationWarning</span><span class="s2">,</span>
        <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">str_join(seq)</span>


<span class="s2">def </span><span class="s1">new_context(</span>
    <span class="s1">environment: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">,</span>
    <span class="s1">template_name: t.Optional[str]</span><span class="s2">,</span>
    <span class="s1">blocks: t.Dict[str</span><span class="s2">, </span><span class="s1">t.Callable[[</span><span class="s4">&quot;Context&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">t.Iterator[str]]]</span><span class="s2">,</span>
    <span class="s1">vars: t.Optional[t.Dict[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
    <span class="s1">shared: bool = </span><span class="s2">False,</span>
    <span class="s1">globals: t.Optional[t.MutableMapping[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
    <span class="s1">locals: t.Optional[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;Context&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Internal helper for context creation.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">vars </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">vars = {}</span>
    <span class="s2">if </span><span class="s1">shared:</span>
        <span class="s1">parent = vars</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">parent = dict(globals </span><span class="s2">or </span><span class="s1">()</span><span class="s2">, </span><span class="s1">**vars)</span>
    <span class="s2">if </span><span class="s1">locals:</span>
        <span class="s3"># if the parent is shared a copy should be created because</span>
        <span class="s3"># we don't want to modify the dict passed</span>
        <span class="s2">if </span><span class="s1">shared:</span>
            <span class="s1">parent = dict(parent)</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">locals.items():</span>
            <span class="s2">if </span><span class="s1">value </span><span class="s2">is not </span><span class="s1">missing:</span>
                <span class="s1">parent[key] = value</span>
    <span class="s2">return </span><span class="s1">environment.context_class(</span>
        <span class="s1">environment</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">template_name</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">globals=globals</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TemplateReference:</span>
    <span class="s0">&quot;&quot;&quot;The `self` in templates.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.__context = context</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">name: str) -&gt; t.Any:</span>
        <span class="s1">blocks = self.__context.blocks[name]</span>
        <span class="s2">return </span><span class="s1">BlockReference(name</span><span class="s2">, </span><span class="s1">self.__context</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s4">f&quot;&lt;</span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">} {</span><span class="s1">self.__context.name</span><span class="s2">!r}</span><span class="s4">&gt;&quot;</span>


<span class="s2">def </span><span class="s1">_dict_method_all(dict_method: F) -&gt; F:</span>
    <span class="s1">@functools.wraps(dict_method)</span>
    <span class="s2">def </span><span class="s1">f_all(self: </span><span class="s4">&quot;Context&quot;</span><span class="s1">) -&gt; t.Any:</span>
        <span class="s2">return </span><span class="s1">dict_method(self.get_all())</span>

    <span class="s2">return </span><span class="s1">t.cast(F</span><span class="s2">, </span><span class="s1">f_all)</span>


<span class="s1">@abc.Mapping.register</span>
<span class="s2">class </span><span class="s1">Context:</span>
    <span class="s0">&quot;&quot;&quot;The template context holds the variables of a template.  It stores the 
    values passed to the template and also the names the template exports. 
    Creating instances is neither supported nor useful as it's created 
    automatically at various stages of the template evaluation and should not 
    be created by hand. 
 
    The context is immutable.  Modifications on :attr:`parent` **must not** 
    happen and modifications on :attr:`vars` are allowed from generated 
    template code only.  Template filters and global functions marked as 
    :func:`pass_context` get the active context passed as first argument 
    and are allowed to access the context read-only. 
 
    The template context supports read only dict operations (`get`, 
    `keys`, `values`, `items`, `iterkeys`, `itervalues`, `iteritems`, 
    `__getitem__`, `__contains__`).  Additionally there is a :meth:`resolve` 
    method that doesn't fail with a `KeyError` but returns an 
    :class:`Undefined` object for missing variables. 
    &quot;&quot;&quot;</span>

    <span class="s1">_legacy_resolve_mode: t.ClassVar[bool] = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__init_subclass__(cls) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s4">&quot;resolve_or_missing&quot; </span><span class="s2">in </span><span class="s1">cls.__dict__:</span>
            <span class="s3"># If the subclass overrides resolve_or_missing it opts in to</span>
            <span class="s3"># modern mode no matter what.</span>
            <span class="s1">cls._legacy_resolve_mode = </span><span class="s2">False</span>
        <span class="s2">elif </span><span class="s4">&quot;resolve&quot; </span><span class="s2">in </span><span class="s1">cls.__dict__ </span><span class="s2">or </span><span class="s1">cls._legacy_resolve_mode:</span>
            <span class="s3"># If the subclass overrides resolve, or if its base is</span>
            <span class="s3"># already in legacy mode, warn about legacy behavior.</span>
            <span class="s2">import </span><span class="s1">warnings</span>

            <span class="s1">warnings.warn(</span>
                <span class="s4">&quot;Overriding 'resolve' is deprecated and will not have&quot;</span>
                <span class="s4">&quot; the expected behavior in Jinja 3.1. Override&quot;</span>
                <span class="s4">&quot; 'resolve_or_missing' instead &quot;</span><span class="s2">,</span>
                <span class="s1">DeprecationWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">cls._legacy_resolve_mode = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">environment: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">,</span>
        <span class="s1">parent: t.Dict[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">,</span>
        <span class="s1">name: t.Optional[str]</span><span class="s2">,</span>
        <span class="s1">blocks: t.Dict[str</span><span class="s2">, </span><span class="s1">t.Callable[[</span><span class="s4">&quot;Context&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">t.Iterator[str]]]</span><span class="s2">,</span>
        <span class="s1">globals: t.Optional[t.MutableMapping[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">self.parent = parent</span>
        <span class="s1">self.vars: t.Dict[str</span><span class="s2">, </span><span class="s1">t.Any] = {}</span>
        <span class="s1">self.environment: </span><span class="s4">&quot;Environment&quot; </span><span class="s1">= environment</span>
        <span class="s1">self.eval_ctx = EvalContext(self.environment</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s1">self.exported_vars: t.Set[str] = set()</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.globals_keys = set() </span><span class="s2">if </span><span class="s1">globals </span><span class="s2">is None else </span><span class="s1">set(globals)</span>

        <span class="s3"># create the initial mapping of blocks.  Whenever template inheritance</span>
        <span class="s3"># takes place the runtime will update this mapping with the new blocks</span>
        <span class="s3"># from the template.</span>
        <span class="s1">self.blocks = {k: [v] </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">blocks.items()}</span>

    <span class="s2">def </span><span class="s1">super(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">current: t.Callable[[</span><span class="s4">&quot;Context&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">t.Iterator[str]]</span>
    <span class="s1">) -&gt; t.Union[</span><span class="s4">&quot;BlockReference&quot;</span><span class="s2">, </span><span class="s4">&quot;Undefined&quot;</span><span class="s1">]:</span>
        <span class="s0">&quot;&quot;&quot;Render a parent block.&quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">blocks = self.blocks[name]</span>
            <span class="s1">index = blocks.index(current) + </span><span class="s5">1</span>
            <span class="s1">blocks[index]</span>
        <span class="s2">except </span><span class="s1">LookupError:</span>
            <span class="s2">return </span><span class="s1">self.environment.undefined(</span>
                <span class="s4">f&quot;there is no parent block called </span><span class="s2">{</span><span class="s1">name</span><span class="s2">!r}</span><span class="s4">.&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;super&quot;</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">BlockReference(name</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">index)</span>

    <span class="s2">def </span><span class="s1">get(self</span><span class="s2">, </span><span class="s1">key: str</span><span class="s2">, </span><span class="s1">default: t.Any = </span><span class="s2">None</span><span class="s1">) -&gt; t.Any:</span>
        <span class="s0">&quot;&quot;&quot;Look up a variable by name, or return a default if the key is 
        not found. 
 
        :param key: The variable name to look up. 
        :param default: The value to return if the key is not found. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self[key]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">return </span><span class="s1">default</span>

    <span class="s2">def </span><span class="s1">resolve(self</span><span class="s2">, </span><span class="s1">key: str) -&gt; t.Union[t.Any</span><span class="s2">, </span><span class="s4">&quot;Undefined&quot;</span><span class="s1">]:</span>
        <span class="s0">&quot;&quot;&quot;Look up a variable by name, or return an :class:`Undefined` 
        object if the key is not found. 
 
        If you need to add custom behavior, override 
        :meth:`resolve_or_missing`, not this method. The various lookup 
        functions use that method, not this one. 
 
        :param key: The variable name to look up. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._legacy_resolve_mode:</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self.vars:</span>
                <span class="s2">return </span><span class="s1">self.vars[key]</span>

            <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self.parent:</span>
                <span class="s2">return </span><span class="s1">self.parent[key]</span>

            <span class="s2">return </span><span class="s1">self.environment.undefined(name=key)</span>

        <span class="s1">rv = self.resolve_or_missing(key)</span>

        <span class="s2">if </span><span class="s1">rv </span><span class="s2">is </span><span class="s1">missing:</span>
            <span class="s2">return </span><span class="s1">self.environment.undefined(name=key)</span>

        <span class="s2">return </span><span class="s1">rv</span>

    <span class="s2">def </span><span class="s1">resolve_or_missing(self</span><span class="s2">, </span><span class="s1">key: str) -&gt; t.Any:</span>
        <span class="s0">&quot;&quot;&quot;Look up a variable by name, or return a ``missing`` sentinel 
        if the key is not found. 
 
        Override this method to add custom lookup behavior. 
        :meth:`resolve`, :meth:`get`, and :meth:`__getitem__` use this 
        method. Don't call this method directly. 
 
        :param key: The variable name to look up. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._legacy_resolve_mode:</span>
            <span class="s1">rv = self.resolve(key)</span>

            <span class="s2">if </span><span class="s1">isinstance(rv</span><span class="s2">, </span><span class="s1">Undefined):</span>
                <span class="s2">return </span><span class="s1">missing</span>

            <span class="s2">return </span><span class="s1">rv</span>

        <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self.vars:</span>
            <span class="s2">return </span><span class="s1">self.vars[key]</span>

        <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self.parent:</span>
            <span class="s2">return </span><span class="s1">self.parent[key]</span>

        <span class="s2">return </span><span class="s1">missing</span>

    <span class="s2">def </span><span class="s1">get_exported(self) -&gt; t.Dict[str</span><span class="s2">, </span><span class="s1">t.Any]:</span>
        <span class="s0">&quot;&quot;&quot;Get a new dict with the exported variables.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">{k: self.vars[k] </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self.exported_vars}</span>

    <span class="s2">def </span><span class="s1">get_all(self) -&gt; t.Dict[str</span><span class="s2">, </span><span class="s1">t.Any]:</span>
        <span class="s0">&quot;&quot;&quot;Return the complete context as dict including the exported 
        variables.  For optimizations reasons this might not return an 
        actual copy so be careful with using it. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self.vars:</span>
            <span class="s2">return </span><span class="s1">self.parent</span>
        <span class="s2">if not </span><span class="s1">self.parent:</span>
            <span class="s2">return </span><span class="s1">self.vars</span>
        <span class="s2">return </span><span class="s1">dict(self.parent</span><span class="s2">, </span><span class="s1">**self.vars)</span>

    <span class="s1">@internalcode</span>
    <span class="s2">def </span><span class="s1">call(</span>
        <span class="s1">__self</span><span class="s2">, </span><span class="s1">__obj: t.Callable</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any  </span><span class="s3"># noqa: B902</span>
    <span class="s1">) -&gt; t.Union[t.Any</span><span class="s2">, </span><span class="s4">&quot;Undefined&quot;</span><span class="s1">]:</span>
        <span class="s0">&quot;&quot;&quot;Call the callable with the arguments and keyword arguments 
        provided but inject the active context or environment as first 
        argument if the callable has :func:`pass_context` or 
        :func:`pass_environment`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if __debug__</span><span class="s1">:</span>
            <span class="s1">__traceback_hide__ = </span><span class="s2">True  </span><span class="s3"># noqa</span>

        <span class="s3"># Allow callable classes to take a context</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">hasattr(__obj</span><span class="s2">, </span><span class="s4">&quot;__call__&quot;</span><span class="s1">)  </span><span class="s3"># noqa: B004</span>
            <span class="s2">and </span><span class="s1">_PassArg.from_obj(__obj.__call__) </span><span class="s2">is not None  </span><span class="s3"># type: ignore</span>
        <span class="s1">):</span>
            <span class="s1">__obj = __obj.__call__  </span><span class="s3"># type: ignore</span>

        <span class="s1">pass_arg = _PassArg.from_obj(__obj)</span>

        <span class="s2">if </span><span class="s1">pass_arg </span><span class="s2">is </span><span class="s1">_PassArg.context:</span>
            <span class="s3"># the active context should have access to variables set in</span>
            <span class="s3"># loops and blocks without mutating the context itself</span>
            <span class="s2">if </span><span class="s1">kwargs.get(</span><span class="s4">&quot;_loop_vars&quot;</span><span class="s1">):</span>
                <span class="s1">__self = __self.derived(kwargs[</span><span class="s4">&quot;_loop_vars&quot;</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s1">kwargs.get(</span><span class="s4">&quot;_block_vars&quot;</span><span class="s1">):</span>
                <span class="s1">__self = __self.derived(kwargs[</span><span class="s4">&quot;_block_vars&quot;</span><span class="s1">])</span>
            <span class="s1">args = (__self</span><span class="s2">,</span><span class="s1">) + args</span>
        <span class="s2">elif </span><span class="s1">pass_arg </span><span class="s2">is </span><span class="s1">_PassArg.eval_context:</span>
            <span class="s1">args = (__self.eval_ctx</span><span class="s2">,</span><span class="s1">) + args</span>
        <span class="s2">elif </span><span class="s1">pass_arg </span><span class="s2">is </span><span class="s1">_PassArg.environment:</span>
            <span class="s1">args = (__self.environment</span><span class="s2">,</span><span class="s1">) + args</span>

        <span class="s1">kwargs.pop(</span><span class="s4">&quot;_block_vars&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">kwargs.pop(</span><span class="s4">&quot;_loop_vars&quot;</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">__obj(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">except </span><span class="s1">StopIteration:</span>
            <span class="s2">return </span><span class="s1">__self.environment.undefined(</span>
                <span class="s4">&quot;value was undefined because a callable raised a&quot;</span>
                <span class="s4">&quot; StopIteration exception&quot;</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">derived(self</span><span class="s2">, </span><span class="s1">locals: t.Optional[t.Dict[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None</span><span class="s1">) -&gt; </span><span class="s4">&quot;Context&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Internal helper function to create a derived context.  This is 
        used in situations where the system needs a new context in the same 
        template that is independent. 
        &quot;&quot;&quot;</span>
        <span class="s1">context = new_context(</span>
            <span class="s1">self.environment</span><span class="s2">, </span><span class="s1">self.name</span><span class="s2">, </span><span class="s1">{}</span><span class="s2">, </span><span class="s1">self.get_all()</span><span class="s2">, True, None, </span><span class="s1">locals</span>
        <span class="s1">)</span>
        <span class="s1">context.eval_ctx = self.eval_ctx</span>
        <span class="s1">context.blocks.update((k</span><span class="s2">, </span><span class="s1">list(v)) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self.blocks.items())</span>
        <span class="s2">return </span><span class="s1">context</span>

    <span class="s1">keys = _dict_method_all(dict.keys)</span>
    <span class="s1">values = _dict_method_all(dict.values)</span>
    <span class="s1">items = _dict_method_all(dict.items)</span>

    <span class="s2">def </span><span class="s1">__contains__(self</span><span class="s2">, </span><span class="s1">name: str) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.vars </span><span class="s2">or </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.parent</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">key: str) -&gt; t.Any:</span>
        <span class="s0">&quot;&quot;&quot;Look up a variable by name with ``[]`` syntax, or raise a 
        ``KeyError`` if the key is not found. 
        &quot;&quot;&quot;</span>
        <span class="s1">item = self.resolve_or_missing(key)</span>

        <span class="s2">if </span><span class="s1">item </span><span class="s2">is </span><span class="s1">missing:</span>
            <span class="s2">raise </span><span class="s1">KeyError(key)</span>

        <span class="s2">return </span><span class="s1">item</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s4">f&quot;&lt;</span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">} {</span><span class="s1">self.get_all()</span><span class="s2">!r} </span><span class="s4">of </span><span class="s2">{</span><span class="s1">self.name</span><span class="s2">!r}</span><span class="s4">&gt;&quot;</span>


<span class="s2">class </span><span class="s1">BlockReference:</span>
    <span class="s0">&quot;&quot;&quot;One block on a template reference.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">name: str</span><span class="s2">,</span>
        <span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">,</span>
        <span class="s1">stack: t.List[t.Callable[[</span><span class="s4">&quot;Context&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">t.Iterator[str]]]</span><span class="s2">,</span>
        <span class="s1">depth: int</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self._context = context</span>
        <span class="s1">self._stack = stack</span>
        <span class="s1">self._depth = depth</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">super(self) -&gt; t.Union[</span><span class="s4">&quot;BlockReference&quot;</span><span class="s2">, </span><span class="s4">&quot;Undefined&quot;</span><span class="s1">]:</span>
        <span class="s0">&quot;&quot;&quot;Super the block.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._depth + </span><span class="s5">1 </span><span class="s1">&gt;= len(self._stack):</span>
            <span class="s2">return </span><span class="s1">self._context.environment.undefined(</span>
                <span class="s4">f&quot;there is no parent block called </span><span class="s2">{</span><span class="s1">self.name</span><span class="s2">!r}</span><span class="s4">.&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;super&quot;</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">BlockReference(self.name</span><span class="s2">, </span><span class="s1">self._context</span><span class="s2">, </span><span class="s1">self._stack</span><span class="s2">, </span><span class="s1">self._depth + </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">@internalcode</span>
    <span class="s2">async def </span><span class="s1">_async_call(self) -&gt; str:</span>
        <span class="s1">rv = concat(</span>
            <span class="s1">[x </span><span class="s2">async for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self._stack[self._depth](self._context)]  </span><span class="s3"># type: ignore</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self._context.eval_ctx.autoescape:</span>
            <span class="s2">return </span><span class="s1">Markup(rv)</span>

        <span class="s2">return </span><span class="s1">rv</span>

    <span class="s1">@internalcode</span>
    <span class="s2">def </span><span class="s1">__call__(self) -&gt; str:</span>
        <span class="s2">if </span><span class="s1">self._context.environment.is_async:</span>
            <span class="s2">return </span><span class="s1">self._async_call()  </span><span class="s3"># type: ignore</span>

        <span class="s1">rv = concat(self._stack[self._depth](self._context))</span>

        <span class="s2">if </span><span class="s1">self._context.eval_ctx.autoescape:</span>
            <span class="s2">return </span><span class="s1">Markup(rv)</span>

        <span class="s2">return </span><span class="s1">rv</span>


<span class="s2">class </span><span class="s1">LoopContext:</span>
    <span class="s0">&quot;&quot;&quot;A wrapper iterable for dynamic ``for`` loops, with information 
    about the loop and iteration. 
    &quot;&quot;&quot;</span>

    <span class="s3">#: Current iteration of the loop, starting at 0.</span>
    <span class="s1">index0 = -</span><span class="s5">1</span>

    <span class="s1">_length: t.Optional[int] = </span><span class="s2">None</span>
    <span class="s1">_after: t.Any = missing</span>
    <span class="s1">_current: t.Any = missing</span>
    <span class="s1">_before: t.Any = missing</span>
    <span class="s1">_last_changed_value: t.Any = missing</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">iterable: t.Iterable[V]</span><span class="s2">,</span>
        <span class="s1">undefined: t.Type[</span><span class="s4">&quot;Undefined&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">recurse: t.Optional[</span><span class="s4">&quot;LoopRenderFunc&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
        <span class="s1">depth0: int = </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        :param iterable: Iterable to wrap. 
        :param undefined: :class:`Undefined` class to use for next and 
            previous items. 
        :param recurse: The function to render the loop body when the 
            loop is marked recursive. 
        :param depth0: Incremented when looping recursively. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._iterable = iterable</span>
        <span class="s1">self._iterator = self._to_iterator(iterable)</span>
        <span class="s1">self._undefined = undefined</span>
        <span class="s1">self._recurse = recurse</span>
        <span class="s3">#: How many levels deep a recursive loop currently is, starting at 0.</span>
        <span class="s1">self.depth0 = depth0</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_to_iterator(iterable: t.Iterable[V]) -&gt; t.Iterator[V]:</span>
        <span class="s2">return </span><span class="s1">iter(iterable)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">length(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;Length of the iterable. 
 
        If the iterable is a generator or otherwise does not have a 
        size, it is eagerly evaluated to get a size. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._length </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._length</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self._length = len(self._iterable)  </span><span class="s3"># type: ignore</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s1">iterable = list(self._iterator)</span>
            <span class="s1">self._iterator = self._to_iterator(iterable)</span>
            <span class="s1">self._length = len(iterable) + self.index + (self._after </span><span class="s2">is not </span><span class="s1">missing)</span>

        <span class="s2">return </span><span class="s1">self._length</span>

    <span class="s2">def </span><span class="s1">__len__(self) -&gt; int:</span>
        <span class="s2">return </span><span class="s1">self.length</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">depth(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;How many levels deep a recursive loop currently is, starting at 1.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.depth0 + </span><span class="s5">1</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">index(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;Current iteration of the loop, starting at 1.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.index0 + </span><span class="s5">1</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">revindex0(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;Number of iterations from the end of the loop, ending at 0. 
 
        Requires calculating :attr:`length`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.length - self.index</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">revindex(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;Number of iterations from the end of the loop, ending at 1. 
 
        Requires calculating :attr:`length`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.length - self.index0</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">first(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Whether this is the first iteration of the loop.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.index0 == </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">_peek_next(self) -&gt; t.Any:</span>
        <span class="s0">&quot;&quot;&quot;Return the next element in the iterable, or :data:`missing` 
        if the iterable is exhausted. Only peeks one item ahead, caching 
        the result in :attr:`_last` for use in subsequent checks. The 
        cache is reset when :meth:`__next__` is called. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._after </span><span class="s2">is not </span><span class="s1">missing:</span>
            <span class="s2">return </span><span class="s1">self._after</span>

        <span class="s1">self._after = next(self._iterator</span><span class="s2">, </span><span class="s1">missing)</span>
        <span class="s2">return </span><span class="s1">self._after</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">last(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Whether this is the last iteration of the loop. 
 
        Causes the iterable to advance early. See 
        :func:`itertools.groupby` for issues this can cause. 
        The :func:`groupby` filter avoids that issue. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._peek_next() </span><span class="s2">is </span><span class="s1">missing</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">previtem(self) -&gt; t.Union[t.Any</span><span class="s2">, </span><span class="s4">&quot;Undefined&quot;</span><span class="s1">]:</span>
        <span class="s0">&quot;&quot;&quot;The item in the previous iteration. Undefined during the 
        first iteration. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.first:</span>
            <span class="s2">return </span><span class="s1">self._undefined(</span><span class="s4">&quot;there is no previous item&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">self._before</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">nextitem(self) -&gt; t.Union[t.Any</span><span class="s2">, </span><span class="s4">&quot;Undefined&quot;</span><span class="s1">]:</span>
        <span class="s0">&quot;&quot;&quot;The item in the next iteration. Undefined during the last 
        iteration. 
 
        Causes the iterable to advance early. See 
        :func:`itertools.groupby` for issues this can cause. 
        The :func:`jinja-filters.groupby` filter avoids that issue. 
        &quot;&quot;&quot;</span>
        <span class="s1">rv = self._peek_next()</span>

        <span class="s2">if </span><span class="s1">rv </span><span class="s2">is </span><span class="s1">missing:</span>
            <span class="s2">return </span><span class="s1">self._undefined(</span><span class="s4">&quot;there is no next item&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">rv</span>

    <span class="s2">def </span><span class="s1">cycle(self</span><span class="s2">, </span><span class="s1">*args: V) -&gt; V:</span>
        <span class="s0">&quot;&quot;&quot;Return a value from the given args, cycling through based on 
        the current :attr:`index0`. 
 
        :param args: One or more values to cycle through. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">args:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;no items for cycling given&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">args[self.index0 % len(args)]</span>

    <span class="s2">def </span><span class="s1">changed(self</span><span class="s2">, </span><span class="s1">*value: t.Any) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Return ``True`` if previously called with a different value 
        (including when called for the first time). 
 
        :param value: One or more values to compare to the last call. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._last_changed_value != value:</span>
            <span class="s1">self._last_changed_value = value</span>
            <span class="s2">return True</span>

        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">__iter__(self) -&gt; </span><span class="s4">&quot;LoopContext&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__next__(self) -&gt; t.Tuple[t.Any</span><span class="s2">, </span><span class="s4">&quot;LoopContext&quot;</span><span class="s1">]:</span>
        <span class="s2">if </span><span class="s1">self._after </span><span class="s2">is not </span><span class="s1">missing:</span>
            <span class="s1">rv = self._after</span>
            <span class="s1">self._after = missing</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rv = next(self._iterator)</span>

        <span class="s1">self.index0 += </span><span class="s5">1</span>
        <span class="s1">self._before = self._current</span>
        <span class="s1">self._current = rv</span>
        <span class="s2">return </span><span class="s1">rv</span><span class="s2">, </span><span class="s1">self</span>

    <span class="s1">@internalcode</span>
    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">iterable: t.Iterable[V]) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;When iterating over nested data, render the body of the loop 
        recursively with the given inner iterable data. 
 
        The loop must have the ``recursive`` marker for this to work. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._recurse </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;The loop must have the 'recursive' marker to be called recursively.&quot;</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">self._recurse(iterable</span><span class="s2">, </span><span class="s1">self._recurse</span><span class="s2">, </span><span class="s1">depth=self.depth)</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s4">f&quot;&lt;</span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">} {</span><span class="s1">self.index</span><span class="s2">}</span><span class="s4">/</span><span class="s2">{</span><span class="s1">self.length</span><span class="s2">}</span><span class="s4">&gt;&quot;</span>


<span class="s2">class </span><span class="s1">AsyncLoopContext(LoopContext):</span>
    <span class="s1">_iterator: t.AsyncIterator[t.Any]  </span><span class="s3"># type: ignore</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_to_iterator(  </span><span class="s3"># type: ignore</span>
        <span class="s1">iterable: t.Union[t.Iterable[V]</span><span class="s2">, </span><span class="s1">t.AsyncIterable[V]]</span>
    <span class="s1">) -&gt; t.AsyncIterator[V]:</span>
        <span class="s2">return </span><span class="s1">auto_aiter(iterable)</span>

    <span class="s1">@property</span>
    <span class="s2">async def </span><span class="s1">length(self) -&gt; int:  </span><span class="s3"># type: ignore</span>
        <span class="s2">if </span><span class="s1">self._length </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._length</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self._length = len(self._iterable)  </span><span class="s3"># type: ignore</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s1">iterable = [x </span><span class="s2">async for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self._iterator]</span>
            <span class="s1">self._iterator = self._to_iterator(iterable)</span>
            <span class="s1">self._length = len(iterable) + self.index + (self._after </span><span class="s2">is not </span><span class="s1">missing)</span>

        <span class="s2">return </span><span class="s1">self._length</span>

    <span class="s1">@property</span>
    <span class="s2">async def </span><span class="s1">revindex0(self) -&gt; int:  </span><span class="s3"># type: ignore</span>
        <span class="s2">return await </span><span class="s1">self.length - self.index</span>

    <span class="s1">@property</span>
    <span class="s2">async def </span><span class="s1">revindex(self) -&gt; int:  </span><span class="s3"># type: ignore</span>
        <span class="s2">return await </span><span class="s1">self.length - self.index0</span>

    <span class="s2">async def </span><span class="s1">_peek_next(self) -&gt; t.Any:</span>
        <span class="s2">if </span><span class="s1">self._after </span><span class="s2">is not </span><span class="s1">missing:</span>
            <span class="s2">return </span><span class="s1">self._after</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self._after = </span><span class="s2">await </span><span class="s1">self._iterator.__anext__()</span>
        <span class="s2">except </span><span class="s1">StopAsyncIteration:</span>
            <span class="s1">self._after = missing</span>

        <span class="s2">return </span><span class="s1">self._after</span>

    <span class="s1">@property</span>
    <span class="s2">async def </span><span class="s1">last(self) -&gt; bool:  </span><span class="s3"># type: ignore</span>
        <span class="s2">return await </span><span class="s1">self._peek_next() </span><span class="s2">is </span><span class="s1">missing</span>

    <span class="s1">@property</span>
    <span class="s2">async def </span><span class="s1">nextitem(self) -&gt; t.Union[t.Any</span><span class="s2">, </span><span class="s4">&quot;Undefined&quot;</span><span class="s1">]:</span>
        <span class="s1">rv = </span><span class="s2">await </span><span class="s1">self._peek_next()</span>

        <span class="s2">if </span><span class="s1">rv </span><span class="s2">is </span><span class="s1">missing:</span>
            <span class="s2">return </span><span class="s1">self._undefined(</span><span class="s4">&quot;there is no next item&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">rv</span>

    <span class="s2">def </span><span class="s1">__aiter__(self) -&gt; </span><span class="s4">&quot;AsyncLoopContext&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">async def </span><span class="s1">__anext__(self) -&gt; t.Tuple[t.Any</span><span class="s2">, </span><span class="s4">&quot;AsyncLoopContext&quot;</span><span class="s1">]:</span>
        <span class="s2">if </span><span class="s1">self._after </span><span class="s2">is not </span><span class="s1">missing:</span>
            <span class="s1">rv = self._after</span>
            <span class="s1">self._after = missing</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rv = </span><span class="s2">await </span><span class="s1">self._iterator.__anext__()</span>

        <span class="s1">self.index0 += </span><span class="s5">1</span>
        <span class="s1">self._before = self._current</span>
        <span class="s1">self._current = rv</span>
        <span class="s2">return </span><span class="s1">rv</span><span class="s2">, </span><span class="s1">self</span>


<span class="s2">class </span><span class="s1">Macro:</span>
    <span class="s0">&quot;&quot;&quot;Wraps a macro function.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">environment: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">,</span>
        <span class="s1">func: t.Callable[...</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">,</span>
        <span class="s1">name: str</span><span class="s2">,</span>
        <span class="s1">arguments: t.List[str]</span><span class="s2">,</span>
        <span class="s1">catch_kwargs: bool</span><span class="s2">,</span>
        <span class="s1">catch_varargs: bool</span><span class="s2">,</span>
        <span class="s1">caller: bool</span><span class="s2">,</span>
        <span class="s1">default_autoescape: t.Optional[bool] = </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">self._environment = environment</span>
        <span class="s1">self._func = func</span>
        <span class="s1">self._argument_count = len(arguments)</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.arguments = arguments</span>
        <span class="s1">self.catch_kwargs = catch_kwargs</span>
        <span class="s1">self.catch_varargs = catch_varargs</span>
        <span class="s1">self.caller = caller</span>
        <span class="s1">self.explicit_caller = </span><span class="s4">&quot;caller&quot; </span><span class="s2">in </span><span class="s1">arguments</span>

        <span class="s2">if </span><span class="s1">default_autoescape </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">callable(environment.autoescape):</span>
                <span class="s1">default_autoescape = environment.autoescape(</span><span class="s2">None</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">default_autoescape = environment.autoescape</span>

        <span class="s1">self._default_autoescape = default_autoescape</span>

    <span class="s1">@internalcode</span>
    <span class="s1">@pass_eval_context</span>
    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any) -&gt; str:</span>
        <span class="s3"># This requires a bit of explanation,  In the past we used to</span>
        <span class="s3"># decide largely based on compile-time information if a macro is</span>
        <span class="s3"># safe or unsafe.  While there was a volatile mode it was largely</span>
        <span class="s3"># unused for deciding on escaping.  This turns out to be</span>
        <span class="s3"># problematic for macros because whether a macro is safe depends not</span>
        <span class="s3"># on the escape mode when it was defined, but rather when it was used.</span>
        <span class="s3">#</span>
        <span class="s3"># Because however we export macros from the module system and</span>
        <span class="s3"># there are historic callers that do not pass an eval context (and</span>
        <span class="s3"># will continue to not pass one), we need to perform an instance</span>
        <span class="s3"># check here.</span>
        <span class="s3">#</span>
        <span class="s3"># This is considered safe because an eval context is not a valid</span>
        <span class="s3"># argument to callables otherwise anyway.  Worst case here is</span>
        <span class="s3"># that if no eval context is passed we fall back to the compile</span>
        <span class="s3"># time autoescape flag.</span>
        <span class="s2">if </span><span class="s1">args </span><span class="s2">and </span><span class="s1">isinstance(args[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">EvalContext):</span>
            <span class="s1">autoescape = args[</span><span class="s5">0</span><span class="s1">].autoescape</span>
            <span class="s1">args = args[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">autoescape = self._default_autoescape</span>

        <span class="s3"># try to consume the positional arguments</span>
        <span class="s1">arguments = list(args[: self._argument_count])</span>
        <span class="s1">off = len(arguments)</span>

        <span class="s3"># For information why this is necessary refer to the handling</span>
        <span class="s3"># of caller in the `macro_body` handler in the compiler.</span>
        <span class="s1">found_caller = </span><span class="s2">False</span>

        <span class="s3"># if the number of arguments consumed is not the number of</span>
        <span class="s3"># arguments expected we start filling in keyword arguments</span>
        <span class="s3"># and defaults.</span>
        <span class="s2">if </span><span class="s1">off != self._argument_count:</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.arguments[len(arguments) :]:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">value = kwargs.pop(name)</span>
                <span class="s2">except </span><span class="s1">KeyError:</span>
                    <span class="s1">value = missing</span>
                <span class="s2">if </span><span class="s1">name == </span><span class="s4">&quot;caller&quot;</span><span class="s1">:</span>
                    <span class="s1">found_caller = </span><span class="s2">True</span>
                <span class="s1">arguments.append(value)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">found_caller = self.explicit_caller</span>

        <span class="s3"># it's important that the order of these arguments does not change</span>
        <span class="s3"># if not also changed in the compiler's `function_scoping` method.</span>
        <span class="s3"># the order is caller, keyword arguments, positional arguments!</span>
        <span class="s2">if </span><span class="s1">self.caller </span><span class="s2">and not </span><span class="s1">found_caller:</span>
            <span class="s1">caller = kwargs.pop(</span><span class="s4">&quot;caller&quot;</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">caller </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">caller = self._environment.undefined(</span><span class="s4">&quot;No caller defined&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;caller&quot;</span><span class="s1">)</span>
            <span class="s1">arguments.append(caller)</span>

        <span class="s2">if </span><span class="s1">self.catch_kwargs:</span>
            <span class="s1">arguments.append(kwargs)</span>
        <span class="s2">elif </span><span class="s1">kwargs:</span>
            <span class="s2">if </span><span class="s4">&quot;caller&quot; </span><span class="s2">in </span><span class="s1">kwargs:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">f&quot;macro </span><span class="s2">{</span><span class="s1">self.name</span><span class="s2">!r} </span><span class="s4">was invoked with two values for the special&quot;</span>
                    <span class="s4">&quot; caller argument. This is most likely a bug.&quot;</span>
                <span class="s1">)</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">f&quot;macro </span><span class="s2">{</span><span class="s1">self.name</span><span class="s2">!r} </span><span class="s4">takes no keyword argument </span><span class="s2">{</span><span class="s1">next(iter(kwargs))</span><span class="s2">!r}</span><span class="s4">&quot;</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.catch_varargs:</span>
            <span class="s1">arguments.append(args[self._argument_count :])</span>
        <span class="s2">elif </span><span class="s1">len(args) &gt; self._argument_count:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">f&quot;macro </span><span class="s2">{</span><span class="s1">self.name</span><span class="s2">!r} </span><span class="s4">takes not more than&quot;</span>
                <span class="s4">f&quot; </span><span class="s2">{</span><span class="s1">len(self.arguments)</span><span class="s2">} </span><span class="s4">argument(s)&quot;</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">self._invoke(arguments</span><span class="s2">, </span><span class="s1">autoescape)</span>

    <span class="s2">async def </span><span class="s1">_async_invoke(self</span><span class="s2">, </span><span class="s1">arguments: t.List[t.Any]</span><span class="s2">, </span><span class="s1">autoescape: bool) -&gt; str:</span>
        <span class="s1">rv = </span><span class="s2">await </span><span class="s1">self._func(*arguments)  </span><span class="s3"># type: ignore</span>

        <span class="s2">if </span><span class="s1">autoescape:</span>
            <span class="s2">return </span><span class="s1">Markup(rv)</span>

        <span class="s2">return </span><span class="s1">rv  </span><span class="s3"># type: ignore</span>

    <span class="s2">def </span><span class="s1">_invoke(self</span><span class="s2">, </span><span class="s1">arguments: t.List[t.Any]</span><span class="s2">, </span><span class="s1">autoescape: bool) -&gt; str:</span>
        <span class="s2">if </span><span class="s1">self._environment.is_async:</span>
            <span class="s2">return </span><span class="s1">self._async_invoke(arguments</span><span class="s2">, </span><span class="s1">autoescape)  </span><span class="s3"># type: ignore</span>

        <span class="s1">rv = self._func(*arguments)</span>

        <span class="s2">if </span><span class="s1">autoescape:</span>
            <span class="s1">rv = Markup(rv)</span>

        <span class="s2">return </span><span class="s1">rv</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s1">name = </span><span class="s4">&quot;anonymous&quot; </span><span class="s2">if </span><span class="s1">self.name </span><span class="s2">is None else </span><span class="s1">repr(self.name)</span>
        <span class="s2">return </span><span class="s4">f&quot;&lt;</span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">} {</span><span class="s1">name</span><span class="s2">}</span><span class="s4">&gt;&quot;</span>


<span class="s2">class </span><span class="s1">Undefined:</span>
    <span class="s0">&quot;&quot;&quot;The default undefined type.  This undefined type can be printed and 
    iterated over, but every other access will raise an :exc:`UndefinedError`: 
 
    &gt;&gt;&gt; foo = Undefined(name='foo') 
    &gt;&gt;&gt; str(foo) 
    '' 
    &gt;&gt;&gt; not foo 
    True 
    &gt;&gt;&gt; foo + 42 
    Traceback (most recent call last): 
      ... 
    jinja2.exceptions.UndefinedError: 'foo' is undefined 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span>
        <span class="s4">&quot;_undefined_hint&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;_undefined_obj&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;_undefined_name&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;_undefined_exception&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">hint: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">obj: t.Any = missing</span><span class="s2">,</span>
        <span class="s1">name: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">exc: t.Type[TemplateRuntimeError] = UndefinedError</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._undefined_hint = hint</span>
        <span class="s1">self._undefined_obj = obj</span>
        <span class="s1">self._undefined_name = name</span>
        <span class="s1">self._undefined_exception = exc</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_undefined_message(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Build a message about the undefined value based on how it was 
        accessed. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._undefined_hint:</span>
            <span class="s2">return </span><span class="s1">self._undefined_hint</span>

        <span class="s2">if </span><span class="s1">self._undefined_obj </span><span class="s2">is </span><span class="s1">missing:</span>
            <span class="s2">return </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">self._undefined_name</span><span class="s2">!r} </span><span class="s4">is undefined&quot;</span>

        <span class="s2">if not </span><span class="s1">isinstance(self._undefined_name</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">return </span><span class="s1">(</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">object_type_repr(self._undefined_obj)</span><span class="s2">} </span><span class="s4">has no&quot;</span>
                <span class="s4">f&quot; element </span><span class="s2">{</span><span class="s1">self._undefined_name</span><span class="s2">!r}</span><span class="s4">&quot;</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">object_type_repr(self._undefined_obj)</span><span class="s2">!r} </span><span class="s4">has no&quot;</span>
            <span class="s4">f&quot; attribute </span><span class="s2">{</span><span class="s1">self._undefined_name</span><span class="s2">!r}</span><span class="s4">&quot;</span>
        <span class="s1">)</span>

    <span class="s1">@internalcode</span>
    <span class="s2">def </span><span class="s1">_fail_with_undefined_error(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any</span>
    <span class="s1">) -&gt; </span><span class="s4">&quot;te.NoReturn&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Raise an :exc:`UndefinedError` when operations are performed 
        on the undefined value. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">self._undefined_exception(self._undefined_message)</span>

    <span class="s1">@internalcode</span>
    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">name: str) -&gt; t.Any:</span>
        <span class="s2">if </span><span class="s1">name[:</span><span class="s5">2</span><span class="s1">] == </span><span class="s4">&quot;__&quot;</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">AttributeError(name)</span>

        <span class="s2">return </span><span class="s1">self._fail_with_undefined_error()</span>

    <span class="s1">__add__ = __radd__ = __sub__ = __rsub__ = _fail_with_undefined_error</span>
    <span class="s1">__mul__ = __rmul__ = __div__ = __rdiv__ = _fail_with_undefined_error</span>
    <span class="s1">__truediv__ = __rtruediv__ = _fail_with_undefined_error</span>
    <span class="s1">__floordiv__ = __rfloordiv__ = _fail_with_undefined_error</span>
    <span class="s1">__mod__ = __rmod__ = _fail_with_undefined_error</span>
    <span class="s1">__pos__ = __neg__ = _fail_with_undefined_error</span>
    <span class="s1">__call__ = __getitem__ = _fail_with_undefined_error</span>
    <span class="s1">__lt__ = __le__ = __gt__ = __ge__ = _fail_with_undefined_error</span>
    <span class="s1">__int__ = __float__ = __complex__ = _fail_with_undefined_error</span>
    <span class="s1">__pow__ = __rpow__ = _fail_with_undefined_error</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other: t.Any) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">type(self) </span><span class="s2">is </span><span class="s1">type(other)</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other: t.Any) -&gt; bool:</span>
        <span class="s2">return not </span><span class="s1">self.__eq__(other)</span>

    <span class="s2">def </span><span class="s1">__hash__(self) -&gt; int:</span>
        <span class="s2">return </span><span class="s1">id(type(self))</span>

    <span class="s2">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s4">&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__len__(self) -&gt; int:</span>
        <span class="s2">return </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">__iter__(self) -&gt; t.Iterator[t.Any]:</span>
        <span class="s2">yield from </span><span class="s1">()</span>

    <span class="s2">async def </span><span class="s1">__aiter__(self) -&gt; t.AsyncIterator[t.Any]:</span>
        <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">():</span>
            <span class="s2">yield</span>

    <span class="s2">def </span><span class="s1">__bool__(self) -&gt; bool:</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s4">&quot;Undefined&quot;</span>


<span class="s2">def </span><span class="s1">make_logging_undefined(</span>
    <span class="s1">logger: t.Optional[</span><span class="s4">&quot;logging.Logger&quot;</span><span class="s1">] = </span><span class="s2">None, </span><span class="s1">base: t.Type[Undefined] = Undefined</span>
<span class="s1">) -&gt; t.Type[Undefined]:</span>
    <span class="s0">&quot;&quot;&quot;Given a logger object this returns a new undefined class that will 
    log certain failures.  It will log iterations and printing.  If no 
    logger is given a default logger is created. 
 
    Example:: 
 
        logger = logging.getLogger(__name__) 
        LoggingUndefined = make_logging_undefined( 
            logger=logger, 
            base=Undefined 
        ) 
 
    .. versionadded:: 2.8 
 
    :param logger: the logger to use.  If not provided, a default logger 
                   is created. 
    :param base: the base class to add logging functionality to.  This 
                 defaults to :class:`Undefined`. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">logger </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">import </span><span class="s1">logging</span>

        <span class="s1">logger = logging.getLogger(__name__)</span>
        <span class="s1">logger.addHandler(logging.StreamHandler(sys.stderr))</span>

    <span class="s2">def </span><span class="s1">_log_message(undef: Undefined) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">logger.warning(  </span><span class="s3"># type: ignore</span>
            <span class="s4">&quot;Template variable warning: %s&quot;</span><span class="s2">, </span><span class="s1">undef._undefined_message</span>
        <span class="s1">)</span>

    <span class="s2">class </span><span class="s1">LoggingUndefined(base):  </span><span class="s3"># type: ignore</span>
        <span class="s1">__slots__ = ()</span>

        <span class="s2">def </span><span class="s1">_fail_with_undefined_error(  </span><span class="s3"># type: ignore</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any</span>
        <span class="s1">) -&gt; </span><span class="s4">&quot;te.NoReturn&quot;</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">super()._fail_with_undefined_error(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">except </span><span class="s1">self._undefined_exception </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s1">logger.error(</span><span class="s4">&quot;Template variable error: %s&quot;</span><span class="s2">, </span><span class="s1">e)  </span><span class="s3"># type: ignore</span>
                <span class="s2">raise </span><span class="s1">e</span>

        <span class="s2">def </span><span class="s1">__str__(self) -&gt; str:</span>
            <span class="s1">_log_message(self)</span>
            <span class="s2">return </span><span class="s1">super().__str__()  </span><span class="s3"># type: ignore</span>

        <span class="s2">def </span><span class="s1">__iter__(self) -&gt; t.Iterator[t.Any]:</span>
            <span class="s1">_log_message(self)</span>
            <span class="s2">return </span><span class="s1">super().__iter__()  </span><span class="s3"># type: ignore</span>

        <span class="s2">def </span><span class="s1">__bool__(self) -&gt; bool:</span>
            <span class="s1">_log_message(self)</span>
            <span class="s2">return </span><span class="s1">super().__bool__()  </span><span class="s3"># type: ignore</span>

    <span class="s2">return </span><span class="s1">LoggingUndefined</span>


<span class="s2">class </span><span class="s1">ChainableUndefined(Undefined):</span>
    <span class="s0">&quot;&quot;&quot;An undefined that is chainable, where both ``__getattr__`` and 
    ``__getitem__`` return itself rather than raising an 
    :exc:`UndefinedError`. 
 
    &gt;&gt;&gt; foo = ChainableUndefined(name='foo') 
    &gt;&gt;&gt; str(foo.bar['baz']) 
    '' 
    &gt;&gt;&gt; foo.bar['baz'] + 42 
    Traceback (most recent call last): 
      ... 
    jinja2.exceptions.UndefinedError: 'foo' is undefined 
 
    .. versionadded:: 2.11.0 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = ()</span>

    <span class="s2">def </span><span class="s1">__html__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">str(self)</span>

    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">_: str) -&gt; </span><span class="s4">&quot;ChainableUndefined&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">__getitem__ = __getattr__  </span><span class="s3"># type: ignore</span>


<span class="s2">class </span><span class="s1">DebugUndefined(Undefined):</span>
    <span class="s0">&quot;&quot;&quot;An undefined that returns the debug info when printed. 
 
    &gt;&gt;&gt; foo = DebugUndefined(name='foo') 
    &gt;&gt;&gt; str(foo) 
    '{{ foo }}' 
    &gt;&gt;&gt; not foo 
    True 
    &gt;&gt;&gt; foo + 42 
    Traceback (most recent call last): 
      ... 
    jinja2.exceptions.UndefinedError: 'foo' is undefined 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = ()</span>

    <span class="s2">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s2">if </span><span class="s1">self._undefined_hint:</span>
            <span class="s1">message = </span><span class="s4">f&quot;undefined value printed: </span><span class="s2">{</span><span class="s1">self._undefined_hint</span><span class="s2">}</span><span class="s4">&quot;</span>

        <span class="s2">elif </span><span class="s1">self._undefined_obj </span><span class="s2">is </span><span class="s1">missing:</span>
            <span class="s1">message = self._undefined_name  </span><span class="s3"># type: ignore</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">message = (</span>
                <span class="s4">f&quot;no such element: </span><span class="s2">{</span><span class="s1">object_type_repr(self._undefined_obj)</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s4">f&quot;[</span><span class="s2">{</span><span class="s1">self._undefined_name</span><span class="s2">!r}</span><span class="s4">]&quot;</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s4">f&quot;</span><span class="s2">{{{{ {</span><span class="s1">message</span><span class="s2">} }}}}</span><span class="s4">&quot;</span>


<span class="s2">class </span><span class="s1">StrictUndefined(Undefined):</span>
    <span class="s0">&quot;&quot;&quot;An undefined that barks on print and iteration as well as boolean 
    tests and all kinds of comparisons.  In other words: you can do nothing 
    with it except checking if it's defined using the `defined` test. 
 
    &gt;&gt;&gt; foo = StrictUndefined(name='foo') 
    &gt;&gt;&gt; str(foo) 
    Traceback (most recent call last): 
      ... 
    jinja2.exceptions.UndefinedError: 'foo' is undefined 
    &gt;&gt;&gt; not foo 
    Traceback (most recent call last): 
      ... 
    jinja2.exceptions.UndefinedError: 'foo' is undefined 
    &gt;&gt;&gt; foo + 42 
    Traceback (most recent call last): 
      ... 
    jinja2.exceptions.UndefinedError: 'foo' is undefined 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = ()</span>
    <span class="s1">__iter__ = __str__ = __len__ = Undefined._fail_with_undefined_error</span>
    <span class="s1">__eq__ = __ne__ = __bool__ = __hash__ = Undefined._fail_with_undefined_error</span>
    <span class="s1">__contains__ = Undefined._fail_with_undefined_error</span>


<span class="s3"># Remove slots attributes, after the metaclass is applied they are</span>
<span class="s3"># unneeded and contain wrong data for subclasses.</span>
<span class="s2">del </span><span class="s1">(</span>
    <span class="s1">Undefined.__slots__</span><span class="s2">,</span>
    <span class="s1">ChainableUndefined.__slots__</span><span class="s2">,</span>
    <span class="s1">DebugUndefined.__slots__</span><span class="s2">,</span>
    <span class="s1">StrictUndefined.__slots__</span><span class="s2">,</span>
<span class="s1">)</span>
</pre>
</body>
</html>