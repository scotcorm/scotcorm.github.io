<html>
<head>
<title>text.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
text.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">re</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span><span class="s0">, </span><span class="s1">reduce</span>
<span class="s0">from </span><span class="s1">math </span><span class="s0">import </span><span class="s1">gcd</span>
<span class="s0">from </span><span class="s1">operator </span><span class="s0">import </span><span class="s1">itemgetter</span>
<span class="s0">from </span><span class="s1">pip._vendor.rich.emoji </span><span class="s0">import </span><span class="s1">EmojiVariant</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s0">,</span>
    <span class="s1">Any</span><span class="s0">,</span>
    <span class="s1">Callable</span><span class="s0">,</span>
    <span class="s1">Dict</span><span class="s0">,</span>
    <span class="s1">Iterable</span><span class="s0">,</span>
    <span class="s1">List</span><span class="s0">,</span>
    <span class="s1">NamedTuple</span><span class="s0">,</span>
    <span class="s1">Optional</span><span class="s0">,</span>
    <span class="s1">Tuple</span><span class="s0">,</span>
    <span class="s1">Union</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">._loop </span><span class="s0">import </span><span class="s1">loop_last</span>
<span class="s0">from </span><span class="s1">._pick </span><span class="s0">import </span><span class="s1">pick_bool</span>
<span class="s0">from </span><span class="s1">._wrap </span><span class="s0">import </span><span class="s1">divide_line</span>
<span class="s0">from </span><span class="s1">.align </span><span class="s0">import </span><span class="s1">AlignMethod</span>
<span class="s0">from </span><span class="s1">.cells </span><span class="s0">import </span><span class="s1">cell_len</span><span class="s0">, </span><span class="s1">set_cell_size</span>
<span class="s0">from </span><span class="s1">.containers </span><span class="s0">import </span><span class="s1">Lines</span>
<span class="s0">from </span><span class="s1">.control </span><span class="s0">import </span><span class="s1">strip_control_codes</span>
<span class="s0">from </span><span class="s1">.emoji </span><span class="s0">import </span><span class="s1">EmojiVariant</span>
<span class="s0">from </span><span class="s1">.jupyter </span><span class="s0">import </span><span class="s1">JupyterMixin</span>
<span class="s0">from </span><span class="s1">.measure </span><span class="s0">import </span><span class="s1">Measurement</span>
<span class="s0">from </span><span class="s1">.segment </span><span class="s0">import </span><span class="s1">Segment</span>
<span class="s0">from </span><span class="s1">.style </span><span class="s0">import </span><span class="s1">Style</span><span class="s0">, </span><span class="s1">StyleType</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:  </span><span class="s2"># pragma: no cover</span>
    <span class="s0">from </span><span class="s1">.console </span><span class="s0">import </span><span class="s1">Console</span><span class="s0">, </span><span class="s1">ConsoleOptions</span><span class="s0">, </span><span class="s1">JustifyMethod</span><span class="s0">, </span><span class="s1">OverflowMethod</span>

<span class="s1">DEFAULT_JUSTIFY: </span><span class="s3">&quot;JustifyMethod&quot; </span><span class="s1">= </span><span class="s3">&quot;default&quot;</span>
<span class="s1">DEFAULT_OVERFLOW: </span><span class="s3">&quot;OverflowMethod&quot; </span><span class="s1">= </span><span class="s3">&quot;fold&quot;</span>


<span class="s1">_re_whitespace = re.compile(</span><span class="s3">r&quot;\s+$&quot;</span><span class="s1">)</span>

<span class="s1">TextType = Union[str</span><span class="s0">, </span><span class="s3">&quot;Text&quot;</span><span class="s1">]</span>

<span class="s1">GetStyleCallable = Callable[[str]</span><span class="s0">, </span><span class="s1">Optional[StyleType]]</span>


<span class="s0">class </span><span class="s1">Span(NamedTuple):</span>
    <span class="s4">&quot;&quot;&quot;A marked up region in some text.&quot;&quot;&quot;</span>

    <span class="s1">start: int</span>
    <span class="s3">&quot;&quot;&quot;Span start index.&quot;&quot;&quot;</span>
    <span class="s1">end: int</span>
    <span class="s3">&quot;&quot;&quot;Span end index.&quot;&quot;&quot;</span>
    <span class="s1">style: Union[str</span><span class="s0">, </span><span class="s1">Style]</span>
    <span class="s3">&quot;&quot;&quot;Style associated with the span.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s1">(</span>
            <span class="s3">f&quot;Span(</span><span class="s0">{</span><span class="s1">self.start</span><span class="s0">}</span><span class="s3">, </span><span class="s0">{</span><span class="s1">self.end</span><span class="s0">}</span><span class="s3">, </span><span class="s0">{</span><span class="s1">self.style</span><span class="s0">!r}</span><span class="s3">)&quot;</span>
            <span class="s0">if </span><span class="s1">(isinstance(self.style</span><span class="s0">, </span><span class="s1">Style) </span><span class="s0">and </span><span class="s1">self.style._meta)</span>
            <span class="s0">else </span><span class="s3">f&quot;Span(</span><span class="s0">{</span><span class="s1">self.start</span><span class="s0">}</span><span class="s3">, </span><span class="s0">{</span><span class="s1">self.end</span><span class="s0">}</span><span class="s3">, </span><span class="s0">{</span><span class="s1">repr(self.style)</span><span class="s0">}</span><span class="s3">)&quot;</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__bool__(self) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">self.end &gt; self.start</span>

    <span class="s0">def </span><span class="s1">split(self</span><span class="s0">, </span><span class="s1">offset: int) -&gt; Tuple[</span><span class="s3">&quot;Span&quot;</span><span class="s0">, </span><span class="s1">Optional[</span><span class="s3">&quot;Span&quot;</span><span class="s1">]]:</span>
        <span class="s4">&quot;&quot;&quot;Split a span in to 2 from a given offset.&quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">offset &lt; self.start:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s0">, None</span>
        <span class="s0">if </span><span class="s1">offset &gt;= self.end:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s0">, None</span>

        <span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">style = self</span>
        <span class="s1">span1 = Span(start</span><span class="s0">, </span><span class="s1">min(end</span><span class="s0">, </span><span class="s1">offset)</span><span class="s0">, </span><span class="s1">style)</span>
        <span class="s1">span2 = Span(span1.end</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">style)</span>
        <span class="s0">return </span><span class="s1">span1</span><span class="s0">, </span><span class="s1">span2</span>

    <span class="s0">def </span><span class="s1">move(self</span><span class="s0">, </span><span class="s1">offset: int) -&gt; </span><span class="s3">&quot;Span&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Move start and end by a given offset. 
 
        Args: 
            offset (int): Number of characters to add to start and end. 
 
        Returns: 
            TextSpan: A new TextSpan with adjusted position. 
        &quot;&quot;&quot;</span>
        <span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">style = self</span>
        <span class="s0">return </span><span class="s1">Span(start + offset</span><span class="s0">, </span><span class="s1">end + offset</span><span class="s0">, </span><span class="s1">style)</span>

    <span class="s0">def </span><span class="s1">right_crop(self</span><span class="s0">, </span><span class="s1">offset: int) -&gt; </span><span class="s3">&quot;Span&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Crop the span at the given offset. 
 
        Args: 
            offset (int): A value between start and end. 
 
        Returns: 
            Span: A new (possibly smaller) span. 
        &quot;&quot;&quot;</span>
        <span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">style = self</span>
        <span class="s0">if </span><span class="s1">offset &gt;= end:</span>
            <span class="s0">return </span><span class="s1">self</span>
        <span class="s0">return </span><span class="s1">Span(start</span><span class="s0">, </span><span class="s1">min(offset</span><span class="s0">, </span><span class="s1">end)</span><span class="s0">, </span><span class="s1">style)</span>


<span class="s0">class </span><span class="s1">Text(JupyterMixin):</span>
    <span class="s4">&quot;&quot;&quot;Text with color / style. 
 
    Args: 
        text (str, optional): Default unstyled text. Defaults to &quot;&quot;. 
        style (Union[str, Style], optional): Base style for text. Defaults to &quot;&quot;. 
        justify (str, optional): Justify method: &quot;left&quot;, &quot;center&quot;, &quot;full&quot;, &quot;right&quot;. Defaults to None. 
        overflow (str, optional): Overflow method: &quot;crop&quot;, &quot;fold&quot;, &quot;ellipsis&quot;. Defaults to None. 
        no_wrap (bool, optional): Disable text wrapping, or None for default. Defaults to None. 
        end (str, optional): Character to end text with. Defaults to &quot;\\\\n&quot;. 
        tab_size (int): Number of spaces per tab, or ``None`` to use ``console.tab_size``. Defaults to 8. 
        spans (List[Span], optional). A list of predefined style spans. Defaults to None. 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = [</span>
        <span class="s3">&quot;_text&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;style&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;justify&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;overflow&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;no_wrap&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;end&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;tab_size&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;_spans&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;_length&quot;</span><span class="s0">,</span>
    <span class="s1">]</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">text: str = </span><span class="s3">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">style: Union[str</span><span class="s0">, </span><span class="s1">Style] = </span><span class="s3">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">justify: Optional[</span><span class="s3">&quot;JustifyMethod&quot;</span><span class="s1">] = </span><span class="s0">None,</span>
        <span class="s1">overflow: Optional[</span><span class="s3">&quot;OverflowMethod&quot;</span><span class="s1">] = </span><span class="s0">None,</span>
        <span class="s1">no_wrap: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">end: str = </span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">,</span>
        <span class="s1">tab_size: Optional[int] = </span><span class="s5">8</span><span class="s0">,</span>
        <span class="s1">spans: Optional[List[Span]] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._text = [strip_control_codes(text)]</span>
        <span class="s1">self.style = style</span>
        <span class="s1">self.justify: Optional[</span><span class="s3">&quot;JustifyMethod&quot;</span><span class="s1">] = justify</span>
        <span class="s1">self.overflow: Optional[</span><span class="s3">&quot;OverflowMethod&quot;</span><span class="s1">] = overflow</span>
        <span class="s1">self.no_wrap = no_wrap</span>
        <span class="s1">self.end = end</span>
        <span class="s1">self.tab_size = tab_size</span>
        <span class="s1">self._spans: List[Span] = spans </span><span class="s0">or </span><span class="s1">[]</span>
        <span class="s1">self._length: int = len(text)</span>

    <span class="s0">def </span><span class="s1">__len__(self) -&gt; int:</span>
        <span class="s0">return </span><span class="s1">self._length</span>

    <span class="s0">def </span><span class="s1">__bool__(self) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">bool(self._length)</span>

    <span class="s0">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s1">self.plain</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s3">f&quot;&lt;text </span><span class="s0">{</span><span class="s1">self.plain</span><span class="s0">!r} {</span><span class="s1">self._spans</span><span class="s0">!r}</span><span class="s3">&gt;&quot;</span>

    <span class="s0">def </span><span class="s1">__add__(self</span><span class="s0">, </span><span class="s1">other: Any) -&gt; </span><span class="s3">&quot;Text&quot;</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">(str</span><span class="s0">, </span><span class="s1">Text)):</span>
            <span class="s1">result = self.copy()</span>
            <span class="s1">result.append(other)</span>
            <span class="s0">return </span><span class="s1">result</span>
        <span class="s0">return </span><span class="s1">NotImplemented</span>

    <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other: object) -&gt; bool:</span>
        <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">Text):</span>
            <span class="s0">return </span><span class="s1">NotImplemented</span>
        <span class="s0">return </span><span class="s1">self.plain == other.plain </span><span class="s0">and </span><span class="s1">self._spans == other._spans</span>

    <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">other: object) -&gt; bool:</span>
        <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">return </span><span class="s1">other </span><span class="s0">in </span><span class="s1">self.plain</span>
        <span class="s0">elif </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">Text):</span>
            <span class="s0">return </span><span class="s1">other.plain </span><span class="s0">in </span><span class="s1">self.plain</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">slice: Union[int</span><span class="s0">, </span><span class="s1">slice]) -&gt; </span><span class="s3">&quot;Text&quot;</span><span class="s1">:</span>
        <span class="s0">def </span><span class="s1">get_text_at(offset: int) -&gt; </span><span class="s3">&quot;Text&quot;</span><span class="s1">:</span>
            <span class="s1">_Span = Span</span>
            <span class="s1">text = Text(</span>
                <span class="s1">self.plain[offset]</span><span class="s0">,</span>
                <span class="s1">spans=[</span>
                    <span class="s1">_Span(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s1">style)</span>
                    <span class="s0">for </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">style </span><span class="s0">in </span><span class="s1">self._spans</span>
                    <span class="s0">if </span><span class="s1">end &gt; offset &gt;= start</span>
                <span class="s1">]</span><span class="s0">,</span>
                <span class="s1">end=</span><span class="s3">&quot;&quot;</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">return </span><span class="s1">text</span>

        <span class="s0">if </span><span class="s1">isinstance(slice</span><span class="s0">, </span><span class="s1">int):</span>
            <span class="s0">return </span><span class="s1">get_text_at(slice)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step = slice.indices(len(self.plain))</span>
            <span class="s0">if </span><span class="s1">step == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">lines = self.divide([start</span><span class="s0">, </span><span class="s1">stop])</span>
                <span class="s0">return </span><span class="s1">lines[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># This would be a bit of work to implement efficiently</span>
                <span class="s2"># For now, its not required</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;slices with step!=1 are not supported&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">cell_len(self) -&gt; int:</span>
        <span class="s4">&quot;&quot;&quot;Get the number of cells required to render this text.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">cell_len(self.plain)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">markup(self) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;Get console markup to render this Text. 
 
        Returns: 
            str: A string potentially creating markup tags. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">.markup </span><span class="s0">import </span><span class="s1">escape</span>

        <span class="s1">output: List[str] = []</span>

        <span class="s1">plain = self.plain</span>
        <span class="s1">markup_spans = [</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, False, </span><span class="s1">self.style)</span><span class="s0">,</span>
            <span class="s1">*((span.start</span><span class="s0">, False, </span><span class="s1">span.style) </span><span class="s0">for </span><span class="s1">span </span><span class="s0">in </span><span class="s1">self._spans)</span><span class="s0">,</span>
            <span class="s1">*((span.end</span><span class="s0">, True, </span><span class="s1">span.style) </span><span class="s0">for </span><span class="s1">span </span><span class="s0">in </span><span class="s1">self._spans)</span><span class="s0">,</span>
            <span class="s1">(len(plain)</span><span class="s0">, True, </span><span class="s1">self.style)</span><span class="s0">,</span>
        <span class="s1">]</span>
        <span class="s1">markup_spans.sort(key=itemgetter(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">position = </span><span class="s5">0</span>
        <span class="s1">append = output.append</span>
        <span class="s0">for </span><span class="s1">offset</span><span class="s0">, </span><span class="s1">closing</span><span class="s0">, </span><span class="s1">style </span><span class="s0">in </span><span class="s1">markup_spans:</span>
            <span class="s0">if </span><span class="s1">offset &gt; position:</span>
                <span class="s1">append(escape(plain[position:offset]))</span>
                <span class="s1">position = offset</span>
            <span class="s0">if </span><span class="s1">style:</span>
                <span class="s1">append(</span><span class="s3">f&quot;[/</span><span class="s0">{</span><span class="s1">style</span><span class="s0">}</span><span class="s3">]&quot; </span><span class="s0">if </span><span class="s1">closing </span><span class="s0">else </span><span class="s3">f&quot;[</span><span class="s0">{</span><span class="s1">style</span><span class="s0">}</span><span class="s3">]&quot;</span><span class="s1">)</span>
        <span class="s1">markup = </span><span class="s3">&quot;&quot;</span><span class="s1">.join(output)</span>
        <span class="s0">return </span><span class="s1">markup</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_markup(</span>
        <span class="s1">cls</span><span class="s0">,</span>
        <span class="s1">text: str</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">style: Union[str</span><span class="s0">, </span><span class="s1">Style] = </span><span class="s3">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">emoji: bool = </span><span class="s0">True,</span>
        <span class="s1">emoji_variant: Optional[EmojiVariant] = </span><span class="s0">None,</span>
        <span class="s1">justify: Optional[</span><span class="s3">&quot;JustifyMethod&quot;</span><span class="s1">] = </span><span class="s0">None,</span>
        <span class="s1">overflow: Optional[</span><span class="s3">&quot;OverflowMethod&quot;</span><span class="s1">] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Text&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Create Text instance from markup. 
 
        Args: 
            text (str): A string containing console markup. 
            emoji (bool, optional): Also render emoji code. Defaults to True. 
            justify (str, optional): Justify method: &quot;left&quot;, &quot;center&quot;, &quot;full&quot;, &quot;right&quot;. Defaults to None. 
            overflow (str, optional): Overflow method: &quot;crop&quot;, &quot;fold&quot;, &quot;ellipsis&quot;. Defaults to None. 
 
        Returns: 
            Text: A Text instance with markup rendered. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">.markup </span><span class="s0">import </span><span class="s1">render</span>

        <span class="s1">rendered_text = render(text</span><span class="s0">, </span><span class="s1">style</span><span class="s0">, </span><span class="s1">emoji=emoji</span><span class="s0">, </span><span class="s1">emoji_variant=emoji_variant)</span>
        <span class="s1">rendered_text.justify = justify</span>
        <span class="s1">rendered_text.overflow = overflow</span>
        <span class="s0">return </span><span class="s1">rendered_text</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_ansi(</span>
        <span class="s1">cls</span><span class="s0">,</span>
        <span class="s1">text: str</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">style: Union[str</span><span class="s0">, </span><span class="s1">Style] = </span><span class="s3">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">justify: Optional[</span><span class="s3">&quot;JustifyMethod&quot;</span><span class="s1">] = </span><span class="s0">None,</span>
        <span class="s1">overflow: Optional[</span><span class="s3">&quot;OverflowMethod&quot;</span><span class="s1">] = </span><span class="s0">None,</span>
        <span class="s1">no_wrap: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">end: str = </span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">,</span>
        <span class="s1">tab_size: Optional[int] = </span><span class="s5">8</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Text&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Create a Text object from a string containing ANSI escape codes. 
 
        Args: 
            text (str): A string containing escape codes. 
            style (Union[str, Style], optional): Base style for text. Defaults to &quot;&quot;. 
            justify (str, optional): Justify method: &quot;left&quot;, &quot;center&quot;, &quot;full&quot;, &quot;right&quot;. Defaults to None. 
            overflow (str, optional): Overflow method: &quot;crop&quot;, &quot;fold&quot;, &quot;ellipsis&quot;. Defaults to None. 
            no_wrap (bool, optional): Disable text wrapping, or None for default. Defaults to None. 
            end (str, optional): Character to end text with. Defaults to &quot;\\\\n&quot;. 
            tab_size (int): Number of spaces per tab, or ``None`` to use ``console.tab_size``. Defaults to 8. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">.ansi </span><span class="s0">import </span><span class="s1">AnsiDecoder</span>

        <span class="s1">joiner = Text(</span>
            <span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">,</span>
            <span class="s1">justify=justify</span><span class="s0">,</span>
            <span class="s1">overflow=overflow</span><span class="s0">,</span>
            <span class="s1">no_wrap=no_wrap</span><span class="s0">,</span>
            <span class="s1">end=end</span><span class="s0">,</span>
            <span class="s1">tab_size=tab_size</span><span class="s0">,</span>
            <span class="s1">style=style</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">decoder = AnsiDecoder()</span>
        <span class="s1">result = joiner.join(line </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">decoder.decode(text))</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">styled(</span>
        <span class="s1">cls</span><span class="s0">,</span>
        <span class="s1">text: str</span><span class="s0">,</span>
        <span class="s1">style: StyleType = </span><span class="s3">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">justify: Optional[</span><span class="s3">&quot;JustifyMethod&quot;</span><span class="s1">] = </span><span class="s0">None,</span>
        <span class="s1">overflow: Optional[</span><span class="s3">&quot;OverflowMethod&quot;</span><span class="s1">] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Text&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Construct a Text instance with a pre-applied styled. A style applied in this way won't be used 
        to pad the text when it is justified. 
 
        Args: 
            text (str): A string containing console markup. 
            style (Union[str, Style]): Style to apply to the text. Defaults to &quot;&quot;. 
            justify (str, optional): Justify method: &quot;left&quot;, &quot;center&quot;, &quot;full&quot;, &quot;right&quot;. Defaults to None. 
            overflow (str, optional): Overflow method: &quot;crop&quot;, &quot;fold&quot;, &quot;ellipsis&quot;. Defaults to None. 
 
        Returns: 
            Text: A text instance with a style applied to the entire string. 
        &quot;&quot;&quot;</span>
        <span class="s1">styled_text = cls(text</span><span class="s0">, </span><span class="s1">justify=justify</span><span class="s0">, </span><span class="s1">overflow=overflow)</span>
        <span class="s1">styled_text.stylize(style)</span>
        <span class="s0">return </span><span class="s1">styled_text</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">assemble(</span>
        <span class="s1">cls</span><span class="s0">,</span>
        <span class="s1">*parts: Union[str</span><span class="s0">, </span><span class="s3">&quot;Text&quot;</span><span class="s0">, </span><span class="s1">Tuple[str</span><span class="s0">, </span><span class="s1">StyleType]]</span><span class="s0">,</span>
        <span class="s1">style: Union[str</span><span class="s0">, </span><span class="s1">Style] = </span><span class="s3">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">justify: Optional[</span><span class="s3">&quot;JustifyMethod&quot;</span><span class="s1">] = </span><span class="s0">None,</span>
        <span class="s1">overflow: Optional[</span><span class="s3">&quot;OverflowMethod&quot;</span><span class="s1">] = </span><span class="s0">None,</span>
        <span class="s1">no_wrap: Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">end: str = </span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">,</span>
        <span class="s1">tab_size: int = </span><span class="s5">8</span><span class="s0">,</span>
        <span class="s1">meta: Optional[Dict[str</span><span class="s0">, </span><span class="s1">Any]] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Text&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Construct a text instance by combining a sequence of strings with optional styles. 
        The positional arguments should be either strings, or a tuple of string + style. 
 
        Args: 
            style (Union[str, Style], optional): Base style for text. Defaults to &quot;&quot;. 
            justify (str, optional): Justify method: &quot;left&quot;, &quot;center&quot;, &quot;full&quot;, &quot;right&quot;. Defaults to None. 
            overflow (str, optional): Overflow method: &quot;crop&quot;, &quot;fold&quot;, &quot;ellipsis&quot;. Defaults to None. 
            end (str, optional): Character to end text with. Defaults to &quot;\\\\n&quot;. 
            tab_size (int): Number of spaces per tab, or ``None`` to use ``console.tab_size``. Defaults to 8. 
            meta (Dict[str, Any], optional). Meta data to apply to text, or None for no meta data. Default to None 
 
        Returns: 
            Text: A new text instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">text = cls(</span>
            <span class="s1">style=style</span><span class="s0">,</span>
            <span class="s1">justify=justify</span><span class="s0">,</span>
            <span class="s1">overflow=overflow</span><span class="s0">,</span>
            <span class="s1">no_wrap=no_wrap</span><span class="s0">,</span>
            <span class="s1">end=end</span><span class="s0">,</span>
            <span class="s1">tab_size=tab_size</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">append = text.append</span>
        <span class="s1">_Text = Text</span>
        <span class="s0">for </span><span class="s1">part </span><span class="s0">in </span><span class="s1">parts:</span>
            <span class="s0">if </span><span class="s1">isinstance(part</span><span class="s0">, </span><span class="s1">(_Text</span><span class="s0">, </span><span class="s1">str)):</span>
                <span class="s1">append(part)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">append(*part)</span>
        <span class="s0">if </span><span class="s1">meta:</span>
            <span class="s1">text.apply_meta(meta)</span>
        <span class="s0">return </span><span class="s1">text</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">plain(self) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;Get the text as a single string.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">len(self._text) != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">self._text[:] = [</span><span class="s3">&quot;&quot;</span><span class="s1">.join(self._text)]</span>
        <span class="s0">return </span><span class="s1">self._text[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">@plain.setter</span>
    <span class="s0">def </span><span class="s1">plain(self</span><span class="s0">, </span><span class="s1">new_text: str) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Set the text to a new value.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">new_text != self.plain:</span>
            <span class="s1">self._text[:] = [new_text]</span>
            <span class="s1">old_length = self._length</span>
            <span class="s1">self._length = len(new_text)</span>
            <span class="s0">if </span><span class="s1">old_length &gt; self._length:</span>
                <span class="s1">self._trim_spans()</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">spans(self) -&gt; List[Span]:</span>
        <span class="s4">&quot;&quot;&quot;Get a reference to the internal list of spans.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._spans</span>

    <span class="s1">@spans.setter</span>
    <span class="s0">def </span><span class="s1">spans(self</span><span class="s0">, </span><span class="s1">spans: List[Span]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Set spans.&quot;&quot;&quot;</span>
        <span class="s1">self._spans = spans[:]</span>

    <span class="s0">def </span><span class="s1">blank_copy(self</span><span class="s0">, </span><span class="s1">plain: str = </span><span class="s3">&quot;&quot;</span><span class="s1">) -&gt; </span><span class="s3">&quot;Text&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Return a new Text instance with copied meta data (but not the string or spans).&quot;&quot;&quot;</span>
        <span class="s1">copy_self = Text(</span>
            <span class="s1">plain</span><span class="s0">,</span>
            <span class="s1">style=self.style</span><span class="s0">,</span>
            <span class="s1">justify=self.justify</span><span class="s0">,</span>
            <span class="s1">overflow=self.overflow</span><span class="s0">,</span>
            <span class="s1">no_wrap=self.no_wrap</span><span class="s0">,</span>
            <span class="s1">end=self.end</span><span class="s0">,</span>
            <span class="s1">tab_size=self.tab_size</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">copy_self</span>

    <span class="s0">def </span><span class="s1">copy(self) -&gt; </span><span class="s3">&quot;Text&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Return a copy of this instance.&quot;&quot;&quot;</span>
        <span class="s1">copy_self = Text(</span>
            <span class="s1">self.plain</span><span class="s0">,</span>
            <span class="s1">style=self.style</span><span class="s0">,</span>
            <span class="s1">justify=self.justify</span><span class="s0">,</span>
            <span class="s1">overflow=self.overflow</span><span class="s0">,</span>
            <span class="s1">no_wrap=self.no_wrap</span><span class="s0">,</span>
            <span class="s1">end=self.end</span><span class="s0">,</span>
            <span class="s1">tab_size=self.tab_size</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">copy_self._spans[:] = self._spans</span>
        <span class="s0">return </span><span class="s1">copy_self</span>

    <span class="s0">def </span><span class="s1">stylize(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">style: Union[str</span><span class="s0">, </span><span class="s1">Style]</span><span class="s0">,</span>
        <span class="s1">start: int = </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">end: Optional[int] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Apply a style to the text, or a portion of the text. 
 
        Args: 
            style (Union[str, Style]): Style instance or style definition to apply. 
            start (int): Start offset (negative indexing is supported). Defaults to 0. 
            end (Optional[int], optional): End offset (negative indexing is supported), or None for end of text. Defaults to None. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">style:</span>
            <span class="s1">length = len(self)</span>
            <span class="s0">if </span><span class="s1">start &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">start = length + start</span>
            <span class="s0">if </span><span class="s1">end </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">end = length</span>
            <span class="s0">if </span><span class="s1">end &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">end = length + end</span>
            <span class="s0">if </span><span class="s1">start &gt;= length </span><span class="s0">or </span><span class="s1">end &lt;= start:</span>
                <span class="s2"># Span not in text or not valid</span>
                <span class="s0">return</span>
            <span class="s1">self._spans.append(Span(start</span><span class="s0">, </span><span class="s1">min(length</span><span class="s0">, </span><span class="s1">end)</span><span class="s0">, </span><span class="s1">style))</span>

    <span class="s0">def </span><span class="s1">apply_meta(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">meta: Dict[str</span><span class="s0">, </span><span class="s1">Any]</span><span class="s0">, </span><span class="s1">start: int = </span><span class="s5">0</span><span class="s0">, </span><span class="s1">end: Optional[int] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Apply meta data to the text, or a portion of the text. 
 
        Args: 
            meta (Dict[str, Any]): A dict of meta information. 
            start (int): Start offset (negative indexing is supported). Defaults to 0. 
            end (Optional[int], optional): End offset (negative indexing is supported), or None for end of text. Defaults to None. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">style = Style.from_meta(meta)</span>
        <span class="s1">self.stylize(style</span><span class="s0">, </span><span class="s1">start=start</span><span class="s0">, </span><span class="s1">end=end)</span>

    <span class="s0">def </span><span class="s1">on(self</span><span class="s0">, </span><span class="s1">meta: Optional[Dict[str</span><span class="s0">, </span><span class="s1">Any]] = </span><span class="s0">None, </span><span class="s1">**handlers: Any) -&gt; </span><span class="s3">&quot;Text&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Apply event handlers (used by Textual project). 
 
        Example: 
            &gt;&gt;&gt; from rich.text import Text 
            &gt;&gt;&gt; text = Text(&quot;hello world&quot;) 
            &gt;&gt;&gt; text.on(click=&quot;view.toggle('world')&quot;) 
 
        Args: 
            meta (Dict[str, Any]): Mapping of meta information. 
            **handlers: Keyword args are prefixed with &quot;@&quot; to defined handlers. 
 
        Returns: 
            Text: Self is returned to method may be chained. 
        &quot;&quot;&quot;</span>
        <span class="s1">meta = {} </span><span class="s0">if </span><span class="s1">meta </span><span class="s0">is None else </span><span class="s1">meta</span>
        <span class="s1">meta.update({</span><span class="s3">f&quot;@</span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">: value </span><span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">handlers.items()})</span>
        <span class="s1">self.stylize(Style.from_meta(meta))</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">remove_suffix(self</span><span class="s0">, </span><span class="s1">suffix: str) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Remove a suffix if it exists. 
 
        Args: 
            suffix (str): Suffix to remove. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.plain.endswith(suffix):</span>
            <span class="s1">self.right_crop(len(suffix))</span>

    <span class="s0">def </span><span class="s1">get_style_at_offset(self</span><span class="s0">, </span><span class="s1">console: </span><span class="s3">&quot;Console&quot;</span><span class="s0">, </span><span class="s1">offset: int) -&gt; Style:</span>
        <span class="s4">&quot;&quot;&quot;Get the style of a character at give offset. 
 
        Args: 
            console (~Console): Console where text will be rendered. 
            offset (int): Offset in to text (negative indexing supported) 
 
        Returns: 
            Style: A Style instance. 
        &quot;&quot;&quot;</span>
        <span class="s2"># TODO: This is a little inefficient, it is only used by full justify</span>
        <span class="s0">if </span><span class="s1">offset &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">offset = len(self) + offset</span>
        <span class="s1">get_style = console.get_style</span>
        <span class="s1">style = get_style(self.style).copy()</span>
        <span class="s0">for </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">span_style </span><span class="s0">in </span><span class="s1">self._spans:</span>
            <span class="s0">if </span><span class="s1">end &gt; offset &gt;= start:</span>
                <span class="s1">style += get_style(span_style</span><span class="s0">, </span><span class="s1">default=</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">style</span>

    <span class="s0">def </span><span class="s1">highlight_regex(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">re_highlight: str</span><span class="s0">,</span>
        <span class="s1">style: Optional[Union[GetStyleCallable</span><span class="s0">, </span><span class="s1">StyleType]] = </span><span class="s0">None,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">style_prefix: str = </span><span class="s3">&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">) -&gt; int:</span>
        <span class="s4">&quot;&quot;&quot;Highlight text with a regular expression, where group names are 
        translated to styles. 
 
        Args: 
            re_highlight (str): A regular expression. 
            style (Union[GetStyleCallable, StyleType]): Optional style to apply to whole match, or a callable 
                which accepts the matched text and returns a style. Defaults to None. 
            style_prefix (str, optional): Optional prefix to add to style group names. 
 
        Returns: 
            int: Number of regex matches 
        &quot;&quot;&quot;</span>
        <span class="s1">count = </span><span class="s5">0</span>
        <span class="s1">append_span = self._spans.append</span>
        <span class="s1">_Span = Span</span>
        <span class="s1">plain = self.plain</span>
        <span class="s0">for </span><span class="s1">match </span><span class="s0">in </span><span class="s1">re.finditer(re_highlight</span><span class="s0">, </span><span class="s1">plain):</span>
            <span class="s1">get_span = match.span</span>
            <span class="s0">if </span><span class="s1">style:</span>
                <span class="s1">start</span><span class="s0">, </span><span class="s1">end = get_span()</span>
                <span class="s1">match_style = style(plain[start:end]) </span><span class="s0">if </span><span class="s1">callable(style) </span><span class="s0">else </span><span class="s1">style</span>
                <span class="s0">if </span><span class="s1">match_style </span><span class="s0">is not None and </span><span class="s1">end &gt; start:</span>
                    <span class="s1">append_span(_Span(start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">match_style))</span>

            <span class="s1">count += </span><span class="s5">1</span>
            <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">match.groupdict().keys():</span>
                <span class="s1">start</span><span class="s0">, </span><span class="s1">end = get_span(name)</span>
                <span class="s0">if </span><span class="s1">start != -</span><span class="s5">1 </span><span class="s0">and </span><span class="s1">end &gt; start:</span>
                    <span class="s1">append_span(_Span(start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">style_prefix</span><span class="s0">}{</span><span class="s1">name</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">))</span>
        <span class="s0">return </span><span class="s1">count</span>

    <span class="s0">def </span><span class="s1">highlight_words(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">words: Iterable[str]</span><span class="s0">,</span>
        <span class="s1">style: Union[str</span><span class="s0">, </span><span class="s1">Style]</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">case_sensitive: bool = </span><span class="s0">True,</span>
    <span class="s1">) -&gt; int:</span>
        <span class="s4">&quot;&quot;&quot;Highlight words with a style. 
 
        Args: 
            words (Iterable[str]): Worlds to highlight. 
            style (Union[str, Style]): Style to apply. 
            case_sensitive (bool, optional): Enable case sensitive matchings. Defaults to True. 
 
        Returns: 
            int: Number of words highlighted. 
        &quot;&quot;&quot;</span>
        <span class="s1">re_words = </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(re.escape(word) </span><span class="s0">for </span><span class="s1">word </span><span class="s0">in </span><span class="s1">words)</span>
        <span class="s1">add_span = self._spans.append</span>
        <span class="s1">count = </span><span class="s5">0</span>
        <span class="s1">_Span = Span</span>
        <span class="s0">for </span><span class="s1">match </span><span class="s0">in </span><span class="s1">re.finditer(</span>
            <span class="s1">re_words</span><span class="s0">, </span><span class="s1">self.plain</span><span class="s0">, </span><span class="s1">flags=</span><span class="s5">0 </span><span class="s0">if </span><span class="s1">case_sensitive </span><span class="s0">else </span><span class="s1">re.IGNORECASE</span>
        <span class="s1">):</span>
            <span class="s1">start</span><span class="s0">, </span><span class="s1">end = match.span(</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">add_span(_Span(start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">style))</span>
            <span class="s1">count += </span><span class="s5">1</span>
        <span class="s0">return </span><span class="s1">count</span>

    <span class="s0">def </span><span class="s1">rstrip(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Strip whitespace from end of text.&quot;&quot;&quot;</span>
        <span class="s1">self.plain = self.plain.rstrip()</span>

    <span class="s0">def </span><span class="s1">rstrip_end(self</span><span class="s0">, </span><span class="s1">size: int) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Remove whitespace beyond a certain width at the end of the text. 
 
        Args: 
            size (int): The desired size of the text. 
        &quot;&quot;&quot;</span>
        <span class="s1">text_length = len(self)</span>
        <span class="s0">if </span><span class="s1">text_length &gt; size:</span>
            <span class="s1">excess = text_length - size</span>
            <span class="s1">whitespace_match = _re_whitespace.search(self.plain)</span>
            <span class="s0">if </span><span class="s1">whitespace_match </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">whitespace_count = len(whitespace_match.group(</span><span class="s5">0</span><span class="s1">))</span>
                <span class="s1">self.right_crop(min(whitespace_count</span><span class="s0">, </span><span class="s1">excess))</span>

    <span class="s0">def </span><span class="s1">set_length(self</span><span class="s0">, </span><span class="s1">new_length: int) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Set new length of the text, clipping or padding is required.&quot;&quot;&quot;</span>
        <span class="s1">length = len(self)</span>
        <span class="s0">if </span><span class="s1">length != new_length:</span>
            <span class="s0">if </span><span class="s1">length &lt; new_length:</span>
                <span class="s1">self.pad_right(new_length - length)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.right_crop(length - new_length)</span>

    <span class="s0">def </span><span class="s1">__rich_console__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">console: </span><span class="s3">&quot;Console&quot;</span><span class="s0">, </span><span class="s1">options: </span><span class="s3">&quot;ConsoleOptions&quot;</span>
    <span class="s1">) -&gt; Iterable[Segment]:</span>
        <span class="s1">tab_size: int = console.tab_size </span><span class="s0">or </span><span class="s1">self.tab_size </span><span class="s0">or </span><span class="s5">8</span>
        <span class="s1">justify = self.justify </span><span class="s0">or </span><span class="s1">options.justify </span><span class="s0">or </span><span class="s1">DEFAULT_JUSTIFY</span>

        <span class="s1">overflow = self.overflow </span><span class="s0">or </span><span class="s1">options.overflow </span><span class="s0">or </span><span class="s1">DEFAULT_OVERFLOW</span>

        <span class="s1">lines = self.wrap(</span>
            <span class="s1">console</span><span class="s0">,</span>
            <span class="s1">options.max_width</span><span class="s0">,</span>
            <span class="s1">justify=justify</span><span class="s0">,</span>
            <span class="s1">overflow=overflow</span><span class="s0">,</span>
            <span class="s1">tab_size=tab_size </span><span class="s0">or </span><span class="s5">8</span><span class="s0">,</span>
            <span class="s1">no_wrap=pick_bool(self.no_wrap</span><span class="s0">, </span><span class="s1">options.no_wrap</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">all_lines = Text(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s1">).join(lines)</span>
        <span class="s0">yield from </span><span class="s1">all_lines.render(console</span><span class="s0">, </span><span class="s1">end=self.end)</span>

    <span class="s0">def </span><span class="s1">__rich_measure__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">console: </span><span class="s3">&quot;Console&quot;</span><span class="s0">, </span><span class="s1">options: </span><span class="s3">&quot;ConsoleOptions&quot;</span>
    <span class="s1">) -&gt; Measurement:</span>
        <span class="s1">text = self.plain</span>
        <span class="s1">lines = text.splitlines()</span>
        <span class="s1">max_text_width = max(cell_len(line) </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">lines) </span><span class="s0">if </span><span class="s1">lines </span><span class="s0">else </span><span class="s5">0</span>
        <span class="s1">words = text.split()</span>
        <span class="s1">min_text_width = (</span>
            <span class="s1">max(cell_len(word) </span><span class="s0">for </span><span class="s1">word </span><span class="s0">in </span><span class="s1">words) </span><span class="s0">if </span><span class="s1">words </span><span class="s0">else </span><span class="s1">max_text_width</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">Measurement(min_text_width</span><span class="s0">, </span><span class="s1">max_text_width)</span>

    <span class="s0">def </span><span class="s1">render(self</span><span class="s0">, </span><span class="s1">console: </span><span class="s3">&quot;Console&quot;</span><span class="s0">, </span><span class="s1">end: str = </span><span class="s3">&quot;&quot;</span><span class="s1">) -&gt; Iterable[</span><span class="s3">&quot;Segment&quot;</span><span class="s1">]:</span>
        <span class="s4">&quot;&quot;&quot;Render the text as Segments. 
 
        Args: 
            console (Console): Console instance. 
            end (Optional[str], optional): Optional end character. 
 
        Returns: 
            Iterable[Segment]: Result of render that may be written to the console. 
        &quot;&quot;&quot;</span>
        <span class="s1">_Segment = Segment</span>
        <span class="s1">text = self.plain</span>
        <span class="s0">if not </span><span class="s1">self._spans:</span>
            <span class="s0">yield </span><span class="s1">Segment(text)</span>
            <span class="s0">if </span><span class="s1">end:</span>
                <span class="s0">yield </span><span class="s1">_Segment(end)</span>
            <span class="s0">return</span>
        <span class="s1">get_style = partial(console.get_style</span><span class="s0">, </span><span class="s1">default=Style.null())</span>

        <span class="s1">enumerated_spans = list(enumerate(self._spans</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">style_map = {index: get_style(span.style) </span><span class="s0">for </span><span class="s1">index</span><span class="s0">, </span><span class="s1">span </span><span class="s0">in </span><span class="s1">enumerated_spans}</span>
        <span class="s1">style_map[</span><span class="s5">0</span><span class="s1">] = get_style(self.style)</span>

        <span class="s1">spans = [</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, False, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">*((span.start</span><span class="s0">, False, </span><span class="s1">index) </span><span class="s0">for </span><span class="s1">index</span><span class="s0">, </span><span class="s1">span </span><span class="s0">in </span><span class="s1">enumerated_spans)</span><span class="s0">,</span>
            <span class="s1">*((span.end</span><span class="s0">, True, </span><span class="s1">index) </span><span class="s0">for </span><span class="s1">index</span><span class="s0">, </span><span class="s1">span </span><span class="s0">in </span><span class="s1">enumerated_spans)</span><span class="s0">,</span>
            <span class="s1">(len(text)</span><span class="s0">, True, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span>
        <span class="s1">spans.sort(key=itemgetter(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>

        <span class="s1">stack: List[int] = []</span>
        <span class="s1">stack_append = stack.append</span>
        <span class="s1">stack_pop = stack.remove</span>

        <span class="s1">style_cache: Dict[Tuple[Style</span><span class="s0">, </span><span class="s1">...]</span><span class="s0">, </span><span class="s1">Style] = {}</span>
        <span class="s1">style_cache_get = style_cache.get</span>
        <span class="s1">combine = Style.combine</span>

        <span class="s0">def </span><span class="s1">get_current_style() -&gt; Style:</span>
            <span class="s4">&quot;&quot;&quot;Construct current style from stack.&quot;&quot;&quot;</span>
            <span class="s1">styles = tuple(style_map[_style_id] </span><span class="s0">for </span><span class="s1">_style_id </span><span class="s0">in </span><span class="s1">sorted(stack))</span>
            <span class="s1">cached_style = style_cache_get(styles)</span>
            <span class="s0">if </span><span class="s1">cached_style </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">cached_style</span>
            <span class="s1">current_style = combine(styles)</span>
            <span class="s1">style_cache[styles] = current_style</span>
            <span class="s0">return </span><span class="s1">current_style</span>

        <span class="s0">for </span><span class="s1">(offset</span><span class="s0">, </span><span class="s1">leaving</span><span class="s0">, </span><span class="s1">style_id)</span><span class="s0">, </span><span class="s1">(next_offset</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_) </span><span class="s0">in </span><span class="s1">zip(spans</span><span class="s0">, </span><span class="s1">spans[</span><span class="s5">1</span><span class="s1">:]):</span>
            <span class="s0">if </span><span class="s1">leaving:</span>
                <span class="s1">stack_pop(style_id)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">stack_append(style_id)</span>
            <span class="s0">if </span><span class="s1">next_offset &gt; offset:</span>
                <span class="s0">yield </span><span class="s1">_Segment(text[offset:next_offset]</span><span class="s0">, </span><span class="s1">get_current_style())</span>
        <span class="s0">if </span><span class="s1">end:</span>
            <span class="s0">yield </span><span class="s1">_Segment(end)</span>

    <span class="s0">def </span><span class="s1">join(self</span><span class="s0">, </span><span class="s1">lines: Iterable[</span><span class="s3">&quot;Text&quot;</span><span class="s1">]) -&gt; </span><span class="s3">&quot;Text&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Join text together with this instance as the separator. 
 
        Args: 
            lines (Iterable[Text]): An iterable of Text instances to join. 
 
        Returns: 
            Text: A new text instance containing join text. 
        &quot;&quot;&quot;</span>

        <span class="s1">new_text = self.blank_copy()</span>

        <span class="s0">def </span><span class="s1">iter_text() -&gt; Iterable[</span><span class="s3">&quot;Text&quot;</span><span class="s1">]:</span>
            <span class="s0">if </span><span class="s1">self.plain:</span>
                <span class="s0">for </span><span class="s1">last</span><span class="s0">, </span><span class="s1">line </span><span class="s0">in </span><span class="s1">loop_last(lines):</span>
                    <span class="s0">yield </span><span class="s1">line</span>
                    <span class="s0">if not </span><span class="s1">last:</span>
                        <span class="s0">yield </span><span class="s1">self</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">yield from </span><span class="s1">lines</span>

        <span class="s1">extend_text = new_text._text.extend</span>
        <span class="s1">append_span = new_text._spans.append</span>
        <span class="s1">extend_spans = new_text._spans.extend</span>
        <span class="s1">offset = </span><span class="s5">0</span>
        <span class="s1">_Span = Span</span>

        <span class="s0">for </span><span class="s1">text </span><span class="s0">in </span><span class="s1">iter_text():</span>
            <span class="s1">extend_text(text._text)</span>
            <span class="s0">if </span><span class="s1">text.style:</span>
                <span class="s1">append_span(_Span(offset</span><span class="s0">, </span><span class="s1">offset + len(text)</span><span class="s0">, </span><span class="s1">text.style))</span>
            <span class="s1">extend_spans(</span>
                <span class="s1">_Span(offset + start</span><span class="s0">, </span><span class="s1">offset + end</span><span class="s0">, </span><span class="s1">style)</span>
                <span class="s0">for </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">style </span><span class="s0">in </span><span class="s1">text._spans</span>
            <span class="s1">)</span>
            <span class="s1">offset += len(text)</span>
        <span class="s1">new_text._length = offset</span>
        <span class="s0">return </span><span class="s1">new_text</span>

    <span class="s0">def </span><span class="s1">expand_tabs(self</span><span class="s0">, </span><span class="s1">tab_size: Optional[int] = </span><span class="s0">None</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Converts tabs to spaces. 
 
        Args: 
            tab_size (int, optional): Size of tabs. Defaults to 8. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s3">&quot;</span><span class="s0">\t</span><span class="s3">&quot; </span><span class="s0">not in </span><span class="s1">self.plain:</span>
            <span class="s0">return</span>
        <span class="s1">pos = </span><span class="s5">0</span>
        <span class="s0">if </span><span class="s1">tab_size </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">tab_size = self.tab_size</span>
        <span class="s0">assert </span><span class="s1">tab_size </span><span class="s0">is not None</span>
        <span class="s1">result = self.blank_copy()</span>
        <span class="s1">append = result.append</span>

        <span class="s1">_style = self.style</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">self.split(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s1">include_separator=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s1">parts = line.split(</span><span class="s3">&quot;</span><span class="s0">\t</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s1">include_separator=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">part </span><span class="s0">in </span><span class="s1">parts:</span>
                <span class="s0">if </span><span class="s1">part.plain.endswith(</span><span class="s3">&quot;</span><span class="s0">\t</span><span class="s3">&quot;</span><span class="s1">):</span>
                    <span class="s1">part._text = [part.plain[:-</span><span class="s5">1</span><span class="s1">] + </span><span class="s3">&quot; &quot;</span><span class="s1">]</span>
                    <span class="s1">append(part)</span>
                    <span class="s1">pos += len(part)</span>
                    <span class="s1">spaces = tab_size - ((pos - </span><span class="s5">1</span><span class="s1">) % tab_size) - </span><span class="s5">1</span>
                    <span class="s0">if </span><span class="s1">spaces:</span>
                        <span class="s1">append(</span><span class="s3">&quot; &quot; </span><span class="s1">* spaces</span><span class="s0">, </span><span class="s1">_style)</span>
                        <span class="s1">pos += spaces</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">append(part)</span>
        <span class="s1">self._text = [result.plain]</span>
        <span class="s1">self._length = len(self.plain)</span>
        <span class="s1">self._spans[:] = result._spans</span>

    <span class="s0">def </span><span class="s1">truncate(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">max_width: int</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">overflow: Optional[</span><span class="s3">&quot;OverflowMethod&quot;</span><span class="s1">] = </span><span class="s0">None,</span>
        <span class="s1">pad: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Truncate text if it is longer that a given width. 
 
        Args: 
            max_width (int): Maximum number of characters in text. 
            overflow (str, optional): Overflow method: &quot;crop&quot;, &quot;fold&quot;, or &quot;ellipsis&quot;. Defaults to None, to use self.overflow. 
            pad (bool, optional): Pad with spaces if the length is less than max_width. Defaults to False. 
        &quot;&quot;&quot;</span>
        <span class="s1">_overflow = overflow </span><span class="s0">or </span><span class="s1">self.overflow </span><span class="s0">or </span><span class="s1">DEFAULT_OVERFLOW</span>
        <span class="s0">if </span><span class="s1">_overflow != </span><span class="s3">&quot;ignore&quot;</span><span class="s1">:</span>
            <span class="s1">length = cell_len(self.plain)</span>
            <span class="s0">if </span><span class="s1">length &gt; max_width:</span>
                <span class="s0">if </span><span class="s1">_overflow == </span><span class="s3">&quot;ellipsis&quot;</span><span class="s1">:</span>
                    <span class="s1">self.plain = set_cell_size(self.plain</span><span class="s0">, </span><span class="s1">max_width - </span><span class="s5">1</span><span class="s1">) + </span><span class="s3">&quot;&quot;</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">self.plain = set_cell_size(self.plain</span><span class="s0">, </span><span class="s1">max_width)</span>
            <span class="s0">if </span><span class="s1">pad </span><span class="s0">and </span><span class="s1">length &lt; max_width:</span>
                <span class="s1">spaces = max_width - length</span>
                <span class="s1">self._text = [</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self.plain</span><span class="s0">}{</span><span class="s3">' ' </span><span class="s1">* spaces</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">]</span>
                <span class="s1">self._length = len(self.plain)</span>

    <span class="s0">def </span><span class="s1">_trim_spans(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Remove or modify any spans that are over the end of the text.&quot;&quot;&quot;</span>
        <span class="s1">max_offset = len(self.plain)</span>
        <span class="s1">_Span = Span</span>
        <span class="s1">self._spans[:] = [</span>
            <span class="s1">(</span>
                <span class="s1">span</span>
                <span class="s0">if </span><span class="s1">span.end &lt; max_offset</span>
                <span class="s0">else </span><span class="s1">_Span(span.start</span><span class="s0">, </span><span class="s1">min(max_offset</span><span class="s0">, </span><span class="s1">span.end)</span><span class="s0">, </span><span class="s1">span.style)</span>
            <span class="s1">)</span>
            <span class="s0">for </span><span class="s1">span </span><span class="s0">in </span><span class="s1">self._spans</span>
            <span class="s0">if </span><span class="s1">span.start &lt; max_offset</span>
        <span class="s1">]</span>

    <span class="s0">def </span><span class="s1">pad(self</span><span class="s0">, </span><span class="s1">count: int</span><span class="s0">, </span><span class="s1">character: str = </span><span class="s3">&quot; &quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Pad left and right with a given number of characters. 
 
        Args: 
            count (int): Width of padding. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">len(character) == </span><span class="s5">1</span><span class="s0">, </span><span class="s3">&quot;Character must be a string of length 1&quot;</span>
        <span class="s0">if </span><span class="s1">count:</span>
            <span class="s1">pad_characters = character * count</span>
            <span class="s1">self.plain = </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">pad_characters</span><span class="s0">}{</span><span class="s1">self.plain</span><span class="s0">}{</span><span class="s1">pad_characters</span><span class="s0">}</span><span class="s3">&quot;</span>
            <span class="s1">_Span = Span</span>
            <span class="s1">self._spans[:] = [</span>
                <span class="s1">_Span(start + count</span><span class="s0">, </span><span class="s1">end + count</span><span class="s0">, </span><span class="s1">style)</span>
                <span class="s0">for </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">style </span><span class="s0">in </span><span class="s1">self._spans</span>
            <span class="s1">]</span>

    <span class="s0">def </span><span class="s1">pad_left(self</span><span class="s0">, </span><span class="s1">count: int</span><span class="s0">, </span><span class="s1">character: str = </span><span class="s3">&quot; &quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Pad the left with a given character. 
 
        Args: 
            count (int): Number of characters to pad. 
            character (str, optional): Character to pad with. Defaults to &quot; &quot;. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">len(character) == </span><span class="s5">1</span><span class="s0">, </span><span class="s3">&quot;Character must be a string of length 1&quot;</span>
        <span class="s0">if </span><span class="s1">count:</span>
            <span class="s1">self.plain = </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">character * count</span><span class="s0">}{</span><span class="s1">self.plain</span><span class="s0">}</span><span class="s3">&quot;</span>
            <span class="s1">_Span = Span</span>
            <span class="s1">self._spans[:] = [</span>
                <span class="s1">_Span(start + count</span><span class="s0">, </span><span class="s1">end + count</span><span class="s0">, </span><span class="s1">style)</span>
                <span class="s0">for </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">style </span><span class="s0">in </span><span class="s1">self._spans</span>
            <span class="s1">]</span>

    <span class="s0">def </span><span class="s1">pad_right(self</span><span class="s0">, </span><span class="s1">count: int</span><span class="s0">, </span><span class="s1">character: str = </span><span class="s3">&quot; &quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Pad the right with a given character. 
 
        Args: 
            count (int): Number of characters to pad. 
            character (str, optional): Character to pad with. Defaults to &quot; &quot;. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">len(character) == </span><span class="s5">1</span><span class="s0">, </span><span class="s3">&quot;Character must be a string of length 1&quot;</span>
        <span class="s0">if </span><span class="s1">count:</span>
            <span class="s1">self.plain = </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self.plain</span><span class="s0">}{</span><span class="s1">character * count</span><span class="s0">}</span><span class="s3">&quot;</span>

    <span class="s0">def </span><span class="s1">align(self</span><span class="s0">, </span><span class="s1">align: AlignMethod</span><span class="s0">, </span><span class="s1">width: int</span><span class="s0">, </span><span class="s1">character: str = </span><span class="s3">&quot; &quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Align text to a given width. 
 
        Args: 
            align (AlignMethod): One of &quot;left&quot;, &quot;center&quot;, or &quot;right&quot;. 
            width (int): Desired width. 
            character (str, optional): Character to pad with. Defaults to &quot; &quot;. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.truncate(width)</span>
        <span class="s1">excess_space = width - cell_len(self.plain)</span>
        <span class="s0">if </span><span class="s1">excess_space:</span>
            <span class="s0">if </span><span class="s1">align == </span><span class="s3">&quot;left&quot;</span><span class="s1">:</span>
                <span class="s1">self.pad_right(excess_space</span><span class="s0">, </span><span class="s1">character)</span>
            <span class="s0">elif </span><span class="s1">align == </span><span class="s3">&quot;center&quot;</span><span class="s1">:</span>
                <span class="s1">left = excess_space // </span><span class="s5">2</span>
                <span class="s1">self.pad_left(left</span><span class="s0">, </span><span class="s1">character)</span>
                <span class="s1">self.pad_right(excess_space - left</span><span class="s0">, </span><span class="s1">character)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.pad_left(excess_space</span><span class="s0">, </span><span class="s1">character)</span>

    <span class="s0">def </span><span class="s1">append(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">text: Union[</span><span class="s3">&quot;Text&quot;</span><span class="s0">, </span><span class="s1">str]</span><span class="s0">, </span><span class="s1">style: Optional[Union[str</span><span class="s0">, </span><span class="s3">&quot;Style&quot;</span><span class="s1">]] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Text&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Add text with an optional style. 
 
        Args: 
            text (Union[Text, str]): A str or Text to append. 
            style (str, optional): A style name. Defaults to None. 
 
        Returns: 
            Text: Returns self for chaining. 
        &quot;&quot;&quot;</span>

        <span class="s0">if not </span><span class="s1">isinstance(text</span><span class="s0">, </span><span class="s1">(str</span><span class="s0">, </span><span class="s1">Text)):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only str or Text can be appended to Text&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">len(text):</span>
            <span class="s0">if </span><span class="s1">isinstance(text</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s1">text = strip_control_codes(text)</span>
                <span class="s1">self._text.append(text)</span>
                <span class="s1">offset = len(self)</span>
                <span class="s1">text_length = len(text)</span>
                <span class="s0">if </span><span class="s1">style </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">self._spans.append(Span(offset</span><span class="s0">, </span><span class="s1">offset + text_length</span><span class="s0">, </span><span class="s1">style))</span>
                <span class="s1">self._length += text_length</span>
            <span class="s0">elif </span><span class="s1">isinstance(text</span><span class="s0">, </span><span class="s1">Text):</span>
                <span class="s1">_Span = Span</span>
                <span class="s0">if </span><span class="s1">style </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">&quot;style must not be set when appending Text instance&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">text_length = self._length</span>
                <span class="s0">if </span><span class="s1">text.style </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">self._spans.append(</span>
                        <span class="s1">_Span(text_length</span><span class="s0">, </span><span class="s1">text_length + len(text)</span><span class="s0">, </span><span class="s1">text.style)</span>
                    <span class="s1">)</span>
                <span class="s1">self._text.append(text.plain)</span>
                <span class="s1">self._spans.extend(</span>
                    <span class="s1">_Span(start + text_length</span><span class="s0">, </span><span class="s1">end + text_length</span><span class="s0">, </span><span class="s1">style)</span>
                    <span class="s0">for </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">style </span><span class="s0">in </span><span class="s1">text._spans</span>
                <span class="s1">)</span>
                <span class="s1">self._length += len(text)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">append_text(self</span><span class="s0">, </span><span class="s1">text: </span><span class="s3">&quot;Text&quot;</span><span class="s1">) -&gt; </span><span class="s3">&quot;Text&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Append another Text instance. This method is more performant that Text.append, but 
        only works for Text. 
 
        Returns: 
            Text: Returns self for chaining. 
        &quot;&quot;&quot;</span>
        <span class="s1">_Span = Span</span>
        <span class="s1">text_length = self._length</span>
        <span class="s0">if </span><span class="s1">text.style </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self._spans.append(_Span(text_length</span><span class="s0">, </span><span class="s1">text_length + len(text)</span><span class="s0">, </span><span class="s1">text.style))</span>
        <span class="s1">self._text.append(text.plain)</span>
        <span class="s1">self._spans.extend(</span>
            <span class="s1">_Span(start + text_length</span><span class="s0">, </span><span class="s1">end + text_length</span><span class="s0">, </span><span class="s1">style)</span>
            <span class="s0">for </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">style </span><span class="s0">in </span><span class="s1">text._spans</span>
        <span class="s1">)</span>
        <span class="s1">self._length += len(text)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">append_tokens(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">tokens: Iterable[Tuple[str</span><span class="s0">, </span><span class="s1">Optional[StyleType]]]</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Text&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Append iterable of str and style. Style may be a Style instance or a str style definition. 
 
        Args: 
            pairs (Iterable[Tuple[str, Optional[StyleType]]]): An iterable of tuples containing str content and style. 
 
        Returns: 
            Text: Returns self for chaining. 
        &quot;&quot;&quot;</span>
        <span class="s1">append_text = self._text.append</span>
        <span class="s1">append_span = self._spans.append</span>
        <span class="s1">_Span = Span</span>
        <span class="s1">offset = len(self)</span>
        <span class="s0">for </span><span class="s1">content</span><span class="s0">, </span><span class="s1">style </span><span class="s0">in </span><span class="s1">tokens:</span>
            <span class="s1">append_text(content)</span>
            <span class="s0">if </span><span class="s1">style </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">append_span(_Span(offset</span><span class="s0">, </span><span class="s1">offset + len(content)</span><span class="s0">, </span><span class="s1">style))</span>
            <span class="s1">offset += len(content)</span>
        <span class="s1">self._length = offset</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">copy_styles(self</span><span class="s0">, </span><span class="s1">text: </span><span class="s3">&quot;Text&quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Copy styles from another Text instance. 
 
        Args: 
            text (Text): A Text instance to copy styles from, must be the same length. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._spans.extend(text._spans)</span>

    <span class="s0">def </span><span class="s1">split(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">separator: str = </span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">include_separator: bool = </span><span class="s0">False,</span>
        <span class="s1">allow_blank: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; Lines:</span>
        <span class="s4">&quot;&quot;&quot;Split rich text in to lines, preserving styles. 
 
        Args: 
            separator (str, optional): String to split on. Defaults to &quot;\\\\n&quot;. 
            include_separator (bool, optional): Include the separator in the lines. Defaults to False. 
            allow_blank (bool, optional): Return a blank line if the text ends with a separator. Defaults to False. 
 
        Returns: 
            List[RichText]: A list of rich text, one per line of the original. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">separator</span><span class="s0">, </span><span class="s3">&quot;separator must not be empty&quot;</span>

        <span class="s1">text = self.plain</span>
        <span class="s0">if </span><span class="s1">separator </span><span class="s0">not in </span><span class="s1">text:</span>
            <span class="s0">return </span><span class="s1">Lines([self.copy()])</span>

        <span class="s0">if </span><span class="s1">include_separator:</span>
            <span class="s1">lines = self.divide(</span>
                <span class="s1">match.end() </span><span class="s0">for </span><span class="s1">match </span><span class="s0">in </span><span class="s1">re.finditer(re.escape(separator)</span><span class="s0">, </span><span class="s1">text)</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>

            <span class="s0">def </span><span class="s1">flatten_spans() -&gt; Iterable[int]:</span>
                <span class="s0">for </span><span class="s1">match </span><span class="s0">in </span><span class="s1">re.finditer(re.escape(separator)</span><span class="s0">, </span><span class="s1">text):</span>
                    <span class="s1">start</span><span class="s0">, </span><span class="s1">end = match.span()</span>
                    <span class="s0">yield </span><span class="s1">start</span>
                    <span class="s0">yield </span><span class="s1">end</span>

            <span class="s1">lines = Lines(</span>
                <span class="s1">line </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">self.divide(flatten_spans()) </span><span class="s0">if </span><span class="s1">line.plain != separator</span>
            <span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">allow_blank </span><span class="s0">and </span><span class="s1">text.endswith(separator):</span>
            <span class="s1">lines.pop()</span>

        <span class="s0">return </span><span class="s1">lines</span>

    <span class="s0">def </span><span class="s1">divide(self</span><span class="s0">, </span><span class="s1">offsets: Iterable[int]) -&gt; Lines:</span>
        <span class="s4">&quot;&quot;&quot;Divide text in to a number of lines at given offsets. 
 
        Args: 
            offsets (Iterable[int]): Offsets used to divide text. 
 
        Returns: 
            Lines: New RichText instances between offsets. 
        &quot;&quot;&quot;</span>
        <span class="s1">_offsets = list(offsets)</span>

        <span class="s0">if not </span><span class="s1">_offsets:</span>
            <span class="s0">return </span><span class="s1">Lines([self.copy()])</span>

        <span class="s1">text = self.plain</span>
        <span class="s1">text_length = len(text)</span>
        <span class="s1">divide_offsets = [</span><span class="s5">0</span><span class="s0">, </span><span class="s1">*_offsets</span><span class="s0">, </span><span class="s1">text_length]</span>
        <span class="s1">line_ranges = list(zip(divide_offsets</span><span class="s0">, </span><span class="s1">divide_offsets[</span><span class="s5">1</span><span class="s1">:]))</span>

        <span class="s1">style = self.style</span>
        <span class="s1">justify = self.justify</span>
        <span class="s1">overflow = self.overflow</span>
        <span class="s1">_Text = Text</span>
        <span class="s1">new_lines = Lines(</span>
            <span class="s1">_Text(</span>
                <span class="s1">text[start:end]</span><span class="s0">,</span>
                <span class="s1">style=style</span><span class="s0">,</span>
                <span class="s1">justify=justify</span><span class="s0">,</span>
                <span class="s1">overflow=overflow</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">for </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end </span><span class="s0">in </span><span class="s1">line_ranges</span>
        <span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">self._spans:</span>
            <span class="s0">return </span><span class="s1">new_lines</span>

        <span class="s1">_line_appends = [line._spans.append </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">new_lines._lines]</span>
        <span class="s1">line_count = len(line_ranges)</span>
        <span class="s1">_Span = Span</span>

        <span class="s0">for </span><span class="s1">span_start</span><span class="s0">, </span><span class="s1">span_end</span><span class="s0">, </span><span class="s1">style </span><span class="s0">in </span><span class="s1">self._spans:</span>

            <span class="s1">lower_bound = </span><span class="s5">0</span>
            <span class="s1">upper_bound = line_count</span>
            <span class="s1">start_line_no = (lower_bound + upper_bound) // </span><span class="s5">2</span>

            <span class="s0">while True</span><span class="s1">:</span>
                <span class="s1">line_start</span><span class="s0">, </span><span class="s1">line_end = line_ranges[start_line_no]</span>
                <span class="s0">if </span><span class="s1">span_start &lt; line_start:</span>
                    <span class="s1">upper_bound = start_line_no - </span><span class="s5">1</span>
                <span class="s0">elif </span><span class="s1">span_start &gt; line_end:</span>
                    <span class="s1">lower_bound = start_line_no + </span><span class="s5">1</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">break</span>
                <span class="s1">start_line_no = (lower_bound + upper_bound) // </span><span class="s5">2</span>

            <span class="s0">if </span><span class="s1">span_end &lt; line_end:</span>
                <span class="s1">end_line_no = start_line_no</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">end_line_no = lower_bound = start_line_no</span>
                <span class="s1">upper_bound = line_count</span>

                <span class="s0">while True</span><span class="s1">:</span>
                    <span class="s1">line_start</span><span class="s0">, </span><span class="s1">line_end = line_ranges[end_line_no]</span>
                    <span class="s0">if </span><span class="s1">span_end &lt; line_start:</span>
                        <span class="s1">upper_bound = end_line_no - </span><span class="s5">1</span>
                    <span class="s0">elif </span><span class="s1">span_end &gt; line_end:</span>
                        <span class="s1">lower_bound = end_line_no + </span><span class="s5">1</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s0">break</span>
                    <span class="s1">end_line_no = (lower_bound + upper_bound) // </span><span class="s5">2</span>

            <span class="s0">for </span><span class="s1">line_no </span><span class="s0">in </span><span class="s1">range(start_line_no</span><span class="s0">, </span><span class="s1">end_line_no + </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s1">line_start</span><span class="s0">, </span><span class="s1">line_end = line_ranges[line_no]</span>
                <span class="s1">new_start = max(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">span_start - line_start)</span>
                <span class="s1">new_end = min(span_end - line_start</span><span class="s0">, </span><span class="s1">line_end - line_start)</span>
                <span class="s0">if </span><span class="s1">new_end &gt; new_start:</span>
                    <span class="s1">_line_appends[line_no](_Span(new_start</span><span class="s0">, </span><span class="s1">new_end</span><span class="s0">, </span><span class="s1">style))</span>

        <span class="s0">return </span><span class="s1">new_lines</span>

    <span class="s0">def </span><span class="s1">right_crop(self</span><span class="s0">, </span><span class="s1">amount: int = </span><span class="s5">1</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Remove a number of characters from the end of the text.&quot;&quot;&quot;</span>
        <span class="s1">max_offset = len(self.plain) - amount</span>
        <span class="s1">_Span = Span</span>
        <span class="s1">self._spans[:] = [</span>
            <span class="s1">(</span>
                <span class="s1">span</span>
                <span class="s0">if </span><span class="s1">span.end &lt; max_offset</span>
                <span class="s0">else </span><span class="s1">_Span(span.start</span><span class="s0">, </span><span class="s1">min(max_offset</span><span class="s0">, </span><span class="s1">span.end)</span><span class="s0">, </span><span class="s1">span.style)</span>
            <span class="s1">)</span>
            <span class="s0">for </span><span class="s1">span </span><span class="s0">in </span><span class="s1">self._spans</span>
            <span class="s0">if </span><span class="s1">span.start &lt; max_offset</span>
        <span class="s1">]</span>
        <span class="s1">self._text = [self.plain[:-amount]]</span>
        <span class="s1">self._length -= amount</span>

    <span class="s0">def </span><span class="s1">wrap(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">console: </span><span class="s3">&quot;Console&quot;</span><span class="s0">,</span>
        <span class="s1">width: int</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">justify: Optional[</span><span class="s3">&quot;JustifyMethod&quot;</span><span class="s1">] = </span><span class="s0">None,</span>
        <span class="s1">overflow: Optional[</span><span class="s3">&quot;OverflowMethod&quot;</span><span class="s1">] = </span><span class="s0">None,</span>
        <span class="s1">tab_size: int = </span><span class="s5">8</span><span class="s0">,</span>
        <span class="s1">no_wrap: Optional[bool] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; Lines:</span>
        <span class="s4">&quot;&quot;&quot;Word wrap the text. 
 
        Args: 
            console (Console): Console instance. 
            width (int): Number of characters per line. 
            emoji (bool, optional): Also render emoji code. Defaults to True. 
            justify (str, optional): Justify method: &quot;default&quot;, &quot;left&quot;, &quot;center&quot;, &quot;full&quot;, &quot;right&quot;. Defaults to &quot;default&quot;. 
            overflow (str, optional): Overflow method: &quot;crop&quot;, &quot;fold&quot;, or &quot;ellipsis&quot;. Defaults to None. 
            tab_size (int, optional): Default tab size. Defaults to 8. 
            no_wrap (bool, optional): Disable wrapping, Defaults to False. 
 
        Returns: 
            Lines: Number of lines. 
        &quot;&quot;&quot;</span>
        <span class="s1">wrap_justify = justify </span><span class="s0">or </span><span class="s1">self.justify </span><span class="s0">or </span><span class="s1">DEFAULT_JUSTIFY</span>
        <span class="s1">wrap_overflow = overflow </span><span class="s0">or </span><span class="s1">self.overflow </span><span class="s0">or </span><span class="s1">DEFAULT_OVERFLOW</span>

        <span class="s1">no_wrap = pick_bool(no_wrap</span><span class="s0">, </span><span class="s1">self.no_wrap</span><span class="s0">, False</span><span class="s1">) </span><span class="s0">or </span><span class="s1">overflow == </span><span class="s3">&quot;ignore&quot;</span>

        <span class="s1">lines = Lines()</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">self.split(allow_blank=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s3">&quot;</span><span class="s0">\t</span><span class="s3">&quot; </span><span class="s0">in </span><span class="s1">line:</span>
                <span class="s1">line.expand_tabs(tab_size)</span>
            <span class="s0">if </span><span class="s1">no_wrap:</span>
                <span class="s1">new_lines = Lines([line])</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">offsets = divide_line(str(line)</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">fold=wrap_overflow == </span><span class="s3">&quot;fold&quot;</span><span class="s1">)</span>
                <span class="s1">new_lines = line.divide(offsets)</span>
            <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">new_lines:</span>
                <span class="s1">line.rstrip_end(width)</span>
            <span class="s0">if </span><span class="s1">wrap_justify:</span>
                <span class="s1">new_lines.justify(</span>
                    <span class="s1">console</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">justify=wrap_justify</span><span class="s0">, </span><span class="s1">overflow=wrap_overflow</span>
                <span class="s1">)</span>
            <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">new_lines:</span>
                <span class="s1">line.truncate(width</span><span class="s0">, </span><span class="s1">overflow=wrap_overflow)</span>
            <span class="s1">lines.extend(new_lines)</span>
        <span class="s0">return </span><span class="s1">lines</span>

    <span class="s0">def </span><span class="s1">fit(self</span><span class="s0">, </span><span class="s1">width: int) -&gt; Lines:</span>
        <span class="s4">&quot;&quot;&quot;Fit the text in to given width by chopping in to lines. 
 
        Args: 
            width (int): Maximum characters in a line. 
 
        Returns: 
            Lines: List of lines. 
        &quot;&quot;&quot;</span>
        <span class="s1">lines: Lines = Lines()</span>
        <span class="s1">append = lines.append</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">self.split():</span>
            <span class="s1">line.set_length(width)</span>
            <span class="s1">append(line)</span>
        <span class="s0">return </span><span class="s1">lines</span>

    <span class="s0">def </span><span class="s1">detect_indentation(self) -&gt; int:</span>
        <span class="s4">&quot;&quot;&quot;Auto-detect indentation of code. 
 
        Returns: 
            int: Number of spaces used to indent code. 
        &quot;&quot;&quot;</span>

        <span class="s1">_indentations = {</span>
            <span class="s1">len(match.group(</span><span class="s5">1</span><span class="s1">))</span>
            <span class="s0">for </span><span class="s1">match </span><span class="s0">in </span><span class="s1">re.finditer(</span><span class="s3">r&quot;^( *)(.*)$&quot;</span><span class="s0">, </span><span class="s1">self.plain</span><span class="s0">, </span><span class="s1">flags=re.MULTILINE)</span>
        <span class="s1">}</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">indentation = (</span>
                <span class="s1">reduce(gcd</span><span class="s0">, </span><span class="s1">[indent </span><span class="s0">for </span><span class="s1">indent </span><span class="s0">in </span><span class="s1">_indentations </span><span class="s0">if not </span><span class="s1">indent % </span><span class="s5">2</span><span class="s1">]) </span><span class="s0">or </span><span class="s5">1</span>
            <span class="s1">)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s1">indentation = </span><span class="s5">1</span>

        <span class="s0">return </span><span class="s1">indentation</span>

    <span class="s0">def </span><span class="s1">with_indent_guides(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">indent_size: Optional[int] = </span><span class="s0">None,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">character: str = </span><span class="s3">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">style: StyleType = </span><span class="s3">&quot;dim green&quot;</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Text&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Adds indent guide lines to text. 
 
        Args: 
            indent_size (Optional[int]): Size of indentation, or None to auto detect. Defaults to None. 
            character (str, optional): Character to use for indentation. Defaults to &quot;&quot;. 
            style (Union[Style, str], optional): Style of indent guides. 
 
        Returns: 
            Text: New text with indentation guides. 
        &quot;&quot;&quot;</span>

        <span class="s1">_indent_size = self.detect_indentation() </span><span class="s0">if </span><span class="s1">indent_size </span><span class="s0">is None else </span><span class="s1">indent_size</span>

        <span class="s1">text = self.copy()</span>
        <span class="s1">text.expand_tabs()</span>
        <span class="s1">indent_line = </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">character</span><span class="s0">}{</span><span class="s3">' ' </span><span class="s1">* (_indent_size - </span><span class="s5">1</span><span class="s1">)</span><span class="s0">}</span><span class="s3">&quot;</span>

        <span class="s1">re_indent = re.compile(</span><span class="s3">r&quot;^( *)(.*)$&quot;</span><span class="s1">)</span>
        <span class="s1">new_lines: List[Text] = []</span>
        <span class="s1">add_line = new_lines.append</span>
        <span class="s1">blank_lines = </span><span class="s5">0</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">text.split(allow_blank=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s1">match = re_indent.match(line.plain)</span>
            <span class="s0">if not </span><span class="s1">match </span><span class="s0">or not </span><span class="s1">match.group(</span><span class="s5">2</span><span class="s1">):</span>
                <span class="s1">blank_lines += </span><span class="s5">1</span>
                <span class="s0">continue</span>
            <span class="s1">indent = match.group(</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">full_indents</span><span class="s0">, </span><span class="s1">remaining_space = divmod(len(indent)</span><span class="s0">, </span><span class="s1">_indent_size)</span>
            <span class="s1">new_indent = </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">indent_line * full_indents</span><span class="s0">}{</span><span class="s3">' ' </span><span class="s1">* remaining_space</span><span class="s0">}</span><span class="s3">&quot;</span>
            <span class="s1">line.plain = new_indent + line.plain[len(new_indent) :]</span>
            <span class="s1">line.stylize(style</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">len(new_indent))</span>
            <span class="s0">if </span><span class="s1">blank_lines:</span>
                <span class="s1">new_lines.extend([Text(new_indent</span><span class="s0">, </span><span class="s1">style=style)] * blank_lines)</span>
                <span class="s1">blank_lines = </span><span class="s5">0</span>
            <span class="s1">add_line(line)</span>
        <span class="s0">if </span><span class="s1">blank_lines:</span>
            <span class="s1">new_lines.extend([Text(</span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s1">style=style)] * blank_lines)</span>

        <span class="s1">new_text = text.blank_copy(</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s1">).join(new_lines)</span>
        <span class="s0">return </span><span class="s1">new_text</span>


<span class="s0">if </span><span class="s1">__name__ == </span><span class="s3">&quot;__main__&quot;</span><span class="s1">:  </span><span class="s2"># pragma: no cover</span>
    <span class="s0">from </span><span class="s1">pip._vendor.rich.console </span><span class="s0">import </span><span class="s1">Console</span>

    <span class="s1">text = Text(</span>
        <span class="s3">&quot;&quot;&quot;</span><span class="s0">\n</span><span class="s3">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</span><span class="s0">\n</span><span class="s3">&quot;&quot;&quot;</span>
    <span class="s1">)</span>
    <span class="s1">text.highlight_words([</span><span class="s3">&quot;Lorem&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s3">&quot;bold&quot;</span><span class="s1">)</span>
    <span class="s1">text.highlight_words([</span><span class="s3">&quot;ipsum&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s3">&quot;italic&quot;</span><span class="s1">)</span>

    <span class="s1">console = Console()</span>

    <span class="s1">console.rule(</span><span class="s3">&quot;justify='left'&quot;</span><span class="s1">)</span>
    <span class="s1">console.print(text</span><span class="s0">, </span><span class="s1">style=</span><span class="s3">&quot;red&quot;</span><span class="s1">)</span>
    <span class="s1">console.print()</span>

    <span class="s1">console.rule(</span><span class="s3">&quot;justify='center'&quot;</span><span class="s1">)</span>
    <span class="s1">console.print(text</span><span class="s0">, </span><span class="s1">style=</span><span class="s3">&quot;green&quot;</span><span class="s0">, </span><span class="s1">justify=</span><span class="s3">&quot;center&quot;</span><span class="s1">)</span>
    <span class="s1">console.print()</span>

    <span class="s1">console.rule(</span><span class="s3">&quot;justify='right'&quot;</span><span class="s1">)</span>
    <span class="s1">console.print(text</span><span class="s0">, </span><span class="s1">style=</span><span class="s3">&quot;blue&quot;</span><span class="s0">, </span><span class="s1">justify=</span><span class="s3">&quot;right&quot;</span><span class="s1">)</span>
    <span class="s1">console.print()</span>

    <span class="s1">console.rule(</span><span class="s3">&quot;justify='full'&quot;</span><span class="s1">)</span>
    <span class="s1">console.print(text</span><span class="s0">, </span><span class="s1">style=</span><span class="s3">&quot;magenta&quot;</span><span class="s0">, </span><span class="s1">justify=</span><span class="s3">&quot;full&quot;</span><span class="s1">)</span>
    <span class="s1">console.print()</span>
</pre>
</body>
</html>