<html>
<head>
<title>shape_base.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
shape_base.py</font>
</center></td></tr></table>
<pre><span class="s0">__all__ = [</span><span class="s1">'atleast_1d'</span><span class="s2">, </span><span class="s1">'atleast_2d'</span><span class="s2">, </span><span class="s1">'atleast_3d'</span><span class="s2">, </span><span class="s1">'block'</span><span class="s2">, </span><span class="s1">'hstack'</span><span class="s2">,</span>
           <span class="s1">'stack'</span><span class="s2">, </span><span class="s1">'vstack'</span><span class="s0">]</span>

<span class="s2">import </span><span class="s0">functools</span>
<span class="s2">import </span><span class="s0">itertools</span>
<span class="s2">import </span><span class="s0">operator</span>
<span class="s2">import </span><span class="s0">warnings</span>

<span class="s2">from </span><span class="s0">. </span><span class="s2">import </span><span class="s0">numeric </span><span class="s2">as </span><span class="s0">_nx</span>
<span class="s2">from </span><span class="s0">. </span><span class="s2">import </span><span class="s0">overrides</span>
<span class="s2">from </span><span class="s0">.multiarray </span><span class="s2">import </span><span class="s0">array</span><span class="s2">, </span><span class="s0">asanyarray</span><span class="s2">, </span><span class="s0">normalize_axis_index</span>
<span class="s2">from </span><span class="s0">. </span><span class="s2">import </span><span class="s0">fromnumeric </span><span class="s2">as </span><span class="s0">_from_nx</span>


<span class="s0">array_function_dispatch = functools.partial(</span>
    <span class="s0">overrides.array_function_dispatch</span><span class="s2">, </span><span class="s0">module=</span><span class="s1">'numpy'</span><span class="s0">)</span>


<span class="s2">def </span><span class="s0">_atleast_1d_dispatcher(*arys):</span>
    <span class="s2">return </span><span class="s0">arys</span>


<span class="s0">@array_function_dispatch(_atleast_1d_dispatcher)</span>
<span class="s2">def </span><span class="s0">atleast_1d(*arys):</span>
    <span class="s3">&quot;&quot;&quot; 
    Convert inputs to arrays with at least one dimension. 
 
    Scalar inputs are converted to 1-dimensional arrays, whilst 
    higher-dimensional inputs are preserved. 
 
    Parameters 
    ---------- 
    arys1, arys2, ... : array_like 
        One or more input arrays. 
 
    Returns 
    ------- 
    ret : ndarray 
        An array, or list of arrays, each with ``a.ndim &gt;= 1``. 
        Copies are made only if necessary. 
 
    See Also 
    -------- 
    atleast_2d, atleast_3d 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.atleast_1d(1.0) 
    array([1.]) 
 
    &gt;&gt;&gt; x = np.arange(9.0).reshape(3,3) 
    &gt;&gt;&gt; np.atleast_1d(x) 
    array([[0., 1., 2.], 
           [3., 4., 5.], 
           [6., 7., 8.]]) 
    &gt;&gt;&gt; np.atleast_1d(x) is x 
    True 
 
    &gt;&gt;&gt; np.atleast_1d(1, [3, 4]) 
    [array([1]), array([3, 4])] 
 
    &quot;&quot;&quot;</span>
    <span class="s0">res = []</span>
    <span class="s2">for </span><span class="s0">ary </span><span class="s2">in </span><span class="s0">arys:</span>
        <span class="s0">ary = asanyarray(ary)</span>
        <span class="s2">if </span><span class="s0">ary.ndim == </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s0">result = ary.reshape(</span><span class="s4">1</span><span class="s0">)</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">result = ary</span>
        <span class="s0">res.append(result)</span>
    <span class="s2">if </span><span class="s0">len(res) == </span><span class="s4">1</span><span class="s0">:</span>
        <span class="s2">return </span><span class="s0">res[</span><span class="s4">0</span><span class="s0">]</span>
    <span class="s2">else</span><span class="s0">:</span>
        <span class="s2">return </span><span class="s0">res</span>


<span class="s2">def </span><span class="s0">_atleast_2d_dispatcher(*arys):</span>
    <span class="s2">return </span><span class="s0">arys</span>


<span class="s0">@array_function_dispatch(_atleast_2d_dispatcher)</span>
<span class="s2">def </span><span class="s0">atleast_2d(*arys):</span>
    <span class="s3">&quot;&quot;&quot; 
    View inputs as arrays with at least two dimensions. 
 
    Parameters 
    ---------- 
    arys1, arys2, ... : array_like 
        One or more array-like sequences.  Non-array inputs are converted 
        to arrays.  Arrays that already have two or more dimensions are 
        preserved. 
 
    Returns 
    ------- 
    res, res2, ... : ndarray 
        An array, or list of arrays, each with ``a.ndim &gt;= 2``. 
        Copies are avoided where possible, and views with two or more 
        dimensions are returned. 
 
    See Also 
    -------- 
    atleast_1d, atleast_3d 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.atleast_2d(3.0) 
    array([[3.]]) 
 
    &gt;&gt;&gt; x = np.arange(3.0) 
    &gt;&gt;&gt; np.atleast_2d(x) 
    array([[0., 1., 2.]]) 
    &gt;&gt;&gt; np.atleast_2d(x).base is x 
    True 
 
    &gt;&gt;&gt; np.atleast_2d(1, [1, 2], [[1, 2]]) 
    [array([[1]]), array([[1, 2]]), array([[1, 2]])] 
 
    &quot;&quot;&quot;</span>
    <span class="s0">res = []</span>
    <span class="s2">for </span><span class="s0">ary </span><span class="s2">in </span><span class="s0">arys:</span>
        <span class="s0">ary = asanyarray(ary)</span>
        <span class="s2">if </span><span class="s0">ary.ndim == </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s0">result = ary.reshape(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s0">)</span>
        <span class="s2">elif </span><span class="s0">ary.ndim == </span><span class="s4">1</span><span class="s0">:</span>
            <span class="s0">result = ary[_nx.newaxis</span><span class="s2">, </span><span class="s0">:]</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">result = ary</span>
        <span class="s0">res.append(result)</span>
    <span class="s2">if </span><span class="s0">len(res) == </span><span class="s4">1</span><span class="s0">:</span>
        <span class="s2">return </span><span class="s0">res[</span><span class="s4">0</span><span class="s0">]</span>
    <span class="s2">else</span><span class="s0">:</span>
        <span class="s2">return </span><span class="s0">res</span>


<span class="s2">def </span><span class="s0">_atleast_3d_dispatcher(*arys):</span>
    <span class="s2">return </span><span class="s0">arys</span>


<span class="s0">@array_function_dispatch(_atleast_3d_dispatcher)</span>
<span class="s2">def </span><span class="s0">atleast_3d(*arys):</span>
    <span class="s3">&quot;&quot;&quot; 
    View inputs as arrays with at least three dimensions. 
 
    Parameters 
    ---------- 
    arys1, arys2, ... : array_like 
        One or more array-like sequences.  Non-array inputs are converted to 
        arrays.  Arrays that already have three or more dimensions are 
        preserved. 
 
    Returns 
    ------- 
    res1, res2, ... : ndarray 
        An array, or list of arrays, each with ``a.ndim &gt;= 3``.  Copies are 
        avoided where possible, and views with three or more dimensions are 
        returned.  For example, a 1-D array of shape ``(N,)`` becomes a view 
        of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a 
        view of shape ``(M, N, 1)``. 
 
    See Also 
    -------- 
    atleast_1d, atleast_2d 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.atleast_3d(3.0) 
    array([[[3.]]]) 
 
    &gt;&gt;&gt; x = np.arange(3.0) 
    &gt;&gt;&gt; np.atleast_3d(x).shape 
    (1, 3, 1) 
 
    &gt;&gt;&gt; x = np.arange(12.0).reshape(4,3) 
    &gt;&gt;&gt; np.atleast_3d(x).shape 
    (4, 3, 1) 
    &gt;&gt;&gt; np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself 
    True 
 
    &gt;&gt;&gt; for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]): 
    ...     print(arr, arr.shape) # doctest: +SKIP 
    ... 
    [[[1] 
      [2]]] (1, 2, 1) 
    [[[1] 
      [2]]] (1, 2, 1) 
    [[[1 2]]] (1, 1, 2) 
 
    &quot;&quot;&quot;</span>
    <span class="s0">res = []</span>
    <span class="s2">for </span><span class="s0">ary </span><span class="s2">in </span><span class="s0">arys:</span>
        <span class="s0">ary = asanyarray(ary)</span>
        <span class="s2">if </span><span class="s0">ary.ndim == </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s0">result = ary.reshape(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s0">)</span>
        <span class="s2">elif </span><span class="s0">ary.ndim == </span><span class="s4">1</span><span class="s0">:</span>
            <span class="s0">result = ary[_nx.newaxis</span><span class="s2">, </span><span class="s0">:</span><span class="s2">, </span><span class="s0">_nx.newaxis]</span>
        <span class="s2">elif </span><span class="s0">ary.ndim == </span><span class="s4">2</span><span class="s0">:</span>
            <span class="s0">result = ary[:</span><span class="s2">, </span><span class="s0">:</span><span class="s2">, </span><span class="s0">_nx.newaxis]</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">result = ary</span>
        <span class="s0">res.append(result)</span>
    <span class="s2">if </span><span class="s0">len(res) == </span><span class="s4">1</span><span class="s0">:</span>
        <span class="s2">return </span><span class="s0">res[</span><span class="s4">0</span><span class="s0">]</span>
    <span class="s2">else</span><span class="s0">:</span>
        <span class="s2">return </span><span class="s0">res</span>


<span class="s2">def </span><span class="s0">_arrays_for_stack_dispatcher(arrays</span><span class="s2">, </span><span class="s0">stacklevel=</span><span class="s4">4</span><span class="s0">):</span>
    <span class="s2">if not </span><span class="s0">hasattr(arrays</span><span class="s2">, </span><span class="s1">'__getitem__'</span><span class="s0">) </span><span class="s2">and </span><span class="s0">hasattr(arrays</span><span class="s2">, </span><span class="s1">'__iter__'</span><span class="s0">):</span>
        <span class="s0">warnings.warn(</span><span class="s1">'arrays to stack must be passed as a &quot;sequence&quot; type '</span>
                      <span class="s1">'such as list or tuple. Support for non-sequence '</span>
                      <span class="s1">'iterables such as generators is deprecated as of '</span>
                      <span class="s1">'NumPy 1.16 and will raise an error in the future.'</span><span class="s2">,</span>
                      <span class="s0">FutureWarning</span><span class="s2">, </span><span class="s0">stacklevel=stacklevel)</span>
        <span class="s2">return </span><span class="s0">()</span>
    <span class="s2">return </span><span class="s0">arrays</span>


<span class="s2">def </span><span class="s0">_vhstack_dispatcher(tup):</span>
    <span class="s2">return </span><span class="s0">_arrays_for_stack_dispatcher(tup)</span>


<span class="s0">@array_function_dispatch(_vhstack_dispatcher)</span>
<span class="s2">def </span><span class="s0">vstack(tup):</span>
    <span class="s3">&quot;&quot;&quot; 
    Stack arrays in sequence vertically (row wise). 
 
    This is equivalent to concatenation along the first axis after 1-D arrays 
    of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by 
    `vsplit`. 
 
    This function makes most sense for arrays with up to 3 dimensions. For 
    instance, for pixel-data with a height (first axis), width (second axis), 
    and r/g/b channels (third axis). The functions `concatenate`, `stack` and 
    `block` provide more general stacking and concatenation operations. 
 
    Parameters 
    ---------- 
    tup : sequence of ndarrays 
        The arrays must have the same shape along all but the first axis. 
        1-D arrays must have the same length. 
 
    Returns 
    ------- 
    stacked : ndarray 
        The array formed by stacking the given arrays, will be at least 2-D. 
 
    See Also 
    -------- 
    concatenate : Join a sequence of arrays along an existing axis. 
    stack : Join a sequence of arrays along a new axis. 
    block : Assemble an nd-array from nested lists of blocks. 
    hstack : Stack arrays in sequence horizontally (column wise). 
    dstack : Stack arrays in sequence depth wise (along third axis). 
    column_stack : Stack 1-D arrays as columns into a 2-D array. 
    vsplit : Split an array into multiple sub-arrays vertically (row-wise). 
 
    Examples 
    -------- 
    &gt;&gt;&gt; a = np.array([1, 2, 3]) 
    &gt;&gt;&gt; b = np.array([4, 5, 6]) 
    &gt;&gt;&gt; np.vstack((a,b)) 
    array([[1, 2, 3], 
           [4, 5, 6]]) 
 
    &gt;&gt;&gt; a = np.array([[1], [2], [3]]) 
    &gt;&gt;&gt; b = np.array([[4], [5], [6]]) 
    &gt;&gt;&gt; np.vstack((a,b)) 
    array([[1], 
           [2], 
           [3], 
           [4], 
           [5], 
           [6]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s0">overrides.ARRAY_FUNCTION_ENABLED:</span>
        <span class="s5"># raise warning if necessary</span>
        <span class="s0">_arrays_for_stack_dispatcher(tup</span><span class="s2">, </span><span class="s0">stacklevel=</span><span class="s4">2</span><span class="s0">)</span>
    <span class="s0">arrs = atleast_2d(*tup)</span>
    <span class="s2">if not </span><span class="s0">isinstance(arrs</span><span class="s2">, </span><span class="s0">list):</span>
        <span class="s0">arrs = [arrs]</span>
    <span class="s2">return </span><span class="s0">_nx.concatenate(arrs</span><span class="s2">, </span><span class="s4">0</span><span class="s0">)</span>


<span class="s0">@array_function_dispatch(_vhstack_dispatcher)</span>
<span class="s2">def </span><span class="s0">hstack(tup):</span>
    <span class="s3">&quot;&quot;&quot; 
    Stack arrays in sequence horizontally (column wise). 
 
    This is equivalent to concatenation along the second axis, except for 1-D 
    arrays where it concatenates along the first axis. Rebuilds arrays divided 
    by `hsplit`. 
 
    This function makes most sense for arrays with up to 3 dimensions. For 
    instance, for pixel-data with a height (first axis), width (second axis), 
    and r/g/b channels (third axis). The functions `concatenate`, `stack` and 
    `block` provide more general stacking and concatenation operations. 
 
    Parameters 
    ---------- 
    tup : sequence of ndarrays 
        The arrays must have the same shape along all but the second axis, 
        except 1-D arrays which can be any length. 
 
    Returns 
    ------- 
    stacked : ndarray 
        The array formed by stacking the given arrays. 
 
    See Also 
    -------- 
    concatenate : Join a sequence of arrays along an existing axis. 
    stack : Join a sequence of arrays along a new axis. 
    block : Assemble an nd-array from nested lists of blocks. 
    vstack : Stack arrays in sequence vertically (row wise). 
    dstack : Stack arrays in sequence depth wise (along third axis). 
    column_stack : Stack 1-D arrays as columns into a 2-D array. 
    hsplit : Split an array into multiple sub-arrays horizontally (column-wise). 
 
    Examples 
    -------- 
    &gt;&gt;&gt; a = np.array((1,2,3)) 
    &gt;&gt;&gt; b = np.array((4,5,6)) 
    &gt;&gt;&gt; np.hstack((a,b)) 
    array([1, 2, 3, 4, 5, 6]) 
    &gt;&gt;&gt; a = np.array([[1],[2],[3]]) 
    &gt;&gt;&gt; b = np.array([[4],[5],[6]]) 
    &gt;&gt;&gt; np.hstack((a,b)) 
    array([[1, 4], 
           [2, 5], 
           [3, 6]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s0">overrides.ARRAY_FUNCTION_ENABLED:</span>
        <span class="s5"># raise warning if necessary</span>
        <span class="s0">_arrays_for_stack_dispatcher(tup</span><span class="s2">, </span><span class="s0">stacklevel=</span><span class="s4">2</span><span class="s0">)</span>

    <span class="s0">arrs = atleast_1d(*tup)</span>
    <span class="s2">if not </span><span class="s0">isinstance(arrs</span><span class="s2">, </span><span class="s0">list):</span>
        <span class="s0">arrs = [arrs]</span>
    <span class="s5"># As a special case, dimension 0 of 1-dimensional arrays is &quot;horizontal&quot;</span>
    <span class="s2">if </span><span class="s0">arrs </span><span class="s2">and </span><span class="s0">arrs[</span><span class="s4">0</span><span class="s0">].ndim == </span><span class="s4">1</span><span class="s0">:</span>
        <span class="s2">return </span><span class="s0">_nx.concatenate(arrs</span><span class="s2">, </span><span class="s4">0</span><span class="s0">)</span>
    <span class="s2">else</span><span class="s0">:</span>
        <span class="s2">return </span><span class="s0">_nx.concatenate(arrs</span><span class="s2">, </span><span class="s4">1</span><span class="s0">)</span>


<span class="s2">def </span><span class="s0">_stack_dispatcher(arrays</span><span class="s2">, </span><span class="s0">axis=</span><span class="s2">None, </span><span class="s0">out=</span><span class="s2">None</span><span class="s0">):</span>
    <span class="s0">arrays = _arrays_for_stack_dispatcher(arrays</span><span class="s2">, </span><span class="s0">stacklevel=</span><span class="s4">6</span><span class="s0">)</span>
    <span class="s2">if </span><span class="s0">out </span><span class="s2">is not None</span><span class="s0">:</span>
        <span class="s5"># optimize for the typical case where only arrays is provided</span>
        <span class="s0">arrays = list(arrays)</span>
        <span class="s0">arrays.append(out)</span>
    <span class="s2">return </span><span class="s0">arrays</span>


<span class="s0">@array_function_dispatch(_stack_dispatcher)</span>
<span class="s2">def </span><span class="s0">stack(arrays</span><span class="s2">, </span><span class="s0">axis=</span><span class="s4">0</span><span class="s2">, </span><span class="s0">out=</span><span class="s2">None</span><span class="s0">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Join a sequence of arrays along a new axis. 
 
    The ``axis`` parameter specifies the index of the new axis in the 
    dimensions of the result. For example, if ``axis=0`` it will be the first 
    dimension and if ``axis=-1`` it will be the last dimension. 
 
    .. versionadded:: 1.10.0 
 
    Parameters 
    ---------- 
    arrays : sequence of array_like 
        Each array must have the same shape. 
 
    axis : int, optional 
        The axis in the result array along which the input arrays are stacked. 
 
    out : ndarray, optional 
        If provided, the destination to place the result. The shape must be 
        correct, matching that of what stack would have returned if no 
        out argument were specified. 
 
    Returns 
    ------- 
    stacked : ndarray 
        The stacked array has one more dimension than the input arrays. 
 
    See Also 
    -------- 
    concatenate : Join a sequence of arrays along an existing axis. 
    block : Assemble an nd-array from nested lists of blocks. 
    split : Split array into a list of multiple sub-arrays of equal size. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; arrays = [np.random.randn(3, 4) for _ in range(10)] 
    &gt;&gt;&gt; np.stack(arrays, axis=0).shape 
    (10, 3, 4) 
 
    &gt;&gt;&gt; np.stack(arrays, axis=1).shape 
    (3, 10, 4) 
 
    &gt;&gt;&gt; np.stack(arrays, axis=2).shape 
    (3, 4, 10) 
 
    &gt;&gt;&gt; a = np.array([1, 2, 3]) 
    &gt;&gt;&gt; b = np.array([4, 5, 6]) 
    &gt;&gt;&gt; np.stack((a, b)) 
    array([[1, 2, 3], 
           [4, 5, 6]]) 
 
    &gt;&gt;&gt; np.stack((a, b), axis=-1) 
    array([[1, 4], 
           [2, 5], 
           [3, 6]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s0">overrides.ARRAY_FUNCTION_ENABLED:</span>
        <span class="s5"># raise warning if necessary</span>
        <span class="s0">_arrays_for_stack_dispatcher(arrays</span><span class="s2">, </span><span class="s0">stacklevel=</span><span class="s4">2</span><span class="s0">)</span>

    <span class="s0">arrays = [asanyarray(arr) </span><span class="s2">for </span><span class="s0">arr </span><span class="s2">in </span><span class="s0">arrays]</span>
    <span class="s2">if not </span><span class="s0">arrays:</span>
        <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">'need at least one array to stack'</span><span class="s0">)</span>

    <span class="s0">shapes = {arr.shape </span><span class="s2">for </span><span class="s0">arr </span><span class="s2">in </span><span class="s0">arrays}</span>
    <span class="s2">if </span><span class="s0">len(shapes) != </span><span class="s4">1</span><span class="s0">:</span>
        <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">'all input arrays must have the same shape'</span><span class="s0">)</span>

    <span class="s0">result_ndim = arrays[</span><span class="s4">0</span><span class="s0">].ndim + </span><span class="s4">1</span>
    <span class="s0">axis = normalize_axis_index(axis</span><span class="s2">, </span><span class="s0">result_ndim)</span>

    <span class="s0">sl = (slice(</span><span class="s2">None</span><span class="s0">)</span><span class="s2">,</span><span class="s0">) * axis + (_nx.newaxis</span><span class="s2">,</span><span class="s0">)</span>
    <span class="s0">expanded_arrays = [arr[sl] </span><span class="s2">for </span><span class="s0">arr </span><span class="s2">in </span><span class="s0">arrays]</span>
    <span class="s2">return </span><span class="s0">_nx.concatenate(expanded_arrays</span><span class="s2">, </span><span class="s0">axis=axis</span><span class="s2">, </span><span class="s0">out=out)</span>


<span class="s5"># Internal functions to eliminate the overhead of repeated dispatch in one of</span>
<span class="s5"># the two possible paths inside np.block.</span>
<span class="s5"># Use getattr to protect against __array_function__ being disabled.</span>
<span class="s0">_size = getattr(_from_nx.size</span><span class="s2">, </span><span class="s1">'__wrapped__'</span><span class="s2">, </span><span class="s0">_from_nx.size)</span>
<span class="s0">_ndim = getattr(_from_nx.ndim</span><span class="s2">, </span><span class="s1">'__wrapped__'</span><span class="s2">, </span><span class="s0">_from_nx.ndim)</span>
<span class="s0">_concatenate = getattr(_from_nx.concatenate</span><span class="s2">, </span><span class="s1">'__wrapped__'</span><span class="s2">, </span><span class="s0">_from_nx.concatenate)</span>


<span class="s2">def </span><span class="s0">_block_format_index(index):</span>
    <span class="s3">&quot;&quot;&quot; 
    Convert a list of indices ``[0, 1, 2]`` into ``&quot;arrays[0][1][2]&quot;``. 
    &quot;&quot;&quot;</span>
    <span class="s0">idx_str = </span><span class="s1">''</span><span class="s0">.join(</span><span class="s1">'[{}]'</span><span class="s0">.format(i) </span><span class="s2">for </span><span class="s0">i </span><span class="s2">in </span><span class="s0">index </span><span class="s2">if </span><span class="s0">i </span><span class="s2">is not None</span><span class="s0">)</span>
    <span class="s2">return </span><span class="s1">'arrays' </span><span class="s0">+ idx_str</span>


<span class="s2">def </span><span class="s0">_block_check_depths_match(arrays</span><span class="s2">, </span><span class="s0">parent_index=[]):</span>
    <span class="s3">&quot;&quot;&quot; 
    Recursive function checking that the depths of nested lists in `arrays` 
    all match. Mismatch raises a ValueError as described in the block 
    docstring below. 
 
    The entire index (rather than just the depth) needs to be calculated 
    for each innermost list, in case an error needs to be raised, so that 
    the index of the offending list can be printed as part of the error. 
 
    Parameters 
    ---------- 
    arrays : nested list of arrays 
        The arrays to check 
    parent_index : list of int 
        The full index of `arrays` within the nested lists passed to 
        `_block_check_depths_match` at the top of the recursion. 
 
    Returns 
    ------- 
    first_index : list of int 
        The full index of an element from the bottom of the nesting in 
        `arrays`. If any element at the bottom is an empty list, this will 
        refer to it, and the last index along the empty axis will be None. 
    max_arr_ndim : int 
        The maximum of the ndims of the arrays nested in `arrays`. 
    final_size: int 
        The number of elements in the final array. This is used the motivate 
        the choice of algorithm used using benchmarking wisdom. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s0">type(arrays) </span><span class="s2">is </span><span class="s0">tuple:</span>
        <span class="s5"># not strictly necessary, but saves us from:</span>
        <span class="s5">#  - more than one way to do things - no point treating tuples like</span>
        <span class="s5">#    lists</span>
        <span class="s5">#  - horribly confusing behaviour that results when tuples are</span>
        <span class="s5">#    treated like ndarray</span>
        <span class="s2">raise </span><span class="s0">TypeError(</span>
            <span class="s1">'{} is a tuple. '</span>
            <span class="s1">'Only lists can be used to arrange blocks, and np.block does '</span>
            <span class="s1">'not allow implicit conversion from tuple to ndarray.'</span><span class="s0">.format(</span>
                <span class="s0">_block_format_index(parent_index)</span>
            <span class="s0">)</span>
        <span class="s0">)</span>
    <span class="s2">elif </span><span class="s0">type(arrays) </span><span class="s2">is </span><span class="s0">list </span><span class="s2">and </span><span class="s0">len(arrays) &gt; </span><span class="s4">0</span><span class="s0">:</span>
        <span class="s0">idxs_ndims = (_block_check_depths_match(arr</span><span class="s2">, </span><span class="s0">parent_index + [i])</span>
                      <span class="s2">for </span><span class="s0">i</span><span class="s2">, </span><span class="s0">arr </span><span class="s2">in </span><span class="s0">enumerate(arrays))</span>

        <span class="s0">first_index</span><span class="s2">, </span><span class="s0">max_arr_ndim</span><span class="s2">, </span><span class="s0">final_size = next(idxs_ndims)</span>
        <span class="s2">for </span><span class="s0">index</span><span class="s2">, </span><span class="s0">ndim</span><span class="s2">, </span><span class="s0">size </span><span class="s2">in </span><span class="s0">idxs_ndims:</span>
            <span class="s0">final_size += size</span>
            <span class="s2">if </span><span class="s0">ndim &gt; max_arr_ndim:</span>
                <span class="s0">max_arr_ndim = ndim</span>
            <span class="s2">if </span><span class="s0">len(index) != len(first_index):</span>
                <span class="s2">raise </span><span class="s0">ValueError(</span>
                    <span class="s1">&quot;List depths are mismatched. First element was at depth &quot;</span>
                    <span class="s1">&quot;{}, but there is an element at depth {} ({})&quot;</span><span class="s0">.format(</span>
                        <span class="s0">len(first_index)</span><span class="s2">,</span>
                        <span class="s0">len(index)</span><span class="s2">,</span>
                        <span class="s0">_block_format_index(index)</span>
                    <span class="s0">)</span>
                <span class="s0">)</span>
            <span class="s5"># propagate our flag that indicates an empty list at the bottom</span>
            <span class="s2">if </span><span class="s0">index[-</span><span class="s4">1</span><span class="s0">] </span><span class="s2">is None</span><span class="s0">:</span>
                <span class="s0">first_index = index</span>

        <span class="s2">return </span><span class="s0">first_index</span><span class="s2">, </span><span class="s0">max_arr_ndim</span><span class="s2">, </span><span class="s0">final_size</span>
    <span class="s2">elif </span><span class="s0">type(arrays) </span><span class="s2">is </span><span class="s0">list </span><span class="s2">and </span><span class="s0">len(arrays) == </span><span class="s4">0</span><span class="s0">:</span>
        <span class="s5"># We've 'bottomed out' on an empty list</span>
        <span class="s2">return </span><span class="s0">parent_index + [</span><span class="s2">None</span><span class="s0">]</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span>
    <span class="s2">else</span><span class="s0">:</span>
        <span class="s5"># We've 'bottomed out' - arrays is either a scalar or an array</span>
        <span class="s0">size = _size(arrays)</span>
        <span class="s2">return </span><span class="s0">parent_index</span><span class="s2">, </span><span class="s0">_ndim(arrays)</span><span class="s2">, </span><span class="s0">size</span>


<span class="s2">def </span><span class="s0">_atleast_nd(a</span><span class="s2">, </span><span class="s0">ndim):</span>
    <span class="s5"># Ensures `a` has at least `ndim` dimensions by prepending</span>
    <span class="s5"># ones to `a.shape` as necessary</span>
    <span class="s2">return </span><span class="s0">array(a</span><span class="s2">, </span><span class="s0">ndmin=ndim</span><span class="s2">, </span><span class="s0">copy=</span><span class="s2">False, </span><span class="s0">subok=</span><span class="s2">True</span><span class="s0">)</span>


<span class="s2">def </span><span class="s0">_accumulate(values):</span>
    <span class="s2">return </span><span class="s0">list(itertools.accumulate(values))</span>


<span class="s2">def </span><span class="s0">_concatenate_shapes(shapes</span><span class="s2">, </span><span class="s0">axis):</span>
    <span class="s3">&quot;&quot;&quot;Given array shapes, return the resulting shape and slices prefixes. 
 
    These help in nested concatenation. 
     
    Returns 
    ------- 
    shape: tuple of int 
        This tuple satisfies: 
        ``` 
        shape, _ = _concatenate_shapes([arr.shape for shape in arrs], axis) 
        shape == concatenate(arrs, axis).shape 
        ``` 
 
    slice_prefixes: tuple of (slice(start, end), ) 
        For a list of arrays being concatenated, this returns the slice 
        in the larger array at axis that needs to be sliced into. 
 
        For example, the following holds: 
        ``` 
        ret = concatenate([a, b, c], axis) 
        _, (sl_a, sl_b, sl_c) = concatenate_slices([a, b, c], axis) 
 
        ret[(slice(None),) * axis + sl_a] == a 
        ret[(slice(None),) * axis + sl_b] == b 
        ret[(slice(None),) * axis + sl_c] == c 
        ``` 
 
        These are called slice prefixes since they are used in the recursive 
        blocking algorithm to compute the left-most slices during the 
        recursion. Therefore, they must be prepended to rest of the slice 
        that was computed deeper in the recursion. 
 
        These are returned as tuples to ensure that they can quickly be added 
        to existing slice tuple without creating a new tuple every time. 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># Cache a result that will be reused.</span>
    <span class="s0">shape_at_axis = [shape[axis] </span><span class="s2">for </span><span class="s0">shape </span><span class="s2">in </span><span class="s0">shapes]</span>

    <span class="s5"># Take a shape, any shape</span>
    <span class="s0">first_shape = shapes[</span><span class="s4">0</span><span class="s0">]</span>
    <span class="s0">first_shape_pre = first_shape[:axis]</span>
    <span class="s0">first_shape_post = first_shape[axis+</span><span class="s4">1</span><span class="s0">:]</span>

    <span class="s2">if </span><span class="s0">any(shape[:axis] != first_shape_pre </span><span class="s2">or</span>
           <span class="s0">shape[axis+</span><span class="s4">1</span><span class="s0">:] != first_shape_post </span><span class="s2">for </span><span class="s0">shape </span><span class="s2">in </span><span class="s0">shapes):</span>
        <span class="s2">raise </span><span class="s0">ValueError(</span>
            <span class="s1">'Mismatched array shapes in block along axis {}.'</span><span class="s0">.format(axis))</span>

    <span class="s0">shape = (first_shape_pre + (sum(shape_at_axis)</span><span class="s2">,</span><span class="s0">) + first_shape[axis+</span><span class="s4">1</span><span class="s0">:])</span>

    <span class="s0">offsets_at_axis = _accumulate(shape_at_axis)</span>
    <span class="s0">slice_prefixes = [(slice(start</span><span class="s2">, </span><span class="s0">end)</span><span class="s2">,</span><span class="s0">)</span>
                      <span class="s2">for </span><span class="s0">start</span><span class="s2">, </span><span class="s0">end </span><span class="s2">in </span><span class="s0">zip([</span><span class="s4">0</span><span class="s0">] + offsets_at_axis</span><span class="s2">,</span>
                                            <span class="s0">offsets_at_axis)]</span>
    <span class="s2">return </span><span class="s0">shape</span><span class="s2">, </span><span class="s0">slice_prefixes</span>


<span class="s2">def </span><span class="s0">_block_info_recursion(arrays</span><span class="s2">, </span><span class="s0">max_depth</span><span class="s2">, </span><span class="s0">result_ndim</span><span class="s2">, </span><span class="s0">depth=</span><span class="s4">0</span><span class="s0">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Returns the shape of the final array, along with a list 
    of slices and a list of arrays that can be used for assignment inside the 
    new array 
 
    Parameters 
    ---------- 
    arrays : nested list of arrays 
        The arrays to check 
    max_depth : list of int 
        The number of nested lists 
    result_ndim : int 
        The number of dimensions in thefinal array. 
 
    Returns 
    ------- 
    shape : tuple of int 
        The shape that the final array will take on. 
    slices: list of tuple of slices 
        The slices into the full array required for assignment. These are 
        required to be prepended with ``(Ellipsis, )`` to obtain to correct 
        final index. 
    arrays: list of ndarray 
        The data to assign to each slice of the full array 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s0">depth &lt; max_depth:</span>
        <span class="s0">shapes</span><span class="s2">, </span><span class="s0">slices</span><span class="s2">, </span><span class="s0">arrays = zip(</span>
            <span class="s0">*[_block_info_recursion(arr</span><span class="s2">, </span><span class="s0">max_depth</span><span class="s2">, </span><span class="s0">result_ndim</span><span class="s2">, </span><span class="s0">depth+</span><span class="s4">1</span><span class="s0">)</span>
              <span class="s2">for </span><span class="s0">arr </span><span class="s2">in </span><span class="s0">arrays])</span>

        <span class="s0">axis = result_ndim - max_depth + depth</span>
        <span class="s0">shape</span><span class="s2">, </span><span class="s0">slice_prefixes = _concatenate_shapes(shapes</span><span class="s2">, </span><span class="s0">axis)</span>

        <span class="s5"># Prepend the slice prefix and flatten the slices</span>
        <span class="s0">slices = [slice_prefix + the_slice</span>
                  <span class="s2">for </span><span class="s0">slice_prefix</span><span class="s2">, </span><span class="s0">inner_slices </span><span class="s2">in </span><span class="s0">zip(slice_prefixes</span><span class="s2">, </span><span class="s0">slices)</span>
                  <span class="s2">for </span><span class="s0">the_slice </span><span class="s2">in </span><span class="s0">inner_slices]</span>

        <span class="s5"># Flatten the array list</span>
        <span class="s0">arrays = functools.reduce(operator.add</span><span class="s2">, </span><span class="s0">arrays)</span>

        <span class="s2">return </span><span class="s0">shape</span><span class="s2">, </span><span class="s0">slices</span><span class="s2">, </span><span class="s0">arrays</span>
    <span class="s2">else</span><span class="s0">:</span>
        <span class="s5"># We've 'bottomed out' - arrays is either a scalar or an array</span>
        <span class="s5"># type(arrays) is not list</span>
        <span class="s5"># Return the slice and the array inside a list to be consistent with</span>
        <span class="s5"># the recursive case.</span>
        <span class="s0">arr = _atleast_nd(arrays</span><span class="s2">, </span><span class="s0">result_ndim)</span>
        <span class="s2">return </span><span class="s0">arr.shape</span><span class="s2">, </span><span class="s0">[()]</span><span class="s2">, </span><span class="s0">[arr]</span>


<span class="s2">def </span><span class="s0">_block(arrays</span><span class="s2">, </span><span class="s0">max_depth</span><span class="s2">, </span><span class="s0">result_ndim</span><span class="s2">, </span><span class="s0">depth=</span><span class="s4">0</span><span class="s0">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Internal implementation of block based on repeated concatenation. 
    `arrays` is the argument passed to 
    block. `max_depth` is the depth of nested lists within `arrays` and 
    `result_ndim` is the greatest of the dimensions of the arrays in 
    `arrays` and the depth of the lists in `arrays` (see block docstring 
    for details). 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s0">depth &lt; max_depth:</span>
        <span class="s0">arrs = [_block(arr</span><span class="s2">, </span><span class="s0">max_depth</span><span class="s2">, </span><span class="s0">result_ndim</span><span class="s2">, </span><span class="s0">depth+</span><span class="s4">1</span><span class="s0">)</span>
                <span class="s2">for </span><span class="s0">arr </span><span class="s2">in </span><span class="s0">arrays]</span>
        <span class="s2">return </span><span class="s0">_concatenate(arrs</span><span class="s2">, </span><span class="s0">axis=-(max_depth-depth))</span>
    <span class="s2">else</span><span class="s0">:</span>
        <span class="s5"># We've 'bottomed out' - arrays is either a scalar or an array</span>
        <span class="s5"># type(arrays) is not list</span>
        <span class="s2">return </span><span class="s0">_atleast_nd(arrays</span><span class="s2">, </span><span class="s0">result_ndim)</span>


<span class="s2">def </span><span class="s0">_block_dispatcher(arrays):</span>
    <span class="s5"># Use type(...) is list to match the behavior of np.block(), which special</span>
    <span class="s5"># cases list specifically rather than allowing for generic iterables or</span>
    <span class="s5"># tuple. Also, we know that list.__array_function__ will never exist.</span>
    <span class="s2">if </span><span class="s0">type(arrays) </span><span class="s2">is </span><span class="s0">list:</span>
        <span class="s2">for </span><span class="s0">subarrays </span><span class="s2">in </span><span class="s0">arrays:</span>
            <span class="s2">yield from </span><span class="s0">_block_dispatcher(subarrays)</span>
    <span class="s2">else</span><span class="s0">:</span>
        <span class="s2">yield </span><span class="s0">arrays</span>


<span class="s0">@array_function_dispatch(_block_dispatcher)</span>
<span class="s2">def </span><span class="s0">block(arrays):</span>
    <span class="s3">&quot;&quot;&quot; 
    Assemble an nd-array from nested lists of blocks. 
 
    Blocks in the innermost lists are concatenated (see `concatenate`) along 
    the last dimension (-1), then these are concatenated along the 
    second-last dimension (-2), and so on until the outermost list is reached. 
 
    Blocks can be of any dimension, but will not be broadcasted using the normal 
    rules. Instead, leading axes of size 1 are inserted, to make ``block.ndim`` 
    the same for all blocks. This is primarily useful for working with scalars, 
    and means that code like ``np.block([v, 1])`` is valid, where 
    ``v.ndim == 1``. 
 
    When the nested list is two levels deep, this allows block matrices to be 
    constructed from their components. 
 
    .. versionadded:: 1.13.0 
 
    Parameters 
    ---------- 
    arrays : nested list of array_like or scalars (but not tuples) 
        If passed a single ndarray or scalar (a nested list of depth 0), this 
        is returned unmodified (and not copied). 
 
        Elements shapes must match along the appropriate axes (without 
        broadcasting), but leading 1s will be prepended to the shape as 
        necessary to make the dimensions match. 
 
    Returns 
    ------- 
    block_array : ndarray 
        The array assembled from the given blocks. 
 
        The dimensionality of the output is equal to the greatest of: 
        * the dimensionality of all the inputs 
        * the depth to which the input list is nested 
 
    Raises 
    ------ 
    ValueError 
        * If list depths are mismatched - for instance, ``[[a, b], c]`` is 
          illegal, and should be spelt ``[[a, b], [c]]`` 
        * If lists are empty - for instance, ``[[a, b], []]`` 
 
    See Also 
    -------- 
    concatenate : Join a sequence of arrays along an existing axis. 
    stack : Join a sequence of arrays along a new axis. 
    vstack : Stack arrays in sequence vertically (row wise). 
    hstack : Stack arrays in sequence horizontally (column wise). 
    dstack : Stack arrays in sequence depth wise (along third axis). 
    column_stack : Stack 1-D arrays as columns into a 2-D array. 
    vsplit : Split an array into multiple sub-arrays vertically (row-wise). 
 
    Notes 
    ----- 
 
    When called with only scalars, ``np.block`` is equivalent to an ndarray 
    call. So ``np.block([[1, 2], [3, 4]])`` is equivalent to 
    ``np.array([[1, 2], [3, 4]])``. 
 
    This function does not enforce that the blocks lie on a fixed grid. 
    ``np.block([[a, b], [c, d]])`` is not restricted to arrays of the form:: 
 
        AAAbb 
        AAAbb 
        cccDD 
 
    But is also allowed to produce, for some ``a, b, c, d``:: 
 
        AAAbb 
        AAAbb 
        cDDDD 
 
    Since concatenation happens along the last axis first, `block` is _not_ 
    capable of producing the following directly:: 
 
        AAAbb 
        cccbb 
        cccDD 
 
    Matlab's &quot;square bracket stacking&quot;, ``[A, B, ...; p, q, ...]``, is 
    equivalent to ``np.block([[A, B, ...], [p, q, ...]])``. 
 
    Examples 
    -------- 
    The most common use of this function is to build a block matrix 
 
    &gt;&gt;&gt; A = np.eye(2) * 2 
    &gt;&gt;&gt; B = np.eye(3) * 3 
    &gt;&gt;&gt; np.block([ 
    ...     [A,               np.zeros((2, 3))], 
    ...     [np.ones((3, 2)), B               ] 
    ... ]) 
    array([[2., 0., 0., 0., 0.], 
           [0., 2., 0., 0., 0.], 
           [1., 1., 3., 0., 0.], 
           [1., 1., 0., 3., 0.], 
           [1., 1., 0., 0., 3.]]) 
 
    With a list of depth 1, `block` can be used as `hstack` 
 
    &gt;&gt;&gt; np.block([1, 2, 3])              # hstack([1, 2, 3]) 
    array([1, 2, 3]) 
 
    &gt;&gt;&gt; a = np.array([1, 2, 3]) 
    &gt;&gt;&gt; b = np.array([4, 5, 6]) 
    &gt;&gt;&gt; np.block([a, b, 10])             # hstack([a, b, 10]) 
    array([ 1,  2,  3,  4,  5,  6, 10]) 
 
    &gt;&gt;&gt; A = np.ones((2, 2), int) 
    &gt;&gt;&gt; B = 2 * A 
    &gt;&gt;&gt; np.block([A, B])                 # hstack([A, B]) 
    array([[1, 1, 2, 2], 
           [1, 1, 2, 2]]) 
 
    With a list of depth 2, `block` can be used in place of `vstack`: 
 
    &gt;&gt;&gt; a = np.array([1, 2, 3]) 
    &gt;&gt;&gt; b = np.array([4, 5, 6]) 
    &gt;&gt;&gt; np.block([[a], [b]])             # vstack([a, b]) 
    array([[1, 2, 3], 
           [4, 5, 6]]) 
 
    &gt;&gt;&gt; A = np.ones((2, 2), int) 
    &gt;&gt;&gt; B = 2 * A 
    &gt;&gt;&gt; np.block([[A], [B]])             # vstack([A, B]) 
    array([[1, 1], 
           [1, 1], 
           [2, 2], 
           [2, 2]]) 
 
    It can also be used in places of `atleast_1d` and `atleast_2d` 
 
    &gt;&gt;&gt; a = np.array(0) 
    &gt;&gt;&gt; b = np.array([1]) 
    &gt;&gt;&gt; np.block([a])                    # atleast_1d(a) 
    array([0]) 
    &gt;&gt;&gt; np.block([b])                    # atleast_1d(b) 
    array([1]) 
 
    &gt;&gt;&gt; np.block([[a]])                  # atleast_2d(a) 
    array([[0]]) 
    &gt;&gt;&gt; np.block([[b]])                  # atleast_2d(b) 
    array([[1]]) 
 
 
    &quot;&quot;&quot;</span>
    <span class="s0">arrays</span><span class="s2">, </span><span class="s0">list_ndim</span><span class="s2">, </span><span class="s0">result_ndim</span><span class="s2">, </span><span class="s0">final_size = _block_setup(arrays)</span>

    <span class="s5"># It was found through benchmarking that making an array of final size</span>
    <span class="s5"># around 256x256 was faster by straight concatenation on a</span>
    <span class="s5"># i7-7700HQ processor and dual channel ram 2400MHz.</span>
    <span class="s5"># It didn't seem to matter heavily on the dtype used.</span>
    <span class="s5">#</span>
    <span class="s5"># A 2D array using repeated concatenation requires 2 copies of the array.</span>
    <span class="s5">#</span>
    <span class="s5"># The fastest algorithm will depend on the ratio of CPU power to memory</span>
    <span class="s5"># speed.</span>
    <span class="s5"># One can monitor the results of the benchmark</span>
    <span class="s5"># https://pv.github.io/numpy-bench/#bench_shape_base.Block2D.time_block2d</span>
    <span class="s5"># to tune this parameter until a C version of the `_block_info_recursion`</span>
    <span class="s5"># algorithm is implemented which would likely be faster than the python</span>
    <span class="s5"># version.</span>
    <span class="s2">if </span><span class="s0">list_ndim * final_size &gt; (</span><span class="s4">2 </span><span class="s0">* </span><span class="s4">512 </span><span class="s0">* </span><span class="s4">512</span><span class="s0">):</span>
        <span class="s2">return </span><span class="s0">_block_slicing(arrays</span><span class="s2">, </span><span class="s0">list_ndim</span><span class="s2">, </span><span class="s0">result_ndim)</span>
    <span class="s2">else</span><span class="s0">:</span>
        <span class="s2">return </span><span class="s0">_block_concatenate(arrays</span><span class="s2">, </span><span class="s0">list_ndim</span><span class="s2">, </span><span class="s0">result_ndim)</span>


<span class="s5"># These helper functions are mostly used for testing.</span>
<span class="s5"># They allow us to write tests that directly call `_block_slicing`</span>
<span class="s5"># or `_block_concatenate` without blocking large arrays to force the wisdom</span>
<span class="s5"># to trigger the desired path.</span>
<span class="s2">def </span><span class="s0">_block_setup(arrays):</span>
    <span class="s3">&quot;&quot;&quot; 
    Returns 
    (`arrays`, list_ndim, result_ndim, final_size) 
    &quot;&quot;&quot;</span>
    <span class="s0">bottom_index</span><span class="s2">, </span><span class="s0">arr_ndim</span><span class="s2">, </span><span class="s0">final_size = _block_check_depths_match(arrays)</span>
    <span class="s0">list_ndim = len(bottom_index)</span>
    <span class="s2">if </span><span class="s0">bottom_index </span><span class="s2">and </span><span class="s0">bottom_index[-</span><span class="s4">1</span><span class="s0">] </span><span class="s2">is None</span><span class="s0">:</span>
        <span class="s2">raise </span><span class="s0">ValueError(</span>
            <span class="s1">'List at {} cannot be empty'</span><span class="s0">.format(</span>
                <span class="s0">_block_format_index(bottom_index)</span>
            <span class="s0">)</span>
        <span class="s0">)</span>
    <span class="s0">result_ndim = max(arr_ndim</span><span class="s2">, </span><span class="s0">list_ndim)</span>
    <span class="s2">return </span><span class="s0">arrays</span><span class="s2">, </span><span class="s0">list_ndim</span><span class="s2">, </span><span class="s0">result_ndim</span><span class="s2">, </span><span class="s0">final_size</span>


<span class="s2">def </span><span class="s0">_block_slicing(arrays</span><span class="s2">, </span><span class="s0">list_ndim</span><span class="s2">, </span><span class="s0">result_ndim):</span>
    <span class="s0">shape</span><span class="s2">, </span><span class="s0">slices</span><span class="s2">, </span><span class="s0">arrays = _block_info_recursion(</span>
        <span class="s0">arrays</span><span class="s2">, </span><span class="s0">list_ndim</span><span class="s2">, </span><span class="s0">result_ndim)</span>
    <span class="s0">dtype = _nx.result_type(*[arr.dtype </span><span class="s2">for </span><span class="s0">arr </span><span class="s2">in </span><span class="s0">arrays])</span>

    <span class="s5"># Test preferring F only in the case that all input arrays are F</span>
    <span class="s0">F_order = all(arr.flags[</span><span class="s1">'F_CONTIGUOUS'</span><span class="s0">] </span><span class="s2">for </span><span class="s0">arr </span><span class="s2">in </span><span class="s0">arrays)</span>
    <span class="s0">C_order = all(arr.flags[</span><span class="s1">'C_CONTIGUOUS'</span><span class="s0">] </span><span class="s2">for </span><span class="s0">arr </span><span class="s2">in </span><span class="s0">arrays)</span>
    <span class="s0">order = </span><span class="s1">'F' </span><span class="s2">if </span><span class="s0">F_order </span><span class="s2">and not </span><span class="s0">C_order </span><span class="s2">else </span><span class="s1">'C'</span>
    <span class="s0">result = _nx.empty(shape=shape</span><span class="s2">, </span><span class="s0">dtype=dtype</span><span class="s2">, </span><span class="s0">order=order)</span>
    <span class="s5"># Note: In a c implementation, the function</span>
    <span class="s5"># PyArray_CreateMultiSortedStridePerm could be used for more advanced</span>
    <span class="s5"># guessing of the desired order.</span>

    <span class="s2">for </span><span class="s0">the_slice</span><span class="s2">, </span><span class="s0">arr </span><span class="s2">in </span><span class="s0">zip(slices</span><span class="s2">, </span><span class="s0">arrays):</span>
        <span class="s0">result[(Ellipsis</span><span class="s2">,</span><span class="s0">) + the_slice] = arr</span>
    <span class="s2">return </span><span class="s0">result</span>


<span class="s2">def </span><span class="s0">_block_concatenate(arrays</span><span class="s2">, </span><span class="s0">list_ndim</span><span class="s2">, </span><span class="s0">result_ndim):</span>
    <span class="s0">result = _block(arrays</span><span class="s2">, </span><span class="s0">list_ndim</span><span class="s2">, </span><span class="s0">result_ndim)</span>
    <span class="s2">if </span><span class="s0">list_ndim == </span><span class="s4">0</span><span class="s0">:</span>
        <span class="s5"># Catch an edge case where _block returns a view because</span>
        <span class="s5"># `arrays` is a single numpy array and not a list of numpy arrays.</span>
        <span class="s5"># This might copy scalars or lists twice, but this isn't a likely</span>
        <span class="s5"># usecase for those interested in performance</span>
        <span class="s0">result = result.copy()</span>
    <span class="s2">return </span><span class="s0">result</span>
</pre>
</body>
</html>