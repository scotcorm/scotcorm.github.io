<html>
<head>
<title>misc_util.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
misc_util.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">copy</span>
<span class="s0">import </span><span class="s1">glob</span>
<span class="s0">import </span><span class="s1">atexit</span>
<span class="s0">import </span><span class="s1">tempfile</span>
<span class="s0">import </span><span class="s1">subprocess</span>
<span class="s0">import </span><span class="s1">shutil</span>
<span class="s0">import </span><span class="s1">multiprocessing</span>
<span class="s0">import </span><span class="s1">textwrap</span>
<span class="s0">import </span><span class="s1">importlib.util</span>
<span class="s0">from </span><span class="s1">threading </span><span class="s0">import </span><span class="s1">local </span><span class="s0">as </span><span class="s1">tlocal</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">reduce</span>

<span class="s0">import </span><span class="s1">distutils</span>
<span class="s0">from </span><span class="s1">distutils.errors </span><span class="s0">import </span><span class="s1">DistutilsError</span>

<span class="s2"># stores temporary directory of each thread to only create one per thread</span>
<span class="s1">_tdata = tlocal()</span>

<span class="s2"># store all created temporary directories so they can be deleted on exit</span>
<span class="s1">_tmpdirs = []</span>
<span class="s0">def </span><span class="s1">clean_up_temporary_directory():</span>
    <span class="s0">if </span><span class="s1">_tmpdirs </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">_tmpdirs:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">shutil.rmtree(d)</span>
            <span class="s0">except </span><span class="s1">OSError:</span>
                <span class="s0">pass</span>

<span class="s1">atexit.register(clean_up_temporary_directory)</span>

<span class="s1">__all__ = [</span><span class="s3">'Configuration'</span><span class="s0">, </span><span class="s3">'get_numpy_include_dirs'</span><span class="s0">, </span><span class="s3">'default_config_dict'</span><span class="s0">,</span>
           <span class="s3">'dict_append'</span><span class="s0">, </span><span class="s3">'appendpath'</span><span class="s0">, </span><span class="s3">'generate_config_py'</span><span class="s0">,</span>
           <span class="s3">'get_cmd'</span><span class="s0">, </span><span class="s3">'allpath'</span><span class="s0">, </span><span class="s3">'get_mathlibs'</span><span class="s0">,</span>
           <span class="s3">'terminal_has_colors'</span><span class="s0">, </span><span class="s3">'red_text'</span><span class="s0">, </span><span class="s3">'green_text'</span><span class="s0">, </span><span class="s3">'yellow_text'</span><span class="s0">,</span>
           <span class="s3">'blue_text'</span><span class="s0">, </span><span class="s3">'cyan_text'</span><span class="s0">, </span><span class="s3">'cyg2win32'</span><span class="s0">, </span><span class="s3">'mingw32'</span><span class="s0">, </span><span class="s3">'all_strings'</span><span class="s0">,</span>
           <span class="s3">'has_f_sources'</span><span class="s0">, </span><span class="s3">'has_cxx_sources'</span><span class="s0">, </span><span class="s3">'filter_sources'</span><span class="s0">,</span>
           <span class="s3">'get_dependencies'</span><span class="s0">, </span><span class="s3">'is_local_src_dir'</span><span class="s0">, </span><span class="s3">'get_ext_source_files'</span><span class="s0">,</span>
           <span class="s3">'get_script_files'</span><span class="s0">, </span><span class="s3">'get_lib_source_files'</span><span class="s0">, </span><span class="s3">'get_data_files'</span><span class="s0">,</span>
           <span class="s3">'dot_join'</span><span class="s0">, </span><span class="s3">'get_frame'</span><span class="s0">, </span><span class="s3">'minrelpath'</span><span class="s0">, </span><span class="s3">'njoin'</span><span class="s0">,</span>
           <span class="s3">'is_sequence'</span><span class="s0">, </span><span class="s3">'is_string'</span><span class="s0">, </span><span class="s3">'as_list'</span><span class="s0">, </span><span class="s3">'gpaths'</span><span class="s0">, </span><span class="s3">'get_language'</span><span class="s0">,</span>
           <span class="s3">'get_build_architecture'</span><span class="s0">, </span><span class="s3">'get_info'</span><span class="s0">, </span><span class="s3">'get_pkg_info'</span><span class="s0">,</span>
           <span class="s3">'get_num_build_jobs'</span><span class="s0">, </span><span class="s3">'sanitize_cxx_flags'</span><span class="s0">,</span>
           <span class="s3">'exec_mod_from_location'</span><span class="s1">]</span>

<span class="s0">class </span><span class="s1">InstallableLib:</span>
    <span class="s4">&quot;&quot;&quot; 
    Container to hold information on an installable library. 
 
    Parameters 
    ---------- 
    name : str 
        Name of the installed library. 
    build_info : dict 
        Dictionary holding build information. 
    target_dir : str 
        Absolute path specifying where to install the library. 
 
    See Also 
    -------- 
    Configuration.add_installed_library 
 
    Notes 
    ----- 
    The three parameters are stored as attributes with the same names. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">build_info</span><span class="s0">, </span><span class="s1">target_dir):</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.build_info = build_info</span>
        <span class="s1">self.target_dir = target_dir</span>


<span class="s0">def </span><span class="s1">get_num_build_jobs():</span>
    <span class="s4">&quot;&quot;&quot; 
    Get number of parallel build jobs set by the --parallel command line 
    argument of setup.py 
    If the command did not receive a setting the environment variable 
    NPY_NUM_BUILD_JOBS is checked. If that is unset, return the number of 
    processors on the system, with a maximum of 8 (to prevent 
    overloading the system if there a lot of CPUs). 
 
    Returns 
    ------- 
    out : int 
        number of parallel jobs that can be run 
 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">numpy.distutils.core </span><span class="s0">import </span><span class="s1">get_distribution</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">cpu_count = len(os.sched_getaffinity(</span><span class="s5">0</span><span class="s1">))</span>
    <span class="s0">except </span><span class="s1">AttributeError:</span>
        <span class="s1">cpu_count = multiprocessing.cpu_count()</span>
    <span class="s1">cpu_count = min(cpu_count</span><span class="s0">, </span><span class="s5">8</span><span class="s1">)</span>
    <span class="s1">envjobs = int(os.environ.get(</span><span class="s3">&quot;NPY_NUM_BUILD_JOBS&quot;</span><span class="s0">, </span><span class="s1">cpu_count))</span>
    <span class="s1">dist = get_distribution()</span>
    <span class="s2"># may be None during configuration</span>
    <span class="s0">if </span><span class="s1">dist </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">envjobs</span>

    <span class="s2"># any of these three may have the job set, take the largest</span>
    <span class="s1">cmdattr = (getattr(dist.get_command_obj(</span><span class="s3">'build'</span><span class="s1">)</span><span class="s0">, </span><span class="s3">'parallel'</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
               <span class="s1">getattr(dist.get_command_obj(</span><span class="s3">'build_ext'</span><span class="s1">)</span><span class="s0">, </span><span class="s3">'parallel'</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
               <span class="s1">getattr(dist.get_command_obj(</span><span class="s3">'build_clib'</span><span class="s1">)</span><span class="s0">, </span><span class="s3">'parallel'</span><span class="s0">, None</span><span class="s1">))</span>
    <span class="s0">if </span><span class="s1">all(x </span><span class="s0">is None for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">cmdattr):</span>
        <span class="s0">return </span><span class="s1">envjobs</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">max(x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">cmdattr </span><span class="s0">if </span><span class="s1">x </span><span class="s0">is not None</span><span class="s1">)</span>

<span class="s0">def </span><span class="s1">quote_args(args):</span>
    <span class="s4">&quot;&quot;&quot;Quote list of arguments. 
 
    .. deprecated:: 1.22. 
    &quot;&quot;&quot;</span>
    <span class="s0">import </span><span class="s1">warnings</span>
    <span class="s1">warnings.warn(</span><span class="s3">'&quot;quote_args&quot; is deprecated.'</span><span class="s0">,</span>
                  <span class="s1">DeprecationWarning</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s2"># don't used _nt_quote_args as it does not check if</span>
    <span class="s2"># args items already have quotes or not.</span>
    <span class="s1">args = list(args)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(args)):</span>
        <span class="s1">a = args[i]</span>
        <span class="s0">if </span><span class="s3">' ' </span><span class="s0">in </span><span class="s1">a </span><span class="s0">and </span><span class="s1">a[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">not in </span><span class="s3">'&quot;</span><span class="s0">\'</span><span class="s3">'</span><span class="s1">:</span>
            <span class="s1">args[i] = </span><span class="s3">'&quot;%s&quot;' </span><span class="s1">% (a)</span>
    <span class="s0">return </span><span class="s1">args</span>

<span class="s0">def </span><span class="s1">allpath(name):</span>
    <span class="s4">&quot;Convert a /-separated pathname to one using the OS's path separator.&quot;</span>
    <span class="s1">split = name.split(</span><span class="s3">'/'</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">os.path.join(*split)</span>

<span class="s0">def </span><span class="s1">rel_path(path</span><span class="s0">, </span><span class="s1">parent_path):</span>
    <span class="s4">&quot;&quot;&quot;Return path relative to parent_path.&quot;&quot;&quot;</span>
    <span class="s2"># Use realpath to avoid issues with symlinked dirs (see gh-7707)</span>
    <span class="s1">pd = os.path.realpath(os.path.abspath(parent_path))</span>
    <span class="s1">apath = os.path.realpath(os.path.abspath(path))</span>
    <span class="s0">if </span><span class="s1">len(apath) &lt; len(pd):</span>
        <span class="s0">return </span><span class="s1">path</span>
    <span class="s0">if </span><span class="s1">apath == pd:</span>
        <span class="s0">return </span><span class="s3">''</span>
    <span class="s0">if </span><span class="s1">pd == apath[:len(pd)]:</span>
        <span class="s0">assert </span><span class="s1">apath[len(pd)] </span><span class="s0">in </span><span class="s1">[os.sep]</span><span class="s0">, </span><span class="s1">repr((path</span><span class="s0">, </span><span class="s1">apath[len(pd)]))</span>
        <span class="s1">path = apath[len(pd)+</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s0">return </span><span class="s1">path</span>

<span class="s0">def </span><span class="s1">get_path_from_frame(frame</span><span class="s0">, </span><span class="s1">parent_path=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Return path of the module given a frame object from the call stack. 
 
    Returned path is relative to parent_path when given, 
    otherwise it is absolute path. 
    &quot;&quot;&quot;</span>

    <span class="s2"># First, try to find if the file name is in the frame.</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">caller_file = eval(</span><span class="s3">'__file__'</span><span class="s0">, </span><span class="s1">frame.f_globals</span><span class="s0">, </span><span class="s1">frame.f_locals)</span>
        <span class="s1">d = os.path.dirname(os.path.abspath(caller_file))</span>
    <span class="s0">except </span><span class="s1">NameError:</span>
        <span class="s2"># __file__ is not defined, so let's try __name__. We try this second</span>
        <span class="s2"># because setuptools spoofs __name__ to be '__main__' even though</span>
        <span class="s2"># sys.modules['__main__'] might be something else, like easy_install(1).</span>
        <span class="s1">caller_name = eval(</span><span class="s3">'__name__'</span><span class="s0">, </span><span class="s1">frame.f_globals</span><span class="s0">, </span><span class="s1">frame.f_locals)</span>
        <span class="s1">__import__(caller_name)</span>
        <span class="s1">mod = sys.modules[caller_name]</span>
        <span class="s0">if </span><span class="s1">hasattr(mod</span><span class="s0">, </span><span class="s3">'__file__'</span><span class="s1">):</span>
            <span class="s1">d = os.path.dirname(os.path.abspath(mod.__file__))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># we're probably running setup.py as execfile(&quot;setup.py&quot;)</span>
            <span class="s2"># (likely we're building an egg)</span>
            <span class="s1">d = os.path.abspath(</span><span class="s3">'.'</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">parent_path </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">d = rel_path(d</span><span class="s0">, </span><span class="s1">parent_path)</span>

    <span class="s0">return </span><span class="s1">d </span><span class="s0">or </span><span class="s3">'.'</span>

<span class="s0">def </span><span class="s1">njoin(*path):</span>
    <span class="s4">&quot;&quot;&quot;Join two or more pathname components + 
    - convert a /-separated pathname to one using the OS's path separator. 
    - resolve `..` and `.` from path. 
 
    Either passing n arguments as in njoin('a','b'), or a sequence 
    of n names as in njoin(['a','b']) is handled, or a mixture of such arguments. 
    &quot;&quot;&quot;</span>
    <span class="s1">paths = []</span>
    <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">path:</span>
        <span class="s0">if </span><span class="s1">is_sequence(p):</span>
            <span class="s2"># njoin(['a', 'b'], 'c')</span>
            <span class="s1">paths.append(njoin(*p))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">is_string(p)</span>
            <span class="s1">paths.append(p)</span>
    <span class="s1">path = paths</span>
    <span class="s0">if not </span><span class="s1">path:</span>
        <span class="s2"># njoin()</span>
        <span class="s1">joined = </span><span class="s3">''</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s2"># njoin('a', 'b')</span>
        <span class="s1">joined = os.path.join(*path)</span>
    <span class="s0">if </span><span class="s1">os.path.sep != </span><span class="s3">'/'</span><span class="s1">:</span>
        <span class="s1">joined = joined.replace(</span><span class="s3">'/'</span><span class="s0">, </span><span class="s1">os.path.sep)</span>
    <span class="s0">return </span><span class="s1">minrelpath(joined)</span>

<span class="s0">def </span><span class="s1">get_mathlibs(path=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Return the MATHLIB line from numpyconfig.h 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">path </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">config_file = os.path.join(path</span><span class="s0">, </span><span class="s3">'_numpyconfig.h'</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s2"># Look for the file in each of the numpy include directories.</span>
        <span class="s1">dirs = get_numpy_include_dirs()</span>
        <span class="s0">for </span><span class="s1">path </span><span class="s0">in </span><span class="s1">dirs:</span>
            <span class="s1">fn = os.path.join(path</span><span class="s0">, </span><span class="s3">'_numpyconfig.h'</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">os.path.exists(fn):</span>
                <span class="s1">config_file = fn</span>
                <span class="s0">break</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">DistutilsError(</span><span class="s3">'_numpyconfig.h not found in numpy include '</span>
                <span class="s3">'dirs %r' </span><span class="s1">% (dirs</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s0">with </span><span class="s1">open(config_file) </span><span class="s0">as </span><span class="s1">fid:</span>
        <span class="s1">mathlibs = []</span>
        <span class="s1">s = </span><span class="s3">'#define MATHLIB'</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">fid:</span>
            <span class="s0">if </span><span class="s1">line.startswith(s):</span>
                <span class="s1">value = line[len(s):].strip()</span>
                <span class="s0">if </span><span class="s1">value:</span>
                    <span class="s1">mathlibs.extend(value.split(</span><span class="s3">','</span><span class="s1">))</span>
    <span class="s0">return </span><span class="s1">mathlibs</span>

<span class="s0">def </span><span class="s1">minrelpath(path):</span>
    <span class="s4">&quot;&quot;&quot;Resolve `..` and '.' from path. 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">is_string(path):</span>
        <span class="s0">return </span><span class="s1">path</span>
    <span class="s0">if </span><span class="s3">'.' </span><span class="s0">not in </span><span class="s1">path:</span>
        <span class="s0">return </span><span class="s1">path</span>
    <span class="s1">l = path.split(os.sep)</span>
    <span class="s0">while </span><span class="s1">l:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">i = l.index(</span><span class="s3">'.'</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s0">break</span>
        <span class="s0">del </span><span class="s1">l[i]</span>
    <span class="s1">j = </span><span class="s5">1</span>
    <span class="s0">while </span><span class="s1">l:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">i = l.index(</span><span class="s3">'..'</span><span class="s0">, </span><span class="s1">j)</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s0">break</span>
        <span class="s0">if </span><span class="s1">l[i-</span><span class="s5">1</span><span class="s1">]==</span><span class="s3">'..'</span><span class="s1">:</span>
            <span class="s1">j += </span><span class="s5">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">del </span><span class="s1">l[i]</span><span class="s0">, </span><span class="s1">l[i-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">j = </span><span class="s5">1</span>
    <span class="s0">if not </span><span class="s1">l:</span>
        <span class="s0">return </span><span class="s3">''</span>
    <span class="s0">return </span><span class="s1">os.sep.join(l)</span>

<span class="s0">def </span><span class="s1">sorted_glob(fileglob):</span>
    <span class="s4">&quot;&quot;&quot;sorts output of python glob for https://bugs.python.org/issue30461 
    to allow extensions to have reproducible build results&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">sorted(glob.glob(fileglob))</span>

<span class="s0">def </span><span class="s1">_fix_paths(paths</span><span class="s0">, </span><span class="s1">local_path</span><span class="s0">, </span><span class="s1">include_non_existing):</span>
    <span class="s0">assert </span><span class="s1">is_sequence(paths)</span><span class="s0">, </span><span class="s1">repr(type(paths))</span>
    <span class="s1">new_paths = []</span>
    <span class="s0">assert not </span><span class="s1">is_string(paths)</span><span class="s0">, </span><span class="s1">repr(paths)</span>
    <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">paths:</span>
        <span class="s0">if </span><span class="s1">is_string(n):</span>
            <span class="s0">if </span><span class="s3">'*' </span><span class="s0">in </span><span class="s1">n </span><span class="s0">or </span><span class="s3">'?' </span><span class="s0">in </span><span class="s1">n:</span>
                <span class="s1">p = sorted_glob(n)</span>
                <span class="s1">p2 = sorted_glob(njoin(local_path</span><span class="s0">, </span><span class="s1">n))</span>
                <span class="s0">if </span><span class="s1">p2:</span>
                    <span class="s1">new_paths.extend(p2)</span>
                <span class="s0">elif </span><span class="s1">p:</span>
                    <span class="s1">new_paths.extend(p)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">include_non_existing:</span>
                        <span class="s1">new_paths.append(n)</span>
                    <span class="s1">print(</span><span class="s3">'could not resolve pattern in %r: %r' </span><span class="s1">%</span>
                            <span class="s1">(local_path</span><span class="s0">, </span><span class="s1">n))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">n2 = njoin(local_path</span><span class="s0">, </span><span class="s1">n)</span>
                <span class="s0">if </span><span class="s1">os.path.exists(n2):</span>
                    <span class="s1">new_paths.append(n2)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">os.path.exists(n):</span>
                        <span class="s1">new_paths.append(n)</span>
                    <span class="s0">elif </span><span class="s1">include_non_existing:</span>
                        <span class="s1">new_paths.append(n)</span>
                    <span class="s0">if not </span><span class="s1">os.path.exists(n):</span>
                        <span class="s1">print(</span><span class="s3">'non-existing path in %r: %r' </span><span class="s1">%</span>
                                <span class="s1">(local_path</span><span class="s0">, </span><span class="s1">n))</span>

        <span class="s0">elif </span><span class="s1">is_sequence(n):</span>
            <span class="s1">new_paths.extend(_fix_paths(n</span><span class="s0">, </span><span class="s1">local_path</span><span class="s0">, </span><span class="s1">include_non_existing))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">new_paths.append(n)</span>
    <span class="s0">return </span><span class="s1">[minrelpath(p) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">new_paths]</span>

<span class="s0">def </span><span class="s1">gpaths(paths</span><span class="s0">, </span><span class="s1">local_path=</span><span class="s3">''</span><span class="s0">, </span><span class="s1">include_non_existing=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Apply glob to paths and prepend local_path if needed. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">is_string(paths):</span>
        <span class="s1">paths = (paths</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">_fix_paths(paths</span><span class="s0">, </span><span class="s1">local_path</span><span class="s0">, </span><span class="s1">include_non_existing)</span>

<span class="s0">def </span><span class="s1">make_temp_file(suffix=</span><span class="s3">''</span><span class="s0">, </span><span class="s1">prefix=</span><span class="s3">''</span><span class="s0">, </span><span class="s1">text=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s0">if not </span><span class="s1">hasattr(_tdata</span><span class="s0">, </span><span class="s3">'tempdir'</span><span class="s1">):</span>
        <span class="s1">_tdata.tempdir = tempfile.mkdtemp()</span>
        <span class="s1">_tmpdirs.append(_tdata.tempdir)</span>
    <span class="s1">fid</span><span class="s0">, </span><span class="s1">name = tempfile.mkstemp(suffix=suffix</span><span class="s0">,</span>
                                 <span class="s1">prefix=prefix</span><span class="s0">,</span>
                                 <span class="s1">dir=_tdata.tempdir</span><span class="s0">,</span>
                                 <span class="s1">text=text)</span>
    <span class="s1">fo = os.fdopen(fid</span><span class="s0">, </span><span class="s3">'w'</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">fo</span><span class="s0">, </span><span class="s1">name</span>

<span class="s2"># Hooks for colored terminal output.</span>
<span class="s2"># See also https://web.archive.org/web/20100314204946/http://www.livinglogic.de/Python/ansistyle</span>
<span class="s0">def </span><span class="s1">terminal_has_colors():</span>
    <span class="s0">if </span><span class="s1">sys.platform==</span><span class="s3">'cygwin' </span><span class="s0">and </span><span class="s3">'USE_COLOR' </span><span class="s0">not in </span><span class="s1">os.environ:</span>
        <span class="s2"># Avoid importing curses that causes illegal operation</span>
        <span class="s2"># with a message:</span>
        <span class="s2">#  PYTHON2 caused an invalid page fault in</span>
        <span class="s2">#  module CYGNURSES7.DLL as 015f:18bbfc28</span>
        <span class="s2"># Details: Python 2.3.3 [GCC 3.3.1 (cygming special)]</span>
        <span class="s2">#          ssh to Win32 machine from debian</span>
        <span class="s2">#          curses.version is 2.2</span>
        <span class="s2">#          CYGWIN_98-4.10, release 1.5.7(0.109/3/2))</span>
        <span class="s0">return </span><span class="s5">0</span>
    <span class="s0">if </span><span class="s1">hasattr(sys.stdout</span><span class="s0">, </span><span class="s3">'isatty'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">sys.stdout.isatty():</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">import </span><span class="s1">curses</span>
            <span class="s1">curses.setupterm()</span>
            <span class="s0">if </span><span class="s1">(curses.tigetnum(</span><span class="s3">&quot;colors&quot;</span><span class="s1">) &gt;= </span><span class="s5">0</span>
                <span class="s0">and </span><span class="s1">curses.tigetnum(</span><span class="s3">&quot;pairs&quot;</span><span class="s1">) &gt;= </span><span class="s5">0</span>
                <span class="s0">and </span><span class="s1">((curses.tigetstr(</span><span class="s3">&quot;setf&quot;</span><span class="s1">) </span><span class="s0">is not None</span>
                      <span class="s0">and </span><span class="s1">curses.tigetstr(</span><span class="s3">&quot;setb&quot;</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">)</span>
                     <span class="s0">or </span><span class="s1">(curses.tigetstr(</span><span class="s3">&quot;setaf&quot;</span><span class="s1">) </span><span class="s0">is not None</span>
                         <span class="s0">and </span><span class="s1">curses.tigetstr(</span><span class="s3">&quot;setab&quot;</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">)</span>
                     <span class="s0">or </span><span class="s1">curses.tigetstr(</span><span class="s3">&quot;scp&quot;</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">)):</span>
                <span class="s0">return </span><span class="s5">1</span>
        <span class="s0">except </span><span class="s1">Exception:</span>
            <span class="s0">pass</span>
    <span class="s0">return </span><span class="s5">0</span>

<span class="s0">if </span><span class="s1">terminal_has_colors():</span>
    <span class="s1">_colour_codes = dict(black=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">red=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">green=</span><span class="s5">2</span><span class="s0">, </span><span class="s1">yellow=</span><span class="s5">3</span><span class="s0">,</span>
                         <span class="s1">blue=</span><span class="s5">4</span><span class="s0">, </span><span class="s1">magenta=</span><span class="s5">5</span><span class="s0">, </span><span class="s1">cyan=</span><span class="s5">6</span><span class="s0">, </span><span class="s1">white=</span><span class="s5">7</span><span class="s0">, </span><span class="s1">default=</span><span class="s5">9</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">colour_text(s</span><span class="s0">, </span><span class="s1">fg=</span><span class="s0">None, </span><span class="s1">bg=</span><span class="s0">None, </span><span class="s1">bold=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s1">seq = []</span>
        <span class="s0">if </span><span class="s1">bold:</span>
            <span class="s1">seq.append(</span><span class="s3">'1'</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">fg:</span>
            <span class="s1">fgcode = </span><span class="s5">30 </span><span class="s1">+ _colour_codes.get(fg.lower()</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">seq.append(str(fgcode))</span>
        <span class="s0">if </span><span class="s1">bg:</span>
            <span class="s1">bgcode = </span><span class="s5">40 </span><span class="s1">+ _colour_codes.get(fg.lower()</span><span class="s0">, </span><span class="s5">7</span><span class="s1">)</span>
            <span class="s1">seq.append(str(bgcode))</span>
        <span class="s0">if </span><span class="s1">seq:</span>
            <span class="s0">return </span><span class="s3">'</span><span class="s0">\x1b</span><span class="s3">[%sm%s</span><span class="s0">\x1b</span><span class="s3">[0m' </span><span class="s1">% (</span><span class="s3">';'</span><span class="s1">.join(seq)</span><span class="s0">, </span><span class="s1">s)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">s</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">colour_text(s</span><span class="s0">, </span><span class="s1">fg=</span><span class="s0">None, </span><span class="s1">bg=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">s</span>

<span class="s0">def </span><span class="s1">default_text(s):</span>
    <span class="s0">return </span><span class="s1">colour_text(s</span><span class="s0">, </span><span class="s3">'default'</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">red_text(s):</span>
    <span class="s0">return </span><span class="s1">colour_text(s</span><span class="s0">, </span><span class="s3">'red'</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">green_text(s):</span>
    <span class="s0">return </span><span class="s1">colour_text(s</span><span class="s0">, </span><span class="s3">'green'</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">yellow_text(s):</span>
    <span class="s0">return </span><span class="s1">colour_text(s</span><span class="s0">, </span><span class="s3">'yellow'</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">cyan_text(s):</span>
    <span class="s0">return </span><span class="s1">colour_text(s</span><span class="s0">, </span><span class="s3">'cyan'</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">blue_text(s):</span>
    <span class="s0">return </span><span class="s1">colour_text(s</span><span class="s0">, </span><span class="s3">'blue'</span><span class="s1">)</span>

<span class="s2">#########################</span>

<span class="s0">def </span><span class="s1">cyg2win32(path: str) -&gt; str:</span>
    <span class="s4">&quot;&quot;&quot;Convert a path from Cygwin-native to Windows-native. 
 
    Uses the cygpath utility (part of the Base install) to do the 
    actual conversion.  Falls back to returning the original path if 
    this fails. 
 
    Handles the default ``/cygdrive`` mount prefix as well as the 
    ``/proc/cygdrive`` portable prefix, custom cygdrive prefixes such 
    as ``/`` or ``/mnt``, and absolute paths such as ``/usr/src/`` or 
    ``/home/username`` 
 
    Parameters 
    ---------- 
    path : str 
       The path to convert 
 
    Returns 
    ------- 
    converted_path : str 
        The converted path 
 
    Notes 
    ----- 
    Documentation for cygpath utility: 
    https://cygwin.com/cygwin-ug-net/cygpath.html 
    Documentation for the C function it wraps: 
    https://cygwin.com/cygwin-api/func-cygwin-conv-path.html 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">sys.platform != </span><span class="s3">&quot;cygwin&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">path</span>
    <span class="s0">return </span><span class="s1">subprocess.check_output(</span>
        <span class="s1">[</span><span class="s3">&quot;/usr/bin/cygpath&quot;</span><span class="s0">, </span><span class="s3">&quot;--windows&quot;</span><span class="s0">, </span><span class="s1">path]</span><span class="s0">, </span><span class="s1">universal_newlines=</span><span class="s0">True</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">mingw32():</span>
    <span class="s4">&quot;&quot;&quot;Return true when using mingw32 environment. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">sys.platform==</span><span class="s3">'win32'</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">os.environ.get(</span><span class="s3">'OSTYPE'</span><span class="s0">, </span><span class="s3">''</span><span class="s1">)==</span><span class="s3">'msys'</span><span class="s1">:</span>
            <span class="s0">return True</span>
        <span class="s0">if </span><span class="s1">os.environ.get(</span><span class="s3">'MSYSTEM'</span><span class="s0">, </span><span class="s3">''</span><span class="s1">)==</span><span class="s3">'MINGW32'</span><span class="s1">:</span>
            <span class="s0">return True</span>
    <span class="s0">return False</span>

<span class="s0">def </span><span class="s1">msvc_runtime_version():</span>
    <span class="s4">&quot;Return version of MSVC runtime library, as defined by __MSC_VER__ macro&quot;</span>
    <span class="s1">msc_pos = sys.version.find(</span><span class="s3">'MSC v.'</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">msc_pos != -</span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">msc_ver = int(sys.version[msc_pos+</span><span class="s5">6</span><span class="s1">:msc_pos+</span><span class="s5">10</span><span class="s1">])</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">msc_ver = </span><span class="s0">None</span>
    <span class="s0">return </span><span class="s1">msc_ver</span>

<span class="s0">def </span><span class="s1">msvc_runtime_library():</span>
    <span class="s4">&quot;Return name of MSVC runtime library if Python was built with MSVC &gt;= 7&quot;</span>
    <span class="s1">ver = msvc_runtime_major ()</span>
    <span class="s0">if </span><span class="s1">ver:</span>
        <span class="s0">if </span><span class="s1">ver &lt; </span><span class="s5">140</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s3">&quot;msvcr%i&quot; </span><span class="s1">% ver</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s3">&quot;vcruntime%i&quot; </span><span class="s1">% ver</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return None</span>

<span class="s0">def </span><span class="s1">msvc_runtime_major():</span>
    <span class="s4">&quot;Return major version of MSVC runtime coded like get_build_msvc_version&quot;</span>
    <span class="s1">major = {</span><span class="s5">1300</span><span class="s1">:  </span><span class="s5">70</span><span class="s0">,  </span><span class="s2"># MSVC 7.0</span>
             <span class="s5">1310</span><span class="s1">:  </span><span class="s5">71</span><span class="s0">,  </span><span class="s2"># MSVC 7.1</span>
             <span class="s5">1400</span><span class="s1">:  </span><span class="s5">80</span><span class="s0">,  </span><span class="s2"># MSVC 8</span>
             <span class="s5">1500</span><span class="s1">:  </span><span class="s5">90</span><span class="s0">,  </span><span class="s2"># MSVC 9  (aka 2008)</span>
             <span class="s5">1600</span><span class="s1">: </span><span class="s5">100</span><span class="s0">,  </span><span class="s2"># MSVC 10 (aka 2010)</span>
             <span class="s5">1900</span><span class="s1">: </span><span class="s5">140</span><span class="s0">,  </span><span class="s2"># MSVC 14 (aka 2015)</span>
    <span class="s1">}.get(msvc_runtime_version()</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">major</span>

<span class="s2">#########################</span>

<span class="s2">#XXX need support for .C that is also C++</span>
<span class="s1">cxx_ext_match = re.compile(</span><span class="s3">r'.*\.(cpp|cxx|cc)\Z'</span><span class="s0">, </span><span class="s1">re.I).match</span>
<span class="s1">fortran_ext_match = re.compile(</span><span class="s3">r'.*\.(f90|f95|f77|for|ftn|f)\Z'</span><span class="s0">, </span><span class="s1">re.I).match</span>
<span class="s1">f90_ext_match = re.compile(</span><span class="s3">r'.*\.(f90|f95)\Z'</span><span class="s0">, </span><span class="s1">re.I).match</span>
<span class="s1">f90_module_name_match = re.compile(</span><span class="s3">r'\s*module\s*(?P&lt;name&gt;[\w_]+)'</span><span class="s0">, </span><span class="s1">re.I).match</span>
<span class="s0">def </span><span class="s1">_get_f90_modules(source):</span>
    <span class="s4">&quot;&quot;&quot;Return a list of Fortran f90 module names that 
    given source file defines. 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">f90_ext_match(source):</span>
        <span class="s0">return </span><span class="s1">[]</span>
    <span class="s1">modules = []</span>
    <span class="s0">with </span><span class="s1">open(source</span><span class="s0">, </span><span class="s3">'r'</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">f:</span>
            <span class="s1">m = f90_module_name_match(line)</span>
            <span class="s0">if </span><span class="s1">m:</span>
                <span class="s1">name = m.group(</span><span class="s3">'name'</span><span class="s1">)</span>
                <span class="s1">modules.append(name)</span>
                <span class="s2"># break  # XXX can we assume that there is one module per file?</span>
    <span class="s0">return </span><span class="s1">modules</span>

<span class="s0">def </span><span class="s1">is_string(s):</span>
    <span class="s0">return </span><span class="s1">isinstance(s</span><span class="s0">, </span><span class="s1">str)</span>

<span class="s0">def </span><span class="s1">all_strings(lst):</span>
    <span class="s4">&quot;&quot;&quot;Return True if all items in lst are string objects. &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">lst:</span>
        <span class="s0">if not </span><span class="s1">is_string(item):</span>
            <span class="s0">return False</span>
    <span class="s0">return True</span>

<span class="s0">def </span><span class="s1">is_sequence(seq):</span>
    <span class="s0">if </span><span class="s1">is_string(seq):</span>
        <span class="s0">return False</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">len(seq)</span>
    <span class="s0">except </span><span class="s1">Exception:</span>
        <span class="s0">return False</span>
    <span class="s0">return True</span>

<span class="s0">def </span><span class="s1">is_glob_pattern(s):</span>
    <span class="s0">return </span><span class="s1">is_string(s) </span><span class="s0">and </span><span class="s1">(</span><span class="s3">'*' </span><span class="s0">in </span><span class="s1">s </span><span class="s0">or </span><span class="s3">'?' </span><span class="s0">in </span><span class="s1">s)</span>

<span class="s0">def </span><span class="s1">as_list(seq):</span>
    <span class="s0">if </span><span class="s1">is_sequence(seq):</span>
        <span class="s0">return </span><span class="s1">list(seq)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">[seq]</span>

<span class="s0">def </span><span class="s1">get_language(sources):</span>
    <span class="s2"># not used in numpy/scipy packages, use build_ext.detect_language instead</span>
    <span class="s4">&quot;&quot;&quot;Determine language value (c,f77,f90) from sources &quot;&quot;&quot;</span>
    <span class="s1">language = </span><span class="s0">None</span>
    <span class="s0">for </span><span class="s1">source </span><span class="s0">in </span><span class="s1">sources:</span>
        <span class="s0">if </span><span class="s1">isinstance(source</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">if </span><span class="s1">f90_ext_match(source):</span>
                <span class="s1">language = </span><span class="s3">'f90'</span>
                <span class="s0">break</span>
            <span class="s0">elif </span><span class="s1">fortran_ext_match(source):</span>
                <span class="s1">language = </span><span class="s3">'f77'</span>
    <span class="s0">return </span><span class="s1">language</span>

<span class="s0">def </span><span class="s1">has_f_sources(sources):</span>
    <span class="s4">&quot;&quot;&quot;Return True if sources contains Fortran files &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">source </span><span class="s0">in </span><span class="s1">sources:</span>
        <span class="s0">if </span><span class="s1">fortran_ext_match(source):</span>
            <span class="s0">return True</span>
    <span class="s0">return False</span>

<span class="s0">def </span><span class="s1">has_cxx_sources(sources):</span>
    <span class="s4">&quot;&quot;&quot;Return True if sources contains C++ files &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">source </span><span class="s0">in </span><span class="s1">sources:</span>
        <span class="s0">if </span><span class="s1">cxx_ext_match(source):</span>
            <span class="s0">return True</span>
    <span class="s0">return False</span>

<span class="s0">def </span><span class="s1">filter_sources(sources):</span>
    <span class="s4">&quot;&quot;&quot;Return four lists of filenames containing 
    C, C++, Fortran, and Fortran 90 module sources, 
    respectively. 
    &quot;&quot;&quot;</span>
    <span class="s1">c_sources = []</span>
    <span class="s1">cxx_sources = []</span>
    <span class="s1">f_sources = []</span>
    <span class="s1">fmodule_sources = []</span>
    <span class="s0">for </span><span class="s1">source </span><span class="s0">in </span><span class="s1">sources:</span>
        <span class="s0">if </span><span class="s1">fortran_ext_match(source):</span>
            <span class="s1">modules = _get_f90_modules(source)</span>
            <span class="s0">if </span><span class="s1">modules:</span>
                <span class="s1">fmodule_sources.append(source)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">f_sources.append(source)</span>
        <span class="s0">elif </span><span class="s1">cxx_ext_match(source):</span>
            <span class="s1">cxx_sources.append(source)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">c_sources.append(source)</span>
    <span class="s0">return </span><span class="s1">c_sources</span><span class="s0">, </span><span class="s1">cxx_sources</span><span class="s0">, </span><span class="s1">f_sources</span><span class="s0">, </span><span class="s1">fmodule_sources</span>


<span class="s0">def </span><span class="s1">_get_headers(directory_list):</span>
    <span class="s2"># get *.h files from list of directories</span>
    <span class="s1">headers = []</span>
    <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">directory_list:</span>
        <span class="s1">head = sorted_glob(os.path.join(d</span><span class="s0">, </span><span class="s3">&quot;*.h&quot;</span><span class="s1">)) </span><span class="s2">#XXX: *.hpp files??</span>
        <span class="s1">headers.extend(head)</span>
    <span class="s0">return </span><span class="s1">headers</span>

<span class="s0">def </span><span class="s1">_get_directories(list_of_sources):</span>
    <span class="s2"># get unique directories from list of sources.</span>
    <span class="s1">direcs = []</span>
    <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">list_of_sources:</span>
        <span class="s1">d = os.path.split(f)</span>
        <span class="s0">if </span><span class="s1">d[</span><span class="s5">0</span><span class="s1">] != </span><span class="s3">'' </span><span class="s0">and not </span><span class="s1">d[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">in </span><span class="s1">direcs:</span>
            <span class="s1">direcs.append(d[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s0">return </span><span class="s1">direcs</span>

<span class="s0">def </span><span class="s1">_commandline_dep_string(cc_args</span><span class="s0">, </span><span class="s1">extra_postargs</span><span class="s0">, </span><span class="s1">pp_opts):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return commandline representation used to determine if a file needs 
    to be recompiled 
    &quot;&quot;&quot;</span>
    <span class="s1">cmdline = </span><span class="s3">'commandline: '</span>
    <span class="s1">cmdline += </span><span class="s3">' '</span><span class="s1">.join(cc_args)</span>
    <span class="s1">cmdline += </span><span class="s3">' '</span><span class="s1">.join(extra_postargs)</span>
    <span class="s1">cmdline += </span><span class="s3">' '</span><span class="s1">.join(pp_opts) + </span><span class="s3">'</span><span class="s0">\n</span><span class="s3">'</span>
    <span class="s0">return </span><span class="s1">cmdline</span>


<span class="s0">def </span><span class="s1">get_dependencies(sources):</span>
    <span class="s2">#XXX scan sources for include statements</span>
    <span class="s0">return </span><span class="s1">_get_headers(_get_directories(sources))</span>

<span class="s0">def </span><span class="s1">is_local_src_dir(directory):</span>
    <span class="s4">&quot;&quot;&quot;Return true if directory is local directory. 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">is_string(directory):</span>
        <span class="s0">return False</span>
    <span class="s1">abs_dir = os.path.abspath(directory)</span>
    <span class="s1">c = os.path.commonprefix([os.getcwd()</span><span class="s0">, </span><span class="s1">abs_dir])</span>
    <span class="s1">new_dir = abs_dir[len(c):].split(os.sep)</span>
    <span class="s0">if </span><span class="s1">new_dir </span><span class="s0">and not </span><span class="s1">new_dir[</span><span class="s5">0</span><span class="s1">]:</span>
        <span class="s1">new_dir = new_dir[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s0">if </span><span class="s1">new_dir </span><span class="s0">and </span><span class="s1">new_dir[</span><span class="s5">0</span><span class="s1">]==</span><span class="s3">'build'</span><span class="s1">:</span>
        <span class="s0">return False</span>
    <span class="s1">new_dir = os.sep.join(new_dir)</span>
    <span class="s0">return </span><span class="s1">os.path.isdir(new_dir)</span>

<span class="s0">def </span><span class="s1">general_source_files(top_path):</span>
    <span class="s1">pruned_directories = {</span><span class="s3">'CVS'</span><span class="s1">:</span><span class="s5">1</span><span class="s0">, </span><span class="s3">'.svn'</span><span class="s1">:</span><span class="s5">1</span><span class="s0">, </span><span class="s3">'build'</span><span class="s1">:</span><span class="s5">1</span><span class="s1">}</span>
    <span class="s1">prune_file_pat = re.compile(</span><span class="s3">r'(?:[~#]|\.py[co]|\.o)$'</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">dirpath</span><span class="s0">, </span><span class="s1">dirnames</span><span class="s0">, </span><span class="s1">filenames </span><span class="s0">in </span><span class="s1">os.walk(top_path</span><span class="s0">, </span><span class="s1">topdown=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s1">pruned = [ d </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">dirnames </span><span class="s0">if </span><span class="s1">d </span><span class="s0">not in </span><span class="s1">pruned_directories ]</span>
        <span class="s1">dirnames[:] = pruned</span>
        <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">filenames:</span>
            <span class="s0">if not </span><span class="s1">prune_file_pat.search(f):</span>
                <span class="s0">yield </span><span class="s1">os.path.join(dirpath</span><span class="s0">, </span><span class="s1">f)</span>

<span class="s0">def </span><span class="s1">general_source_directories_files(top_path):</span>
    <span class="s4">&quot;&quot;&quot;Return a directory name relative to top_path and 
    files contained. 
    &quot;&quot;&quot;</span>
    <span class="s1">pruned_directories = [</span><span class="s3">'CVS'</span><span class="s0">, </span><span class="s3">'.svn'</span><span class="s0">, </span><span class="s3">'build'</span><span class="s1">]</span>
    <span class="s1">prune_file_pat = re.compile(</span><span class="s3">r'(?:[~#]|\.py[co]|\.o)$'</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">dirpath</span><span class="s0">, </span><span class="s1">dirnames</span><span class="s0">, </span><span class="s1">filenames </span><span class="s0">in </span><span class="s1">os.walk(top_path</span><span class="s0">, </span><span class="s1">topdown=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s1">pruned = [ d </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">dirnames </span><span class="s0">if </span><span class="s1">d </span><span class="s0">not in </span><span class="s1">pruned_directories ]</span>
        <span class="s1">dirnames[:] = pruned</span>
        <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">dirnames:</span>
            <span class="s1">dpath = os.path.join(dirpath</span><span class="s0">, </span><span class="s1">d)</span>
            <span class="s1">rpath = rel_path(dpath</span><span class="s0">, </span><span class="s1">top_path)</span>
            <span class="s1">files = []</span>
            <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">os.listdir(dpath):</span>
                <span class="s1">fn = os.path.join(dpath</span><span class="s0">, </span><span class="s1">f)</span>
                <span class="s0">if </span><span class="s1">os.path.isfile(fn) </span><span class="s0">and not </span><span class="s1">prune_file_pat.search(fn):</span>
                    <span class="s1">files.append(fn)</span>
            <span class="s0">yield </span><span class="s1">rpath</span><span class="s0">, </span><span class="s1">files</span>
    <span class="s1">dpath = top_path</span>
    <span class="s1">rpath = rel_path(dpath</span><span class="s0">, </span><span class="s1">top_path)</span>
    <span class="s1">filenames = [os.path.join(dpath</span><span class="s0">, </span><span class="s1">f) </span><span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">os.listdir(dpath) \</span>
                 <span class="s0">if not </span><span class="s1">prune_file_pat.search(f)]</span>
    <span class="s1">files = [f </span><span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">filenames </span><span class="s0">if </span><span class="s1">os.path.isfile(f)]</span>
    <span class="s0">yield </span><span class="s1">rpath</span><span class="s0">, </span><span class="s1">files</span>


<span class="s0">def </span><span class="s1">get_ext_source_files(ext):</span>
    <span class="s2"># Get sources and any include files in the same directory.</span>
    <span class="s1">filenames = []</span>
    <span class="s1">sources = [_m </span><span class="s0">for </span><span class="s1">_m </span><span class="s0">in </span><span class="s1">ext.sources </span><span class="s0">if </span><span class="s1">is_string(_m)]</span>
    <span class="s1">filenames.extend(sources)</span>
    <span class="s1">filenames.extend(get_dependencies(sources))</span>
    <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">ext.depends:</span>
        <span class="s0">if </span><span class="s1">is_local_src_dir(d):</span>
            <span class="s1">filenames.extend(list(general_source_files(d)))</span>
        <span class="s0">elif </span><span class="s1">os.path.isfile(d):</span>
            <span class="s1">filenames.append(d)</span>
    <span class="s0">return </span><span class="s1">filenames</span>

<span class="s0">def </span><span class="s1">get_script_files(scripts):</span>
    <span class="s1">scripts = [_m </span><span class="s0">for </span><span class="s1">_m </span><span class="s0">in </span><span class="s1">scripts </span><span class="s0">if </span><span class="s1">is_string(_m)]</span>
    <span class="s0">return </span><span class="s1">scripts</span>

<span class="s0">def </span><span class="s1">get_lib_source_files(lib):</span>
    <span class="s1">filenames = []</span>
    <span class="s1">sources = lib[</span><span class="s5">1</span><span class="s1">].get(</span><span class="s3">'sources'</span><span class="s0">, </span><span class="s1">[])</span>
    <span class="s1">sources = [_m </span><span class="s0">for </span><span class="s1">_m </span><span class="s0">in </span><span class="s1">sources </span><span class="s0">if </span><span class="s1">is_string(_m)]</span>
    <span class="s1">filenames.extend(sources)</span>
    <span class="s1">filenames.extend(get_dependencies(sources))</span>
    <span class="s1">depends = lib[</span><span class="s5">1</span><span class="s1">].get(</span><span class="s3">'depends'</span><span class="s0">, </span><span class="s1">[])</span>
    <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">depends:</span>
        <span class="s0">if </span><span class="s1">is_local_src_dir(d):</span>
            <span class="s1">filenames.extend(list(general_source_files(d)))</span>
        <span class="s0">elif </span><span class="s1">os.path.isfile(d):</span>
            <span class="s1">filenames.append(d)</span>
    <span class="s0">return </span><span class="s1">filenames</span>

<span class="s0">def </span><span class="s1">get_shared_lib_extension(is_python_ext=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Return the correct file extension for shared libraries. 
 
    Parameters 
    ---------- 
    is_python_ext : bool, optional 
        Whether the shared library is a Python extension.  Default is False. 
 
    Returns 
    ------- 
    so_ext : str 
        The shared library extension. 
 
    Notes 
    ----- 
    For Python shared libs, `so_ext` will typically be '.so' on Linux and OS X, 
    and '.pyd' on Windows.  For Python &gt;= 3.2 `so_ext` has a tag prepended on 
    POSIX systems according to PEP 3149.  For Python 3.2 this is implemented on 
    Linux, but not on OS X. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">confvars = distutils.sysconfig.get_config_vars()</span>
    <span class="s2"># SO is deprecated in 3.3.1, use EXT_SUFFIX instead</span>
    <span class="s1">so_ext = confvars.get(</span><span class="s3">'EXT_SUFFIX'</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">so_ext </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">so_ext = confvars.get(</span><span class="s3">'SO'</span><span class="s0">, </span><span class="s3">''</span><span class="s1">)</span>

    <span class="s0">if not </span><span class="s1">is_python_ext:</span>
        <span class="s2"># hardcode known values, config vars (including SHLIB_SUFFIX) are</span>
        <span class="s2"># unreliable (see #3182)</span>
        <span class="s2"># darwin, windows and debug linux are wrong in 3.3.1 and older</span>
        <span class="s0">if </span><span class="s1">(sys.platform.startswith(</span><span class="s3">'linux'</span><span class="s1">) </span><span class="s0">or</span>
            <span class="s1">sys.platform.startswith(</span><span class="s3">'gnukfreebsd'</span><span class="s1">)):</span>
            <span class="s1">so_ext = </span><span class="s3">'.so'</span>
        <span class="s0">elif </span><span class="s1">sys.platform.startswith(</span><span class="s3">'darwin'</span><span class="s1">):</span>
            <span class="s1">so_ext = </span><span class="s3">'.dylib'</span>
        <span class="s0">elif </span><span class="s1">sys.platform.startswith(</span><span class="s3">'win'</span><span class="s1">):</span>
            <span class="s1">so_ext = </span><span class="s3">'.dll'</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># fall back to config vars for unknown platforms</span>
            <span class="s2"># fix long extension for Python &gt;=3.2, see PEP 3149.</span>
            <span class="s0">if </span><span class="s3">'SOABI' </span><span class="s0">in </span><span class="s1">confvars:</span>
                <span class="s2"># Does nothing unless SOABI config var exists</span>
                <span class="s1">so_ext = so_ext.replace(</span><span class="s3">'.' </span><span class="s1">+ confvars.get(</span><span class="s3">'SOABI'</span><span class="s1">)</span><span class="s0">, </span><span class="s3">''</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">so_ext</span>

<span class="s0">def </span><span class="s1">get_data_files(data):</span>
    <span class="s0">if </span><span class="s1">is_string(data):</span>
        <span class="s0">return </span><span class="s1">[data]</span>
    <span class="s1">sources = data[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">filenames = []</span>
    <span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">sources:</span>
        <span class="s0">if </span><span class="s1">hasattr(s</span><span class="s0">, </span><span class="s3">'__call__'</span><span class="s1">):</span>
            <span class="s0">continue</span>
        <span class="s0">if </span><span class="s1">is_local_src_dir(s):</span>
            <span class="s1">filenames.extend(list(general_source_files(s)))</span>
        <span class="s0">elif </span><span class="s1">is_string(s):</span>
            <span class="s0">if </span><span class="s1">os.path.isfile(s):</span>
                <span class="s1">filenames.append(s)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">print(</span><span class="s3">'Not existing data file:'</span><span class="s0">, </span><span class="s1">s)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(repr(s))</span>
    <span class="s0">return </span><span class="s1">filenames</span>

<span class="s0">def </span><span class="s1">dot_join(*args):</span>
    <span class="s0">return </span><span class="s3">'.'</span><span class="s1">.join([a </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">args </span><span class="s0">if </span><span class="s1">a])</span>

<span class="s0">def </span><span class="s1">get_frame(level=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Return frame object from call stack with given level. 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">sys._getframe(level+</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s0">except </span><span class="s1">AttributeError:</span>
        <span class="s1">frame = sys.exc_info()[</span><span class="s5">2</span><span class="s1">].tb_frame</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(level+</span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">frame = frame.f_back</span>
        <span class="s0">return </span><span class="s1">frame</span>


<span class="s2">######################</span>

<span class="s0">class </span><span class="s1">Configuration:</span>

    <span class="s1">_list_keys = [</span><span class="s3">'packages'</span><span class="s0">, </span><span class="s3">'ext_modules'</span><span class="s0">, </span><span class="s3">'data_files'</span><span class="s0">, </span><span class="s3">'include_dirs'</span><span class="s0">,</span>
                  <span class="s3">'libraries'</span><span class="s0">, </span><span class="s3">'headers'</span><span class="s0">, </span><span class="s3">'scripts'</span><span class="s0">, </span><span class="s3">'py_modules'</span><span class="s0">,</span>
                  <span class="s3">'installed_libraries'</span><span class="s0">, </span><span class="s3">'define_macros'</span><span class="s1">]</span>
    <span class="s1">_dict_keys = [</span><span class="s3">'package_dir'</span><span class="s0">, </span><span class="s3">'installed_pkg_config'</span><span class="s1">]</span>
    <span class="s1">_extra_keys = [</span><span class="s3">'name'</span><span class="s0">, </span><span class="s3">'version'</span><span class="s1">]</span>

    <span class="s1">numpy_include_dirs = []</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">,</span>
                 <span class="s1">package_name=</span><span class="s0">None,</span>
                 <span class="s1">parent_name=</span><span class="s0">None,</span>
                 <span class="s1">top_path=</span><span class="s0">None,</span>
                 <span class="s1">package_path=</span><span class="s0">None,</span>
                 <span class="s1">caller_level=</span><span class="s5">1</span><span class="s0">,</span>
                 <span class="s1">setup_name=</span><span class="s3">'setup.py'</span><span class="s0">,</span>
                 <span class="s1">**attrs):</span>
        <span class="s4">&quot;&quot;&quot;Construct configuration instance of a package. 
 
        package_name -- name of the package 
                        Ex.: 'distutils' 
        parent_name  -- name of the parent package 
                        Ex.: 'numpy' 
        top_path     -- directory of the toplevel package 
                        Ex.: the directory where the numpy package source sits 
        package_path -- directory of package. Will be computed by magic from the 
                        directory of the caller module if not specified 
                        Ex.: the directory where numpy.distutils is 
        caller_level -- frame level to caller namespace, internal parameter. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.name = dot_join(parent_name</span><span class="s0">, </span><span class="s1">package_name)</span>
        <span class="s1">self.version = </span><span class="s0">None</span>

        <span class="s1">caller_frame = get_frame(caller_level)</span>
        <span class="s1">self.local_path = get_path_from_frame(caller_frame</span><span class="s0">, </span><span class="s1">top_path)</span>
        <span class="s2"># local_path -- directory of a file (usually setup.py) that</span>
        <span class="s2">#               defines a configuration() function.</span>
        <span class="s2"># local_path -- directory of a file (usually setup.py) that</span>
        <span class="s2">#               defines a configuration() function.</span>
        <span class="s0">if </span><span class="s1">top_path </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">top_path = self.local_path</span>
            <span class="s1">self.local_path = </span><span class="s3">''</span>
        <span class="s0">if </span><span class="s1">package_path </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">package_path = self.local_path</span>
        <span class="s0">elif </span><span class="s1">os.path.isdir(njoin(self.local_path</span><span class="s0">, </span><span class="s1">package_path)):</span>
            <span class="s1">package_path = njoin(self.local_path</span><span class="s0">, </span><span class="s1">package_path)</span>
        <span class="s0">if not </span><span class="s1">os.path.isdir(package_path </span><span class="s0">or </span><span class="s3">'.'</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;%r is not a directory&quot; </span><span class="s1">% (package_path</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">self.top_path = top_path</span>
        <span class="s1">self.package_path = package_path</span>
        <span class="s2"># this is the relative path in the installed package</span>
        <span class="s1">self.path_in_package = os.path.join(*self.name.split(</span><span class="s3">'.'</span><span class="s1">))</span>

        <span class="s1">self.list_keys = self._list_keys[:]</span>
        <span class="s1">self.dict_keys = self._dict_keys[:]</span>

        <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">self.list_keys:</span>
            <span class="s1">v = copy.copy(attrs.get(n</span><span class="s0">, </span><span class="s1">[]))</span>
            <span class="s1">setattr(self</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">as_list(v))</span>

        <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">self.dict_keys:</span>
            <span class="s1">v = copy.copy(attrs.get(n</span><span class="s0">, </span><span class="s1">{}))</span>
            <span class="s1">setattr(self</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">v)</span>

        <span class="s1">known_keys = self.list_keys + self.dict_keys</span>
        <span class="s1">self.extra_keys = self._extra_keys[:]</span>
        <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">attrs.keys():</span>
            <span class="s0">if </span><span class="s1">n </span><span class="s0">in </span><span class="s1">known_keys:</span>
                <span class="s0">continue</span>
            <span class="s1">a = attrs[n]</span>
            <span class="s1">setattr(self</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">a)</span>
            <span class="s0">if </span><span class="s1">isinstance(a</span><span class="s0">, </span><span class="s1">list):</span>
                <span class="s1">self.list_keys.append(n)</span>
            <span class="s0">elif </span><span class="s1">isinstance(a</span><span class="s0">, </span><span class="s1">dict):</span>
                <span class="s1">self.dict_keys.append(n)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.extra_keys.append(n)</span>

        <span class="s0">if </span><span class="s1">os.path.exists(njoin(package_path</span><span class="s0">, </span><span class="s3">'__init__.py'</span><span class="s1">)):</span>
            <span class="s1">self.packages.append(self.name)</span>
            <span class="s1">self.package_dir[self.name] = package_path</span>

        <span class="s1">self.options = dict(</span>
            <span class="s1">ignore_setup_xxx_py = </span><span class="s0">False,</span>
            <span class="s1">assume_default_configuration = </span><span class="s0">False,</span>
            <span class="s1">delegate_options_to_subpackages = </span><span class="s0">False,</span>
            <span class="s1">quiet = </span><span class="s0">False,</span>
            <span class="s1">)</span>

        <span class="s1">caller_instance = </span><span class="s0">None</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">):</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">f = get_frame(i)</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s0">break</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">caller_instance = eval(</span><span class="s3">'self'</span><span class="s0">, </span><span class="s1">f.f_globals</span><span class="s0">, </span><span class="s1">f.f_locals)</span>
                <span class="s0">break</span>
            <span class="s0">except </span><span class="s1">NameError:</span>
                <span class="s0">pass</span>
        <span class="s0">if </span><span class="s1">isinstance(caller_instance</span><span class="s0">, </span><span class="s1">self.__class__):</span>
            <span class="s0">if </span><span class="s1">caller_instance.options[</span><span class="s3">'delegate_options_to_subpackages'</span><span class="s1">]:</span>
                <span class="s1">self.set_options(**caller_instance.options)</span>

        <span class="s1">self.setup_name = setup_name</span>

    <span class="s0">def </span><span class="s1">todict(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return a dictionary compatible with the keyword arguments of distutils 
        setup function. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; setup(**config.todict())                           #doctest: +SKIP 
        &quot;&quot;&quot;</span>

        <span class="s1">self._optimize_data_files()</span>
        <span class="s1">d = {}</span>
        <span class="s1">known_keys = self.list_keys + self.dict_keys + self.extra_keys</span>
        <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">known_keys:</span>
            <span class="s1">a = getattr(self</span><span class="s0">, </span><span class="s1">n)</span>
            <span class="s0">if </span><span class="s1">a:</span>
                <span class="s1">d[n] = a</span>
        <span class="s0">return </span><span class="s1">d</span>

    <span class="s0">def </span><span class="s1">info(self</span><span class="s0">, </span><span class="s1">message):</span>
        <span class="s0">if not </span><span class="s1">self.options[</span><span class="s3">'quiet'</span><span class="s1">]:</span>
            <span class="s1">print(message)</span>

    <span class="s0">def </span><span class="s1">warn(self</span><span class="s0">, </span><span class="s1">message):</span>
        <span class="s1">sys.stderr.write(</span><span class="s3">'Warning: %s</span><span class="s0">\n</span><span class="s3">' </span><span class="s1">% (message</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">set_options(self</span><span class="s0">, </span><span class="s1">**options):</span>
        <span class="s4">&quot;&quot;&quot; 
        Configure Configuration instance. 
 
        The following options are available: 
         - ignore_setup_xxx_py 
         - assume_default_configuration 
         - delegate_options_to_subpackages 
         - quiet 
 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">options.items():</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self.options:</span>
                <span class="s1">self.options[key] = value</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">'Unknown option: '</span><span class="s1">+key)</span>

    <span class="s0">def </span><span class="s1">get_distribution(self):</span>
        <span class="s4">&quot;&quot;&quot;Return the distutils distribution object for self.&quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">numpy.distutils.core </span><span class="s0">import </span><span class="s1">get_distribution</span>
        <span class="s0">return </span><span class="s1">get_distribution()</span>

    <span class="s0">def </span><span class="s1">_wildcard_get_subpackage(self</span><span class="s0">, </span><span class="s1">subpackage_name</span><span class="s0">,</span>
                                 <span class="s1">parent_name</span><span class="s0">,</span>
                                 <span class="s1">caller_level = </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s1">l = subpackage_name.split(</span><span class="s3">'.'</span><span class="s1">)</span>
        <span class="s1">subpackage_path = njoin([self.local_path]+l)</span>
        <span class="s1">dirs = [_m </span><span class="s0">for </span><span class="s1">_m </span><span class="s0">in </span><span class="s1">sorted_glob(subpackage_path) </span><span class="s0">if </span><span class="s1">os.path.isdir(_m)]</span>
        <span class="s1">config_list = []</span>
        <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">dirs:</span>
            <span class="s0">if not </span><span class="s1">os.path.isfile(njoin(d</span><span class="s0">, </span><span class="s3">'__init__.py'</span><span class="s1">)):</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s3">'build' </span><span class="s0">in </span><span class="s1">d.split(os.sep):</span>
                <span class="s0">continue</span>
            <span class="s1">n = </span><span class="s3">'.'</span><span class="s1">.join(d.split(os.sep)[-len(l):])</span>
            <span class="s1">c = self.get_subpackage(n</span><span class="s0">,</span>
                                    <span class="s1">parent_name = parent_name</span><span class="s0">,</span>
                                    <span class="s1">caller_level = caller_level+</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">config_list.extend(c)</span>
        <span class="s0">return </span><span class="s1">config_list</span>

    <span class="s0">def </span><span class="s1">_get_configuration_from_setup_py(self</span><span class="s0">, </span><span class="s1">setup_py</span><span class="s0">,</span>
                                         <span class="s1">subpackage_name</span><span class="s0">,</span>
                                         <span class="s1">subpackage_path</span><span class="s0">,</span>
                                         <span class="s1">parent_name</span><span class="s0">,</span>
                                         <span class="s1">caller_level = </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s2"># In case setup_py imports local modules:</span>
        <span class="s1">sys.path.insert(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">os.path.dirname(setup_py))</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">setup_name = os.path.splitext(os.path.basename(setup_py))[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">n = dot_join(self.name</span><span class="s0">, </span><span class="s1">subpackage_name</span><span class="s0">, </span><span class="s1">setup_name)</span>
            <span class="s1">setup_module = exec_mod_from_location(</span>
                                <span class="s3">'_'</span><span class="s1">.join(n.split(</span><span class="s3">'.'</span><span class="s1">))</span><span class="s0">, </span><span class="s1">setup_py)</span>
            <span class="s0">if not </span><span class="s1">hasattr(setup_module</span><span class="s0">, </span><span class="s3">'configuration'</span><span class="s1">):</span>
                <span class="s0">if not </span><span class="s1">self.options[</span><span class="s3">'assume_default_configuration'</span><span class="s1">]:</span>
                    <span class="s1">self.warn(</span><span class="s3">'Assuming default configuration '</span><span class="s1">\</span>
                              <span class="s3">'(%s does not define configuration())'</span><span class="s1">\</span>
                              <span class="s1">% (setup_module))</span>
                <span class="s1">config = Configuration(subpackage_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">,</span>
                                       <span class="s1">self.top_path</span><span class="s0">, </span><span class="s1">subpackage_path</span><span class="s0">,</span>
                                       <span class="s1">caller_level = caller_level + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">pn = dot_join(*([parent_name] + subpackage_name.split(</span><span class="s3">'.'</span><span class="s1">)[:-</span><span class="s5">1</span><span class="s1">]))</span>
                <span class="s1">args = (pn</span><span class="s0">,</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">setup_module.configuration.__code__.co_argcount &gt; </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">args = args + (self.top_path</span><span class="s0">,</span><span class="s1">)</span>
                <span class="s1">config = setup_module.configuration(*args)</span>
            <span class="s0">if </span><span class="s1">config.name!=dot_join(parent_name</span><span class="s0">, </span><span class="s1">subpackage_name):</span>
                <span class="s1">self.warn(</span><span class="s3">'Subpackage %r configuration returned as %r' </span><span class="s1">% \</span>
                          <span class="s1">(dot_join(parent_name</span><span class="s0">, </span><span class="s1">subpackage_name)</span><span class="s0">, </span><span class="s1">config.name))</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">del </span><span class="s1">sys.path[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">config</span>

    <span class="s0">def </span><span class="s1">get_subpackage(self</span><span class="s0">,</span><span class="s1">subpackage_name</span><span class="s0">,</span>
                       <span class="s1">subpackage_path=</span><span class="s0">None,</span>
                       <span class="s1">parent_name=</span><span class="s0">None,</span>
                       <span class="s1">caller_level = </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Return list of subpackage configurations. 
 
        Parameters 
        ---------- 
        subpackage_name : str or None 
            Name of the subpackage to get the configuration. '*' in 
            subpackage_name is handled as a wildcard. 
        subpackage_path : str 
            If None, then the path is assumed to be the local path plus the 
            subpackage_name. If a setup.py file is not found in the 
            subpackage_path, then a default configuration is used. 
        parent_name : str 
            Parent name. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">subpackage_name </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">subpackage_path </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;either subpackage_name or subpackage_path must be specified&quot;</span><span class="s1">)</span>
            <span class="s1">subpackage_name = os.path.basename(subpackage_path)</span>

        <span class="s2"># handle wildcards</span>
        <span class="s1">l = subpackage_name.split(</span><span class="s3">'.'</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">subpackage_path </span><span class="s0">is None and </span><span class="s3">'*' </span><span class="s0">in </span><span class="s1">subpackage_name:</span>
            <span class="s0">return </span><span class="s1">self._wildcard_get_subpackage(subpackage_name</span><span class="s0">,</span>
                                                 <span class="s1">parent_name</span><span class="s0">,</span>
                                                 <span class="s1">caller_level = caller_level+</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s3">'*' </span><span class="s0">not in </span><span class="s1">subpackage_name</span><span class="s0">, </span><span class="s1">repr((subpackage_name</span><span class="s0">, </span><span class="s1">subpackage_path</span><span class="s0">, </span><span class="s1">parent_name))</span>
        <span class="s0">if </span><span class="s1">subpackage_path </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">subpackage_path = njoin([self.local_path] + l)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">subpackage_path = njoin([subpackage_path] + l[:-</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s1">subpackage_path = self.paths([subpackage_path])[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">setup_py = njoin(subpackage_path</span><span class="s0">, </span><span class="s1">self.setup_name)</span>
        <span class="s0">if not </span><span class="s1">self.options[</span><span class="s3">'ignore_setup_xxx_py'</span><span class="s1">]:</span>
            <span class="s0">if not </span><span class="s1">os.path.isfile(setup_py):</span>
                <span class="s1">setup_py = njoin(subpackage_path</span><span class="s0">,</span>
                                 <span class="s3">'setup_%s.py' </span><span class="s1">% (subpackage_name))</span>
        <span class="s0">if not </span><span class="s1">os.path.isfile(setup_py):</span>
            <span class="s0">if not </span><span class="s1">self.options[</span><span class="s3">'assume_default_configuration'</span><span class="s1">]:</span>
                <span class="s1">self.warn(</span><span class="s3">'Assuming default configuration '</span><span class="s1">\</span>
                          <span class="s3">'(%s/{setup_%s,setup}.py was not found)' </span><span class="s1">\</span>
                          <span class="s1">% (os.path.dirname(setup_py)</span><span class="s0">, </span><span class="s1">subpackage_name))</span>
            <span class="s1">config = Configuration(subpackage_name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">,</span>
                                   <span class="s1">self.top_path</span><span class="s0">, </span><span class="s1">subpackage_path</span><span class="s0">,</span>
                                   <span class="s1">caller_level = caller_level+</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">config = self._get_configuration_from_setup_py(</span>
                <span class="s1">setup_py</span><span class="s0">,</span>
                <span class="s1">subpackage_name</span><span class="s0">,</span>
                <span class="s1">subpackage_path</span><span class="s0">,</span>
                <span class="s1">parent_name</span><span class="s0">,</span>
                <span class="s1">caller_level = caller_level + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">config:</span>
            <span class="s0">return </span><span class="s1">[config]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">[]</span>

    <span class="s0">def </span><span class="s1">add_subpackage(self</span><span class="s0">,</span><span class="s1">subpackage_name</span><span class="s0">,</span>
                       <span class="s1">subpackage_path=</span><span class="s0">None,</span>
                       <span class="s1">standalone = </span><span class="s0">False</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Add a sub-package to the current Configuration instance. 
 
        This is useful in a setup.py script for adding sub-packages to a 
        package. 
 
        Parameters 
        ---------- 
        subpackage_name : str 
            name of the subpackage 
        subpackage_path : str 
            if given, the subpackage path such as the subpackage is in 
            subpackage_path / subpackage_name. If None,the subpackage is 
            assumed to be located in the local path / subpackage_name. 
        standalone : bool 
        &quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">standalone:</span>
            <span class="s1">parent_name = </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">parent_name = self.name</span>
        <span class="s1">config_list = self.get_subpackage(subpackage_name</span><span class="s0">, </span><span class="s1">subpackage_path</span><span class="s0">,</span>
                                          <span class="s1">parent_name = parent_name</span><span class="s0">,</span>
                                          <span class="s1">caller_level = </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">config_list:</span>
            <span class="s1">self.warn(</span><span class="s3">'No configuration returned, assuming unavailable.'</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">config </span><span class="s0">in </span><span class="s1">config_list:</span>
            <span class="s1">d = config</span>
            <span class="s0">if </span><span class="s1">isinstance(config</span><span class="s0">, </span><span class="s1">Configuration):</span>
                <span class="s1">d = config.todict()</span>
            <span class="s0">assert </span><span class="s1">isinstance(d</span><span class="s0">, </span><span class="s1">dict)</span><span class="s0">, </span><span class="s1">repr(type(d))</span>

            <span class="s1">self.info(</span><span class="s3">'Appending %s configuration to %s' </span><span class="s1">\</span>
                      <span class="s1">% (d.get(</span><span class="s3">'name'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">self.name))</span>
            <span class="s1">self.dict_append(**d)</span>

        <span class="s1">dist = self.get_distribution()</span>
        <span class="s0">if </span><span class="s1">dist </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.warn(</span><span class="s3">'distutils distribution has been initialized,'</span><span class="s1">\</span>
                      <span class="s3">' it may be too late to add a subpackage '</span><span class="s1">+ subpackage_name)</span>

    <span class="s0">def </span><span class="s1">add_data_dir(self</span><span class="s0">, </span><span class="s1">data_path):</span>
        <span class="s4">&quot;&quot;&quot;Recursively add files under data_path to data_files list. 
 
        Recursively add files under data_path to the list of data_files to be 
        installed (and distributed). The data_path can be either a relative 
        path-name, or an absolute path-name, or a 2-tuple where the first 
        argument shows where in the install directory the data directory 
        should be installed to. 
 
        Parameters 
        ---------- 
        data_path : seq or str 
            Argument can be either 
 
                * 2-sequence (&lt;datadir suffix&gt;, &lt;path to data directory&gt;) 
                * path to data directory where python datadir suffix defaults 
                  to package dir. 
 
        Notes 
        ----- 
        Rules for installation paths:: 
 
            foo/bar -&gt; (foo/bar, foo/bar) -&gt; parent/foo/bar 
            (gun, foo/bar) -&gt; parent/gun 
            foo/* -&gt; (foo/a, foo/a), (foo/b, foo/b) -&gt; parent/foo/a, parent/foo/b 
            (gun, foo/*) -&gt; (gun, foo/a), (gun, foo/b) -&gt; gun 
            (gun/*, foo/*) -&gt; parent/gun/a, parent/gun/b 
            /foo/bar -&gt; (bar, /foo/bar) -&gt; parent/bar 
            (gun, /foo/bar) -&gt; parent/gun 
            (fun/*/gun/*, sun/foo/bar) -&gt; parent/fun/foo/gun/bar 
 
        Examples 
        -------- 
        For example suppose the source directory contains fun/foo.dat and 
        fun/bar/car.dat: 
 
        &gt;&gt;&gt; self.add_data_dir('fun')                       #doctest: +SKIP 
        &gt;&gt;&gt; self.add_data_dir(('sun', 'fun'))              #doctest: +SKIP 
        &gt;&gt;&gt; self.add_data_dir(('gun', '/full/path/to/fun'))#doctest: +SKIP 
 
        Will install data-files to the locations:: 
 
            &lt;package install directory&gt;/ 
              fun/ 
                foo.dat 
                bar/ 
                  car.dat 
              sun/ 
                foo.dat 
                bar/ 
                  car.dat 
              gun/ 
                foo.dat 
                car.dat 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">is_sequence(data_path):</span>
            <span class="s1">d</span><span class="s0">, </span><span class="s1">data_path = data_path</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">d = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">is_sequence(data_path):</span>
            <span class="s1">[self.add_data_dir((d</span><span class="s0">, </span><span class="s1">p)) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">data_path]</span>
            <span class="s0">return</span>
        <span class="s0">if not </span><span class="s1">is_string(data_path):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;not a string: %r&quot; </span><span class="s1">% (data_path</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s0">if </span><span class="s1">d </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">os.path.isabs(data_path):</span>
                <span class="s0">return </span><span class="s1">self.add_data_dir((os.path.basename(data_path)</span><span class="s0">, </span><span class="s1">data_path))</span>
            <span class="s0">return </span><span class="s1">self.add_data_dir((data_path</span><span class="s0">, </span><span class="s1">data_path))</span>
        <span class="s1">paths = self.paths(data_path</span><span class="s0">, </span><span class="s1">include_non_existing=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">is_glob_pattern(data_path):</span>
            <span class="s0">if </span><span class="s1">is_glob_pattern(d):</span>
                <span class="s1">pattern_list = allpath(d).split(os.sep)</span>
                <span class="s1">pattern_list.reverse()</span>
                <span class="s2"># /a/*//b/ -&gt; /a/*/b</span>
                <span class="s1">rl = list(range(len(pattern_list)-</span><span class="s5">1</span><span class="s1">)); rl.reverse()</span>
                <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">rl:</span>
                    <span class="s0">if not </span><span class="s1">pattern_list[i]:</span>
                        <span class="s0">del </span><span class="s1">pattern_list[i]</span>
                <span class="s2">#</span>
                <span class="s0">for </span><span class="s1">path </span><span class="s0">in </span><span class="s1">paths:</span>
                    <span class="s0">if not </span><span class="s1">os.path.isdir(path):</span>
                        <span class="s1">print(</span><span class="s3">'Not a directory, skipping'</span><span class="s0">, </span><span class="s1">path)</span>
                        <span class="s0">continue</span>
                    <span class="s1">rpath = rel_path(path</span><span class="s0">, </span><span class="s1">self.local_path)</span>
                    <span class="s1">path_list = rpath.split(os.sep)</span>
                    <span class="s1">path_list.reverse()</span>
                    <span class="s1">target_list = []</span>
                    <span class="s1">i = </span><span class="s5">0</span>
                    <span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">pattern_list:</span>
                        <span class="s0">if </span><span class="s1">is_glob_pattern(s):</span>
                            <span class="s0">if </span><span class="s1">i&gt;=len(path_list):</span>
                                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">'cannot fill pattern %r with %r' </span><span class="s1">\</span>
                                      <span class="s1">% (d</span><span class="s0">, </span><span class="s1">path))</span>
                            <span class="s1">target_list.append(path_list[i])</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s0">assert </span><span class="s1">s==path_list[i]</span><span class="s0">, </span><span class="s1">repr((s</span><span class="s0">, </span><span class="s1">path_list[i]</span><span class="s0">, </span><span class="s1">data_path</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">rpath))</span>
                            <span class="s1">target_list.append(s)</span>
                        <span class="s1">i += </span><span class="s5">1</span>
                    <span class="s0">if </span><span class="s1">path_list[i:]:</span>
                        <span class="s1">self.warn(</span><span class="s3">'mismatch of pattern_list=%s and path_list=%s'</span><span class="s1">\</span>
                                  <span class="s1">% (pattern_list</span><span class="s0">, </span><span class="s1">path_list))</span>
                    <span class="s1">target_list.reverse()</span>
                    <span class="s1">self.add_data_dir((os.sep.join(target_list)</span><span class="s0">, </span><span class="s1">path))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">for </span><span class="s1">path </span><span class="s0">in </span><span class="s1">paths:</span>
                    <span class="s1">self.add_data_dir((d</span><span class="s0">, </span><span class="s1">path))</span>
            <span class="s0">return</span>
        <span class="s0">assert not </span><span class="s1">is_glob_pattern(d)</span><span class="s0">, </span><span class="s1">repr(d)</span>

        <span class="s1">dist = self.get_distribution()</span>
        <span class="s0">if </span><span class="s1">dist </span><span class="s0">is not None and </span><span class="s1">dist.data_files </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">data_files = dist.data_files</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">data_files = self.data_files</span>

        <span class="s0">for </span><span class="s1">path </span><span class="s0">in </span><span class="s1">paths:</span>
            <span class="s0">for </span><span class="s1">d1</span><span class="s0">, </span><span class="s1">f </span><span class="s0">in </span><span class="s1">list(general_source_directories_files(path)):</span>
                <span class="s1">target_path = os.path.join(self.path_in_package</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">d1)</span>
                <span class="s1">data_files.append((target_path</span><span class="s0">, </span><span class="s1">f))</span>

    <span class="s0">def </span><span class="s1">_optimize_data_files(self):</span>
        <span class="s1">data_dict = {}</span>
        <span class="s0">for </span><span class="s1">p</span><span class="s0">, </span><span class="s1">files </span><span class="s0">in </span><span class="s1">self.data_files:</span>
            <span class="s0">if </span><span class="s1">p </span><span class="s0">not in </span><span class="s1">data_dict:</span>
                <span class="s1">data_dict[p] = set()</span>
            <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">files:</span>
                <span class="s1">data_dict[p].add(f)</span>
        <span class="s1">self.data_files[:] = [(p</span><span class="s0">, </span><span class="s1">list(files)) </span><span class="s0">for </span><span class="s1">p</span><span class="s0">, </span><span class="s1">files </span><span class="s0">in </span><span class="s1">data_dict.items()]</span>

    <span class="s0">def </span><span class="s1">add_data_files(self</span><span class="s0">,</span><span class="s1">*files):</span>
        <span class="s4">&quot;&quot;&quot;Add data files to configuration data_files. 
 
        Parameters 
        ---------- 
        files : sequence 
            Argument(s) can be either 
 
                * 2-sequence (&lt;datadir prefix&gt;,&lt;path to data file(s)&gt;) 
                * paths to data files where python datadir prefix defaults 
                  to package dir. 
 
        Notes 
        ----- 
        The form of each element of the files sequence is very flexible 
        allowing many combinations of where to get the files from the package 
        and where they should ultimately be installed on the system. The most 
        basic usage is for an element of the files argument sequence to be a 
        simple filename. This will cause that file from the local path to be 
        installed to the installation path of the self.name package (package 
        path). The file argument can also be a relative path in which case the 
        entire relative path will be installed into the package directory. 
        Finally, the file can be an absolute path name in which case the file 
        will be found at the absolute path name but installed to the package 
        path. 
 
        This basic behavior can be augmented by passing a 2-tuple in as the 
        file argument. The first element of the tuple should specify the 
        relative path (under the package install directory) where the 
        remaining sequence of files should be installed to (it has nothing to 
        do with the file-names in the source distribution). The second element 
        of the tuple is the sequence of files that should be installed. The 
        files in this sequence can be filenames, relative paths, or absolute 
        paths. For absolute paths the file will be installed in the top-level 
        package installation directory (regardless of the first argument). 
        Filenames and relative path names will be installed in the package 
        install directory under the path name given as the first element of 
        the tuple. 
 
        Rules for installation paths: 
 
          #. file.txt -&gt; (., file.txt)-&gt; parent/file.txt 
          #. foo/file.txt -&gt; (foo, foo/file.txt) -&gt; parent/foo/file.txt 
          #. /foo/bar/file.txt -&gt; (., /foo/bar/file.txt) -&gt; parent/file.txt 
          #. ``*``.txt -&gt; parent/a.txt, parent/b.txt 
          #. foo/``*``.txt`` -&gt; parent/foo/a.txt, parent/foo/b.txt 
          #. ``*/*.txt`` -&gt; (``*``, ``*``/``*``.txt) -&gt; parent/c/a.txt, parent/d/b.txt 
          #. (sun, file.txt) -&gt; parent/sun/file.txt 
          #. (sun, bar/file.txt) -&gt; parent/sun/file.txt 
          #. (sun, /foo/bar/file.txt) -&gt; parent/sun/file.txt 
          #. (sun, ``*``.txt) -&gt; parent/sun/a.txt, parent/sun/b.txt 
          #. (sun, bar/``*``.txt) -&gt; parent/sun/a.txt, parent/sun/b.txt 
          #. (sun/``*``, ``*``/``*``.txt) -&gt; parent/sun/c/a.txt, parent/d/b.txt 
 
        An additional feature is that the path to a data-file can actually be 
        a function that takes no arguments and returns the actual path(s) to 
        the data-files. This is useful when the data files are generated while 
        building the package. 
 
        Examples 
        -------- 
        Add files to the list of data_files to be included with the package. 
 
            &gt;&gt;&gt; self.add_data_files('foo.dat', 
            ...     ('fun', ['gun.dat', 'nun/pun.dat', '/tmp/sun.dat']), 
            ...     'bar/cat.dat', 
            ...     '/full/path/to/can.dat')                   #doctest: +SKIP 
 
        will install these data files to:: 
 
            &lt;package install directory&gt;/ 
             foo.dat 
             fun/ 
               gun.dat 
               nun/ 
                 pun.dat 
             sun.dat 
             bar/ 
               car.dat 
             can.dat 
 
        where &lt;package install directory&gt; is the package (or sub-package) 
        directory such as '/usr/lib/python2.4/site-packages/mypackage' ('C: 
        \\Python2.4 \\Lib \\site-packages \\mypackage') or 
        '/usr/lib/python2.4/site- packages/mypackage/mysubpackage' ('C: 
        \\Python2.4 \\Lib \\site-packages \\mypackage \\mysubpackage'). 
        &quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">len(files)&gt;</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">files:</span>
                <span class="s1">self.add_data_files(f)</span>
            <span class="s0">return</span>
        <span class="s0">assert </span><span class="s1">len(files)==</span><span class="s5">1</span>
        <span class="s0">if </span><span class="s1">is_sequence(files[</span><span class="s5">0</span><span class="s1">]):</span>
            <span class="s1">d</span><span class="s0">, </span><span class="s1">files = files[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">d = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">is_string(files):</span>
            <span class="s1">filepat = files</span>
        <span class="s0">elif </span><span class="s1">is_sequence(files):</span>
            <span class="s0">if </span><span class="s1">len(files)==</span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">filepat = files[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">files:</span>
                    <span class="s1">self.add_data_files((d</span><span class="s0">, </span><span class="s1">f))</span>
                <span class="s0">return</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(repr(type(files)))</span>

        <span class="s0">if </span><span class="s1">d </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">hasattr(filepat</span><span class="s0">, </span><span class="s3">'__call__'</span><span class="s1">):</span>
                <span class="s1">d = </span><span class="s3">''</span>
            <span class="s0">elif </span><span class="s1">os.path.isabs(filepat):</span>
                <span class="s1">d = </span><span class="s3">''</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">d = os.path.dirname(filepat)</span>
            <span class="s1">self.add_data_files((d</span><span class="s0">, </span><span class="s1">files))</span>
            <span class="s0">return</span>

        <span class="s1">paths = self.paths(filepat</span><span class="s0">, </span><span class="s1">include_non_existing=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">is_glob_pattern(filepat):</span>
            <span class="s0">if </span><span class="s1">is_glob_pattern(d):</span>
                <span class="s1">pattern_list = d.split(os.sep)</span>
                <span class="s1">pattern_list.reverse()</span>
                <span class="s0">for </span><span class="s1">path </span><span class="s0">in </span><span class="s1">paths:</span>
                    <span class="s1">path_list = path.split(os.sep)</span>
                    <span class="s1">path_list.reverse()</span>
                    <span class="s1">path_list.pop() </span><span class="s2"># filename</span>
                    <span class="s1">target_list = []</span>
                    <span class="s1">i = </span><span class="s5">0</span>
                    <span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">pattern_list:</span>
                        <span class="s0">if </span><span class="s1">is_glob_pattern(s):</span>
                            <span class="s1">target_list.append(path_list[i])</span>
                            <span class="s1">i += </span><span class="s5">1</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">target_list.append(s)</span>
                    <span class="s1">target_list.reverse()</span>
                    <span class="s1">self.add_data_files((os.sep.join(target_list)</span><span class="s0">, </span><span class="s1">path))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.add_data_files((d</span><span class="s0">, </span><span class="s1">paths))</span>
            <span class="s0">return</span>
        <span class="s0">assert not </span><span class="s1">is_glob_pattern(d)</span><span class="s0">, </span><span class="s1">repr((d</span><span class="s0">, </span><span class="s1">filepat))</span>

        <span class="s1">dist = self.get_distribution()</span>
        <span class="s0">if </span><span class="s1">dist </span><span class="s0">is not None and </span><span class="s1">dist.data_files </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">data_files = dist.data_files</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">data_files = self.data_files</span>

        <span class="s1">data_files.append((os.path.join(self.path_in_package</span><span class="s0">, </span><span class="s1">d)</span><span class="s0">, </span><span class="s1">paths))</span>

    <span class="s2">### XXX Implement add_py_modules</span>

    <span class="s0">def </span><span class="s1">add_define_macros(self</span><span class="s0">, </span><span class="s1">macros):</span>
        <span class="s4">&quot;&quot;&quot;Add define macros to configuration 
 
        Add the given sequence of macro name and value duples to the beginning 
        of the define_macros list This list will be visible to all extension 
        modules of the current package. 
        &quot;&quot;&quot;</span>
        <span class="s1">dist = self.get_distribution()</span>
        <span class="s0">if </span><span class="s1">dist </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">hasattr(dist</span><span class="s0">, </span><span class="s3">'define_macros'</span><span class="s1">):</span>
                <span class="s1">dist.define_macros = []</span>
            <span class="s1">dist.define_macros.extend(macros)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.define_macros.extend(macros)</span>


    <span class="s0">def </span><span class="s1">add_include_dirs(self</span><span class="s0">,</span><span class="s1">*paths):</span>
        <span class="s4">&quot;&quot;&quot;Add paths to configuration include directories. 
 
        Add the given sequence of paths to the beginning of the include_dirs 
        list. This list will be visible to all extension modules of the 
        current package. 
        &quot;&quot;&quot;</span>
        <span class="s1">include_dirs = self.paths(paths)</span>
        <span class="s1">dist = self.get_distribution()</span>
        <span class="s0">if </span><span class="s1">dist </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">dist.include_dirs </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">dist.include_dirs = []</span>
            <span class="s1">dist.include_dirs.extend(include_dirs)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.include_dirs.extend(include_dirs)</span>

    <span class="s0">def </span><span class="s1">add_headers(self</span><span class="s0">,</span><span class="s1">*files):</span>
        <span class="s4">&quot;&quot;&quot;Add installable headers to configuration. 
 
        Add the given sequence of files to the beginning of the headers list. 
        By default, headers will be installed under &lt;python- 
        include&gt;/&lt;self.name.replace('.','/')&gt;/ directory. If an item of files 
        is a tuple, then its first argument specifies the actual installation 
        location relative to the &lt;python-include&gt; path. 
 
        Parameters 
        ---------- 
        files : str or seq 
            Argument(s) can be either: 
 
                * 2-sequence (&lt;includedir suffix&gt;,&lt;path to header file(s)&gt;) 
                * path(s) to header file(s) where python includedir suffix will 
                  default to package name. 
        &quot;&quot;&quot;</span>
        <span class="s1">headers = []</span>
        <span class="s0">for </span><span class="s1">path </span><span class="s0">in </span><span class="s1">files:</span>
            <span class="s0">if </span><span class="s1">is_string(path):</span>
                <span class="s1">[headers.append((self.name</span><span class="s0">, </span><span class="s1">p)) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">self.paths(path)]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if not </span><span class="s1">isinstance(path</span><span class="s0">, </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list)) </span><span class="s0">or </span><span class="s1">len(path) != </span><span class="s5">2</span><span class="s1">:</span>
                    <span class="s0">raise </span><span class="s1">TypeError(repr(path))</span>
                <span class="s1">[headers.append((path[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">p)) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">self.paths(path[</span><span class="s5">1</span><span class="s1">])]</span>
        <span class="s1">dist = self.get_distribution()</span>
        <span class="s0">if </span><span class="s1">dist </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">dist.headers </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">dist.headers = []</span>
            <span class="s1">dist.headers.extend(headers)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.headers.extend(headers)</span>

    <span class="s0">def </span><span class="s1">paths(self</span><span class="s0">,</span><span class="s1">*paths</span><span class="s0">,</span><span class="s1">**kws):</span>
        <span class="s4">&quot;&quot;&quot;Apply glob to paths and prepend local_path if needed. 
 
        Applies glob.glob(...) to each path in the sequence (if needed) and 
        pre-pends the local_path if needed. Because this is called on all 
        source lists, this allows wildcard characters to be specified in lists 
        of sources for extension modules and libraries and scripts and allows 
        path-names be relative to the source directory. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">include_non_existing = kws.get(</span><span class="s3">'include_non_existing'</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">gpaths(paths</span><span class="s0">,</span>
                      <span class="s1">local_path = self.local_path</span><span class="s0">,</span>
                      <span class="s1">include_non_existing=include_non_existing)</span>

    <span class="s0">def </span><span class="s1">_fix_paths_dict(self</span><span class="s0">, </span><span class="s1">kw):</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">kw.keys():</span>
            <span class="s1">v = kw[k]</span>
            <span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'sources'</span><span class="s0">, </span><span class="s3">'depends'</span><span class="s0">, </span><span class="s3">'include_dirs'</span><span class="s0">, </span><span class="s3">'library_dirs'</span><span class="s0">,</span>
                     <span class="s3">'module_dirs'</span><span class="s0">, </span><span class="s3">'extra_objects'</span><span class="s1">]:</span>
                <span class="s1">new_v = self.paths(v)</span>
                <span class="s1">kw[k] = new_v</span>

    <span class="s0">def </span><span class="s1">add_extension(self</span><span class="s0">,</span><span class="s1">name</span><span class="s0">,</span><span class="s1">sources</span><span class="s0">,</span><span class="s1">**kw):</span>
        <span class="s4">&quot;&quot;&quot;Add extension to configuration. 
 
        Create and add an Extension instance to the ext_modules list. This 
        method also takes the following optional keyword arguments that are 
        passed on to the Extension constructor. 
 
        Parameters 
        ---------- 
        name : str 
            name of the extension 
        sources : seq 
            list of the sources. The list of sources may contain functions 
            (called source generators) which must take an extension instance 
            and a build directory as inputs and return a source file or list of 
            source files or None. If None is returned then no sources are 
            generated. If the Extension instance has no sources after 
            processing all source generators, then no extension module is 
            built. 
        include_dirs : 
        define_macros : 
        undef_macros : 
        library_dirs : 
        libraries : 
        runtime_library_dirs : 
        extra_objects : 
        extra_compile_args : 
        extra_link_args : 
        extra_f77_compile_args : 
        extra_f90_compile_args : 
        export_symbols : 
        swig_opts : 
        depends : 
            The depends list contains paths to files or directories that the 
            sources of the extension module depend on. If any path in the 
            depends list is newer than the extension module, then the module 
            will be rebuilt. 
        language : 
        f2py_options : 
        module_dirs : 
        extra_info : dict or list 
            dict or list of dict of keywords to be appended to keywords. 
 
        Notes 
        ----- 
        The self.paths(...) method is applied to all lists that may contain 
        paths. 
        &quot;&quot;&quot;</span>
        <span class="s1">ext_args = copy.copy(kw)</span>
        <span class="s1">ext_args[</span><span class="s3">'name'</span><span class="s1">] = dot_join(self.name</span><span class="s0">, </span><span class="s1">name)</span>
        <span class="s1">ext_args[</span><span class="s3">'sources'</span><span class="s1">] = sources</span>

        <span class="s0">if </span><span class="s3">'extra_info' </span><span class="s0">in </span><span class="s1">ext_args:</span>
            <span class="s1">extra_info = ext_args[</span><span class="s3">'extra_info'</span><span class="s1">]</span>
            <span class="s0">del </span><span class="s1">ext_args[</span><span class="s3">'extra_info'</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">isinstance(extra_info</span><span class="s0">, </span><span class="s1">dict):</span>
                <span class="s1">extra_info = [extra_info]</span>
            <span class="s0">for </span><span class="s1">info </span><span class="s0">in </span><span class="s1">extra_info:</span>
                <span class="s0">assert </span><span class="s1">isinstance(info</span><span class="s0">, </span><span class="s1">dict)</span><span class="s0">, </span><span class="s1">repr(info)</span>
                <span class="s1">dict_append(ext_args</span><span class="s0">,</span><span class="s1">**info)</span>

        <span class="s1">self._fix_paths_dict(ext_args)</span>

        <span class="s2"># Resolve out-of-tree dependencies</span>
        <span class="s1">libraries = ext_args.get(</span><span class="s3">'libraries'</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">libnames = []</span>
        <span class="s1">ext_args[</span><span class="s3">'libraries'</span><span class="s1">] = []</span>
        <span class="s0">for </span><span class="s1">libname </span><span class="s0">in </span><span class="s1">libraries:</span>
            <span class="s0">if </span><span class="s1">isinstance(libname</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">self._fix_paths_dict(libname[</span><span class="s5">1</span><span class="s1">])</span>

            <span class="s2"># Handle library names of the form libname@relative/path/to/library</span>
            <span class="s0">if </span><span class="s3">'@' </span><span class="s0">in </span><span class="s1">libname:</span>
                <span class="s1">lname</span><span class="s0">, </span><span class="s1">lpath = libname.split(</span><span class="s3">'@'</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">lpath = os.path.abspath(njoin(self.local_path</span><span class="s0">, </span><span class="s1">lpath))</span>
                <span class="s0">if </span><span class="s1">os.path.isdir(lpath):</span>
                    <span class="s1">c = self.get_subpackage(</span><span class="s0">None, </span><span class="s1">lpath</span><span class="s0">,</span>
                                            <span class="s1">caller_level = </span><span class="s5">2</span><span class="s1">)</span>
                    <span class="s0">if </span><span class="s1">isinstance(c</span><span class="s0">, </span><span class="s1">Configuration):</span>
                        <span class="s1">c = c.todict()</span>
                    <span class="s0">for </span><span class="s1">l </span><span class="s0">in </span><span class="s1">[l[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">l </span><span class="s0">in </span><span class="s1">c.get(</span><span class="s3">'libraries'</span><span class="s0">, </span><span class="s1">[])]:</span>
                        <span class="s1">llname = l.split(</span><span class="s3">'__OF__'</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
                        <span class="s0">if </span><span class="s1">llname == lname:</span>
                            <span class="s1">c.pop(</span><span class="s3">'name'</span><span class="s0">, None</span><span class="s1">)</span>
                            <span class="s1">dict_append(ext_args</span><span class="s0">,</span><span class="s1">**c)</span>
                            <span class="s0">break</span>
                    <span class="s0">continue</span>
            <span class="s1">libnames.append(libname)</span>

        <span class="s1">ext_args[</span><span class="s3">'libraries'</span><span class="s1">] = libnames + ext_args[</span><span class="s3">'libraries'</span><span class="s1">]</span>
        <span class="s1">ext_args[</span><span class="s3">'define_macros'</span><span class="s1">] = \</span>
            <span class="s1">self.define_macros + ext_args.get(</span><span class="s3">'define_macros'</span><span class="s0">, </span><span class="s1">[])</span>

        <span class="s0">from </span><span class="s1">numpy.distutils.core </span><span class="s0">import </span><span class="s1">Extension</span>
        <span class="s1">ext = Extension(**ext_args)</span>
        <span class="s1">self.ext_modules.append(ext)</span>

        <span class="s1">dist = self.get_distribution()</span>
        <span class="s0">if </span><span class="s1">dist </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.warn(</span><span class="s3">'distutils distribution has been initialized,'</span><span class="s1">\</span>
                      <span class="s3">' it may be too late to add an extension '</span><span class="s1">+name)</span>
        <span class="s0">return </span><span class="s1">ext</span>

    <span class="s0">def </span><span class="s1">add_library(self</span><span class="s0">,</span><span class="s1">name</span><span class="s0">,</span><span class="s1">sources</span><span class="s0">,</span><span class="s1">**build_info):</span>
        <span class="s4">&quot;&quot;&quot; 
        Add library to configuration. 
 
        Parameters 
        ---------- 
        name : str 
            Name of the extension. 
        sources : sequence 
            List of the sources. The list of sources may contain functions 
            (called source generators) which must take an extension instance 
            and a build directory as inputs and return a source file or list of 
            source files or None. If None is returned then no sources are 
            generated. If the Extension instance has no sources after 
            processing all source generators, then no extension module is 
            built. 
        build_info : dict, optional 
            The following keys are allowed: 
 
                * depends 
                * macros 
                * include_dirs 
                * extra_compiler_args 
                * extra_f77_compile_args 
                * extra_f90_compile_args 
                * f2py_options 
                * language 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._add_library(name</span><span class="s0">, </span><span class="s1">sources</span><span class="s0">, None, </span><span class="s1">build_info)</span>

        <span class="s1">dist = self.get_distribution()</span>
        <span class="s0">if </span><span class="s1">dist </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.warn(</span><span class="s3">'distutils distribution has been initialized,'</span><span class="s1">\</span>
                      <span class="s3">' it may be too late to add a library '</span><span class="s1">+ name)</span>

    <span class="s0">def </span><span class="s1">_add_library(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">sources</span><span class="s0">, </span><span class="s1">install_dir</span><span class="s0">, </span><span class="s1">build_info):</span>
        <span class="s4">&quot;&quot;&quot;Common implementation for add_library and add_installed_library. Do 
        not use directly&quot;&quot;&quot;</span>
        <span class="s1">build_info = copy.copy(build_info)</span>
        <span class="s1">build_info[</span><span class="s3">'sources'</span><span class="s1">] = sources</span>

        <span class="s2"># Sometimes, depends is not set up to an empty list by default, and if</span>
        <span class="s2"># depends is not given to add_library, distutils barfs (#1134)</span>
        <span class="s0">if not </span><span class="s3">'depends' </span><span class="s0">in </span><span class="s1">build_info:</span>
            <span class="s1">build_info[</span><span class="s3">'depends'</span><span class="s1">] = []</span>

        <span class="s1">self._fix_paths_dict(build_info)</span>

        <span class="s2"># Add to libraries list so that it is build with build_clib</span>
        <span class="s1">self.libraries.append((name</span><span class="s0">, </span><span class="s1">build_info))</span>

    <span class="s0">def </span><span class="s1">add_installed_library(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">sources</span><span class="s0">, </span><span class="s1">install_dir</span><span class="s0">, </span><span class="s1">build_info=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Similar to add_library, but the specified library is installed. 
 
        Most C libraries used with `distutils` are only used to build python 
        extensions, but libraries built through this method will be installed 
        so that they can be reused by third-party packages. 
 
        Parameters 
        ---------- 
        name : str 
            Name of the installed library. 
        sources : sequence 
            List of the library's source files. See `add_library` for details. 
        install_dir : str 
            Path to install the library, relative to the current sub-package. 
        build_info : dict, optional 
            The following keys are allowed: 
 
                * depends 
                * macros 
                * include_dirs 
                * extra_compiler_args 
                * extra_f77_compile_args 
                * extra_f90_compile_args 
                * f2py_options 
                * language 
 
        Returns 
        ------- 
        None 
 
        See Also 
        -------- 
        add_library, add_npy_pkg_config, get_info 
 
        Notes 
        ----- 
        The best way to encode the options required to link against the specified 
        C libraries is to use a &quot;libname.ini&quot; file, and use `get_info` to 
        retrieve the required options (see `add_npy_pkg_config` for more 
        information). 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">build_info:</span>
            <span class="s1">build_info = {}</span>

        <span class="s1">install_dir = os.path.join(self.package_path</span><span class="s0">, </span><span class="s1">install_dir)</span>
        <span class="s1">self._add_library(name</span><span class="s0">, </span><span class="s1">sources</span><span class="s0">, </span><span class="s1">install_dir</span><span class="s0">, </span><span class="s1">build_info)</span>
        <span class="s1">self.installed_libraries.append(InstallableLib(name</span><span class="s0">, </span><span class="s1">build_info</span><span class="s0">, </span><span class="s1">install_dir))</span>

    <span class="s0">def </span><span class="s1">add_npy_pkg_config(self</span><span class="s0">, </span><span class="s1">template</span><span class="s0">, </span><span class="s1">install_dir</span><span class="s0">, </span><span class="s1">subst_dict=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Generate and install a npy-pkg config file from a template. 
 
        The config file generated from `template` is installed in the 
        given install directory, using `subst_dict` for variable substitution. 
 
        Parameters 
        ---------- 
        template : str 
            The path of the template, relatively to the current package path. 
        install_dir : str 
            Where to install the npy-pkg config file, relatively to the current 
            package path. 
        subst_dict : dict, optional 
            If given, any string of the form ``@key@`` will be replaced by 
            ``subst_dict[key]`` in the template file when installed. The install 
            prefix is always available through the variable ``@prefix@``, since the 
            install prefix is not easy to get reliably from setup.py. 
 
        See also 
        -------- 
        add_installed_library, get_info 
 
        Notes 
        ----- 
        This works for both standard installs and in-place builds, i.e. the 
        ``@prefix@`` refer to the source directory for in-place builds. 
 
        Examples 
        -------- 
        :: 
 
            config.add_npy_pkg_config('foo.ini.in', 'lib', {'foo': bar}) 
 
        Assuming the foo.ini.in file has the following content:: 
 
            [meta] 
            Name=@foo@ 
            Version=1.0 
            Description=dummy description 
 
            [default] 
            Cflags=-I@prefix@/include 
            Libs= 
 
        The generated file will have the following content:: 
 
            [meta] 
            Name=bar 
            Version=1.0 
            Description=dummy description 
 
            [default] 
            Cflags=-Iprefix_dir/include 
            Libs= 
 
        and will be installed as foo.ini in the 'lib' subpath. 
 
        When cross-compiling with numpy distutils, it might be necessary to 
        use modified npy-pkg-config files.  Using the default/generated files 
        will link with the host libraries (i.e. libnpymath.a).  For 
        cross-compilation you of-course need to link with target libraries, 
        while using the host Python installation. 
 
        You can copy out the numpy/core/lib/npy-pkg-config directory, add a 
        pkgdir value to the .ini files and set NPY_PKG_CONFIG_PATH environment 
        variable to point to the directory with the modified npy-pkg-config 
        files. 
 
        Example npymath.ini modified for cross-compilation:: 
 
            [meta] 
            Name=npymath 
            Description=Portable, core math library implementing C99 standard 
            Version=0.1 
 
            [variables] 
            pkgname=numpy.core 
            pkgdir=/build/arm-linux-gnueabi/sysroot/usr/lib/python3.7/site-packages/numpy/core 
            prefix=${pkgdir} 
            libdir=${prefix}/lib 
            includedir=${prefix}/include 
 
            [default] 
            Libs=-L${libdir} -lnpymath 
            Cflags=-I${includedir} 
            Requires=mlib 
 
            [msvc] 
            Libs=/LIBPATH:${libdir} npymath.lib 
            Cflags=/INCLUDE:${includedir} 
            Requires=mlib 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">subst_dict </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">subst_dict = {}</span>
        <span class="s1">template = os.path.join(self.package_path</span><span class="s0">, </span><span class="s1">template)</span>

        <span class="s0">if </span><span class="s1">self.name </span><span class="s0">in </span><span class="s1">self.installed_pkg_config:</span>
            <span class="s1">self.installed_pkg_config[self.name].append((template</span><span class="s0">, </span><span class="s1">install_dir</span><span class="s0">,</span>
                <span class="s1">subst_dict))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.installed_pkg_config[self.name] = [(template</span><span class="s0">, </span><span class="s1">install_dir</span><span class="s0">,</span>
                <span class="s1">subst_dict)]</span>


    <span class="s0">def </span><span class="s1">add_scripts(self</span><span class="s0">,</span><span class="s1">*files):</span>
        <span class="s4">&quot;&quot;&quot;Add scripts to configuration. 
 
        Add the sequence of files to the beginning of the scripts list. 
        Scripts will be installed under the &lt;prefix&gt;/bin/ directory. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">scripts = self.paths(files)</span>
        <span class="s1">dist = self.get_distribution()</span>
        <span class="s0">if </span><span class="s1">dist </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">dist.scripts </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">dist.scripts = []</span>
            <span class="s1">dist.scripts.extend(scripts)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.scripts.extend(scripts)</span>

    <span class="s0">def </span><span class="s1">dict_append(self</span><span class="s0">,</span><span class="s1">**dict):</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self.list_keys:</span>
            <span class="s1">a = getattr(self</span><span class="s0">, </span><span class="s1">key)</span>
            <span class="s1">a.extend(dict.get(key</span><span class="s0">, </span><span class="s1">[]))</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self.dict_keys:</span>
            <span class="s1">a = getattr(self</span><span class="s0">, </span><span class="s1">key)</span>
            <span class="s1">a.update(dict.get(key</span><span class="s0">, </span><span class="s1">{}))</span>
        <span class="s1">known_keys = self.list_keys + self.dict_keys + self.extra_keys</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">dict.keys():</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">known_keys:</span>
                <span class="s1">a = getattr(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, None</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">a </span><span class="s0">and </span><span class="s1">a==dict[key]: </span><span class="s0">continue</span>
                <span class="s1">self.warn(</span><span class="s3">'Inheriting attribute %r=%r from %r' </span><span class="s1">\</span>
                          <span class="s1">% (key</span><span class="s0">, </span><span class="s1">dict[key]</span><span class="s0">, </span><span class="s1">dict.get(</span><span class="s3">'name'</span><span class="s0">, </span><span class="s3">'?'</span><span class="s1">)))</span>
                <span class="s1">setattr(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">dict[key])</span>
                <span class="s1">self.extra_keys.append(key)</span>
            <span class="s0">elif </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self.extra_keys:</span>
                <span class="s1">self.info(</span><span class="s3">'Ignoring attempt to set %r (from %r to %r)' </span><span class="s1">\</span>
                          <span class="s1">% (key</span><span class="s0">, </span><span class="s1">getattr(self</span><span class="s0">, </span><span class="s1">key)</span><span class="s0">, </span><span class="s1">dict[key]))</span>
            <span class="s0">elif </span><span class="s1">key </span><span class="s0">in </span><span class="s1">known_keys:</span>
                <span class="s2"># key is already processed above</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Don't know about key=%r&quot; </span><span class="s1">% (key))</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">from </span><span class="s1">pprint </span><span class="s0">import </span><span class="s1">pformat</span>
        <span class="s1">known_keys = self.list_keys + self.dict_keys + self.extra_keys</span>
        <span class="s1">s = </span><span class="s3">'&lt;'</span><span class="s1">+</span><span class="s5">5</span><span class="s1">*</span><span class="s3">'-' </span><span class="s1">+ </span><span class="s3">'</span><span class="s0">\n</span><span class="s3">'</span>
        <span class="s1">s += </span><span class="s3">'Configuration of '</span><span class="s1">+self.name+</span><span class="s3">':</span><span class="s0">\n</span><span class="s3">'</span>
        <span class="s1">known_keys.sort()</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">known_keys:</span>
            <span class="s1">a = getattr(self</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">a:</span>
                <span class="s1">s += </span><span class="s3">'%s = %s</span><span class="s0">\n</span><span class="s3">' </span><span class="s1">% (k</span><span class="s0">, </span><span class="s1">pformat(a))</span>
        <span class="s1">s += </span><span class="s5">5</span><span class="s1">*</span><span class="s3">'-' </span><span class="s1">+ </span><span class="s3">'&gt;'</span>
        <span class="s0">return </span><span class="s1">s</span>

    <span class="s0">def </span><span class="s1">get_config_cmd(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Returns the numpy.distutils config command instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">cmd = get_cmd(</span><span class="s3">'config'</span><span class="s1">)</span>
        <span class="s1">cmd.ensure_finalized()</span>
        <span class="s1">cmd.dump_source = </span><span class="s5">0</span>
        <span class="s1">cmd.noisy = </span><span class="s5">0</span>
        <span class="s1">old_path = os.environ.get(</span><span class="s3">'PATH'</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">old_path:</span>
            <span class="s1">path = os.pathsep.join([</span><span class="s3">'.'</span><span class="s0">, </span><span class="s1">old_path])</span>
            <span class="s1">os.environ[</span><span class="s3">'PATH'</span><span class="s1">] = path</span>
        <span class="s0">return </span><span class="s1">cmd</span>

    <span class="s0">def </span><span class="s1">get_build_temp_dir(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return a path to a temporary directory where temporary files should be 
        placed. 
        &quot;&quot;&quot;</span>
        <span class="s1">cmd = get_cmd(</span><span class="s3">'build'</span><span class="s1">)</span>
        <span class="s1">cmd.ensure_finalized()</span>
        <span class="s0">return </span><span class="s1">cmd.build_temp</span>

    <span class="s0">def </span><span class="s1">have_f77c(self):</span>
        <span class="s4">&quot;&quot;&quot;Check for availability of Fortran 77 compiler. 
 
        Use it inside source generating function to ensure that 
        setup distribution instance has been initialized. 
 
        Notes 
        ----- 
        True if a Fortran 77 compiler is available (because a simple Fortran 77 
        code was able to be compiled successfully). 
        &quot;&quot;&quot;</span>
        <span class="s1">simple_fortran_subroutine = </span><span class="s3">''' 
        subroutine simple 
        end 
        '''</span>
        <span class="s1">config_cmd = self.get_config_cmd()</span>
        <span class="s1">flag = config_cmd.try_compile(simple_fortran_subroutine</span><span class="s0">, </span><span class="s1">lang=</span><span class="s3">'f77'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">flag</span>

    <span class="s0">def </span><span class="s1">have_f90c(self):</span>
        <span class="s4">&quot;&quot;&quot;Check for availability of Fortran 90 compiler. 
 
        Use it inside source generating function to ensure that 
        setup distribution instance has been initialized. 
 
        Notes 
        ----- 
        True if a Fortran 90 compiler is available (because a simple Fortran 
        90 code was able to be compiled successfully) 
        &quot;&quot;&quot;</span>
        <span class="s1">simple_fortran_subroutine = </span><span class="s3">''' 
        subroutine simple 
        end 
        '''</span>
        <span class="s1">config_cmd = self.get_config_cmd()</span>
        <span class="s1">flag = config_cmd.try_compile(simple_fortran_subroutine</span><span class="s0">, </span><span class="s1">lang=</span><span class="s3">'f90'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">flag</span>

    <span class="s0">def </span><span class="s1">append_to(self</span><span class="s0">, </span><span class="s1">extlib):</span>
        <span class="s4">&quot;&quot;&quot;Append libraries, include_dirs to extension or library item. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">is_sequence(extlib):</span>
            <span class="s1">lib_name</span><span class="s0">, </span><span class="s1">build_info = extlib</span>
            <span class="s1">dict_append(build_info</span><span class="s0">,</span>
                        <span class="s1">libraries=self.libraries</span><span class="s0">,</span>
                        <span class="s1">include_dirs=self.include_dirs)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">from </span><span class="s1">numpy.distutils.core </span><span class="s0">import </span><span class="s1">Extension</span>
            <span class="s0">assert </span><span class="s1">isinstance(extlib</span><span class="s0">, </span><span class="s1">Extension)</span><span class="s0">, </span><span class="s1">repr(extlib)</span>
            <span class="s1">extlib.libraries.extend(self.libraries)</span>
            <span class="s1">extlib.include_dirs.extend(self.include_dirs)</span>

    <span class="s0">def </span><span class="s1">_get_svn_revision(self</span><span class="s0">, </span><span class="s1">path):</span>
        <span class="s4">&quot;&quot;&quot;Return path's SVN revision number. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">output = subprocess.check_output([</span><span class="s3">'svnversion'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">cwd=path)</span>
        <span class="s0">except </span><span class="s1">(subprocess.CalledProcessError</span><span class="s0">, </span><span class="s1">OSError):</span>
            <span class="s0">pass</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">m = re.match(</span><span class="s6">rb'(?P&lt;revision&gt;\d+)'</span><span class="s0">, </span><span class="s1">output)</span>
            <span class="s0">if </span><span class="s1">m:</span>
                <span class="s0">return </span><span class="s1">int(m.group(</span><span class="s3">'revision'</span><span class="s1">))</span>

        <span class="s0">if </span><span class="s1">sys.platform==</span><span class="s3">'win32' </span><span class="s0">and </span><span class="s1">os.environ.get(</span><span class="s3">'SVN_ASP_DOT_NET_HACK'</span><span class="s0">, None</span><span class="s1">):</span>
            <span class="s1">entries = njoin(path</span><span class="s0">, </span><span class="s3">'_svn'</span><span class="s0">, </span><span class="s3">'entries'</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">entries = njoin(path</span><span class="s0">, </span><span class="s3">'.svn'</span><span class="s0">, </span><span class="s3">'entries'</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">os.path.isfile(entries):</span>
            <span class="s0">with </span><span class="s1">open(entries) </span><span class="s0">as </span><span class="s1">f:</span>
                <span class="s1">fstr = f.read()</span>
            <span class="s0">if </span><span class="s1">fstr[:</span><span class="s5">5</span><span class="s1">] == </span><span class="s3">'&lt;?xml'</span><span class="s1">:  </span><span class="s2"># pre 1.4</span>
                <span class="s1">m = re.search(</span><span class="s3">r'revision=&quot;(?P&lt;revision&gt;\d+)&quot;'</span><span class="s0">, </span><span class="s1">fstr)</span>
                <span class="s0">if </span><span class="s1">m:</span>
                    <span class="s0">return </span><span class="s1">int(m.group(</span><span class="s3">'revision'</span><span class="s1">))</span>
            <span class="s0">else</span><span class="s1">:  </span><span class="s2"># non-xml entries file --- check to be sure that</span>
                <span class="s1">m = re.search(</span><span class="s3">r'dir[\n\r]+(?P&lt;revision&gt;\d+)'</span><span class="s0">, </span><span class="s1">fstr)</span>
                <span class="s0">if </span><span class="s1">m:</span>
                    <span class="s0">return </span><span class="s1">int(m.group(</span><span class="s3">'revision'</span><span class="s1">))</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">_get_hg_revision(self</span><span class="s0">, </span><span class="s1">path):</span>
        <span class="s4">&quot;&quot;&quot;Return path's Mercurial revision number. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">output = subprocess.check_output(</span>
                <span class="s1">[</span><span class="s3">'hg'</span><span class="s0">, </span><span class="s3">'identify'</span><span class="s0">, </span><span class="s3">'--num'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">cwd=path)</span>
        <span class="s0">except </span><span class="s1">(subprocess.CalledProcessError</span><span class="s0">, </span><span class="s1">OSError):</span>
            <span class="s0">pass</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">m = re.match(</span><span class="s6">rb'(?P&lt;revision&gt;\d+)'</span><span class="s0">, </span><span class="s1">output)</span>
            <span class="s0">if </span><span class="s1">m:</span>
                <span class="s0">return </span><span class="s1">int(m.group(</span><span class="s3">'revision'</span><span class="s1">))</span>

        <span class="s1">branch_fn = njoin(path</span><span class="s0">, </span><span class="s3">'.hg'</span><span class="s0">, </span><span class="s3">'branch'</span><span class="s1">)</span>
        <span class="s1">branch_cache_fn = njoin(path</span><span class="s0">, </span><span class="s3">'.hg'</span><span class="s0">, </span><span class="s3">'branch.cache'</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">os.path.isfile(branch_fn):</span>
            <span class="s1">branch0 = </span><span class="s0">None</span>
            <span class="s0">with </span><span class="s1">open(branch_fn) </span><span class="s0">as </span><span class="s1">f:</span>
                <span class="s1">revision0 = f.read().strip()</span>

            <span class="s1">branch_map = {}</span>
            <span class="s0">with </span><span class="s1">open(branch_cache_fn</span><span class="s0">, </span><span class="s3">'r'</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
                <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">f:</span>
                    <span class="s1">branch1</span><span class="s0">, </span><span class="s1">revision1  = line.split()[:</span><span class="s5">2</span><span class="s1">]</span>
                    <span class="s0">if </span><span class="s1">revision1==revision0:</span>
                        <span class="s1">branch0 = branch1</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s1">revision1 = int(revision1)</span>
                    <span class="s0">except </span><span class="s1">ValueError:</span>
                        <span class="s0">continue</span>
                    <span class="s1">branch_map[branch1] = revision1</span>

            <span class="s0">return </span><span class="s1">branch_map.get(branch0)</span>

        <span class="s0">return None</span>


    <span class="s0">def </span><span class="s1">get_version(self</span><span class="s0">, </span><span class="s1">version_file=</span><span class="s0">None, </span><span class="s1">version_variable=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Try to get version string of a package. 
 
        Return a version string of the current package or None if the version 
        information could not be detected. 
 
        Notes 
        ----- 
        This method scans files named 
        __version__.py, &lt;packagename&gt;_version.py, version.py, and 
        __svn_version__.py for string variables version, __version__, and 
        &lt;packagename&gt;_version, until a version number is found. 
        &quot;&quot;&quot;</span>
        <span class="s1">version = getattr(self</span><span class="s0">, </span><span class="s3">'version'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">version </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">version</span>

        <span class="s2"># Get version from version file.</span>
        <span class="s0">if </span><span class="s1">version_file </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">files = [</span><span class="s3">'__version__.py'</span><span class="s0">,</span>
                     <span class="s1">self.name.split(</span><span class="s3">'.'</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]+</span><span class="s3">'_version.py'</span><span class="s0">,</span>
                     <span class="s3">'version.py'</span><span class="s0">,</span>
                     <span class="s3">'__svn_version__.py'</span><span class="s0">,</span>
                     <span class="s3">'__hg_version__.py'</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">files = [version_file]</span>
        <span class="s0">if </span><span class="s1">version_variable </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">version_vars = [</span><span class="s3">'version'</span><span class="s0">,</span>
                            <span class="s3">'__version__'</span><span class="s0">,</span>
                            <span class="s1">self.name.split(</span><span class="s3">'.'</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]+</span><span class="s3">'_version'</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">version_vars = [version_variable]</span>
        <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">files:</span>
            <span class="s1">fn = njoin(self.local_path</span><span class="s0">, </span><span class="s1">f)</span>
            <span class="s0">if </span><span class="s1">os.path.isfile(fn):</span>
                <span class="s1">info = (</span><span class="s3">'.py'</span><span class="s0">, </span><span class="s3">'U'</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">name = os.path.splitext(os.path.basename(fn))[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s1">n = dot_join(self.name</span><span class="s0">, </span><span class="s1">name)</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">version_module = exec_mod_from_location(</span>
                                        <span class="s3">'_'</span><span class="s1">.join(n.split(</span><span class="s3">'.'</span><span class="s1">))</span><span class="s0">, </span><span class="s1">fn)</span>
                <span class="s0">except </span><span class="s1">ImportError </span><span class="s0">as </span><span class="s1">e:</span>
                    <span class="s1">self.warn(str(e))</span>
                    <span class="s1">version_module = </span><span class="s0">None</span>
                <span class="s0">if </span><span class="s1">version_module </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s0">continue</span>

                <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">version_vars:</span>
                    <span class="s1">version = getattr(version_module</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, None</span><span class="s1">)</span>
                    <span class="s0">if </span><span class="s1">version </span><span class="s0">is not None</span><span class="s1">:</span>
                        <span class="s0">break</span>

                <span class="s2"># Try if versioneer module</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">version = version_module.get_versions()[</span><span class="s3">'version'</span><span class="s1">]</span>
                <span class="s0">except </span><span class="s1">AttributeError:</span>
                    <span class="s0">pass</span>

                <span class="s0">if </span><span class="s1">version </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s0">break</span>

        <span class="s0">if </span><span class="s1">version </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.version = version</span>
            <span class="s0">return </span><span class="s1">version</span>

        <span class="s2"># Get version as SVN or Mercurial revision number</span>
        <span class="s1">revision = self._get_svn_revision(self.local_path)</span>
        <span class="s0">if </span><span class="s1">revision </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">revision = self._get_hg_revision(self.local_path)</span>

        <span class="s0">if </span><span class="s1">revision </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">version = str(revision)</span>
            <span class="s1">self.version = version</span>

        <span class="s0">return </span><span class="s1">version</span>

    <span class="s0">def </span><span class="s1">make_svn_version_py(self</span><span class="s0">, </span><span class="s1">delete=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Appends a data function to the data_files list that will generate 
        __svn_version__.py file to the current package directory. 
 
        Generate package __svn_version__.py file from SVN revision number, 
        it will be removed after python exits but will be available 
        when sdist, etc commands are executed. 
 
        Notes 
        ----- 
        If __svn_version__.py existed before, nothing is done. 
 
        This is 
        intended for working with source directories that are in an SVN 
        repository. 
        &quot;&quot;&quot;</span>
        <span class="s1">target = njoin(self.local_path</span><span class="s0">, </span><span class="s3">'__svn_version__.py'</span><span class="s1">)</span>
        <span class="s1">revision = self._get_svn_revision(self.local_path)</span>
        <span class="s0">if </span><span class="s1">os.path.isfile(target) </span><span class="s0">or </span><span class="s1">revision </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">def </span><span class="s1">generate_svn_version_py():</span>
                <span class="s0">if not </span><span class="s1">os.path.isfile(target):</span>
                    <span class="s1">version = str(revision)</span>
                    <span class="s1">self.info(</span><span class="s3">'Creating %s (version=%r)' </span><span class="s1">% (target</span><span class="s0">, </span><span class="s1">version))</span>
                    <span class="s0">with </span><span class="s1">open(target</span><span class="s0">, </span><span class="s3">'w'</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
                        <span class="s1">f.write(</span><span class="s3">'version = %r</span><span class="s0">\n</span><span class="s3">' </span><span class="s1">% (version))</span>

                <span class="s0">def </span><span class="s1">rm_file(f=target</span><span class="s0">,</span><span class="s1">p=self.info):</span>
                    <span class="s0">if </span><span class="s1">delete:</span>
                        <span class="s0">try</span><span class="s1">: os.remove(f); p(</span><span class="s3">'removed '</span><span class="s1">+f)</span>
                        <span class="s0">except </span><span class="s1">OSError: </span><span class="s0">pass</span>
                        <span class="s0">try</span><span class="s1">: os.remove(f+</span><span class="s3">'c'</span><span class="s1">); p(</span><span class="s3">'removed '</span><span class="s1">+f+</span><span class="s3">'c'</span><span class="s1">)</span>
                        <span class="s0">except </span><span class="s1">OSError: </span><span class="s0">pass</span>

                <span class="s1">atexit.register(rm_file)</span>

                <span class="s0">return </span><span class="s1">target</span>

            <span class="s1">self.add_data_files((</span><span class="s3">''</span><span class="s0">, </span><span class="s1">generate_svn_version_py()))</span>

    <span class="s0">def </span><span class="s1">make_hg_version_py(self</span><span class="s0">, </span><span class="s1">delete=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Appends a data function to the data_files list that will generate 
        __hg_version__.py file to the current package directory. 
 
        Generate package __hg_version__.py file from Mercurial revision, 
        it will be removed after python exits but will be available 
        when sdist, etc commands are executed. 
 
        Notes 
        ----- 
        If __hg_version__.py existed before, nothing is done. 
 
        This is intended for working with source directories that are 
        in an Mercurial repository. 
        &quot;&quot;&quot;</span>
        <span class="s1">target = njoin(self.local_path</span><span class="s0">, </span><span class="s3">'__hg_version__.py'</span><span class="s1">)</span>
        <span class="s1">revision = self._get_hg_revision(self.local_path)</span>
        <span class="s0">if </span><span class="s1">os.path.isfile(target) </span><span class="s0">or </span><span class="s1">revision </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">def </span><span class="s1">generate_hg_version_py():</span>
                <span class="s0">if not </span><span class="s1">os.path.isfile(target):</span>
                    <span class="s1">version = str(revision)</span>
                    <span class="s1">self.info(</span><span class="s3">'Creating %s (version=%r)' </span><span class="s1">% (target</span><span class="s0">, </span><span class="s1">version))</span>
                    <span class="s0">with </span><span class="s1">open(target</span><span class="s0">, </span><span class="s3">'w'</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
                        <span class="s1">f.write(</span><span class="s3">'version = %r</span><span class="s0">\n</span><span class="s3">' </span><span class="s1">% (version))</span>

                <span class="s0">def </span><span class="s1">rm_file(f=target</span><span class="s0">,</span><span class="s1">p=self.info):</span>
                    <span class="s0">if </span><span class="s1">delete:</span>
                        <span class="s0">try</span><span class="s1">: os.remove(f); p(</span><span class="s3">'removed '</span><span class="s1">+f)</span>
                        <span class="s0">except </span><span class="s1">OSError: </span><span class="s0">pass</span>
                        <span class="s0">try</span><span class="s1">: os.remove(f+</span><span class="s3">'c'</span><span class="s1">); p(</span><span class="s3">'removed '</span><span class="s1">+f+</span><span class="s3">'c'</span><span class="s1">)</span>
                        <span class="s0">except </span><span class="s1">OSError: </span><span class="s0">pass</span>

                <span class="s1">atexit.register(rm_file)</span>

                <span class="s0">return </span><span class="s1">target</span>

            <span class="s1">self.add_data_files((</span><span class="s3">''</span><span class="s0">, </span><span class="s1">generate_hg_version_py()))</span>

    <span class="s0">def </span><span class="s1">make_config_py(self</span><span class="s0">,</span><span class="s1">name=</span><span class="s3">'__config__'</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Generate package __config__.py file containing system_info 
        information used during building the package. 
 
        This file is installed to the 
        package installation directory. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.py_modules.append((self.name</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">generate_config_py))</span>

    <span class="s0">def </span><span class="s1">get_info(self</span><span class="s0">,</span><span class="s1">*names):</span>
        <span class="s4">&quot;&quot;&quot;Get resources information. 
 
        Return information (from system_info.get_info) for all of the names in 
        the argument list in a single dictionary. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">.system_info </span><span class="s0">import </span><span class="s1">get_info</span><span class="s0">, </span><span class="s1">dict_append</span>
        <span class="s1">info_dict = {}</span>
        <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">names:</span>
            <span class="s1">dict_append(info_dict</span><span class="s0">,</span><span class="s1">**get_info(a))</span>
        <span class="s0">return </span><span class="s1">info_dict</span>


<span class="s0">def </span><span class="s1">get_cmd(cmdname</span><span class="s0">, </span><span class="s1">_cache={}):</span>
    <span class="s0">if </span><span class="s1">cmdname </span><span class="s0">not in </span><span class="s1">_cache:</span>
        <span class="s0">import </span><span class="s1">distutils.core</span>
        <span class="s1">dist = distutils.core._setup_distribution</span>
        <span class="s0">if </span><span class="s1">dist </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">from </span><span class="s1">distutils.errors </span><span class="s0">import </span><span class="s1">DistutilsInternalError</span>
            <span class="s0">raise </span><span class="s1">DistutilsInternalError(</span>
                  <span class="s3">'setup distribution instance not initialized'</span><span class="s1">)</span>
        <span class="s1">cmd = dist.get_command_obj(cmdname)</span>
        <span class="s1">_cache[cmdname] = cmd</span>
    <span class="s0">return </span><span class="s1">_cache[cmdname]</span>

<span class="s0">def </span><span class="s1">get_numpy_include_dirs():</span>
    <span class="s2"># numpy_include_dirs are set by numpy/core/setup.py, otherwise []</span>
    <span class="s1">include_dirs = Configuration.numpy_include_dirs[:]</span>
    <span class="s0">if not </span><span class="s1">include_dirs:</span>
        <span class="s0">import </span><span class="s1">numpy</span>
        <span class="s1">include_dirs = [ numpy.get_include() ]</span>
    <span class="s2"># else running numpy/core/setup.py</span>
    <span class="s0">return </span><span class="s1">include_dirs</span>

<span class="s0">def </span><span class="s1">get_npy_pkg_dir():</span>
    <span class="s4">&quot;&quot;&quot;Return the path where to find the npy-pkg-config directory. 
 
    If the NPY_PKG_CONFIG_PATH environment variable is set, the value of that 
    is returned.  Otherwise, a path inside the location of the numpy module is 
    returned. 
 
    The NPY_PKG_CONFIG_PATH can be useful when cross-compiling, maintaining 
    customized npy-pkg-config .ini files for the cross-compilation 
    environment, and using them when cross-compiling. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">d = os.environ.get(</span><span class="s3">'NPY_PKG_CONFIG_PATH'</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">d </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">d</span>
    <span class="s1">spec = importlib.util.find_spec(</span><span class="s3">'numpy'</span><span class="s1">)</span>
    <span class="s1">d = os.path.join(os.path.dirname(spec.origin)</span><span class="s0">,</span>
            <span class="s3">'core'</span><span class="s0">, </span><span class="s3">'lib'</span><span class="s0">, </span><span class="s3">'npy-pkg-config'</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">d</span>

<span class="s0">def </span><span class="s1">get_pkg_info(pkgname</span><span class="s0">, </span><span class="s1">dirs=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return library info for the given package. 
 
    Parameters 
    ---------- 
    pkgname : str 
        Name of the package (should match the name of the .ini file, without 
        the extension, e.g. foo for the file foo.ini). 
    dirs : sequence, optional 
        If given, should be a sequence of additional directories where to look 
        for npy-pkg-config files. Those directories are searched prior to the 
        NumPy directory. 
 
    Returns 
    ------- 
    pkginfo : class instance 
        The `LibraryInfo` instance containing the build information. 
 
    Raises 
    ------ 
    PkgNotFound 
        If the package is not found. 
 
    See Also 
    -------- 
    Configuration.add_npy_pkg_config, Configuration.add_installed_library, 
    get_info 
 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">numpy.distutils.npy_pkg_config </span><span class="s0">import </span><span class="s1">read_config</span>

    <span class="s0">if </span><span class="s1">dirs:</span>
        <span class="s1">dirs.append(get_npy_pkg_dir())</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">dirs = [get_npy_pkg_dir()]</span>
    <span class="s0">return </span><span class="s1">read_config(pkgname</span><span class="s0">, </span><span class="s1">dirs)</span>

<span class="s0">def </span><span class="s1">get_info(pkgname</span><span class="s0">, </span><span class="s1">dirs=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return an info dict for a given C library. 
 
    The info dict contains the necessary options to use the C library. 
 
    Parameters 
    ---------- 
    pkgname : str 
        Name of the package (should match the name of the .ini file, without 
        the extension, e.g. foo for the file foo.ini). 
    dirs : sequence, optional 
        If given, should be a sequence of additional directories where to look 
        for npy-pkg-config files. Those directories are searched prior to the 
        NumPy directory. 
 
    Returns 
    ------- 
    info : dict 
        The dictionary with build information. 
 
    Raises 
    ------ 
    PkgNotFound 
        If the package is not found. 
 
    See Also 
    -------- 
    Configuration.add_npy_pkg_config, Configuration.add_installed_library, 
    get_pkg_info 
 
    Examples 
    -------- 
    To get the necessary information for the npymath library from NumPy: 
 
    &gt;&gt;&gt; npymath_info = np.distutils.misc_util.get_info('npymath') 
    &gt;&gt;&gt; npymath_info                                    #doctest: +SKIP 
    {'define_macros': [], 'libraries': ['npymath'], 'library_dirs': 
    ['.../numpy/core/lib'], 'include_dirs': ['.../numpy/core/include']} 
 
    This info dict can then be used as input to a `Configuration` instance:: 
 
      config.add_extension('foo', sources=['foo.c'], extra_info=npymath_info) 
 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">numpy.distutils.npy_pkg_config </span><span class="s0">import </span><span class="s1">parse_flags</span>
    <span class="s1">pkg_info = get_pkg_info(pkgname</span><span class="s0">, </span><span class="s1">dirs)</span>

    <span class="s2"># Translate LibraryInfo instance into a build_info dict</span>
    <span class="s1">info = parse_flags(pkg_info.cflags())</span>
    <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">parse_flags(pkg_info.libs()).items():</span>
        <span class="s1">info[k].extend(v)</span>

    <span class="s2"># add_extension extra_info argument is ANAL</span>
    <span class="s1">info[</span><span class="s3">'define_macros'</span><span class="s1">] = info[</span><span class="s3">'macros'</span><span class="s1">]</span>
    <span class="s0">del </span><span class="s1">info[</span><span class="s3">'macros'</span><span class="s1">]</span>
    <span class="s0">del </span><span class="s1">info[</span><span class="s3">'ignored'</span><span class="s1">]</span>

    <span class="s0">return </span><span class="s1">info</span>

<span class="s0">def </span><span class="s1">is_bootstrapping():</span>
    <span class="s0">import </span><span class="s1">builtins</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">builtins.__NUMPY_SETUP__</span>
        <span class="s0">return True</span>
    <span class="s0">except </span><span class="s1">AttributeError:</span>
        <span class="s0">return False</span>


<span class="s2">#########################</span>

<span class="s0">def </span><span class="s1">default_config_dict(name = </span><span class="s0">None, </span><span class="s1">parent_name = </span><span class="s0">None, </span><span class="s1">local_path=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Return a configuration dictionary for usage in 
    configuration() function defined in file setup_&lt;name&gt;.py. 
    &quot;&quot;&quot;</span>
    <span class="s0">import </span><span class="s1">warnings</span>
    <span class="s1">warnings.warn(</span><span class="s3">'Use Configuration(%r,%r,top_path=%r) instead of '</span><span class="s1">\</span>
                  <span class="s3">'deprecated default_config_dict(%r,%r,%r)'</span>
                  <span class="s1">% (name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">local_path</span><span class="s0">,</span>
                     <span class="s1">name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">local_path</span><span class="s0">,</span>
                     <span class="s1">)</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">c = Configuration(name</span><span class="s0">, </span><span class="s1">parent_name</span><span class="s0">, </span><span class="s1">local_path)</span>
    <span class="s0">return </span><span class="s1">c.todict()</span>


<span class="s0">def </span><span class="s1">dict_append(d</span><span class="s0">, </span><span class="s1">**kws):</span>
    <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kws.items():</span>
        <span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">d:</span>
            <span class="s1">ov = d[k]</span>
            <span class="s0">if </span><span class="s1">isinstance(ov</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s1">d[k] = v</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">d[k].extend(v)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">d[k] = v</span>

<span class="s0">def </span><span class="s1">appendpath(prefix</span><span class="s0">, </span><span class="s1">path):</span>
    <span class="s0">if </span><span class="s1">os.path.sep != </span><span class="s3">'/'</span><span class="s1">:</span>
        <span class="s1">prefix = prefix.replace(</span><span class="s3">'/'</span><span class="s0">, </span><span class="s1">os.path.sep)</span>
        <span class="s1">path = path.replace(</span><span class="s3">'/'</span><span class="s0">, </span><span class="s1">os.path.sep)</span>
    <span class="s1">drive = </span><span class="s3">''</span>
    <span class="s0">if </span><span class="s1">os.path.isabs(path):</span>
        <span class="s1">drive = os.path.splitdrive(prefix)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">absprefix = os.path.splitdrive(os.path.abspath(prefix))[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">pathdrive</span><span class="s0">, </span><span class="s1">path = os.path.splitdrive(path)</span>
        <span class="s1">d = os.path.commonprefix([absprefix</span><span class="s0">, </span><span class="s1">path])</span>
        <span class="s0">if </span><span class="s1">os.path.join(absprefix[:len(d)]</span><span class="s0">, </span><span class="s1">absprefix[len(d):]) != absprefix \</span>
           <span class="s0">or </span><span class="s1">os.path.join(path[:len(d)]</span><span class="s0">, </span><span class="s1">path[len(d):]) != path:</span>
            <span class="s2"># Handle invalid paths</span>
            <span class="s1">d = os.path.dirname(d)</span>
        <span class="s1">subpath = path[len(d):]</span>
        <span class="s0">if </span><span class="s1">os.path.isabs(subpath):</span>
            <span class="s1">subpath = subpath[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">subpath = path</span>
    <span class="s0">return </span><span class="s1">os.path.normpath(njoin(drive + prefix</span><span class="s0">, </span><span class="s1">subpath))</span>

<span class="s0">def </span><span class="s1">generate_config_py(target):</span>
    <span class="s4">&quot;&quot;&quot;Generate config.py file containing system_info information 
    used during building the package. 
 
    Usage: 
        config['py_modules'].append((packagename, '__config__',generate_config_py)) 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">numpy.distutils.system_info </span><span class="s0">import </span><span class="s1">system_info</span>
    <span class="s0">from </span><span class="s1">distutils.dir_util </span><span class="s0">import </span><span class="s1">mkpath</span>
    <span class="s1">mkpath(os.path.dirname(target))</span>
    <span class="s0">with </span><span class="s1">open(target</span><span class="s0">, </span><span class="s3">'w'</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
        <span class="s1">f.write(</span><span class="s3">'# This file is generated by numpy</span><span class="s0">\'</span><span class="s3">s %s</span><span class="s0">\n</span><span class="s3">' </span><span class="s1">% (os.path.basename(sys.argv[</span><span class="s5">0</span><span class="s1">])))</span>
        <span class="s1">f.write(</span><span class="s3">'# It contains system_info results at the time of building this package.</span><span class="s0">\n</span><span class="s3">'</span><span class="s1">)</span>
        <span class="s1">f.write(</span><span class="s3">'__all__ = [&quot;get_info&quot;,&quot;show&quot;]</span><span class="s0">\n\n</span><span class="s3">'</span><span class="s1">)</span>

        <span class="s2"># For gfortran+msvc combination, extra shared libraries may exist</span>
        <span class="s1">f.write(textwrap.dedent(</span><span class="s3">&quot;&quot;&quot; 
            import os 
            import sys 
 
            extra_dll_dir = os.path.join(os.path.dirname(__file__), '.libs') 
 
            if sys.platform == 'win32' and os.path.isdir(extra_dll_dir): 
                if sys.version_info &gt;= (3, 8): 
                    os.add_dll_directory(extra_dll_dir) 
                else: 
                    os.environ.setdefault('PATH', '') 
                    os.environ['PATH'] += os.pathsep + extra_dll_dir 
 
            &quot;&quot;&quot;</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">i </span><span class="s0">in </span><span class="s1">system_info.saved_results.items():</span>
            <span class="s1">f.write(</span><span class="s3">'%s=%r</span><span class="s0">\n</span><span class="s3">' </span><span class="s1">% (k</span><span class="s0">, </span><span class="s1">i))</span>
        <span class="s1">f.write(textwrap.dedent(</span><span class="s3">r''' 
            def get_info(name): 
                g = globals() 
                return g.get(name, g.get(name + &quot;_info&quot;, {})) 
 
            def show(): 
                &quot;&quot;&quot; 
                Show libraries in the system on which NumPy was built. 
 
                Print information about various resources (libraries, library 
                directories, include directories, etc.) in the system on which 
                NumPy was built. 
 
                See Also 
                -------- 
                get_include : Returns the directory containing NumPy C 
                              header files. 
 
                Notes 
                ----- 
                1. Classes specifying the information to be printed are defined 
                   in the `numpy.distutils.system_info` module. 
 
                   Information may include: 
 
                   * ``language``: language used to write the libraries (mostly 
                     C or f77) 
                   * ``libraries``: names of libraries found in the system 
                   * ``library_dirs``: directories containing the libraries 
                   * ``include_dirs``: directories containing library header files 
                   * ``src_dirs``: directories containing library source files 
                   * ``define_macros``: preprocessor macros used by 
                     ``distutils.setup`` 
                   * ``baseline``: minimum CPU features required 
                   * ``found``: dispatched features supported in the system 
                   * ``not found``: dispatched features that are not supported 
                     in the system 
 
                2. NumPy BLAS/LAPACK Installation Notes 
 
                   Installing a numpy wheel (``pip install numpy`` or force it 
                   via ``pip install numpy --only-binary :numpy: numpy``) includes 
                   an OpenBLAS implementation of the BLAS and LAPACK linear algebra 
                   APIs. In this case, ``library_dirs`` reports the original build 
                   time configuration as compiled with gcc/gfortran; at run time 
                   the OpenBLAS library is in 
                   ``site-packages/numpy.libs/`` (linux), or 
                   ``site-packages/numpy/.dylibs/`` (macOS), or 
                   ``site-packages/numpy/.libs/`` (windows). 
 
                   Installing numpy from source 
                   (``pip install numpy --no-binary numpy``) searches for BLAS and 
                   LAPACK dynamic link libraries at build time as influenced by 
                   environment variables NPY_BLAS_LIBS, NPY_CBLAS_LIBS, and 
                   NPY_LAPACK_LIBS; or NPY_BLAS_ORDER and NPY_LAPACK_ORDER; 
                   or the optional file ``~/.numpy-site.cfg``. 
                   NumPy remembers those locations and expects to load the same 
                   libraries at run-time. 
                   In NumPy 1.21+ on macOS, 'accelerate' (Apple's Accelerate BLAS 
                   library) is in the default build-time search order after 
                   'openblas'. 
 
                Examples 
                -------- 
                &gt;&gt;&gt; import numpy as np 
                &gt;&gt;&gt; np.show_config() 
                blas_opt_info: 
                    language = c 
                    define_macros = [('HAVE_CBLAS', None)] 
                    libraries = ['openblas', 'openblas'] 
                    library_dirs = ['/usr/local/lib'] 
                &quot;&quot;&quot; 
                from numpy.core._multiarray_umath import ( 
                    __cpu_features__, __cpu_baseline__, __cpu_dispatch__ 
                ) 
                for name,info_dict in globals().items(): 
                    if name[0] == &quot;_&quot; or type(info_dict) is not type({}): continue 
                    print(name + &quot;:&quot;) 
                    if not info_dict: 
                        print(&quot;  NOT AVAILABLE&quot;) 
                    for k,v in info_dict.items(): 
                        v = str(v) 
                        if k == &quot;sources&quot; and len(v) &gt; 200: 
                            v = v[:60] + &quot; ...\n... &quot; + v[-60:] 
                        print(&quot;    %s = %s&quot; % (k,v)) 
 
                features_found, features_not_found = [], [] 
                for feature in __cpu_dispatch__: 
                    if __cpu_features__[feature]: 
                        features_found.append(feature) 
                    else: 
                        features_not_found.append(feature) 
 
                print(&quot;Supported SIMD extensions in this NumPy install:&quot;) 
                print(&quot;    baseline = %s&quot; % (','.join(__cpu_baseline__))) 
                print(&quot;    found = %s&quot; % (','.join(features_found))) 
                print(&quot;    not found = %s&quot; % (','.join(features_not_found))) 
 
                    '''</span><span class="s1">))</span>

    <span class="s0">return </span><span class="s1">target</span>

<span class="s0">def </span><span class="s1">msvc_version(compiler):</span>
    <span class="s4">&quot;&quot;&quot;Return version major and minor of compiler instance if it is 
    MSVC, raise an exception otherwise.&quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">compiler.compiler_type == </span><span class="s3">&quot;msvc&quot;</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Compiler instance is not msvc (%s)&quot;</span><span class="s1">\</span>
                         <span class="s1">% compiler.compiler_type)</span>
    <span class="s0">return </span><span class="s1">compiler._MSVCCompiler__version</span>

<span class="s0">def </span><span class="s1">get_build_architecture():</span>
    <span class="s2"># Importing distutils.msvccompiler triggers a warning on non-Windows</span>
    <span class="s2"># systems, so delay the import to here.</span>
    <span class="s0">from </span><span class="s1">distutils.msvccompiler </span><span class="s0">import </span><span class="s1">get_build_architecture</span>
    <span class="s0">return </span><span class="s1">get_build_architecture()</span>


<span class="s1">_cxx_ignore_flags = {</span><span class="s3">'-Werror=implicit-function-declaration'</span><span class="s0">, </span><span class="s3">'-std=c99'</span><span class="s1">}</span>


<span class="s0">def </span><span class="s1">sanitize_cxx_flags(cxxflags):</span>
    <span class="s4">''' 
    Some flags are valid for C but not C++. Prune them. 
    '''</span>
    <span class="s0">return </span><span class="s1">[flag </span><span class="s0">for </span><span class="s1">flag </span><span class="s0">in </span><span class="s1">cxxflags </span><span class="s0">if </span><span class="s1">flag </span><span class="s0">not in </span><span class="s1">_cxx_ignore_flags]</span>


<span class="s0">def </span><span class="s1">exec_mod_from_location(modname</span><span class="s0">, </span><span class="s1">modfile):</span>
    <span class="s4">''' 
    Use importlib machinery to import a module `modname` from the file 
    `modfile`. Depending on the `spec.loader`, the module may not be 
    registered in sys.modules. 
    '''</span>
    <span class="s1">spec = importlib.util.spec_from_file_location(modname</span><span class="s0">, </span><span class="s1">modfile)</span>
    <span class="s1">foo = importlib.util.module_from_spec(spec)</span>
    <span class="s1">spec.loader.exec_module(foo)</span>
    <span class="s0">return </span><span class="s1">foo</span>

</pre>
</body>
</html>