<html>
<head>
<title>dtypes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dtypes.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Define extension dtypes. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">re</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">MutableMapping</span><span class="s2">,</span>
    <span class="s1">cast</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytz</span>

<span class="s2">from </span><span class="s1">pandas._libs.interval </span><span class="s2">import </span><span class="s1">Interval</span>
<span class="s2">from </span><span class="s1">pandas._libs.properties </span><span class="s2">import </span><span class="s1">cache_readonly</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">BaseOffset</span><span class="s2">,</span>
    <span class="s1">NaT</span><span class="s2">,</span>
    <span class="s1">Period</span><span class="s2">,</span>
    <span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">dtypes</span><span class="s2">,</span>
    <span class="s1">timezones</span><span class="s2">,</span>
    <span class="s1">to_offset</span><span class="s2">,</span>
    <span class="s1">tz_compare</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas._typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Dtype</span><span class="s2">,</span>
    <span class="s1">DtypeObj</span><span class="s2">,</span>
    <span class="s1">Ordered</span><span class="s2">,</span>
    <span class="s1">npt</span><span class="s2">,</span>
    <span class="s1">type_t</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.base </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ExtensionDtype</span><span class="s2">,</span>
    <span class="s1">register_extension_dtype</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.generic </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ABCCategoricalIndex</span><span class="s2">,</span>
    <span class="s1">ABCIndex</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.inference </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">is_bool</span><span class="s2">,</span>
    <span class="s1">is_list_like</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">tzinfo</span>

    <span class="s2">import </span><span class="s1">pyarrow</span>

    <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">(</span>
        <span class="s1">Categorical</span><span class="s2">,</span>
        <span class="s1">Index</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">(</span>
        <span class="s1">DatetimeArray</span><span class="s2">,</span>
        <span class="s1">IntervalArray</span><span class="s2">,</span>
        <span class="s1">PandasArray</span><span class="s2">,</span>
        <span class="s1">PeriodArray</span><span class="s2">,</span>
    <span class="s1">)</span>

<span class="s1">str_type = str</span>


<span class="s2">class </span><span class="s1">PandasExtensionDtype(ExtensionDtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    A np.dtype duck-typed class, suitable for holding a custom dtype. 
 
    THIS IS NOT A REAL NUMPY DTYPE 
    &quot;&quot;&quot;</span>

    <span class="s1">type: Any</span>
    <span class="s1">kind: Any</span>
    <span class="s3"># The Any type annotations above are here only because mypy seems to have a</span>
    <span class="s3"># problem dealing with multiple inheritance from PandasExtensionDtype</span>
    <span class="s3"># and ExtensionDtype's @properties in the subclasses below. The kind and</span>
    <span class="s3"># type variables in those subclasses are explicitly typed below.</span>
    <span class="s1">subdtype = </span><span class="s2">None</span>
    <span class="s1">str: str_type</span>
    <span class="s1">num = </span><span class="s4">100</span>
    <span class="s1">shape: tuple[int</span><span class="s2">, </span><span class="s1">...] = ()</span>
    <span class="s1">itemsize = </span><span class="s4">8</span>
    <span class="s1">base: DtypeObj | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span>
    <span class="s1">isbuiltin = </span><span class="s4">0</span>
    <span class="s1">isnative = </span><span class="s4">0</span>
    <span class="s1">_cache_dtypes: dict[str_type</span><span class="s2">, </span><span class="s1">PandasExtensionDtype] = {}</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str_type:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a string representation for a particular object. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">str(self)</span>

    <span class="s2">def </span><span class="s1">__hash__(self) -&gt; int:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s5">&quot;sub-classes should implement an __hash__ method&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__getstate__(self) -&gt; dict[str_type</span><span class="s2">, </span><span class="s1">Any]:</span>
        <span class="s3"># pickle support; we don't want to pickle the cache</span>
        <span class="s2">return </span><span class="s1">{k: getattr(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self._metadata}</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">reset_cache(cls) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;clear the cache&quot;&quot;&quot;</span>
        <span class="s1">cls._cache_dtypes = {}</span>


<span class="s2">class </span><span class="s1">CategoricalDtypeType(type):</span>
    <span class="s0">&quot;&quot;&quot; 
    the type of CategoricalDtype, this metaclass determines subclass ability 
    &quot;&quot;&quot;</span>

    <span class="s2">pass</span>


<span class="s1">@register_extension_dtype</span>
<span class="s2">class </span><span class="s1">CategoricalDtype(PandasExtensionDtype</span><span class="s2">, </span><span class="s1">ExtensionDtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    Type for categorical data with the categories and orderedness. 
 
    Parameters 
    ---------- 
    categories : sequence, optional 
        Must be unique, and must not contain any nulls. 
        The categories are stored in an Index, 
        and if an index is provided the dtype of that index will be used. 
    ordered : bool or None, default False 
        Whether or not this categorical is treated as a ordered categorical. 
        None can be used to maintain the ordered value of existing categoricals when 
        used in operations that combine categoricals, e.g. astype, and will resolve to 
        False if there is no existing ordered to maintain. 
 
    Attributes 
    ---------- 
    categories 
    ordered 
 
    Methods 
    ------- 
    None 
 
    See Also 
    -------- 
    Categorical : Represent a categorical variable in classic R / S-plus fashion. 
 
    Notes 
    ----- 
    This class is useful for specifying the type of a ``Categorical`` 
    independent of the values. See :ref:`categorical.categoricaldtype` 
    for more. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; t = pd.CategoricalDtype(categories=['b', 'a'], ordered=True) 
    &gt;&gt;&gt; pd.Series(['a', 'b', 'a', 'c'], dtype=t) 
    0      a 
    1      b 
    2      a 
    3    NaN 
    dtype: category 
    Categories (2, object): ['b' &lt; 'a'] 
 
    An empty CategoricalDtype with a specific dtype can be created 
    by providing an empty index. As follows, 
 
    &gt;&gt;&gt; pd.CategoricalDtype(pd.DatetimeIndex([])).categories.dtype 
    dtype('&lt;M8[ns]') 
    &quot;&quot;&quot;</span>

    <span class="s3"># TODO: Document public vs. private API</span>
    <span class="s1">name = </span><span class="s5">&quot;category&quot;</span>
    <span class="s1">type: type[CategoricalDtypeType] = CategoricalDtypeType</span>
    <span class="s1">kind: str_type = </span><span class="s5">&quot;O&quot;</span>
    <span class="s1">str = </span><span class="s5">&quot;|O08&quot;</span>
    <span class="s1">base = np.dtype(</span><span class="s5">&quot;O&quot;</span><span class="s1">)</span>
    <span class="s1">_metadata = (</span><span class="s5">&quot;categories&quot;</span><span class="s2">, </span><span class="s5">&quot;ordered&quot;</span><span class="s1">)</span>
    <span class="s1">_cache_dtypes: dict[str_type</span><span class="s2">, </span><span class="s1">PandasExtensionDtype] = {}</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">categories=</span><span class="s2">None, </span><span class="s1">ordered: Ordered = </span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">self._finalize(categories</span><span class="s2">, </span><span class="s1">ordered</span><span class="s2">, </span><span class="s1">fastpath=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_from_fastpath(</span>
        <span class="s1">cls</span><span class="s2">, </span><span class="s1">categories=</span><span class="s2">None, </span><span class="s1">ordered: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span>
    <span class="s1">) -&gt; CategoricalDtype:</span>
        <span class="s1">self = cls.__new__(cls)</span>
        <span class="s1">self._finalize(categories</span><span class="s2">, </span><span class="s1">ordered</span><span class="s2">, </span><span class="s1">fastpath=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_from_categorical_dtype(</span>
        <span class="s1">cls</span><span class="s2">, </span><span class="s1">dtype: CategoricalDtype</span><span class="s2">, </span><span class="s1">categories=</span><span class="s2">None, </span><span class="s1">ordered: Ordered = </span><span class="s2">None</span>
    <span class="s1">) -&gt; CategoricalDtype:</span>
        <span class="s2">if </span><span class="s1">categories </span><span class="s2">is </span><span class="s1">ordered </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">dtype</span>
        <span class="s2">if </span><span class="s1">categories </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">categories = dtype.categories</span>
        <span class="s2">if </span><span class="s1">ordered </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ordered = dtype.ordered</span>
        <span class="s2">return </span><span class="s1">cls(categories</span><span class="s2">, </span><span class="s1">ordered)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_from_values_or_dtype(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">values=</span><span class="s2">None,</span>
        <span class="s1">categories=</span><span class="s2">None,</span>
        <span class="s1">ordered: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">dtype: Dtype | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">) -&gt; CategoricalDtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct dtype from the input parameters used in :class:`Categorical`. 
 
        This constructor method specifically does not do the factorization 
        step, if that is needed to find the categories. This constructor may 
        therefore return ``CategoricalDtype(categories=None, ordered=None)``, 
        which may not be useful. Additional steps may therefore have to be 
        taken to create the final dtype. 
 
        The return dtype is specified from the inputs in this prioritized 
        order: 
        1. if dtype is a CategoricalDtype, return dtype 
        2. if dtype is the string 'category', create a CategoricalDtype from 
           the supplied categories and ordered parameters, and return that. 
        3. if values is a categorical, use value.dtype, but override it with 
           categories and ordered if either/both of those are not None. 
        4. if dtype is None and values is not a categorical, construct the 
           dtype from categories and ordered, even if either of those is None. 
 
        Parameters 
        ---------- 
        values : list-like, optional 
            The list-like must be 1-dimensional. 
        categories : list-like, optional 
            Categories for the CategoricalDtype. 
        ordered : bool, optional 
            Designating if the categories are ordered. 
        dtype : CategoricalDtype or the string &quot;category&quot;, optional 
            If ``CategoricalDtype``, cannot be used together with 
            `categories` or `ordered`. 
 
        Returns 
        ------- 
        CategoricalDtype 
 
        Examples 
        -------- 
        &gt;&gt;&gt; pd.CategoricalDtype._from_values_or_dtype() 
        CategoricalDtype(categories=None, ordered=None) 
        &gt;&gt;&gt; pd.CategoricalDtype._from_values_or_dtype( 
        ...     categories=['a', 'b'], ordered=True 
        ... ) 
        CategoricalDtype(categories=['a', 'b'], ordered=True) 
        &gt;&gt;&gt; dtype1 = pd.CategoricalDtype(['a', 'b'], ordered=True) 
        &gt;&gt;&gt; dtype2 = pd.CategoricalDtype(['x', 'y'], ordered=False) 
        &gt;&gt;&gt; c = pd.Categorical([0, 1], dtype=dtype1, fastpath=True) 
        &gt;&gt;&gt; pd.CategoricalDtype._from_values_or_dtype( 
        ...     c, ['x', 'y'], ordered=True, dtype=dtype2 
        ... ) 
        Traceback (most recent call last): 
            ... 
        ValueError: Cannot specify `categories` or `ordered` together with 
        `dtype`. 
 
        The supplied dtype takes precedence over values' dtype: 
 
        &gt;&gt;&gt; pd.CategoricalDtype._from_values_or_dtype(c, dtype=dtype2) 
        CategoricalDtype(categories=['x', 'y'], ordered=False) 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s3"># The dtype argument takes precedence over values.dtype (if any)</span>
            <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s2">if </span><span class="s1">dtype == </span><span class="s5">&quot;category&quot;</span><span class="s1">:</span>
                    <span class="s1">dtype = CategoricalDtype(categories</span><span class="s2">, </span><span class="s1">ordered)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;Unknown dtype </span><span class="s2">{</span><span class="s1">repr(dtype)</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">categories </span><span class="s2">is not None or </span><span class="s1">ordered </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s5">&quot;Cannot specify `categories` or `ordered` together with `dtype`.&quot;</span>
                <span class="s1">)</span>
            <span class="s2">elif not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">CategoricalDtype):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;Cannot not construct CategoricalDtype from </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">cls.is_dtype(values):</span>
            <span class="s3"># If no &quot;dtype&quot; was passed, use the one from &quot;values&quot;, but honor</span>
            <span class="s3"># the &quot;ordered&quot; and &quot;categories&quot; arguments</span>
            <span class="s1">dtype = values.dtype._from_categorical_dtype(</span>
                <span class="s1">values.dtype</span><span class="s2">, </span><span class="s1">categories</span><span class="s2">, </span><span class="s1">ordered</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># If dtype=None and values is not categorical, create a new dtype.</span>
            <span class="s3"># Note: This could potentially have categories=None and</span>
            <span class="s3"># ordered=None.</span>
            <span class="s1">dtype = CategoricalDtype(categories</span><span class="s2">, </span><span class="s1">ordered)</span>

        <span class="s2">return </span><span class="s1">cast(CategoricalDtype</span><span class="s2">, </span><span class="s1">dtype)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_from_string(cls</span><span class="s2">, </span><span class="s1">string: str_type) -&gt; CategoricalDtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct a CategoricalDtype from a string. 
 
        Parameters 
        ---------- 
        string : str 
            Must be the string &quot;category&quot; in order to be successfully constructed. 
 
        Returns 
        ------- 
        CategoricalDtype 
            Instance of the dtype. 
 
        Raises 
        ------ 
        TypeError 
            If a CategoricalDtype cannot be constructed from the input. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(string</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">f&quot;'construct_from_string' expects a string, got </span><span class="s2">{</span><span class="s1">type(string)</span><span class="s2">}</span><span class="s5">&quot;</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">string != cls.name:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">f&quot;Cannot construct a 'CategoricalDtype' from '</span><span class="s2">{</span><span class="s1">string</span><span class="s2">}</span><span class="s5">'&quot;</span><span class="s1">)</span>

        <span class="s3"># need ordered=None to ensure that operations specifying dtype=&quot;category&quot; don't</span>
        <span class="s3"># override the ordered value for existing categoricals</span>
        <span class="s2">return </span><span class="s1">cls(ordered=</span><span class="s2">None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_finalize(self</span><span class="s2">, </span><span class="s1">categories</span><span class="s2">, </span><span class="s1">ordered: Ordered</span><span class="s2">, </span><span class="s1">fastpath: bool = </span><span class="s2">False</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>

        <span class="s2">if </span><span class="s1">ordered </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.validate_ordered(ordered)</span>

        <span class="s2">if </span><span class="s1">categories </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">categories = self.validate_categories(categories</span><span class="s2">, </span><span class="s1">fastpath=fastpath)</span>

        <span class="s1">self._categories = categories</span>
        <span class="s1">self._ordered = ordered</span>

    <span class="s2">def </span><span class="s1">__setstate__(self</span><span class="s2">, </span><span class="s1">state: MutableMapping[str_type</span><span class="s2">, </span><span class="s1">Any]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3"># for pickle compat. __get_state__ is defined in the</span>
        <span class="s3"># PandasExtensionDtype superclass and uses the public properties to</span>
        <span class="s3"># pickle -&gt; need to set the settable private ones here (see GH26067)</span>
        <span class="s1">self._categories = state.pop(</span><span class="s5">&quot;categories&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">self._ordered = state.pop(</span><span class="s5">&quot;ordered&quot;</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__hash__(self) -&gt; int:</span>
        <span class="s3"># _hash_categories returns a uint64, so use the negative</span>
        <span class="s3"># space for when we have unknown categories to avoid a conflict</span>
        <span class="s2">if </span><span class="s1">self.categories </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.ordered:</span>
                <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">-</span><span class="s4">2</span>
        <span class="s3"># We *do* want to include the real self.ordered here</span>
        <span class="s2">return </span><span class="s1">int(self._hash_categories)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other: Any) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Rules for CDT equality: 
        1) Any CDT is equal to the string 'category' 
        2) Any CDT is equal to itself 
        3) Any CDT is equal to a CDT with categories=None regardless of ordered 
        4) A CDT with ordered=True is only equal to another CDT with 
           ordered=True and identical categories in the same order 
        5) A CDT with ordered={False, None} is only equal to another CDT with 
           ordered={False, None} and identical categories, but same order is 
           not required. There is no distinction between False/None. 
        6) Any other comparison returns False 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">return </span><span class="s1">other == self.name</span>
        <span class="s2">elif </span><span class="s1">other </span><span class="s2">is </span><span class="s1">self:</span>
            <span class="s2">return True</span>
        <span class="s2">elif not </span><span class="s1">(hasattr(other</span><span class="s2">, </span><span class="s5">&quot;ordered&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">hasattr(other</span><span class="s2">, </span><span class="s5">&quot;categories&quot;</span><span class="s1">)):</span>
            <span class="s2">return False</span>
        <span class="s2">elif </span><span class="s1">self.categories </span><span class="s2">is None or </span><span class="s1">other.categories </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># For non-fully-initialized dtypes, these are only equal to</span>
            <span class="s3">#  - the string &quot;category&quot; (handled above)</span>
            <span class="s3">#  - other CategoricalDtype with categories=None</span>
            <span class="s2">return </span><span class="s1">self.categories </span><span class="s2">is </span><span class="s1">other.categories</span>
        <span class="s2">elif </span><span class="s1">self.ordered </span><span class="s2">or </span><span class="s1">other.ordered:</span>
            <span class="s3"># At least one has ordered=True; equal if both have ordered=True</span>
            <span class="s3"># and the same values for categories in the same order.</span>
            <span class="s2">return </span><span class="s1">(self.ordered == other.ordered) </span><span class="s2">and </span><span class="s1">self.categories.equals(</span>
                <span class="s1">other.categories</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># Neither has ordered=True; equal if both have the same categories,</span>
            <span class="s3"># but same order is not necessary.  There is no distinction between</span>
            <span class="s3"># ordered=False and ordered=None: CDT(., False) and CDT(., None)</span>
            <span class="s3"># will be equal if they have the same categories.</span>
            <span class="s1">left = self.categories</span>
            <span class="s1">right = other.categories</span>

            <span class="s3"># GH#36280 the ordering of checks here is for performance</span>
            <span class="s2">if not </span><span class="s1">left.dtype == right.dtype:</span>
                <span class="s2">return False</span>

            <span class="s2">if </span><span class="s1">len(left) != len(right):</span>
                <span class="s2">return False</span>

            <span class="s2">if </span><span class="s1">self.categories.equals(other.categories):</span>
                <span class="s3"># Check and see if they happen to be identical categories</span>
                <span class="s2">return True</span>

            <span class="s2">if </span><span class="s1">left.dtype != object:</span>
                <span class="s3"># Faster than calculating hash</span>
                <span class="s1">indexer = left.get_indexer(right)</span>
                <span class="s3"># Because left and right have the same length and are unique,</span>
                <span class="s3">#  `indexer` not having any -1s implies that there is a</span>
                <span class="s3">#  bijection between `left` and `right`.</span>
                <span class="s2">return </span><span class="s1">(indexer != -</span><span class="s4">1</span><span class="s1">).all()</span>

            <span class="s3"># With object-dtype we need a comparison that identifies</span>
            <span class="s3">#  e.g. int(2) as distinct from float(2)</span>
            <span class="s2">return </span><span class="s1">hash(self) == hash(other)</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str_type:</span>
        <span class="s2">if </span><span class="s1">self.categories </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">data = </span><span class="s5">&quot;None&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">data = self.categories._format_data(name=type(self).__name__)</span>
            <span class="s2">if </span><span class="s1">data </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s3"># self.categories is RangeIndex</span>
                <span class="s1">data = str(self.categories._range)</span>
            <span class="s1">data = data.rstrip(</span><span class="s5">&quot;, &quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s5">f&quot;CategoricalDtype(categories=</span><span class="s2">{</span><span class="s1">data</span><span class="s2">}</span><span class="s5">, ordered=</span><span class="s2">{</span><span class="s1">self.ordered</span><span class="s2">}</span><span class="s5">)&quot;</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">_hash_categories(self) -&gt; int:</span>
        <span class="s2">from </span><span class="s1">pandas.core.util.hashing </span><span class="s2">import </span><span class="s1">(</span>
            <span class="s1">combine_hash_arrays</span><span class="s2">,</span>
            <span class="s1">hash_array</span><span class="s2">,</span>
            <span class="s1">hash_tuples</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">categories = self.categories</span>
        <span class="s1">ordered = self.ordered</span>

        <span class="s2">if </span><span class="s1">len(categories) </span><span class="s2">and </span><span class="s1">isinstance(categories[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tuple):</span>
            <span class="s3"># assumes if any individual category is a tuple, then all our. ATM</span>
            <span class="s3"># I don't really want to support just some of the categories being</span>
            <span class="s3"># tuples.</span>
            <span class="s1">cat_list = list(categories)  </span><span class="s3"># breaks if a np.array of categories</span>
            <span class="s1">cat_array = hash_tuples(cat_list)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">categories.dtype == </span><span class="s5">&quot;O&quot; </span><span class="s2">and </span><span class="s1">len({type(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">categories}) != </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s3"># TODO: hash_array doesn't handle mixed types. It casts</span>
                <span class="s3"># everything to a str first, which means we treat</span>
                <span class="s3"># {'1', '2'} the same as {'1', 2}</span>
                <span class="s3"># find a better solution</span>
                <span class="s1">hashed = hash((tuple(categories)</span><span class="s2">, </span><span class="s1">ordered))</span>
                <span class="s2">return </span><span class="s1">hashed</span>

            <span class="s2">if </span><span class="s1">DatetimeTZDtype.is_dtype(categories.dtype):</span>
                <span class="s3"># Avoid future warning.</span>
                <span class="s1">categories = categories.view(</span><span class="s5">&quot;datetime64[ns]&quot;</span><span class="s1">)</span>

            <span class="s1">cat_array = hash_array(np.asarray(categories)</span><span class="s2">, </span><span class="s1">categorize=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">ordered:</span>
            <span class="s1">cat_array = np.vstack(</span>
                <span class="s1">[cat_array</span><span class="s2">, </span><span class="s1">np.arange(len(cat_array)</span><span class="s2">, </span><span class="s1">dtype=cat_array.dtype)]</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cat_array = np.array([cat_array])</span>
        <span class="s1">combined_hashed = combine_hash_arrays(iter(cat_array)</span><span class="s2">, </span><span class="s1">num_items=len(cat_array))</span>
        <span class="s2">return </span><span class="s1">np.bitwise_xor.reduce(combined_hashed)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_array_type(cls) -&gt; type_t[Categorical]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the array type associated with this dtype. 
 
        Returns 
        ------- 
        type 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">Categorical</span>

        <span class="s2">return </span><span class="s1">Categorical</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">validate_ordered(ordered: Ordered) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Validates that we have a valid ordered parameter. If 
        it is not a boolean, a TypeError will be raised. 
 
        Parameters 
        ---------- 
        ordered : object 
            The parameter to be verified. 
 
        Raises 
        ------ 
        TypeError 
            If 'ordered' is not a boolean. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">is_bool(ordered):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;'ordered' must either be 'True' or 'False'&quot;</span><span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">validate_categories(categories</span><span class="s2">, </span><span class="s1">fastpath: bool = </span><span class="s2">False</span><span class="s1">) -&gt; Index:</span>
        <span class="s0">&quot;&quot;&quot; 
        Validates that we have good categories 
 
        Parameters 
        ---------- 
        categories : array-like 
        fastpath : bool 
            Whether to skip nan and uniqueness checks 
 
        Returns 
        ------- 
        categories : Index 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas.core.indexes.base </span><span class="s2">import </span><span class="s1">Index</span>

        <span class="s2">if not </span><span class="s1">fastpath </span><span class="s2">and not </span><span class="s1">is_list_like(categories):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">f&quot;Parameter 'categories' must be list-like, was </span><span class="s2">{</span><span class="s1">repr(categories)</span><span class="s2">}</span><span class="s5">&quot;</span>
            <span class="s1">)</span>
        <span class="s2">elif not </span><span class="s1">isinstance(categories</span><span class="s2">, </span><span class="s1">ABCIndex):</span>
            <span class="s1">categories = Index._with_infer(categories</span><span class="s2">, </span><span class="s1">tupleize_cols=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">fastpath:</span>

            <span class="s2">if </span><span class="s1">categories.hasnans:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Categorical categories cannot be null&quot;</span><span class="s1">)</span>

            <span class="s2">if not </span><span class="s1">categories.is_unique:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Categorical categories must be unique&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(categories</span><span class="s2">, </span><span class="s1">ABCCategoricalIndex):</span>
            <span class="s1">categories = categories.categories</span>

        <span class="s2">return </span><span class="s1">categories</span>

    <span class="s2">def </span><span class="s1">update_dtype(self</span><span class="s2">, </span><span class="s1">dtype: str_type | CategoricalDtype) -&gt; CategoricalDtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a CategoricalDtype with categories and ordered taken from dtype 
        if specified, otherwise falling back to self if unspecified 
 
        Parameters 
        ---------- 
        dtype : CategoricalDtype 
 
        Returns 
        ------- 
        new_dtype : CategoricalDtype 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">dtype == </span><span class="s5">&quot;category&quot;</span><span class="s1">:</span>
            <span class="s3"># dtype='category' should not change anything</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s2">elif not </span><span class="s1">self.is_dtype(dtype):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s5">f&quot;a CategoricalDtype must be passed to perform an update, &quot;</span>
                <span class="s5">f&quot;got </span><span class="s2">{</span><span class="s1">repr(dtype)</span><span class="s2">}</span><span class="s5">&quot;</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># from here on, dtype is a CategoricalDtype</span>
            <span class="s1">dtype = cast(CategoricalDtype</span><span class="s2">, </span><span class="s1">dtype)</span>

        <span class="s3"># update categories/ordered unless they've been explicitly passed as None</span>
        <span class="s1">new_categories = (</span>
            <span class="s1">dtype.categories </span><span class="s2">if </span><span class="s1">dtype.categories </span><span class="s2">is not None else </span><span class="s1">self.categories</span>
        <span class="s1">)</span>
        <span class="s1">new_ordered = dtype.ordered </span><span class="s2">if </span><span class="s1">dtype.ordered </span><span class="s2">is not None else </span><span class="s1">self.ordered</span>

        <span class="s2">return </span><span class="s1">CategoricalDtype(new_categories</span><span class="s2">, </span><span class="s1">new_ordered)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">categories(self) -&gt; Index:</span>
        <span class="s0">&quot;&quot;&quot; 
        An ``Index`` containing the unique categories allowed. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._categories</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ordered(self) -&gt; Ordered:</span>
        <span class="s0">&quot;&quot;&quot; 
        Whether the categories have an ordered relationship. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._ordered</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_is_boolean(self) -&gt; bool:</span>
        <span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">is_bool_dtype</span>

        <span class="s2">return </span><span class="s1">is_bool_dtype(self.categories)</span>

    <span class="s2">def </span><span class="s1">_get_common_dtype(self</span><span class="s2">, </span><span class="s1">dtypes: list[DtypeObj]) -&gt; DtypeObj | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">pandas.core.arrays.sparse </span><span class="s2">import </span><span class="s1">SparseDtype</span>

        <span class="s3"># check if we have all categorical dtype with identical categories</span>
        <span class="s2">if </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">CategoricalDtype) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dtypes):</span>
            <span class="s1">first = dtypes[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">all(first == other </span><span class="s2">for </span><span class="s1">other </span><span class="s2">in </span><span class="s1">dtypes[</span><span class="s4">1</span><span class="s1">:]):</span>
                <span class="s2">return </span><span class="s1">first</span>

        <span class="s3"># special case non-initialized categorical</span>
        <span class="s3"># TODO we should figure out the expected return value in general</span>
        <span class="s1">non_init_cats = [</span>
            <span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">CategoricalDtype) </span><span class="s2">and </span><span class="s1">x.categories </span><span class="s2">is None for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dtypes</span>
        <span class="s1">]</span>
        <span class="s2">if </span><span class="s1">all(non_init_cats):</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s2">elif </span><span class="s1">any(non_init_cats):</span>
            <span class="s2">return None</span>

        <span class="s3"># categorical is aware of Sparse -&gt; extract sparse subdtypes</span>
        <span class="s1">dtypes = [x.subtype </span><span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">SparseDtype) </span><span class="s2">else </span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dtypes]</span>
        <span class="s3"># extract the categories' dtype</span>
        <span class="s1">non_cat_dtypes = [</span>
            <span class="s1">x.categories.dtype </span><span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">CategoricalDtype) </span><span class="s2">else </span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dtypes</span>
        <span class="s1">]</span>
        <span class="s3"># TODO should categorical always give an answer?</span>
        <span class="s2">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s2">import </span><span class="s1">find_common_type</span>

        <span class="s2">return </span><span class="s1">find_common_type(non_cat_dtypes)</span>


<span class="s1">@register_extension_dtype</span>
<span class="s2">class </span><span class="s1">DatetimeTZDtype(PandasExtensionDtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    An ExtensionDtype for timezone-aware datetime data. 
 
    **This is not an actual numpy dtype**, but a duck type. 
 
    Parameters 
    ---------- 
    unit : str, default &quot;ns&quot; 
        The precision of the datetime data. Currently limited 
        to ``&quot;ns&quot;``. 
    tz : str, int, or datetime.tzinfo 
        The timezone. 
 
    Attributes 
    ---------- 
    unit 
    tz 
 
    Methods 
    ------- 
    None 
 
    Raises 
    ------ 
    pytz.UnknownTimeZoneError 
        When the requested timezone cannot be found. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; pd.DatetimeTZDtype(tz='UTC') 
    datetime64[ns, UTC] 
 
    &gt;&gt;&gt; pd.DatetimeTZDtype(tz='dateutil/US/Central') 
    datetime64[ns, tzfile('/usr/share/zoneinfo/US/Central')] 
    &quot;&quot;&quot;</span>

    <span class="s1">type: type[Timestamp] = Timestamp</span>
    <span class="s1">kind: str_type = </span><span class="s5">&quot;M&quot;</span>
    <span class="s1">str = </span><span class="s5">&quot;|M8[ns]&quot;</span>
    <span class="s1">num = </span><span class="s4">101</span>
    <span class="s1">base = np.dtype(</span><span class="s5">&quot;M8[ns]&quot;</span><span class="s1">)</span>
    <span class="s1">na_value = NaT</span>
    <span class="s1">_metadata = (</span><span class="s5">&quot;unit&quot;</span><span class="s2">, </span><span class="s5">&quot;tz&quot;</span><span class="s1">)</span>
    <span class="s1">_match = re.compile(</span><span class="s5">r&quot;(datetime64|M8)\[(?P&lt;unit&gt;.+), (?P&lt;tz&gt;.+)\]&quot;</span><span class="s1">)</span>
    <span class="s1">_cache_dtypes: dict[str_type</span><span class="s2">, </span><span class="s1">PandasExtensionDtype] = {}</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">unit: str_type | DatetimeTZDtype = </span><span class="s5">&quot;ns&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">isinstance(unit</span><span class="s2">, </span><span class="s1">DatetimeTZDtype):</span>
            <span class="s3"># error: &quot;str&quot; has no attribute &quot;tz&quot;</span>
            <span class="s1">unit</span><span class="s2">, </span><span class="s1">tz = unit.unit</span><span class="s2">, </span><span class="s1">unit.tz  </span><span class="s3"># type: ignore[attr-defined]</span>

        <span class="s2">if </span><span class="s1">unit != </span><span class="s5">&quot;ns&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(unit</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">tz </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s3"># maybe a string like datetime64[ns, tz], which we support for</span>
                <span class="s3"># now.</span>
                <span class="s1">result = type(self).construct_from_string(unit)</span>
                <span class="s1">unit = result.unit</span>
                <span class="s1">tz = result.tz</span>
                <span class="s1">msg = (</span>
                    <span class="s5">f&quot;Passing a dtype alias like 'datetime64[ns, </span><span class="s2">{</span><span class="s1">tz</span><span class="s2">}</span><span class="s5">]' &quot;</span>
                    <span class="s5">&quot;to DatetimeTZDtype is no longer supported. Use &quot;</span>
                    <span class="s5">&quot;'DatetimeTZDtype.construct_from_string()' instead.&quot;</span>
                <span class="s1">)</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;DatetimeTZDtype only supports ns units&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">tz:</span>
            <span class="s1">tz = timezones.maybe_get_tz(tz)</span>
            <span class="s1">tz = timezones.tz_standardize(tz)</span>
        <span class="s2">elif </span><span class="s1">tz </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">pytz.UnknownTimeZoneError(tz)</span>
        <span class="s2">if </span><span class="s1">tz </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;A 'tz' is required.&quot;</span><span class="s1">)</span>

        <span class="s1">self._unit = unit</span>
        <span class="s1">self._tz = tz</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">unit(self) -&gt; str_type:</span>
        <span class="s0">&quot;&quot;&quot; 
        The precision of the datetime data. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._unit</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">tz(self) -&gt; tzinfo:</span>
        <span class="s0">&quot;&quot;&quot; 
        The timezone. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._tz</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_array_type(cls) -&gt; type_t[DatetimeArray]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the array type associated with this dtype. 
 
        Returns 
        ------- 
        type 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">DatetimeArray</span>

        <span class="s2">return </span><span class="s1">DatetimeArray</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_from_string(cls</span><span class="s2">, </span><span class="s1">string: str_type) -&gt; DatetimeTZDtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct a DatetimeTZDtype from a string. 
 
        Parameters 
        ---------- 
        string : str 
            The string alias for this DatetimeTZDtype. 
            Should be formatted like ``datetime64[ns, &lt;tz&gt;]``, 
            where ``&lt;tz&gt;`` is the timezone name. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; DatetimeTZDtype.construct_from_string('datetime64[ns, UTC]') 
        datetime64[ns, UTC] 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(string</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">f&quot;'construct_from_string' expects a string, got </span><span class="s2">{</span><span class="s1">type(string)</span><span class="s2">}</span><span class="s5">&quot;</span>
            <span class="s1">)</span>

        <span class="s1">msg = </span><span class="s5">f&quot;Cannot construct a 'DatetimeTZDtype' from '</span><span class="s2">{</span><span class="s1">string</span><span class="s2">}</span><span class="s5">'&quot;</span>
        <span class="s1">match = cls._match.match(string)</span>
        <span class="s2">if </span><span class="s1">match:</span>
            <span class="s1">d = match.groupdict()</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">cls(unit=d[</span><span class="s5">&quot;unit&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tz=d[</span><span class="s5">&quot;tz&quot;</span><span class="s1">])</span>
            <span class="s2">except </span><span class="s1">(KeyError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">ValueError) </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s3"># KeyError if maybe_get_tz tries and fails to get a</span>
                <span class="s3">#  pytz timezone (actually pytz.UnknownTimeZoneError).</span>
                <span class="s3"># TypeError if we pass a nonsense tz;</span>
                <span class="s3"># ValueError if we pass a unit other than &quot;ns&quot;</span>
                <span class="s2">raise </span><span class="s1">TypeError(msg) </span><span class="s2">from </span><span class="s1">err</span>
        <span class="s2">raise </span><span class="s1">TypeError(msg)</span>

    <span class="s2">def </span><span class="s1">__str__(self) -&gt; str_type:</span>
        <span class="s2">return </span><span class="s5">f&quot;datetime64[</span><span class="s2">{</span><span class="s1">self.unit</span><span class="s2">}</span><span class="s5">, </span><span class="s2">{</span><span class="s1">self.tz</span><span class="s2">}</span><span class="s5">]&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">name(self) -&gt; str_type:</span>
        <span class="s0">&quot;&quot;&quot;A string representation of the dtype.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">str(self)</span>

    <span class="s2">def </span><span class="s1">__hash__(self) -&gt; int:</span>
        <span class="s3"># make myself hashable</span>
        <span class="s3"># TODO: update this.</span>
        <span class="s2">return </span><span class="s1">hash(str(self))</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other: Any) -&gt; bool:</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">if </span><span class="s1">other.startswith(</span><span class="s5">&quot;M8[&quot;</span><span class="s1">):</span>
                <span class="s1">other = </span><span class="s5">&quot;datetime64[&quot; </span><span class="s1">+ other[</span><span class="s4">3</span><span class="s1">:]</span>
            <span class="s2">return </span><span class="s1">other == self.name</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">DatetimeTZDtype)</span>
            <span class="s2">and </span><span class="s1">self.unit == other.unit</span>
            <span class="s2">and </span><span class="s1">tz_compare(self.tz</span><span class="s2">, </span><span class="s1">other.tz)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__setstate__(self</span><span class="s2">, </span><span class="s1">state) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3"># for pickle compat. __get_state__ is defined in the</span>
        <span class="s3"># PandasExtensionDtype superclass and uses the public properties to</span>
        <span class="s3"># pickle -&gt; need to set the settable private ones here (see GH26067)</span>
        <span class="s1">self._tz = state[</span><span class="s5">&quot;tz&quot;</span><span class="s1">]</span>
        <span class="s1">self._unit = state[</span><span class="s5">&quot;unit&quot;</span><span class="s1">]</span>


<span class="s1">@register_extension_dtype</span>
<span class="s2">class </span><span class="s1">PeriodDtype(dtypes.PeriodDtypeBase</span><span class="s2">, </span><span class="s1">PandasExtensionDtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    An ExtensionDtype for Period data. 
 
    **This is not an actual numpy dtype**, but a duck type. 
 
    Parameters 
    ---------- 
    freq : str or DateOffset 
        The frequency of this PeriodDtype. 
 
    Attributes 
    ---------- 
    freq 
 
    Methods 
    ------- 
    None 
 
    Examples 
    -------- 
    &gt;&gt;&gt; pd.PeriodDtype(freq='D') 
    period[D] 
 
    &gt;&gt;&gt; pd.PeriodDtype(freq=pd.offsets.MonthEnd()) 
    period[M] 
    &quot;&quot;&quot;</span>

    <span class="s1">type: type[Period] = Period</span>
    <span class="s1">kind: str_type = </span><span class="s5">&quot;O&quot;</span>
    <span class="s1">str = </span><span class="s5">&quot;|O08&quot;</span>
    <span class="s1">base = np.dtype(</span><span class="s5">&quot;O&quot;</span><span class="s1">)</span>
    <span class="s1">num = </span><span class="s4">102</span>
    <span class="s1">_metadata = (</span><span class="s5">&quot;freq&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">_match = re.compile(</span><span class="s5">r&quot;(P|p)eriod\[(?P&lt;freq&gt;.+)\]&quot;</span><span class="s1">)</span>
    <span class="s1">_cache_dtypes: dict[str_type</span><span class="s2">, </span><span class="s1">PandasExtensionDtype] = {}</span>

    <span class="s2">def </span><span class="s1">__new__(cls</span><span class="s2">, </span><span class="s1">freq=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        freq : frequency 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(freq</span><span class="s2">, </span><span class="s1">PeriodDtype):</span>
            <span class="s2">return </span><span class="s1">freq</span>

        <span class="s2">elif </span><span class="s1">freq </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># empty constructor for pickle compat</span>
            <span class="s3"># -10_000 corresponds to PeriodDtypeCode.UNDEFINED</span>
            <span class="s1">u = dtypes.PeriodDtypeBase.__new__(cls</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10_000</span><span class="s1">)</span>
            <span class="s1">u._freq = </span><span class="s2">None</span>
            <span class="s2">return </span><span class="s1">u</span>

        <span class="s2">if not </span><span class="s1">isinstance(freq</span><span class="s2">, </span><span class="s1">BaseOffset):</span>
            <span class="s1">freq = cls._parse_dtype_strict(freq)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">cls._cache_dtypes[freq.freqstr]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s1">dtype_code = freq._period_dtype_code</span>
            <span class="s1">u = dtypes.PeriodDtypeBase.__new__(cls</span><span class="s2">, </span><span class="s1">dtype_code)</span>
            <span class="s1">u._freq = freq</span>
            <span class="s1">cls._cache_dtypes[freq.freqstr] = u</span>
            <span class="s2">return </span><span class="s1">u</span>

    <span class="s2">def </span><span class="s1">__reduce__(self):</span>
        <span class="s2">return </span><span class="s1">type(self)</span><span class="s2">, </span><span class="s1">(self.freq</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">freq(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The frequency object of this PeriodDtype. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._freq</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_parse_dtype_strict(cls</span><span class="s2">, </span><span class="s1">freq: str_type) -&gt; BaseOffset:</span>
        <span class="s2">if </span><span class="s1">isinstance(freq</span><span class="s2">, </span><span class="s1">str):  </span><span class="s3"># note: freq is already of type str!</span>
            <span class="s2">if </span><span class="s1">freq.startswith(</span><span class="s5">&quot;period[&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">freq.startswith(</span><span class="s5">&quot;Period[&quot;</span><span class="s1">):</span>
                <span class="s1">m = cls._match.search(freq)</span>
                <span class="s2">if </span><span class="s1">m </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">freq = m.group(</span><span class="s5">&quot;freq&quot;</span><span class="s1">)</span>

            <span class="s1">freq_offset = to_offset(freq)</span>
            <span class="s2">if </span><span class="s1">freq_offset </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">freq_offset</span>

        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;could not construct PeriodDtype&quot;</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_from_string(cls</span><span class="s2">, </span><span class="s1">string: str_type) -&gt; PeriodDtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        Strict construction from a string, raise a TypeError if not 
        possible 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">isinstance(string</span><span class="s2">, </span><span class="s1">str)</span>
            <span class="s2">and </span><span class="s1">(string.startswith(</span><span class="s5">&quot;period[&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">string.startswith(</span><span class="s5">&quot;Period[&quot;</span><span class="s1">))</span>
            <span class="s2">or </span><span class="s1">isinstance(string</span><span class="s2">, </span><span class="s1">BaseOffset)</span>
        <span class="s1">):</span>
            <span class="s3"># do not parse string like U as period[U]</span>
            <span class="s3"># avoid tuple to be regarded as freq</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">cls(freq=string)</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s2">pass</span>
        <span class="s2">if </span><span class="s1">isinstance(string</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">msg = </span><span class="s5">f&quot;Cannot construct a 'PeriodDtype' from '</span><span class="s2">{</span><span class="s1">string</span><span class="s2">}</span><span class="s5">'&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s5">f&quot;'construct_from_string' expects a string, got </span><span class="s2">{</span><span class="s1">type(string)</span><span class="s2">}</span><span class="s5">&quot;</span>
        <span class="s2">raise </span><span class="s1">TypeError(msg)</span>

    <span class="s2">def </span><span class="s1">__str__(self) -&gt; str_type:</span>
        <span class="s2">return </span><span class="s1">self.name</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">name(self) -&gt; str_type:</span>
        <span class="s2">return </span><span class="s5">f&quot;period[</span><span class="s2">{</span><span class="s1">self.freq.freqstr</span><span class="s2">}</span><span class="s5">]&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">na_value(self):</span>
        <span class="s2">return </span><span class="s1">NaT</span>

    <span class="s2">def </span><span class="s1">__hash__(self) -&gt; int:</span>
        <span class="s3"># make myself hashable</span>
        <span class="s2">return </span><span class="s1">hash(str(self))</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other: Any) -&gt; bool:</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">return </span><span class="s1">other </span><span class="s2">in </span><span class="s1">[self.name</span><span class="s2">, </span><span class="s1">self.name.title()]</span>

        <span class="s2">elif </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">PeriodDtype):</span>

            <span class="s3"># For freqs that can be held by a PeriodDtype, this check is</span>
            <span class="s3"># equivalent to (and much faster than) self.freq == other.freq</span>
            <span class="s1">sfreq = self.freq</span>
            <span class="s1">ofreq = other.freq</span>
            <span class="s2">return </span><span class="s1">(</span>
                <span class="s1">sfreq.n == ofreq.n</span>
                <span class="s2">and </span><span class="s1">sfreq._period_dtype_code == ofreq._period_dtype_code</span>
            <span class="s1">)</span>

        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other: Any) -&gt; bool:</span>
        <span class="s2">return not </span><span class="s1">self.__eq__(other)</span>

    <span class="s2">def </span><span class="s1">__setstate__(self</span><span class="s2">, </span><span class="s1">state):</span>
        <span class="s3"># for pickle compat. __getstate__ is defined in the</span>
        <span class="s3"># PandasExtensionDtype superclass and uses the public properties to</span>
        <span class="s3"># pickle -&gt; need to set the settable private ones here (see GH26067)</span>
        <span class="s1">self._freq = state[</span><span class="s5">&quot;freq&quot;</span><span class="s1">]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">is_dtype(cls</span><span class="s2">, </span><span class="s1">dtype: object) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a boolean if we if the passed type is an actual dtype that we 
        can match (via string or type) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s3"># PeriodDtype can be instantiated from freq string like &quot;U&quot;,</span>
            <span class="s3"># but doesn't regard freq str like &quot;U&quot; as dtype.</span>
            <span class="s2">if </span><span class="s1">dtype.startswith(</span><span class="s5">&quot;period[&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">dtype.startswith(</span><span class="s5">&quot;Period[&quot;</span><span class="s1">):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">cls._parse_dtype_strict(dtype) </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s2">return True</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">return False</span>
                <span class="s2">except </span><span class="s1">ValueError:</span>
                    <span class="s2">return False</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return False</span>
        <span class="s2">return </span><span class="s1">super().is_dtype(dtype)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_array_type(cls) -&gt; type_t[PeriodArray]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the array type associated with this dtype. 
 
        Returns 
        ------- 
        type 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">PeriodArray</span>

        <span class="s2">return </span><span class="s1">PeriodArray</span>

    <span class="s2">def </span><span class="s1">__from_arrow__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">array: pyarrow.Array | pyarrow.ChunkedArray</span>
    <span class="s1">) -&gt; PeriodArray:</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct PeriodArray from pyarrow Array/ChunkedArray. 
        &quot;&quot;&quot;</span>
        <span class="s2">import </span><span class="s1">pyarrow</span>

        <span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">PeriodArray</span>
        <span class="s2">from </span><span class="s1">pandas.core.arrays._arrow_utils </span><span class="s2">import </span><span class="s1">pyarrow_array_to_numpy_and_mask</span>

        <span class="s2">if </span><span class="s1">isinstance(array</span><span class="s2">, </span><span class="s1">pyarrow.Array):</span>
            <span class="s1">chunks = [array]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">chunks = array.chunks</span>

        <span class="s1">results = []</span>
        <span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">chunks:</span>
            <span class="s1">data</span><span class="s2">, </span><span class="s1">mask = pyarrow_array_to_numpy_and_mask(arr</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;int64&quot;</span><span class="s1">)</span>
            <span class="s1">parr = PeriodArray(data.copy()</span><span class="s2">, </span><span class="s1">freq=self.freq</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">parr[~mask] = NaT</span>
            <span class="s1">results.append(parr)</span>

        <span class="s2">if not </span><span class="s1">results:</span>
            <span class="s2">return </span><span class="s1">PeriodArray(np.array([]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;int64&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">freq=self.freq</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">PeriodArray._concat_same_type(results)</span>


<span class="s1">@register_extension_dtype</span>
<span class="s2">class </span><span class="s1">IntervalDtype(PandasExtensionDtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    An ExtensionDtype for Interval data. 
 
    **This is not an actual numpy dtype**, but a duck type. 
 
    Parameters 
    ---------- 
    subtype : str, np.dtype 
        The dtype of the Interval bounds. 
 
    Attributes 
    ---------- 
    subtype 
 
    Methods 
    ------- 
    None 
 
    Examples 
    -------- 
    &gt;&gt;&gt; pd.IntervalDtype(subtype='int64', closed='both') 
    interval[int64, both] 
    &quot;&quot;&quot;</span>

    <span class="s1">name = </span><span class="s5">&quot;interval&quot;</span>
    <span class="s1">kind: str_type = </span><span class="s5">&quot;O&quot;</span>
    <span class="s1">str = </span><span class="s5">&quot;|O08&quot;</span>
    <span class="s1">base = np.dtype(</span><span class="s5">&quot;O&quot;</span><span class="s1">)</span>
    <span class="s1">num = </span><span class="s4">103</span>
    <span class="s1">_metadata = (</span>
        <span class="s5">&quot;subtype&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;closed&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">_match = re.compile(</span>
        <span class="s5">r&quot;(I|i)nterval\[(?P&lt;subtype&gt;[^,]+)(, (?P&lt;closed&gt;(right|left|both|neither)))?\]&quot;</span>
    <span class="s1">)</span>
    <span class="s1">_cache_dtypes: dict[str_type</span><span class="s2">, </span><span class="s1">PandasExtensionDtype] = {}</span>

    <span class="s2">def </span><span class="s1">__new__(cls</span><span class="s2">, </span><span class="s1">subtype=</span><span class="s2">None, </span><span class="s1">closed: str_type | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">(</span>
            <span class="s1">is_string_dtype</span><span class="s2">,</span>
            <span class="s1">pandas_dtype</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">closed </span><span class="s2">is not None and </span><span class="s1">closed </span><span class="s2">not in </span><span class="s1">{</span><span class="s5">&quot;right&quot;</span><span class="s2">, </span><span class="s5">&quot;left&quot;</span><span class="s2">, </span><span class="s5">&quot;both&quot;</span><span class="s2">, </span><span class="s5">&quot;neither&quot;</span><span class="s1">}:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;closed must be one of 'right', 'left', 'both', 'neither'&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(subtype</span><span class="s2">, </span><span class="s1">IntervalDtype):</span>
            <span class="s2">if </span><span class="s1">closed </span><span class="s2">is not None and </span><span class="s1">closed != subtype.closed:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s5">&quot;dtype.closed and 'closed' do not match. &quot;</span>
                    <span class="s5">&quot;Try IntervalDtype(dtype.subtype, closed) instead.&quot;</span>
                <span class="s1">)</span>
            <span class="s2">return </span><span class="s1">subtype</span>
        <span class="s2">elif </span><span class="s1">subtype </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># we are called as an empty constructor</span>
            <span class="s3"># generally for pickle compat</span>
            <span class="s1">u = object.__new__(cls)</span>
            <span class="s1">u._subtype = </span><span class="s2">None</span>
            <span class="s1">u._closed = closed</span>
            <span class="s2">return </span><span class="s1">u</span>
        <span class="s2">elif </span><span class="s1">isinstance(subtype</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">subtype.lower() == </span><span class="s5">&quot;interval&quot;</span><span class="s1">:</span>
            <span class="s1">subtype = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(subtype</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">m = cls._match.search(subtype)</span>
                <span class="s2">if </span><span class="s1">m </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">gd = m.groupdict()</span>
                    <span class="s1">subtype = gd[</span><span class="s5">&quot;subtype&quot;</span><span class="s1">]</span>
                    <span class="s2">if </span><span class="s1">gd.get(</span><span class="s5">&quot;closed&quot;</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s2">if </span><span class="s1">closed </span><span class="s2">is not None</span><span class="s1">:</span>
                            <span class="s2">if </span><span class="s1">closed != gd[</span><span class="s5">&quot;closed&quot;</span><span class="s1">]:</span>
                                <span class="s2">raise </span><span class="s1">ValueError(</span>
                                    <span class="s5">&quot;'closed' keyword does not match value &quot;</span>
                                    <span class="s5">&quot;specified in dtype string&quot;</span>
                                <span class="s1">)</span>
                        <span class="s1">closed = gd[</span><span class="s5">&quot;closed&quot;</span><span class="s1">]</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">subtype = pandas_dtype(subtype)</span>
            <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;could not construct IntervalDtype&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

        <span class="s2">if </span><span class="s1">CategoricalDtype.is_dtype(subtype) </span><span class="s2">or </span><span class="s1">is_string_dtype(subtype):</span>
            <span class="s3"># GH 19016</span>
            <span class="s1">msg = (</span>
                <span class="s5">&quot;category, object, and string subtypes are not supported &quot;</span>
                <span class="s5">&quot;for IntervalDtype&quot;</span>
            <span class="s1">)</span>
            <span class="s2">raise </span><span class="s1">TypeError(msg)</span>

        <span class="s1">key = str(subtype) + str(closed)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">cls._cache_dtypes[key]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s1">u = object.__new__(cls)</span>
            <span class="s1">u._subtype = subtype</span>
            <span class="s1">u._closed = closed</span>
            <span class="s1">cls._cache_dtypes[key] = u</span>
            <span class="s2">return </span><span class="s1">u</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">closed(self):</span>
        <span class="s2">return </span><span class="s1">self._closed</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">subtype(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The dtype of the Interval bounds. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._subtype</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_array_type(cls) -&gt; type[IntervalArray]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the array type associated with this dtype. 
 
        Returns 
        ------- 
        type 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">IntervalArray</span>

        <span class="s2">return </span><span class="s1">IntervalArray</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_from_string(cls</span><span class="s2">, </span><span class="s1">string: str_type) -&gt; IntervalDtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        attempt to construct this type from a string, raise a TypeError 
        if its not possible 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(string</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">f&quot;'construct_from_string' expects a string, got </span><span class="s2">{</span><span class="s1">type(string)</span><span class="s2">}</span><span class="s5">&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">string.lower() == </span><span class="s5">&quot;interval&quot; </span><span class="s2">or </span><span class="s1">cls._match.search(string) </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">cls(string)</span>

        <span class="s1">msg = (</span>
            <span class="s5">f&quot;Cannot construct a 'IntervalDtype' from '</span><span class="s2">{</span><span class="s1">string</span><span class="s2">}</span><span class="s5">'.</span><span class="s2">\n\n</span><span class="s5">&quot;</span>
            <span class="s5">&quot;Incorrectly formatted string passed to constructor. &quot;</span>
            <span class="s5">&quot;Valid formats include Interval or Interval[dtype] &quot;</span>
            <span class="s5">&quot;where dtype is numeric, datetime, or timedelta&quot;</span>
        <span class="s1">)</span>
        <span class="s2">raise </span><span class="s1">TypeError(msg)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">type(self):</span>
        <span class="s2">return </span><span class="s1">Interval</span>

    <span class="s2">def </span><span class="s1">__str__(self) -&gt; str_type:</span>
        <span class="s2">if </span><span class="s1">self.subtype </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s5">&quot;interval&quot;</span>
        <span class="s2">if </span><span class="s1">self.closed </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># Only partially initialized GH#38394</span>
            <span class="s2">return </span><span class="s5">f&quot;interval[</span><span class="s2">{</span><span class="s1">self.subtype</span><span class="s2">}</span><span class="s5">]&quot;</span>
        <span class="s2">return </span><span class="s5">f&quot;interval[</span><span class="s2">{</span><span class="s1">self.subtype</span><span class="s2">}</span><span class="s5">, </span><span class="s2">{</span><span class="s1">self.closed</span><span class="s2">}</span><span class="s5">]&quot;</span>

    <span class="s2">def </span><span class="s1">__hash__(self) -&gt; int:</span>
        <span class="s3"># make myself hashable</span>
        <span class="s2">return </span><span class="s1">hash(str(self))</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other: Any) -&gt; bool:</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">return </span><span class="s1">other.lower() </span><span class="s2">in </span><span class="s1">(self.name.lower()</span><span class="s2">, </span><span class="s1">str(self).lower())</span>
        <span class="s2">elif not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">IntervalDtype):</span>
            <span class="s2">return False</span>
        <span class="s2">elif </span><span class="s1">self.subtype </span><span class="s2">is None or </span><span class="s1">other.subtype </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># None should match any subtype</span>
            <span class="s2">return True</span>
        <span class="s2">elif </span><span class="s1">self.closed != other.closed:</span>
            <span class="s2">return False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">is_dtype_equal</span>

            <span class="s2">return </span><span class="s1">is_dtype_equal(self.subtype</span><span class="s2">, </span><span class="s1">other.subtype)</span>

    <span class="s2">def </span><span class="s1">__setstate__(self</span><span class="s2">, </span><span class="s1">state):</span>
        <span class="s3"># for pickle compat. __get_state__ is defined in the</span>
        <span class="s3"># PandasExtensionDtype superclass and uses the public properties to</span>
        <span class="s3"># pickle -&gt; need to set the settable private ones here (see GH26067)</span>
        <span class="s1">self._subtype = state[</span><span class="s5">&quot;subtype&quot;</span><span class="s1">]</span>

        <span class="s3"># backward-compat older pickles won't have &quot;closed&quot; key</span>
        <span class="s1">self._closed = state.pop(</span><span class="s5">&quot;closed&quot;</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">is_dtype(cls</span><span class="s2">, </span><span class="s1">dtype: object) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a boolean if we if the passed type is an actual dtype that we 
        can match (via string or type) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">if </span><span class="s1">dtype.lower().startswith(</span><span class="s5">&quot;interval&quot;</span><span class="s1">):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">cls.construct_from_string(dtype) </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s2">return True</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">return False</span>
                <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">TypeError):</span>
                    <span class="s2">return False</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return False</span>
        <span class="s2">return </span><span class="s1">super().is_dtype(dtype)</span>

    <span class="s2">def </span><span class="s1">__from_arrow__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">array: pyarrow.Array | pyarrow.ChunkedArray</span>
    <span class="s1">) -&gt; IntervalArray:</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct IntervalArray from pyarrow Array/ChunkedArray. 
        &quot;&quot;&quot;</span>
        <span class="s2">import </span><span class="s1">pyarrow</span>

        <span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">IntervalArray</span>

        <span class="s2">if </span><span class="s1">isinstance(array</span><span class="s2">, </span><span class="s1">pyarrow.Array):</span>
            <span class="s1">chunks = [array]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">chunks = array.chunks</span>

        <span class="s1">results = []</span>
        <span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">chunks:</span>
            <span class="s1">left = np.asarray(arr.storage.field(</span><span class="s5">&quot;left&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=self.subtype)</span>
            <span class="s1">right = np.asarray(arr.storage.field(</span><span class="s5">&quot;right&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=self.subtype)</span>
            <span class="s1">iarr = IntervalArray.from_arrays(left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">closed=array.type.closed)</span>
            <span class="s1">results.append(iarr)</span>

        <span class="s2">if not </span><span class="s1">results:</span>
            <span class="s2">return </span><span class="s1">IntervalArray.from_arrays(</span>
                <span class="s1">np.array([]</span><span class="s2">, </span><span class="s1">dtype=self.subtype)</span><span class="s2">,</span>
                <span class="s1">np.array([]</span><span class="s2">, </span><span class="s1">dtype=self.subtype)</span><span class="s2">,</span>
                <span class="s1">closed=array.type.closed</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">IntervalArray._concat_same_type(results)</span>

    <span class="s2">def </span><span class="s1">_get_common_dtype(self</span><span class="s2">, </span><span class="s1">dtypes: list[DtypeObj]) -&gt; DtypeObj | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">IntervalDtype) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dtypes):</span>
            <span class="s2">return None</span>

        <span class="s1">closed = cast(</span><span class="s5">&quot;IntervalDtype&quot;</span><span class="s2">, </span><span class="s1">dtypes[</span><span class="s4">0</span><span class="s1">]).closed</span>
        <span class="s2">if not </span><span class="s1">all(cast(</span><span class="s5">&quot;IntervalDtype&quot;</span><span class="s2">, </span><span class="s1">x).closed == closed </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dtypes):</span>
            <span class="s2">return </span><span class="s1">np.dtype(object)</span>

        <span class="s2">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s2">import </span><span class="s1">find_common_type</span>

        <span class="s1">common = find_common_type([cast(</span><span class="s5">&quot;IntervalDtype&quot;</span><span class="s2">, </span><span class="s1">x).subtype </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dtypes])</span>
        <span class="s2">if </span><span class="s1">common == object:</span>
            <span class="s2">return </span><span class="s1">np.dtype(object)</span>
        <span class="s2">return </span><span class="s1">IntervalDtype(common</span><span class="s2">, </span><span class="s1">closed=closed)</span>


<span class="s2">class </span><span class="s1">PandasDtype(ExtensionDtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    A Pandas ExtensionDtype for NumPy dtypes. 
 
    This is mostly for internal compatibility, and is not especially 
    useful on its own. 
 
    Parameters 
    ---------- 
    dtype : object 
        Object to be converted to a NumPy data type object. 
 
    See Also 
    -------- 
    numpy.dtype 
    &quot;&quot;&quot;</span>

    <span class="s1">_metadata = (</span><span class="s5">&quot;_dtype&quot;</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">dtype: npt.DTypeLike | PandasDtype | </span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">PandasDtype):</span>
            <span class="s3"># make constructor univalent</span>
            <span class="s1">dtype = dtype.numpy_dtype</span>
        <span class="s1">self._dtype = np.dtype(dtype)</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s5">f&quot;PandasDtype(</span><span class="s2">{</span><span class="s1">repr(self.name)</span><span class="s2">}</span><span class="s5">)&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">numpy_dtype(self) -&gt; np.dtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        The NumPy dtype this PandasDtype wraps. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._dtype</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">name(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        A bit-width name for this data-type. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._dtype.name</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">type(self) -&gt; type[np.generic]:</span>
        <span class="s0">&quot;&quot;&quot; 
        The type object used to instantiate a scalar of this NumPy data-type. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._dtype.type</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_is_numeric(self) -&gt; bool:</span>
        <span class="s3"># exclude object, str, unicode, void.</span>
        <span class="s2">return </span><span class="s1">self.kind </span><span class="s2">in </span><span class="s1">set(</span><span class="s5">&quot;biufc&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_is_boolean(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">self.kind == </span><span class="s5">&quot;b&quot;</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_from_string(cls</span><span class="s2">, </span><span class="s1">string: str) -&gt; PandasDtype:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">dtype = np.dtype(string)</span>
        <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s2">if not </span><span class="s1">isinstance(string</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">msg = </span><span class="s5">f&quot;'construct_from_string' expects a string, got </span><span class="s2">{</span><span class="s1">type(string)</span><span class="s2">}</span><span class="s5">&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s5">f&quot;Cannot construct a 'PandasDtype' from '</span><span class="s2">{</span><span class="s1">string</span><span class="s2">}</span><span class="s5">'&quot;</span>
            <span class="s2">raise </span><span class="s1">TypeError(msg) </span><span class="s2">from </span><span class="s1">err</span>
        <span class="s2">return </span><span class="s1">cls(dtype)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_array_type(cls) -&gt; type_t[PandasArray]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the array type associated with this dtype. 
 
        Returns 
        ------- 
        type 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">PandasArray</span>

        <span class="s2">return </span><span class="s1">PandasArray</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">kind(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        A character code (one of 'biufcmMOSUV') identifying the general kind of data. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._dtype.kind</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">itemsize(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot; 
        The element size of this data-type object. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._dtype.itemsize</span>
</pre>
</body>
</html>