<html>
<head>
<title>test_pandas.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_pandas.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">datetime</span>
<span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">timedelta</span>
<span class="s0">from </span><span class="s1">decimal </span><span class="s0">import </span><span class="s1">Decimal</span>
<span class="s0">from </span><span class="s1">io </span><span class="s0">import </span><span class="s1">StringIO</span>
<span class="s0">import </span><span class="s1">json</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">sys</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">pandas.compat </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">IS64</span><span class="s0">,</span>
    <span class="s1">PY310</span><span class="s0">,</span>
    <span class="s1">is_platform_windows</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas.util._test_decorators </span><span class="s0">as </span><span class="s1">td</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s0">,</span>
    <span class="s1">DatetimeIndex</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">Timestamp</span><span class="s0">,</span>
    <span class="s1">read_json</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>

<span class="s1">_seriesd = tm.getSeriesData()</span>

<span class="s1">_frame = DataFrame(_seriesd)</span>

<span class="s1">_cat_frame = _frame.copy()</span>
<span class="s1">cat = [</span><span class="s2">&quot;bah&quot;</span><span class="s1">] * </span><span class="s3">5 </span><span class="s1">+ [</span><span class="s2">&quot;bar&quot;</span><span class="s1">] * </span><span class="s3">5 </span><span class="s1">+ [</span><span class="s2">&quot;baz&quot;</span><span class="s1">] * </span><span class="s3">5 </span><span class="s1">+ [</span><span class="s2">&quot;foo&quot;</span><span class="s1">] * (len(_cat_frame) - </span><span class="s3">15</span><span class="s1">)</span>
<span class="s1">_cat_frame.index = pd.CategoricalIndex(cat</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;E&quot;</span><span class="s1">)</span>
<span class="s1">_cat_frame[</span><span class="s2">&quot;E&quot;</span><span class="s1">] = list(reversed(cat))</span>
<span class="s1">_cat_frame[</span><span class="s2">&quot;sort&quot;</span><span class="s1">] = np.arange(len(_cat_frame)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">assert_json_roundtrip_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">orient):</span>
    <span class="s0">if </span><span class="s1">orient == </span><span class="s2">&quot;records&quot; </span><span class="s0">or </span><span class="s1">orient == </span><span class="s2">&quot;values&quot;</span><span class="s1">:</span>
        <span class="s1">expected = expected.reset_index(drop=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">orient == </span><span class="s2">&quot;values&quot;</span><span class="s1">:</span>
        <span class="s1">expected.columns = range(len(expected.columns))</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.filterwarnings(</span>
    <span class="s2">&quot;ignore:an integer is required (got type float)*:DeprecationWarning&quot;</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.filterwarnings(</span><span class="s2">&quot;ignore:the 'numpy' keyword is deprecated:FutureWarning&quot;</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">TestPandasContainer:</span>
    <span class="s1">@pytest.fixture(autouse=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">setup(self):</span>
        <span class="s1">self.categorical = _cat_frame.copy()</span>

        <span class="s0">yield</span>

    <span class="s1">@pytest.fixture</span>
    <span class="s0">def </span><span class="s1">datetime_series(self):</span>
        <span class="s4"># Same as usual datetime_series, but with index freq set to None,</span>
        <span class="s4">#  since that doesn't round-trip, see GH#33711</span>
        <span class="s1">ser = tm.makeTimeSeries()</span>
        <span class="s1">ser.name = </span><span class="s2">&quot;ts&quot;</span>
        <span class="s1">ser.index = ser.index._with_freq(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">ser</span>

    <span class="s1">@pytest.fixture</span>
    <span class="s0">def </span><span class="s1">datetime_frame(self):</span>
        <span class="s4"># Same as usual datetime_frame, but with index freq set to None,</span>
        <span class="s4">#  since that doesn't round-trip, see GH#33711</span>
        <span class="s1">df = DataFrame(tm.getTimeSeriesData())</span>
        <span class="s1">df.index = df.index._with_freq(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">df</span>

    <span class="s0">def </span><span class="s1">test_frame_double_encoded_labels(self</span><span class="s0">, </span><span class="s1">orient):</span>
        <span class="s1">df = DataFrame(</span>
            <span class="s1">[[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">index=[</span><span class="s2">'index &quot; 1'</span><span class="s0">, </span><span class="s2">&quot;index / 2&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">columns=[</span><span class="s2">&quot;a </span><span class="s0">\\ </span><span class="s2">b&quot;</span><span class="s0">, </span><span class="s2">&quot;y / z&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">result = read_json(df.to_json(orient=orient)</span><span class="s0">, </span><span class="s1">orient=orient)</span>
        <span class="s1">expected = df.copy()</span>

        <span class="s1">assert_json_roundtrip_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">orient)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;orient&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;split&quot;</span><span class="s0">, </span><span class="s2">&quot;records&quot;</span><span class="s0">, </span><span class="s2">&quot;values&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_frame_non_unique_index(self</span><span class="s0">, </span><span class="s1">orient):</span>
        <span class="s1">df = DataFrame([[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">])</span>
        <span class="s1">result = read_json(df.to_json(orient=orient)</span><span class="s0">, </span><span class="s1">orient=orient)</span>
        <span class="s1">expected = df.copy()</span>

        <span class="s1">assert_json_roundtrip_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">orient)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;orient&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s2">&quot;columns&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_frame_non_unique_index_raises(self</span><span class="s0">, </span><span class="s1">orient):</span>
        <span class="s1">df = DataFrame([[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">])</span>
        <span class="s1">msg = </span><span class="s2">f&quot;DataFrame index must be unique for orient='</span><span class="s0">{</span><span class="s1">orient</span><span class="s0">}</span><span class="s2">'&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">df.to_json(orient=orient)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;orient&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;split&quot;</span><span class="s0">, </span><span class="s2">&quot;values&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;data&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">[[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">[[</span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">2.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3.5</span><span class="s0">, </span><span class="s3">4.5</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4.5</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">[[Timestamp(</span><span class="s2">&quot;20130101&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">3.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[Timestamp(</span><span class="s2">&quot;20130102&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">4.5</span><span class="s1">]]</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_frame_non_unique_columns(self</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">data):</span>
        <span class="s1">df = DataFrame(data</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s1">])</span>

        <span class="s1">result = read_json(</span>
            <span class="s1">df.to_json(orient=orient)</span><span class="s0">, </span><span class="s1">orient=orient</span><span class="s0">, </span><span class="s1">convert_dates=[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">orient == </span><span class="s2">&quot;values&quot;</span><span class="s1">:</span>
            <span class="s1">expected = DataFrame(data)</span>
            <span class="s0">if </span><span class="s1">expected.iloc[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">].dtype == </span><span class="s2">&quot;datetime64[ns]&quot;</span><span class="s1">:</span>
                <span class="s4"># orient == &quot;values&quot; by default will write Timestamp objects out</span>
                <span class="s4"># in milliseconds; these are internally stored in nanosecond,</span>
                <span class="s4"># so divide to get where we need</span>
                <span class="s4"># TODO: a to_epoch method would also solve; see GH 14772</span>
                <span class="s1">expected.iloc[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] = expected.iloc[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">].view(np.int64) // </span><span class="s3">1000000</span>
        <span class="s0">elif </span><span class="s1">orient == </span><span class="s2">&quot;split&quot;</span><span class="s1">:</span>
            <span class="s1">expected = df</span>

        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;orient&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s2">&quot;columns&quot;</span><span class="s0">, </span><span class="s2">&quot;records&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_frame_non_unique_columns_raises(self</span><span class="s0">, </span><span class="s1">orient):</span>
        <span class="s1">df = DataFrame([[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s1">])</span>

        <span class="s1">msg = </span><span class="s2">f&quot;DataFrame columns must be unique for orient='</span><span class="s0">{</span><span class="s1">orient</span><span class="s0">}</span><span class="s2">'&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">df.to_json(orient=orient)</span>

    <span class="s0">def </span><span class="s1">test_frame_default_orient(self</span><span class="s0">, </span><span class="s1">float_frame):</span>
        <span class="s0">assert </span><span class="s1">float_frame.to_json() == float_frame.to_json(orient=</span><span class="s2">&quot;columns&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, </span><span class="s1">float])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;convert_axes&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;numpy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_roundtrip_simple(self</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">convert_axes</span><span class="s0">, </span><span class="s1">numpy</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">float_frame):</span>
        <span class="s1">data = float_frame.to_json(orient=orient)</span>
        <span class="s1">result = read_json(</span>
            <span class="s1">data</span><span class="s0">, </span><span class="s1">orient=orient</span><span class="s0">, </span><span class="s1">convert_axes=convert_axes</span><span class="s0">, </span><span class="s1">numpy=numpy</span><span class="s0">, </span><span class="s1">dtype=dtype</span>
        <span class="s1">)</span>

        <span class="s1">expected = float_frame</span>

        <span class="s1">assert_json_roundtrip_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">orient)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, </span><span class="s1">np.int64])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;convert_axes&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;numpy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_roundtrip_intframe(self</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">convert_axes</span><span class="s0">, </span><span class="s1">numpy</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">int_frame):</span>
        <span class="s1">data = int_frame.to_json(orient=orient)</span>
        <span class="s1">result = read_json(</span>
            <span class="s1">data</span><span class="s0">, </span><span class="s1">orient=orient</span><span class="s0">, </span><span class="s1">convert_axes=convert_axes</span><span class="s0">, </span><span class="s1">numpy=numpy</span><span class="s0">, </span><span class="s1">dtype=dtype</span>
        <span class="s1">)</span>
        <span class="s1">expected = int_frame</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">numpy</span>
            <span class="s0">and </span><span class="s1">(</span><span class="s0">not </span><span class="s1">IS64 </span><span class="s0">or </span><span class="s1">is_platform_windows())</span>
            <span class="s0">and not </span><span class="s1">dtype</span>
            <span class="s0">and </span><span class="s1">orient != </span><span class="s2">&quot;split&quot;</span>
        <span class="s1">):</span>
            <span class="s4"># TODO: see what is causing roundtrip dtype loss</span>
            <span class="s1">expected = expected.astype(np.int32)</span>

        <span class="s1">assert_json_roundtrip_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">orient)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s1">np.float64</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s2">&quot;U3&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;convert_axes&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;numpy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_roundtrip_str_axes(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">convert_axes</span><span class="s0">, </span><span class="s1">numpy</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s1">df = DataFrame(</span>
            <span class="s1">np.zeros((</span><span class="s3">200</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">columns=[str(i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">4</span><span class="s1">)]</span><span class="s0">,</span>
            <span class="s1">index=[str(i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">200</span><span class="s1">)]</span><span class="s0">,</span>
            <span class="s1">dtype=dtype</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s4"># TODO: do we even need to support U3 dtypes?</span>
        <span class="s0">if </span><span class="s1">numpy </span><span class="s0">and </span><span class="s1">dtype == </span><span class="s2">&quot;U3&quot; </span><span class="s0">and </span><span class="s1">orient != </span><span class="s2">&quot;split&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(reason=</span><span class="s2">&quot;Can't decode directly to array&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">data = df.to_json(orient=orient)</span>
        <span class="s1">result = read_json(</span>
            <span class="s1">data</span><span class="s0">, </span><span class="s1">orient=orient</span><span class="s0">, </span><span class="s1">convert_axes=convert_axes</span><span class="s0">, </span><span class="s1">numpy=numpy</span><span class="s0">, </span><span class="s1">dtype=dtype</span>
        <span class="s1">)</span>

        <span class="s1">expected = df.copy()</span>
        <span class="s0">if not </span><span class="s1">dtype:</span>
            <span class="s1">expected = expected.astype(np.int64)</span>

        <span class="s4"># index columns, and records orients cannot fully preserve the string</span>
        <span class="s4"># dtype for axes as the index and column labels are used as keys in</span>
        <span class="s4"># JSON objects. JSON keys are by definition strings, so there's no way</span>
        <span class="s4"># to disambiguate whether those keys actually were strings or numeric</span>
        <span class="s4"># beforehand and numeric wins out.</span>
        <span class="s0">if </span><span class="s1">convert_axes </span><span class="s0">and </span><span class="s1">(orient </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s2">&quot;columns&quot;</span><span class="s1">)):</span>
            <span class="s1">expected.columns = expected.columns.astype(np.int64)</span>
            <span class="s1">expected.index = expected.index.astype(np.int64)</span>
        <span class="s0">elif </span><span class="s1">orient == </span><span class="s2">&quot;records&quot; </span><span class="s0">and </span><span class="s1">convert_axes:</span>
            <span class="s1">expected.columns = expected.columns.astype(np.int64)</span>
        <span class="s0">elif </span><span class="s1">convert_axes </span><span class="s0">and </span><span class="s1">orient == </span><span class="s2">&quot;split&quot;</span><span class="s1">:</span>
            <span class="s1">expected.columns = expected.columns.astype(np.int64)</span>

        <span class="s1">assert_json_roundtrip_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">orient)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;convert_axes&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;numpy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_roundtrip_categorical(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">convert_axes</span><span class="s0">, </span><span class="s1">numpy):</span>
        <span class="s4"># TODO: create a better frame to test with and improve coverage</span>
        <span class="s0">if </span><span class="s1">orient </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s2">&quot;columns&quot;</span><span class="s1">):</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">f&quot;Can't have duplicate index values for orient '</span><span class="s0">{</span><span class="s1">orient</span><span class="s0">}</span><span class="s2">')&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">data = self.categorical.to_json(orient=orient)</span>
        <span class="s0">if </span><span class="s1">numpy </span><span class="s0">and </span><span class="s1">orient </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;records&quot;</span><span class="s0">, </span><span class="s2">&quot;values&quot;</span><span class="s1">):</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(reason=</span><span class="s2">f&quot;Orient </span><span class="s0">{</span><span class="s1">orient</span><span class="s0">} </span><span class="s2">is broken with numpy=True&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">result = read_json(data</span><span class="s0">, </span><span class="s1">orient=orient</span><span class="s0">, </span><span class="s1">convert_axes=convert_axes</span><span class="s0">, </span><span class="s1">numpy=numpy)</span>

        <span class="s1">expected = self.categorical.copy()</span>
        <span class="s1">expected.index = expected.index.astype(str)  </span><span class="s4"># Categorical not preserved</span>
        <span class="s1">expected.index.name = </span><span class="s0">None  </span><span class="s4"># index names aren't preserved in JSON</span>

        <span class="s0">if not </span><span class="s1">numpy </span><span class="s0">and </span><span class="s1">orient == </span><span class="s2">&quot;index&quot;</span><span class="s1">:</span>
            <span class="s1">expected = expected.sort_index()</span>

        <span class="s1">assert_json_roundtrip_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">orient)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;convert_axes&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;numpy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_roundtrip_empty(self</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">convert_axes</span><span class="s0">, </span><span class="s1">numpy):</span>
        <span class="s1">empty_frame = DataFrame()</span>
        <span class="s1">data = empty_frame.to_json(orient=orient)</span>
        <span class="s1">result = read_json(data</span><span class="s0">, </span><span class="s1">orient=orient</span><span class="s0">, </span><span class="s1">convert_axes=convert_axes</span><span class="s0">, </span><span class="s1">numpy=numpy)</span>
        <span class="s1">expected = empty_frame.copy()</span>

        <span class="s4"># TODO: both conditions below are probably bugs</span>
        <span class="s0">if </span><span class="s1">convert_axes:</span>
            <span class="s1">expected.index = expected.index.astype(float)</span>
            <span class="s1">expected.columns = expected.columns.astype(float)</span>
        <span class="s0">if </span><span class="s1">numpy </span><span class="s0">and </span><span class="s1">orient == </span><span class="s2">&quot;values&quot;</span><span class="s1">:</span>
            <span class="s1">expected = expected.reindex([</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">).reset_index(drop=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;convert_axes&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;numpy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_roundtrip_timestamp(self</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">convert_axes</span><span class="s0">, </span><span class="s1">numpy</span><span class="s0">, </span><span class="s1">datetime_frame):</span>
        <span class="s4"># TODO: improve coverage with date_format parameter</span>
        <span class="s1">data = datetime_frame.to_json(orient=orient)</span>
        <span class="s1">result = read_json(data</span><span class="s0">, </span><span class="s1">orient=orient</span><span class="s0">, </span><span class="s1">convert_axes=convert_axes</span><span class="s0">, </span><span class="s1">numpy=numpy)</span>
        <span class="s1">expected = datetime_frame.copy()</span>

        <span class="s0">if not </span><span class="s1">convert_axes:  </span><span class="s4"># one off for ts handling</span>
            <span class="s4"># DTI gets converted to epoch values</span>
            <span class="s1">idx = expected.index.view(np.int64) // </span><span class="s3">1000000</span>
            <span class="s0">if </span><span class="s1">orient != </span><span class="s2">&quot;split&quot;</span><span class="s1">:  </span><span class="s4"># TODO: handle consistently across orients</span>
                <span class="s1">idx = idx.astype(str)</span>

            <span class="s1">expected.index = idx</span>

        <span class="s1">assert_json_roundtrip_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">orient)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;convert_axes&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;numpy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_roundtrip_mixed(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">convert_axes</span><span class="s0">, </span><span class="s1">numpy):</span>
        <span class="s0">if </span><span class="s1">numpy </span><span class="s0">and </span><span class="s1">orient != </span><span class="s2">&quot;split&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(reason=</span><span class="s2">&quot;Can't decode directly to array&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">index = pd.Index([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">])</span>
        <span class="s1">values = {</span>
            <span class="s2">&quot;A&quot;</span><span class="s1">: [</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">4.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;B&quot;</span><span class="s1">: [</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;C&quot;</span><span class="s1">: [</span><span class="s2">&quot;foo1&quot;</span><span class="s0">, </span><span class="s2">&quot;foo2&quot;</span><span class="s0">, </span><span class="s2">&quot;foo3&quot;</span><span class="s0">, </span><span class="s2">&quot;foo4&quot;</span><span class="s0">, </span><span class="s2">&quot;foo5&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;D&quot;</span><span class="s1">: [</span><span class="s0">True, False, True, False, True</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">df = DataFrame(data=values</span><span class="s0">, </span><span class="s1">index=index)</span>

        <span class="s1">data = df.to_json(orient=orient)</span>
        <span class="s1">result = read_json(data</span><span class="s0">, </span><span class="s1">orient=orient</span><span class="s0">, </span><span class="s1">convert_axes=convert_axes</span><span class="s0">, </span><span class="s1">numpy=numpy)</span>

        <span class="s1">expected = df.copy()</span>
        <span class="s1">expected = expected.assign(**expected.select_dtypes(</span><span class="s2">&quot;number&quot;</span><span class="s1">).astype(np.int64))</span>

        <span class="s0">if not </span><span class="s1">numpy </span><span class="s0">and </span><span class="s1">orient == </span><span class="s2">&quot;index&quot;</span><span class="s1">:</span>
            <span class="s1">expected = expected.sort_index()</span>

        <span class="s1">assert_json_roundtrip_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">orient)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;data,msg,orient&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s2">'{&quot;key&quot;:b:a:d}'</span><span class="s0">, </span><span class="s2">&quot;Expected object or value&quot;</span><span class="s0">, </span><span class="s2">&quot;columns&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s4"># too few indices</span>
            <span class="s1">(</span>
                <span class="s2">'{&quot;columns&quot;:[&quot;A&quot;,&quot;B&quot;],'</span>
                <span class="s2">'&quot;index&quot;:[&quot;2&quot;,&quot;3&quot;],'</span>
                <span class="s2">'&quot;data&quot;:[[1.0,&quot;1&quot;],[2.0,&quot;2&quot;],[null,&quot;3&quot;]]}'</span><span class="s0">,</span>
                <span class="s2">&quot;|&quot;</span><span class="s1">.join(</span>
                    <span class="s1">[</span>
                        <span class="s2">r&quot;Length of values \(3\) does not match length of index \(2\)&quot;</span><span class="s0">,</span>
                    <span class="s1">]</span>
                <span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;split&quot;</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s4"># too many columns</span>
            <span class="s1">(</span>
                <span class="s2">'{&quot;columns&quot;:[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;],'</span>
                <span class="s2">'&quot;index&quot;:[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;],'</span>
                <span class="s2">'&quot;data&quot;:[[1.0,&quot;1&quot;],[2.0,&quot;2&quot;],[null,&quot;3&quot;]]}'</span><span class="s0">,</span>
                <span class="s2">&quot;3 columns passed, passed data had 2 columns&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;split&quot;</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s4"># bad key</span>
            <span class="s1">(</span>
                <span class="s2">'{&quot;badkey&quot;:[&quot;A&quot;,&quot;B&quot;],'</span>
                <span class="s2">'&quot;index&quot;:[&quot;2&quot;,&quot;3&quot;],'</span>
                <span class="s2">'&quot;data&quot;:[[1.0,&quot;1&quot;],[2.0,&quot;2&quot;],[null,&quot;3&quot;]]}'</span><span class="s0">,</span>
                <span class="s2">r&quot;unexpected key\(s\): badkey&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;split&quot;</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_frame_from_json_bad_data_raises(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">msg</span><span class="s0">, </span><span class="s1">orient):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">read_json(StringIO(data)</span><span class="s0">, </span><span class="s1">orient=orient)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;convert_axes&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;numpy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_frame_from_json_missing_data(self</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">convert_axes</span><span class="s0">, </span><span class="s1">numpy</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s1">num_df = DataFrame([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]])</span>
        <span class="s1">result = read_json(</span>
            <span class="s1">num_df.to_json(orient=orient)</span><span class="s0">,</span>
            <span class="s1">orient=orient</span><span class="s0">,</span>
            <span class="s1">convert_axes=convert_axes</span><span class="s0">,</span>
            <span class="s1">dtype=dtype</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">np.isnan(result.iloc[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>

        <span class="s1">obj_df = DataFrame([[</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;4&quot;</span><span class="s0">, </span><span class="s2">&quot;5&quot;</span><span class="s0">, </span><span class="s2">&quot;6&quot;</span><span class="s1">]])</span>
        <span class="s1">result = read_json(</span>
            <span class="s1">obj_df.to_json(orient=orient)</span><span class="s0">,</span>
            <span class="s1">orient=orient</span><span class="s0">,</span>
            <span class="s1">convert_axes=convert_axes</span><span class="s0">,</span>
            <span class="s1">dtype=dtype</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">np.isnan(result.iloc[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_frame_read_json_dtype_missing_value(self</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s4"># GH28501 Parse missing values using read_json with dtype=False</span>
        <span class="s4"># to NaN instead of None</span>
        <span class="s1">result = read_json(</span><span class="s2">&quot;[null]&quot;</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">expected = DataFrame([np.nan])</span>

        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;inf&quot;</span><span class="s0">, </span><span class="s1">[np.inf</span><span class="s0">, </span><span class="s1">np.NINF])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_frame_infinity(self</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">inf</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s4"># infinities get mapped to nulls which get mapped to NaNs during</span>
        <span class="s4"># deserialisation</span>
        <span class="s1">df = DataFrame([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]])</span>
        <span class="s1">df.loc[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">] = inf</span>
        <span class="s1">result = read_json(df.to_json()</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s0">assert </span><span class="s1">np.isnan(result.iloc[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">IS64</span><span class="s0">, </span><span class="s1">reason=</span><span class="s2">&quot;not compliant on 32-bit, xref #15865&quot;</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;value,precision,expected_val&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">0.95</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">1.95</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(-</span><span class="s3">1.95</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2.0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">0.995</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">0.9995</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">0.99999999999999944</span><span class="s0">, </span><span class="s3">15</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_frame_to_json_float_precision(self</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">precision</span><span class="s0">, </span><span class="s1">expected_val):</span>
        <span class="s1">df = DataFrame([{</span><span class="s2">&quot;a_float&quot;</span><span class="s1">: value}])</span>
        <span class="s1">encoded = df.to_json(double_precision=precision)</span>
        <span class="s0">assert </span><span class="s1">encoded == </span><span class="s2">f'</span><span class="s0">{{</span><span class="s2">&quot;a_float&quot;:</span><span class="s0">{{</span><span class="s2">&quot;0&quot;:</span><span class="s0">{</span><span class="s1">expected_val</span><span class="s0">}}}}}</span><span class="s2">'</span>

    <span class="s0">def </span><span class="s1">test_frame_to_json_except(self):</span>
        <span class="s1">df = DataFrame([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
        <span class="s1">msg = </span><span class="s2">&quot;Invalid value 'garbage' for option 'orient'&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">df.to_json(orient=</span><span class="s2">&quot;garbage&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_frame_empty(self):</span>
        <span class="s1">df = DataFrame(columns=[</span><span class="s2">&quot;jim&quot;</span><span class="s0">, </span><span class="s2">&quot;joe&quot;</span><span class="s1">])</span>
        <span class="s0">assert not </span><span class="s1">df._is_mixed_type</span>
        <span class="s1">tm.assert_frame_equal(</span>
            <span class="s1">read_json(df.to_json()</span><span class="s0">, </span><span class="s1">dtype=dict(df.dtypes))</span><span class="s0">, </span><span class="s1">df</span><span class="s0">, </span><span class="s1">check_index_type=</span><span class="s0">False</span>
        <span class="s1">)</span>
        <span class="s4"># GH 7445</span>
        <span class="s1">result = DataFrame({</span><span class="s2">&quot;test&quot;</span><span class="s1">: []}</span><span class="s0">, </span><span class="s1">index=[]).to_json(orient=</span><span class="s2">&quot;columns&quot;</span><span class="s1">)</span>
        <span class="s1">expected = </span><span class="s2">'{&quot;test&quot;:{}}'</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s0">def </span><span class="s1">test_frame_empty_mixedtype(self):</span>
        <span class="s4"># mixed type</span>
        <span class="s1">df = DataFrame(columns=[</span><span class="s2">&quot;jim&quot;</span><span class="s0">, </span><span class="s2">&quot;joe&quot;</span><span class="s1">])</span>
        <span class="s1">df[</span><span class="s2">&quot;joe&quot;</span><span class="s1">] = df[</span><span class="s2">&quot;joe&quot;</span><span class="s1">].astype(</span><span class="s2">&quot;i8&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">df._is_mixed_type</span>
        <span class="s1">tm.assert_frame_equal(</span>
            <span class="s1">read_json(df.to_json()</span><span class="s0">, </span><span class="s1">dtype=dict(df.dtypes))</span><span class="s0">, </span><span class="s1">df</span><span class="s0">, </span><span class="s1">check_index_type=</span><span class="s0">False</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_frame_mixedtype_orient(self):  </span><span class="s4"># GH10289</span>
        <span class="s1">vals = [</span>
            <span class="s1">[</span><span class="s3">10</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">0.01</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s3">20</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s0">, </span><span class="s3">0.2</span><span class="s0">, </span><span class="s3">0.02</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s3">30</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s2">&quot;baz&quot;</span><span class="s0">, </span><span class="s3">0.3</span><span class="s0">, </span><span class="s3">0.03</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s3">40</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s2">&quot;qux&quot;</span><span class="s0">, </span><span class="s3">0.4</span><span class="s0">, </span><span class="s3">0.04</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s1">df = DataFrame(</span>
            <span class="s1">vals</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;abcd&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;1st&quot;</span><span class="s0">, </span><span class="s2">&quot;2nd&quot;</span><span class="s0">, </span><span class="s2">&quot;3rd&quot;</span><span class="s0">, </span><span class="s2">&quot;4th&quot;</span><span class="s0">, </span><span class="s2">&quot;5th&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>

        <span class="s0">assert </span><span class="s1">df._is_mixed_type</span>
        <span class="s1">right = df.copy()</span>

        <span class="s0">for </span><span class="s1">orient </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;split&quot;</span><span class="s0">, </span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s2">&quot;columns&quot;</span><span class="s1">]:</span>
            <span class="s1">inp = df.to_json(orient=orient)</span>
            <span class="s1">left = read_json(inp</span><span class="s0">, </span><span class="s1">orient=orient</span><span class="s0">, </span><span class="s1">convert_axes=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(left</span><span class="s0">, </span><span class="s1">right)</span>

        <span class="s1">right.index = np.arange(len(df))</span>
        <span class="s1">inp = df.to_json(orient=</span><span class="s2">&quot;records&quot;</span><span class="s1">)</span>
        <span class="s1">left = read_json(inp</span><span class="s0">, </span><span class="s1">orient=</span><span class="s2">&quot;records&quot;</span><span class="s0">, </span><span class="s1">convert_axes=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(left</span><span class="s0">, </span><span class="s1">right)</span>

        <span class="s1">right.columns = np.arange(df.shape[</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">inp = df.to_json(orient=</span><span class="s2">&quot;values&quot;</span><span class="s1">)</span>
        <span class="s1">left = read_json(inp</span><span class="s0">, </span><span class="s1">orient=</span><span class="s2">&quot;values&quot;</span><span class="s0">, </span><span class="s1">convert_axes=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(left</span><span class="s0">, </span><span class="s1">right)</span>

    <span class="s0">def </span><span class="s1">test_v12_compat(self</span><span class="s0">, </span><span class="s1">datapath):</span>
        <span class="s1">dti = pd.date_range(</span><span class="s2">&quot;2000-01-03&quot;</span><span class="s0">, </span><span class="s2">&quot;2000-01-07&quot;</span><span class="s1">)</span>
        <span class="s4"># freq doesn't roundtrip</span>
        <span class="s1">dti = DatetimeIndex(np.asarray(dti)</span><span class="s0">, </span><span class="s1">freq=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">df = DataFrame(</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s3">1.56808523</span><span class="s0">, </span><span class="s3">0.65727391</span><span class="s0">, </span><span class="s3">1.81021139</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.17251653</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[-</span><span class="s3">0.2550111</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.08072427</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.03202878</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.17581665</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s3">1.51493992</span><span class="s0">, </span><span class="s3">0.11805825</span><span class="s0">, </span><span class="s3">1.629455</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.31506612</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[-</span><span class="s3">0.02765498</span><span class="s0">, </span><span class="s3">0.44679743</span><span class="s0">, </span><span class="s3">0.33192641</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.27885413</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s3">0.05951614</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2.69652057</span><span class="s0">, </span><span class="s3">1.28163262</span><span class="s0">, </span><span class="s3">0.34703478</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">columns=[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s0">, </span><span class="s2">&quot;D&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">index=dti</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">df[</span><span class="s2">&quot;date&quot;</span><span class="s1">] = Timestamp(</span><span class="s2">&quot;19920106 18:21:32.12&quot;</span><span class="s1">)</span>
        <span class="s1">df.iloc[</span><span class="s3">3</span><span class="s0">, </span><span class="s1">df.columns.get_loc(</span><span class="s2">&quot;date&quot;</span><span class="s1">)] = Timestamp(</span><span class="s2">&quot;20130101&quot;</span><span class="s1">)</span>
        <span class="s1">df[</span><span class="s2">&quot;modified&quot;</span><span class="s1">] = df[</span><span class="s2">&quot;date&quot;</span><span class="s1">]</span>
        <span class="s1">df.iloc[</span><span class="s3">1</span><span class="s0">, </span><span class="s1">df.columns.get_loc(</span><span class="s2">&quot;modified&quot;</span><span class="s1">)] = pd.NaT</span>

        <span class="s1">dirpath = datapath(</span><span class="s2">&quot;io&quot;</span><span class="s0">, </span><span class="s2">&quot;json&quot;</span><span class="s0">, </span><span class="s2">&quot;data&quot;</span><span class="s1">)</span>
        <span class="s1">v12_json = os.path.join(dirpath</span><span class="s0">, </span><span class="s2">&quot;tsframe_v012.json&quot;</span><span class="s1">)</span>
        <span class="s1">df_unser = read_json(v12_json)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">df_unser)</span>

        <span class="s1">df_iso = df.drop([</span><span class="s2">&quot;modified&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">v12_iso_json = os.path.join(dirpath</span><span class="s0">, </span><span class="s2">&quot;tsframe_iso_v012.json&quot;</span><span class="s1">)</span>
        <span class="s1">df_unser_iso = read_json(v12_iso_json)</span>
        <span class="s1">tm.assert_frame_equal(df_iso</span><span class="s0">, </span><span class="s1">df_unser_iso)</span>

    <span class="s0">def </span><span class="s1">test_blocks_compat_GH9037(self):</span>
        <span class="s1">index = pd.date_range(</span><span class="s2">&quot;20000101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;H&quot;</span><span class="s1">)</span>
        <span class="s4"># freq doesn't round-trip</span>
        <span class="s1">index = DatetimeIndex(list(index)</span><span class="s0">, </span><span class="s1">freq=</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s1">df_mixed = DataFrame(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;float_1&quot;</span><span class="s1">: [</span>
                    <span class="s1">-</span><span class="s3">0.92077639</span><span class="s0">,</span>
                    <span class="s3">0.77434435</span><span class="s0">,</span>
                    <span class="s3">1.25234727</span><span class="s0">,</span>
                    <span class="s3">0.61485564</span><span class="s0">,</span>
                    <span class="s1">-</span><span class="s3">0.60316077</span><span class="s0">,</span>
                    <span class="s3">0.24653374</span><span class="s0">,</span>
                    <span class="s3">0.28668979</span><span class="s0">,</span>
                    <span class="s1">-</span><span class="s3">2.51969012</span><span class="s0">,</span>
                    <span class="s3">0.95748401</span><span class="s0">,</span>
                    <span class="s1">-</span><span class="s3">1.02970536</span><span class="s0">,</span>
                <span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;int_1&quot;</span><span class="s1">: [</span>
                    <span class="s3">19680418</span><span class="s0">,</span>
                    <span class="s3">75337055</span><span class="s0">,</span>
                    <span class="s3">99973684</span><span class="s0">,</span>
                    <span class="s3">65103179</span><span class="s0">,</span>
                    <span class="s3">79373900</span><span class="s0">,</span>
                    <span class="s3">40314334</span><span class="s0">,</span>
                    <span class="s3">21290235</span><span class="s0">,</span>
                    <span class="s3">4991321</span><span class="s0">,</span>
                    <span class="s3">41903419</span><span class="s0">,</span>
                    <span class="s3">16008365</span><span class="s0">,</span>
                <span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;str_1&quot;</span><span class="s1">: [</span>
                    <span class="s2">&quot;78c608f1&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;64a99743&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;13d2ff52&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;ca7f4af2&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;97236474&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;bde7e214&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;1a6bde47&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;b1190be5&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;7a669144&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;8d64d068&quot;</span><span class="s0">,</span>
                <span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;float_2&quot;</span><span class="s1">: [</span>
                    <span class="s1">-</span><span class="s3">0.0428278</span><span class="s0">,</span>
                    <span class="s1">-</span><span class="s3">1.80872357</span><span class="s0">,</span>
                    <span class="s3">3.36042349</span><span class="s0">,</span>
                    <span class="s1">-</span><span class="s3">0.7573685</span><span class="s0">,</span>
                    <span class="s1">-</span><span class="s3">0.48217572</span><span class="s0">,</span>
                    <span class="s3">0.86229683</span><span class="s0">,</span>
                    <span class="s3">1.08935819</span><span class="s0">,</span>
                    <span class="s3">0.93898739</span><span class="s0">,</span>
                    <span class="s1">-</span><span class="s3">0.03030452</span><span class="s0">,</span>
                    <span class="s3">1.43366348</span><span class="s0">,</span>
                <span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;str_2&quot;</span><span class="s1">: [</span>
                    <span class="s2">&quot;14f04af9&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;d085da90&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;4bcfac83&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;81504caf&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;2ffef4a9&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;08e2f5c4&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;07e1af03&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;addbd4a7&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;1f6a09ba&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;4bfc4d87&quot;</span><span class="s0">,</span>
                <span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;int_2&quot;</span><span class="s1">: [</span>
                    <span class="s3">86967717</span><span class="s0">,</span>
                    <span class="s3">98098830</span><span class="s0">,</span>
                    <span class="s3">51927505</span><span class="s0">,</span>
                    <span class="s3">20372254</span><span class="s0">,</span>
                    <span class="s3">12601730</span><span class="s0">,</span>
                    <span class="s3">20884027</span><span class="s0">,</span>
                    <span class="s3">34193846</span><span class="s0">,</span>
                    <span class="s3">10561746</span><span class="s0">,</span>
                    <span class="s3">24867120</span><span class="s0">,</span>
                    <span class="s3">76131025</span><span class="s0">,</span>
                <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">index=index</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s4"># JSON deserialisation always creates unicode strings</span>
        <span class="s1">df_mixed.columns = df_mixed.columns.astype(</span><span class="s2">&quot;unicode&quot;</span><span class="s1">)</span>

        <span class="s1">df_roundtrip = read_json(df_mixed.to_json(orient=</span><span class="s2">&quot;split&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">orient=</span><span class="s2">&quot;split&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(</span>
            <span class="s1">df_mixed</span><span class="s0">,</span>
            <span class="s1">df_roundtrip</span><span class="s0">,</span>
            <span class="s1">check_index_type=</span><span class="s0">True,</span>
            <span class="s1">check_column_type=</span><span class="s0">True,</span>
            <span class="s1">by_blocks=</span><span class="s0">True,</span>
            <span class="s1">check_exact=</span><span class="s0">True,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_frame_nonprintable_bytes(self):</span>
        <span class="s4"># GH14256: failing column caused segfaults, if it is not the last one</span>

        <span class="s0">class </span><span class="s1">BinaryThing:</span>
            <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">hexed):</span>
                <span class="s1">self.hexed = hexed</span>
                <span class="s1">self.binary = bytes.fromhex(hexed)</span>

            <span class="s0">def </span><span class="s1">__str__(self) -&gt; str:</span>
                <span class="s0">return </span><span class="s1">self.hexed</span>

        <span class="s1">hexed = </span><span class="s2">&quot;574b4454ba8c5eb4f98a8f45&quot;</span>
        <span class="s1">binthing = BinaryThing(hexed)</span>

        <span class="s4"># verify the proper conversion of printable content</span>
        <span class="s1">df_printable = DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: [binthing.hexed]})</span>
        <span class="s0">assert </span><span class="s1">df_printable.to_json() == </span><span class="s2">f'</span><span class="s0">{{</span><span class="s2">&quot;A&quot;:</span><span class="s0">{{</span><span class="s2">&quot;0&quot;:&quot;</span><span class="s0">{</span><span class="s1">hexed</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">}}}}</span><span class="s2">'</span>

        <span class="s4"># check if non-printable content throws appropriate Exception</span>
        <span class="s1">df_nonprintable = DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: [binthing]})</span>
        <span class="s1">msg = </span><span class="s2">&quot;Unsupported UTF-8 sequence length when encoding string&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(OverflowError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">df_nonprintable.to_json()</span>

        <span class="s4"># the same with multiple columns threw segfaults</span>
        <span class="s1">df_mixed = DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: [binthing]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">pytest.raises(OverflowError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">df_mixed.to_json()</span>

        <span class="s4"># default_handler should resolve exceptions for non-string types</span>
        <span class="s1">result = df_nonprintable.to_json(default_handler=str)</span>
        <span class="s1">expected = </span><span class="s2">f'</span><span class="s0">{{</span><span class="s2">&quot;A&quot;:</span><span class="s0">{{</span><span class="s2">&quot;0&quot;:&quot;</span><span class="s0">{</span><span class="s1">hexed</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">}}}}</span><span class="s2">'</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>
        <span class="s0">assert </span><span class="s1">(</span>
            <span class="s1">df_mixed.to_json(default_handler=str)</span>
            <span class="s1">== </span><span class="s2">f'</span><span class="s0">{{</span><span class="s2">&quot;A&quot;:</span><span class="s0">{{</span><span class="s2">&quot;0&quot;:&quot;</span><span class="s0">{</span><span class="s1">hexed</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">}}</span><span class="s2">,&quot;B&quot;:</span><span class="s0">{{</span><span class="s2">&quot;0&quot;:1</span><span class="s0">}}}}</span><span class="s2">'</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_label_overflow(self):</span>
        <span class="s4"># GH14256: buffer length not checked when writing label</span>
        <span class="s1">result = DataFrame({</span><span class="s2">&quot;bar&quot; </span><span class="s1">* </span><span class="s3">100000</span><span class="s1">: [</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;foo&quot;</span><span class="s1">: [</span><span class="s3">1337</span><span class="s1">]}).to_json()</span>
        <span class="s1">expected = </span><span class="s2">f'</span><span class="s0">{{</span><span class="s2">&quot;</span><span class="s0">{</span><span class="s2">&quot;bar&quot; </span><span class="s1">* </span><span class="s3">100000</span><span class="s0">}</span><span class="s2">&quot;:</span><span class="s0">{{</span><span class="s2">&quot;0&quot;:1</span><span class="s0">}}</span><span class="s2">,&quot;foo&quot;:</span><span class="s0">{{</span><span class="s2">&quot;0&quot;:1337</span><span class="s0">}}}}</span><span class="s2">'</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s0">def </span><span class="s1">test_series_non_unique_index(self):</span>
        <span class="s1">s = Series([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>

        <span class="s1">msg = </span><span class="s2">&quot;Series index must be unique for orient='index'&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s.to_json(orient=</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>

        <span class="s1">tm.assert_series_equal(</span>
            <span class="s1">s</span><span class="s0">, </span><span class="s1">read_json(s.to_json(orient=</span><span class="s2">&quot;split&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">orient=</span><span class="s2">&quot;split&quot;</span><span class="s0">, </span><span class="s1">typ=</span><span class="s2">&quot;series&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">unserialized = read_json(</span>
            <span class="s1">s.to_json(orient=</span><span class="s2">&quot;records&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">orient=</span><span class="s2">&quot;records&quot;</span><span class="s0">, </span><span class="s1">typ=</span><span class="s2">&quot;series&quot;</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_numpy_array_equal(s.values</span><span class="s0">, </span><span class="s1">unserialized.values)</span>

    <span class="s0">def </span><span class="s1">test_series_default_orient(self</span><span class="s0">, </span><span class="s1">string_series):</span>
        <span class="s0">assert </span><span class="s1">string_series.to_json() == string_series.to_json(orient=</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;numpy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_series_roundtrip_simple(self</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">numpy</span><span class="s0">, </span><span class="s1">string_series):</span>
        <span class="s1">data = string_series.to_json(orient=orient)</span>
        <span class="s1">result = read_json(data</span><span class="s0">, </span><span class="s1">typ=</span><span class="s2">&quot;series&quot;</span><span class="s0">, </span><span class="s1">orient=orient</span><span class="s0">, </span><span class="s1">numpy=numpy)</span>

        <span class="s1">expected = string_series</span>
        <span class="s0">if </span><span class="s1">orient </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;values&quot;</span><span class="s0">, </span><span class="s2">&quot;records&quot;</span><span class="s1">):</span>
            <span class="s1">expected = expected.reset_index(drop=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">orient != </span><span class="s2">&quot;split&quot;</span><span class="s1">:</span>
            <span class="s1">expected.name = </span><span class="s0">None</span>

        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, None</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;numpy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_series_roundtrip_object(self</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">numpy</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">object_series):</span>
        <span class="s1">data = object_series.to_json(orient=orient)</span>
        <span class="s1">result = read_json(data</span><span class="s0">, </span><span class="s1">typ=</span><span class="s2">&quot;series&quot;</span><span class="s0">, </span><span class="s1">orient=orient</span><span class="s0">, </span><span class="s1">numpy=numpy</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

        <span class="s1">expected = object_series</span>
        <span class="s0">if </span><span class="s1">orient </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;values&quot;</span><span class="s0">, </span><span class="s2">&quot;records&quot;</span><span class="s1">):</span>
            <span class="s1">expected = expected.reset_index(drop=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">orient != </span><span class="s2">&quot;split&quot;</span><span class="s1">:</span>
            <span class="s1">expected.name = </span><span class="s0">None</span>

        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;numpy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_series_roundtrip_empty(self</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">numpy):</span>
        <span class="s1">empty_series = Series([]</span><span class="s0">, </span><span class="s1">index=[]</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">data = empty_series.to_json(orient=orient)</span>
        <span class="s1">result = read_json(data</span><span class="s0">, </span><span class="s1">typ=</span><span class="s2">&quot;series&quot;</span><span class="s0">, </span><span class="s1">orient=orient</span><span class="s0">, </span><span class="s1">numpy=numpy)</span>

        <span class="s1">expected = empty_series</span>
        <span class="s0">if </span><span class="s1">orient </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;values&quot;</span><span class="s0">, </span><span class="s2">&quot;records&quot;</span><span class="s1">):</span>
            <span class="s1">expected = expected.reset_index(drop=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expected.index = expected.index.astype(float)</span>

        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;numpy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_series_roundtrip_timeseries(self</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">numpy</span><span class="s0">, </span><span class="s1">datetime_series):</span>
        <span class="s1">data = datetime_series.to_json(orient=orient)</span>
        <span class="s1">result = read_json(data</span><span class="s0">, </span><span class="s1">typ=</span><span class="s2">&quot;series&quot;</span><span class="s0">, </span><span class="s1">orient=orient</span><span class="s0">, </span><span class="s1">numpy=numpy)</span>

        <span class="s1">expected = datetime_series</span>
        <span class="s0">if </span><span class="s1">orient </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;values&quot;</span><span class="s0">, </span><span class="s2">&quot;records&quot;</span><span class="s1">):</span>
            <span class="s1">expected = expected.reset_index(drop=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">orient != </span><span class="s2">&quot;split&quot;</span><span class="s1">:</span>
            <span class="s1">expected.name = </span><span class="s0">None</span>

        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[np.float64</span><span class="s0">, </span><span class="s1">int])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;numpy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_series_roundtrip_numeric(self</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">numpy</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s1">s = Series(range(</span><span class="s3">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s0">, </span><span class="s2">&quot;f&quot;</span><span class="s1">])</span>
        <span class="s1">data = s.to_json(orient=orient)</span>
        <span class="s1">result = read_json(data</span><span class="s0">, </span><span class="s1">typ=</span><span class="s2">&quot;series&quot;</span><span class="s0">, </span><span class="s1">orient=orient</span><span class="s0">, </span><span class="s1">numpy=numpy)</span>

        <span class="s1">expected = s.copy()</span>
        <span class="s0">if </span><span class="s1">orient </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;values&quot;</span><span class="s0">, </span><span class="s2">&quot;records&quot;</span><span class="s1">):</span>
            <span class="s1">expected = expected.reset_index(drop=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_series_to_json_except(self):</span>
        <span class="s1">s = Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
        <span class="s1">msg = </span><span class="s2">&quot;Invalid value 'garbage' for option 'orient'&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s.to_json(orient=</span><span class="s2">&quot;garbage&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_series_from_json_precise_float(self):</span>
        <span class="s1">s = Series([</span><span class="s3">4.56</span><span class="s0">, </span><span class="s3">4.56</span><span class="s0">, </span><span class="s3">4.56</span><span class="s1">])</span>
        <span class="s1">result = read_json(s.to_json()</span><span class="s0">, </span><span class="s1">typ=</span><span class="s2">&quot;series&quot;</span><span class="s0">, </span><span class="s1">precise_float=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">check_index_type=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_series_with_dtype(self):</span>
        <span class="s4"># GH 21986</span>
        <span class="s1">s = Series([</span><span class="s3">4.56</span><span class="s0">, </span><span class="s3">4.56</span><span class="s0">, </span><span class="s3">4.56</span><span class="s1">])</span>
        <span class="s1">result = read_json(s.to_json()</span><span class="s0">, </span><span class="s1">typ=</span><span class="s2">&quot;series&quot;</span><span class="s0">, </span><span class="s1">dtype=np.int64)</span>
        <span class="s1">expected = Series([</span><span class="s3">4</span><span class="s1">] * </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;dtype,expected&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s0">True, </span><span class="s1">Series([</span><span class="s2">&quot;2000-01-01&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;datetime64[ns]&quot;</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s0">False, </span><span class="s1">Series([</span><span class="s3">946684800000</span><span class="s1">]))</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_series_with_dtype_datetime(self</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s1">s = Series([</span><span class="s2">&quot;2000-01-01&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;datetime64[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">data = s.to_json()</span>
        <span class="s1">result = read_json(data</span><span class="s0">, </span><span class="s1">typ=</span><span class="s2">&quot;series&quot;</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_frame_from_json_precise_float(self):</span>
        <span class="s1">df = DataFrame([[</span><span class="s3">4.56</span><span class="s0">, </span><span class="s3">4.56</span><span class="s0">, </span><span class="s3">4.56</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4.56</span><span class="s0">, </span><span class="s3">4.56</span><span class="s0">, </span><span class="s3">4.56</span><span class="s1">]])</span>
        <span class="s1">result = read_json(df.to_json()</span><span class="s0">, </span><span class="s1">precise_float=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">df)</span>

    <span class="s0">def </span><span class="s1">test_typ(self):</span>

        <span class="s1">s = Series(range(</span><span class="s3">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s0">, </span><span class="s2">&quot;f&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span>
        <span class="s1">result = read_json(s.to_json()</span><span class="s0">, </span><span class="s1">typ=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">s)</span>

    <span class="s0">def </span><span class="s1">test_reconstruction_index(self):</span>

        <span class="s1">df = DataFrame([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]])</span>
        <span class="s1">result = read_json(df.to_json())</span>

        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">df)</span>

        <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">])</span>
        <span class="s1">result = read_json(df.to_json())</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">df)</span>

    <span class="s0">def </span><span class="s1">test_path(self</span><span class="s0">, </span><span class="s1">float_frame</span><span class="s0">, </span><span class="s1">int_frame</span><span class="s0">, </span><span class="s1">datetime_frame):</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean(</span><span class="s2">&quot;test.json&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s0">for </span><span class="s1">df </span><span class="s0">in </span><span class="s1">[float_frame</span><span class="s0">, </span><span class="s1">int_frame</span><span class="s0">, </span><span class="s1">datetime_frame]:</span>
                <span class="s1">df.to_json(path)</span>
                <span class="s1">read_json(path)</span>

    <span class="s0">def </span><span class="s1">test_axis_dates(self</span><span class="s0">, </span><span class="s1">datetime_series</span><span class="s0">, </span><span class="s1">datetime_frame):</span>

        <span class="s4"># frame</span>
        <span class="s1">json = datetime_frame.to_json()</span>
        <span class="s1">result = read_json(json)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">datetime_frame)</span>

        <span class="s4"># series</span>
        <span class="s1">json = datetime_series.to_json()</span>
        <span class="s1">result = read_json(json</span><span class="s0">, </span><span class="s1">typ=</span><span class="s2">&quot;series&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">datetime_series</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">result.name </span><span class="s0">is None</span>

    <span class="s0">def </span><span class="s1">test_convert_dates(self</span><span class="s0">, </span><span class="s1">datetime_series</span><span class="s0">, </span><span class="s1">datetime_frame):</span>

        <span class="s4"># frame</span>
        <span class="s1">df = datetime_frame</span>
        <span class="s1">df[</span><span class="s2">&quot;date&quot;</span><span class="s1">] = Timestamp(</span><span class="s2">&quot;20130101&quot;</span><span class="s1">)</span>

        <span class="s1">json = df.to_json()</span>
        <span class="s1">result = read_json(json)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">df)</span>

        <span class="s1">df[</span><span class="s2">&quot;foo&quot;</span><span class="s1">] = </span><span class="s3">1.0</span>
        <span class="s1">json = df.to_json(date_unit=</span><span class="s2">&quot;ns&quot;</span><span class="s1">)</span>

        <span class="s1">result = read_json(json</span><span class="s0">, </span><span class="s1">convert_dates=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">expected = df.copy()</span>
        <span class="s1">expected[</span><span class="s2">&quot;date&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;date&quot;</span><span class="s1">].values.view(</span><span class="s2">&quot;i8&quot;</span><span class="s1">)</span>
        <span class="s1">expected[</span><span class="s2">&quot;foo&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;foo&quot;</span><span class="s1">].astype(</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># series</span>
        <span class="s1">ts = Series(Timestamp(</span><span class="s2">&quot;20130101&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index=datetime_series.index)</span>
        <span class="s1">json = ts.to_json()</span>
        <span class="s1">result = read_json(json</span><span class="s0">, </span><span class="s1">typ=</span><span class="s2">&quot;series&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">ts)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;date_format&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;epoch&quot;</span><span class="s0">, </span><span class="s2">&quot;iso&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;as_object&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;date_typ&quot;</span><span class="s0">, </span><span class="s1">[datetime.date</span><span class="s0">, </span><span class="s1">datetime.datetime</span><span class="s0">, </span><span class="s1">Timestamp])</span>
    <span class="s0">def </span><span class="s1">test_date_index_and_values(self</span><span class="s0">, </span><span class="s1">date_format</span><span class="s0">, </span><span class="s1">as_object</span><span class="s0">, </span><span class="s1">date_typ):</span>
        <span class="s1">data = [date_typ(year=</span><span class="s3">2020</span><span class="s0">, </span><span class="s1">month=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">day=</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.NaT]</span>
        <span class="s0">if </span><span class="s1">as_object:</span>
            <span class="s1">data.append(</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>

        <span class="s1">ser = Series(data</span><span class="s0">, </span><span class="s1">index=data)</span>
        <span class="s1">result = ser.to_json(date_format=date_format)</span>

        <span class="s0">if </span><span class="s1">date_format == </span><span class="s2">&quot;epoch&quot;</span><span class="s1">:</span>
            <span class="s1">expected = </span><span class="s2">'{&quot;1577836800000&quot;:1577836800000,&quot;null&quot;:null}'</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expected = (</span>
                <span class="s2">'{&quot;2020-01-01T00:00:00.000Z&quot;:&quot;2020-01-01T00:00:00.000Z&quot;,&quot;null&quot;:null}'</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">as_object:</span>
            <span class="s1">expected = expected.replace(</span><span class="s2">&quot;}&quot;</span><span class="s0">, </span><span class="s2">',&quot;a&quot;:&quot;a&quot;}'</span><span class="s1">)</span>

        <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;infer_word&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s2">&quot;trade_time&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;date&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;datetime&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;sold_at&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;modified&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;timestamp&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;timestamps&quot;</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_convert_dates_infer(self</span><span class="s0">, </span><span class="s1">infer_word):</span>
        <span class="s4"># GH10747</span>
        <span class="s0">from </span><span class="s1">pandas.io.json </span><span class="s0">import </span><span class="s1">dumps</span>

        <span class="s1">data = [{</span><span class="s2">&quot;id&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s1">infer_word: </span><span class="s3">1036713600000</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;id&quot;</span><span class="s1">: </span><span class="s3">2</span><span class="s1">}]</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s1">Timestamp(</span><span class="s2">&quot;2002-11-08&quot;</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s1">pd.NaT]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;id&quot;</span><span class="s0">, </span><span class="s1">infer_word]</span>
        <span class="s1">)</span>
        <span class="s1">result = read_json(dumps(data))[[</span><span class="s2">&quot;id&quot;</span><span class="s0">, </span><span class="s1">infer_word]]</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;date,date_unit&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s2">&quot;20130101 20:43:42.123&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;20130101 20:43:42&quot;</span><span class="s0">, </span><span class="s2">&quot;s&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;20130101 20:43:42.123&quot;</span><span class="s0">, </span><span class="s2">&quot;ms&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;20130101 20:43:42.123456&quot;</span><span class="s0">, </span><span class="s2">&quot;us&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;20130101 20:43:42.123456789&quot;</span><span class="s0">, </span><span class="s2">&quot;ns&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_date_format_frame(self</span><span class="s0">, </span><span class="s1">date</span><span class="s0">, </span><span class="s1">date_unit</span><span class="s0">, </span><span class="s1">datetime_frame):</span>
        <span class="s1">df = datetime_frame</span>

        <span class="s1">df[</span><span class="s2">&quot;date&quot;</span><span class="s1">] = Timestamp(date)</span>
        <span class="s1">df.iloc[</span><span class="s3">1</span><span class="s0">, </span><span class="s1">df.columns.get_loc(</span><span class="s2">&quot;date&quot;</span><span class="s1">)] = pd.NaT</span>
        <span class="s1">df.iloc[</span><span class="s3">5</span><span class="s0">, </span><span class="s1">df.columns.get_loc(</span><span class="s2">&quot;date&quot;</span><span class="s1">)] = pd.NaT</span>
        <span class="s0">if </span><span class="s1">date_unit:</span>
            <span class="s1">json = df.to_json(date_format=</span><span class="s2">&quot;iso&quot;</span><span class="s0">, </span><span class="s1">date_unit=date_unit)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">json = df.to_json(date_format=</span><span class="s2">&quot;iso&quot;</span><span class="s1">)</span>
        <span class="s1">result = read_json(json)</span>
        <span class="s1">expected = df.copy()</span>
        <span class="s1">expected.index = expected.index.tz_localize(</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)</span>
        <span class="s1">expected[</span><span class="s2">&quot;date&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;date&quot;</span><span class="s1">].dt.tz_localize(</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_date_format_frame_raises(self</span><span class="s0">, </span><span class="s1">datetime_frame):</span>
        <span class="s1">df = datetime_frame</span>
        <span class="s1">msg = </span><span class="s2">&quot;Invalid value 'foo' for option 'date_unit'&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">df.to_json(date_format=</span><span class="s2">&quot;iso&quot;</span><span class="s0">, </span><span class="s1">date_unit=</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;date,date_unit&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s2">&quot;20130101 20:43:42.123&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;20130101 20:43:42&quot;</span><span class="s0">, </span><span class="s2">&quot;s&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;20130101 20:43:42.123&quot;</span><span class="s0">, </span><span class="s2">&quot;ms&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;20130101 20:43:42.123456&quot;</span><span class="s0">, </span><span class="s2">&quot;us&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;20130101 20:43:42.123456789&quot;</span><span class="s0">, </span><span class="s2">&quot;ns&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_date_format_series(self</span><span class="s0">, </span><span class="s1">date</span><span class="s0">, </span><span class="s1">date_unit</span><span class="s0">, </span><span class="s1">datetime_series):</span>
        <span class="s1">ts = Series(Timestamp(date)</span><span class="s0">, </span><span class="s1">index=datetime_series.index)</span>
        <span class="s1">ts.iloc[</span><span class="s3">1</span><span class="s1">] = pd.NaT</span>
        <span class="s1">ts.iloc[</span><span class="s3">5</span><span class="s1">] = pd.NaT</span>
        <span class="s0">if </span><span class="s1">date_unit:</span>
            <span class="s1">json = ts.to_json(date_format=</span><span class="s2">&quot;iso&quot;</span><span class="s0">, </span><span class="s1">date_unit=date_unit)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">json = ts.to_json(date_format=</span><span class="s2">&quot;iso&quot;</span><span class="s1">)</span>
        <span class="s1">result = read_json(json</span><span class="s0">, </span><span class="s1">typ=</span><span class="s2">&quot;series&quot;</span><span class="s1">)</span>
        <span class="s1">expected = ts.copy()</span>
        <span class="s1">expected.index = expected.index.tz_localize(</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)</span>
        <span class="s1">expected = expected.dt.tz_localize(</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_date_format_series_raises(self</span><span class="s0">, </span><span class="s1">datetime_series):</span>
        <span class="s1">ts = Series(Timestamp(</span><span class="s2">&quot;20130101 20:43:42.123&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index=datetime_series.index)</span>
        <span class="s1">msg = </span><span class="s2">&quot;Invalid value 'foo' for option 'date_unit'&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">ts.to_json(date_format=</span><span class="s2">&quot;iso&quot;</span><span class="s0">, </span><span class="s1">date_unit=</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;unit&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;s&quot;</span><span class="s0">, </span><span class="s2">&quot;ms&quot;</span><span class="s0">, </span><span class="s2">&quot;us&quot;</span><span class="s0">, </span><span class="s2">&quot;ns&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_date_unit(self</span><span class="s0">, </span><span class="s1">unit</span><span class="s0">, </span><span class="s1">datetime_frame):</span>
        <span class="s1">df = datetime_frame</span>
        <span class="s1">df[</span><span class="s2">&quot;date&quot;</span><span class="s1">] = Timestamp(</span><span class="s2">&quot;20130101 20:43:42&quot;</span><span class="s1">)</span>
        <span class="s1">dl = df.columns.get_loc(</span><span class="s2">&quot;date&quot;</span><span class="s1">)</span>
        <span class="s1">df.iloc[</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dl] = Timestamp(</span><span class="s2">&quot;19710101 20:43:42&quot;</span><span class="s1">)</span>
        <span class="s1">df.iloc[</span><span class="s3">2</span><span class="s0">, </span><span class="s1">dl] = Timestamp(</span><span class="s2">&quot;21460101 20:43:42&quot;</span><span class="s1">)</span>
        <span class="s1">df.iloc[</span><span class="s3">4</span><span class="s0">, </span><span class="s1">dl] = pd.NaT</span>

        <span class="s1">json = df.to_json(date_format=</span><span class="s2">&quot;epoch&quot;</span><span class="s0">, </span><span class="s1">date_unit=unit)</span>

        <span class="s4"># force date unit</span>
        <span class="s1">result = read_json(json</span><span class="s0">, </span><span class="s1">date_unit=unit)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">df)</span>

        <span class="s4"># detect date unit</span>
        <span class="s1">result = read_json(json</span><span class="s0">, </span><span class="s1">date_unit=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">df)</span>

    <span class="s0">def </span><span class="s1">test_weird_nested_json(self):</span>
        <span class="s4"># this used to core dump the parser</span>
        <span class="s1">s = </span><span class="s2">r&quot;&quot;&quot;{ 
        &quot;status&quot;: &quot;success&quot;, 
        &quot;data&quot;: { 
        &quot;posts&quot;: [ 
            { 
            &quot;id&quot;: 1, 
            &quot;title&quot;: &quot;A blog post&quot;, 
            &quot;body&quot;: &quot;Some useful content&quot; 
            }, 
            { 
            &quot;id&quot;: 2, 
            &quot;title&quot;: &quot;Another blog post&quot;, 
            &quot;body&quot;: &quot;More content&quot; 
            } 
           ] 
          } 
        }&quot;&quot;&quot;</span>

        <span class="s1">read_json(s)</span>

    <span class="s0">def </span><span class="s1">test_doc_example(self):</span>
        <span class="s1">dfj2 = DataFrame(np.random.randn(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">columns=list(</span><span class="s2">&quot;AB&quot;</span><span class="s1">))</span>
        <span class="s1">dfj2[</span><span class="s2">&quot;date&quot;</span><span class="s1">] = Timestamp(</span><span class="s2">&quot;20130101&quot;</span><span class="s1">)</span>
        <span class="s1">dfj2[</span><span class="s2">&quot;ints&quot;</span><span class="s1">] = range(</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">dfj2[</span><span class="s2">&quot;bools&quot;</span><span class="s1">] = </span><span class="s0">True</span>
        <span class="s1">dfj2.index = pd.date_range(</span><span class="s2">&quot;20130101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">5</span><span class="s1">)</span>

        <span class="s1">json = dfj2.to_json()</span>
        <span class="s1">result = read_json(json</span><span class="s0">, </span><span class="s1">dtype={</span><span class="s2">&quot;ints&quot;</span><span class="s1">: np.int64</span><span class="s0">, </span><span class="s2">&quot;bools&quot;</span><span class="s1">: np.bool_})</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">result)</span>

    <span class="s0">def </span><span class="s1">test_misc_example(self):</span>

        <span class="s4"># parsing unordered input fails</span>
        <span class="s1">result = read_json(</span><span class="s2">'[{&quot;a&quot;: 1, &quot;b&quot;: 2}, {&quot;b&quot;:2, &quot;a&quot; :1}]'</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected = DataFrame([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>

        <span class="s1">error_msg = </span><span class="s2">&quot;&quot;&quot;DataFrame</span><span class="s0">\\</span><span class="s2">.index are different 
 
DataFrame</span><span class="s0">\\</span><span class="s2">.index values are different </span><span class="s0">\\</span><span class="s2">(100</span><span class="s0">\\</span><span class="s2">.0 %</span><span class="s0">\\</span><span class="s2">) 
</span><span class="s0">\\</span><span class="s2">[left</span><span class="s0">\\</span><span class="s2">]:  Index</span><span class="s0">\\</span><span class="s2">(</span><span class="s0">\\</span><span class="s2">['a', 'b'</span><span class="s0">\\</span><span class="s2">], dtype='object'</span><span class="s0">\\</span><span class="s2">) 
</span><span class="s0">\\</span><span class="s2">[right</span><span class="s0">\\</span><span class="s2">]: RangeIndex</span><span class="s0">\\</span><span class="s2">(start=0, stop=2, step=1</span><span class="s0">\\</span><span class="s2">)&quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError</span><span class="s0">, </span><span class="s1">match=error_msg):</span>
            <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_index_type=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">result = read_json(</span><span class="s2">'[{&quot;a&quot;: 1, &quot;b&quot;: 2}, {&quot;b&quot;:2, &quot;a&quot; :1}]'</span><span class="s1">)</span>
        <span class="s1">expected = DataFrame([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@tm.network</span>
    <span class="s1">@pytest.mark.single</span>
    <span class="s0">def </span><span class="s1">test_round_trip_exception_(self):</span>
        <span class="s4"># GH 3867</span>
        <span class="s1">csv = </span><span class="s2">&quot;https://raw.github.com/hayd/lahman2012/master/csvs/Teams.csv&quot;</span>
        <span class="s1">df = pd.read_csv(csv)</span>
        <span class="s1">s = df.to_json()</span>
        <span class="s1">result = read_json(s)</span>
        <span class="s1">tm.assert_frame_equal(result.reindex(index=df.index</span><span class="s0">, </span><span class="s1">columns=df.columns)</span><span class="s0">, </span><span class="s1">df)</span>

    <span class="s1">@tm.network</span>
    <span class="s1">@pytest.mark.single</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;field,dtype&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s2">&quot;created_at&quot;</span><span class="s0">, </span><span class="s1">pd.DatetimeTZDtype(tz=</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">&quot;closed_at&quot;</span><span class="s0">, </span><span class="s2">&quot;datetime64[ns]&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">&quot;updated_at&quot;</span><span class="s0">, </span><span class="s1">pd.DatetimeTZDtype(tz=</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)]</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_url(self</span><span class="s0">, </span><span class="s1">field</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s1">url = </span><span class="s2">&quot;https://api.github.com/repos/pandas-dev/pandas/issues?per_page=5&quot;</span>
        <span class="s1">result = read_json(url</span><span class="s0">, </span><span class="s1">convert_dates=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">result[field].dtype == dtype</span>

    <span class="s0">def </span><span class="s1">test_timedelta(self):</span>
        <span class="s1">converter = </span><span class="s0">lambda </span><span class="s1">x: pd.to_timedelta(x</span><span class="s0">, </span><span class="s1">unit=</span><span class="s2">&quot;ms&quot;</span><span class="s1">)</span>

        <span class="s1">s = Series([timedelta(</span><span class="s3">23</span><span class="s1">)</span><span class="s0">, </span><span class="s1">timedelta(seconds=</span><span class="s3">5</span><span class="s1">)])</span>
        <span class="s0">assert </span><span class="s1">s.dtype == </span><span class="s2">&quot;timedelta64[ns]&quot;</span>

        <span class="s1">result = read_json(s.to_json()</span><span class="s0">, </span><span class="s1">typ=</span><span class="s2">&quot;series&quot;</span><span class="s1">).apply(converter)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">s)</span>

        <span class="s1">s = Series([timedelta(</span><span class="s3">23</span><span class="s1">)</span><span class="s0">, </span><span class="s1">timedelta(seconds=</span><span class="s3">5</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">index=pd.Index([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]))</span>
        <span class="s0">assert </span><span class="s1">s.dtype == </span><span class="s2">&quot;timedelta64[ns]&quot;</span>
        <span class="s1">result = read_json(s.to_json()</span><span class="s0">, </span><span class="s1">typ=</span><span class="s2">&quot;series&quot;</span><span class="s1">).apply(converter)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">s)</span>

        <span class="s1">frame = DataFrame([timedelta(</span><span class="s3">23</span><span class="s1">)</span><span class="s0">, </span><span class="s1">timedelta(seconds=</span><span class="s3">5</span><span class="s1">)])</span>
        <span class="s0">assert </span><span class="s1">frame[</span><span class="s3">0</span><span class="s1">].dtype == </span><span class="s2">&quot;timedelta64[ns]&quot;</span>
        <span class="s1">tm.assert_frame_equal(frame</span><span class="s0">, </span><span class="s1">read_json(frame.to_json()).apply(converter))</span>

        <span class="s1">frame = DataFrame(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;a&quot;</span><span class="s1">: [timedelta(days=</span><span class="s3">23</span><span class="s1">)</span><span class="s0">, </span><span class="s1">timedelta(seconds=</span><span class="s3">5</span><span class="s1">)]</span><span class="s0">,</span>
                <span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;c&quot;</span><span class="s1">: pd.date_range(start=</span><span class="s2">&quot;20130101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

        <span class="s1">result = read_json(frame.to_json(date_unit=</span><span class="s2">&quot;ns&quot;</span><span class="s1">))</span>
        <span class="s1">result[</span><span class="s2">&quot;a&quot;</span><span class="s1">] = pd.to_timedelta(result.a</span><span class="s0">, </span><span class="s1">unit=</span><span class="s2">&quot;ns&quot;</span><span class="s1">)</span>
        <span class="s1">result[</span><span class="s2">&quot;c&quot;</span><span class="s1">] = pd.to_datetime(result.c)</span>
        <span class="s1">tm.assert_frame_equal(frame</span><span class="s0">, </span><span class="s1">result)</span>

    <span class="s0">def </span><span class="s1">test_mixed_timedelta_datetime(self):</span>
        <span class="s1">frame = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [timedelta(</span><span class="s3">23</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Timestamp(</span><span class="s2">&quot;20130101&quot;</span><span class="s1">)]}</span><span class="s0">, </span><span class="s1">dtype=object)</span>

        <span class="s1">expected = DataFrame(</span>
            <span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: [pd.Timedelta(frame.a[</span><span class="s3">0</span><span class="s1">]).value</span><span class="s0">, </span><span class="s1">Timestamp(frame.a[</span><span class="s3">1</span><span class="s1">]).value]}</span>
        <span class="s1">)</span>
        <span class="s1">result = read_json(frame.to_json(date_unit=</span><span class="s2">&quot;ns&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype={</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s2">&quot;int64&quot;</span><span class="s1">})</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_index_type=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;as_object&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;date_format&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;iso&quot;</span><span class="s0">, </span><span class="s2">&quot;epoch&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;timedelta_typ&quot;</span><span class="s0">, </span><span class="s1">[pd.Timedelta</span><span class="s0">, </span><span class="s1">timedelta])</span>
    <span class="s0">def </span><span class="s1">test_timedelta_to_json(self</span><span class="s0">, </span><span class="s1">as_object</span><span class="s0">, </span><span class="s1">date_format</span><span class="s0">, </span><span class="s1">timedelta_typ):</span>
        <span class="s4"># GH28156: to_json not correctly formatting Timedelta</span>
        <span class="s1">data = [timedelta_typ(days=</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">timedelta_typ(days=</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.NaT]</span>
        <span class="s0">if </span><span class="s1">as_object:</span>
            <span class="s1">data.append(</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>

        <span class="s1">ser = Series(data</span><span class="s0">, </span><span class="s1">index=data)</span>
        <span class="s0">if </span><span class="s1">date_format == </span><span class="s2">&quot;iso&quot;</span><span class="s1">:</span>
            <span class="s1">expected = (</span>
                <span class="s2">'{&quot;P1DT0H0M0S&quot;:&quot;P1DT0H0M0S&quot;,&quot;P2DT0H0M0S&quot;:&quot;P2DT0H0M0S&quot;,&quot;null&quot;:null}'</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expected = </span><span class="s2">'{&quot;86400000&quot;:86400000,&quot;172800000&quot;:172800000,&quot;null&quot;:null}'</span>

        <span class="s0">if </span><span class="s1">as_object:</span>
            <span class="s1">expected = expected.replace(</span><span class="s2">&quot;}&quot;</span><span class="s0">, </span><span class="s2">',&quot;a&quot;:&quot;a&quot;}'</span><span class="s1">)</span>

        <span class="s1">result = ser.to_json(date_format=date_format)</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s0">def </span><span class="s1">test_default_handler(self):</span>
        <span class="s1">value = object()</span>
        <span class="s1">frame = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">7</span><span class="s0">, </span><span class="s1">value]})</span>
        <span class="s1">expected = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">7</span><span class="s0">, </span><span class="s1">str(value)]})</span>
        <span class="s1">result = read_json(frame.to_json(default_handler=str))</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">check_index_type=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_default_handler_indirect(self):</span>
        <span class="s0">from </span><span class="s1">pandas.io.json </span><span class="s0">import </span><span class="s1">dumps</span>

        <span class="s0">def </span><span class="s1">default(obj):</span>
            <span class="s0">if </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">complex):</span>
                <span class="s0">return </span><span class="s1">[(</span><span class="s2">&quot;mathjs&quot;</span><span class="s0">, </span><span class="s2">&quot;Complex&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;re&quot;</span><span class="s0">, </span><span class="s1">obj.real)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;im&quot;</span><span class="s0">, </span><span class="s1">obj.imag)]</span>
            <span class="s0">return </span><span class="s1">str(obj)</span>

        <span class="s1">df_list = [</span>
            <span class="s3">9</span><span class="s0">,</span>
            <span class="s1">DataFrame(</span>
                <span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;STR&quot;</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">4</span><span class="s0">, </span><span class="s1">-</span><span class="s3">5</span><span class="s1">)]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [float(</span><span class="s2">&quot;nan&quot;</span><span class="s1">)</span><span class="s0">, None, </span><span class="s2">&quot;N/A&quot;</span><span class="s1">]}</span><span class="s0">,</span>
                <span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span>
        <span class="s1">expected = (</span>
            <span class="s2">'[9,[[1,null],[&quot;STR&quot;,null],[[[&quot;mathjs&quot;,&quot;Complex&quot;],'</span>
            <span class="s2">'[&quot;re&quot;,4.0],[&quot;im&quot;,-5.0]],&quot;N</span><span class="s0">\\</span><span class="s2">/A&quot;]]]'</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">dumps(df_list</span><span class="s0">, </span><span class="s1">default_handler=default</span><span class="s0">, </span><span class="s1">orient=</span><span class="s2">&quot;values&quot;</span><span class="s1">) == expected</span>

    <span class="s0">def </span><span class="s1">test_default_handler_numpy_unsupported_dtype(self):</span>
        <span class="s4"># GH12554 to_json raises 'Unhandled numpy dtype 15'</span>
        <span class="s1">df = DataFrame(</span>
            <span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2.3</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">4</span><span class="s0">, </span><span class="s1">-</span><span class="s3">5</span><span class="s1">)]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [float(</span><span class="s2">&quot;nan&quot;</span><span class="s1">)</span><span class="s0">, None, </span><span class="s1">complex(</span><span class="s3">1.2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)]}</span><span class="s0">,</span>
            <span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">expected = (</span>
            <span class="s2">'[[&quot;(1+0j)&quot;,&quot;(nan+0j)&quot;],'</span>
            <span class="s2">'[&quot;(2.3+0j)&quot;,&quot;(nan+0j)&quot;],'</span>
            <span class="s2">'[&quot;(4-5j)&quot;,&quot;(1.2+0j)&quot;]]'</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">df.to_json(default_handler=str</span><span class="s0">, </span><span class="s1">orient=</span><span class="s2">&quot;values&quot;</span><span class="s1">) == expected</span>

    <span class="s0">def </span><span class="s1">test_default_handler_raises(self):</span>
        <span class="s1">msg = </span><span class="s2">&quot;raisin&quot;</span>

        <span class="s0">def </span><span class="s1">my_handler_raises(obj):</span>
            <span class="s0">raise </span><span class="s1">TypeError(msg)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">object()]}).to_json(</span>
                <span class="s1">default_handler=my_handler_raises</span>
            <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">4</span><span class="s0">, </span><span class="s1">-</span><span class="s3">5</span><span class="s1">)]}).to_json(</span>
                <span class="s1">default_handler=my_handler_raises</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_categorical(self):</span>
        <span class="s4"># GH4377 df.to_json segfaults with non-ndarray blocks</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s1">]})</span>
        <span class="s1">df[</span><span class="s2">&quot;B&quot;</span><span class="s1">] = df[</span><span class="s2">&quot;A&quot;</span><span class="s1">]</span>
        <span class="s1">expected = df.to_json()</span>

        <span class="s1">df[</span><span class="s2">&quot;B&quot;</span><span class="s1">] = df[</span><span class="s2">&quot;A&quot;</span><span class="s1">].astype(</span><span class="s2">&quot;category&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">expected == df.to_json()</span>

        <span class="s1">s = df[</span><span class="s2">&quot;A&quot;</span><span class="s1">]</span>
        <span class="s1">sc = df[</span><span class="s2">&quot;B&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">s.to_json() == sc.to_json()</span>

    <span class="s0">def </span><span class="s1">test_datetime_tz(self):</span>
        <span class="s4"># GH4377 df.to_json segfaults with non-ndarray blocks</span>
        <span class="s1">tz_range = pd.date_range(</span><span class="s2">&quot;20130101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s1">tz_naive = tz_range.tz_convert(</span><span class="s2">&quot;utc&quot;</span><span class="s1">).tz_localize(</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s1">df = DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: tz_range</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: pd.date_range(</span><span class="s2">&quot;20130101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">3</span><span class="s1">)})</span>

        <span class="s1">df_naive = df.copy()</span>
        <span class="s1">df_naive[</span><span class="s2">&quot;A&quot;</span><span class="s1">] = tz_naive</span>
        <span class="s1">expected = df_naive.to_json()</span>
        <span class="s0">assert </span><span class="s1">expected == df.to_json()</span>

        <span class="s1">stz = Series(tz_range)</span>
        <span class="s1">s_naive = Series(tz_naive)</span>
        <span class="s0">assert </span><span class="s1">stz.to_json() == s_naive.to_json()</span>

    <span class="s0">def </span><span class="s1">test_sparse(self):</span>
        <span class="s4"># GH4377 df.to_json segfaults with non-ndarray blocks</span>
        <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))</span>
        <span class="s1">df.loc[:</span><span class="s3">8</span><span class="s1">] = np.nan</span>

        <span class="s1">sdf = df.astype(</span><span class="s2">&quot;Sparse&quot;</span><span class="s1">)</span>
        <span class="s1">expected = df.to_json()</span>
        <span class="s0">assert </span><span class="s1">expected == sdf.to_json()</span>

        <span class="s1">s = Series(np.random.randn(</span><span class="s3">10</span><span class="s1">))</span>
        <span class="s1">s.loc[:</span><span class="s3">8</span><span class="s1">] = np.nan</span>
        <span class="s1">ss = s.astype(</span><span class="s2">&quot;Sparse&quot;</span><span class="s1">)</span>

        <span class="s1">expected = s.to_json()</span>
        <span class="s0">assert </span><span class="s1">expected == ss.to_json()</span>

    <span class="s1">@pytest.mark.skipif(PY310</span><span class="s0">, </span><span class="s1">reason=</span><span class="s2">&quot;segfault GH 42130&quot;</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;ts&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">Timestamp(</span><span class="s2">&quot;2013-01-10 05:00:00Z&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Timestamp(</span><span class="s2">&quot;2013-01-10 00:00:00&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Timestamp(</span><span class="s2">&quot;2013-01-10 00:00:00-0500&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_tz_is_utc(self</span><span class="s0">, </span><span class="s1">ts):</span>
        <span class="s0">from </span><span class="s1">pandas.io.json </span><span class="s0">import </span><span class="s1">dumps</span>

        <span class="s1">exp = </span><span class="s2">'&quot;2013-01-10T05:00:00.000Z&quot;'</span>

        <span class="s0">assert </span><span class="s1">dumps(ts</span><span class="s0">, </span><span class="s1">iso_dates=</span><span class="s0">True</span><span class="s1">) == exp</span>
        <span class="s1">dt = ts.to_pydatetime()</span>
        <span class="s0">assert </span><span class="s1">dumps(dt</span><span class="s0">, </span><span class="s1">iso_dates=</span><span class="s0">True</span><span class="s1">) == exp</span>

    <span class="s1">@pytest.mark.skipif(PY310</span><span class="s0">, </span><span class="s1">reason=</span><span class="s2">&quot;segfault GH 42130&quot;</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;tz_range&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">pd.date_range(</span><span class="s2">&quot;2013-01-01 05:00:00Z&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">pd.date_range(</span><span class="s2">&quot;2013-01-01 00:00:00&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">pd.date_range(</span><span class="s2">&quot;2013-01-01 00:00:00-0500&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_tz_range_is_utc(self</span><span class="s0">, </span><span class="s1">tz_range):</span>
        <span class="s0">from </span><span class="s1">pandas.io.json </span><span class="s0">import </span><span class="s1">dumps</span>

        <span class="s1">exp = </span><span class="s2">'[&quot;2013-01-01T05:00:00.000Z&quot;,&quot;2013-01-02T05:00:00.000Z&quot;]'</span>
        <span class="s1">dfexp = (</span>
            <span class="s2">'{&quot;DT&quot;:{'</span>
            <span class="s2">'&quot;0&quot;:&quot;2013-01-01T05:00:00.000Z&quot;,'</span>
            <span class="s2">'&quot;1&quot;:&quot;2013-01-02T05:00:00.000Z&quot;}}'</span>
        <span class="s1">)</span>

        <span class="s0">assert </span><span class="s1">dumps(tz_range</span><span class="s0">, </span><span class="s1">iso_dates=</span><span class="s0">True</span><span class="s1">) == exp</span>
        <span class="s1">dti = DatetimeIndex(tz_range)</span>
        <span class="s0">assert </span><span class="s1">dumps(dti</span><span class="s0">, </span><span class="s1">iso_dates=</span><span class="s0">True</span><span class="s1">) == exp</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;DT&quot;</span><span class="s1">: dti})</span>
        <span class="s1">result = dumps(df</span><span class="s0">, </span><span class="s1">iso_dates=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">result == dfexp</span>

    <span class="s0">def </span><span class="s1">test_read_inline_jsonl(self):</span>
        <span class="s4"># GH9180</span>
        <span class="s1">result = read_json(</span><span class="s2">'{&quot;a&quot;: 1, &quot;b&quot;: 2}</span><span class="s0">\n</span><span class="s2">{&quot;b&quot;:2, &quot;a&quot; :1}</span><span class="s0">\n</span><span class="s2">'</span><span class="s0">, </span><span class="s1">lines=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected = DataFrame([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@td.skip_if_not_us_locale</span>
    <span class="s0">def </span><span class="s1">test_read_s3_jsonl(self</span><span class="s0">, </span><span class="s1">s3_resource</span><span class="s0">, </span><span class="s1">s3so):</span>
        <span class="s4"># GH17200</span>

        <span class="s1">result = read_json(</span>
            <span class="s2">&quot;s3n://pandas-test/items.jsonl&quot;</span><span class="s0">, </span><span class="s1">lines=</span><span class="s0">True, </span><span class="s1">storage_options=s3so</span>
        <span class="s1">)</span>
        <span class="s1">expected = DataFrame([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_read_local_jsonl(self):</span>
        <span class="s4"># GH17200</span>
        <span class="s0">with </span><span class="s1">tm.ensure_clean(</span><span class="s2">&quot;tmp_items.json&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">path:</span>
            <span class="s0">with </span><span class="s1">open(path</span><span class="s0">, </span><span class="s2">&quot;w&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">infile:</span>
                <span class="s1">infile.write(</span><span class="s2">'{&quot;a&quot;: 1, &quot;b&quot;: 2}</span><span class="s0">\n</span><span class="s2">{&quot;b&quot;:2, &quot;a&quot; :1}</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">)</span>
            <span class="s1">result = read_json(path</span><span class="s0">, </span><span class="s1">lines=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">expected = DataFrame([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>
            <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_read_jsonl_unicode_chars(self):</span>
        <span class="s4"># GH15132: non-ascii unicode characters</span>
        <span class="s4"># \u201d == RIGHT DOUBLE QUOTATION MARK</span>

        <span class="s4"># simulate file handle</span>
        <span class="s1">json = </span><span class="s2">'{&quot;a&quot;: &quot;foo”&quot;, &quot;b&quot;: &quot;bar&quot;}</span><span class="s0">\n</span><span class="s2">{&quot;a&quot;: &quot;foo&quot;, &quot;b&quot;: &quot;bar&quot;}</span><span class="s0">\n</span><span class="s2">'</span>
        <span class="s1">json = StringIO(json)</span>
        <span class="s1">result = read_json(json</span><span class="s0">, </span><span class="s1">lines=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected = DataFrame([[</span><span class="s2">&quot;foo</span><span class="s0">\u201d</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># simulate string</span>
        <span class="s1">json = </span><span class="s2">'{&quot;a&quot;: &quot;foo”&quot;, &quot;b&quot;: &quot;bar&quot;}</span><span class="s0">\n</span><span class="s2">{&quot;a&quot;: &quot;foo&quot;, &quot;b&quot;: &quot;bar&quot;}</span><span class="s0">\n</span><span class="s2">'</span>
        <span class="s1">result = read_json(json</span><span class="s0">, </span><span class="s1">lines=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected = DataFrame([[</span><span class="s2">&quot;foo</span><span class="s0">\u201d</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;bigNum&quot;</span><span class="s0">, </span><span class="s1">[sys.maxsize + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-(sys.maxsize + </span><span class="s3">2</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test_to_json_large_numbers(self</span><span class="s0">, </span><span class="s1">bigNum):</span>
        <span class="s4"># GH34473</span>
        <span class="s1">series = Series(bigNum</span><span class="s0">, </span><span class="s1">dtype=object</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;articleId&quot;</span><span class="s1">])</span>
        <span class="s1">json = series.to_json()</span>
        <span class="s1">expected = </span><span class="s2">'{&quot;articleId&quot;:' </span><span class="s1">+ str(bigNum) + </span><span class="s2">&quot;}&quot;</span>
        <span class="s0">assert </span><span class="s1">json == expected</span>

        <span class="s1">df = DataFrame(bigNum</span><span class="s0">, </span><span class="s1">dtype=object</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;articleId&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">json = df.to_json()</span>
        <span class="s1">expected = </span><span class="s2">'{&quot;0&quot;:{&quot;articleId&quot;:' </span><span class="s1">+ str(bigNum) + </span><span class="s2">&quot;}}&quot;</span>
        <span class="s0">assert </span><span class="s1">json == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;bigNum&quot;</span><span class="s0">, </span><span class="s1">[-(</span><span class="s3">2 </span><span class="s1">** </span><span class="s3">63</span><span class="s1">) - </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">** </span><span class="s3">64</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_read_json_large_numbers(self</span><span class="s0">, </span><span class="s1">bigNum):</span>
        <span class="s4"># GH20599, 26068</span>
        <span class="s1">json = StringIO(</span><span class="s2">'{&quot;articleId&quot;:' </span><span class="s1">+ str(bigNum) + </span><span class="s2">&quot;}&quot;</span><span class="s1">)</span>
        <span class="s1">msg = </span><span class="s2">r&quot;Value is too small|Value is too big&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">read_json(json)</span>

        <span class="s1">json = StringIO(</span><span class="s2">'{&quot;0&quot;:{&quot;articleId&quot;:' </span><span class="s1">+ str(bigNum) + </span><span class="s2">&quot;}}&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">read_json(json)</span>

    <span class="s0">def </span><span class="s1">test_read_json_large_numbers2(self):</span>
        <span class="s4"># GH18842</span>
        <span class="s1">json = </span><span class="s2">'{&quot;articleId&quot;: &quot;1404366058080022500245&quot;}'</span>
        <span class="s1">json = StringIO(json)</span>
        <span class="s1">result = read_json(json</span><span class="s0">, </span><span class="s1">typ=</span><span class="s2">&quot;series&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series(</span><span class="s3">1.404366e21</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;articleId&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">json = </span><span class="s2">'{&quot;0&quot;: {&quot;articleId&quot;: &quot;1404366058080022500245&quot;}}'</span>
        <span class="s1">json = StringIO(json)</span>
        <span class="s1">result = read_json(json)</span>
        <span class="s1">expected = DataFrame(</span><span class="s3">1.404366e21</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;articleId&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_to_jsonl(self):</span>
        <span class="s4"># GH9180</span>
        <span class="s1">df = DataFrame([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>
        <span class="s1">result = df.to_json(orient=</span><span class="s2">&quot;records&quot;</span><span class="s0">, </span><span class="s1">lines=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected = </span><span class="s2">'{&quot;a&quot;:1,&quot;b&quot;:2}</span><span class="s0">\n</span><span class="s2">{&quot;a&quot;:1,&quot;b&quot;:2}</span><span class="s0">\n</span><span class="s2">'</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>

        <span class="s1">df = DataFrame([[</span><span class="s2">&quot;foo}&quot;</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'foo&quot;'</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>
        <span class="s1">result = df.to_json(orient=</span><span class="s2">&quot;records&quot;</span><span class="s0">, </span><span class="s1">lines=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected = </span><span class="s2">'{&quot;a&quot;:&quot;foo}&quot;,&quot;b&quot;:&quot;bar&quot;}</span><span class="s0">\n</span><span class="s2">{&quot;a&quot;:&quot;foo</span><span class="s0">\\</span><span class="s2">&quot;&quot;,&quot;b&quot;:&quot;bar&quot;}</span><span class="s0">\n</span><span class="s2">'</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>
        <span class="s1">tm.assert_frame_equal(read_json(result</span><span class="s0">, </span><span class="s1">lines=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">df)</span>

        <span class="s4"># GH15096: escaped characters in columns and data</span>
        <span class="s1">df = DataFrame([[</span><span class="s2">&quot;foo</span><span class="s0">\\</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'foo&quot;'</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a</span><span class="s0">\\</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>
        <span class="s1">result = df.to_json(orient=</span><span class="s2">&quot;records&quot;</span><span class="s0">, </span><span class="s1">lines=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected = </span><span class="s2">'{&quot;a</span><span class="s0">\\\\</span><span class="s2">&quot;:&quot;foo</span><span class="s0">\\\\</span><span class="s2">&quot;,&quot;b&quot;:&quot;bar&quot;}</span><span class="s0">\n</span><span class="s2">{&quot;a</span><span class="s0">\\\\</span><span class="s2">&quot;:&quot;foo</span><span class="s0">\\</span><span class="s2">&quot;&quot;,&quot;b&quot;:&quot;bar&quot;}</span><span class="s0">\n</span><span class="s2">'</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>
        <span class="s1">tm.assert_frame_equal(read_json(result</span><span class="s0">, </span><span class="s1">lines=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">df)</span>

    <span class="s4"># TODO: there is a near-identical test for pytables; can we share?</span>
    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s2">&quot;GH#13774 encoding kwarg not supported&quot;</span><span class="s0">, </span><span class="s1">raises=TypeError)</span>
    <span class="s0">def </span><span class="s1">test_latin_encoding(self):</span>
        <span class="s4"># GH 13774</span>
        <span class="s1">values = [</span>
            <span class="s1">[</span><span class="s5">b&quot;E</span><span class="s0">\xc9</span><span class="s5">, 17&quot;</span><span class="s0">, </span><span class="s5">b&quot;&quot;</span><span class="s0">, </span><span class="s5">b&quot;a&quot;</span><span class="s0">, </span><span class="s5">b&quot;b&quot;</span><span class="s0">, </span><span class="s5">b&quot;c&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">b&quot;E</span><span class="s0">\xc9</span><span class="s5">, 17&quot;</span><span class="s0">, </span><span class="s5">b&quot;a&quot;</span><span class="s0">, </span><span class="s5">b&quot;b&quot;</span><span class="s0">, </span><span class="s5">b&quot;c&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">b&quot;EE, 17&quot;</span><span class="s0">, </span><span class="s5">b&quot;&quot;</span><span class="s0">, </span><span class="s5">b&quot;a&quot;</span><span class="s0">, </span><span class="s5">b&quot;b&quot;</span><span class="s0">, </span><span class="s5">b&quot;c&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">b&quot;E</span><span class="s0">\xc9</span><span class="s5">, 17&quot;</span><span class="s0">, </span><span class="s5">b&quot;</span><span class="s0">\xf8\xfc</span><span class="s5">&quot;</span><span class="s0">, </span><span class="s5">b&quot;a&quot;</span><span class="s0">, </span><span class="s5">b&quot;b&quot;</span><span class="s0">, </span><span class="s5">b&quot;c&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">b&quot;&quot;</span><span class="s0">, </span><span class="s5">b&quot;a&quot;</span><span class="s0">, </span><span class="s5">b&quot;b&quot;</span><span class="s0">, </span><span class="s5">b&quot;c&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">b&quot;</span><span class="s0">\xf8\xfc</span><span class="s5">&quot;</span><span class="s0">, </span><span class="s5">b&quot;a&quot;</span><span class="s0">, </span><span class="s5">b&quot;b&quot;</span><span class="s0">, </span><span class="s5">b&quot;c&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">b&quot;A</span><span class="s0">\xf8\xfc</span><span class="s5">&quot;</span><span class="s0">, </span><span class="s5">b&quot;&quot;</span><span class="s0">, </span><span class="s5">b&quot;a&quot;</span><span class="s0">, </span><span class="s5">b&quot;b&quot;</span><span class="s0">, </span><span class="s5">b&quot;c&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[np.nan</span><span class="s0">, </span><span class="s5">b&quot;&quot;</span><span class="s0">, </span><span class="s5">b&quot;b&quot;</span><span class="s0">, </span><span class="s5">b&quot;c&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">b&quot;A</span><span class="s0">\xf8\xfc</span><span class="s5">&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s5">b&quot;&quot;</span><span class="s0">, </span><span class="s5">b&quot;b&quot;</span><span class="s0">, </span><span class="s5">b&quot;c&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s1">values = [</span>
            <span class="s1">[x.decode(</span><span class="s2">&quot;latin-1&quot;</span><span class="s1">) </span><span class="s0">if </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">bytes) </span><span class="s0">else </span><span class="s1">x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">y]</span>
            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">values</span>
        <span class="s1">]</span>

        <span class="s1">examples = []</span>
        <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;category&quot;</span><span class="s0">, </span><span class="s1">object]:</span>
            <span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">values:</span>
                <span class="s1">examples.append(Series(val</span><span class="s0">, </span><span class="s1">dtype=dtype))</span>

        <span class="s0">def </span><span class="s1">roundtrip(s</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">&quot;latin-1&quot;</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">tm.ensure_clean(</span><span class="s2">&quot;test.json&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">path:</span>
                <span class="s1">s.to_json(path</span><span class="s0">, </span><span class="s1">encoding=encoding)</span>
                <span class="s1">retr = read_json(path</span><span class="s0">, </span><span class="s1">encoding=encoding)</span>
                <span class="s1">tm.assert_series_equal(s</span><span class="s0">, </span><span class="s1">retr</span><span class="s0">, </span><span class="s1">check_categorical=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">examples:</span>
            <span class="s1">roundtrip(s)</span>

    <span class="s0">def </span><span class="s1">test_data_frame_size_after_to_json(self):</span>
        <span class="s4"># GH15344</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [str(</span><span class="s3">1</span><span class="s1">)]})</span>

        <span class="s1">size_before = df.memory_usage(index=</span><span class="s0">True, </span><span class="s1">deep=</span><span class="s0">True</span><span class="s1">).sum()</span>
        <span class="s1">df.to_json()</span>
        <span class="s1">size_after = df.memory_usage(index=</span><span class="s0">True, </span><span class="s1">deep=</span><span class="s0">True</span><span class="s1">).sum()</span>

        <span class="s0">assert </span><span class="s1">size_before == size_after</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;1.&quot;</span><span class="s0">, </span><span class="s2">&quot;2.&quot;</span><span class="s1">]]</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;columns&quot;</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;1.&quot;</span><span class="s0">, </span><span class="s2">&quot;2.&quot;</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_from_json_to_json_table_index_and_columns(self</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">columns):</span>
        <span class="s4"># GH25433 GH25435</span>
        <span class="s1">expected = DataFrame([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">columns=columns)</span>
        <span class="s1">dfjson = expected.to_json(orient=</span><span class="s2">&quot;table&quot;</span><span class="s1">)</span>
        <span class="s1">result = read_json(dfjson</span><span class="s0">, </span><span class="s1">orient=</span><span class="s2">&quot;table&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_from_json_to_json_table_dtypes(self):</span>
        <span class="s4"># GH21345</span>
        <span class="s1">expected = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">4.0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s2">&quot;5&quot;</span><span class="s0">, </span><span class="s2">&quot;6&quot;</span><span class="s1">]})</span>
        <span class="s1">dfjson = expected.to_json(orient=</span><span class="s2">&quot;table&quot;</span><span class="s1">)</span>
        <span class="s1">result = read_json(dfjson</span><span class="s0">, </span><span class="s1">orient=</span><span class="s2">&quot;table&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;orient&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;split&quot;</span><span class="s0">, </span><span class="s2">&quot;records&quot;</span><span class="s0">, </span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s2">&quot;columns&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_to_json_from_json_columns_dtypes(self</span><span class="s0">, </span><span class="s1">orient):</span>
        <span class="s4"># GH21892 GH33205</span>
        <span class="s1">expected = DataFrame.from_dict(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;Integer&quot;</span><span class="s1">: Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;Float&quot;</span><span class="s1">: Series([</span><span class="s0">None, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;float64&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;Object&quot;</span><span class="s1">: Series([</span><span class="s0">None, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;object&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;Bool&quot;</span><span class="s1">: Series([</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;bool&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;Category&quot;</span><span class="s1">: Series([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;category&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;Datetime&quot;</span><span class="s1">: Series(</span>
                    <span class="s1">[</span><span class="s2">&quot;2020-01-01&quot;</span><span class="s0">, None, </span><span class="s2">&quot;2020-01-03&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;datetime64[ns]&quot;</span>
                <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>
        <span class="s1">dfjson = expected.to_json(orient=orient)</span>
        <span class="s1">result = read_json(</span>
            <span class="s1">dfjson</span><span class="s0">,</span>
            <span class="s1">orient=orient</span><span class="s0">,</span>
            <span class="s1">dtype={</span>
                <span class="s2">&quot;Integer&quot;</span><span class="s1">: </span><span class="s2">&quot;int64&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;Float&quot;</span><span class="s1">: </span><span class="s2">&quot;float64&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;Object&quot;</span><span class="s1">: </span><span class="s2">&quot;object&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;Bool&quot;</span><span class="s1">: </span><span class="s2">&quot;bool&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;Category&quot;</span><span class="s1">: </span><span class="s2">&quot;category&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;Datetime&quot;</span><span class="s1">: </span><span class="s2">&quot;datetime64[ns]&quot;</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, </span><span class="s1">{</span><span class="s2">&quot;b&quot;</span><span class="s1">: int</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: int}])</span>
    <span class="s0">def </span><span class="s1">test_read_json_table_dtype_raises(self</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s4"># GH21345</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">4.0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s2">&quot;5&quot;</span><span class="s0">, </span><span class="s2">&quot;6&quot;</span><span class="s1">]})</span>
        <span class="s1">dfjson = df.to_json(orient=</span><span class="s2">&quot;table&quot;</span><span class="s1">)</span>
        <span class="s1">msg = </span><span class="s2">&quot;cannot pass both dtype and orient='table'&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">read_json(dfjson</span><span class="s0">, </span><span class="s1">orient=</span><span class="s2">&quot;table&quot;</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

    <span class="s0">def </span><span class="s1">test_read_json_table_convert_axes_raises(self):</span>
        <span class="s4"># GH25433 GH25435</span>
        <span class="s1">df = DataFrame([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;1.&quot;</span><span class="s0">, </span><span class="s2">&quot;2.&quot;</span><span class="s1">])</span>
        <span class="s1">dfjson = df.to_json(orient=</span><span class="s2">&quot;table&quot;</span><span class="s1">)</span>
        <span class="s1">msg = </span><span class="s2">&quot;cannot pass both convert_axes and orient='table'&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">read_json(dfjson</span><span class="s0">, </span><span class="s1">orient=</span><span class="s2">&quot;table&quot;</span><span class="s0">, </span><span class="s1">convert_axes=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;data, expected&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s1">DataFrame([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s2">&quot;columns&quot;</span><span class="s1">: [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;data&quot;</span><span class="s1">: [[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]]}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">DataFrame([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]).rename_axis(</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s2">&quot;columns&quot;</span><span class="s1">: [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;data&quot;</span><span class="s1">: [[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]]}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">DataFrame(</span>
                    <span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]]</span>
                <span class="s1">)</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s2">&quot;columns&quot;</span><span class="s1">: [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;data&quot;</span><span class="s1">: [[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]]}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;A&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;name&quot;</span><span class="s1">: </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;data&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]})</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;A&quot;</span><span class="s1">).rename_axis(</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s2">&quot;name&quot;</span><span class="s1">: </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;data&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">index=[[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]])</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s2">&quot;name&quot;</span><span class="s1">: </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;data&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_index_false_to_json_split(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s4"># GH 17394</span>
        <span class="s4"># Testing index=False in to_json with orient='split'</span>

        <span class="s1">result = data.to_json(orient=</span><span class="s2">&quot;split&quot;</span><span class="s0">, </span><span class="s1">index=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">result = json.loads(result)</span>

        <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;data&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(DataFrame([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]))</span><span class="s0">,</span>
            <span class="s1">(DataFrame([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]).rename_axis(</span><span class="s2">&quot;foo&quot;</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">DataFrame(</span>
                    <span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]]</span>
                <span class="s1">)</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;A&quot;</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;A&quot;</span><span class="s1">).rename_axis(</span><span class="s2">&quot;foo&quot;</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">index=[[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]]))</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_index_false_to_json_table(self</span><span class="s0">, </span><span class="s1">data):</span>
        <span class="s4"># GH 17394</span>
        <span class="s4"># Testing index=False in to_json with orient='table'</span>

        <span class="s1">result = data.to_json(orient=</span><span class="s2">&quot;table&quot;</span><span class="s0">, </span><span class="s1">index=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">result = json.loads(result)</span>

        <span class="s1">expected = {</span>
            <span class="s2">&quot;schema&quot;</span><span class="s1">: pd.io.json.build_table_schema(data</span><span class="s0">, </span><span class="s1">index=</span><span class="s0">False</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;data&quot;</span><span class="s1">: DataFrame(data).to_dict(orient=</span><span class="s2">&quot;records&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;orient&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;records&quot;</span><span class="s0">, </span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s2">&quot;columns&quot;</span><span class="s0">, </span><span class="s2">&quot;values&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_index_false_error_to_json(self</span><span class="s0">, </span><span class="s1">orient):</span>
        <span class="s4"># GH 17394</span>
        <span class="s4"># Testing error message from to_json with index=False</span>

        <span class="s1">df = DataFrame([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>

        <span class="s1">msg = </span><span class="s2">&quot;'index=False' is only valid when 'orient' is 'split' or 'table'&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">df.to_json(orient=orient</span><span class="s0">, </span><span class="s1">index=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;orient&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;split&quot;</span><span class="s0">, </span><span class="s2">&quot;table&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_index_false_from_json_to_json(self</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s4"># GH25170</span>
        <span class="s4"># Test index=False in from_json to_json</span>
        <span class="s1">expected = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]})</span>
        <span class="s1">dfjson = expected.to_json(orient=orient</span><span class="s0">, </span><span class="s1">index=index)</span>
        <span class="s1">result = read_json(dfjson</span><span class="s0">, </span><span class="s1">orient=orient)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_read_timezone_information(self):</span>
        <span class="s4"># GH 25546</span>
        <span class="s1">result = read_json(</span>
            <span class="s2">'{&quot;2019-01-01T11:00:00.000Z&quot;:88}'</span><span class="s0">, </span><span class="s1">typ=</span><span class="s2">&quot;series&quot;</span><span class="s0">, </span><span class="s1">orient=</span><span class="s2">&quot;index&quot;</span>
        <span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s3">88</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=DatetimeIndex([</span><span class="s2">&quot;2019-01-01 11:00:00&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;UTC&quot;</span><span class="s1">))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;url&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s2">&quot;s3://example-fsspec/&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;gcs://another-fsspec/file.json&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;https://example-site.com/data&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;some-protocol://data.txt&quot;</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_read_json_with_url_value(self</span><span class="s0">, </span><span class="s1">url):</span>
        <span class="s4"># GH 36271</span>
        <span class="s1">result = read_json(</span><span class="s2">f'</span><span class="s0">{{</span><span class="s2">&quot;url&quot;:</span><span class="s0">{{</span><span class="s2">&quot;0&quot;:&quot;</span><span class="s0">{</span><span class="s1">url</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">}}}}</span><span class="s2">'</span><span class="s1">)</span>
        <span class="s1">expected = DataFrame({</span><span class="s2">&quot;url&quot;</span><span class="s1">: [url]})</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;date_format,key&quot;</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">&quot;epoch&quot;</span><span class="s0">, </span><span class="s3">86400000</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;iso&quot;</span><span class="s0">, </span><span class="s2">&quot;P1DT0H0M0S&quot;</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_timedelta_as_label(self</span><span class="s0">, </span><span class="s1">date_format</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s1">df = DataFrame([[</span><span class="s3">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[pd.Timedelta(</span><span class="s2">&quot;1D&quot;</span><span class="s1">)])</span>
        <span class="s1">expected = </span><span class="s2">f'</span><span class="s0">{{</span><span class="s2">&quot;</span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s2">&quot;:</span><span class="s0">{{</span><span class="s2">&quot;0&quot;:1</span><span class="s0">}}}}</span><span class="s2">'</span>
        <span class="s1">result = df.to_json(date_format=date_format)</span>

        <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;orient,expected&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s2">&quot;{</span><span class="s0">\&quot;</span><span class="s2">('a', 'b')</span><span class="s0">\&quot;</span><span class="s2">:{</span><span class="s0">\&quot;</span><span class="s2">('c', 'd')</span><span class="s0">\&quot;</span><span class="s2">:1}}&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;columns&quot;</span><span class="s0">, </span><span class="s2">&quot;{</span><span class="s0">\&quot;</span><span class="s2">('c', 'd')</span><span class="s0">\&quot;</span><span class="s2">:{</span><span class="s0">\&quot;</span><span class="s2">('a', 'b')</span><span class="s0">\&quot;</span><span class="s2">:1}}&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s4"># TODO: the below have separate encoding procedures</span>
            <span class="s4"># They produce JSON but not in a consistent manner</span>
            <span class="s1">pytest.param(</span><span class="s2">&quot;split&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">marks=pytest.mark.skip)</span><span class="s0">,</span>
            <span class="s1">pytest.param(</span><span class="s2">&quot;table&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">marks=pytest.mark.skip)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_tuple_labels(self</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s4"># GH 20500</span>
        <span class="s1">df = DataFrame([[</span><span class="s3">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">index=[(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">columns=[(</span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">)])</span>
        <span class="s1">result = df.to_json(orient=orient)</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;indent&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_to_json_indent(self</span><span class="s0">, </span><span class="s1">indent):</span>
        <span class="s4"># GH 12004</span>
        <span class="s1">df = DataFrame([[</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;baz&quot;</span><span class="s0">, </span><span class="s2">&quot;qux&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>

        <span class="s1">result = df.to_json(indent=indent)</span>
        <span class="s1">spaces = </span><span class="s2">&quot; &quot; </span><span class="s1">* indent</span>
        <span class="s1">expected = </span><span class="s2">f&quot;&quot;&quot;</span><span class="s0">{{</span>
<span class="s0">{</span><span class="s1">spaces</span><span class="s0">}</span><span class="s2">&quot;a&quot;:</span><span class="s0">{{</span>
<span class="s0">{</span><span class="s1">spaces</span><span class="s0">}{</span><span class="s1">spaces</span><span class="s0">}</span><span class="s2">&quot;0&quot;:&quot;foo&quot;,</span>
<span class="s0">{</span><span class="s1">spaces</span><span class="s0">}{</span><span class="s1">spaces</span><span class="s0">}</span><span class="s2">&quot;1&quot;:&quot;baz&quot;</span>
<span class="s0">{</span><span class="s1">spaces</span><span class="s0">}}}</span><span class="s2">,</span>
<span class="s0">{</span><span class="s1">spaces</span><span class="s0">}</span><span class="s2">&quot;b&quot;:</span><span class="s0">{{</span>
<span class="s0">{</span><span class="s1">spaces</span><span class="s0">}{</span><span class="s1">spaces</span><span class="s0">}</span><span class="s2">&quot;0&quot;:&quot;bar&quot;,</span>
<span class="s0">{</span><span class="s1">spaces</span><span class="s0">}{</span><span class="s1">spaces</span><span class="s0">}</span><span class="s2">&quot;1&quot;:&quot;qux&quot;</span>
<span class="s0">{</span><span class="s1">spaces</span><span class="s0">}}}</span>
<span class="s0">}}</span><span class="s2">&quot;&quot;&quot;</span>

        <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;orient,expected&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s2">&quot;split&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;&quot;&quot;{ 
    &quot;columns&quot;:[ 
        &quot;a&quot;, 
        &quot;b&quot; 
    ], 
    &quot;index&quot;:[ 
        0, 
        1 
    ], 
    &quot;data&quot;:[ 
        [ 
            &quot;foo&quot;, 
            &quot;bar&quot; 
        ], 
        [ 
            &quot;baz&quot;, 
            &quot;qux&quot; 
        ] 
    ] 
}&quot;&quot;&quot;</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s2">&quot;records&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;&quot;&quot;[ 
    { 
        &quot;a&quot;:&quot;foo&quot;, 
        &quot;b&quot;:&quot;bar&quot; 
    }, 
    { 
        &quot;a&quot;:&quot;baz&quot;, 
        &quot;b&quot;:&quot;qux&quot; 
    } 
]&quot;&quot;&quot;</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s2">&quot;index&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;&quot;&quot;{ 
    &quot;0&quot;:{ 
        &quot;a&quot;:&quot;foo&quot;, 
        &quot;b&quot;:&quot;bar&quot; 
    }, 
    &quot;1&quot;:{ 
        &quot;a&quot;:&quot;baz&quot;, 
        &quot;b&quot;:&quot;qux&quot; 
    } 
}&quot;&quot;&quot;</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s2">&quot;columns&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;&quot;&quot;{ 
    &quot;a&quot;:{ 
        &quot;0&quot;:&quot;foo&quot;, 
        &quot;1&quot;:&quot;baz&quot; 
    }, 
    &quot;b&quot;:{ 
        &quot;0&quot;:&quot;bar&quot;, 
        &quot;1&quot;:&quot;qux&quot; 
    } 
}&quot;&quot;&quot;</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s2">&quot;values&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;&quot;&quot;[ 
    [ 
        &quot;foo&quot;, 
        &quot;bar&quot; 
    ], 
    [ 
        &quot;baz&quot;, 
        &quot;qux&quot; 
    ] 
]&quot;&quot;&quot;</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s2">&quot;table&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;&quot;&quot;{ 
    &quot;schema&quot;:{ 
        &quot;fields&quot;:[ 
            { 
                &quot;name&quot;:&quot;index&quot;, 
                &quot;type&quot;:&quot;integer&quot; 
            }, 
            { 
                &quot;name&quot;:&quot;a&quot;, 
                &quot;type&quot;:&quot;string&quot; 
            }, 
            { 
                &quot;name&quot;:&quot;b&quot;, 
                &quot;type&quot;:&quot;string&quot; 
            } 
        ], 
        &quot;primaryKey&quot;:[ 
            &quot;index&quot; 
        ], 
        &quot;pandas_version&quot;:&quot;1.4.0&quot; 
    }, 
    &quot;data&quot;:[ 
        { 
            &quot;index&quot;:0, 
            &quot;a&quot;:&quot;foo&quot;, 
            &quot;b&quot;:&quot;bar&quot; 
        }, 
        { 
            &quot;index&quot;:1, 
            &quot;a&quot;:&quot;baz&quot;, 
            &quot;b&quot;:&quot;qux&quot; 
        } 
    ] 
}&quot;&quot;&quot;</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_json_indent_all_orients(self</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s4"># GH 12004</span>
        <span class="s1">df = DataFrame([[</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;baz&quot;</span><span class="s0">, </span><span class="s2">&quot;qux&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>
        <span class="s1">result = df.to_json(orient=orient</span><span class="s0">, </span><span class="s1">indent=</span><span class="s3">4</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s0">def </span><span class="s1">test_json_negative_indent_raises(self):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;must be a nonnegative integer&quot;</span><span class="s1">):</span>
            <span class="s1">DataFrame().to_json(indent=-</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_emca_262_nan_inf_support(self):</span>
        <span class="s4"># GH 12213</span>
        <span class="s1">data = </span><span class="s2">'[&quot;a&quot;, NaN, &quot;NaN&quot;, Infinity, &quot;Infinity&quot;, -Infinity, &quot;-Infinity&quot;]'</span>
        <span class="s1">result = read_json(data)</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">&quot;NaN&quot;</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s2">&quot;Infinity&quot;</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s2">&quot;-Infinity&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_deprecate_numpy_argument_read_json(self):</span>
        <span class="s4"># GH 28512</span>
        <span class="s1">expected = DataFrame([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
            <span class="s1">result = read_json(expected.to_json()</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_frame_int_overflow(self):</span>
        <span class="s4"># GH 30320</span>
        <span class="s1">encoded_json = json.dumps([{</span><span class="s2">&quot;col&quot;</span><span class="s1">: </span><span class="s2">&quot;31900441201190696999&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;col&quot;</span><span class="s1">: </span><span class="s2">&quot;Text&quot;</span><span class="s1">}])</span>
        <span class="s1">expected = DataFrame({</span><span class="s2">&quot;col&quot;</span><span class="s1">: [</span><span class="s2">&quot;31900441201190696999&quot;</span><span class="s0">, </span><span class="s2">&quot;Text&quot;</span><span class="s1">]})</span>
        <span class="s1">result = read_json(encoded_json)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;dataframe,expected&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s1">DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]})</span><span class="s0">,</span>
                <span class="s2">'{&quot;(0, </span><span class="s0">\'</span><span class="s2">x</span><span class="s0">\'</span><span class="s2">)&quot;:1,&quot;(0, </span><span class="s0">\'</span><span class="s2">y</span><span class="s0">\'</span><span class="s2">)&quot;:&quot;a&quot;,&quot;(1, </span><span class="s0">\'</span><span class="s2">x</span><span class="s0">\'</span><span class="s2">)&quot;:2,'</span>
                <span class="s2">'&quot;(1, </span><span class="s0">\'</span><span class="s2">y</span><span class="s0">\'</span><span class="s2">)&quot;:&quot;b&quot;,&quot;(2, </span><span class="s0">\'</span><span class="s2">x</span><span class="s0">\'</span><span class="s2">)&quot;:3,&quot;(2, </span><span class="s0">\'</span><span class="s2">y</span><span class="s0">\'</span><span class="s2">)&quot;:&quot;c&quot;}'</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_json_multiindex(self</span><span class="s0">, </span><span class="s1">dataframe</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s1">series = dataframe.stack()</span>
        <span class="s1">result = series.to_json(orient=</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s0">def </span><span class="s1">test_to_s3(self</span><span class="s0">, </span><span class="s1">s3_resource</span><span class="s0">, </span><span class="s1">s3so):</span>
        <span class="s0">import </span><span class="s1">time</span>

        <span class="s4"># GH 28375</span>
        <span class="s1">mock_bucket_name</span><span class="s0">, </span><span class="s1">target_file = </span><span class="s2">&quot;pandas-test&quot;</span><span class="s0">, </span><span class="s2">&quot;test.json&quot;</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: [</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]})</span>
        <span class="s1">df.to_json(</span><span class="s2">f&quot;s3://</span><span class="s0">{</span><span class="s1">mock_bucket_name</span><span class="s0">}</span><span class="s2">/</span><span class="s0">{</span><span class="s1">target_file</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s1">storage_options=s3so)</span>
        <span class="s1">timeout = </span><span class="s3">5</span>
        <span class="s0">while True</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">target_file </span><span class="s0">in </span><span class="s1">(</span>
                <span class="s1">obj.key </span><span class="s0">for </span><span class="s1">obj </span><span class="s0">in </span><span class="s1">s3_resource.Bucket(</span><span class="s2">&quot;pandas-test&quot;</span><span class="s1">).objects.all()</span>
            <span class="s1">):</span>
                <span class="s0">break</span>
            <span class="s1">time.sleep(</span><span class="s3">0.1</span><span class="s1">)</span>
            <span class="s1">timeout -= </span><span class="s3">0.1</span>
            <span class="s0">assert </span><span class="s1">timeout &gt; </span><span class="s3">0</span><span class="s0">, </span><span class="s2">&quot;Timed out waiting for file to appear on moto&quot;</span>

    <span class="s0">def </span><span class="s1">test_json_pandas_nulls(self</span><span class="s0">, </span><span class="s1">nulls_fixture</span><span class="s0">, </span><span class="s1">request):</span>
        <span class="s4"># GH 31615</span>
        <span class="s0">if </span><span class="s1">isinstance(nulls_fixture</span><span class="s0">, </span><span class="s1">Decimal):</span>
            <span class="s1">mark = pytest.mark.xfail(reason=</span><span class="s2">&quot;not implemented&quot;</span><span class="s1">)</span>
            <span class="s1">request.node.add_marker(mark)</span>

        <span class="s1">result = DataFrame([[nulls_fixture]]).to_json()</span>
        <span class="s0">assert </span><span class="s1">result == </span><span class="s2">'{&quot;0&quot;:{&quot;0&quot;:null}}'</span>

    <span class="s0">def </span><span class="s1">test_readjson_bool_series(self):</span>
        <span class="s4"># GH31464</span>
        <span class="s1">result = read_json(</span><span class="s2">&quot;[true, true, false]&quot;</span><span class="s0">, </span><span class="s1">typ=</span><span class="s2">&quot;series&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s0">True, True, False</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_to_json_multiindex_escape(self):</span>
        <span class="s4"># GH 15273</span>
        <span class="s1">df = DataFrame(</span>
            <span class="s0">True,</span>
            <span class="s1">index=pd.date_range(</span><span class="s2">&quot;2017-01-20&quot;</span><span class="s0">, </span><span class="s2">&quot;2017-01-23&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">columns=[</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">).stack()</span>
        <span class="s1">result = df.to_json()</span>
        <span class="s1">expected = (</span>
            <span class="s2">&quot;{</span><span class="s0">\&quot;</span><span class="s2">(Timestamp('2017-01-20 00:00:00'), 'foo')</span><span class="s0">\&quot;</span><span class="s2">:true,&quot;</span>
            <span class="s2">&quot;</span><span class="s0">\&quot;</span><span class="s2">(Timestamp('2017-01-20 00:00:00'), 'bar')</span><span class="s0">\&quot;</span><span class="s2">:true,&quot;</span>
            <span class="s2">&quot;</span><span class="s0">\&quot;</span><span class="s2">(Timestamp('2017-01-21 00:00:00'), 'foo')</span><span class="s0">\&quot;</span><span class="s2">:true,&quot;</span>
            <span class="s2">&quot;</span><span class="s0">\&quot;</span><span class="s2">(Timestamp('2017-01-21 00:00:00'), 'bar')</span><span class="s0">\&quot;</span><span class="s2">:true,&quot;</span>
            <span class="s2">&quot;</span><span class="s0">\&quot;</span><span class="s2">(Timestamp('2017-01-22 00:00:00'), 'foo')</span><span class="s0">\&quot;</span><span class="s2">:true,&quot;</span>
            <span class="s2">&quot;</span><span class="s0">\&quot;</span><span class="s2">(Timestamp('2017-01-22 00:00:00'), 'bar')</span><span class="s0">\&quot;</span><span class="s2">:true,&quot;</span>
            <span class="s2">&quot;</span><span class="s0">\&quot;</span><span class="s2">(Timestamp('2017-01-23 00:00:00'), 'foo')</span><span class="s0">\&quot;</span><span class="s2">:true,&quot;</span>
            <span class="s2">&quot;</span><span class="s0">\&quot;</span><span class="s2">(Timestamp('2017-01-23 00:00:00'), 'bar')</span><span class="s0">\&quot;</span><span class="s2">:true}&quot;</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s0">def </span><span class="s1">test_to_json_series_of_objects(self):</span>
        <span class="s0">class </span><span class="s1">_TestObject:</span>
            <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">_c</span><span class="s0">, </span><span class="s1">d):</span>
                <span class="s1">self.a = a</span>
                <span class="s1">self.b = b</span>
                <span class="s1">self._c = _c</span>
                <span class="s1">self.d = d</span>

            <span class="s0">def </span><span class="s1">e(self):</span>
                <span class="s0">return </span><span class="s3">5</span>

        <span class="s4"># JSON keys should be all non-callable non-underscore attributes, see GH-42768</span>
        <span class="s1">series = Series([_TestObject(a=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">b=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">_c=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">d=</span><span class="s3">4</span><span class="s1">)])</span>
        <span class="s0">assert </span><span class="s1">json.loads(series.to_json()) == {</span><span class="s2">&quot;0&quot;</span><span class="s1">: {</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s3">2</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">: </span><span class="s3">4</span><span class="s1">}}</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;data,expected&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s1">Series({</span><span class="s3">0</span><span class="s1">: -</span><span class="s3">6 </span><span class="s1">+ </span><span class="s3">8j</span><span class="s0">, </span><span class="s3">1</span><span class="s1">: </span><span class="s3">0 </span><span class="s1">+ </span><span class="s3">1j</span><span class="s0">, </span><span class="s3">2</span><span class="s1">: </span><span class="s3">9 </span><span class="s1">- </span><span class="s3">5j</span><span class="s1">})</span><span class="s0">,</span>
                <span class="s2">'{&quot;0&quot;:{&quot;imag&quot;:8.0,&quot;real&quot;:-6.0},'</span>
                <span class="s2">'&quot;1&quot;:{&quot;imag&quot;:1.0,&quot;real&quot;:0.0},'</span>
                <span class="s2">'&quot;2&quot;:{&quot;imag&quot;:-5.0,&quot;real&quot;:9.0}}'</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">Series({</span><span class="s3">0</span><span class="s1">: -</span><span class="s3">9.39 </span><span class="s1">+ </span><span class="s3">0.66j</span><span class="s0">, </span><span class="s3">1</span><span class="s1">: </span><span class="s3">3.95 </span><span class="s1">+ </span><span class="s3">9.32j</span><span class="s0">, </span><span class="s3">2</span><span class="s1">: </span><span class="s3">4.03 </span><span class="s1">- </span><span class="s3">0.17j</span><span class="s1">})</span><span class="s0">,</span>
                <span class="s2">'{&quot;0&quot;:{&quot;imag&quot;:0.66,&quot;real&quot;:-9.39},'</span>
                <span class="s2">'&quot;1&quot;:{&quot;imag&quot;:9.32,&quot;real&quot;:3.95},'</span>
                <span class="s2">'&quot;2&quot;:{&quot;imag&quot;:-0.17,&quot;real&quot;:4.03}}'</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">DataFrame([[-</span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">3j</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1 </span><span class="s1">- </span><span class="s3">0j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4 </span><span class="s1">- </span><span class="s3">3j</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0 </span><span class="s1">- </span><span class="s3">10j</span><span class="s1">]])</span><span class="s0">,</span>
                <span class="s2">'{&quot;0&quot;:{&quot;0&quot;:{&quot;imag&quot;:3.0,&quot;real&quot;:-2.0},'</span>
                <span class="s2">'&quot;1&quot;:{&quot;imag&quot;:-3.0,&quot;real&quot;:4.0}},'</span>
                <span class="s2">'&quot;1&quot;:{&quot;0&quot;:{&quot;imag&quot;:0.0,&quot;real&quot;:-1.0},'</span>
                <span class="s2">'&quot;1&quot;:{&quot;imag&quot;:-10.0,&quot;real&quot;:0.0}}}'</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">DataFrame(</span>
                    <span class="s1">[[-</span><span class="s3">0.28 </span><span class="s1">+ </span><span class="s3">0.34j</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.08 </span><span class="s1">- </span><span class="s3">0.39j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.41 </span><span class="s1">- </span><span class="s3">0.34j</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.78 </span><span class="s1">- </span><span class="s3">1.35j</span><span class="s1">]]</span>
                <span class="s1">)</span><span class="s0">,</span>
                <span class="s2">'{&quot;0&quot;:{&quot;0&quot;:{&quot;imag&quot;:0.34,&quot;real&quot;:-0.28},'</span>
                <span class="s2">'&quot;1&quot;:{&quot;imag&quot;:-0.34,&quot;real&quot;:0.41}},'</span>
                <span class="s2">'&quot;1&quot;:{&quot;0&quot;:{&quot;imag&quot;:-0.39,&quot;real&quot;:-1.08},'</span>
                <span class="s2">'&quot;1&quot;:{&quot;imag&quot;:-1.35,&quot;real&quot;:-0.78}}}'</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_complex_data_tojson(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s4"># GH41174</span>
        <span class="s1">result = data.to_json()</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>
</pre>
</body>
</html>