<html>
<head>
<title>more.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
more.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">Counter</span><span class="s0">, </span><span class="s1">defaultdict</span><span class="s0">, </span><span class="s1">deque</span><span class="s0">, </span><span class="s1">abc</span>
<span class="s0">from </span><span class="s1">collections.abc </span><span class="s0">import </span><span class="s1">Sequence</span>
<span class="s0">from </span><span class="s1">concurrent.futures </span><span class="s0">import </span><span class="s1">ThreadPoolExecutor</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span><span class="s0">, </span><span class="s1">reduce</span><span class="s0">, </span><span class="s1">wraps</span>
<span class="s0">from </span><span class="s1">heapq </span><span class="s0">import </span><span class="s1">merge</span><span class="s0">, </span><span class="s1">heapify</span><span class="s0">, </span><span class="s1">heapreplace</span><span class="s0">, </span><span class="s1">heappop</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">chain</span><span class="s0">,</span>
    <span class="s1">compress</span><span class="s0">,</span>
    <span class="s1">count</span><span class="s0">,</span>
    <span class="s1">cycle</span><span class="s0">,</span>
    <span class="s1">dropwhile</span><span class="s0">,</span>
    <span class="s1">groupby</span><span class="s0">,</span>
    <span class="s1">islice</span><span class="s0">,</span>
    <span class="s1">repeat</span><span class="s0">,</span>
    <span class="s1">starmap</span><span class="s0">,</span>
    <span class="s1">takewhile</span><span class="s0">,</span>
    <span class="s1">tee</span><span class="s0">,</span>
    <span class="s1">zip_longest</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">math </span><span class="s0">import </span><span class="s1">exp</span><span class="s0">, </span><span class="s1">factorial</span><span class="s0">, </span><span class="s1">floor</span><span class="s0">, </span><span class="s1">log</span>
<span class="s0">from </span><span class="s1">queue </span><span class="s0">import </span><span class="s1">Empty</span><span class="s0">, </span><span class="s1">Queue</span>
<span class="s0">from </span><span class="s1">random </span><span class="s0">import </span><span class="s1">random</span><span class="s0">, </span><span class="s1">randrange</span><span class="s0">, </span><span class="s1">uniform</span>
<span class="s0">from </span><span class="s1">operator </span><span class="s0">import </span><span class="s1">itemgetter</span><span class="s0">, </span><span class="s1">mul</span><span class="s0">, </span><span class="s1">sub</span><span class="s0">, </span><span class="s1">gt</span><span class="s0">, </span><span class="s1">lt</span>
<span class="s0">from </span><span class="s1">sys </span><span class="s0">import </span><span class="s1">hexversion</span><span class="s0">, </span><span class="s1">maxsize</span>
<span class="s0">from </span><span class="s1">time </span><span class="s0">import </span><span class="s1">monotonic</span>

<span class="s0">from </span><span class="s1">.recipes </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">consume</span><span class="s0">,</span>
    <span class="s1">flatten</span><span class="s0">,</span>
    <span class="s1">pairwise</span><span class="s0">,</span>
    <span class="s1">powerset</span><span class="s0">,</span>
    <span class="s1">take</span><span class="s0">,</span>
    <span class="s1">unique_everseen</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s1">__all__ = [</span>
    <span class="s2">'AbortThread'</span><span class="s0">,</span>
    <span class="s2">'adjacent'</span><span class="s0">,</span>
    <span class="s2">'always_iterable'</span><span class="s0">,</span>
    <span class="s2">'always_reversible'</span><span class="s0">,</span>
    <span class="s2">'bucket'</span><span class="s0">,</span>
    <span class="s2">'callback_iter'</span><span class="s0">,</span>
    <span class="s2">'chunked'</span><span class="s0">,</span>
    <span class="s2">'circular_shifts'</span><span class="s0">,</span>
    <span class="s2">'collapse'</span><span class="s0">,</span>
    <span class="s2">'collate'</span><span class="s0">,</span>
    <span class="s2">'consecutive_groups'</span><span class="s0">,</span>
    <span class="s2">'consumer'</span><span class="s0">,</span>
    <span class="s2">'countable'</span><span class="s0">,</span>
    <span class="s2">'count_cycle'</span><span class="s0">,</span>
    <span class="s2">'mark_ends'</span><span class="s0">,</span>
    <span class="s2">'difference'</span><span class="s0">,</span>
    <span class="s2">'distinct_combinations'</span><span class="s0">,</span>
    <span class="s2">'distinct_permutations'</span><span class="s0">,</span>
    <span class="s2">'distribute'</span><span class="s0">,</span>
    <span class="s2">'divide'</span><span class="s0">,</span>
    <span class="s2">'exactly_n'</span><span class="s0">,</span>
    <span class="s2">'filter_except'</span><span class="s0">,</span>
    <span class="s2">'first'</span><span class="s0">,</span>
    <span class="s2">'groupby_transform'</span><span class="s0">,</span>
    <span class="s2">'ilen'</span><span class="s0">,</span>
    <span class="s2">'interleave_longest'</span><span class="s0">,</span>
    <span class="s2">'interleave'</span><span class="s0">,</span>
    <span class="s2">'intersperse'</span><span class="s0">,</span>
    <span class="s2">'islice_extended'</span><span class="s0">,</span>
    <span class="s2">'iterate'</span><span class="s0">,</span>
    <span class="s2">'ichunked'</span><span class="s0">,</span>
    <span class="s2">'is_sorted'</span><span class="s0">,</span>
    <span class="s2">'last'</span><span class="s0">,</span>
    <span class="s2">'locate'</span><span class="s0">,</span>
    <span class="s2">'lstrip'</span><span class="s0">,</span>
    <span class="s2">'make_decorator'</span><span class="s0">,</span>
    <span class="s2">'map_except'</span><span class="s0">,</span>
    <span class="s2">'map_reduce'</span><span class="s0">,</span>
    <span class="s2">'nth_or_last'</span><span class="s0">,</span>
    <span class="s2">'nth_permutation'</span><span class="s0">,</span>
    <span class="s2">'nth_product'</span><span class="s0">,</span>
    <span class="s2">'numeric_range'</span><span class="s0">,</span>
    <span class="s2">'one'</span><span class="s0">,</span>
    <span class="s2">'only'</span><span class="s0">,</span>
    <span class="s2">'padded'</span><span class="s0">,</span>
    <span class="s2">'partitions'</span><span class="s0">,</span>
    <span class="s2">'set_partitions'</span><span class="s0">,</span>
    <span class="s2">'peekable'</span><span class="s0">,</span>
    <span class="s2">'repeat_last'</span><span class="s0">,</span>
    <span class="s2">'replace'</span><span class="s0">,</span>
    <span class="s2">'rlocate'</span><span class="s0">,</span>
    <span class="s2">'rstrip'</span><span class="s0">,</span>
    <span class="s2">'run_length'</span><span class="s0">,</span>
    <span class="s2">'sample'</span><span class="s0">,</span>
    <span class="s2">'seekable'</span><span class="s0">,</span>
    <span class="s2">'SequenceView'</span><span class="s0">,</span>
    <span class="s2">'side_effect'</span><span class="s0">,</span>
    <span class="s2">'sliced'</span><span class="s0">,</span>
    <span class="s2">'sort_together'</span><span class="s0">,</span>
    <span class="s2">'split_at'</span><span class="s0">,</span>
    <span class="s2">'split_after'</span><span class="s0">,</span>
    <span class="s2">'split_before'</span><span class="s0">,</span>
    <span class="s2">'split_when'</span><span class="s0">,</span>
    <span class="s2">'split_into'</span><span class="s0">,</span>
    <span class="s2">'spy'</span><span class="s0">,</span>
    <span class="s2">'stagger'</span><span class="s0">,</span>
    <span class="s2">'strip'</span><span class="s0">,</span>
    <span class="s2">'substrings'</span><span class="s0">,</span>
    <span class="s2">'substrings_indexes'</span><span class="s0">,</span>
    <span class="s2">'time_limited'</span><span class="s0">,</span>
    <span class="s2">'unique_to_each'</span><span class="s0">,</span>
    <span class="s2">'unzip'</span><span class="s0">,</span>
    <span class="s2">'windowed'</span><span class="s0">,</span>
    <span class="s2">'with_iter'</span><span class="s0">,</span>
    <span class="s2">'UnequalIterablesError'</span><span class="s0">,</span>
    <span class="s2">'zip_equal'</span><span class="s0">,</span>
    <span class="s2">'zip_offset'</span><span class="s0">,</span>
    <span class="s2">'windowed_complete'</span><span class="s0">,</span>
    <span class="s2">'all_unique'</span><span class="s0">,</span>
    <span class="s2">'value_chain'</span><span class="s0">,</span>
    <span class="s2">'product_index'</span><span class="s0">,</span>
    <span class="s2">'combination_index'</span><span class="s0">,</span>
    <span class="s2">'permutation_index'</span><span class="s0">,</span>
<span class="s1">]</span>

<span class="s1">_marker = object()</span>


<span class="s0">def </span><span class="s1">chunked(iterable</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">strict=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Break *iterable* into lists of length *n*: 
 
        &gt;&gt;&gt; list(chunked([1, 2, 3, 4, 5, 6], 3)) 
        [[1, 2, 3], [4, 5, 6]] 
 
    By the default, the last yielded list will have fewer than *n* elements 
    if the length of *iterable* is not divisible by *n*: 
 
        &gt;&gt;&gt; list(chunked([1, 2, 3, 4, 5, 6, 7, 8], 3)) 
        [[1, 2, 3], [4, 5, 6], [7, 8]] 
 
    To use a fill-in value instead, see the :func:`grouper` recipe. 
 
    If the length of *iterable* is not divisible by *n* and *strict* is 
    ``True``, then ``ValueError`` will be raised before the last 
    list is yielded. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">iterator = iter(partial(take</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">iter(iterable))</span><span class="s0">, </span><span class="s1">[])</span>
    <span class="s0">if </span><span class="s1">strict:</span>

        <span class="s0">def </span><span class="s1">ret():</span>
            <span class="s0">for </span><span class="s1">chunk </span><span class="s0">in </span><span class="s1">iterator:</span>
                <span class="s0">if </span><span class="s1">len(chunk) != n:</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'iterable is not divisible by n.'</span><span class="s1">)</span>
                <span class="s0">yield </span><span class="s1">chunk</span>

        <span class="s0">return </span><span class="s1">iter(ret())</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">iterator</span>


<span class="s0">def </span><span class="s1">first(iterable</span><span class="s0">, </span><span class="s1">default=_marker):</span>
    <span class="s3">&quot;&quot;&quot;Return the first item of *iterable*, or *default* if *iterable* is 
    empty. 
 
        &gt;&gt;&gt; first([0, 1, 2, 3]) 
        0 
        &gt;&gt;&gt; first([], 'some default') 
        'some default' 
 
    If *default* is not provided and there are no items in the iterable, 
    raise ``ValueError``. 
 
    :func:`first` is useful when you have a generator of expensive-to-retrieve 
    values and want any arbitrary one. It is marginally shorter than 
    ``next(iter(iterable), default)``. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">next(iter(iterable))</span>
    <span class="s0">except </span><span class="s1">StopIteration </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s0">if </span><span class="s1">default </span><span class="s0">is </span><span class="s1">_marker:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">'first() was called on an empty iterable, and no '</span>
                <span class="s2">'default value was provided.'</span>
            <span class="s1">) </span><span class="s0">from </span><span class="s1">e</span>
        <span class="s0">return </span><span class="s1">default</span>


<span class="s0">def </span><span class="s1">last(iterable</span><span class="s0">, </span><span class="s1">default=_marker):</span>
    <span class="s3">&quot;&quot;&quot;Return the last item of *iterable*, or *default* if *iterable* is 
    empty. 
 
        &gt;&gt;&gt; last([0, 1, 2, 3]) 
        3 
        &gt;&gt;&gt; last([], 'some default') 
        'some default' 
 
    If *default* is not provided and there are no items in the iterable, 
    raise ``ValueError``. 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">isinstance(iterable</span><span class="s0">, </span><span class="s1">Sequence):</span>
            <span class="s0">return </span><span class="s1">iterable[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s5"># Work around https://bugs.python.org/issue38525</span>
        <span class="s0">elif </span><span class="s1">hasattr(iterable</span><span class="s0">, </span><span class="s2">'__reversed__'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(hexversion != </span><span class="s4">0x030800F0</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">next(reversed(iterable))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">deque(iterable</span><span class="s0">, </span><span class="s1">maxlen=</span><span class="s4">1</span><span class="s1">)[-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s0">except </span><span class="s1">(IndexError</span><span class="s0">, </span><span class="s1">TypeError</span><span class="s0">, </span><span class="s1">StopIteration):</span>
        <span class="s0">if </span><span class="s1">default </span><span class="s0">is </span><span class="s1">_marker:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">'last() was called on an empty iterable, and no default was '</span>
                <span class="s2">'provided.'</span>
            <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">default</span>


<span class="s0">def </span><span class="s1">nth_or_last(iterable</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">default=_marker):</span>
    <span class="s3">&quot;&quot;&quot;Return the nth or the last item of *iterable*, 
    or *default* if *iterable* is empty. 
 
        &gt;&gt;&gt; nth_or_last([0, 1, 2, 3], 2) 
        2 
        &gt;&gt;&gt; nth_or_last([0, 1], 2) 
        1 
        &gt;&gt;&gt; nth_or_last([], 0, 'some default') 
        'some default' 
 
    If *default* is not provided and there are no items in the iterable, 
    raise ``ValueError``. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">last(islice(iterable</span><span class="s0">, </span><span class="s1">n + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">default=default)</span>


<span class="s0">class </span><span class="s1">peekable:</span>
    <span class="s3">&quot;&quot;&quot;Wrap an iterator to allow lookahead and prepending elements. 
 
    Call :meth:`peek` on the result to get the value that will be returned 
    by :func:`next`. This won't advance the iterator: 
 
        &gt;&gt;&gt; p = peekable(['a', 'b']) 
        &gt;&gt;&gt; p.peek() 
        'a' 
        &gt;&gt;&gt; next(p) 
        'a' 
 
    Pass :meth:`peek` a default value to return that instead of raising 
    ``StopIteration`` when the iterator is exhausted. 
 
        &gt;&gt;&gt; p = peekable([]) 
        &gt;&gt;&gt; p.peek('hi') 
        'hi' 
 
    peekables also offer a :meth:`prepend` method, which &quot;inserts&quot; items 
    at the head of the iterable: 
 
        &gt;&gt;&gt; p = peekable([1, 2, 3]) 
        &gt;&gt;&gt; p.prepend(10, 11, 12) 
        &gt;&gt;&gt; next(p) 
        10 
        &gt;&gt;&gt; p.peek() 
        11 
        &gt;&gt;&gt; list(p) 
        [11, 12, 1, 2, 3] 
 
    peekables can be indexed. Index 0 is the item that will be returned by 
    :func:`next`, index 1 is the item after that, and so on: 
    The values up to the given index will be cached. 
 
        &gt;&gt;&gt; p = peekable(['a', 'b', 'c', 'd']) 
        &gt;&gt;&gt; p[0] 
        'a' 
        &gt;&gt;&gt; p[1] 
        'b' 
        &gt;&gt;&gt; next(p) 
        'a' 
 
    Negative indexes are supported, but be aware that they will cache the 
    remaining items in the source iterator, which may require significant 
    storage. 
 
    To check whether a peekable is exhausted, check its truth value: 
 
        &gt;&gt;&gt; p = peekable(['a', 'b']) 
        &gt;&gt;&gt; if p:  # peekable has items 
        ...     list(p) 
        ['a', 'b'] 
        &gt;&gt;&gt; if not p:  # peekable is exhausted 
        ...     list(p) 
        [] 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">iterable):</span>
        <span class="s1">self._it = iter(iterable)</span>
        <span class="s1">self._cache = deque()</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__bool__(self):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self.peek()</span>
        <span class="s0">except </span><span class="s1">StopIteration:</span>
            <span class="s0">return False</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">peek(self</span><span class="s0">, </span><span class="s1">default=_marker):</span>
        <span class="s3">&quot;&quot;&quot;Return the item that will be next returned from ``next()``. 
 
        Return ``default`` if there are no items left. If ``default`` is not 
        provided, raise ``StopIteration``. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self._cache:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">self._cache.append(next(self._it))</span>
            <span class="s0">except </span><span class="s1">StopIteration:</span>
                <span class="s0">if </span><span class="s1">default </span><span class="s0">is </span><span class="s1">_marker:</span>
                    <span class="s0">raise</span>
                <span class="s0">return </span><span class="s1">default</span>
        <span class="s0">return </span><span class="s1">self._cache[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">prepend(self</span><span class="s0">, </span><span class="s1">*items):</span>
        <span class="s3">&quot;&quot;&quot;Stack up items to be the next ones returned from ``next()`` or 
        ``self.peek()``. The items will be returned in 
        first in, first out order:: 
 
            &gt;&gt;&gt; p = peekable([1, 2, 3]) 
            &gt;&gt;&gt; p.prepend(10, 11, 12) 
            &gt;&gt;&gt; next(p) 
            10 
            &gt;&gt;&gt; list(p) 
            [11, 12, 1, 2, 3] 
 
        It is possible, by prepending items, to &quot;resurrect&quot; a peekable that 
        previously raised ``StopIteration``. 
 
            &gt;&gt;&gt; p = peekable([]) 
            &gt;&gt;&gt; next(p) 
            Traceback (most recent call last): 
              ... 
            StopIteration 
            &gt;&gt;&gt; p.prepend(1) 
            &gt;&gt;&gt; next(p) 
            1 
            &gt;&gt;&gt; next(p) 
            Traceback (most recent call last): 
              ... 
            StopIteration 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._cache.extendleft(reversed(items))</span>

    <span class="s0">def </span><span class="s1">__next__(self):</span>
        <span class="s0">if </span><span class="s1">self._cache:</span>
            <span class="s0">return </span><span class="s1">self._cache.popleft()</span>

        <span class="s0">return </span><span class="s1">next(self._it)</span>

    <span class="s0">def </span><span class="s1">_get_slice(self</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s5"># Normalize the slice's arguments</span>
        <span class="s1">step = </span><span class="s4">1 </span><span class="s0">if </span><span class="s1">(index.step </span><span class="s0">is None</span><span class="s1">) </span><span class="s0">else </span><span class="s1">index.step</span>
        <span class="s0">if </span><span class="s1">step &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">start = </span><span class="s4">0 </span><span class="s0">if </span><span class="s1">(index.start </span><span class="s0">is None</span><span class="s1">) </span><span class="s0">else </span><span class="s1">index.start</span>
            <span class="s1">stop = maxsize </span><span class="s0">if </span><span class="s1">(index.stop </span><span class="s0">is None</span><span class="s1">) </span><span class="s0">else </span><span class="s1">index.stop</span>
        <span class="s0">elif </span><span class="s1">step &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">start = -</span><span class="s4">1 </span><span class="s0">if </span><span class="s1">(index.start </span><span class="s0">is None</span><span class="s1">) </span><span class="s0">else </span><span class="s1">index.start</span>
            <span class="s1">stop = (-maxsize - </span><span class="s4">1</span><span class="s1">) </span><span class="s0">if </span><span class="s1">(index.stop </span><span class="s0">is None</span><span class="s1">) </span><span class="s0">else </span><span class="s1">index.stop</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'slice step cannot be zero'</span><span class="s1">)</span>

        <span class="s5"># If either the start or stop index is negative, we'll need to cache</span>
        <span class="s5"># the rest of the iterable in order to slice from the right side.</span>
        <span class="s0">if </span><span class="s1">(start &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(stop &lt; </span><span class="s4">0</span><span class="s1">):</span>
            <span class="s1">self._cache.extend(self._it)</span>
        <span class="s5"># Otherwise we'll need to find the rightmost index and cache to that</span>
        <span class="s5"># point.</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">n = min(max(start</span><span class="s0">, </span><span class="s1">stop) + </span><span class="s4">1</span><span class="s0">, </span><span class="s1">maxsize)</span>
            <span class="s1">cache_len = len(self._cache)</span>
            <span class="s0">if </span><span class="s1">n &gt;= cache_len:</span>
                <span class="s1">self._cache.extend(islice(self._it</span><span class="s0">, </span><span class="s1">n - cache_len))</span>

        <span class="s0">return </span><span class="s1">list(self._cache)[index]</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">slice):</span>
            <span class="s0">return </span><span class="s1">self._get_slice(index)</span>

        <span class="s1">cache_len = len(self._cache)</span>
        <span class="s0">if </span><span class="s1">index &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self._cache.extend(self._it)</span>
        <span class="s0">elif </span><span class="s1">index &gt;= cache_len:</span>
            <span class="s1">self._cache.extend(islice(self._it</span><span class="s0">, </span><span class="s1">index + </span><span class="s4">1 </span><span class="s1">- cache_len))</span>

        <span class="s0">return </span><span class="s1">self._cache[index]</span>


<span class="s0">def </span><span class="s1">collate(*iterables</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s3">&quot;&quot;&quot;Return a sorted merge of the items from each of several already-sorted 
    *iterables*. 
 
        &gt;&gt;&gt; list(collate('ACDZ', 'AZ', 'JKL')) 
        ['A', 'A', 'C', 'D', 'J', 'K', 'L', 'Z', 'Z'] 
 
    Works lazily, keeping only the next value from each iterable in memory. Use 
    :func:`collate` to, for example, perform a n-way mergesort of items that 
    don't fit in memory. 
 
    If a *key* function is specified, the iterables will be sorted according 
    to its result: 
 
        &gt;&gt;&gt; key = lambda s: int(s)  # Sort by numeric value, not by string 
        &gt;&gt;&gt; list(collate(['1', '10'], ['2', '11'], key=key)) 
        ['1', '2', '10', '11'] 
 
 
    If the *iterables* are sorted in descending order, set *reverse* to 
    ``True``: 
 
        &gt;&gt;&gt; list(collate([5, 3, 1], [4, 2, 0], reverse=True)) 
        [5, 4, 3, 2, 1, 0] 
 
    If the elements of the passed-in iterables are out of order, you might get 
    unexpected results. 
 
    On Python 3.5+, this function is an alias for :func:`heapq.merge`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">warnings.warn(</span>
        <span class="s2">&quot;collate is no longer part of more_itertools, use heapq.merge&quot;</span><span class="s0">,</span>
        <span class="s1">DeprecationWarning</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">merge(*iterables</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s0">def </span><span class="s1">consumer(func):</span>
    <span class="s3">&quot;&quot;&quot;Decorator that automatically advances a PEP-342-style &quot;reverse iterator&quot; 
    to its first yield point so you don't have to call ``next()`` on it 
    manually. 
 
        &gt;&gt;&gt; @consumer 
        ... def tally(): 
        ...     i = 0 
        ...     while True: 
        ...         print('Thing number %s is %s.' % (i, (yield))) 
        ...         i += 1 
        ... 
        &gt;&gt;&gt; t = tally() 
        &gt;&gt;&gt; t.send('red') 
        Thing number 0 is red. 
        &gt;&gt;&gt; t.send('fish') 
        Thing number 1 is fish. 
 
    Without the decorator, you would have to call ``next(t)`` before 
    ``t.send()`` could be used. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">@wraps(func)</span>
    <span class="s0">def </span><span class="s1">wrapper(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">gen = func(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">next(gen)</span>
        <span class="s0">return </span><span class="s1">gen</span>

    <span class="s0">return </span><span class="s1">wrapper</span>


<span class="s0">def </span><span class="s1">ilen(iterable):</span>
    <span class="s3">&quot;&quot;&quot;Return the number of items in *iterable*. 
 
        &gt;&gt;&gt; ilen(x for x in range(1000000) if x % 3 == 0) 
        333334 
 
    This consumes the iterable, so handle with care. 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># This approach was selected because benchmarks showed it's likely the</span>
    <span class="s5"># fastest of the known implementations at the time of writing.</span>
    <span class="s5"># See GitHub tracker: #236, #230.</span>
    <span class="s1">counter = count()</span>
    <span class="s1">deque(zip(iterable</span><span class="s0">, </span><span class="s1">counter)</span><span class="s0">, </span><span class="s1">maxlen=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">next(counter)</span>


<span class="s0">def </span><span class="s1">iterate(func</span><span class="s0">, </span><span class="s1">start):</span>
    <span class="s3">&quot;&quot;&quot;Return ``start``, ``func(start)``, ``func(func(start))``, ... 
 
    &gt;&gt;&gt; from itertools import islice 
    &gt;&gt;&gt; list(islice(iterate(lambda x: 2*x, 1), 10)) 
    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512] 
 
    &quot;&quot;&quot;</span>
    <span class="s0">while True</span><span class="s1">:</span>
        <span class="s0">yield </span><span class="s1">start</span>
        <span class="s1">start = func(start)</span>


<span class="s0">def </span><span class="s1">with_iter(context_manager):</span>
    <span class="s3">&quot;&quot;&quot;Wrap an iterable in a ``with`` statement, so it closes once exhausted. 
 
    For example, this will close the file when the iterator is exhausted:: 
 
        upper_lines = (line.upper() for line in with_iter(open('foo'))) 
 
    Any context manager which returns an iterable is a candidate for 
    ``with_iter``. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">with </span><span class="s1">context_manager </span><span class="s0">as </span><span class="s1">iterable:</span>
        <span class="s0">yield from </span><span class="s1">iterable</span>


<span class="s0">def </span><span class="s1">one(iterable</span><span class="s0">, </span><span class="s1">too_short=</span><span class="s0">None, </span><span class="s1">too_long=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Return the first item from *iterable*, which is expected to contain only 
    that item. Raise an exception if *iterable* is empty or has more than one 
    item. 
 
    :func:`one` is useful for ensuring that an iterable contains only one item. 
    For example, it can be used to retrieve the result of a database query 
    that is expected to return a single row. 
 
    If *iterable* is empty, ``ValueError`` will be raised. You may specify a 
    different exception with the *too_short* keyword: 
 
        &gt;&gt;&gt; it = [] 
        &gt;&gt;&gt; one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL 
        Traceback (most recent call last): 
        ... 
        ValueError: too many items in iterable (expected 1)' 
        &gt;&gt;&gt; too_short = IndexError('too few items') 
        &gt;&gt;&gt; one(it, too_short=too_short)  # doctest: +IGNORE_EXCEPTION_DETAIL 
        Traceback (most recent call last): 
        ... 
        IndexError: too few items 
 
    Similarly, if *iterable* contains more than one item, ``ValueError`` will 
    be raised. You may specify a different exception with the *too_long* 
    keyword: 
 
        &gt;&gt;&gt; it = ['too', 'many'] 
        &gt;&gt;&gt; one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL 
        Traceback (most recent call last): 
        ... 
        ValueError: Expected exactly one item in iterable, but got 'too', 
        'many', and perhaps more. 
        &gt;&gt;&gt; too_long = RuntimeError 
        &gt;&gt;&gt; one(it, too_long=too_long)  # doctest: +IGNORE_EXCEPTION_DETAIL 
        Traceback (most recent call last): 
        ... 
        RuntimeError 
 
    Note that :func:`one` attempts to advance *iterable* twice to ensure there 
    is only one item. See :func:`spy` or :func:`peekable` to check iterable 
    contents less destructively. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">it = iter(iterable)</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">first_value = next(it)</span>
    <span class="s0">except </span><span class="s1">StopIteration </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s0">raise </span><span class="s1">(</span>
            <span class="s1">too_short </span><span class="s0">or </span><span class="s1">ValueError(</span><span class="s2">'too few items in iterable (expected 1)'</span><span class="s1">)</span>
        <span class="s1">) </span><span class="s0">from </span><span class="s1">e</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">second_value = next(it)</span>
    <span class="s0">except </span><span class="s1">StopIteration:</span>
        <span class="s0">pass</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">msg = (</span>
            <span class="s2">'Expected exactly one item in iterable, but got {!r}, {!r}, '</span>
            <span class="s2">'and perhaps more.'</span><span class="s1">.format(first_value</span><span class="s0">, </span><span class="s1">second_value)</span>
        <span class="s1">)</span>
        <span class="s0">raise </span><span class="s1">too_long </span><span class="s0">or </span><span class="s1">ValueError(msg)</span>

    <span class="s0">return </span><span class="s1">first_value</span>


<span class="s0">def </span><span class="s1">distinct_permutations(iterable</span><span class="s0">, </span><span class="s1">r=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Yield successive distinct permutations of the elements in *iterable*. 
 
        &gt;&gt;&gt; sorted(distinct_permutations([1, 0, 1])) 
        [(0, 1, 1), (1, 0, 1), (1, 1, 0)] 
 
    Equivalent to ``set(permutations(iterable))``, except duplicates are not 
    generated and thrown away. For larger input sequences this is much more 
    efficient. 
 
    Duplicate permutations arise when there are duplicated elements in the 
    input iterable. The number of items returned is 
    `n! / (x_1! * x_2! * ... * x_n!)`, where `n` is the total number of 
    items input, and each `x_i` is the count of a distinct item in the input 
    sequence. 
 
    If *r* is given, only the *r*-length permutations are yielded. 
 
        &gt;&gt;&gt; sorted(distinct_permutations([1, 0, 1], r=2)) 
        [(0, 1), (1, 0), (1, 1)] 
        &gt;&gt;&gt; sorted(distinct_permutations(range(3), r=2)) 
        [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)] 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># Algorithm: https://w.wiki/Qai</span>
    <span class="s0">def </span><span class="s1">_full(A):</span>
        <span class="s0">while True</span><span class="s1">:</span>
            <span class="s5"># Yield the permutation we have</span>
            <span class="s0">yield </span><span class="s1">tuple(A)</span>

            <span class="s5"># Find the largest index i such that A[i] &lt; A[i + 1]</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(size - </span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">):</span>
                <span class="s0">if </span><span class="s1">A[i] &lt; A[i + </span><span class="s4">1</span><span class="s1">]:</span>
                    <span class="s0">break</span>
            <span class="s5">#  If no such index exists, this permutation is the last one</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return</span>

            <span class="s5"># Find the largest index j greater than j such that A[i] &lt; A[j]</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(size - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">):</span>
                <span class="s0">if </span><span class="s1">A[i] &lt; A[j]:</span>
                    <span class="s0">break</span>

            <span class="s5"># Swap the value of A[i] with that of A[j], then reverse the</span>
            <span class="s5"># sequence from A[i + 1] to form the new permutation</span>
            <span class="s1">A[i]</span><span class="s0">, </span><span class="s1">A[j] = A[j]</span><span class="s0">, </span><span class="s1">A[i]</span>
            <span class="s1">A[i + </span><span class="s4">1 </span><span class="s1">:] = A[: i - size : -</span><span class="s4">1</span><span class="s1">]  </span><span class="s5"># A[i + 1:][::-1]</span>

    <span class="s5"># Algorithm: modified from the above</span>
    <span class="s0">def </span><span class="s1">_partial(A</span><span class="s0">, </span><span class="s1">r):</span>
        <span class="s5"># Split A into the first r items and the last r items</span>
        <span class="s1">head</span><span class="s0">, </span><span class="s1">tail = A[:r]</span><span class="s0">, </span><span class="s1">A[r:]</span>
        <span class="s1">right_head_indexes = range(r - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">left_tail_indexes = range(len(tail))</span>

        <span class="s0">while True</span><span class="s1">:</span>
            <span class="s5"># Yield the permutation we have</span>
            <span class="s0">yield </span><span class="s1">tuple(head)</span>

            <span class="s5"># Starting from the right, find the first index of the head with</span>
            <span class="s5"># value smaller than the maximum value of the tail - call it i.</span>
            <span class="s1">pivot = tail[-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">right_head_indexes:</span>
                <span class="s0">if </span><span class="s1">head[i] &lt; pivot:</span>
                    <span class="s0">break</span>
                <span class="s1">pivot = head[i]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return</span>

            <span class="s5"># Starting from the left, find the first value of the tail</span>
            <span class="s5"># with a value greater than head[i] and swap.</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">left_tail_indexes:</span>
                <span class="s0">if </span><span class="s1">tail[j] &gt; head[i]:</span>
                    <span class="s1">head[i]</span><span class="s0">, </span><span class="s1">tail[j] = tail[j]</span><span class="s0">, </span><span class="s1">head[i]</span>
                    <span class="s0">break</span>
            <span class="s5"># If we didn't find one, start from the right and find the first</span>
            <span class="s5"># index of the head with a value greater than head[i] and swap.</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">right_head_indexes:</span>
                    <span class="s0">if </span><span class="s1">head[j] &gt; head[i]:</span>
                        <span class="s1">head[i]</span><span class="s0">, </span><span class="s1">head[j] = head[j]</span><span class="s0">, </span><span class="s1">head[i]</span>
                        <span class="s0">break</span>

            <span class="s5"># Reverse head[i + 1:] and swap it with tail[:r - (i + 1)]</span>
            <span class="s1">tail += head[: i - r : -</span><span class="s4">1</span><span class="s1">]  </span><span class="s5"># head[i + 1:][::-1]</span>
            <span class="s1">i += </span><span class="s4">1</span>
            <span class="s1">head[i:]</span><span class="s0">, </span><span class="s1">tail[:] = tail[: r - i]</span><span class="s0">, </span><span class="s1">tail[r - i :]</span>

    <span class="s1">items = sorted(iterable)</span>

    <span class="s1">size = len(items)</span>
    <span class="s0">if </span><span class="s1">r </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">r = size</span>

    <span class="s0">if </span><span class="s4">0 </span><span class="s1">&lt; r &lt;= size:</span>
        <span class="s0">return </span><span class="s1">_full(items) </span><span class="s0">if </span><span class="s1">(r == size) </span><span class="s0">else </span><span class="s1">_partial(items</span><span class="s0">, </span><span class="s1">r)</span>

    <span class="s0">return </span><span class="s1">iter(() </span><span class="s0">if </span><span class="s1">r </span><span class="s0">else </span><span class="s1">(()</span><span class="s0">,</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">intersperse(e</span><span class="s0">, </span><span class="s1">iterable</span><span class="s0">, </span><span class="s1">n=</span><span class="s4">1</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Intersperse filler element *e* among the items in *iterable*, leaving 
    *n* items between each filler element. 
 
        &gt;&gt;&gt; list(intersperse('!', [1, 2, 3, 4, 5])) 
        [1, '!', 2, '!', 3, '!', 4, '!', 5] 
 
        &gt;&gt;&gt; list(intersperse(None, [1, 2, 3, 4, 5], n=2)) 
        [1, 2, None, 3, 4, None, 5] 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">n == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'n must be &gt; 0'</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">n == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s5"># interleave(repeat(e), iterable) -&gt; e, x_0, e, e, x_1, e, x_2...</span>
        <span class="s5"># islice(..., 1, None) -&gt; x_0, e, e, x_1, e, x_2...</span>
        <span class="s0">return </span><span class="s1">islice(interleave(repeat(e)</span><span class="s0">, </span><span class="s1">iterable)</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s5"># interleave(filler, chunks) -&gt; [e], [x_0, x_1], [e], [x_2, x_3]...</span>
        <span class="s5"># islice(..., 1, None) -&gt; [x_0, x_1], [e], [x_2, x_3]...</span>
        <span class="s5"># flatten(...) -&gt; x_0, x_1, e, x_2, x_3...</span>
        <span class="s1">filler = repeat([e])</span>
        <span class="s1">chunks = chunked(iterable</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s0">return </span><span class="s1">flatten(islice(interleave(filler</span><span class="s0">, </span><span class="s1">chunks)</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, None</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">unique_to_each(*iterables):</span>
    <span class="s3">&quot;&quot;&quot;Return the elements from each of the input iterables that aren't in the 
    other input iterables. 
 
    For example, suppose you have a set of packages, each with a set of 
    dependencies:: 
 
        {'pkg_1': {'A', 'B'}, 'pkg_2': {'B', 'C'}, 'pkg_3': {'B', 'D'}} 
 
    If you remove one package, which dependencies can also be removed? 
 
    If ``pkg_1`` is removed, then ``A`` is no longer necessary - it is not 
    associated with ``pkg_2`` or ``pkg_3``. Similarly, ``C`` is only needed for 
    ``pkg_2``, and ``D`` is only needed for ``pkg_3``:: 
 
        &gt;&gt;&gt; unique_to_each({'A', 'B'}, {'B', 'C'}, {'B', 'D'}) 
        [['A'], ['C'], ['D']] 
 
    If there are duplicates in one input iterable that aren't in the others 
    they will be duplicated in the output. Input order is preserved:: 
 
        &gt;&gt;&gt; unique_to_each(&quot;mississippi&quot;, &quot;missouri&quot;) 
        [['p', 'p'], ['o', 'u', 'r']] 
 
    It is assumed that the elements of each iterable are hashable. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">pool = [list(it) </span><span class="s0">for </span><span class="s1">it </span><span class="s0">in </span><span class="s1">iterables]</span>
    <span class="s1">counts = Counter(chain.from_iterable(map(set</span><span class="s0">, </span><span class="s1">pool)))</span>
    <span class="s1">uniques = {element </span><span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">counts </span><span class="s0">if </span><span class="s1">counts[element] == </span><span class="s4">1</span><span class="s1">}</span>
    <span class="s0">return </span><span class="s1">[list(filter(uniques.__contains__</span><span class="s0">, </span><span class="s1">it)) </span><span class="s0">for </span><span class="s1">it </span><span class="s0">in </span><span class="s1">pool]</span>


<span class="s0">def </span><span class="s1">windowed(seq</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">fillvalue=</span><span class="s0">None, </span><span class="s1">step=</span><span class="s4">1</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Return a sliding window of width *n* over the given iterable. 
 
        &gt;&gt;&gt; all_windows = windowed([1, 2, 3, 4, 5], 3) 
        &gt;&gt;&gt; list(all_windows) 
        [(1, 2, 3), (2, 3, 4), (3, 4, 5)] 
 
    When the window is larger than the iterable, *fillvalue* is used in place 
    of missing values: 
 
        &gt;&gt;&gt; list(windowed([1, 2, 3], 4)) 
        [(1, 2, 3, None)] 
 
    Each window will advance in increments of *step*: 
 
        &gt;&gt;&gt; list(windowed([1, 2, 3, 4, 5, 6], 3, fillvalue='!', step=2)) 
        [(1, 2, 3), (3, 4, 5), (5, 6, '!')] 
 
    To slide into the iterable's items, use :func:`chain` to add filler items 
    to the left: 
 
        &gt;&gt;&gt; iterable = [1, 2, 3, 4] 
        &gt;&gt;&gt; n = 3 
        &gt;&gt;&gt; padding = [None] * (n - 1) 
        &gt;&gt;&gt; list(windowed(chain(padding, iterable), 3)) 
        [(None, None, 1), (None, 1, 2), (1, 2, 3), (2, 3, 4)] 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">n &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'n must be &gt;= 0'</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">n == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">yield </span><span class="s1">tuple()</span>
        <span class="s0">return</span>
    <span class="s0">if </span><span class="s1">step &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'step must be &gt;= 1'</span><span class="s1">)</span>

    <span class="s1">window = deque(maxlen=n)</span>
    <span class="s1">i = n</span>
    <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">map(window.append</span><span class="s0">, </span><span class="s1">seq):</span>
        <span class="s1">i -= </span><span class="s4">1</span>
        <span class="s0">if not </span><span class="s1">i:</span>
            <span class="s1">i = step</span>
            <span class="s0">yield </span><span class="s1">tuple(window)</span>

    <span class="s1">size = len(window)</span>
    <span class="s0">if </span><span class="s1">size &lt; n:</span>
        <span class="s0">yield </span><span class="s1">tuple(chain(window</span><span class="s0">, </span><span class="s1">repeat(fillvalue</span><span class="s0">, </span><span class="s1">n - size)))</span>
    <span class="s0">elif </span><span class="s4">0 </span><span class="s1">&lt; i &lt; min(step</span><span class="s0">, </span><span class="s1">n):</span>
        <span class="s1">window += (fillvalue</span><span class="s0">,</span><span class="s1">) * i</span>
        <span class="s0">yield </span><span class="s1">tuple(window)</span>


<span class="s0">def </span><span class="s1">substrings(iterable):</span>
    <span class="s3">&quot;&quot;&quot;Yield all of the substrings of *iterable*. 
 
        &gt;&gt;&gt; [''.join(s) for s in substrings('more')] 
        ['m', 'o', 'r', 'e', 'mo', 'or', 're', 'mor', 'ore', 'more'] 
 
    Note that non-string iterables can also be subdivided. 
 
        &gt;&gt;&gt; list(substrings([0, 1, 2])) 
        [(0,), (1,), (2,), (0, 1), (1, 2), (0, 1, 2)] 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># The length-1 substrings</span>
    <span class="s1">seq = []</span>
    <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">iter(iterable):</span>
        <span class="s1">seq.append(item)</span>
        <span class="s0">yield </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s1">seq = tuple(seq)</span>
    <span class="s1">item_count = len(seq)</span>

    <span class="s5"># And the rest</span>
    <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">2</span><span class="s0">, </span><span class="s1">item_count + </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(item_count - n + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s0">yield </span><span class="s1">seq[i : i + n]</span>


<span class="s0">def </span><span class="s1">substrings_indexes(seq</span><span class="s0">, </span><span class="s1">reverse=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Yield all substrings and their positions in *seq* 
 
    The items yielded will be a tuple of the form ``(substr, i, j)``, where 
    ``substr == seq[i:j]``. 
 
    This function only works for iterables that support slicing, such as 
    ``str`` objects. 
 
    &gt;&gt;&gt; for item in substrings_indexes('more'): 
    ...    print(item) 
    ('m', 0, 1) 
    ('o', 1, 2) 
    ('r', 2, 3) 
    ('e', 3, 4) 
    ('mo', 0, 2) 
    ('or', 1, 3) 
    ('re', 2, 4) 
    ('mor', 0, 3) 
    ('ore', 1, 4) 
    ('more', 0, 4) 
 
    Set *reverse* to ``True`` to yield the same items in the opposite order. 
 
 
    &quot;&quot;&quot;</span>
    <span class="s1">r = range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">len(seq) + </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">reverse:</span>
        <span class="s1">r = reversed(r)</span>
    <span class="s0">return </span><span class="s1">(</span>
        <span class="s1">(seq[i : i + L]</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">i + L) </span><span class="s0">for </span><span class="s1">L </span><span class="s0">in </span><span class="s1">r </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(seq) - L + </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">)</span>


<span class="s0">class </span><span class="s1">bucket:</span>
    <span class="s3">&quot;&quot;&quot;Wrap *iterable* and return an object that buckets it iterable into 
    child iterables based on a *key* function. 
 
        &gt;&gt;&gt; iterable = ['a1', 'b1', 'c1', 'a2', 'b2', 'c2', 'b3'] 
        &gt;&gt;&gt; s = bucket(iterable, key=lambda x: x[0])  # Bucket by 1st character 
        &gt;&gt;&gt; sorted(list(s))  # Get the keys 
        ['a', 'b', 'c'] 
        &gt;&gt;&gt; a_iterable = s['a'] 
        &gt;&gt;&gt; next(a_iterable) 
        'a1' 
        &gt;&gt;&gt; next(a_iterable) 
        'a2' 
        &gt;&gt;&gt; list(s['b']) 
        ['b1', 'b2', 'b3'] 
 
    The original iterable will be advanced and its items will be cached until 
    they are used by the child iterables. This may require significant storage. 
 
    By default, attempting to select a bucket to which no items belong  will 
    exhaust the iterable and cache all values. 
    If you specify a *validator* function, selected buckets will instead be 
    checked against it. 
 
        &gt;&gt;&gt; from itertools import count 
        &gt;&gt;&gt; it = count(1, 2)  # Infinite sequence of odd numbers 
        &gt;&gt;&gt; key = lambda x: x % 10  # Bucket by last digit 
        &gt;&gt;&gt; validator = lambda x: x in {1, 3, 5, 7, 9}  # Odd digits only 
        &gt;&gt;&gt; s = bucket(it, key=key, validator=validator) 
        &gt;&gt;&gt; 2 in s 
        False 
        &gt;&gt;&gt; list(s[2]) 
        [] 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">iterable</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">validator=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self._it = iter(iterable)</span>
        <span class="s1">self._key = key</span>
        <span class="s1">self._cache = defaultdict(deque)</span>
        <span class="s1">self._validator = validator </span><span class="s0">or </span><span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s0">if not </span><span class="s1">self._validator(value):</span>
            <span class="s0">return False</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">item = next(self[value])</span>
        <span class="s0">except </span><span class="s1">StopIteration:</span>
            <span class="s0">return False</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._cache[value].appendleft(item)</span>

        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">_get_values(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s3">&quot;&quot;&quot; 
        Helper to yield items from the parent iterator that match *value*. 
        Items that don't match are stored in the local cache as they 
        are encountered. 
        &quot;&quot;&quot;</span>
        <span class="s0">while True</span><span class="s1">:</span>
            <span class="s5"># If we've cached some items that match the target value, emit</span>
            <span class="s5"># the first one and evict it from the cache.</span>
            <span class="s0">if </span><span class="s1">self._cache[value]:</span>
                <span class="s0">yield </span><span class="s1">self._cache[value].popleft()</span>
            <span class="s5"># Otherwise we need to advance the parent iterator to search for</span>
            <span class="s5"># a matching item, caching the rest.</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">while True</span><span class="s1">:</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s1">item = next(self._it)</span>
                    <span class="s0">except </span><span class="s1">StopIteration:</span>
                        <span class="s0">return</span>
                    <span class="s1">item_value = self._key(item)</span>
                    <span class="s0">if </span><span class="s1">item_value == value:</span>
                        <span class="s0">yield </span><span class="s1">item</span>
                        <span class="s0">break</span>
                    <span class="s0">elif </span><span class="s1">self._validator(item_value):</span>
                        <span class="s1">self._cache[item_value].append(item)</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">self._it:</span>
            <span class="s1">item_value = self._key(item)</span>
            <span class="s0">if </span><span class="s1">self._validator(item_value):</span>
                <span class="s1">self._cache[item_value].append(item)</span>

        <span class="s0">yield from </span><span class="s1">self._cache.keys()</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s0">if not </span><span class="s1">self._validator(value):</span>
            <span class="s0">return </span><span class="s1">iter(())</span>

        <span class="s0">return </span><span class="s1">self._get_values(value)</span>


<span class="s0">def </span><span class="s1">spy(iterable</span><span class="s0">, </span><span class="s1">n=</span><span class="s4">1</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Return a 2-tuple with a list containing the first *n* elements of 
    *iterable*, and an iterator with the same items as *iterable*. 
    This allows you to &quot;look ahead&quot; at the items in the iterable without 
    advancing it. 
 
    There is one item in the list by default: 
 
        &gt;&gt;&gt; iterable = 'abcdefg' 
        &gt;&gt;&gt; head, iterable = spy(iterable) 
        &gt;&gt;&gt; head 
        ['a'] 
        &gt;&gt;&gt; list(iterable) 
        ['a', 'b', 'c', 'd', 'e', 'f', 'g'] 
 
    You may use unpacking to retrieve items instead of lists: 
 
        &gt;&gt;&gt; (head,), iterable = spy('abcdefg') 
        &gt;&gt;&gt; head 
        'a' 
        &gt;&gt;&gt; (first, second), iterable = spy('abcdefg', 2) 
        &gt;&gt;&gt; first 
        'a' 
        &gt;&gt;&gt; second 
        'b' 
 
    The number of items requested can be larger than the number of items in 
    the iterable: 
 
        &gt;&gt;&gt; iterable = [1, 2, 3, 4, 5] 
        &gt;&gt;&gt; head, iterable = spy(iterable, 10) 
        &gt;&gt;&gt; head 
        [1, 2, 3, 4, 5] 
        &gt;&gt;&gt; list(iterable) 
        [1, 2, 3, 4, 5] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">it = iter(iterable)</span>
    <span class="s1">head = take(n</span><span class="s0">, </span><span class="s1">it)</span>

    <span class="s0">return </span><span class="s1">head.copy()</span><span class="s0">, </span><span class="s1">chain(head</span><span class="s0">, </span><span class="s1">it)</span>


<span class="s0">def </span><span class="s1">interleave(*iterables):</span>
    <span class="s3">&quot;&quot;&quot;Return a new iterable yielding from each iterable in turn, 
    until the shortest is exhausted. 
 
        &gt;&gt;&gt; list(interleave([1, 2, 3], [4, 5], [6, 7, 8])) 
        [1, 4, 6, 2, 5, 7] 
 
    For a version that doesn't terminate after the shortest iterable is 
    exhausted, see :func:`interleave_longest`. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">chain.from_iterable(zip(*iterables))</span>


<span class="s0">def </span><span class="s1">interleave_longest(*iterables):</span>
    <span class="s3">&quot;&quot;&quot;Return a new iterable yielding from each iterable in turn, 
    skipping any that are exhausted. 
 
        &gt;&gt;&gt; list(interleave_longest([1, 2, 3], [4, 5], [6, 7, 8])) 
        [1, 4, 6, 2, 5, 7, 3, 8] 
 
    This function produces the same output as :func:`roundrobin`, but may 
    perform better for some inputs (in particular when the number of iterables 
    is large). 
 
    &quot;&quot;&quot;</span>
    <span class="s1">i = chain.from_iterable(zip_longest(*iterables</span><span class="s0">, </span><span class="s1">fillvalue=_marker))</span>
    <span class="s0">return </span><span class="s1">(x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">i </span><span class="s0">if </span><span class="s1">x </span><span class="s0">is not </span><span class="s1">_marker)</span>


<span class="s0">def </span><span class="s1">collapse(iterable</span><span class="s0">, </span><span class="s1">base_type=</span><span class="s0">None, </span><span class="s1">levels=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Flatten an iterable with multiple levels of nesting (e.g., a list of 
    lists of tuples) into non-iterable types. 
 
        &gt;&gt;&gt; iterable = [(1, 2), ([3, 4], [[5], [6]])] 
        &gt;&gt;&gt; list(collapse(iterable)) 
        [1, 2, 3, 4, 5, 6] 
 
    Binary and text strings are not considered iterable and 
    will not be collapsed. 
 
    To avoid collapsing other types, specify *base_type*: 
 
        &gt;&gt;&gt; iterable = ['ab', ('cd', 'ef'), ['gh', 'ij']] 
        &gt;&gt;&gt; list(collapse(iterable, base_type=tuple)) 
        ['ab', ('cd', 'ef'), 'gh', 'ij'] 
 
    Specify *levels* to stop flattening after a certain level: 
 
    &gt;&gt;&gt; iterable = [('a', ['b']), ('c', ['d'])] 
    &gt;&gt;&gt; list(collapse(iterable))  # Fully flattened 
    ['a', 'b', 'c', 'd'] 
    &gt;&gt;&gt; list(collapse(iterable, levels=1))  # Only one level flattened 
    ['a', ['b'], 'c', ['d']] 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">walk(node</span><span class="s0">, </span><span class="s1">level):</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">((levels </span><span class="s0">is not None</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(level &gt; levels))</span>
            <span class="s0">or </span><span class="s1">isinstance(node</span><span class="s0">, </span><span class="s1">(str</span><span class="s0">, </span><span class="s1">bytes))</span>
            <span class="s0">or </span><span class="s1">((base_type </span><span class="s0">is not None</span><span class="s1">) </span><span class="s0">and </span><span class="s1">isinstance(node</span><span class="s0">, </span><span class="s1">base_type))</span>
        <span class="s1">):</span>
            <span class="s0">yield </span><span class="s1">node</span>
            <span class="s0">return</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">tree = iter(node)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">yield </span><span class="s1">node</span>
            <span class="s0">return</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">child </span><span class="s0">in </span><span class="s1">tree:</span>
                <span class="s0">yield from </span><span class="s1">walk(child</span><span class="s0">, </span><span class="s1">level + </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">yield from </span><span class="s1">walk(iterable</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">side_effect(func</span><span class="s0">, </span><span class="s1">iterable</span><span class="s0">, </span><span class="s1">chunk_size=</span><span class="s0">None, </span><span class="s1">before=</span><span class="s0">None, </span><span class="s1">after=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Invoke *func* on each item in *iterable* (or on each *chunk_size* group 
    of items) before yielding the item. 
 
    `func` must be a function that takes a single argument. Its return value 
    will be discarded. 
 
    *before* and *after* are optional functions that take no arguments. They 
    will be executed before iteration starts and after it ends, respectively. 
 
    `side_effect` can be used for logging, updating progress bars, or anything 
    that is not functionally &quot;pure.&quot; 
 
    Emitting a status message: 
 
        &gt;&gt;&gt; from more_itertools import consume 
        &gt;&gt;&gt; func = lambda item: print('Received {}'.format(item)) 
        &gt;&gt;&gt; consume(side_effect(func, range(2))) 
        Received 0 
        Received 1 
 
    Operating on chunks of items: 
 
        &gt;&gt;&gt; pair_sums = [] 
        &gt;&gt;&gt; func = lambda chunk: pair_sums.append(sum(chunk)) 
        &gt;&gt;&gt; list(side_effect(func, [0, 1, 2, 3, 4, 5], 2)) 
        [0, 1, 2, 3, 4, 5] 
        &gt;&gt;&gt; list(pair_sums) 
        [1, 5, 9] 
 
    Writing to a file-like object: 
 
        &gt;&gt;&gt; from io import StringIO 
        &gt;&gt;&gt; from more_itertools import consume 
        &gt;&gt;&gt; f = StringIO() 
        &gt;&gt;&gt; func = lambda x: print(x, file=f) 
        &gt;&gt;&gt; before = lambda: print(u'HEADER', file=f) 
        &gt;&gt;&gt; after = f.close 
        &gt;&gt;&gt; it = [u'a', u'b', u'c'] 
        &gt;&gt;&gt; consume(side_effect(func, it, before=before, after=after)) 
        &gt;&gt;&gt; f.closed 
        True 
 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">before </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">before()</span>

        <span class="s0">if </span><span class="s1">chunk_size </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">iterable:</span>
                <span class="s1">func(item)</span>
                <span class="s0">yield </span><span class="s1">item</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">chunk </span><span class="s0">in </span><span class="s1">chunked(iterable</span><span class="s0">, </span><span class="s1">chunk_size):</span>
                <span class="s1">func(chunk)</span>
                <span class="s0">yield from </span><span class="s1">chunk</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">after </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">after()</span>


<span class="s0">def </span><span class="s1">sliced(seq</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">strict=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Yield slices of length *n* from the sequence *seq*. 
 
    &gt;&gt;&gt; list(sliced((1, 2, 3, 4, 5, 6), 3)) 
    [(1, 2, 3), (4, 5, 6)] 
 
    By the default, the last yielded slice will have fewer than *n* elements 
    if the length of *seq* is not divisible by *n*: 
 
    &gt;&gt;&gt; list(sliced((1, 2, 3, 4, 5, 6, 7, 8), 3)) 
    [(1, 2, 3), (4, 5, 6), (7, 8)] 
 
    If the length of *seq* is not divisible by *n* and *strict* is 
    ``True``, then ``ValueError`` will be raised before the last 
    slice is yielded. 
 
    This function will only work for iterables that support slicing. 
    For non-sliceable iterables, see :func:`chunked`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">iterator = takewhile(len</span><span class="s0">, </span><span class="s1">(seq[i : i + n] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">count(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">n)))</span>
    <span class="s0">if </span><span class="s1">strict:</span>

        <span class="s0">def </span><span class="s1">ret():</span>
            <span class="s0">for </span><span class="s1">_slice </span><span class="s0">in </span><span class="s1">iterator:</span>
                <span class="s0">if </span><span class="s1">len(_slice) != n:</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;seq is not divisible by n.&quot;</span><span class="s1">)</span>
                <span class="s0">yield </span><span class="s1">_slice</span>

        <span class="s0">return </span><span class="s1">iter(ret())</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">iterator</span>


<span class="s0">def </span><span class="s1">split_at(iterable</span><span class="s0">, </span><span class="s1">pred</span><span class="s0">, </span><span class="s1">maxsplit=-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">keep_separator=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Yield lists of items from *iterable*, where each list is delimited by 
    an item where callable *pred* returns ``True``. 
 
        &gt;&gt;&gt; list(split_at('abcdcba', lambda x: x == 'b')) 
        [['a'], ['c', 'd', 'c'], ['a']] 
 
        &gt;&gt;&gt; list(split_at(range(10), lambda n: n % 2 == 1)) 
        [[0], [2], [4], [6], [8], []] 
 
    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1, 
    then there is no limit on the number of splits: 
 
        &gt;&gt;&gt; list(split_at(range(10), lambda n: n % 2 == 1, maxsplit=2)) 
        [[0], [2], [4, 5, 6, 7, 8, 9]] 
 
    By default, the delimiting items are not included in the output. 
    The include them, set *keep_separator* to ``True``. 
 
        &gt;&gt;&gt; list(split_at('abcdcba', lambda x: x == 'b', keep_separator=True)) 
        [['a'], ['b'], ['c', 'd', 'c'], ['b'], ['a']] 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">maxsplit == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">yield </span><span class="s1">list(iterable)</span>
        <span class="s0">return</span>

    <span class="s1">buf = []</span>
    <span class="s1">it = iter(iterable)</span>
    <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">it:</span>
        <span class="s0">if </span><span class="s1">pred(item):</span>
            <span class="s0">yield </span><span class="s1">buf</span>
            <span class="s0">if </span><span class="s1">keep_separator:</span>
                <span class="s0">yield </span><span class="s1">[item]</span>
            <span class="s0">if </span><span class="s1">maxsplit == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s0">yield </span><span class="s1">list(it)</span>
                <span class="s0">return</span>
            <span class="s1">buf = []</span>
            <span class="s1">maxsplit -= </span><span class="s4">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">buf.append(item)</span>
    <span class="s0">yield </span><span class="s1">buf</span>


<span class="s0">def </span><span class="s1">split_before(iterable</span><span class="s0">, </span><span class="s1">pred</span><span class="s0">, </span><span class="s1">maxsplit=-</span><span class="s4">1</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Yield lists of items from *iterable*, where each list ends just before 
    an item for which callable *pred* returns ``True``: 
 
        &gt;&gt;&gt; list(split_before('OneTwo', lambda s: s.isupper())) 
        [['O', 'n', 'e'], ['T', 'w', 'o']] 
 
        &gt;&gt;&gt; list(split_before(range(10), lambda n: n % 3 == 0)) 
        [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]] 
 
    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1, 
    then there is no limit on the number of splits: 
 
        &gt;&gt;&gt; list(split_before(range(10), lambda n: n % 3 == 0, maxsplit=2)) 
        [[0, 1, 2], [3, 4, 5], [6, 7, 8, 9]] 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">maxsplit == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">yield </span><span class="s1">list(iterable)</span>
        <span class="s0">return</span>

    <span class="s1">buf = []</span>
    <span class="s1">it = iter(iterable)</span>
    <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">it:</span>
        <span class="s0">if </span><span class="s1">pred(item) </span><span class="s0">and </span><span class="s1">buf:</span>
            <span class="s0">yield </span><span class="s1">buf</span>
            <span class="s0">if </span><span class="s1">maxsplit == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s0">yield </span><span class="s1">[item] + list(it)</span>
                <span class="s0">return</span>
            <span class="s1">buf = []</span>
            <span class="s1">maxsplit -= </span><span class="s4">1</span>
        <span class="s1">buf.append(item)</span>
    <span class="s0">if </span><span class="s1">buf:</span>
        <span class="s0">yield </span><span class="s1">buf</span>


<span class="s0">def </span><span class="s1">split_after(iterable</span><span class="s0">, </span><span class="s1">pred</span><span class="s0">, </span><span class="s1">maxsplit=-</span><span class="s4">1</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Yield lists of items from *iterable*, where each list ends with an 
    item where callable *pred* returns ``True``: 
 
        &gt;&gt;&gt; list(split_after('one1two2', lambda s: s.isdigit())) 
        [['o', 'n', 'e', '1'], ['t', 'w', 'o', '2']] 
 
        &gt;&gt;&gt; list(split_after(range(10), lambda n: n % 3 == 0)) 
        [[0], [1, 2, 3], [4, 5, 6], [7, 8, 9]] 
 
    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1, 
    then there is no limit on the number of splits: 
 
        &gt;&gt;&gt; list(split_after(range(10), lambda n: n % 3 == 0, maxsplit=2)) 
        [[0], [1, 2, 3], [4, 5, 6, 7, 8, 9]] 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">maxsplit == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">yield </span><span class="s1">list(iterable)</span>
        <span class="s0">return</span>

    <span class="s1">buf = []</span>
    <span class="s1">it = iter(iterable)</span>
    <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">it:</span>
        <span class="s1">buf.append(item)</span>
        <span class="s0">if </span><span class="s1">pred(item) </span><span class="s0">and </span><span class="s1">buf:</span>
            <span class="s0">yield </span><span class="s1">buf</span>
            <span class="s0">if </span><span class="s1">maxsplit == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s0">yield </span><span class="s1">list(it)</span>
                <span class="s0">return</span>
            <span class="s1">buf = []</span>
            <span class="s1">maxsplit -= </span><span class="s4">1</span>
    <span class="s0">if </span><span class="s1">buf:</span>
        <span class="s0">yield </span><span class="s1">buf</span>


<span class="s0">def </span><span class="s1">split_when(iterable</span><span class="s0">, </span><span class="s1">pred</span><span class="s0">, </span><span class="s1">maxsplit=-</span><span class="s4">1</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Split *iterable* into pieces based on the output of *pred*. 
    *pred* should be a function that takes successive pairs of items and 
    returns ``True`` if the iterable should be split in between them. 
 
    For example, to find runs of increasing numbers, split the iterable when 
    element ``i`` is larger than element ``i + 1``: 
 
        &gt;&gt;&gt; list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2], lambda x, y: x &gt; y)) 
        [[1, 2, 3, 3], [2, 5], [2, 4], [2]] 
 
    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1, 
    then there is no limit on the number of splits: 
 
        &gt;&gt;&gt; list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2], 
        ...                 lambda x, y: x &gt; y, maxsplit=2)) 
        [[1, 2, 3, 3], [2, 5], [2, 4, 2]] 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">maxsplit == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">yield </span><span class="s1">list(iterable)</span>
        <span class="s0">return</span>

    <span class="s1">it = iter(iterable)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">cur_item = next(it)</span>
    <span class="s0">except </span><span class="s1">StopIteration:</span>
        <span class="s0">return</span>

    <span class="s1">buf = [cur_item]</span>
    <span class="s0">for </span><span class="s1">next_item </span><span class="s0">in </span><span class="s1">it:</span>
        <span class="s0">if </span><span class="s1">pred(cur_item</span><span class="s0">, </span><span class="s1">next_item):</span>
            <span class="s0">yield </span><span class="s1">buf</span>
            <span class="s0">if </span><span class="s1">maxsplit == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s0">yield </span><span class="s1">[next_item] + list(it)</span>
                <span class="s0">return</span>
            <span class="s1">buf = []</span>
            <span class="s1">maxsplit -= </span><span class="s4">1</span>

        <span class="s1">buf.append(next_item)</span>
        <span class="s1">cur_item = next_item</span>

    <span class="s0">yield </span><span class="s1">buf</span>


<span class="s0">def </span><span class="s1">split_into(iterable</span><span class="s0">, </span><span class="s1">sizes):</span>
    <span class="s3">&quot;&quot;&quot;Yield a list of sequential items from *iterable* of length 'n' for each 
    integer 'n' in *sizes*. 
 
        &gt;&gt;&gt; list(split_into([1,2,3,4,5,6], [1,2,3])) 
        [[1], [2, 3], [4, 5, 6]] 
 
    If the sum of *sizes* is smaller than the length of *iterable*, then the 
    remaining items of *iterable* will not be returned. 
 
        &gt;&gt;&gt; list(split_into([1,2,3,4,5,6], [2,3])) 
        [[1, 2], [3, 4, 5]] 
 
    If the sum of *sizes* is larger than the length of *iterable*, fewer items 
    will be returned in the iteration that overruns *iterable* and further 
    lists will be empty: 
 
        &gt;&gt;&gt; list(split_into([1,2,3,4], [1,2,3,4])) 
        [[1], [2, 3], [4], []] 
 
    When a ``None`` object is encountered in *sizes*, the returned list will 
    contain items up to the end of *iterable* the same way that itertools.slice 
    does: 
 
        &gt;&gt;&gt; list(split_into([1,2,3,4,5,6,7,8,9,0], [2,3,None])) 
        [[1, 2], [3, 4, 5], [6, 7, 8, 9, 0]] 
 
    :func:`split_into` can be useful for grouping a series of items where the 
    sizes of the groups are not uniform. An example would be where in a row 
    from a table, multiple columns represent elements of the same feature 
    (e.g. a point represented by x,y,z) but, the format is not the same for 
    all columns. 
    &quot;&quot;&quot;</span>
    <span class="s5"># convert the iterable argument into an iterator so its contents can</span>
    <span class="s5"># be consumed by islice in case it is a generator</span>
    <span class="s1">it = iter(iterable)</span>

    <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">sizes:</span>
        <span class="s0">if </span><span class="s1">size </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">yield </span><span class="s1">list(it)</span>
            <span class="s0">return</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">yield </span><span class="s1">list(islice(it</span><span class="s0">, </span><span class="s1">size))</span>


<span class="s0">def </span><span class="s1">padded(iterable</span><span class="s0">, </span><span class="s1">fillvalue=</span><span class="s0">None, </span><span class="s1">n=</span><span class="s0">None, </span><span class="s1">next_multiple=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Yield the elements from *iterable*, followed by *fillvalue*, such that 
    at least *n* items are emitted. 
 
        &gt;&gt;&gt; list(padded([1, 2, 3], '?', 5)) 
        [1, 2, 3, '?', '?'] 
 
    If *next_multiple* is ``True``, *fillvalue* will be emitted until the 
    number of items emitted is a multiple of *n*:: 
 
        &gt;&gt;&gt; list(padded([1, 2, 3, 4], n=3, next_multiple=True)) 
        [1, 2, 3, 4, None, None] 
 
    If *n* is ``None``, *fillvalue* will be emitted indefinitely. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">it = iter(iterable)</span>
    <span class="s0">if </span><span class="s1">n </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">yield from </span><span class="s1">chain(it</span><span class="s0">, </span><span class="s1">repeat(fillvalue))</span>
    <span class="s0">elif </span><span class="s1">n &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'n must be at least 1'</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">item_count = </span><span class="s4">0</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">it:</span>
            <span class="s0">yield </span><span class="s1">item</span>
            <span class="s1">item_count += </span><span class="s4">1</span>

        <span class="s1">remaining = (n - item_count) % n </span><span class="s0">if </span><span class="s1">next_multiple </span><span class="s0">else </span><span class="s1">n - item_count</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(remaining):</span>
            <span class="s0">yield </span><span class="s1">fillvalue</span>


<span class="s0">def </span><span class="s1">repeat_last(iterable</span><span class="s0">, </span><span class="s1">default=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;After the *iterable* is exhausted, keep yielding its last element. 
 
        &gt;&gt;&gt; list(islice(repeat_last(range(3)), 5)) 
        [0, 1, 2, 2, 2] 
 
    If the iterable is empty, yield *default* forever:: 
 
        &gt;&gt;&gt; list(islice(repeat_last(range(0), 42), 5)) 
        [42, 42, 42, 42, 42] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">item = _marker</span>
    <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">iterable:</span>
        <span class="s0">yield </span><span class="s1">item</span>
    <span class="s1">final = default </span><span class="s0">if </span><span class="s1">item </span><span class="s0">is </span><span class="s1">_marker </span><span class="s0">else </span><span class="s1">item</span>
    <span class="s0">yield from </span><span class="s1">repeat(final)</span>


<span class="s0">def </span><span class="s1">distribute(n</span><span class="s0">, </span><span class="s1">iterable):</span>
    <span class="s3">&quot;&quot;&quot;Distribute the items from *iterable* among *n* smaller iterables. 
 
        &gt;&gt;&gt; group_1, group_2 = distribute(2, [1, 2, 3, 4, 5, 6]) 
        &gt;&gt;&gt; list(group_1) 
        [1, 3, 5] 
        &gt;&gt;&gt; list(group_2) 
        [2, 4, 6] 
 
    If the length of *iterable* is not evenly divisible by *n*, then the 
    length of the returned iterables will not be identical: 
 
        &gt;&gt;&gt; children = distribute(3, [1, 2, 3, 4, 5, 6, 7]) 
        &gt;&gt;&gt; [list(c) for c in children] 
        [[1, 4, 7], [2, 5], [3, 6]] 
 
    If the length of *iterable* is smaller than *n*, then the last returned 
    iterables will be empty: 
 
        &gt;&gt;&gt; children = distribute(5, [1, 2, 3]) 
        &gt;&gt;&gt; [list(c) for c in children] 
        [[1], [2], [3], [], []] 
 
    This function uses :func:`itertools.tee` and may require significant 
    storage. If you need the order items in the smaller iterables to match the 
    original iterable, see :func:`divide`. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">n &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'n must be at least 1'</span><span class="s1">)</span>

    <span class="s1">children = tee(iterable</span><span class="s0">, </span><span class="s1">n)</span>
    <span class="s0">return </span><span class="s1">[islice(it</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, None, </span><span class="s1">n) </span><span class="s0">for </span><span class="s1">index</span><span class="s0">, </span><span class="s1">it </span><span class="s0">in </span><span class="s1">enumerate(children)]</span>


<span class="s0">def </span><span class="s1">stagger(iterable</span><span class="s0">, </span><span class="s1">offsets=(-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">longest=</span><span class="s0">False, </span><span class="s1">fillvalue=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Yield tuples whose elements are offset from *iterable*. 
    The amount by which the `i`-th item in each tuple is offset is given by 
    the `i`-th item in *offsets*. 
 
        &gt;&gt;&gt; list(stagger([0, 1, 2, 3])) 
        [(None, 0, 1), (0, 1, 2), (1, 2, 3)] 
        &gt;&gt;&gt; list(stagger(range(8), offsets=(0, 2, 4))) 
        [(0, 2, 4), (1, 3, 5), (2, 4, 6), (3, 5, 7)] 
 
    By default, the sequence will end when the final element of a tuple is the 
    last item in the iterable. To continue until the first element of a tuple 
    is the last item in the iterable, set *longest* to ``True``:: 
 
        &gt;&gt;&gt; list(stagger([0, 1, 2, 3], longest=True)) 
        [(None, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, None), (3, None, None)] 
 
    By default, ``None`` will be used to replace offsets beyond the end of the 
    sequence. Specify *fillvalue* to use some other value. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">children = tee(iterable</span><span class="s0">, </span><span class="s1">len(offsets))</span>

    <span class="s0">return </span><span class="s1">zip_offset(</span>
        <span class="s1">*children</span><span class="s0">, </span><span class="s1">offsets=offsets</span><span class="s0">, </span><span class="s1">longest=longest</span><span class="s0">, </span><span class="s1">fillvalue=fillvalue</span>
    <span class="s1">)</span>


<span class="s0">class </span><span class="s1">UnequalIterablesError(ValueError):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">details=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">msg = </span><span class="s2">'Iterables have different lengths'</span>
        <span class="s0">if </span><span class="s1">details </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">msg += (</span><span class="s2">': index 0 has length {}; index {} has length {}'</span><span class="s1">).format(</span>
                <span class="s1">*details</span>
            <span class="s1">)</span>

        <span class="s1">super().__init__(msg)</span>


<span class="s0">def </span><span class="s1">_zip_equal_generator(iterables):</span>
    <span class="s0">for </span><span class="s1">combo </span><span class="s0">in </span><span class="s1">zip_longest(*iterables</span><span class="s0">, </span><span class="s1">fillvalue=_marker):</span>
        <span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">combo:</span>
            <span class="s0">if </span><span class="s1">val </span><span class="s0">is </span><span class="s1">_marker:</span>
                <span class="s0">raise </span><span class="s1">UnequalIterablesError()</span>
        <span class="s0">yield </span><span class="s1">combo</span>


<span class="s0">def </span><span class="s1">zip_equal(*iterables):</span>
    <span class="s3">&quot;&quot;&quot;``zip`` the input *iterables* together, but raise 
    ``UnequalIterablesError`` if they aren't all the same length. 
 
        &gt;&gt;&gt; it_1 = range(3) 
        &gt;&gt;&gt; it_2 = iter('abc') 
        &gt;&gt;&gt; list(zip_equal(it_1, it_2)) 
        [(0, 'a'), (1, 'b'), (2, 'c')] 
 
        &gt;&gt;&gt; it_1 = range(3) 
        &gt;&gt;&gt; it_2 = iter('abcd') 
        &gt;&gt;&gt; list(zip_equal(it_1, it_2)) # doctest: +IGNORE_EXCEPTION_DETAIL 
        Traceback (most recent call last): 
        ... 
        more_itertools.more.UnequalIterablesError: Iterables have different 
        lengths 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">hexversion &gt;= </span><span class="s4">0x30A00A6</span><span class="s1">:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s1">(</span>
                <span class="s2">'zip_equal will be removed in a future version of '</span>
                <span class="s2">'more-itertools. Use the builtin zip function with '</span>
                <span class="s2">'strict=True instead.'</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">DeprecationWarning</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s5"># Check whether the iterables are all the same size.</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">first_size = len(iterables[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">it </span><span class="s0">in </span><span class="s1">enumerate(iterables[</span><span class="s4">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">size = len(it)</span>
            <span class="s0">if </span><span class="s1">size != first_size:</span>
                <span class="s0">break</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># If we didn't break out, we can use the built-in zip.</span>
            <span class="s0">return </span><span class="s1">zip(*iterables)</span>

        <span class="s5"># If we did break out, there was a mismatch.</span>
        <span class="s0">raise </span><span class="s1">UnequalIterablesError(details=(first_size</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">size))</span>
    <span class="s5"># If any one of the iterables didn't have a length, start reading</span>
    <span class="s5"># them until one runs out.</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">return </span><span class="s1">_zip_equal_generator(iterables)</span>


<span class="s0">def </span><span class="s1">zip_offset(*iterables</span><span class="s0">, </span><span class="s1">offsets</span><span class="s0">, </span><span class="s1">longest=</span><span class="s0">False, </span><span class="s1">fillvalue=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;``zip`` the input *iterables* together, but offset the `i`-th iterable 
    by the `i`-th item in *offsets*. 
 
        &gt;&gt;&gt; list(zip_offset('0123', 'abcdef', offsets=(0, 1))) 
        [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e')] 
 
    This can be used as a lightweight alternative to SciPy or pandas to analyze 
    data sets in which some series have a lead or lag relationship. 
 
    By default, the sequence will end when the shortest iterable is exhausted. 
    To continue until the longest iterable is exhausted, set *longest* to 
    ``True``. 
 
        &gt;&gt;&gt; list(zip_offset('0123', 'abcdef', offsets=(0, 1), longest=True)) 
        [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e'), (None, 'f')] 
 
    By default, ``None`` will be used to replace offsets beyond the end of the 
    sequence. Specify *fillvalue* to use some other value. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">len(iterables) != len(offsets):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Number of iterables and offsets didn't match&quot;</span><span class="s1">)</span>

    <span class="s1">staggered = []</span>
    <span class="s0">for </span><span class="s1">it</span><span class="s0">, </span><span class="s1">n </span><span class="s0">in </span><span class="s1">zip(iterables</span><span class="s0">, </span><span class="s1">offsets):</span>
        <span class="s0">if </span><span class="s1">n &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">staggered.append(chain(repeat(fillvalue</span><span class="s0">, </span><span class="s1">-n)</span><span class="s0">, </span><span class="s1">it))</span>
        <span class="s0">elif </span><span class="s1">n &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">staggered.append(islice(it</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, None</span><span class="s1">))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">staggered.append(it)</span>

    <span class="s0">if </span><span class="s1">longest:</span>
        <span class="s0">return </span><span class="s1">zip_longest(*staggered</span><span class="s0">, </span><span class="s1">fillvalue=fillvalue)</span>

    <span class="s0">return </span><span class="s1">zip(*staggered)</span>


<span class="s0">def </span><span class="s1">sort_together(iterables</span><span class="s0">, </span><span class="s1">key_list=(</span><span class="s4">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">None, </span><span class="s1">reverse=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Return the input iterables sorted together, with *key_list* as the 
    priority for sorting. All iterables are trimmed to the length of the 
    shortest one. 
 
    This can be used like the sorting function in a spreadsheet. If each 
    iterable represents a column of data, the key list determines which 
    columns are used for sorting. 
 
    By default, all iterables are sorted using the ``0``-th iterable:: 
 
        &gt;&gt;&gt; iterables = [(4, 3, 2, 1), ('a', 'b', 'c', 'd')] 
        &gt;&gt;&gt; sort_together(iterables) 
        [(1, 2, 3, 4), ('d', 'c', 'b', 'a')] 
 
    Set a different key list to sort according to another iterable. 
    Specifying multiple keys dictates how ties are broken:: 
 
        &gt;&gt;&gt; iterables = [(3, 1, 2), (0, 1, 0), ('c', 'b', 'a')] 
        &gt;&gt;&gt; sort_together(iterables, key_list=(1, 2)) 
        [(2, 3, 1), (0, 0, 1), ('a', 'c', 'b')] 
 
    To sort by a function of the elements of the iterable, pass a *key* 
    function. Its arguments are the elements of the iterables corresponding to 
    the key list:: 
 
        &gt;&gt;&gt; names = ('a', 'b', 'c') 
        &gt;&gt;&gt; lengths = (1, 2, 3) 
        &gt;&gt;&gt; widths = (5, 2, 1) 
        &gt;&gt;&gt; def area(length, width): 
        ...     return length * width 
        &gt;&gt;&gt; sort_together([names, lengths, widths], key_list=(1, 2), key=area) 
        [('c', 'b', 'a'), (3, 2, 1), (1, 2, 5)] 
 
    Set *reverse* to ``True`` to sort in descending order. 
 
        &gt;&gt;&gt; sort_together([(1, 2, 3), ('c', 'b', 'a')], reverse=True) 
        [(3, 2, 1), ('a', 'b', 'c')] 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">key </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s5"># if there is no key function, the key argument to sorted is an</span>
        <span class="s5"># itemgetter</span>
        <span class="s1">key_argument = itemgetter(*key_list)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s5"># if there is a key function, call it with the items at the offsets</span>
        <span class="s5"># specified by the key function as arguments</span>
        <span class="s1">key_list = list(key_list)</span>
        <span class="s0">if </span><span class="s1">len(key_list) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s5"># if key_list contains a single item, pass the item at that offset</span>
            <span class="s5"># as the only argument to the key function</span>
            <span class="s1">key_offset = key_list[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">key_argument = </span><span class="s0">lambda </span><span class="s1">zipped_items: key(zipped_items[key_offset])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># if key_list contains multiple items, use itemgetter to return a</span>
            <span class="s5"># tuple of items, which we pass as *args to the key function</span>
            <span class="s1">get_key_items = itemgetter(*key_list)</span>
            <span class="s1">key_argument = </span><span class="s0">lambda </span><span class="s1">zipped_items: key(</span>
                <span class="s1">*get_key_items(zipped_items)</span>
            <span class="s1">)</span>

    <span class="s0">return </span><span class="s1">list(</span>
        <span class="s1">zip(*sorted(zip(*iterables)</span><span class="s0">, </span><span class="s1">key=key_argument</span><span class="s0">, </span><span class="s1">reverse=reverse))</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">unzip(iterable):</span>
    <span class="s3">&quot;&quot;&quot;The inverse of :func:`zip`, this function disaggregates the elements 
    of the zipped *iterable*. 
 
    The ``i``-th iterable contains the ``i``-th element from each element 
    of the zipped iterable. The first element is used to to determine the 
    length of the remaining elements. 
 
        &gt;&gt;&gt; iterable = [('a', 1), ('b', 2), ('c', 3), ('d', 4)] 
        &gt;&gt;&gt; letters, numbers = unzip(iterable) 
        &gt;&gt;&gt; list(letters) 
        ['a', 'b', 'c', 'd'] 
        &gt;&gt;&gt; list(numbers) 
        [1, 2, 3, 4] 
 
    This is similar to using ``zip(*iterable)``, but it avoids reading 
    *iterable* into memory. Note, however, that this function uses 
    :func:`itertools.tee` and thus may require significant storage. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">head</span><span class="s0">, </span><span class="s1">iterable = spy(iter(iterable))</span>
    <span class="s0">if not </span><span class="s1">head:</span>
        <span class="s5"># empty iterable, e.g. zip([], [], [])</span>
        <span class="s0">return </span><span class="s1">()</span>
    <span class="s5"># spy returns a one-length iterable as head</span>
    <span class="s1">head = head[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">iterables = tee(iterable</span><span class="s0">, </span><span class="s1">len(head))</span>

    <span class="s0">def </span><span class="s1">itemgetter(i):</span>
        <span class="s0">def </span><span class="s1">getter(obj):</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">obj[i]</span>
            <span class="s0">except </span><span class="s1">IndexError:</span>
                <span class="s5"># basically if we have an iterable like</span>
                <span class="s5"># iter([(1, 2, 3), (4, 5), (6,)])</span>
                <span class="s5"># the second unzipped iterable would fail at the third tuple</span>
                <span class="s5"># since it would try to access tup[1]</span>
                <span class="s5"># same with the third unzipped iterable and the second tuple</span>
                <span class="s5"># to support these &quot;improperly zipped&quot; iterables,</span>
                <span class="s5"># we create a custom itemgetter</span>
                <span class="s5"># which just stops the unzipped iterables</span>
                <span class="s5"># at first length mismatch</span>
                <span class="s0">raise </span><span class="s1">StopIteration</span>

        <span class="s0">return </span><span class="s1">getter</span>

    <span class="s0">return </span><span class="s1">tuple(map(itemgetter(i)</span><span class="s0">, </span><span class="s1">it) </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">it </span><span class="s0">in </span><span class="s1">enumerate(iterables))</span>


<span class="s0">def </span><span class="s1">divide(n</span><span class="s0">, </span><span class="s1">iterable):</span>
    <span class="s3">&quot;&quot;&quot;Divide the elements from *iterable* into *n* parts, maintaining 
    order. 
 
        &gt;&gt;&gt; group_1, group_2 = divide(2, [1, 2, 3, 4, 5, 6]) 
        &gt;&gt;&gt; list(group_1) 
        [1, 2, 3] 
        &gt;&gt;&gt; list(group_2) 
        [4, 5, 6] 
 
    If the length of *iterable* is not evenly divisible by *n*, then the 
    length of the returned iterables will not be identical: 
 
        &gt;&gt;&gt; children = divide(3, [1, 2, 3, 4, 5, 6, 7]) 
        &gt;&gt;&gt; [list(c) for c in children] 
        [[1, 2, 3], [4, 5], [6, 7]] 
 
    If the length of the iterable is smaller than n, then the last returned 
    iterables will be empty: 
 
        &gt;&gt;&gt; children = divide(5, [1, 2, 3]) 
        &gt;&gt;&gt; [list(c) for c in children] 
        [[1], [2], [3], [], []] 
 
    This function will exhaust the iterable before returning and may require 
    significant storage. If order is not important, see :func:`distribute`, 
    which does not first pull the iterable into memory. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">n &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'n must be at least 1'</span><span class="s1">)</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">iterable[:</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s1">seq = tuple(iterable)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">seq = iterable</span>

    <span class="s1">q</span><span class="s0">, </span><span class="s1">r = divmod(len(seq)</span><span class="s0">, </span><span class="s1">n)</span>

    <span class="s1">ret = []</span>
    <span class="s1">stop = </span><span class="s4">0</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">n + </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">start = stop</span>
        <span class="s1">stop += q + </span><span class="s4">1 </span><span class="s0">if </span><span class="s1">i &lt;= r </span><span class="s0">else </span><span class="s1">q</span>
        <span class="s1">ret.append(iter(seq[start:stop]))</span>

    <span class="s0">return </span><span class="s1">ret</span>


<span class="s0">def </span><span class="s1">always_iterable(obj</span><span class="s0">, </span><span class="s1">base_type=(str</span><span class="s0">, </span><span class="s1">bytes)):</span>
    <span class="s3">&quot;&quot;&quot;If *obj* is iterable, return an iterator over its items:: 
 
        &gt;&gt;&gt; obj = (1, 2, 3) 
        &gt;&gt;&gt; list(always_iterable(obj)) 
        [1, 2, 3] 
 
    If *obj* is not iterable, return a one-item iterable containing *obj*:: 
 
        &gt;&gt;&gt; obj = 1 
        &gt;&gt;&gt; list(always_iterable(obj)) 
        [1] 
 
    If *obj* is ``None``, return an empty iterable: 
 
        &gt;&gt;&gt; obj = None 
        &gt;&gt;&gt; list(always_iterable(None)) 
        [] 
 
    By default, binary and text strings are not considered iterable:: 
 
        &gt;&gt;&gt; obj = 'foo' 
        &gt;&gt;&gt; list(always_iterable(obj)) 
        ['foo'] 
 
    If *base_type* is set, objects for which ``isinstance(obj, base_type)`` 
    returns ``True`` won't be considered iterable. 
 
        &gt;&gt;&gt; obj = {'a': 1} 
        &gt;&gt;&gt; list(always_iterable(obj))  # Iterate over the dict's keys 
        ['a'] 
        &gt;&gt;&gt; list(always_iterable(obj, base_type=dict))  # Treat dicts as a unit 
        [{'a': 1}] 
 
    Set *base_type* to ``None`` to avoid any special handling and treat objects 
    Python considers iterable as iterable: 
 
        &gt;&gt;&gt; obj = 'foo' 
        &gt;&gt;&gt; list(always_iterable(obj, base_type=None)) 
        ['f', 'o', 'o'] 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">obj </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">iter(())</span>

    <span class="s0">if </span><span class="s1">(base_type </span><span class="s0">is not None</span><span class="s1">) </span><span class="s0">and </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">base_type):</span>
        <span class="s0">return </span><span class="s1">iter((obj</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">iter(obj)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">return </span><span class="s1">iter((obj</span><span class="s0">,</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">adjacent(predicate</span><span class="s0">, </span><span class="s1">iterable</span><span class="s0">, </span><span class="s1">distance=</span><span class="s4">1</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Return an iterable over `(bool, item)` tuples where the `item` is 
    drawn from *iterable* and the `bool` indicates whether 
    that item satisfies the *predicate* or is adjacent to an item that does. 
 
    For example, to find whether items are adjacent to a ``3``:: 
 
        &gt;&gt;&gt; list(adjacent(lambda x: x == 3, range(6))) 
        [(False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5)] 
 
    Set *distance* to change what counts as adjacent. For example, to find 
    whether items are two places away from a ``3``: 
 
        &gt;&gt;&gt; list(adjacent(lambda x: x == 3, range(6), distance=2)) 
        [(False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5)] 
 
    This is useful for contextualizing the results of a search function. 
    For example, a code comparison tool might want to identify lines that 
    have changed, but also surrounding lines to give the viewer of the diff 
    context. 
 
    The predicate function will only be called once for each item in the 
    iterable. 
 
    See also :func:`groupby_transform`, which can be used with this function 
    to group ranges of items with the same `bool` value. 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># Allow distance=0 mainly for testing that it reproduces results with map()</span>
    <span class="s0">if </span><span class="s1">distance &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'distance must be at least 0'</span><span class="s1">)</span>

    <span class="s1">i1</span><span class="s0">, </span><span class="s1">i2 = tee(iterable)</span>
    <span class="s1">padding = [</span><span class="s0">False</span><span class="s1">] * distance</span>
    <span class="s1">selected = chain(padding</span><span class="s0">, </span><span class="s1">map(predicate</span><span class="s0">, </span><span class="s1">i1)</span><span class="s0">, </span><span class="s1">padding)</span>
    <span class="s1">adjacent_to_selected = map(any</span><span class="s0">, </span><span class="s1">windowed(selected</span><span class="s0">, </span><span class="s4">2 </span><span class="s1">* distance + </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s0">return </span><span class="s1">zip(adjacent_to_selected</span><span class="s0">, </span><span class="s1">i2)</span>


<span class="s0">def </span><span class="s1">groupby_transform(iterable</span><span class="s0">, </span><span class="s1">keyfunc=</span><span class="s0">None, </span><span class="s1">valuefunc=</span><span class="s0">None, </span><span class="s1">reducefunc=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;An extension of :func:`itertools.groupby` that can apply transformations 
    to the grouped data. 
 
    * *keyfunc* is a function computing a key value for each item in *iterable* 
    * *valuefunc* is a function that transforms the individual items from 
      *iterable* after grouping 
    * *reducefunc* is a function that transforms each group of items 
 
    &gt;&gt;&gt; iterable = 'aAAbBBcCC' 
    &gt;&gt;&gt; keyfunc = lambda k: k.upper() 
    &gt;&gt;&gt; valuefunc = lambda v: v.lower() 
    &gt;&gt;&gt; reducefunc = lambda g: ''.join(g) 
    &gt;&gt;&gt; list(groupby_transform(iterable, keyfunc, valuefunc, reducefunc)) 
    [('A', 'aaa'), ('B', 'bbb'), ('C', 'ccc')] 
 
    Each optional argument defaults to an identity function if not specified. 
 
    :func:`groupby_transform` is useful when grouping elements of an iterable 
    using a separate iterable as the key. To do this, :func:`zip` the iterables 
    and pass a *keyfunc* that extracts the first element and a *valuefunc* 
    that extracts the second element:: 
 
        &gt;&gt;&gt; from operator import itemgetter 
        &gt;&gt;&gt; keys = [0, 0, 1, 1, 1, 2, 2, 2, 3] 
        &gt;&gt;&gt; values = 'abcdefghi' 
        &gt;&gt;&gt; iterable = zip(keys, values) 
        &gt;&gt;&gt; grouper = groupby_transform(iterable, itemgetter(0), itemgetter(1)) 
        &gt;&gt;&gt; [(k, ''.join(g)) for k, g in grouper] 
        [(0, 'ab'), (1, 'cde'), (2, 'fgh'), (3, 'i')] 
 
    Note that the order of items in the iterable is significant. 
    Only adjacent items are grouped together, so if you don't want any 
    duplicate groups, you should sort the iterable by the key function. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">ret = groupby(iterable</span><span class="s0">, </span><span class="s1">keyfunc)</span>
    <span class="s0">if </span><span class="s1">valuefunc:</span>
        <span class="s1">ret = ((k</span><span class="s0">, </span><span class="s1">map(valuefunc</span><span class="s0">, </span><span class="s1">g)) </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">g </span><span class="s0">in </span><span class="s1">ret)</span>
    <span class="s0">if </span><span class="s1">reducefunc:</span>
        <span class="s1">ret = ((k</span><span class="s0">, </span><span class="s1">reducefunc(g)) </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">g </span><span class="s0">in </span><span class="s1">ret)</span>

    <span class="s0">return </span><span class="s1">ret</span>


<span class="s0">class </span><span class="s1">numeric_range(abc.Sequence</span><span class="s0">, </span><span class="s1">abc.Hashable):</span>
    <span class="s3">&quot;&quot;&quot;An extension of the built-in ``range()`` function whose arguments can 
    be any orderable numeric type. 
 
    With only *stop* specified, *start* defaults to ``0`` and *step* 
    defaults to ``1``. The output items will match the type of *stop*: 
 
        &gt;&gt;&gt; list(numeric_range(3.5)) 
        [0.0, 1.0, 2.0, 3.0] 
 
    With only *start* and *stop* specified, *step* defaults to ``1``. The 
    output items will match the type of *start*: 
 
        &gt;&gt;&gt; from decimal import Decimal 
        &gt;&gt;&gt; start = Decimal('2.1') 
        &gt;&gt;&gt; stop = Decimal('5.1') 
        &gt;&gt;&gt; list(numeric_range(start, stop)) 
        [Decimal('2.1'), Decimal('3.1'), Decimal('4.1')] 
 
    With *start*, *stop*, and *step*  specified the output items will match 
    the type of ``start + step``: 
 
        &gt;&gt;&gt; from fractions import Fraction 
        &gt;&gt;&gt; start = Fraction(1, 2)  # Start at 1/2 
        &gt;&gt;&gt; stop = Fraction(5, 2)  # End at 5/2 
        &gt;&gt;&gt; step = Fraction(1, 2)  # Count by 1/2 
        &gt;&gt;&gt; list(numeric_range(start, stop, step)) 
        [Fraction(1, 2), Fraction(1, 1), Fraction(3, 2), Fraction(2, 1)] 
 
    If *step* is zero, ``ValueError`` is raised. Negative steps are supported: 
 
        &gt;&gt;&gt; list(numeric_range(3, -1, -1.0)) 
        [3.0, 2.0, 1.0, 0.0] 
 
    Be aware of the limitations of floating point numbers; the representation 
    of the yielded numbers may be surprising. 
 
    ``datetime.datetime`` objects can be used for *start* and *stop*, if *step* 
    is a ``datetime.timedelta`` object: 
 
        &gt;&gt;&gt; import datetime 
        &gt;&gt;&gt; start = datetime.datetime(2019, 1, 1) 
        &gt;&gt;&gt; stop = datetime.datetime(2019, 1, 3) 
        &gt;&gt;&gt; step = datetime.timedelta(days=1) 
        &gt;&gt;&gt; items = iter(numeric_range(start, stop, step)) 
        &gt;&gt;&gt; next(items) 
        datetime.datetime(2019, 1, 1, 0, 0) 
        &gt;&gt;&gt; next(items) 
        datetime.datetime(2019, 1, 2, 0, 0) 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_EMPTY_HASH = hash(range(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">argc = len(args)</span>
        <span class="s0">if </span><span class="s1">argc == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">(self._stop</span><span class="s0">,</span><span class="s1">) = args</span>
            <span class="s1">self._start = type(self._stop)(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">self._step = type(self._stop - self._start)(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">argc == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">self._start</span><span class="s0">, </span><span class="s1">self._stop = args</span>
            <span class="s1">self._step = type(self._stop - self._start)(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">argc == </span><span class="s4">3</span><span class="s1">:</span>
            <span class="s1">self._start</span><span class="s0">, </span><span class="s1">self._stop</span><span class="s0">, </span><span class="s1">self._step = args</span>
        <span class="s0">elif </span><span class="s1">argc == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s2">'numeric_range expected at least '</span>
                <span class="s2">'1 argument, got {}'</span><span class="s1">.format(argc)</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s2">'numeric_range expected at most '</span>
                <span class="s2">'3 arguments, got {}'</span><span class="s1">.format(argc)</span>
            <span class="s1">)</span>

        <span class="s1">self._zero = type(self._step)(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self._step == self._zero:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'numeric_range() arg 3 must not be zero'</span><span class="s1">)</span>
        <span class="s1">self._growing = self._step &gt; self._zero</span>
        <span class="s1">self._init_len()</span>

    <span class="s0">def </span><span class="s1">__bool__(self):</span>
        <span class="s0">if </span><span class="s1">self._growing:</span>
            <span class="s0">return </span><span class="s1">self._start &lt; self._stop</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._start &gt; self._stop</span>

    <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">elem):</span>
        <span class="s0">if </span><span class="s1">self._growing:</span>
            <span class="s0">if </span><span class="s1">self._start &lt;= elem &lt; self._stop:</span>
                <span class="s0">return </span><span class="s1">(elem - self._start) % self._step == self._zero</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self._start &gt;= elem &gt; self._stop:</span>
                <span class="s0">return </span><span class="s1">(self._start - elem) % (-self._step) == self._zero</span>

        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">numeric_range):</span>
            <span class="s1">empty_self = </span><span class="s0">not </span><span class="s1">bool(self)</span>
            <span class="s1">empty_other = </span><span class="s0">not </span><span class="s1">bool(other)</span>
            <span class="s0">if </span><span class="s1">empty_self </span><span class="s0">or </span><span class="s1">empty_other:</span>
                <span class="s0">return </span><span class="s1">empty_self </span><span class="s0">and </span><span class="s1">empty_other  </span><span class="s5"># True if both empty</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">(</span>
                    <span class="s1">self._start == other._start</span>
                    <span class="s0">and </span><span class="s1">self._step == other._step</span>
                    <span class="s0">and </span><span class="s1">self._get_by_index(-</span><span class="s4">1</span><span class="s1">) == other._get_by_index(-</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">int):</span>
            <span class="s0">return </span><span class="s1">self._get_by_index(key)</span>
        <span class="s0">elif </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">slice):</span>
            <span class="s1">step = self._step </span><span class="s0">if </span><span class="s1">key.step </span><span class="s0">is None else </span><span class="s1">key.step * self._step</span>

            <span class="s0">if </span><span class="s1">key.start </span><span class="s0">is None or </span><span class="s1">key.start &lt;= -self._len:</span>
                <span class="s1">start = self._start</span>
            <span class="s0">elif </span><span class="s1">key.start &gt;= self._len:</span>
                <span class="s1">start = self._stop</span>
            <span class="s0">else</span><span class="s1">:  </span><span class="s5"># -self._len &lt; key.start &lt; self._len</span>
                <span class="s1">start = self._get_by_index(key.start)</span>

            <span class="s0">if </span><span class="s1">key.stop </span><span class="s0">is None or </span><span class="s1">key.stop &gt;= self._len:</span>
                <span class="s1">stop = self._stop</span>
            <span class="s0">elif </span><span class="s1">key.stop &lt;= -self._len:</span>
                <span class="s1">stop = self._start</span>
            <span class="s0">else</span><span class="s1">:  </span><span class="s5"># -self._len &lt; key.stop &lt; self._len</span>
                <span class="s1">stop = self._get_by_index(key.stop)</span>

            <span class="s0">return </span><span class="s1">numeric_range(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s2">'numeric range indices must be '</span>
                <span class="s2">'integers or slices, not {}'</span><span class="s1">.format(type(key).__name__)</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__hash__(self):</span>
        <span class="s0">if </span><span class="s1">self:</span>
            <span class="s0">return </span><span class="s1">hash((self._start</span><span class="s0">, </span><span class="s1">self._get_by_index(-</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">self._step))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._EMPTY_HASH</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s1">values = (self._start + (n * self._step) </span><span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">count())</span>
        <span class="s0">if </span><span class="s1">self._growing:</span>
            <span class="s0">return </span><span class="s1">takewhile(partial(gt</span><span class="s0">, </span><span class="s1">self._stop)</span><span class="s0">, </span><span class="s1">values)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">takewhile(partial(lt</span><span class="s0">, </span><span class="s1">self._stop)</span><span class="s0">, </span><span class="s1">values)</span>

    <span class="s0">def </span><span class="s1">__len__(self):</span>
        <span class="s0">return </span><span class="s1">self._len</span>

    <span class="s0">def </span><span class="s1">_init_len(self):</span>
        <span class="s0">if </span><span class="s1">self._growing:</span>
            <span class="s1">start = self._start</span>
            <span class="s1">stop = self._stop</span>
            <span class="s1">step = self._step</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">start = self._stop</span>
            <span class="s1">stop = self._start</span>
            <span class="s1">step = -self._step</span>
        <span class="s1">distance = stop - start</span>
        <span class="s0">if </span><span class="s1">distance &lt;= self._zero:</span>
            <span class="s1">self._len = </span><span class="s4">0</span>
        <span class="s0">else</span><span class="s1">:  </span><span class="s5"># distance &gt; 0 and step &gt; 0: regular euclidean division</span>
            <span class="s1">q</span><span class="s0">, </span><span class="s1">r = divmod(distance</span><span class="s0">, </span><span class="s1">step)</span>
            <span class="s1">self._len = int(q) + int(r != self._zero)</span>

    <span class="s0">def </span><span class="s1">__reduce__(self):</span>
        <span class="s0">return </span><span class="s1">numeric_range</span><span class="s0">, </span><span class="s1">(self._start</span><span class="s0">, </span><span class="s1">self._stop</span><span class="s0">, </span><span class="s1">self._step)</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">if </span><span class="s1">self._step == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s2">&quot;numeric_range({}, {})&quot;</span><span class="s1">.format(</span>
                <span class="s1">repr(self._start)</span><span class="s0">, </span><span class="s1">repr(self._stop)</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s2">&quot;numeric_range({}, {}, {})&quot;</span><span class="s1">.format(</span>
                <span class="s1">repr(self._start)</span><span class="s0">, </span><span class="s1">repr(self._stop)</span><span class="s0">, </span><span class="s1">repr(self._step)</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__reversed__(self):</span>
        <span class="s0">return </span><span class="s1">iter(</span>
            <span class="s1">numeric_range(</span>
                <span class="s1">self._get_by_index(-</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">self._start - self._step</span><span class="s0">, </span><span class="s1">-self._step</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">count(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s0">return </span><span class="s1">int(value </span><span class="s0">in </span><span class="s1">self)</span>

    <span class="s0">def </span><span class="s1">index(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s0">if </span><span class="s1">self._growing:</span>
            <span class="s0">if </span><span class="s1">self._start &lt;= value &lt; self._stop:</span>
                <span class="s1">q</span><span class="s0">, </span><span class="s1">r = divmod(value - self._start</span><span class="s0">, </span><span class="s1">self._step)</span>
                <span class="s0">if </span><span class="s1">r == self._zero:</span>
                    <span class="s0">return </span><span class="s1">int(q)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self._start &gt;= value &gt; self._stop:</span>
                <span class="s1">q</span><span class="s0">, </span><span class="s1">r = divmod(self._start - value</span><span class="s0">, </span><span class="s1">-self._step)</span>
                <span class="s0">if </span><span class="s1">r == self._zero:</span>
                    <span class="s0">return </span><span class="s1">int(q)</span>

        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;{} is not in numeric range&quot;</span><span class="s1">.format(value))</span>

    <span class="s0">def </span><span class="s1">_get_by_index(self</span><span class="s0">, </span><span class="s1">i):</span>
        <span class="s0">if </span><span class="s1">i &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">i += self._len</span>
        <span class="s0">if </span><span class="s1">i &lt; </span><span class="s4">0 </span><span class="s0">or </span><span class="s1">i &gt;= self._len:</span>
            <span class="s0">raise </span><span class="s1">IndexError(</span><span class="s2">&quot;numeric range object index out of range&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._start + i * self._step</span>


<span class="s0">def </span><span class="s1">count_cycle(iterable</span><span class="s0">, </span><span class="s1">n=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Cycle through the items from *iterable* up to *n* times, yielding 
    the number of completed cycles along with each item. If *n* is omitted the 
    process repeats indefinitely. 
 
    &gt;&gt;&gt; list(count_cycle('AB', 3)) 
    [(0, 'A'), (0, 'B'), (1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">iterable = tuple(iterable)</span>
    <span class="s0">if not </span><span class="s1">iterable:</span>
        <span class="s0">return </span><span class="s1">iter(())</span>
    <span class="s1">counter = count() </span><span class="s0">if </span><span class="s1">n </span><span class="s0">is None else </span><span class="s1">range(n)</span>
    <span class="s0">return </span><span class="s1">((i</span><span class="s0">, </span><span class="s1">item) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">counter </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">iterable)</span>


<span class="s0">def </span><span class="s1">mark_ends(iterable):</span>
    <span class="s3">&quot;&quot;&quot;Yield 3-tuples of the form ``(is_first, is_last, item)``. 
 
    &gt;&gt;&gt; list(mark_ends('ABC')) 
    [(True, False, 'A'), (False, False, 'B'), (False, True, 'C')] 
 
    Use this when looping over an iterable to take special action on its first 
    and/or last items: 
 
    &gt;&gt;&gt; iterable = ['Header', 100, 200, 'Footer'] 
    &gt;&gt;&gt; total = 0 
    &gt;&gt;&gt; for is_first, is_last, item in mark_ends(iterable): 
    ...     if is_first: 
    ...         continue  # Skip the header 
    ...     if is_last: 
    ...         continue  # Skip the footer 
    ...     total += item 
    &gt;&gt;&gt; print(total) 
    300 
    &quot;&quot;&quot;</span>
    <span class="s1">it = iter(iterable)</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">b = next(it)</span>
    <span class="s0">except </span><span class="s1">StopIteration:</span>
        <span class="s0">return</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">count():</span>
            <span class="s1">a = b</span>
            <span class="s1">b = next(it)</span>
            <span class="s0">yield </span><span class="s1">i == </span><span class="s4">0</span><span class="s0">, False, </span><span class="s1">a</span>

    <span class="s0">except </span><span class="s1">StopIteration:</span>
        <span class="s0">yield </span><span class="s1">i == </span><span class="s4">0</span><span class="s0">, True, </span><span class="s1">a</span>


<span class="s0">def </span><span class="s1">locate(iterable</span><span class="s0">, </span><span class="s1">pred=bool</span><span class="s0">, </span><span class="s1">window_size=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Yield the index of each item in *iterable* for which *pred* returns 
    ``True``. 
 
    *pred* defaults to :func:`bool`, which will select truthy items: 
 
        &gt;&gt;&gt; list(locate([0, 1, 1, 0, 1, 0, 0])) 
        [1, 2, 4] 
 
    Set *pred* to a custom function to, e.g., find the indexes for a particular 
    item. 
 
        &gt;&gt;&gt; list(locate(['a', 'b', 'c', 'b'], lambda x: x == 'b')) 
        [1, 3] 
 
    If *window_size* is given, then the *pred* function will be called with 
    that many items. This enables searching for sub-sequences: 
 
        &gt;&gt;&gt; iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3] 
        &gt;&gt;&gt; pred = lambda *args: args == (1, 2, 3) 
        &gt;&gt;&gt; list(locate(iterable, pred=pred, window_size=3)) 
        [1, 5, 9] 
 
    Use with :func:`seekable` to find indexes and then retrieve the associated 
    items: 
 
        &gt;&gt;&gt; from itertools import count 
        &gt;&gt;&gt; from more_itertools import seekable 
        &gt;&gt;&gt; source = (3 * n + 1 if (n % 2) else n // 2 for n in count()) 
        &gt;&gt;&gt; it = seekable(source) 
        &gt;&gt;&gt; pred = lambda x: x &gt; 100 
        &gt;&gt;&gt; indexes = locate(it, pred=pred) 
        &gt;&gt;&gt; i = next(indexes) 
        &gt;&gt;&gt; it.seek(i) 
        &gt;&gt;&gt; next(it) 
        106 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">window_size </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">compress(count()</span><span class="s0">, </span><span class="s1">map(pred</span><span class="s0">, </span><span class="s1">iterable))</span>

    <span class="s0">if </span><span class="s1">window_size &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'window size must be at least 1'</span><span class="s1">)</span>

    <span class="s1">it = windowed(iterable</span><span class="s0">, </span><span class="s1">window_size</span><span class="s0">, </span><span class="s1">fillvalue=_marker)</span>
    <span class="s0">return </span><span class="s1">compress(count()</span><span class="s0">, </span><span class="s1">starmap(pred</span><span class="s0">, </span><span class="s1">it))</span>


<span class="s0">def </span><span class="s1">lstrip(iterable</span><span class="s0">, </span><span class="s1">pred):</span>
    <span class="s3">&quot;&quot;&quot;Yield the items from *iterable*, but strip any from the beginning 
    for which *pred* returns ``True``. 
 
    For example, to remove a set of items from the start of an iterable: 
 
        &gt;&gt;&gt; iterable = (None, False, None, 1, 2, None, 3, False, None) 
        &gt;&gt;&gt; pred = lambda x: x in {None, False, ''} 
        &gt;&gt;&gt; list(lstrip(iterable, pred)) 
        [1, 2, None, 3, False, None] 
 
    This function is analogous to to :func:`str.lstrip`, and is essentially 
    an wrapper for :func:`itertools.dropwhile`. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">dropwhile(pred</span><span class="s0">, </span><span class="s1">iterable)</span>


<span class="s0">def </span><span class="s1">rstrip(iterable</span><span class="s0">, </span><span class="s1">pred):</span>
    <span class="s3">&quot;&quot;&quot;Yield the items from *iterable*, but strip any from the end 
    for which *pred* returns ``True``. 
 
    For example, to remove a set of items from the end of an iterable: 
 
        &gt;&gt;&gt; iterable = (None, False, None, 1, 2, None, 3, False, None) 
        &gt;&gt;&gt; pred = lambda x: x in {None, False, ''} 
        &gt;&gt;&gt; list(rstrip(iterable, pred)) 
        [None, False, None, 1, 2, None, 3] 
 
    This function is analogous to :func:`str.rstrip`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">cache = []</span>
    <span class="s1">cache_append = cache.append</span>
    <span class="s1">cache_clear = cache.clear</span>
    <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">iterable:</span>
        <span class="s0">if </span><span class="s1">pred(x):</span>
            <span class="s1">cache_append(x)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">yield from </span><span class="s1">cache</span>
            <span class="s1">cache_clear()</span>
            <span class="s0">yield </span><span class="s1">x</span>


<span class="s0">def </span><span class="s1">strip(iterable</span><span class="s0">, </span><span class="s1">pred):</span>
    <span class="s3">&quot;&quot;&quot;Yield the items from *iterable*, but strip any from the 
    beginning and end for which *pred* returns ``True``. 
 
    For example, to remove a set of items from both ends of an iterable: 
 
        &gt;&gt;&gt; iterable = (None, False, None, 1, 2, None, 3, False, None) 
        &gt;&gt;&gt; pred = lambda x: x in {None, False, ''} 
        &gt;&gt;&gt; list(strip(iterable, pred)) 
        [1, 2, None, 3] 
 
    This function is analogous to :func:`str.strip`. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">rstrip(lstrip(iterable</span><span class="s0">, </span><span class="s1">pred)</span><span class="s0">, </span><span class="s1">pred)</span>


<span class="s0">class </span><span class="s1">islice_extended:</span>
    <span class="s3">&quot;&quot;&quot;An extension of :func:`itertools.islice` that supports negative values 
    for *stop*, *start*, and *step*. 
 
        &gt;&gt;&gt; iterable = iter('abcdefgh') 
        &gt;&gt;&gt; list(islice_extended(iterable, -4, -1)) 
        ['e', 'f', 'g'] 
 
    Slices with negative values require some caching of *iterable*, but this 
    function takes care to minimize the amount of memory required. 
 
    For example, you can use a negative step with an infinite iterator: 
 
        &gt;&gt;&gt; from itertools import count 
        &gt;&gt;&gt; list(islice_extended(count(), 110, 99, -2)) 
        [110, 108, 106, 104, 102, 100] 
 
    You can also use slice notation directly: 
 
        &gt;&gt;&gt; iterable = map(str, count()) 
        &gt;&gt;&gt; it = islice_extended(iterable)[10:20:2] 
        &gt;&gt;&gt; list(it) 
        ['10', '12', '14', '16', '18'] 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">iterable</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">it = iter(iterable)</span>
        <span class="s0">if </span><span class="s1">args:</span>
            <span class="s1">self._iterable = _islice_helper(it</span><span class="s0">, </span><span class="s1">slice(*args))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._iterable = it</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__next__(self):</span>
        <span class="s0">return </span><span class="s1">next(self._iterable)</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">slice):</span>
            <span class="s0">return </span><span class="s1">islice_extended(_islice_helper(self._iterable</span><span class="s0">, </span><span class="s1">key))</span>

        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">'islice_extended.__getitem__ argument must be a slice'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_islice_helper(it</span><span class="s0">, </span><span class="s1">s):</span>
    <span class="s1">start = s.start</span>
    <span class="s1">stop = s.stop</span>
    <span class="s0">if </span><span class="s1">s.step == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'step argument must be a non-zero integer or None.'</span><span class="s1">)</span>
    <span class="s1">step = s.step </span><span class="s0">or </span><span class="s4">1</span>

    <span class="s0">if </span><span class="s1">step &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">start = </span><span class="s4">0 </span><span class="s0">if </span><span class="s1">(start </span><span class="s0">is None</span><span class="s1">) </span><span class="s0">else </span><span class="s1">start</span>

        <span class="s0">if </span><span class="s1">start &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s5"># Consume all but the last -start items</span>
            <span class="s1">cache = deque(enumerate(it</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">maxlen=-start)</span>
            <span class="s1">len_iter = cache[-</span><span class="s4">1</span><span class="s1">][</span><span class="s4">0</span><span class="s1">] </span><span class="s0">if </span><span class="s1">cache </span><span class="s0">else </span><span class="s4">0</span>

            <span class="s5"># Adjust start to be positive</span>
            <span class="s1">i = max(len_iter + start</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>

            <span class="s5"># Adjust stop to be positive</span>
            <span class="s0">if </span><span class="s1">stop </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">j = len_iter</span>
            <span class="s0">elif </span><span class="s1">stop &gt;= </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">j = min(stop</span><span class="s0">, </span><span class="s1">len_iter)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">j = max(len_iter + stop</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>

            <span class="s5"># Slice the cache</span>
            <span class="s1">n = j - i</span>
            <span class="s0">if </span><span class="s1">n &lt;= </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s0">return</span>

            <span class="s0">for </span><span class="s1">index</span><span class="s0">, </span><span class="s1">item </span><span class="s0">in </span><span class="s1">islice(cache</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">step):</span>
                <span class="s0">yield </span><span class="s1">item</span>
        <span class="s0">elif </span><span class="s1">(stop </span><span class="s0">is not None</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(stop &lt; </span><span class="s4">0</span><span class="s1">):</span>
            <span class="s5"># Advance to the start position</span>
            <span class="s1">next(islice(it</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">start)</span><span class="s0">, None</span><span class="s1">)</span>

            <span class="s5"># When stop is negative, we have to carry -stop items while</span>
            <span class="s5"># iterating</span>
            <span class="s1">cache = deque(islice(it</span><span class="s0">, </span><span class="s1">-stop)</span><span class="s0">, </span><span class="s1">maxlen=-stop)</span>

            <span class="s0">for </span><span class="s1">index</span><span class="s0">, </span><span class="s1">item </span><span class="s0">in </span><span class="s1">enumerate(it):</span>
                <span class="s1">cached_item = cache.popleft()</span>
                <span class="s0">if </span><span class="s1">index % step == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s0">yield </span><span class="s1">cached_item</span>
                <span class="s1">cache.append(item)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># When both start and stop are positive we have the normal case</span>
            <span class="s0">yield from </span><span class="s1">islice(it</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">step)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">start = -</span><span class="s4">1 </span><span class="s0">if </span><span class="s1">(start </span><span class="s0">is None</span><span class="s1">) </span><span class="s0">else </span><span class="s1">start</span>

        <span class="s0">if </span><span class="s1">(stop </span><span class="s0">is not None</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(stop &lt; </span><span class="s4">0</span><span class="s1">):</span>
            <span class="s5"># Consume all but the last items</span>
            <span class="s1">n = -stop - </span><span class="s4">1</span>
            <span class="s1">cache = deque(enumerate(it</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">maxlen=n)</span>
            <span class="s1">len_iter = cache[-</span><span class="s4">1</span><span class="s1">][</span><span class="s4">0</span><span class="s1">] </span><span class="s0">if </span><span class="s1">cache </span><span class="s0">else </span><span class="s4">0</span>

            <span class="s5"># If start and stop are both negative they are comparable and</span>
            <span class="s5"># we can just slice. Otherwise we can adjust start to be negative</span>
            <span class="s5"># and then slice.</span>
            <span class="s0">if </span><span class="s1">start &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">i</span><span class="s0">, </span><span class="s1">j = start</span><span class="s0">, </span><span class="s1">stop</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">i</span><span class="s0">, </span><span class="s1">j = min(start - len_iter</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, None</span>

            <span class="s0">for </span><span class="s1">index</span><span class="s0">, </span><span class="s1">item </span><span class="s0">in </span><span class="s1">list(cache)[i:j:step]:</span>
                <span class="s0">yield </span><span class="s1">item</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># Advance to the stop position</span>
            <span class="s0">if </span><span class="s1">stop </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">m = stop + </span><span class="s4">1</span>
                <span class="s1">next(islice(it</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">m)</span><span class="s0">, None</span><span class="s1">)</span>

            <span class="s5"># stop is positive, so if start is negative they are not comparable</span>
            <span class="s5"># and we need the rest of the items.</span>
            <span class="s0">if </span><span class="s1">start &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">i = start</span>
                <span class="s1">n = </span><span class="s0">None</span>
            <span class="s5"># stop is None and start is positive, so we just need items up to</span>
            <span class="s5"># the start index.</span>
            <span class="s0">elif </span><span class="s1">stop </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">i = </span><span class="s0">None</span>
                <span class="s1">n = start + </span><span class="s4">1</span>
            <span class="s5"># Both stop and start are positive, so they are comparable.</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">i = </span><span class="s0">None</span>
                <span class="s1">n = start - stop</span>
                <span class="s0">if </span><span class="s1">n &lt;= </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s0">return</span>

            <span class="s1">cache = list(islice(it</span><span class="s0">, </span><span class="s1">n))</span>

            <span class="s0">yield from </span><span class="s1">cache[i::step]</span>


<span class="s0">def </span><span class="s1">always_reversible(iterable):</span>
    <span class="s3">&quot;&quot;&quot;An extension of :func:`reversed` that supports all iterables, not 
    just those which implement the ``Reversible`` or ``Sequence`` protocols. 
 
        &gt;&gt;&gt; print(*always_reversible(x for x in range(3))) 
        2 1 0 
 
    If the iterable is already reversible, this function returns the 
    result of :func:`reversed()`. If the iterable is not reversible, 
    this function will cache the remaining items in the iterable and 
    yield them in reverse order, which may require significant storage. 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">reversed(iterable)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">return </span><span class="s1">reversed(list(iterable))</span>


<span class="s0">def </span><span class="s1">consecutive_groups(iterable</span><span class="s0">, </span><span class="s1">ordering=</span><span class="s0">lambda </span><span class="s1">x: x):</span>
    <span class="s3">&quot;&quot;&quot;Yield groups of consecutive items using :func:`itertools.groupby`. 
    The *ordering* function determines whether two items are adjacent by 
    returning their position. 
 
    By default, the ordering function is the identity function. This is 
    suitable for finding runs of numbers: 
 
        &gt;&gt;&gt; iterable = [1, 10, 11, 12, 20, 30, 31, 32, 33, 40] 
        &gt;&gt;&gt; for group in consecutive_groups(iterable): 
        ...     print(list(group)) 
        [1] 
        [10, 11, 12] 
        [20] 
        [30, 31, 32, 33] 
        [40] 
 
    For finding runs of adjacent letters, try using the :meth:`index` method 
    of a string of letters: 
 
        &gt;&gt;&gt; from string import ascii_lowercase 
        &gt;&gt;&gt; iterable = 'abcdfgilmnop' 
        &gt;&gt;&gt; ordering = ascii_lowercase.index 
        &gt;&gt;&gt; for group in consecutive_groups(iterable, ordering): 
        ...     print(list(group)) 
        ['a', 'b', 'c', 'd'] 
        ['f', 'g'] 
        ['i'] 
        ['l', 'm', 'n', 'o', 'p'] 
 
    Each group of consecutive items is an iterator that shares it source with 
    *iterable*. When an an output group is advanced, the previous group is 
    no longer available unless its elements are copied (e.g., into a ``list``). 
 
        &gt;&gt;&gt; iterable = [1, 2, 11, 12, 21, 22] 
        &gt;&gt;&gt; saved_groups = [] 
        &gt;&gt;&gt; for group in consecutive_groups(iterable): 
        ...     saved_groups.append(list(group))  # Copy group elements 
        &gt;&gt;&gt; saved_groups 
        [[1, 2], [11, 12], [21, 22]] 
 
    &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">g </span><span class="s0">in </span><span class="s1">groupby(</span>
        <span class="s1">enumerate(iterable)</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">lambda </span><span class="s1">x: x[</span><span class="s4">0</span><span class="s1">] - ordering(x[</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">):</span>
        <span class="s0">yield </span><span class="s1">map(itemgetter(</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">g)</span>


<span class="s0">def </span><span class="s1">difference(iterable</span><span class="s0">, </span><span class="s1">func=sub</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">initial=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;This function is the inverse of :func:`itertools.accumulate`. By default 
    it will compute the first difference of *iterable* using 
    :func:`operator.sub`: 
 
        &gt;&gt;&gt; from itertools import accumulate 
        &gt;&gt;&gt; iterable = accumulate([0, 1, 2, 3, 4])  # produces 0, 1, 3, 6, 10 
        &gt;&gt;&gt; list(difference(iterable)) 
        [0, 1, 2, 3, 4] 
 
    *func* defaults to :func:`operator.sub`, but other functions can be 
    specified. They will be applied as follows:: 
 
        A, B, C, D, ... --&gt; A, func(B, A), func(C, B), func(D, C), ... 
 
    For example, to do progressive division: 
 
        &gt;&gt;&gt; iterable = [1, 2, 6, 24, 120] 
        &gt;&gt;&gt; func = lambda x, y: x // y 
        &gt;&gt;&gt; list(difference(iterable, func)) 
        [1, 2, 3, 4, 5] 
 
    If the *initial* keyword is set, the first element will be skipped when 
    computing successive differences. 
 
        &gt;&gt;&gt; it = [10, 11, 13, 16]  # from accumulate([1, 2, 3], initial=10) 
        &gt;&gt;&gt; list(difference(it, initial=10)) 
        [1, 2, 3] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = tee(iterable)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">first = [next(b)]</span>
    <span class="s0">except </span><span class="s1">StopIteration:</span>
        <span class="s0">return </span><span class="s1">iter([])</span>

    <span class="s0">if </span><span class="s1">initial </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">first = []</span>

    <span class="s0">return </span><span class="s1">chain(first</span><span class="s0">, </span><span class="s1">starmap(func</span><span class="s0">, </span><span class="s1">zip(b</span><span class="s0">, </span><span class="s1">a)))</span>


<span class="s0">class </span><span class="s1">SequenceView(Sequence):</span>
    <span class="s3">&quot;&quot;&quot;Return a read-only view of the sequence object *target*. 
 
    :class:`SequenceView` objects are analogous to Python's built-in 
    &quot;dictionary view&quot; types. They provide a dynamic view of a sequence's items, 
    meaning that when the sequence updates, so does the view. 
 
        &gt;&gt;&gt; seq = ['0', '1', '2'] 
        &gt;&gt;&gt; view = SequenceView(seq) 
        &gt;&gt;&gt; view 
        SequenceView(['0', '1', '2']) 
        &gt;&gt;&gt; seq.append('3') 
        &gt;&gt;&gt; view 
        SequenceView(['0', '1', '2', '3']) 
 
    Sequence views support indexing, slicing, and length queries. They act 
    like the underlying sequence, except they don't allow assignment: 
 
        &gt;&gt;&gt; view[1] 
        '1' 
        &gt;&gt;&gt; view[1:-1] 
        ['1', '2'] 
        &gt;&gt;&gt; len(view) 
        4 
 
    Sequence views are useful as an alternative to copying, as they don't 
    require (much) extra storage. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">target):</span>
        <span class="s0">if not </span><span class="s1">isinstance(target</span><span class="s0">, </span><span class="s1">Sequence):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span>
        <span class="s1">self._target = target</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s0">return </span><span class="s1">self._target[index]</span>

    <span class="s0">def </span><span class="s1">__len__(self):</span>
        <span class="s0">return </span><span class="s1">len(self._target)</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s2">'{}({})'</span><span class="s1">.format(self.__class__.__name__</span><span class="s0">, </span><span class="s1">repr(self._target))</span>


<span class="s0">class </span><span class="s1">seekable:</span>
    <span class="s3">&quot;&quot;&quot;Wrap an iterator to allow for seeking backward and forward. This 
    progressively caches the items in the source iterable so they can be 
    re-visited. 
 
    Call :meth:`seek` with an index to seek to that position in the source 
    iterable. 
 
    To &quot;reset&quot; an iterator, seek to ``0``: 
 
        &gt;&gt;&gt; from itertools import count 
        &gt;&gt;&gt; it = seekable((str(n) for n in count())) 
        &gt;&gt;&gt; next(it), next(it), next(it) 
        ('0', '1', '2') 
        &gt;&gt;&gt; it.seek(0) 
        &gt;&gt;&gt; next(it), next(it), next(it) 
        ('0', '1', '2') 
        &gt;&gt;&gt; next(it) 
        '3' 
 
    You can also seek forward: 
 
        &gt;&gt;&gt; it = seekable((str(n) for n in range(20))) 
        &gt;&gt;&gt; it.seek(10) 
        &gt;&gt;&gt; next(it) 
        '10' 
        &gt;&gt;&gt; it.seek(20)  # Seeking past the end of the source isn't a problem 
        &gt;&gt;&gt; list(it) 
        [] 
        &gt;&gt;&gt; it.seek(0)  # Resetting works even after hitting the end 
        &gt;&gt;&gt; next(it), next(it), next(it) 
        ('0', '1', '2') 
 
    Call :meth:`peek` to look ahead one item without advancing the iterator: 
 
        &gt;&gt;&gt; it = seekable('1234') 
        &gt;&gt;&gt; it.peek() 
        '1' 
        &gt;&gt;&gt; list(it) 
        ['1', '2', '3', '4'] 
        &gt;&gt;&gt; it.peek(default='empty') 
        'empty' 
 
    Before the iterator is at its end, calling :func:`bool` on it will return 
    ``True``. After it will return ``False``: 
 
        &gt;&gt;&gt; it = seekable('5678') 
        &gt;&gt;&gt; bool(it) 
        True 
        &gt;&gt;&gt; list(it) 
        ['5', '6', '7', '8'] 
        &gt;&gt;&gt; bool(it) 
        False 
 
    You may view the contents of the cache with the :meth:`elements` method. 
    That returns a :class:`SequenceView`, a view that updates automatically: 
 
        &gt;&gt;&gt; it = seekable((str(n) for n in range(10))) 
        &gt;&gt;&gt; next(it), next(it), next(it) 
        ('0', '1', '2') 
        &gt;&gt;&gt; elements = it.elements() 
        &gt;&gt;&gt; elements 
        SequenceView(['0', '1', '2']) 
        &gt;&gt;&gt; next(it) 
        '3' 
        &gt;&gt;&gt; elements 
        SequenceView(['0', '1', '2', '3']) 
 
    By default, the cache grows as the source iterable progresses, so beware of 
    wrapping very large or infinite iterables. Supply *maxlen* to limit the 
    size of the cache (this of course limits how far back you can seek). 
 
        &gt;&gt;&gt; from itertools import count 
        &gt;&gt;&gt; it = seekable((str(n) for n in count()), maxlen=2) 
        &gt;&gt;&gt; next(it), next(it), next(it), next(it) 
        ('0', '1', '2', '3') 
        &gt;&gt;&gt; list(it.elements()) 
        ['2', '3'] 
        &gt;&gt;&gt; it.seek(0) 
        &gt;&gt;&gt; next(it), next(it), next(it), next(it) 
        ('2', '3', '4', '5') 
        &gt;&gt;&gt; next(it) 
        '6' 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">iterable</span><span class="s0">, </span><span class="s1">maxlen=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self._source = iter(iterable)</span>
        <span class="s0">if </span><span class="s1">maxlen </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self._cache = []</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._cache = deque([]</span><span class="s0">, </span><span class="s1">maxlen)</span>
        <span class="s1">self._index = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__next__(self):</span>
        <span class="s0">if </span><span class="s1">self._index </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">item = self._cache[self._index]</span>
            <span class="s0">except </span><span class="s1">IndexError:</span>
                <span class="s1">self._index = </span><span class="s0">None</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self._index += </span><span class="s4">1</span>
                <span class="s0">return </span><span class="s1">item</span>

        <span class="s1">item = next(self._source)</span>
        <span class="s1">self._cache.append(item)</span>
        <span class="s0">return </span><span class="s1">item</span>

    <span class="s0">def </span><span class="s1">__bool__(self):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self.peek()</span>
        <span class="s0">except </span><span class="s1">StopIteration:</span>
            <span class="s0">return False</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">peek(self</span><span class="s0">, </span><span class="s1">default=_marker):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">peeked = next(self)</span>
        <span class="s0">except </span><span class="s1">StopIteration:</span>
            <span class="s0">if </span><span class="s1">default </span><span class="s0">is </span><span class="s1">_marker:</span>
                <span class="s0">raise</span>
            <span class="s0">return </span><span class="s1">default</span>
        <span class="s0">if </span><span class="s1">self._index </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self._index = len(self._cache)</span>
        <span class="s1">self._index -= </span><span class="s4">1</span>
        <span class="s0">return </span><span class="s1">peeked</span>

    <span class="s0">def </span><span class="s1">elements(self):</span>
        <span class="s0">return </span><span class="s1">SequenceView(self._cache)</span>

    <span class="s0">def </span><span class="s1">seek(self</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s1">self._index = index</span>
        <span class="s1">remainder = index - len(self._cache)</span>
        <span class="s0">if </span><span class="s1">remainder &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">consume(self</span><span class="s0">, </span><span class="s1">remainder)</span>


<span class="s0">class </span><span class="s1">run_length:</span>
    <span class="s3">&quot;&quot;&quot; 
    :func:`run_length.encode` compresses an iterable with run-length encoding. 
    It yields groups of repeated items with the count of how many times they 
    were repeated: 
 
        &gt;&gt;&gt; uncompressed = 'abbcccdddd' 
        &gt;&gt;&gt; list(run_length.encode(uncompressed)) 
        [('a', 1), ('b', 2), ('c', 3), ('d', 4)] 
 
    :func:`run_length.decode` decompresses an iterable that was previously 
    compressed with run-length encoding. It yields the items of the 
    decompressed iterable: 
 
        &gt;&gt;&gt; compressed = [('a', 1), ('b', 2), ('c', 3), ('d', 4)] 
        &gt;&gt;&gt; list(run_length.decode(compressed)) 
        ['a', 'b', 'b', 'c', 'c', 'c', 'd', 'd', 'd', 'd'] 
 
    &quot;&quot;&quot;</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">encode(iterable):</span>
        <span class="s0">return </span><span class="s1">((k</span><span class="s0">, </span><span class="s1">ilen(g)) </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">g </span><span class="s0">in </span><span class="s1">groupby(iterable))</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">decode(iterable):</span>
        <span class="s0">return </span><span class="s1">chain.from_iterable(repeat(k</span><span class="s0">, </span><span class="s1">n) </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">n </span><span class="s0">in </span><span class="s1">iterable)</span>


<span class="s0">def </span><span class="s1">exactly_n(iterable</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">predicate=bool):</span>
    <span class="s3">&quot;&quot;&quot;Return ``True`` if exactly ``n`` items in the iterable are ``True`` 
    according to the *predicate* function. 
 
        &gt;&gt;&gt; exactly_n([True, True, False], 2) 
        True 
        &gt;&gt;&gt; exactly_n([True, True, False], 1) 
        False 
        &gt;&gt;&gt; exactly_n([0, 1, 2, 3, 4, 5], 3, lambda x: x &lt; 3) 
        True 
 
    The iterable will be advanced until ``n + 1`` truthy items are encountered, 
    so avoid calling it on infinite iterables. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">len(take(n + </span><span class="s4">1</span><span class="s0">, </span><span class="s1">filter(predicate</span><span class="s0">, </span><span class="s1">iterable))) == n</span>


<span class="s0">def </span><span class="s1">circular_shifts(iterable):</span>
    <span class="s3">&quot;&quot;&quot;Return a list of circular shifts of *iterable*. 
 
    &gt;&gt;&gt; circular_shifts(range(4)) 
    [(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)] 
    &quot;&quot;&quot;</span>
    <span class="s1">lst = list(iterable)</span>
    <span class="s0">return </span><span class="s1">take(len(lst)</span><span class="s0">, </span><span class="s1">windowed(cycle(lst)</span><span class="s0">, </span><span class="s1">len(lst)))</span>


<span class="s0">def </span><span class="s1">make_decorator(wrapping_func</span><span class="s0">, </span><span class="s1">result_index=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Return a decorator version of *wrapping_func*, which is a function that 
    modifies an iterable. *result_index* is the position in that function's 
    signature where the iterable goes. 
 
    This lets you use itertools on the &quot;production end,&quot; i.e. at function 
    definition. This can augment what the function returns without changing the 
    function's code. 
 
    For example, to produce a decorator version of :func:`chunked`: 
 
        &gt;&gt;&gt; from more_itertools import chunked 
        &gt;&gt;&gt; chunker = make_decorator(chunked, result_index=0) 
        &gt;&gt;&gt; @chunker(3) 
        ... def iter_range(n): 
        ...     return iter(range(n)) 
        ... 
        &gt;&gt;&gt; list(iter_range(9)) 
        [[0, 1, 2], [3, 4, 5], [6, 7, 8]] 
 
    To only allow truthy items to be returned: 
 
        &gt;&gt;&gt; truth_serum = make_decorator(filter, result_index=1) 
        &gt;&gt;&gt; @truth_serum(bool) 
        ... def boolean_test(): 
        ...     return [0, 1, '', ' ', False, True] 
        ... 
        &gt;&gt;&gt; list(boolean_test()) 
        [1, ' ', True] 
 
    The :func:`peekable` and :func:`seekable` wrappers make for practical 
    decorators: 
 
        &gt;&gt;&gt; from more_itertools import peekable 
        &gt;&gt;&gt; peekable_function = make_decorator(peekable) 
        &gt;&gt;&gt; @peekable_function() 
        ... def str_range(*args): 
        ...     return (str(x) for x in range(*args)) 
        ... 
        &gt;&gt;&gt; it = str_range(1, 20, 2) 
        &gt;&gt;&gt; next(it), next(it), next(it) 
        ('1', '3', '5') 
        &gt;&gt;&gt; it.peek() 
        '7' 
        &gt;&gt;&gt; next(it) 
        '7' 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># See https://sites.google.com/site/bbayles/index/decorator_factory for</span>
    <span class="s5"># notes on how this works.</span>
    <span class="s0">def </span><span class="s1">decorator(*wrapping_args</span><span class="s0">, </span><span class="s1">**wrapping_kwargs):</span>
        <span class="s0">def </span><span class="s1">outer_wrapper(f):</span>
            <span class="s0">def </span><span class="s1">inner_wrapper(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s1">result = f(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
                <span class="s1">wrapping_args_ = list(wrapping_args)</span>
                <span class="s1">wrapping_args_.insert(result_index</span><span class="s0">, </span><span class="s1">result)</span>
                <span class="s0">return </span><span class="s1">wrapping_func(*wrapping_args_</span><span class="s0">, </span><span class="s1">**wrapping_kwargs)</span>

            <span class="s0">return </span><span class="s1">inner_wrapper</span>

        <span class="s0">return </span><span class="s1">outer_wrapper</span>

    <span class="s0">return </span><span class="s1">decorator</span>


<span class="s0">def </span><span class="s1">map_reduce(iterable</span><span class="s0">, </span><span class="s1">keyfunc</span><span class="s0">, </span><span class="s1">valuefunc=</span><span class="s0">None, </span><span class="s1">reducefunc=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Return a dictionary that maps the items in *iterable* to categories 
    defined by *keyfunc*, transforms them with *valuefunc*, and 
    then summarizes them by category with *reducefunc*. 
 
    *valuefunc* defaults to the identity function if it is unspecified. 
    If *reducefunc* is unspecified, no summarization takes place: 
 
        &gt;&gt;&gt; keyfunc = lambda x: x.upper() 
        &gt;&gt;&gt; result = map_reduce('abbccc', keyfunc) 
        &gt;&gt;&gt; sorted(result.items()) 
        [('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])] 
 
    Specifying *valuefunc* transforms the categorized items: 
 
        &gt;&gt;&gt; keyfunc = lambda x: x.upper() 
        &gt;&gt;&gt; valuefunc = lambda x: 1 
        &gt;&gt;&gt; result = map_reduce('abbccc', keyfunc, valuefunc) 
        &gt;&gt;&gt; sorted(result.items()) 
        [('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])] 
 
    Specifying *reducefunc* summarizes the categorized items: 
 
        &gt;&gt;&gt; keyfunc = lambda x: x.upper() 
        &gt;&gt;&gt; valuefunc = lambda x: 1 
        &gt;&gt;&gt; reducefunc = sum 
        &gt;&gt;&gt; result = map_reduce('abbccc', keyfunc, valuefunc, reducefunc) 
        &gt;&gt;&gt; sorted(result.items()) 
        [('A', 1), ('B', 2), ('C', 3)] 
 
    You may want to filter the input iterable before applying the map/reduce 
    procedure: 
 
        &gt;&gt;&gt; all_items = range(30) 
        &gt;&gt;&gt; items = [x for x in all_items if 10 &lt;= x &lt;= 20]  # Filter 
        &gt;&gt;&gt; keyfunc = lambda x: x % 2  # Evens map to 0; odds to 1 
        &gt;&gt;&gt; categories = map_reduce(items, keyfunc=keyfunc) 
        &gt;&gt;&gt; sorted(categories.items()) 
        [(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])] 
        &gt;&gt;&gt; summaries = map_reduce(items, keyfunc=keyfunc, reducefunc=sum) 
        &gt;&gt;&gt; sorted(summaries.items()) 
        [(0, 90), (1, 75)] 
 
    Note that all items in the iterable are gathered into a list before the 
    summarization step, which may require significant storage. 
 
    The returned object is a :obj:`collections.defaultdict` with the 
    ``default_factory`` set to ``None``, such that it behaves like a normal 
    dictionary. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">valuefunc = (</span><span class="s0">lambda </span><span class="s1">x: x) </span><span class="s0">if </span><span class="s1">(valuefunc </span><span class="s0">is None</span><span class="s1">) </span><span class="s0">else </span><span class="s1">valuefunc</span>

    <span class="s1">ret = defaultdict(list)</span>
    <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">iterable:</span>
        <span class="s1">key = keyfunc(item)</span>
        <span class="s1">value = valuefunc(item)</span>
        <span class="s1">ret[key].append(value)</span>

    <span class="s0">if </span><span class="s1">reducefunc </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value_list </span><span class="s0">in </span><span class="s1">ret.items():</span>
            <span class="s1">ret[key] = reducefunc(value_list)</span>

    <span class="s1">ret.default_factory = </span><span class="s0">None</span>
    <span class="s0">return </span><span class="s1">ret</span>


<span class="s0">def </span><span class="s1">rlocate(iterable</span><span class="s0">, </span><span class="s1">pred=bool</span><span class="s0">, </span><span class="s1">window_size=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Yield the index of each item in *iterable* for which *pred* returns 
    ``True``, starting from the right and moving left. 
 
    *pred* defaults to :func:`bool`, which will select truthy items: 
 
        &gt;&gt;&gt; list(rlocate([0, 1, 1, 0, 1, 0, 0]))  # Truthy at 1, 2, and 4 
        [4, 2, 1] 
 
    Set *pred* to a custom function to, e.g., find the indexes for a particular 
    item: 
 
        &gt;&gt;&gt; iterable = iter('abcb') 
        &gt;&gt;&gt; pred = lambda x: x == 'b' 
        &gt;&gt;&gt; list(rlocate(iterable, pred)) 
        [3, 1] 
 
    If *window_size* is given, then the *pred* function will be called with 
    that many items. This enables searching for sub-sequences: 
 
        &gt;&gt;&gt; iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3] 
        &gt;&gt;&gt; pred = lambda *args: args == (1, 2, 3) 
        &gt;&gt;&gt; list(rlocate(iterable, pred=pred, window_size=3)) 
        [9, 5, 1] 
 
    Beware, this function won't return anything for infinite iterables. 
    If *iterable* is reversible, ``rlocate`` will reverse it and search from 
    the right. Otherwise, it will search from the left and return the results 
    in reverse order. 
 
    See :func:`locate` to for other example applications. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">window_size </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">len_iter = len(iterable)</span>
            <span class="s0">return </span><span class="s1">(len_iter - i - </span><span class="s4">1 </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">locate(reversed(iterable)</span><span class="s0">, </span><span class="s1">pred))</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">pass</span>

    <span class="s0">return </span><span class="s1">reversed(list(locate(iterable</span><span class="s0">, </span><span class="s1">pred</span><span class="s0">, </span><span class="s1">window_size)))</span>


<span class="s0">def </span><span class="s1">replace(iterable</span><span class="s0">, </span><span class="s1">pred</span><span class="s0">, </span><span class="s1">substitutes</span><span class="s0">, </span><span class="s1">count=</span><span class="s0">None, </span><span class="s1">window_size=</span><span class="s4">1</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Yield the items from *iterable*, replacing the items for which *pred* 
    returns ``True`` with the items from the iterable *substitutes*. 
 
        &gt;&gt;&gt; iterable = [1, 1, 0, 1, 1, 0, 1, 1] 
        &gt;&gt;&gt; pred = lambda x: x == 0 
        &gt;&gt;&gt; substitutes = (2, 3) 
        &gt;&gt;&gt; list(replace(iterable, pred, substitutes)) 
        [1, 1, 2, 3, 1, 1, 2, 3, 1, 1] 
 
    If *count* is given, the number of replacements will be limited: 
 
        &gt;&gt;&gt; iterable = [1, 1, 0, 1, 1, 0, 1, 1, 0] 
        &gt;&gt;&gt; pred = lambda x: x == 0 
        &gt;&gt;&gt; substitutes = [None] 
        &gt;&gt;&gt; list(replace(iterable, pred, substitutes, count=2)) 
        [1, 1, None, 1, 1, None, 1, 1, 0] 
 
    Use *window_size* to control the number of items passed as arguments to 
    *pred*. This allows for locating and replacing subsequences. 
 
        &gt;&gt;&gt; iterable = [0, 1, 2, 5, 0, 1, 2, 5] 
        &gt;&gt;&gt; window_size = 3 
        &gt;&gt;&gt; pred = lambda *args: args == (0, 1, 2)  # 3 items passed to pred 
        &gt;&gt;&gt; substitutes = [3, 4] # Splice in these items 
        &gt;&gt;&gt; list(replace(iterable, pred, substitutes, window_size=window_size)) 
        [3, 4, 5, 3, 4, 5] 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">window_size &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'window_size must be at least 1'</span><span class="s1">)</span>

    <span class="s5"># Save the substitutes iterable, since it's used more than once</span>
    <span class="s1">substitutes = tuple(substitutes)</span>

    <span class="s5"># Add padding such that the number of windows matches the length of the</span>
    <span class="s5"># iterable</span>
    <span class="s1">it = chain(iterable</span><span class="s0">, </span><span class="s1">[_marker] * (window_size - </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">windows = windowed(it</span><span class="s0">, </span><span class="s1">window_size)</span>

    <span class="s1">n = </span><span class="s4">0</span>
    <span class="s0">for </span><span class="s1">w </span><span class="s0">in </span><span class="s1">windows:</span>
        <span class="s5"># If the current window matches our predicate (and we haven't hit</span>
        <span class="s5"># our maximum number of replacements), splice in the substitutes</span>
        <span class="s5"># and then consume the following windows that overlap with this one.</span>
        <span class="s5"># For example, if the iterable is (0, 1, 2, 3, 4...)</span>
        <span class="s5"># and the window size is 2, we have (0, 1), (1, 2), (2, 3)...</span>
        <span class="s5"># If the predicate matches on (0, 1), we need to zap (0, 1) and (1, 2)</span>
        <span class="s0">if </span><span class="s1">pred(*w):</span>
            <span class="s0">if </span><span class="s1">(count </span><span class="s0">is None</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(n &lt; count):</span>
                <span class="s1">n += </span><span class="s4">1</span>
                <span class="s0">yield from </span><span class="s1">substitutes</span>
                <span class="s1">consume(windows</span><span class="s0">, </span><span class="s1">window_size - </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s0">continue</span>

        <span class="s5"># If there was no match (or we've reached the replacement limit),</span>
        <span class="s5"># yield the first item from the window.</span>
        <span class="s0">if </span><span class="s1">w </span><span class="s0">and </span><span class="s1">(w[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">is not </span><span class="s1">_marker):</span>
            <span class="s0">yield </span><span class="s1">w[</span><span class="s4">0</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">partitions(iterable):</span>
    <span class="s3">&quot;&quot;&quot;Yield all possible order-preserving partitions of *iterable*. 
 
    &gt;&gt;&gt; iterable = 'abc' 
    &gt;&gt;&gt; for part in partitions(iterable): 
    ...     print([''.join(p) for p in part]) 
    ['abc'] 
    ['a', 'bc'] 
    ['ab', 'c'] 
    ['a', 'b', 'c'] 
 
    This is unrelated to :func:`partition`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">sequence = list(iterable)</span>
    <span class="s1">n = len(sequence)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">powerset(range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">n)):</span>
        <span class="s0">yield </span><span class="s1">[sequence[i:j] </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">zip((</span><span class="s4">0</span><span class="s0">,</span><span class="s1">) + i</span><span class="s0">, </span><span class="s1">i + (n</span><span class="s0">,</span><span class="s1">))]</span>


<span class="s0">def </span><span class="s1">set_partitions(iterable</span><span class="s0">, </span><span class="s1">k=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Yield the set partitions of *iterable* into *k* parts. Set partitions are 
    not order-preserving. 
 
    &gt;&gt;&gt; iterable = 'abc' 
    &gt;&gt;&gt; for part in set_partitions(iterable, 2): 
    ...     print([''.join(p) for p in part]) 
    ['a', 'bc'] 
    ['ab', 'c'] 
    ['b', 'ac'] 
 
 
    If *k* is not given, every set partition is generated. 
 
    &gt;&gt;&gt; iterable = 'abc' 
    &gt;&gt;&gt; for part in set_partitions(iterable): 
    ...     print([''.join(p) for p in part]) 
    ['abc'] 
    ['a', 'bc'] 
    ['ab', 'c'] 
    ['b', 'ac'] 
    ['a', 'b', 'c'] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">L = list(iterable)</span>
    <span class="s1">n = len(L)</span>
    <span class="s0">if </span><span class="s1">k </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">k &lt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;Can't partition in a negative or zero number of groups&quot;</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">k &gt; n:</span>
            <span class="s0">return</span>

    <span class="s0">def </span><span class="s1">set_partitions_helper(L</span><span class="s0">, </span><span class="s1">k):</span>
        <span class="s1">n = len(L)</span>
        <span class="s0">if </span><span class="s1">k == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">yield </span><span class="s1">[L]</span>
        <span class="s0">elif </span><span class="s1">n == k:</span>
            <span class="s0">yield </span><span class="s1">[[s] </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">L]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">e</span><span class="s0">, </span><span class="s1">*M = L</span>
            <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">set_partitions_helper(M</span><span class="s0">, </span><span class="s1">k - </span><span class="s4">1</span><span class="s1">):</span>
                <span class="s0">yield </span><span class="s1">[[e]</span><span class="s0">, </span><span class="s1">*p]</span>
            <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">set_partitions_helper(M</span><span class="s0">, </span><span class="s1">k):</span>
                <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(p)):</span>
                    <span class="s0">yield </span><span class="s1">p[:i] + [[e] + p[i]] + p[i + </span><span class="s4">1 </span><span class="s1">:]</span>

    <span class="s0">if </span><span class="s1">k </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">n + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s0">yield from </span><span class="s1">set_partitions_helper(L</span><span class="s0">, </span><span class="s1">k)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">yield from </span><span class="s1">set_partitions_helper(L</span><span class="s0">, </span><span class="s1">k)</span>


<span class="s0">class </span><span class="s1">time_limited:</span>
    <span class="s3">&quot;&quot;&quot; 
    Yield items from *iterable* until *limit_seconds* have passed. 
    If the time limit expires before all items have been yielded, the 
    ``timed_out`` parameter will be set to ``True``. 
 
    &gt;&gt;&gt; from time import sleep 
    &gt;&gt;&gt; def generator(): 
    ...     yield 1 
    ...     yield 2 
    ...     sleep(0.2) 
    ...     yield 3 
    &gt;&gt;&gt; iterable = time_limited(0.1, generator()) 
    &gt;&gt;&gt; list(iterable) 
    [1, 2] 
    &gt;&gt;&gt; iterable.timed_out 
    True 
 
    Note that the time is checked before each item is yielded, and iteration 
    stops if  the time elapsed is greater than *limit_seconds*. If your time 
    limit is 1 second, but it takes 2 seconds to generate the first item from 
    the iterable, the function will run for 2 seconds and not yield anything. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">limit_seconds</span><span class="s0">, </span><span class="s1">iterable):</span>
        <span class="s0">if </span><span class="s1">limit_seconds &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'limit_seconds must be positive'</span><span class="s1">)</span>
        <span class="s1">self.limit_seconds = limit_seconds</span>
        <span class="s1">self._iterable = iter(iterable)</span>
        <span class="s1">self._start_time = monotonic()</span>
        <span class="s1">self.timed_out = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__next__(self):</span>
        <span class="s1">item = next(self._iterable)</span>
        <span class="s0">if </span><span class="s1">monotonic() - self._start_time &gt; self.limit_seconds:</span>
            <span class="s1">self.timed_out = </span><span class="s0">True</span>
            <span class="s0">raise </span><span class="s1">StopIteration</span>

        <span class="s0">return </span><span class="s1">item</span>


<span class="s0">def </span><span class="s1">only(iterable</span><span class="s0">, </span><span class="s1">default=</span><span class="s0">None, </span><span class="s1">too_long=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;If *iterable* has only one item, return it. 
    If it has zero items, return *default*. 
    If it has more than one item, raise the exception given by *too_long*, 
    which is ``ValueError`` by default. 
 
    &gt;&gt;&gt; only([], default='missing') 
    'missing' 
    &gt;&gt;&gt; only([1]) 
    1 
    &gt;&gt;&gt; only([1, 2])  # doctest: +IGNORE_EXCEPTION_DETAIL 
    Traceback (most recent call last): 
    ... 
    ValueError: Expected exactly one item in iterable, but got 1, 2, 
     and perhaps more.' 
    &gt;&gt;&gt; only([1, 2], too_long=TypeError)  # doctest: +IGNORE_EXCEPTION_DETAIL 
    Traceback (most recent call last): 
    ... 
    TypeError 
 
    Note that :func:`only` attempts to advance *iterable* twice to ensure there 
    is only one item.  See :func:`spy` or :func:`peekable` to check 
    iterable contents less destructively. 
    &quot;&quot;&quot;</span>
    <span class="s1">it = iter(iterable)</span>
    <span class="s1">first_value = next(it</span><span class="s0">, </span><span class="s1">default)</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">second_value = next(it)</span>
    <span class="s0">except </span><span class="s1">StopIteration:</span>
        <span class="s0">pass</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">msg = (</span>
            <span class="s2">'Expected exactly one item in iterable, but got {!r}, {!r}, '</span>
            <span class="s2">'and perhaps more.'</span><span class="s1">.format(first_value</span><span class="s0">, </span><span class="s1">second_value)</span>
        <span class="s1">)</span>
        <span class="s0">raise </span><span class="s1">too_long </span><span class="s0">or </span><span class="s1">ValueError(msg)</span>

    <span class="s0">return </span><span class="s1">first_value</span>


<span class="s0">def </span><span class="s1">ichunked(iterable</span><span class="s0">, </span><span class="s1">n):</span>
    <span class="s3">&quot;&quot;&quot;Break *iterable* into sub-iterables with *n* elements each. 
    :func:`ichunked` is like :func:`chunked`, but it yields iterables 
    instead of lists. 
 
    If the sub-iterables are read in order, the elements of *iterable* 
    won't be stored in memory. 
    If they are read out of order, :func:`itertools.tee` is used to cache 
    elements as necessary. 
 
    &gt;&gt;&gt; from itertools import count 
    &gt;&gt;&gt; all_chunks = ichunked(count(), 4) 
    &gt;&gt;&gt; c_1, c_2, c_3 = next(all_chunks), next(all_chunks), next(all_chunks) 
    &gt;&gt;&gt; list(c_2)  # c_1's elements have been cached; c_3's haven't been 
    [4, 5, 6, 7] 
    &gt;&gt;&gt; list(c_1) 
    [0, 1, 2, 3] 
    &gt;&gt;&gt; list(c_3) 
    [8, 9, 10, 11] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">source = iter(iterable)</span>

    <span class="s0">while True</span><span class="s1">:</span>
        <span class="s5"># Check to see whether we're at the end of the source iterable</span>
        <span class="s1">item = next(source</span><span class="s0">, </span><span class="s1">_marker)</span>
        <span class="s0">if </span><span class="s1">item </span><span class="s0">is </span><span class="s1">_marker:</span>
            <span class="s0">return</span>

        <span class="s5"># Clone the source and yield an n-length slice</span>
        <span class="s1">source</span><span class="s0">, </span><span class="s1">it = tee(chain([item]</span><span class="s0">, </span><span class="s1">source))</span>
        <span class="s0">yield </span><span class="s1">islice(it</span><span class="s0">, </span><span class="s1">n)</span>

        <span class="s5"># Advance the source iterable</span>
        <span class="s1">consume(source</span><span class="s0">, </span><span class="s1">n)</span>


<span class="s0">def </span><span class="s1">distinct_combinations(iterable</span><span class="s0">, </span><span class="s1">r):</span>
    <span class="s3">&quot;&quot;&quot;Yield the distinct combinations of *r* items taken from *iterable*. 
 
        &gt;&gt;&gt; list(distinct_combinations([0, 0, 1], 2)) 
        [(0, 0), (0, 1)] 
 
    Equivalent to ``set(combinations(iterable))``, except duplicates are not 
    generated and thrown away. For larger input sequences this is much more 
    efficient. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">r &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'r must be non-negative'</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">r == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">yield </span><span class="s1">()</span>
        <span class="s0">return</span>
    <span class="s1">pool = tuple(iterable)</span>
    <span class="s1">generators = [unique_everseen(enumerate(pool)</span><span class="s0">, </span><span class="s1">key=itemgetter(</span><span class="s4">1</span><span class="s1">))]</span>
    <span class="s1">current_combo = [</span><span class="s0">None</span><span class="s1">] * r</span>
    <span class="s1">level = </span><span class="s4">0</span>
    <span class="s0">while </span><span class="s1">generators:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">cur_idx</span><span class="s0">, </span><span class="s1">p = next(generators[-</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s0">except </span><span class="s1">StopIteration:</span>
            <span class="s1">generators.pop()</span>
            <span class="s1">level -= </span><span class="s4">1</span>
            <span class="s0">continue</span>
        <span class="s1">current_combo[level] = p</span>
        <span class="s0">if </span><span class="s1">level + </span><span class="s4">1 </span><span class="s1">== r:</span>
            <span class="s0">yield </span><span class="s1">tuple(current_combo)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">generators.append(</span>
                <span class="s1">unique_everseen(</span>
                    <span class="s1">enumerate(pool[cur_idx + </span><span class="s4">1 </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">cur_idx + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">key=itemgetter(</span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">level += </span><span class="s4">1</span>


<span class="s0">def </span><span class="s1">filter_except(validator</span><span class="s0">, </span><span class="s1">iterable</span><span class="s0">, </span><span class="s1">*exceptions):</span>
    <span class="s3">&quot;&quot;&quot;Yield the items from *iterable* for which the *validator* function does 
    not raise one of the specified *exceptions*. 
 
    *validator* is called for each item in *iterable*. 
    It should be a function that accepts one argument and raises an exception 
    if that item is not valid. 
 
    &gt;&gt;&gt; iterable = ['1', '2', 'three', '4', None] 
    &gt;&gt;&gt; list(filter_except(int, iterable, ValueError, TypeError)) 
    ['1', '2', '4'] 
 
    If an exception other than one given by *exceptions* is raised by 
    *validator*, it is raised like normal. 
    &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">iterable:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">validator(item)</span>
        <span class="s0">except </span><span class="s1">exceptions:</span>
            <span class="s0">pass</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">yield </span><span class="s1">item</span>


<span class="s0">def </span><span class="s1">map_except(function</span><span class="s0">, </span><span class="s1">iterable</span><span class="s0">, </span><span class="s1">*exceptions):</span>
    <span class="s3">&quot;&quot;&quot;Transform each item from *iterable* with *function* and yield the 
    result, unless *function* raises one of the specified *exceptions*. 
 
    *function* is called to transform each item in *iterable*. 
    It should be a accept one argument. 
 
    &gt;&gt;&gt; iterable = ['1', '2', 'three', '4', None] 
    &gt;&gt;&gt; list(map_except(int, iterable, ValueError, TypeError)) 
    [1, 2, 4] 
 
    If an exception other than one given by *exceptions* is raised by 
    *function*, it is raised like normal. 
    &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">iterable:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">yield </span><span class="s1">function(item)</span>
        <span class="s0">except </span><span class="s1">exceptions:</span>
            <span class="s0">pass</span>


<span class="s0">def </span><span class="s1">_sample_unweighted(iterable</span><span class="s0">, </span><span class="s1">k):</span>
    <span class="s5"># Implementation of &quot;Algorithm L&quot; from the 1994 paper by Kim-Hung Li:</span>
    <span class="s5"># &quot;Reservoir-Sampling Algorithms of Time Complexity O(n(1+log(N/n)))&quot;.</span>

    <span class="s5"># Fill up the reservoir (collection of samples) with the first `k` samples</span>
    <span class="s1">reservoir = take(k</span><span class="s0">, </span><span class="s1">iterable)</span>

    <span class="s5"># Generate random number that's the largest in a sample of k U(0,1) numbers</span>
    <span class="s5"># Largest order statistic: https://en.wikipedia.org/wiki/Order_statistic</span>
    <span class="s1">W = exp(log(random()) / k)</span>

    <span class="s5"># The number of elements to skip before changing the reservoir is a random</span>
    <span class="s5"># number with a geometric distribution. Sample it using random() and logs.</span>
    <span class="s1">next_index = k + floor(log(random()) / log(</span><span class="s4">1 </span><span class="s1">- W))</span>

    <span class="s0">for </span><span class="s1">index</span><span class="s0">, </span><span class="s1">element </span><span class="s0">in </span><span class="s1">enumerate(iterable</span><span class="s0">, </span><span class="s1">k):</span>

        <span class="s0">if </span><span class="s1">index == next_index:</span>
            <span class="s1">reservoir[randrange(k)] = element</span>
            <span class="s5"># The new W is the largest in a sample of k U(0, `old_W`) numbers</span>
            <span class="s1">W *= exp(log(random()) / k)</span>
            <span class="s1">next_index += floor(log(random()) / log(</span><span class="s4">1 </span><span class="s1">- W)) + </span><span class="s4">1</span>

    <span class="s0">return </span><span class="s1">reservoir</span>


<span class="s0">def </span><span class="s1">_sample_weighted(iterable</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">weights):</span>
    <span class="s5"># Implementation of &quot;A-ExpJ&quot; from the 2006 paper by Efraimidis et al. :</span>
    <span class="s5"># &quot;Weighted random sampling with a reservoir&quot;.</span>

    <span class="s5"># Log-transform for numerical stability for weights that are small/large</span>
    <span class="s1">weight_keys = (log(random()) / weight </span><span class="s0">for </span><span class="s1">weight </span><span class="s0">in </span><span class="s1">weights)</span>

    <span class="s5"># Fill up the reservoir (collection of samples) with the first `k`</span>
    <span class="s5"># weight-keys and elements, then heapify the list.</span>
    <span class="s1">reservoir = take(k</span><span class="s0">, </span><span class="s1">zip(weight_keys</span><span class="s0">, </span><span class="s1">iterable))</span>
    <span class="s1">heapify(reservoir)</span>

    <span class="s5"># The number of jumps before changing the reservoir is a random variable</span>
    <span class="s5"># with an exponential distribution. Sample it using random() and logs.</span>
    <span class="s1">smallest_weight_key</span><span class="s0">, </span><span class="s1">_ = reservoir[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">weights_to_skip = log(random()) / smallest_weight_key</span>

    <span class="s0">for </span><span class="s1">weight</span><span class="s0">, </span><span class="s1">element </span><span class="s0">in </span><span class="s1">zip(weights</span><span class="s0">, </span><span class="s1">iterable):</span>
        <span class="s0">if </span><span class="s1">weight &gt;= weights_to_skip:</span>
            <span class="s5"># The notation here is consistent with the paper, but we store</span>
            <span class="s5"># the weight-keys in log-space for better numerical stability.</span>
            <span class="s1">smallest_weight_key</span><span class="s0">, </span><span class="s1">_ = reservoir[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">t_w = exp(weight * smallest_weight_key)</span>
            <span class="s1">r_2 = uniform(t_w</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)  </span><span class="s5"># generate U(t_w, 1)</span>
            <span class="s1">weight_key = log(r_2) / weight</span>
            <span class="s1">heapreplace(reservoir</span><span class="s0">, </span><span class="s1">(weight_key</span><span class="s0">, </span><span class="s1">element))</span>
            <span class="s1">smallest_weight_key</span><span class="s0">, </span><span class="s1">_ = reservoir[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">weights_to_skip = log(random()) / smallest_weight_key</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">weights_to_skip -= weight</span>

    <span class="s5"># Equivalent to [element for weight_key, element in sorted(reservoir)]</span>
    <span class="s0">return </span><span class="s1">[heappop(reservoir)[</span><span class="s4">1</span><span class="s1">] </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(k)]</span>


<span class="s0">def </span><span class="s1">sample(iterable</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">weights=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Return a *k*-length list of elements chosen (without replacement) 
    from the *iterable*. Like :func:`random.sample`, but works on iterables 
    of unknown length. 
 
    &gt;&gt;&gt; iterable = range(100) 
    &gt;&gt;&gt; sample(iterable, 5)  # doctest: +SKIP 
    [81, 60, 96, 16, 4] 
 
    An iterable with *weights* may also be given: 
 
    &gt;&gt;&gt; iterable = range(100) 
    &gt;&gt;&gt; weights = (i * i + 1 for i in range(100)) 
    &gt;&gt;&gt; sampled = sample(iterable, 5, weights=weights)  # doctest: +SKIP 
    [79, 67, 74, 66, 78] 
 
    The algorithm can also be used to generate weighted random permutations. 
    The relative weight of each item determines the probability that it 
    appears late in the permutation. 
 
    &gt;&gt;&gt; data = &quot;abcdefgh&quot; 
    &gt;&gt;&gt; weights = range(1, len(data) + 1) 
    &gt;&gt;&gt; sample(data, k=len(data), weights=weights)  # doctest: +SKIP 
    ['c', 'a', 'b', 'e', 'g', 'd', 'h', 'f'] 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">k == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">[]</span>

    <span class="s1">iterable = iter(iterable)</span>
    <span class="s0">if </span><span class="s1">weights </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">_sample_unweighted(iterable</span><span class="s0">, </span><span class="s1">k)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">weights = iter(weights)</span>
        <span class="s0">return </span><span class="s1">_sample_weighted(iterable</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">weights)</span>


<span class="s0">def </span><span class="s1">is_sorted(iterable</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">None, </span><span class="s1">reverse=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Returns ``True`` if the items of iterable are in sorted order, and 
    ``False`` otherwise. *key* and *reverse* have the same meaning that they do 
    in the built-in :func:`sorted` function. 
 
    &gt;&gt;&gt; is_sorted(['1', '2', '3', '4', '5'], key=int) 
    True 
    &gt;&gt;&gt; is_sorted([5, 4, 3, 1, 2], reverse=True) 
    False 
 
    The function returns ``False`` after encountering the first out-of-order 
    item. If there are no out-of-order items, the iterable is exhausted. 
    &quot;&quot;&quot;</span>

    <span class="s1">compare = lt </span><span class="s0">if </span><span class="s1">reverse </span><span class="s0">else </span><span class="s1">gt</span>
    <span class="s1">it = iterable </span><span class="s0">if </span><span class="s1">(key </span><span class="s0">is None</span><span class="s1">) </span><span class="s0">else </span><span class="s1">map(key</span><span class="s0">, </span><span class="s1">iterable)</span>
    <span class="s0">return not </span><span class="s1">any(starmap(compare</span><span class="s0">, </span><span class="s1">pairwise(it)))</span>


<span class="s0">class </span><span class="s1">AbortThread(BaseException):</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">callback_iter:</span>
    <span class="s3">&quot;&quot;&quot;Convert a function that uses callbacks to an iterator. 
 
    Let *func* be a function that takes a `callback` keyword argument. 
    For example: 
 
    &gt;&gt;&gt; def func(callback=None): 
    ...     for i, c in [(1, 'a'), (2, 'b'), (3, 'c')]: 
    ...         if callback: 
    ...             callback(i, c) 
    ...     return 4 
 
 
    Use ``with callback_iter(func)`` to get an iterator over the parameters 
    that are delivered to the callback. 
 
    &gt;&gt;&gt; with callback_iter(func) as it: 
    ...     for args, kwargs in it: 
    ...         print(args) 
    (1, 'a') 
    (2, 'b') 
    (3, 'c') 
 
    The function will be called in a background thread. The ``done`` property 
    indicates whether it has completed execution. 
 
    &gt;&gt;&gt; it.done 
    True 
 
    If it completes successfully, its return value will be available 
    in the ``result`` property. 
 
    &gt;&gt;&gt; it.result 
    4 
 
    Notes: 
 
    * If the function uses some keyword argument besides ``callback``, supply 
      *callback_kwd*. 
    * If it finished executing, but raised an exception, accessing the 
      ``result`` property will raise the same exception. 
    * If it hasn't finished executing, accessing the ``result`` 
      property from within the ``with`` block will raise ``RuntimeError``. 
    * If it hasn't finished executing, accessing the ``result`` property from 
      outside the ``with`` block will raise a 
      ``more_itertools.AbortThread`` exception. 
    * Provide *wait_seconds* to adjust how frequently the it is polled for 
      output. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">callback_kwd=</span><span class="s2">'callback'</span><span class="s0">, </span><span class="s1">wait_seconds=</span><span class="s4">0.1</span><span class="s1">):</span>
        <span class="s1">self._func = func</span>
        <span class="s1">self._callback_kwd = callback_kwd</span>
        <span class="s1">self._aborted = </span><span class="s0">False</span>
        <span class="s1">self._future = </span><span class="s0">None</span>
        <span class="s1">self._wait_seconds = wait_seconds</span>
        <span class="s1">self._executor = ThreadPoolExecutor(max_workers=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self._iterator = self._reader()</span>

    <span class="s0">def </span><span class="s1">__enter__(self):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__exit__(self</span><span class="s0">, </span><span class="s1">exc_type</span><span class="s0">, </span><span class="s1">exc_value</span><span class="s0">, </span><span class="s1">traceback):</span>
        <span class="s1">self._aborted = </span><span class="s0">True</span>
        <span class="s1">self._executor.shutdown()</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__next__(self):</span>
        <span class="s0">return </span><span class="s1">next(self._iterator)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">done(self):</span>
        <span class="s0">if </span><span class="s1">self._future </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return False</span>
        <span class="s0">return </span><span class="s1">self._future.done()</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">result(self):</span>
        <span class="s0">if not </span><span class="s1">self.done:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s2">'Function has not yet completed'</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">self._future.result()</span>

    <span class="s0">def </span><span class="s1">_reader(self):</span>
        <span class="s1">q = Queue()</span>

        <span class="s0">def </span><span class="s1">callback(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">if </span><span class="s1">self._aborted:</span>
                <span class="s0">raise </span><span class="s1">AbortThread(</span><span class="s2">'canceled by user'</span><span class="s1">)</span>

            <span class="s1">q.put((args</span><span class="s0">, </span><span class="s1">kwargs))</span>

        <span class="s1">self._future = self._executor.submit(</span>
            <span class="s1">self._func</span><span class="s0">, </span><span class="s1">**{self._callback_kwd: callback}</span>
        <span class="s1">)</span>

        <span class="s0">while True</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">item = q.get(timeout=self._wait_seconds)</span>
            <span class="s0">except </span><span class="s1">Empty:</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">q.task_done()</span>
                <span class="s0">yield </span><span class="s1">item</span>

            <span class="s0">if </span><span class="s1">self._future.done():</span>
                <span class="s0">break</span>

        <span class="s1">remaining = []</span>
        <span class="s0">while True</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">item = q.get_nowait()</span>
            <span class="s0">except </span><span class="s1">Empty:</span>
                <span class="s0">break</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">q.task_done()</span>
                <span class="s1">remaining.append(item)</span>
        <span class="s1">q.join()</span>
        <span class="s0">yield from </span><span class="s1">remaining</span>


<span class="s0">def </span><span class="s1">windowed_complete(iterable</span><span class="s0">, </span><span class="s1">n):</span>
    <span class="s3">&quot;&quot;&quot; 
    Yield ``(beginning, middle, end)`` tuples, where: 
 
    * Each ``middle`` has *n* items from *iterable* 
    * Each ``beginning`` has the items before the ones in ``middle`` 
    * Each ``end`` has the items after the ones in ``middle`` 
 
    &gt;&gt;&gt; iterable = range(7) 
    &gt;&gt;&gt; n = 3 
    &gt;&gt;&gt; for beginning, middle, end in windowed_complete(iterable, n): 
    ...     print(beginning, middle, end) 
    () (0, 1, 2) (3, 4, 5, 6) 
    (0,) (1, 2, 3) (4, 5, 6) 
    (0, 1) (2, 3, 4) (5, 6) 
    (0, 1, 2) (3, 4, 5) (6,) 
    (0, 1, 2, 3) (4, 5, 6) () 
 
    Note that *n* must be at least 0 and most equal to the length of 
    *iterable*. 
 
    This function will exhaust the iterable and may require significant 
    storage. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">n &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'n must be &gt;= 0'</span><span class="s1">)</span>

    <span class="s1">seq = tuple(iterable)</span>
    <span class="s1">size = len(seq)</span>

    <span class="s0">if </span><span class="s1">n &gt; size:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'n must be &lt;= len(seq)'</span><span class="s1">)</span>

    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(size - n + </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">beginning = seq[:i]</span>
        <span class="s1">middle = seq[i : i + n]</span>
        <span class="s1">end = seq[i + n :]</span>
        <span class="s0">yield </span><span class="s1">beginning</span><span class="s0">, </span><span class="s1">middle</span><span class="s0">, </span><span class="s1">end</span>


<span class="s0">def </span><span class="s1">all_unique(iterable</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Returns ``True`` if all the elements of *iterable* are unique (no two 
    elements are equal). 
 
        &gt;&gt;&gt; all_unique('ABCB') 
        False 
 
    If a *key* function is specified, it will be used to make comparisons. 
 
        &gt;&gt;&gt; all_unique('ABCb') 
        True 
        &gt;&gt;&gt; all_unique('ABCb', str.lower) 
        False 
 
    The function returns as soon as the first non-unique element is 
    encountered. Iterables with a mix of hashable and unhashable items can 
    be used, but the function will be slower for unhashable items. 
    &quot;&quot;&quot;</span>
    <span class="s1">seenset = set()</span>
    <span class="s1">seenset_add = seenset.add</span>
    <span class="s1">seenlist = []</span>
    <span class="s1">seenlist_add = seenlist.append</span>
    <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">map(key</span><span class="s0">, </span><span class="s1">iterable) </span><span class="s0">if </span><span class="s1">key </span><span class="s0">else </span><span class="s1">iterable:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">element </span><span class="s0">in </span><span class="s1">seenset:</span>
                <span class="s0">return False</span>
            <span class="s1">seenset_add(element)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">if </span><span class="s1">element </span><span class="s0">in </span><span class="s1">seenlist:</span>
                <span class="s0">return False</span>
            <span class="s1">seenlist_add(element)</span>
    <span class="s0">return True</span>


<span class="s0">def </span><span class="s1">nth_product(index</span><span class="s0">, </span><span class="s1">*args):</span>
    <span class="s3">&quot;&quot;&quot;Equivalent to ``list(product(*args))[index]``. 
 
    The products of *args* can be ordered lexicographically. 
    :func:`nth_product` computes the product at sort position *index* without 
    computing the previous products. 
 
        &gt;&gt;&gt; nth_product(8, range(2), range(2), range(2), range(2)) 
        (1, 0, 0, 0) 
 
    ``IndexError`` will be raised if the given *index* is invalid. 
    &quot;&quot;&quot;</span>
    <span class="s1">pools = list(map(tuple</span><span class="s0">, </span><span class="s1">reversed(args)))</span>
    <span class="s1">ns = list(map(len</span><span class="s0">, </span><span class="s1">pools))</span>

    <span class="s1">c = reduce(mul</span><span class="s0">, </span><span class="s1">ns)</span>

    <span class="s0">if </span><span class="s1">index &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">index += c</span>

    <span class="s0">if not </span><span class="s4">0 </span><span class="s1">&lt;= index &lt; c:</span>
        <span class="s0">raise </span><span class="s1">IndexError</span>

    <span class="s1">result = []</span>
    <span class="s0">for </span><span class="s1">pool</span><span class="s0">, </span><span class="s1">n </span><span class="s0">in </span><span class="s1">zip(pools</span><span class="s0">, </span><span class="s1">ns):</span>
        <span class="s1">result.append(pool[index % n])</span>
        <span class="s1">index //= n</span>

    <span class="s0">return </span><span class="s1">tuple(reversed(result))</span>


<span class="s0">def </span><span class="s1">nth_permutation(iterable</span><span class="s0">, </span><span class="s1">r</span><span class="s0">, </span><span class="s1">index):</span>
    <span class="s3">&quot;&quot;&quot;Equivalent to ``list(permutations(iterable, r))[index]``` 
 
    The subsequences of *iterable* that are of length *r* where order is 
    important can be ordered lexicographically. :func:`nth_permutation` 
    computes the subsequence at sort position *index* directly, without 
    computing the previous subsequences. 
 
        &gt;&gt;&gt; nth_permutation('ghijk', 2, 5) 
        ('h', 'i') 
 
    ``ValueError`` will be raised If *r* is negative or greater than the length 
    of *iterable*. 
    ``IndexError`` will be raised if the given *index* is invalid. 
    &quot;&quot;&quot;</span>
    <span class="s1">pool = list(iterable)</span>
    <span class="s1">n = len(pool)</span>

    <span class="s0">if </span><span class="s1">r </span><span class="s0">is None or </span><span class="s1">r == n:</span>
        <span class="s1">r</span><span class="s0">, </span><span class="s1">c = n</span><span class="s0">, </span><span class="s1">factorial(n)</span>
    <span class="s0">elif not </span><span class="s4">0 </span><span class="s1">&lt;= r &lt; n:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">c = factorial(n) // factorial(n - r)</span>

    <span class="s0">if </span><span class="s1">index &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">index += c</span>

    <span class="s0">if not </span><span class="s4">0 </span><span class="s1">&lt;= index &lt; c:</span>
        <span class="s0">raise </span><span class="s1">IndexError</span>

    <span class="s0">if </span><span class="s1">c == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">tuple()</span>

    <span class="s1">result = [</span><span class="s4">0</span><span class="s1">] * r</span>
    <span class="s1">q = index * factorial(n) // c </span><span class="s0">if </span><span class="s1">r &lt; n </span><span class="s0">else </span><span class="s1">index</span>
    <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">n + </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">q</span><span class="s0">, </span><span class="s1">i = divmod(q</span><span class="s0">, </span><span class="s1">d)</span>
        <span class="s0">if </span><span class="s4">0 </span><span class="s1">&lt;= n - d &lt; r:</span>
            <span class="s1">result[n - d] = i</span>
        <span class="s0">if </span><span class="s1">q == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0">break</span>

    <span class="s0">return </span><span class="s1">tuple(map(pool.pop</span><span class="s0">, </span><span class="s1">result))</span>


<span class="s0">def </span><span class="s1">value_chain(*args):</span>
    <span class="s3">&quot;&quot;&quot;Yield all arguments passed to the function in the same order in which 
    they were passed. If an argument itself is iterable then iterate over its 
    values. 
 
        &gt;&gt;&gt; list(value_chain(1, 2, 3, [4, 5, 6])) 
        [1, 2, 3, 4, 5, 6] 
 
    Binary and text strings are not considered iterable and are emitted 
    as-is: 
 
        &gt;&gt;&gt; list(value_chain('12', '34', ['56', '78'])) 
        ['12', '34', '56', '78'] 
 
 
    Multiple levels of nesting are not flattened. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">value </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">(str</span><span class="s0">, </span><span class="s1">bytes)):</span>
            <span class="s0">yield </span><span class="s1">value</span>
            <span class="s0">continue</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">yield from </span><span class="s1">value</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">yield </span><span class="s1">value</span>


<span class="s0">def </span><span class="s1">product_index(element</span><span class="s0">, </span><span class="s1">*args):</span>
    <span class="s3">&quot;&quot;&quot;Equivalent to ``list(product(*args)).index(element)`` 
 
    The products of *args* can be ordered lexicographically. 
    :func:`product_index` computes the first index of *element* without 
    computing the previous products. 
 
        &gt;&gt;&gt; product_index([8, 2], range(10), range(5)) 
        42 
 
    ``ValueError`` will be raised if the given *element* isn't in the product 
    of *args*. 
    &quot;&quot;&quot;</span>
    <span class="s1">index = </span><span class="s4">0</span>

    <span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">pool </span><span class="s0">in </span><span class="s1">zip_longest(element</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">fillvalue=_marker):</span>
        <span class="s0">if </span><span class="s1">x </span><span class="s0">is </span><span class="s1">_marker </span><span class="s0">or </span><span class="s1">pool </span><span class="s0">is </span><span class="s1">_marker:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'element is not a product of args'</span><span class="s1">)</span>

        <span class="s1">pool = tuple(pool)</span>
        <span class="s1">index = index * len(pool) + pool.index(x)</span>

    <span class="s0">return </span><span class="s1">index</span>


<span class="s0">def </span><span class="s1">combination_index(element</span><span class="s0">, </span><span class="s1">iterable):</span>
    <span class="s3">&quot;&quot;&quot;Equivalent to ``list(combinations(iterable, r)).index(element)`` 
 
    The subsequences of *iterable* that are of length *r* can be ordered 
    lexicographically. :func:`combination_index` computes the index of the 
    first *element*, without computing the previous combinations. 
 
        &gt;&gt;&gt; combination_index('adf', 'abcdefg') 
        10 
 
    ``ValueError`` will be raised if the given *element* isn't one of the 
    combinations of *iterable*. 
    &quot;&quot;&quot;</span>
    <span class="s1">element = enumerate(element)</span>
    <span class="s1">k</span><span class="s0">, </span><span class="s1">y = next(element</span><span class="s0">, </span><span class="s1">(</span><span class="s0">None, None</span><span class="s1">))</span>
    <span class="s0">if </span><span class="s1">k </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s4">0</span>

    <span class="s1">indexes = []</span>
    <span class="s1">pool = enumerate(iterable)</span>
    <span class="s0">for </span><span class="s1">n</span><span class="s0">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">pool:</span>
        <span class="s0">if </span><span class="s1">x == y:</span>
            <span class="s1">indexes.append(n)</span>
            <span class="s1">tmp</span><span class="s0">, </span><span class="s1">y = next(element</span><span class="s0">, </span><span class="s1">(</span><span class="s0">None, None</span><span class="s1">))</span>
            <span class="s0">if </span><span class="s1">tmp </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">break</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">k = tmp</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'element is not a combination of iterable'</span><span class="s1">)</span>

    <span class="s1">n</span><span class="s0">, </span><span class="s1">_ = last(pool</span><span class="s0">, </span><span class="s1">default=(n</span><span class="s0">, None</span><span class="s1">))</span>

    <span class="s5"># Python versiosn below 3.8 don't have math.comb</span>
    <span class="s1">index = </span><span class="s4">1</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">enumerate(reversed(indexes)</span><span class="s0">, </span><span class="s1">start=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">j = n - j</span>
        <span class="s0">if </span><span class="s1">i &lt;= j:</span>
            <span class="s1">index += factorial(j) // (factorial(i) * factorial(j - i))</span>

    <span class="s0">return </span><span class="s1">factorial(n + </span><span class="s4">1</span><span class="s1">) // (factorial(k + </span><span class="s4">1</span><span class="s1">) * factorial(n - k)) - index</span>


<span class="s0">def </span><span class="s1">permutation_index(element</span><span class="s0">, </span><span class="s1">iterable):</span>
    <span class="s3">&quot;&quot;&quot;Equivalent to ``list(permutations(iterable, r)).index(element)``` 
 
    The subsequences of *iterable* that are of length *r* where order is 
    important can be ordered lexicographically. :func:`permutation_index` 
    computes the index of the first *element* directly, without computing 
    the previous permutations. 
 
        &gt;&gt;&gt; permutation_index([1, 3, 2], range(5)) 
        19 
 
    ``ValueError`` will be raised if the given *element* isn't one of the 
    permutations of *iterable*. 
    &quot;&quot;&quot;</span>
    <span class="s1">index = </span><span class="s4">0</span>
    <span class="s1">pool = list(iterable)</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">zip(range(len(pool)</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">element):</span>
        <span class="s1">r = pool.index(x)</span>
        <span class="s1">index = index * i + r</span>
        <span class="s0">del </span><span class="s1">pool[r]</span>

    <span class="s0">return </span><span class="s1">index</span>


<span class="s0">class </span><span class="s1">countable:</span>
    <span class="s3">&quot;&quot;&quot;Wrap *iterable* and keep a count of how many items have been consumed. 
 
    The ``items_seen`` attribute starts at ``0`` and increments as the iterable 
    is consumed: 
 
        &gt;&gt;&gt; iterable = map(str, range(10)) 
        &gt;&gt;&gt; it = countable(iterable) 
        &gt;&gt;&gt; it.items_seen 
        0 
        &gt;&gt;&gt; next(it), next(it) 
        ('0', '1') 
        &gt;&gt;&gt; list(it) 
        ['2', '3', '4', '5', '6', '7', '8', '9'] 
        &gt;&gt;&gt; it.items_seen 
        10 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">iterable):</span>
        <span class="s1">self._it = iter(iterable)</span>
        <span class="s1">self.items_seen = </span><span class="s4">0</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__next__(self):</span>
        <span class="s1">item = next(self._it)</span>
        <span class="s1">self.items_seen += </span><span class="s4">1</span>

        <span class="s0">return </span><span class="s1">item</span>
</pre>
</body>
</html>