<html>
<head>
<title>polynomial.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
polynomial.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
================================================= 
Power Series (:mod:`numpy.polynomial.polynomial`) 
================================================= 
 
This module provides a number of objects (mostly functions) useful for 
dealing with polynomials, including a `Polynomial` class that 
encapsulates the usual arithmetic operations.  (General information 
on how this module represents and works with polynomial objects is in 
the docstring for its &quot;parent&quot; sub-package, `numpy.polynomial`). 
 
Classes 
------- 
.. autosummary:: 
   :toctree: generated/ 
 
   Polynomial 
 
Constants 
--------- 
.. autosummary:: 
   :toctree: generated/ 
 
   polydomain 
   polyzero 
   polyone 
   polyx 
 
Arithmetic 
---------- 
.. autosummary:: 
   :toctree: generated/ 
 
   polyadd 
   polysub 
   polymulx 
   polymul 
   polydiv 
   polypow 
   polyval 
   polyval2d 
   polyval3d 
   polygrid2d 
   polygrid3d 
 
Calculus 
-------- 
.. autosummary:: 
   :toctree: generated/ 
 
   polyder 
   polyint 
 
Misc Functions 
-------------- 
.. autosummary:: 
   :toctree: generated/ 
 
   polyfromroots 
   polyroots 
   polyvalfromroots 
   polyvander 
   polyvander2d 
   polyvander3d 
   polycompanion 
   polyfit 
   polytrim 
   polyline 
 
See Also 
-------- 
`numpy.polynomial` 
 
&quot;&quot;&quot;</span>
<span class="s1">__all__ = [</span>
    <span class="s2">'polyzero'</span><span class="s3">, </span><span class="s2">'polyone'</span><span class="s3">, </span><span class="s2">'polyx'</span><span class="s3">, </span><span class="s2">'polydomain'</span><span class="s3">, </span><span class="s2">'polyline'</span><span class="s3">, </span><span class="s2">'polyadd'</span><span class="s3">,</span>
    <span class="s2">'polysub'</span><span class="s3">, </span><span class="s2">'polymulx'</span><span class="s3">, </span><span class="s2">'polymul'</span><span class="s3">, </span><span class="s2">'polydiv'</span><span class="s3">, </span><span class="s2">'polypow'</span><span class="s3">, </span><span class="s2">'polyval'</span><span class="s3">,</span>
    <span class="s2">'polyvalfromroots'</span><span class="s3">, </span><span class="s2">'polyder'</span><span class="s3">, </span><span class="s2">'polyint'</span><span class="s3">, </span><span class="s2">'polyfromroots'</span><span class="s3">, </span><span class="s2">'polyvander'</span><span class="s3">,</span>
    <span class="s2">'polyfit'</span><span class="s3">, </span><span class="s2">'polytrim'</span><span class="s3">, </span><span class="s2">'polyroots'</span><span class="s3">, </span><span class="s2">'Polynomial'</span><span class="s3">, </span><span class="s2">'polyval2d'</span><span class="s3">, </span><span class="s2">'polyval3d'</span><span class="s3">,</span>
    <span class="s2">'polygrid2d'</span><span class="s3">, </span><span class="s2">'polygrid3d'</span><span class="s3">, </span><span class="s2">'polyvander2d'</span><span class="s3">, </span><span class="s2">'polyvander3d'</span><span class="s1">]</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">numpy.linalg </span><span class="s3">as </span><span class="s1">la</span>
<span class="s3">from </span><span class="s1">numpy.core.multiarray </span><span class="s3">import </span><span class="s1">normalize_axis_index</span>

<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">polyutils </span><span class="s3">as </span><span class="s1">pu</span>
<span class="s3">from </span><span class="s1">._polybase </span><span class="s3">import </span><span class="s1">ABCPolyBase</span>

<span class="s1">polytrim = pu.trimcoef</span>

<span class="s4">#</span>
<span class="s4"># These are constant arrays are of integer type so as to be compatible</span>
<span class="s4"># with the widest range of other types, such as Decimal.</span>
<span class="s4">#</span>

<span class="s4"># Polynomial default domain.</span>
<span class="s1">polydomain = np.array([-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">])</span>

<span class="s4"># Polynomial coefficients representing zero.</span>
<span class="s1">polyzero = np.array([</span><span class="s5">0</span><span class="s1">])</span>

<span class="s4"># Polynomial coefficients representing one.</span>
<span class="s1">polyone = np.array([</span><span class="s5">1</span><span class="s1">])</span>

<span class="s4"># Polynomial coefficients representing the identity x.</span>
<span class="s1">polyx = np.array([</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">])</span>

<span class="s4">#</span>
<span class="s4"># Polynomial series functions</span>
<span class="s4">#</span>


<span class="s3">def </span><span class="s1">polyline(off</span><span class="s3">, </span><span class="s1">scl):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns an array representing a linear polynomial. 
 
    Parameters 
    ---------- 
    off, scl : scalars 
        The &quot;y-intercept&quot; and &quot;slope&quot; of the line, respectively. 
 
    Returns 
    ------- 
    y : ndarray 
        This module's representation of the linear polynomial ``off + 
        scl*x``. 
 
    See Also 
    -------- 
    numpy.polynomial.chebyshev.chebline 
    numpy.polynomial.legendre.legline 
    numpy.polynomial.laguerre.lagline 
    numpy.polynomial.hermite.hermline 
    numpy.polynomial.hermite_e.hermeline 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial import polynomial as P 
    &gt;&gt;&gt; P.polyline(1,-1) 
    array([ 1, -1]) 
    &gt;&gt;&gt; P.polyval(1, P.polyline(1,-1)) # should be 0 
    0.0 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">scl != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.array([off</span><span class="s3">, </span><span class="s1">scl])</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.array([off])</span>


<span class="s3">def </span><span class="s1">polyfromroots(roots):</span>
    <span class="s0">&quot;&quot;&quot; 
    Generate a monic polynomial with given roots. 
 
    Return the coefficients of the polynomial 
 
    .. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n), 
 
    where the ``r_n`` are the roots specified in `roots`.  If a zero has 
    multiplicity n, then it must appear in `roots` n times. For instance, 
    if 2 is a root of multiplicity three and 3 is a root of multiplicity 2, 
    then `roots` looks something like [2, 2, 2, 3, 3]. The roots can appear 
    in any order. 
 
    If the returned coefficients are `c`, then 
 
    .. math:: p(x) = c_0 + c_1 * x + ... +  x^n 
 
    The coefficient of the last term is 1 for monic polynomials in this 
    form. 
 
    Parameters 
    ---------- 
    roots : array_like 
        Sequence containing the roots. 
 
    Returns 
    ------- 
    out : ndarray 
        1-D array of the polynomial's coefficients If all the roots are 
        real, then `out` is also real, otherwise it is complex.  (see 
        Examples below). 
 
    See Also 
    -------- 
    numpy.polynomial.chebyshev.chebfromroots 
    numpy.polynomial.legendre.legfromroots 
    numpy.polynomial.laguerre.lagfromroots 
    numpy.polynomial.hermite.hermfromroots 
    numpy.polynomial.hermite_e.hermefromroots 
 
    Notes 
    ----- 
    The coefficients are determined by multiplying together linear factors 
    of the form ``(x - r_i)``, i.e. 
 
    .. math:: p(x) = (x - r_0) (x - r_1) ... (x - r_n) 
 
    where ``n == len(roots) - 1``; note that this implies that ``1`` is always 
    returned for :math:`a_n`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial import polynomial as P 
    &gt;&gt;&gt; P.polyfromroots((-1,0,1)) # x(x - 1)(x + 1) = x^3 - x 
    array([ 0., -1.,  0.,  1.]) 
    &gt;&gt;&gt; j = complex(0,1) 
    &gt;&gt;&gt; P.polyfromroots((-j,j)) # complex returned, though values are real 
    array([1.+0.j,  0.+0.j,  1.+0.j]) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">pu._fromroots(polyline</span><span class="s3">, </span><span class="s1">polymul</span><span class="s3">, </span><span class="s1">roots)</span>


<span class="s3">def </span><span class="s1">polyadd(c1</span><span class="s3">, </span><span class="s1">c2):</span>
    <span class="s0">&quot;&quot;&quot; 
    Add one polynomial to another. 
 
    Returns the sum of two polynomials `c1` + `c2`.  The arguments are 
    sequences of coefficients from lowest order term to highest, i.e., 
    [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``. 
 
    Parameters 
    ---------- 
    c1, c2 : array_like 
        1-D arrays of polynomial coefficients ordered from low to high. 
 
    Returns 
    ------- 
    out : ndarray 
        The coefficient array representing their sum. 
 
    See Also 
    -------- 
    polysub, polymulx, polymul, polydiv, polypow 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial import polynomial as P 
    &gt;&gt;&gt; c1 = (1,2,3) 
    &gt;&gt;&gt; c2 = (3,2,1) 
    &gt;&gt;&gt; sum = P.polyadd(c1,c2); sum 
    array([4.,  4.,  4.]) 
    &gt;&gt;&gt; P.polyval(2, sum) # 4 + 4(2) + 4(2**2) 
    28.0 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">pu._add(c1</span><span class="s3">, </span><span class="s1">c2)</span>


<span class="s3">def </span><span class="s1">polysub(c1</span><span class="s3">, </span><span class="s1">c2):</span>
    <span class="s0">&quot;&quot;&quot; 
    Subtract one polynomial from another. 
 
    Returns the difference of two polynomials `c1` - `c2`.  The arguments 
    are sequences of coefficients from lowest order term to highest, i.e., 
    [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``. 
 
    Parameters 
    ---------- 
    c1, c2 : array_like 
        1-D arrays of polynomial coefficients ordered from low to 
        high. 
 
    Returns 
    ------- 
    out : ndarray 
        Of coefficients representing their difference. 
 
    See Also 
    -------- 
    polyadd, polymulx, polymul, polydiv, polypow 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial import polynomial as P 
    &gt;&gt;&gt; c1 = (1,2,3) 
    &gt;&gt;&gt; c2 = (3,2,1) 
    &gt;&gt;&gt; P.polysub(c1,c2) 
    array([-2.,  0.,  2.]) 
    &gt;&gt;&gt; P.polysub(c2,c1) # -P.polysub(c1,c2) 
    array([ 2.,  0., -2.]) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">pu._sub(c1</span><span class="s3">, </span><span class="s1">c2)</span>


<span class="s3">def </span><span class="s1">polymulx(c):</span>
    <span class="s0">&quot;&quot;&quot;Multiply a polynomial by x. 
 
    Multiply the polynomial `c` by x, where x is the independent 
    variable. 
 
 
    Parameters 
    ---------- 
    c : array_like 
        1-D array of polynomial coefficients ordered from low to 
        high. 
 
    Returns 
    ------- 
    out : ndarray 
        Array representing the result of the multiplication. 
 
    See Also 
    -------- 
    polyadd, polysub, polymul, polydiv, polypow 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.5.0 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># c is a trimmed copy</span>
    <span class="s1">[c] = pu.as_series([c])</span>
    <span class="s4"># The zero series needs special treatment</span>
    <span class="s3">if </span><span class="s1">len(c) == </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">c[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">c</span>

    <span class="s1">prd = np.empty(len(c) + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">dtype=c.dtype)</span>
    <span class="s1">prd[</span><span class="s5">0</span><span class="s1">] = c[</span><span class="s5">0</span><span class="s1">]*</span><span class="s5">0</span>
    <span class="s1">prd[</span><span class="s5">1</span><span class="s1">:] = c</span>
    <span class="s3">return </span><span class="s1">prd</span>


<span class="s3">def </span><span class="s1">polymul(c1</span><span class="s3">, </span><span class="s1">c2):</span>
    <span class="s0">&quot;&quot;&quot; 
    Multiply one polynomial by another. 
 
    Returns the product of two polynomials `c1` * `c2`.  The arguments are 
    sequences of coefficients, from lowest order term to highest, e.g., 
    [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2.`` 
 
    Parameters 
    ---------- 
    c1, c2 : array_like 
        1-D arrays of coefficients representing a polynomial, relative to the 
        &quot;standard&quot; basis, and ordered from lowest order term to highest. 
 
    Returns 
    ------- 
    out : ndarray 
        Of the coefficients of their product. 
 
    See Also 
    -------- 
    polyadd, polysub, polymulx, polydiv, polypow 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial import polynomial as P 
    &gt;&gt;&gt; c1 = (1,2,3) 
    &gt;&gt;&gt; c2 = (3,2,1) 
    &gt;&gt;&gt; P.polymul(c1,c2) 
    array([  3.,   8.,  14.,   8.,   3.]) 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># c1, c2 are trimmed copies</span>
    <span class="s1">[c1</span><span class="s3">, </span><span class="s1">c2] = pu.as_series([c1</span><span class="s3">, </span><span class="s1">c2])</span>
    <span class="s1">ret = np.convolve(c1</span><span class="s3">, </span><span class="s1">c2)</span>
    <span class="s3">return </span><span class="s1">pu.trimseq(ret)</span>


<span class="s3">def </span><span class="s1">polydiv(c1</span><span class="s3">, </span><span class="s1">c2):</span>
    <span class="s0">&quot;&quot;&quot; 
    Divide one polynomial by another. 
 
    Returns the quotient-with-remainder of two polynomials `c1` / `c2`. 
    The arguments are sequences of coefficients, from lowest order term 
    to highest, e.g., [1,2,3] represents ``1 + 2*x + 3*x**2``. 
 
    Parameters 
    ---------- 
    c1, c2 : array_like 
        1-D arrays of polynomial coefficients ordered from low to high. 
 
    Returns 
    ------- 
    [quo, rem] : ndarrays 
        Of coefficient series representing the quotient and remainder. 
 
    See Also 
    -------- 
    polyadd, polysub, polymulx, polymul, polypow 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial import polynomial as P 
    &gt;&gt;&gt; c1 = (1,2,3) 
    &gt;&gt;&gt; c2 = (3,2,1) 
    &gt;&gt;&gt; P.polydiv(c1,c2) 
    (array([3.]), array([-8., -4.])) 
    &gt;&gt;&gt; P.polydiv(c2,c1) 
    (array([ 0.33333333]), array([ 2.66666667,  1.33333333])) # may vary 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># c1, c2 are trimmed copies</span>
    <span class="s1">[c1</span><span class="s3">, </span><span class="s1">c2] = pu.as_series([c1</span><span class="s3">, </span><span class="s1">c2])</span>
    <span class="s3">if </span><span class="s1">c2[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ZeroDivisionError()</span>

    <span class="s4"># note: this is more efficient than `pu._div(polymul, c1, c2)`</span>
    <span class="s1">lc1 = len(c1)</span>
    <span class="s1">lc2 = len(c2)</span>
    <span class="s3">if </span><span class="s1">lc1 &lt; lc2:</span>
        <span class="s3">return </span><span class="s1">c1[:</span><span class="s5">1</span><span class="s1">]*</span><span class="s5">0</span><span class="s3">, </span><span class="s1">c1</span>
    <span class="s3">elif </span><span class="s1">lc2 == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">c1/c2[-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">c1[:</span><span class="s5">1</span><span class="s1">]*</span><span class="s5">0</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">dlen = lc1 - lc2</span>
        <span class="s1">scl = c2[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">c2 = c2[:-</span><span class="s5">1</span><span class="s1">]/scl</span>
        <span class="s1">i = dlen</span>
        <span class="s1">j = lc1 - </span><span class="s5">1</span>
        <span class="s3">while </span><span class="s1">i &gt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">c1[i:j] -= c2*c1[j]</span>
            <span class="s1">i -= </span><span class="s5">1</span>
            <span class="s1">j -= </span><span class="s5">1</span>
        <span class="s3">return </span><span class="s1">c1[j+</span><span class="s5">1</span><span class="s1">:]/scl</span><span class="s3">, </span><span class="s1">pu.trimseq(c1[:j+</span><span class="s5">1</span><span class="s1">])</span>


<span class="s3">def </span><span class="s1">polypow(c</span><span class="s3">, </span><span class="s1">pow</span><span class="s3">, </span><span class="s1">maxpower=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Raise a polynomial to a power. 
 
    Returns the polynomial `c` raised to the power `pow`. The argument 
    `c` is a sequence of coefficients ordered from low to high. i.e., 
    [1,2,3] is the series  ``1 + 2*x + 3*x**2.`` 
 
    Parameters 
    ---------- 
    c : array_like 
        1-D array of array of series coefficients ordered from low to 
        high degree. 
    pow : integer 
        Power to which the series will be raised 
    maxpower : integer, optional 
        Maximum power allowed. This is mainly to limit growth of the series 
        to unmanageable size. Default is 16 
 
    Returns 
    ------- 
    coef : ndarray 
        Power series of power. 
 
    See Also 
    -------- 
    polyadd, polysub, polymulx, polymul, polydiv 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial import polynomial as P 
    &gt;&gt;&gt; P.polypow([1,2,3], 2) 
    array([ 1., 4., 10., 12., 9.]) 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># note: this is more efficient than `pu._pow(polymul, c1, c2)`, as it</span>
    <span class="s4"># avoids calling `as_series` repeatedly</span>
    <span class="s3">return </span><span class="s1">pu._pow(np.convolve</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">pow</span><span class="s3">, </span><span class="s1">maxpower)</span>


<span class="s3">def </span><span class="s1">polyder(c</span><span class="s3">, </span><span class="s1">m=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">scl=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Differentiate a polynomial. 
 
    Returns the polynomial coefficients `c` differentiated `m` times along 
    `axis`.  At each iteration the result is multiplied by `scl` (the 
    scaling factor is for use in a linear change of variable).  The 
    argument `c` is an array of coefficients from low to high degree along 
    each axis, e.g., [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2`` 
    while [[1,2],[1,2]] represents ``1 + 1*x + 2*y + 2*x*y`` if axis=0 is 
    ``x`` and axis=1 is ``y``. 
 
    Parameters 
    ---------- 
    c : array_like 
        Array of polynomial coefficients. If c is multidimensional the 
        different axis correspond to different variables with the degree 
        in each axis given by the corresponding index. 
    m : int, optional 
        Number of derivatives taken, must be non-negative. (Default: 1) 
    scl : scalar, optional 
        Each differentiation is multiplied by `scl`.  The end result is 
        multiplication by ``scl**m``.  This is for use in a linear change 
        of variable. (Default: 1) 
    axis : int, optional 
        Axis over which the derivative is taken. (Default: 0). 
 
        .. versionadded:: 1.7.0 
 
    Returns 
    ------- 
    der : ndarray 
        Polynomial coefficients of the derivative. 
 
    See Also 
    -------- 
    polyint 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial import polynomial as P 
    &gt;&gt;&gt; c = (1,2,3,4) # 1 + 2x + 3x**2 + 4x**3 
    &gt;&gt;&gt; P.polyder(c) # (d/dx)(c) = 2 + 6x + 12x**2 
    array([  2.,   6.,  12.]) 
    &gt;&gt;&gt; P.polyder(c,3) # (d**3/dx**3)(c) = 24 
    array([24.]) 
    &gt;&gt;&gt; P.polyder(c,scl=-1) # (d/d(-x))(c) = -2 - 6x - 12x**2 
    array([ -2.,  -6., -12.]) 
    &gt;&gt;&gt; P.polyder(c,2,-1) # (d**2/d(-x)**2)(c) = 6 + 24x 
    array([  6.,  24.]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">c = np.array(c</span><span class="s3">, </span><span class="s1">ndmin=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">c.dtype.char </span><span class="s3">in </span><span class="s2">'?bBhHiIlLqQpP'</span><span class="s1">:</span>
        <span class="s4"># astype fails with NA</span>
        <span class="s1">c = c + </span><span class="s5">0.0</span>
    <span class="s1">cdt = c.dtype</span>
    <span class="s1">cnt = pu._deprecate_as_int(m</span><span class="s3">, </span><span class="s2">&quot;the order of derivation&quot;</span><span class="s1">)</span>
    <span class="s1">iaxis = pu._deprecate_as_int(axis</span><span class="s3">, </span><span class="s2">&quot;the axis&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">cnt &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;The order of derivation must be non-negative&quot;</span><span class="s1">)</span>
    <span class="s1">iaxis = normalize_axis_index(iaxis</span><span class="s3">, </span><span class="s1">c.ndim)</span>

    <span class="s3">if </span><span class="s1">cnt == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">c</span>

    <span class="s1">c = np.moveaxis(c</span><span class="s3">, </span><span class="s1">iaxis</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">n = len(c)</span>
    <span class="s3">if </span><span class="s1">cnt &gt;= n:</span>
        <span class="s1">c = c[:</span><span class="s5">1</span><span class="s1">]*</span><span class="s5">0</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(cnt):</span>
            <span class="s1">n = n - </span><span class="s5">1</span>
            <span class="s1">c *= scl</span>
            <span class="s1">der = np.empty((n</span><span class="s3">,</span><span class="s1">) + c.shape[</span><span class="s5">1</span><span class="s1">:]</span><span class="s3">, </span><span class="s1">dtype=cdt)</span>
            <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(n</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">):</span>
                <span class="s1">der[j - </span><span class="s5">1</span><span class="s1">] = j*c[j]</span>
            <span class="s1">c = der</span>
    <span class="s1">c = np.moveaxis(c</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">iaxis)</span>
    <span class="s3">return </span><span class="s1">c</span>


<span class="s3">def </span><span class="s1">polyint(c</span><span class="s3">, </span><span class="s1">m=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">k=[]</span><span class="s3">, </span><span class="s1">lbnd=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">scl=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Integrate a polynomial. 
 
    Returns the polynomial coefficients `c` integrated `m` times from 
    `lbnd` along `axis`.  At each iteration the resulting series is 
    **multiplied** by `scl` and an integration constant, `k`, is added. 
    The scaling factor is for use in a linear change of variable.  (&quot;Buyer 
    beware&quot;: note that, depending on what one is doing, one may want `scl` 
    to be the reciprocal of what one might expect; for more information, 
    see the Notes section below.) The argument `c` is an array of 
    coefficients, from low to high degree along each axis, e.g., [1,2,3] 
    represents the polynomial ``1 + 2*x + 3*x**2`` while [[1,2],[1,2]] 
    represents ``1 + 1*x + 2*y + 2*x*y`` if axis=0 is ``x`` and axis=1 is 
    ``y``. 
 
    Parameters 
    ---------- 
    c : array_like 
        1-D array of polynomial coefficients, ordered from low to high. 
    m : int, optional 
        Order of integration, must be positive. (Default: 1) 
    k : {[], list, scalar}, optional 
        Integration constant(s).  The value of the first integral at zero 
        is the first value in the list, the value of the second integral 
        at zero is the second value, etc.  If ``k == []`` (the default), 
        all constants are set to zero.  If ``m == 1``, a single scalar can 
        be given instead of a list. 
    lbnd : scalar, optional 
        The lower bound of the integral. (Default: 0) 
    scl : scalar, optional 
        Following each integration the result is *multiplied* by `scl` 
        before the integration constant is added. (Default: 1) 
    axis : int, optional 
        Axis over which the integral is taken. (Default: 0). 
 
        .. versionadded:: 1.7.0 
 
    Returns 
    ------- 
    S : ndarray 
        Coefficient array of the integral. 
 
    Raises 
    ------ 
    ValueError 
        If ``m &lt; 1``, ``len(k) &gt; m``, ``np.ndim(lbnd) != 0``, or 
        ``np.ndim(scl) != 0``. 
 
    See Also 
    -------- 
    polyder 
 
    Notes 
    ----- 
    Note that the result of each integration is *multiplied* by `scl`.  Why 
    is this important to note?  Say one is making a linear change of 
    variable :math:`u = ax + b` in an integral relative to `x`. Then 
    :math:`dx = du/a`, so one will need to set `scl` equal to 
    :math:`1/a` - perhaps not what one would have first thought. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial import polynomial as P 
    &gt;&gt;&gt; c = (1,2,3) 
    &gt;&gt;&gt; P.polyint(c) # should return array([0, 1, 1, 1]) 
    array([0.,  1.,  1.,  1.]) 
    &gt;&gt;&gt; P.polyint(c,3) # should return array([0, 0, 0, 1/6, 1/12, 1/20]) 
     array([ 0.        ,  0.        ,  0.        ,  0.16666667,  0.08333333, # may vary 
             0.05      ]) 
    &gt;&gt;&gt; P.polyint(c,k=3) # should return array([3, 1, 1, 1]) 
    array([3.,  1.,  1.,  1.]) 
    &gt;&gt;&gt; P.polyint(c,lbnd=-2) # should return array([6, 1, 1, 1]) 
    array([6.,  1.,  1.,  1.]) 
    &gt;&gt;&gt; P.polyint(c,scl=-2) # should return array([0, -2, -2, -2]) 
    array([ 0., -2., -2., -2.]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">c = np.array(c</span><span class="s3">, </span><span class="s1">ndmin=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">c.dtype.char </span><span class="s3">in </span><span class="s2">'?bBhHiIlLqQpP'</span><span class="s1">:</span>
        <span class="s4"># astype doesn't preserve mask attribute.</span>
        <span class="s1">c = c + </span><span class="s5">0.0</span>
    <span class="s1">cdt = c.dtype</span>
    <span class="s3">if not </span><span class="s1">np.iterable(k):</span>
        <span class="s1">k = [k]</span>
    <span class="s1">cnt = pu._deprecate_as_int(m</span><span class="s3">, </span><span class="s2">&quot;the order of integration&quot;</span><span class="s1">)</span>
    <span class="s1">iaxis = pu._deprecate_as_int(axis</span><span class="s3">, </span><span class="s2">&quot;the axis&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">cnt &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;The order of integration must be non-negative&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">len(k) &gt; cnt:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Too many integration constants&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">np.ndim(lbnd) != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;lbnd must be a scalar.&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">np.ndim(scl) != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;scl must be a scalar.&quot;</span><span class="s1">)</span>
    <span class="s1">iaxis = normalize_axis_index(iaxis</span><span class="s3">, </span><span class="s1">c.ndim)</span>

    <span class="s3">if </span><span class="s1">cnt == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">c</span>

    <span class="s1">k = list(k) + [</span><span class="s5">0</span><span class="s1">]*(cnt - len(k))</span>
    <span class="s1">c = np.moveaxis(c</span><span class="s3">, </span><span class="s1">iaxis</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(cnt):</span>
        <span class="s1">n = len(c)</span>
        <span class="s1">c *= scl</span>
        <span class="s3">if </span><span class="s1">n == </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">np.all(c[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">0</span><span class="s1">):</span>
            <span class="s1">c[</span><span class="s5">0</span><span class="s1">] += k[i]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">tmp = np.empty((n + </span><span class="s5">1</span><span class="s3">,</span><span class="s1">) + c.shape[</span><span class="s5">1</span><span class="s1">:]</span><span class="s3">, </span><span class="s1">dtype=cdt)</span>
            <span class="s1">tmp[</span><span class="s5">0</span><span class="s1">] = c[</span><span class="s5">0</span><span class="s1">]*</span><span class="s5">0</span>
            <span class="s1">tmp[</span><span class="s5">1</span><span class="s1">] = c[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n):</span>
                <span class="s1">tmp[j + </span><span class="s5">1</span><span class="s1">] = c[j]/(j + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">tmp[</span><span class="s5">0</span><span class="s1">] += k[i] - polyval(lbnd</span><span class="s3">, </span><span class="s1">tmp)</span>
            <span class="s1">c = tmp</span>
    <span class="s1">c = np.moveaxis(c</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">iaxis)</span>
    <span class="s3">return </span><span class="s1">c</span>


<span class="s3">def </span><span class="s1">polyval(x</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">tensor=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Evaluate a polynomial at points x. 
 
    If `c` is of length `n + 1`, this function returns the value 
 
    .. math:: p(x) = c_0 + c_1 * x + ... + c_n * x^n 
 
    The parameter `x` is converted to an array only if it is a tuple or a 
    list, otherwise it is treated as a scalar. In either case, either `x` 
    or its elements must support multiplication and addition both with 
    themselves and with the elements of `c`. 
 
    If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If 
    `c` is multidimensional, then the shape of the result depends on the 
    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] + 
    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that 
    scalars have shape (,). 
 
    Trailing zeros in the coefficients will be used in the evaluation, so 
    they should be avoided if efficiency is a concern. 
 
    Parameters 
    ---------- 
    x : array_like, compatible object 
        If `x` is a list or tuple, it is converted to an ndarray, otherwise 
        it is left unchanged and treated as a scalar. In either case, `x` 
        or its elements must support addition and multiplication with 
        with themselves and with the elements of `c`. 
    c : array_like 
        Array of coefficients ordered so that the coefficients for terms of 
        degree n are contained in c[n]. If `c` is multidimensional the 
        remaining indices enumerate multiple polynomials. In the two 
        dimensional case the coefficients may be thought of as stored in 
        the columns of `c`. 
    tensor : boolean, optional 
        If True, the shape of the coefficient array is extended with ones 
        on the right, one for each dimension of `x`. Scalars have dimension 0 
        for this action. The result is that every column of coefficients in 
        `c` is evaluated for every element of `x`. If False, `x` is broadcast 
        over the columns of `c` for the evaluation.  This keyword is useful 
        when `c` is multidimensional. The default value is True. 
 
        .. versionadded:: 1.7.0 
 
    Returns 
    ------- 
    values : ndarray, compatible object 
        The shape of the returned array is described above. 
 
    See Also 
    -------- 
    polyval2d, polygrid2d, polyval3d, polygrid3d 
 
    Notes 
    ----- 
    The evaluation uses Horner's method. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial.polynomial import polyval 
    &gt;&gt;&gt; polyval(1, [1,2,3]) 
    6.0 
    &gt;&gt;&gt; a = np.arange(4).reshape(2,2) 
    &gt;&gt;&gt; a 
    array([[0, 1], 
           [2, 3]]) 
    &gt;&gt;&gt; polyval(a, [1,2,3]) 
    array([[ 1.,   6.], 
           [17.,  34.]]) 
    &gt;&gt;&gt; coef = np.arange(4).reshape(2,2) # multidimensional coefficients 
    &gt;&gt;&gt; coef 
    array([[0, 1], 
           [2, 3]]) 
    &gt;&gt;&gt; polyval([1,2], coef, tensor=True) 
    array([[2.,  4.], 
           [4.,  7.]]) 
    &gt;&gt;&gt; polyval([1,2], coef, tensor=False) 
    array([2.,  7.]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">c = np.array(c</span><span class="s3">, </span><span class="s1">ndmin=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">c.dtype.char </span><span class="s3">in </span><span class="s2">'?bBhHiIlLqQpP'</span><span class="s1">:</span>
        <span class="s4"># astype fails with NA</span>
        <span class="s1">c = c + </span><span class="s5">0.0</span>
    <span class="s3">if </span><span class="s1">isinstance(x</span><span class="s3">, </span><span class="s1">(tuple</span><span class="s3">, </span><span class="s1">list)):</span>
        <span class="s1">x = np.asarray(x)</span>
    <span class="s3">if </span><span class="s1">isinstance(x</span><span class="s3">, </span><span class="s1">np.ndarray) </span><span class="s3">and </span><span class="s1">tensor:</span>
        <span class="s1">c = c.reshape(c.shape + (</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)*x.ndim)</span>

    <span class="s1">c0 = c[-</span><span class="s5">1</span><span class="s1">] + x*</span><span class="s5">0</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s3">, </span><span class="s1">len(c) + </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s1">c0 = c[-i] + c0*x</span>
    <span class="s3">return </span><span class="s1">c0</span>


<span class="s3">def </span><span class="s1">polyvalfromroots(x</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">tensor=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Evaluate a polynomial specified by its roots at points x. 
 
    If `r` is of length `N`, this function returns the value 
 
    .. math:: p(x) = \\prod_{n=1}^{N} (x - r_n) 
 
    The parameter `x` is converted to an array only if it is a tuple or a 
    list, otherwise it is treated as a scalar. In either case, either `x` 
    or its elements must support multiplication and addition both with 
    themselves and with the elements of `r`. 
 
    If `r` is a 1-D array, then `p(x)` will have the same shape as `x`.  If `r` 
    is multidimensional, then the shape of the result depends on the value of 
    `tensor`. If `tensor is ``True`` the shape will be r.shape[1:] + x.shape; 
    that is, each polynomial is evaluated at every value of `x`. If `tensor` is 
    ``False``, the shape will be r.shape[1:]; that is, each polynomial is 
    evaluated only for the corresponding broadcast value of `x`. Note that 
    scalars have shape (,). 
 
    .. versionadded:: 1.12 
 
    Parameters 
    ---------- 
    x : array_like, compatible object 
        If `x` is a list or tuple, it is converted to an ndarray, otherwise 
        it is left unchanged and treated as a scalar. In either case, `x` 
        or its elements must support addition and multiplication with 
        with themselves and with the elements of `r`. 
    r : array_like 
        Array of roots. If `r` is multidimensional the first index is the 
        root index, while the remaining indices enumerate multiple 
        polynomials. For instance, in the two dimensional case the roots 
        of each polynomial may be thought of as stored in the columns of `r`. 
    tensor : boolean, optional 
        If True, the shape of the roots array is extended with ones on the 
        right, one for each dimension of `x`. Scalars have dimension 0 for this 
        action. The result is that every column of coefficients in `r` is 
        evaluated for every element of `x`. If False, `x` is broadcast over the 
        columns of `r` for the evaluation.  This keyword is useful when `r` is 
        multidimensional. The default value is True. 
 
    Returns 
    ------- 
    values : ndarray, compatible object 
        The shape of the returned array is described above. 
 
    See Also 
    -------- 
    polyroots, polyfromroots, polyval 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy.polynomial.polynomial import polyvalfromroots 
    &gt;&gt;&gt; polyvalfromroots(1, [1,2,3]) 
    0.0 
    &gt;&gt;&gt; a = np.arange(4).reshape(2,2) 
    &gt;&gt;&gt; a 
    array([[0, 1], 
           [2, 3]]) 
    &gt;&gt;&gt; polyvalfromroots(a, [-1, 0, 1]) 
    array([[-0.,   0.], 
           [ 6.,  24.]]) 
    &gt;&gt;&gt; r = np.arange(-2, 2).reshape(2,2) # multidimensional coefficients 
    &gt;&gt;&gt; r # each column of r defines one polynomial 
    array([[-2, -1], 
           [ 0,  1]]) 
    &gt;&gt;&gt; b = [-2, 1] 
    &gt;&gt;&gt; polyvalfromroots(b, r, tensor=True) 
    array([[-0.,  3.], 
           [ 3., 0.]]) 
    &gt;&gt;&gt; polyvalfromroots(b, r, tensor=False) 
    array([-0.,  0.]) 
    &quot;&quot;&quot;</span>
    <span class="s1">r = np.array(r</span><span class="s3">, </span><span class="s1">ndmin=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">r.dtype.char </span><span class="s3">in </span><span class="s2">'?bBhHiIlLqQpP'</span><span class="s1">:</span>
        <span class="s1">r = r.astype(np.double)</span>
    <span class="s3">if </span><span class="s1">isinstance(x</span><span class="s3">, </span><span class="s1">(tuple</span><span class="s3">, </span><span class="s1">list)):</span>
        <span class="s1">x = np.asarray(x)</span>
    <span class="s3">if </span><span class="s1">isinstance(x</span><span class="s3">, </span><span class="s1">np.ndarray):</span>
        <span class="s3">if </span><span class="s1">tensor:</span>
            <span class="s1">r = r.reshape(r.shape + (</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)*x.ndim)</span>
        <span class="s3">elif </span><span class="s1">x.ndim &gt;= r.ndim:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;x.ndim must be &lt; r.ndim when tensor == False&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">np.prod(x - r</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">polyval2d(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">c):</span>
    <span class="s0">&quot;&quot;&quot; 
    Evaluate a 2-D polynomial at points (x, y). 
 
    This function returns the value 
 
    .. math:: p(x,y) = \\sum_{i,j} c_{i,j} * x^i * y^j 
 
    The parameters `x` and `y` are converted to arrays only if they are 
    tuples or a lists, otherwise they are treated as a scalars and they 
    must have the same shape after conversion. In either case, either `x` 
    and `y` or their elements must support multiplication and addition both 
    with themselves and with the elements of `c`. 
 
    If `c` has fewer than two dimensions, ones are implicitly appended to 
    its shape to make it 2-D. The shape of the result will be c.shape[2:] + 
    x.shape. 
 
    Parameters 
    ---------- 
    x, y : array_like, compatible objects 
        The two dimensional series is evaluated at the points `(x, y)`, 
        where `x` and `y` must have the same shape. If `x` or `y` is a list 
        or tuple, it is first converted to an ndarray, otherwise it is left 
        unchanged and, if it isn't an ndarray, it is treated as a scalar. 
    c : array_like 
        Array of coefficients ordered so that the coefficient of the term 
        of multi-degree i,j is contained in `c[i,j]`. If `c` has 
        dimension greater than two the remaining indices enumerate multiple 
        sets of coefficients. 
 
    Returns 
    ------- 
    values : ndarray, compatible object 
        The values of the two dimensional polynomial at points formed with 
        pairs of corresponding values from `x` and `y`. 
 
    See Also 
    -------- 
    polyval, polygrid2d, polyval3d, polygrid3d 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.7.0 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">pu._valnd(polyval</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y)</span>


<span class="s3">def </span><span class="s1">polygrid2d(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">c):</span>
    <span class="s0">&quot;&quot;&quot; 
    Evaluate a 2-D polynomial on the Cartesian product of x and y. 
 
    This function returns the values: 
 
    .. math:: p(a,b) = \\sum_{i,j} c_{i,j} * a^i * b^j 
 
    where the points `(a, b)` consist of all pairs formed by taking 
    `a` from `x` and `b` from `y`. The resulting points form a grid with 
    `x` in the first dimension and `y` in the second. 
 
    The parameters `x` and `y` are converted to arrays only if they are 
    tuples or a lists, otherwise they are treated as a scalars. In either 
    case, either `x` and `y` or their elements must support multiplication 
    and addition both with themselves and with the elements of `c`. 
 
    If `c` has fewer than two dimensions, ones are implicitly appended to 
    its shape to make it 2-D. The shape of the result will be c.shape[2:] + 
    x.shape + y.shape. 
 
    Parameters 
    ---------- 
    x, y : array_like, compatible objects 
        The two dimensional series is evaluated at the points in the 
        Cartesian product of `x` and `y`.  If `x` or `y` is a list or 
        tuple, it is first converted to an ndarray, otherwise it is left 
        unchanged and, if it isn't an ndarray, it is treated as a scalar. 
    c : array_like 
        Array of coefficients ordered so that the coefficients for terms of 
        degree i,j are contained in ``c[i,j]``. If `c` has dimension 
        greater than two the remaining indices enumerate multiple sets of 
        coefficients. 
 
    Returns 
    ------- 
    values : ndarray, compatible object 
        The values of the two dimensional polynomial at points in the Cartesian 
        product of `x` and `y`. 
 
    See Also 
    -------- 
    polyval, polyval2d, polyval3d, polygrid3d 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.7.0 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">pu._gridnd(polyval</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y)</span>


<span class="s3">def </span><span class="s1">polyval3d(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">c):</span>
    <span class="s0">&quot;&quot;&quot; 
    Evaluate a 3-D polynomial at points (x, y, z). 
 
    This function returns the values: 
 
    .. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * x^i * y^j * z^k 
 
    The parameters `x`, `y`, and `z` are converted to arrays only if 
    they are tuples or a lists, otherwise they are treated as a scalars and 
    they must have the same shape after conversion. In either case, either 
    `x`, `y`, and `z` or their elements must support multiplication and 
    addition both with themselves and with the elements of `c`. 
 
    If `c` has fewer than 3 dimensions, ones are implicitly appended to its 
    shape to make it 3-D. The shape of the result will be c.shape[3:] + 
    x.shape. 
 
    Parameters 
    ---------- 
    x, y, z : array_like, compatible object 
        The three dimensional series is evaluated at the points 
        `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If 
        any of `x`, `y`, or `z` is a list or tuple, it is first converted 
        to an ndarray, otherwise it is left unchanged and if it isn't an 
        ndarray it is  treated as a scalar. 
    c : array_like 
        Array of coefficients ordered so that the coefficient of the term of 
        multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension 
        greater than 3 the remaining indices enumerate multiple sets of 
        coefficients. 
 
    Returns 
    ------- 
    values : ndarray, compatible object 
        The values of the multidimensional polynomial on points formed with 
        triples of corresponding values from `x`, `y`, and `z`. 
 
    See Also 
    -------- 
    polyval, polyval2d, polygrid2d, polygrid3d 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.7.0 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">pu._valnd(polyval</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z)</span>


<span class="s3">def </span><span class="s1">polygrid3d(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">c):</span>
    <span class="s0">&quot;&quot;&quot; 
    Evaluate a 3-D polynomial on the Cartesian product of x, y and z. 
 
    This function returns the values: 
 
    .. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * a^i * b^j * c^k 
 
    where the points `(a, b, c)` consist of all triples formed by taking 
    `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form 
    a grid with `x` in the first dimension, `y` in the second, and `z` in 
    the third. 
 
    The parameters `x`, `y`, and `z` are converted to arrays only if they 
    are tuples or a lists, otherwise they are treated as a scalars. In 
    either case, either `x`, `y`, and `z` or their elements must support 
    multiplication and addition both with themselves and with the elements 
    of `c`. 
 
    If `c` has fewer than three dimensions, ones are implicitly appended to 
    its shape to make it 3-D. The shape of the result will be c.shape[3:] + 
    x.shape + y.shape + z.shape. 
 
    Parameters 
    ---------- 
    x, y, z : array_like, compatible objects 
        The three dimensional series is evaluated at the points in the 
        Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a 
        list or tuple, it is first converted to an ndarray, otherwise it is 
        left unchanged and, if it isn't an ndarray, it is treated as a 
        scalar. 
    c : array_like 
        Array of coefficients ordered so that the coefficients for terms of 
        degree i,j are contained in ``c[i,j]``. If `c` has dimension 
        greater than two the remaining indices enumerate multiple sets of 
        coefficients. 
 
    Returns 
    ------- 
    values : ndarray, compatible object 
        The values of the two dimensional polynomial at points in the Cartesian 
        product of `x` and `y`. 
 
    See Also 
    -------- 
    polyval, polyval2d, polygrid2d, polyval3d 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.7.0 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">pu._gridnd(polyval</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z)</span>


<span class="s3">def </span><span class="s1">polyvander(x</span><span class="s3">, </span><span class="s1">deg):</span>
    <span class="s0">&quot;&quot;&quot;Vandermonde matrix of given degree. 
 
    Returns the Vandermonde matrix of degree `deg` and sample points 
    `x`. The Vandermonde matrix is defined by 
 
    .. math:: V[..., i] = x^i, 
 
    where `0 &lt;= i &lt;= deg`. The leading indices of `V` index the elements of 
    `x` and the last index is the power of `x`. 
 
    If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the 
    matrix ``V = polyvander(x, n)``, then ``np.dot(V, c)`` and 
    ``polyval(x, c)`` are the same up to roundoff. This equivalence is 
    useful both for least squares fitting and for the evaluation of a large 
    number of polynomials of the same degree and sample points. 
 
    Parameters 
    ---------- 
    x : array_like 
        Array of points. The dtype is converted to float64 or complex128 
        depending on whether any of the elements are complex. If `x` is 
        scalar it is converted to a 1-D array. 
    deg : int 
        Degree of the resulting matrix. 
 
    Returns 
    ------- 
    vander : ndarray. 
        The Vandermonde matrix. The shape of the returned matrix is 
        ``x.shape + (deg + 1,)``, where the last index is the power of `x`. 
        The dtype will be the same as the converted `x`. 
 
    See Also 
    -------- 
    polyvander2d, polyvander3d 
 
    &quot;&quot;&quot;</span>
    <span class="s1">ideg = pu._deprecate_as_int(deg</span><span class="s3">, </span><span class="s2">&quot;deg&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">ideg &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;deg must be non-negative&quot;</span><span class="s1">)</span>

    <span class="s1">x = np.array(x</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False, </span><span class="s1">ndmin=</span><span class="s5">1</span><span class="s1">) + </span><span class="s5">0.0</span>
    <span class="s1">dims = (ideg + </span><span class="s5">1</span><span class="s3">,</span><span class="s1">) + x.shape</span>
    <span class="s1">dtyp = x.dtype</span>
    <span class="s1">v = np.empty(dims</span><span class="s3">, </span><span class="s1">dtype=dtyp)</span>
    <span class="s1">v[</span><span class="s5">0</span><span class="s1">] = x*</span><span class="s5">0 </span><span class="s1">+ </span><span class="s5">1</span>
    <span class="s3">if </span><span class="s1">ideg &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">v[</span><span class="s5">1</span><span class="s1">] = x</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s3">, </span><span class="s1">ideg + </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">v[i] = v[i-</span><span class="s5">1</span><span class="s1">]*x</span>
    <span class="s3">return </span><span class="s1">np.moveaxis(v</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">polyvander2d(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">deg):</span>
    <span class="s0">&quot;&quot;&quot;Pseudo-Vandermonde matrix of given degrees. 
 
    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample 
    points `(x, y)`. The pseudo-Vandermonde matrix is defined by 
 
    .. math:: V[..., (deg[1] + 1)*i + j] = x^i * y^j, 
 
    where `0 &lt;= i &lt;= deg[0]` and `0 &lt;= j &lt;= deg[1]`. The leading indices of 
    `V` index the points `(x, y)` and the last index encodes the powers of 
    `x` and `y`. 
 
    If ``V = polyvander2d(x, y, [xdeg, ydeg])``, then the columns of `V` 
    correspond to the elements of a 2-D coefficient array `c` of shape 
    (xdeg + 1, ydeg + 1) in the order 
 
    .. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ... 
 
    and ``np.dot(V, c.flat)`` and ``polyval2d(x, y, c)`` will be the same 
    up to roundoff. This equivalence is useful both for least squares 
    fitting and for the evaluation of a large number of 2-D polynomials 
    of the same degrees and sample points. 
 
    Parameters 
    ---------- 
    x, y : array_like 
        Arrays of point coordinates, all of the same shape. The dtypes 
        will be converted to either float64 or complex128 depending on 
        whether any of the elements are complex. Scalars are converted to 
        1-D arrays. 
    deg : list of ints 
        List of maximum degrees of the form [x_deg, y_deg]. 
 
    Returns 
    ------- 
    vander2d : ndarray 
        The shape of the returned matrix is ``x.shape + (order,)``, where 
        :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same 
        as the converted `x` and `y`. 
 
    See Also 
    -------- 
    polyvander, polyvander3d, polyval2d, polyval3d 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">pu._vander_nd_flat((polyvander</span><span class="s3">, </span><span class="s1">polyvander)</span><span class="s3">, </span><span class="s1">(x</span><span class="s3">, </span><span class="s1">y)</span><span class="s3">, </span><span class="s1">deg)</span>


<span class="s3">def </span><span class="s1">polyvander3d(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">deg):</span>
    <span class="s0">&quot;&quot;&quot;Pseudo-Vandermonde matrix of given degrees. 
 
    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample 
    points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`, 
    then The pseudo-Vandermonde matrix is defined by 
 
    .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = x^i * y^j * z^k, 
 
    where `0 &lt;= i &lt;= l`, `0 &lt;= j &lt;= m`, and `0 &lt;= j &lt;= n`.  The leading 
    indices of `V` index the points `(x, y, z)` and the last index encodes 
    the powers of `x`, `y`, and `z`. 
 
    If ``V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns 
    of `V` correspond to the elements of a 3-D coefficient array `c` of 
    shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order 
 
    .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},... 
 
    and  ``np.dot(V, c.flat)`` and ``polyval3d(x, y, z, c)`` will be the 
    same up to roundoff. This equivalence is useful both for least squares 
    fitting and for the evaluation of a large number of 3-D polynomials 
    of the same degrees and sample points. 
 
    Parameters 
    ---------- 
    x, y, z : array_like 
        Arrays of point coordinates, all of the same shape. The dtypes will 
        be converted to either float64 or complex128 depending on whether 
        any of the elements are complex. Scalars are converted to 1-D 
        arrays. 
    deg : list of ints 
        List of maximum degrees of the form [x_deg, y_deg, z_deg]. 
 
    Returns 
    ------- 
    vander3d : ndarray 
        The shape of the returned matrix is ``x.shape + (order,)``, where 
        :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will 
        be the same as the converted `x`, `y`, and `z`. 
 
    See Also 
    -------- 
    polyvander, polyvander3d, polyval2d, polyval3d 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.7.0 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">pu._vander_nd_flat((polyvander</span><span class="s3">, </span><span class="s1">polyvander</span><span class="s3">, </span><span class="s1">polyvander)</span><span class="s3">, </span><span class="s1">(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z)</span><span class="s3">, </span><span class="s1">deg)</span>


<span class="s3">def </span><span class="s1">polyfit(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">deg</span><span class="s3">, </span><span class="s1">rcond=</span><span class="s3">None, </span><span class="s1">full=</span><span class="s3">False, </span><span class="s1">w=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Least-squares fit of a polynomial to data. 
 
    Return the coefficients of a polynomial of degree `deg` that is the 
    least squares fit to the data values `y` given at points `x`. If `y` is 
    1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple 
    fits are done, one for each column of `y`, and the resulting 
    coefficients are stored in the corresponding columns of a 2-D return. 
    The fitted polynomial(s) are in the form 
 
    .. math::  p(x) = c_0 + c_1 * x + ... + c_n * x^n, 
 
    where `n` is `deg`. 
 
    Parameters 
    ---------- 
    x : array_like, shape (`M`,) 
        x-coordinates of the `M` sample (data) points ``(x[i], y[i])``. 
    y : array_like, shape (`M`,) or (`M`, `K`) 
        y-coordinates of the sample points.  Several sets of sample points 
        sharing the same x-coordinates can be (independently) fit with one 
        call to `polyfit` by passing in for `y` a 2-D array that contains 
        one data set per column. 
    deg : int or 1-D array_like 
        Degree(s) of the fitting polynomials. If `deg` is a single integer 
        all terms up to and including the `deg`'th term are included in the 
        fit. For NumPy versions &gt;= 1.11.0 a list of integers specifying the 
        degrees of the terms to include may be used instead. 
    rcond : float, optional 
        Relative condition number of the fit.  Singular values smaller 
        than `rcond`, relative to the largest singular value, will be 
        ignored.  The default value is ``len(x)*eps``, where `eps` is the 
        relative precision of the platform's float type, about 2e-16 in 
        most cases. 
    full : bool, optional 
        Switch determining the nature of the return value.  When ``False`` 
        (the default) just the coefficients are returned; when ``True``, 
        diagnostic information from the singular value decomposition (used 
        to solve the fit's matrix equation) is also returned. 
    w : array_like, shape (`M`,), optional 
        Weights. If not None, the weight ``w[i]`` applies to the unsquared 
        residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are 
        chosen so that the errors of the products ``w[i]*y[i]`` all have the 
        same variance.  When using inverse-variance weighting, use 
        ``w[i] = 1/sigma(y[i])``.  The default value is None. 
 
        .. versionadded:: 1.5.0 
 
    Returns 
    ------- 
    coef : ndarray, shape (`deg` + 1,) or (`deg` + 1, `K`) 
        Polynomial coefficients ordered from low to high.  If `y` was 2-D, 
        the coefficients in column `k` of `coef` represent the polynomial 
        fit to the data in `y`'s `k`-th column. 
 
    [residuals, rank, singular_values, rcond] : list 
        These values are only returned if ``full == True`` 
 
        - residuals -- sum of squared residuals of the least squares fit 
        - rank -- the numerical rank of the scaled Vandermonde matrix 
        - singular_values -- singular values of the scaled Vandermonde matrix 
        - rcond -- value of `rcond`. 
 
        For more details, see `numpy.linalg.lstsq`. 
 
    Raises 
    ------ 
    RankWarning 
        Raised if the matrix in the least-squares fit is rank deficient. 
        The warning is only raised if ``full == False``.  The warnings can 
        be turned off by: 
 
        &gt;&gt;&gt; import warnings 
        &gt;&gt;&gt; warnings.simplefilter('ignore', np.RankWarning) 
 
    See Also 
    -------- 
    numpy.polynomial.chebyshev.chebfit 
    numpy.polynomial.legendre.legfit 
    numpy.polynomial.laguerre.lagfit 
    numpy.polynomial.hermite.hermfit 
    numpy.polynomial.hermite_e.hermefit 
    polyval : Evaluates a polynomial. 
    polyvander : Vandermonde matrix for powers. 
    numpy.linalg.lstsq : Computes a least-squares fit from the matrix. 
    scipy.interpolate.UnivariateSpline : Computes spline fits. 
 
    Notes 
    ----- 
    The solution is the coefficients of the polynomial `p` that minimizes 
    the sum of the weighted squared errors 
 
    .. math:: E = \\sum_j w_j^2 * |y_j - p(x_j)|^2, 
 
    where the :math:`w_j` are the weights. This problem is solved by 
    setting up the (typically) over-determined matrix equation: 
 
    .. math:: V(x) * c = w * y, 
 
    where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the 
    coefficients to be solved for, `w` are the weights, and `y` are the 
    observed values.  This equation is then solved using the singular value 
    decomposition of `V`. 
 
    If some of the singular values of `V` are so small that they are 
    neglected (and `full` == ``False``), a `RankWarning` will be raised. 
    This means that the coefficient values may be poorly determined. 
    Fitting to a lower order polynomial will usually get rid of the warning 
    (but may not be what you want, of course; if you have independent 
    reason(s) for choosing the degree which isn't working, you may have to: 
    a) reconsider those reasons, and/or b) reconsider the quality of your 
    data).  The `rcond` parameter can also be set to a value smaller than 
    its default, but the resulting fit may be spurious and have large 
    contributions from roundoff error. 
 
    Polynomial fits using double precision tend to &quot;fail&quot; at about 
    (polynomial) degree 20. Fits using Chebyshev or Legendre series are 
    generally better conditioned, but much can still depend on the 
    distribution of the sample points and the smoothness of the data.  If 
    the quality of the fit is inadequate, splines may be a good 
    alternative. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.random.seed(123) 
    &gt;&gt;&gt; from numpy.polynomial import polynomial as P 
    &gt;&gt;&gt; x = np.linspace(-1,1,51) # x &quot;data&quot;: [-1, -0.96, ..., 0.96, 1] 
    &gt;&gt;&gt; y = x**3 - x + np.random.randn(len(x)) # x^3 - x + N(0,1) &quot;noise&quot; 
    &gt;&gt;&gt; c, stats = P.polyfit(x,y,3,full=True) 
    &gt;&gt;&gt; np.random.seed(123) 
    &gt;&gt;&gt; c # c[0], c[2] should be approx. 0, c[1] approx. -1, c[3] approx. 1 
    array([ 0.01909725, -1.30598256, -0.00577963,  1.02644286]) # may vary 
    &gt;&gt;&gt; stats # note the large SSR, explaining the rather poor results 
     [array([ 38.06116253]), 4, array([ 1.38446749,  1.32119158,  0.50443316, # may vary 
              0.28853036]), 1.1324274851176597e-014] 
 
    Same thing without the added noise 
 
    &gt;&gt;&gt; y = x**3 - x 
    &gt;&gt;&gt; c, stats = P.polyfit(x,y,3,full=True) 
    &gt;&gt;&gt; c # c[0], c[2] should be &quot;very close to 0&quot;, c[1] ~= -1, c[3] ~= 1 
    array([-6.36925336e-18, -1.00000000e+00, -4.08053781e-16,  1.00000000e+00]) 
    &gt;&gt;&gt; stats # note the minuscule SSR 
    [array([  7.46346754e-31]), 4, array([ 1.38446749,  1.32119158, # may vary 
               0.50443316,  0.28853036]), 1.1324274851176597e-014] 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">pu._fit(polyvander</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">deg</span><span class="s3">, </span><span class="s1">rcond</span><span class="s3">, </span><span class="s1">full</span><span class="s3">, </span><span class="s1">w)</span>


<span class="s3">def </span><span class="s1">polycompanion(c):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the companion matrix of c. 
 
    The companion matrix for power series cannot be made symmetric by 
    scaling the basis, so this function differs from those for the 
    orthogonal polynomials. 
 
    Parameters 
    ---------- 
    c : array_like 
        1-D array of polynomial coefficients ordered from low to high 
        degree. 
 
    Returns 
    ------- 
    mat : ndarray 
        Companion matrix of dimensions (deg, deg). 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.7.0 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># c is a trimmed copy</span>
    <span class="s1">[c] = pu.as_series([c])</span>
    <span class="s3">if </span><span class="s1">len(c) &lt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'Series must have maximum degree of at least 1.'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">len(c) == </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.array([[-c[</span><span class="s5">0</span><span class="s1">]/c[</span><span class="s5">1</span><span class="s1">]]])</span>

    <span class="s1">n = len(c) - </span><span class="s5">1</span>
    <span class="s1">mat = np.zeros((n</span><span class="s3">, </span><span class="s1">n)</span><span class="s3">, </span><span class="s1">dtype=c.dtype)</span>
    <span class="s1">bot = mat.reshape(-</span><span class="s5">1</span><span class="s1">)[n::n+</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">bot[...] = </span><span class="s5">1</span>
    <span class="s1">mat[:</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">] -= c[:-</span><span class="s5">1</span><span class="s1">]/c[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3">return </span><span class="s1">mat</span>


<span class="s3">def </span><span class="s1">polyroots(c):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the roots of a polynomial. 
 
    Return the roots (a.k.a. &quot;zeros&quot;) of the polynomial 
 
    .. math:: p(x) = \\sum_i c[i] * x^i. 
 
    Parameters 
    ---------- 
    c : 1-D array_like 
        1-D array of polynomial coefficients. 
 
    Returns 
    ------- 
    out : ndarray 
        Array of the roots of the polynomial. If all the roots are real, 
        then `out` is also real, otherwise it is complex. 
 
    See Also 
    -------- 
    numpy.polynomial.chebyshev.chebroots 
    numpy.polynomial.legendre.legroots 
    numpy.polynomial.laguerre.lagroots 
    numpy.polynomial.hermite.hermroots 
    numpy.polynomial.hermite_e.hermeroots 
 
    Notes 
    ----- 
    The root estimates are obtained as the eigenvalues of the companion 
    matrix, Roots far from the origin of the complex plane may have large 
    errors due to the numerical instability of the power series for such 
    values. Roots with multiplicity greater than 1 will also show larger 
    errors as the value of the series near such points is relatively 
    insensitive to errors in the roots. Isolated roots near the origin can 
    be improved by a few iterations of Newton's method. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy.polynomial.polynomial as poly 
    &gt;&gt;&gt; poly.polyroots(poly.polyfromroots((-1,0,1))) 
    array([-1.,  0.,  1.]) 
    &gt;&gt;&gt; poly.polyroots(poly.polyfromroots((-1,0,1))).dtype 
    dtype('float64') 
    &gt;&gt;&gt; j = complex(0,1) 
    &gt;&gt;&gt; poly.polyroots(poly.polyfromroots((-j,0,j))) 
    array([  0.00000000e+00+0.j,   0.00000000e+00+1.j,   2.77555756e-17-1.j]) # may vary 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># c is a trimmed copy</span>
    <span class="s1">[c] = pu.as_series([c])</span>
    <span class="s3">if </span><span class="s1">len(c) &lt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.array([]</span><span class="s3">, </span><span class="s1">dtype=c.dtype)</span>
    <span class="s3">if </span><span class="s1">len(c) == </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.array([-c[</span><span class="s5">0</span><span class="s1">]/c[</span><span class="s5">1</span><span class="s1">]])</span>

    <span class="s4"># rotated companion matrix reduces error</span>
    <span class="s1">m = polycompanion(c)[::-</span><span class="s5">1</span><span class="s3">,</span><span class="s1">::-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">r = la.eigvals(m)</span>
    <span class="s1">r.sort()</span>
    <span class="s3">return </span><span class="s1">r</span>


<span class="s4">#</span>
<span class="s4"># polynomial class</span>
<span class="s4">#</span>

<span class="s3">class </span><span class="s1">Polynomial(ABCPolyBase):</span>
    <span class="s0">&quot;&quot;&quot;A power series class. 
 
    The Polynomial class provides the standard Python numerical methods 
    '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the 
    attributes and methods listed in the `ABCPolyBase` documentation. 
 
    Parameters 
    ---------- 
    coef : array_like 
        Polynomial coefficients in order of increasing degree, i.e., 
        ``(1, 2, 3)`` give ``1 + 2*x + 3*x**2``. 
    domain : (2,) array_like, optional 
        Domain to use. The interval ``[domain[0], domain[1]]`` is mapped 
        to the interval ``[window[0], window[1]]`` by shifting and scaling. 
        The default value is [-1, 1]. 
    window : (2,) array_like, optional 
        Window, see `domain` for its use. The default value is [-1, 1]. 
 
        .. versionadded:: 1.6.0 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># Virtual Functions</span>
    <span class="s1">_add = staticmethod(polyadd)</span>
    <span class="s1">_sub = staticmethod(polysub)</span>
    <span class="s1">_mul = staticmethod(polymul)</span>
    <span class="s1">_div = staticmethod(polydiv)</span>
    <span class="s1">_pow = staticmethod(polypow)</span>
    <span class="s1">_val = staticmethod(polyval)</span>
    <span class="s1">_int = staticmethod(polyint)</span>
    <span class="s1">_der = staticmethod(polyder)</span>
    <span class="s1">_fit = staticmethod(polyfit)</span>
    <span class="s1">_line = staticmethod(polyline)</span>
    <span class="s1">_roots = staticmethod(polyroots)</span>
    <span class="s1">_fromroots = staticmethod(polyfromroots)</span>

    <span class="s4"># Virtual properties</span>
    <span class="s1">domain = np.array(polydomain)</span>
    <span class="s1">window = np.array(polydomain)</span>
    <span class="s1">basis_name = </span><span class="s3">None</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_str_term_unicode(cls</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">arg_str):</span>
        <span class="s3">return </span><span class="s2">f&quot;·</span><span class="s3">{</span><span class="s1">arg_str</span><span class="s3">}{</span><span class="s1">i.translate(cls._superscript_mapping)</span><span class="s3">}</span><span class="s2">&quot;</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">_str_term_ascii(i</span><span class="s3">, </span><span class="s1">arg_str):</span>
        <span class="s3">return </span><span class="s2">f&quot; </span><span class="s3">{</span><span class="s1">arg_str</span><span class="s3">}</span><span class="s2">**</span><span class="s3">{</span><span class="s1">i</span><span class="s3">}</span><span class="s2">&quot;</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">_repr_latex_term(i</span><span class="s3">, </span><span class="s1">arg_str</span><span class="s3">, </span><span class="s1">needs_parens):</span>
        <span class="s3">if </span><span class="s1">needs_parens:</span>
            <span class="s1">arg_str = </span><span class="s2">rf&quot;\left(</span><span class="s3">{</span><span class="s1">arg_str</span><span class="s3">}</span><span class="s2">\right)&quot;</span>
        <span class="s3">if </span><span class="s1">i == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s2">'1'</span>
        <span class="s3">elif </span><span class="s1">i == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">arg_str</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s2">f&quot;</span><span class="s3">{</span><span class="s1">arg_str</span><span class="s3">}</span><span class="s2">^</span><span class="s3">{{{</span><span class="s1">i</span><span class="s3">}}}</span><span class="s2">&quot;</span>
</pre>
</body>
</html>