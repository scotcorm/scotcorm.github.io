<html>
<head>
<title>_streamline.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_streamline.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">absolute_import</span>

<span class="s0">import </span><span class="s1">math</span>

<span class="s0">from </span><span class="s1">plotly </span><span class="s0">import </span><span class="s1">exceptions</span><span class="s0">, </span><span class="s1">optional_imports</span>
<span class="s0">from </span><span class="s1">plotly.figure_factory </span><span class="s0">import </span><span class="s1">utils</span>
<span class="s0">from </span><span class="s1">plotly.graph_objs </span><span class="s0">import </span><span class="s1">graph_objs</span>

<span class="s1">np = optional_imports.get_module(</span><span class="s2">&quot;numpy&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">validate_streamline(x</span><span class="s0">, </span><span class="s1">y):</span>
    <span class="s3">&quot;&quot;&quot; 
    Streamline-specific validations 
 
    Specifically, this checks that x and y are both evenly spaced, 
    and that the package numpy is available. 
 
    See FigureFactory.create_streamline() for params 
 
    :raises: (ImportError) If numpy is not available. 
    :raises: (PlotlyError) If x is not evenly spaced. 
    :raises: (PlotlyError) If y is not evenly spaced. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">np </span><span class="s0">is False</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ImportError(</span><span class="s2">&quot;FigureFactory.create_streamline requires numpy&quot;</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(len(x) - </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">((x[index + </span><span class="s4">1</span><span class="s1">] - x[index]) - (x[</span><span class="s4">1</span><span class="s1">] - x[</span><span class="s4">0</span><span class="s1">])) &gt; </span><span class="s4">0.0001</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">exceptions.PlotlyError(</span>
                <span class="s2">&quot;x must be a 1 dimensional, &quot; &quot;evenly spaced array&quot;</span>
            <span class="s1">)</span>
    <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(len(y) - </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">((y[index + </span><span class="s4">1</span><span class="s1">] - y[index]) - (y[</span><span class="s4">1</span><span class="s1">] - y[</span><span class="s4">0</span><span class="s1">])) &gt; </span><span class="s4">0.0001</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">exceptions.PlotlyError(</span>
                <span class="s2">&quot;y must be a 1 dimensional, &quot; &quot;evenly spaced array&quot;</span>
            <span class="s1">)</span>


<span class="s0">def </span><span class="s1">create_streamline(</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">density=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">angle=math.pi / </span><span class="s4">9</span><span class="s0">, </span><span class="s1">arrow_scale=</span><span class="s4">0.09</span><span class="s0">, </span><span class="s1">**kwargs</span>
<span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Returns data for a streamline plot. 
 
    :param (list|ndarray) x: 1 dimensional, evenly spaced list or array 
    :param (list|ndarray) y: 1 dimensional, evenly spaced list or array 
    :param (ndarray) u: 2 dimensional array 
    :param (ndarray) v: 2 dimensional array 
    :param (float|int) density: controls the density of streamlines in 
        plot. This is multiplied by 30 to scale similiarly to other 
        available streamline functions such as matplotlib. 
        Default = 1 
    :param (angle in radians) angle: angle of arrowhead. Default = pi/9 
    :param (float in [0,1]) arrow_scale: value to scale length of arrowhead 
        Default = .09 
    :param kwargs: kwargs passed through plotly.graph_objs.Scatter 
        for more information on valid kwargs call 
        help(plotly.graph_objs.Scatter) 
 
    :rtype (dict): returns a representation of streamline figure. 
 
    Example 1: Plot simple streamline and increase arrow size 
 
    &gt;&gt;&gt; from plotly.figure_factory import create_streamline 
    &gt;&gt;&gt; import plotly.graph_objects as go 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import math 
 
    &gt;&gt;&gt; # Add data 
    &gt;&gt;&gt; x = np.linspace(-3, 3, 100) 
    &gt;&gt;&gt; y = np.linspace(-3, 3, 100) 
    &gt;&gt;&gt; Y, X = np.meshgrid(x, y) 
    &gt;&gt;&gt; u = -1 - X**2 + Y 
    &gt;&gt;&gt; v = 1 + X - Y**2 
    &gt;&gt;&gt; u = u.T  # Transpose 
    &gt;&gt;&gt; v = v.T  # Transpose 
 
    &gt;&gt;&gt; # Create streamline 
    &gt;&gt;&gt; fig = create_streamline(x, y, u, v, arrow_scale=.1) 
    &gt;&gt;&gt; fig.show() 
 
    Example 2: from nbviewer.ipython.org/github/barbagroup/AeroPython 
 
    &gt;&gt;&gt; from plotly.figure_factory import create_streamline 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import math 
 
    &gt;&gt;&gt; # Add data 
    &gt;&gt;&gt; N = 50 
    &gt;&gt;&gt; x_start, x_end = -2.0, 2.0 
    &gt;&gt;&gt; y_start, y_end = -1.0, 1.0 
    &gt;&gt;&gt; x = np.linspace(x_start, x_end, N) 
    &gt;&gt;&gt; y = np.linspace(y_start, y_end, N) 
    &gt;&gt;&gt; X, Y = np.meshgrid(x, y) 
    &gt;&gt;&gt; ss = 5.0 
    &gt;&gt;&gt; x_s, y_s = -1.0, 0.0 
 
    &gt;&gt;&gt; # Compute the velocity field on the mesh grid 
    &gt;&gt;&gt; u_s = ss/(2*np.pi) * (X-x_s)/((X-x_s)**2 + (Y-y_s)**2) 
    &gt;&gt;&gt; v_s = ss/(2*np.pi) * (Y-y_s)/((X-x_s)**2 + (Y-y_s)**2) 
 
    &gt;&gt;&gt; # Create streamline 
    &gt;&gt;&gt; fig = create_streamline(x, y, u_s, v_s, density=2, name='streamline') 
 
    &gt;&gt;&gt; # Add source point 
    &gt;&gt;&gt; point = go.Scatter(x=[x_s], y=[y_s], mode='markers', 
    ...                    marker_size=14, name='source point') 
 
    &gt;&gt;&gt; fig.add_trace(point) # doctest: +SKIP 
    &gt;&gt;&gt; fig.show() 
    &quot;&quot;&quot;</span>
    <span class="s1">utils.validate_equal_length(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">utils.validate_equal_length(u</span><span class="s0">, </span><span class="s1">v)</span>
    <span class="s1">validate_streamline(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">utils.validate_positive_scalars(density=density</span><span class="s0">, </span><span class="s1">arrow_scale=arrow_scale)</span>

    <span class="s1">streamline_x</span><span class="s0">, </span><span class="s1">streamline_y = _Streamline(</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">density</span><span class="s0">, </span><span class="s1">angle</span><span class="s0">, </span><span class="s1">arrow_scale</span>
    <span class="s1">).sum_streamlines()</span>
    <span class="s1">arrow_x</span><span class="s0">, </span><span class="s1">arrow_y = _Streamline(</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">density</span><span class="s0">, </span><span class="s1">angle</span><span class="s0">, </span><span class="s1">arrow_scale</span>
    <span class="s1">).get_streamline_arrows()</span>

    <span class="s1">streamline = graph_objs.Scatter(</span>
        <span class="s1">x=streamline_x + arrow_x</span><span class="s0">, </span><span class="s1">y=streamline_y + arrow_y</span><span class="s0">, </span><span class="s1">mode=</span><span class="s2">&quot;lines&quot;</span><span class="s0">, </span><span class="s1">**kwargs</span>
    <span class="s1">)</span>

    <span class="s1">data = [streamline]</span>
    <span class="s1">layout = graph_objs.Layout(hovermode=</span><span class="s2">&quot;closest&quot;</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">graph_objs.Figure(data=data</span><span class="s0">, </span><span class="s1">layout=layout)</span>


<span class="s0">class </span><span class="s1">_Streamline(object):</span>
    <span class="s3">&quot;&quot;&quot; 
    Refer to FigureFactory.create_streamline() for docstring 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">density</span><span class="s0">, </span><span class="s1">angle</span><span class="s0">, </span><span class="s1">arrow_scale</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self.x = np.array(x)</span>
        <span class="s1">self.y = np.array(y)</span>
        <span class="s1">self.u = np.array(u)</span>
        <span class="s1">self.v = np.array(v)</span>
        <span class="s1">self.angle = angle</span>
        <span class="s1">self.arrow_scale = arrow_scale</span>
        <span class="s1">self.density = int(</span><span class="s4">30 </span><span class="s1">* density)  </span><span class="s5"># Scale similarly to other functions</span>
        <span class="s1">self.delta_x = self.x[</span><span class="s4">1</span><span class="s1">] - self.x[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.delta_y = self.y[</span><span class="s4">1</span><span class="s1">] - self.y[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.val_x = self.x</span>
        <span class="s1">self.val_y = self.y</span>

        <span class="s5"># Set up spacing</span>
        <span class="s1">self.blank = np.zeros((self.density</span><span class="s0">, </span><span class="s1">self.density))</span>
        <span class="s1">self.spacing_x = len(self.x) / float(self.density - </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.spacing_y = len(self.y) / float(self.density - </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.trajectories = []</span>

        <span class="s5"># Rescale speed onto axes-coordinates</span>
        <span class="s1">self.u = self.u / (self.x[-</span><span class="s4">1</span><span class="s1">] - self.x[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">self.v = self.v / (self.y[-</span><span class="s4">1</span><span class="s1">] - self.y[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">self.speed = np.sqrt(self.u ** </span><span class="s4">2 </span><span class="s1">+ self.v ** </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s5"># Rescale u and v for integrations.</span>
        <span class="s1">self.u *= len(self.x)</span>
        <span class="s1">self.v *= len(self.y)</span>
        <span class="s1">self.st_x = []</span>
        <span class="s1">self.st_y = []</span>
        <span class="s1">self.get_streamlines()</span>
        <span class="s1">streamline_x</span><span class="s0">, </span><span class="s1">streamline_y = self.sum_streamlines()</span>
        <span class="s1">arrows_x</span><span class="s0">, </span><span class="s1">arrows_y = self.get_streamline_arrows()</span>

    <span class="s0">def </span><span class="s1">blank_pos(self</span><span class="s0">, </span><span class="s1">xi</span><span class="s0">, </span><span class="s1">yi):</span>
        <span class="s3">&quot;&quot;&quot; 
        Set up positions for trajectories to be used with rk4 function. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">(int((xi / self.spacing_x) + </span><span class="s4">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">int((yi / self.spacing_y) + </span><span class="s4">0.5</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">value_at(self</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">xi</span><span class="s0">, </span><span class="s1">yi):</span>
        <span class="s3">&quot;&quot;&quot; 
        Set up for RK4 function, based on Bokeh's streamline code 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(xi</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
            <span class="s1">self.x = xi.astype(np.int)</span>
            <span class="s1">self.y = yi.astype(np.int)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.val_x = np.int(xi)</span>
            <span class="s1">self.val_y = np.int(yi)</span>
        <span class="s1">a00 = a[self.val_y</span><span class="s0">, </span><span class="s1">self.val_x]</span>
        <span class="s1">a01 = a[self.val_y</span><span class="s0">, </span><span class="s1">self.val_x + </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">a10 = a[self.val_y + </span><span class="s4">1</span><span class="s0">, </span><span class="s1">self.val_x]</span>
        <span class="s1">a11 = a[self.val_y + </span><span class="s4">1</span><span class="s0">, </span><span class="s1">self.val_x + </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">xt = xi - self.val_x</span>
        <span class="s1">yt = yi - self.val_y</span>
        <span class="s1">a0 = a00 * (</span><span class="s4">1 </span><span class="s1">- xt) + a01 * xt</span>
        <span class="s1">a1 = a10 * (</span><span class="s4">1 </span><span class="s1">- xt) + a11 * xt</span>
        <span class="s0">return </span><span class="s1">a0 * (</span><span class="s4">1 </span><span class="s1">- yt) + a1 * yt</span>

    <span class="s0">def </span><span class="s1">rk4_integrate(self</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">y0):</span>
        <span class="s3">&quot;&quot;&quot; 
        RK4 forward and back trajectories from the initial conditions. 
 
        Adapted from Bokeh's streamline -uses Runge-Kutta method to fill 
        x and y trajectories then checks length of traj (s in units of axes) 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">f(xi</span><span class="s0">, </span><span class="s1">yi):</span>
            <span class="s1">dt_ds = </span><span class="s4">1.0 </span><span class="s1">/ self.value_at(self.speed</span><span class="s0">, </span><span class="s1">xi</span><span class="s0">, </span><span class="s1">yi)</span>
            <span class="s1">ui = self.value_at(self.u</span><span class="s0">, </span><span class="s1">xi</span><span class="s0">, </span><span class="s1">yi)</span>
            <span class="s1">vi = self.value_at(self.v</span><span class="s0">, </span><span class="s1">xi</span><span class="s0">, </span><span class="s1">yi)</span>
            <span class="s0">return </span><span class="s1">ui * dt_ds</span><span class="s0">, </span><span class="s1">vi * dt_ds</span>

        <span class="s0">def </span><span class="s1">g(xi</span><span class="s0">, </span><span class="s1">yi):</span>
            <span class="s1">dt_ds = </span><span class="s4">1.0 </span><span class="s1">/ self.value_at(self.speed</span><span class="s0">, </span><span class="s1">xi</span><span class="s0">, </span><span class="s1">yi)</span>
            <span class="s1">ui = self.value_at(self.u</span><span class="s0">, </span><span class="s1">xi</span><span class="s0">, </span><span class="s1">yi)</span>
            <span class="s1">vi = self.value_at(self.v</span><span class="s0">, </span><span class="s1">xi</span><span class="s0">, </span><span class="s1">yi)</span>
            <span class="s0">return </span><span class="s1">-ui * dt_ds</span><span class="s0">, </span><span class="s1">-vi * dt_ds</span>

        <span class="s1">check = </span><span class="s0">lambda </span><span class="s1">xi</span><span class="s0">, </span><span class="s1">yi: (</span><span class="s4">0 </span><span class="s1">&lt;= xi &lt; len(self.x) - </span><span class="s4">1 </span><span class="s0">and </span><span class="s4">0 </span><span class="s1">&lt;= yi &lt; len(self.y) - </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">xb_changes = []</span>
        <span class="s1">yb_changes = []</span>

        <span class="s0">def </span><span class="s1">rk4(x0</span><span class="s0">, </span><span class="s1">y0</span><span class="s0">, </span><span class="s1">f):</span>
            <span class="s1">ds = </span><span class="s4">0.01</span>
            <span class="s1">stotal = </span><span class="s4">0</span>
            <span class="s1">xi = x0</span>
            <span class="s1">yi = y0</span>
            <span class="s1">xb</span><span class="s0">, </span><span class="s1">yb = self.blank_pos(xi</span><span class="s0">, </span><span class="s1">yi)</span>
            <span class="s1">xf_traj = []</span>
            <span class="s1">yf_traj = []</span>
            <span class="s0">while </span><span class="s1">check(xi</span><span class="s0">, </span><span class="s1">yi):</span>
                <span class="s1">xf_traj.append(xi)</span>
                <span class="s1">yf_traj.append(yi)</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">k1x</span><span class="s0">, </span><span class="s1">k1y = f(xi</span><span class="s0">, </span><span class="s1">yi)</span>
                    <span class="s1">k2x</span><span class="s0">, </span><span class="s1">k2y = f(xi + </span><span class="s4">0.5 </span><span class="s1">* ds * k1x</span><span class="s0">, </span><span class="s1">yi + </span><span class="s4">0.5 </span><span class="s1">* ds * k1y)</span>
                    <span class="s1">k3x</span><span class="s0">, </span><span class="s1">k3y = f(xi + </span><span class="s4">0.5 </span><span class="s1">* ds * k2x</span><span class="s0">, </span><span class="s1">yi + </span><span class="s4">0.5 </span><span class="s1">* ds * k2y)</span>
                    <span class="s1">k4x</span><span class="s0">, </span><span class="s1">k4y = f(xi + ds * k3x</span><span class="s0">, </span><span class="s1">yi + ds * k3y)</span>
                <span class="s0">except </span><span class="s1">IndexError:</span>
                    <span class="s0">break</span>
                <span class="s1">xi += ds * (k1x + </span><span class="s4">2 </span><span class="s1">* k2x + </span><span class="s4">2 </span><span class="s1">* k3x + k4x) / </span><span class="s4">6.0</span>
                <span class="s1">yi += ds * (k1y + </span><span class="s4">2 </span><span class="s1">* k2y + </span><span class="s4">2 </span><span class="s1">* k3y + k4y) / </span><span class="s4">6.0</span>
                <span class="s0">if not </span><span class="s1">check(xi</span><span class="s0">, </span><span class="s1">yi):</span>
                    <span class="s0">break</span>
                <span class="s1">stotal += ds</span>
                <span class="s1">new_xb</span><span class="s0">, </span><span class="s1">new_yb = self.blank_pos(xi</span><span class="s0">, </span><span class="s1">yi)</span>
                <span class="s0">if </span><span class="s1">new_xb != xb </span><span class="s0">or </span><span class="s1">new_yb != yb:</span>
                    <span class="s0">if </span><span class="s1">self.blank[new_yb</span><span class="s0">, </span><span class="s1">new_xb] == </span><span class="s4">0</span><span class="s1">:</span>
                        <span class="s1">self.blank[new_yb</span><span class="s0">, </span><span class="s1">new_xb] = </span><span class="s4">1</span>
                        <span class="s1">xb_changes.append(new_xb)</span>
                        <span class="s1">yb_changes.append(new_yb)</span>
                        <span class="s1">xb = new_xb</span>
                        <span class="s1">yb = new_yb</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s0">break</span>
                <span class="s0">if </span><span class="s1">stotal &gt; </span><span class="s4">2</span><span class="s1">:</span>
                    <span class="s0">break</span>
            <span class="s0">return </span><span class="s1">stotal</span><span class="s0">, </span><span class="s1">xf_traj</span><span class="s0">, </span><span class="s1">yf_traj</span>

        <span class="s1">sf</span><span class="s0">, </span><span class="s1">xf_traj</span><span class="s0">, </span><span class="s1">yf_traj = rk4(x0</span><span class="s0">, </span><span class="s1">y0</span><span class="s0">, </span><span class="s1">f)</span>
        <span class="s1">sb</span><span class="s0">, </span><span class="s1">xb_traj</span><span class="s0">, </span><span class="s1">yb_traj = rk4(x0</span><span class="s0">, </span><span class="s1">y0</span><span class="s0">, </span><span class="s1">g)</span>
        <span class="s1">stotal = sf + sb</span>
        <span class="s1">x_traj = xb_traj[::-</span><span class="s4">1</span><span class="s1">] + xf_traj[</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s1">y_traj = yb_traj[::-</span><span class="s4">1</span><span class="s1">] + yf_traj[</span><span class="s4">1</span><span class="s1">:]</span>

        <span class="s0">if </span><span class="s1">len(x_traj) &lt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">return None</span>
        <span class="s0">if </span><span class="s1">stotal &gt; </span><span class="s4">0.2</span><span class="s1">:</span>
            <span class="s1">initxb</span><span class="s0">, </span><span class="s1">inityb = self.blank_pos(x0</span><span class="s0">, </span><span class="s1">y0)</span>
            <span class="s1">self.blank[inityb</span><span class="s0">, </span><span class="s1">initxb] = </span><span class="s4">1</span>
            <span class="s0">return </span><span class="s1">x_traj</span><span class="s0">, </span><span class="s1">y_traj</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">xb</span><span class="s0">, </span><span class="s1">yb </span><span class="s0">in </span><span class="s1">zip(xb_changes</span><span class="s0">, </span><span class="s1">yb_changes):</span>
                <span class="s1">self.blank[yb</span><span class="s0">, </span><span class="s1">xb] = </span><span class="s4">0</span>
            <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">traj(self</span><span class="s0">, </span><span class="s1">xb</span><span class="s0">, </span><span class="s1">yb):</span>
        <span class="s3">&quot;&quot;&quot; 
        Integrate trajectories 
 
        :param (int) xb: results of passing xi through self.blank_pos 
        :param (int) xy: results of passing yi through self.blank_pos 
 
        Calculate each trajectory based on rk4 integrate method. 
        &quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">xb &lt; </span><span class="s4">0 </span><span class="s0">or </span><span class="s1">xb &gt;= self.density </span><span class="s0">or </span><span class="s1">yb &lt; </span><span class="s4">0 </span><span class="s0">or </span><span class="s1">yb &gt;= self.density:</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s1">self.blank[yb</span><span class="s0">, </span><span class="s1">xb] == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">t = self.rk4_integrate(xb * self.spacing_x</span><span class="s0">, </span><span class="s1">yb * self.spacing_y)</span>
            <span class="s0">if </span><span class="s1">t </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">self.trajectories.append(t)</span>

    <span class="s0">def </span><span class="s1">get_streamlines(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Get streamlines by building trajectory set. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">indent </span><span class="s0">in </span><span class="s1">range(self.density // </span><span class="s4">2</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">xi </span><span class="s0">in </span><span class="s1">range(self.density - </span><span class="s4">2 </span><span class="s1">* indent):</span>
                <span class="s1">self.traj(xi + indent</span><span class="s0">, </span><span class="s1">indent)</span>
                <span class="s1">self.traj(xi + indent</span><span class="s0">, </span><span class="s1">self.density - </span><span class="s4">1 </span><span class="s1">- indent)</span>
                <span class="s1">self.traj(indent</span><span class="s0">, </span><span class="s1">xi + indent)</span>
                <span class="s1">self.traj(self.density - </span><span class="s4">1 </span><span class="s1">- indent</span><span class="s0">, </span><span class="s1">xi + indent)</span>

        <span class="s1">self.st_x = [</span>
            <span class="s1">np.array(t[</span><span class="s4">0</span><span class="s1">]) * self.delta_x + self.x[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.trajectories</span>
        <span class="s1">]</span>
        <span class="s1">self.st_y = [</span>
            <span class="s1">np.array(t[</span><span class="s4">1</span><span class="s1">]) * self.delta_y + self.y[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.trajectories</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(len(self.st_x)):</span>
            <span class="s1">self.st_x[index] = self.st_x[index].tolist()</span>
            <span class="s1">self.st_x[index].append(np.nan)</span>

        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(len(self.st_y)):</span>
            <span class="s1">self.st_y[index] = self.st_y[index].tolist()</span>
            <span class="s1">self.st_y[index].append(np.nan)</span>

    <span class="s0">def </span><span class="s1">get_streamline_arrows(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Makes an arrow for each streamline. 
 
        Gets angle of streamline at 1/3 mark and creates arrow coordinates 
        based off of user defined angle and arrow_scale. 
 
        :param (array) st_x: x-values for all streamlines 
        :param (array) st_y: y-values for all streamlines 
        :param (angle in radians) angle: angle of arrowhead. Default = pi/9 
        :param (float in [0,1]) arrow_scale: value to scale length of arrowhead 
            Default = .09 
        :rtype (list, list) arrows_x: x-values to create arrowhead and 
            arrows_y: y-values to create arrowhead 
        &quot;&quot;&quot;</span>
        <span class="s1">arrow_end_x = np.empty((len(self.st_x)))</span>
        <span class="s1">arrow_end_y = np.empty((len(self.st_y)))</span>
        <span class="s1">arrow_start_x = np.empty((len(self.st_x)))</span>
        <span class="s1">arrow_start_y = np.empty((len(self.st_y)))</span>
        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(len(self.st_x)):</span>
            <span class="s1">arrow_end_x[index] = self.st_x[index][int(len(self.st_x[index]) / </span><span class="s4">3</span><span class="s1">)]</span>
            <span class="s1">arrow_start_x[index] = self.st_x[index][</span>
                <span class="s1">(int(len(self.st_x[index]) / </span><span class="s4">3</span><span class="s1">)) - </span><span class="s4">1</span>
            <span class="s1">]</span>
            <span class="s1">arrow_end_y[index] = self.st_y[index][int(len(self.st_y[index]) / </span><span class="s4">3</span><span class="s1">)]</span>
            <span class="s1">arrow_start_y[index] = self.st_y[index][</span>
                <span class="s1">(int(len(self.st_y[index]) / </span><span class="s4">3</span><span class="s1">)) - </span><span class="s4">1</span>
            <span class="s1">]</span>

        <span class="s1">dif_x = arrow_end_x - arrow_start_x</span>
        <span class="s1">dif_y = arrow_end_y - arrow_start_y</span>

        <span class="s1">orig_err = np.geterr()</span>
        <span class="s1">np.seterr(divide=</span><span class="s2">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">invalid=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">streamline_ang = np.arctan(dif_y / dif_x)</span>
        <span class="s1">np.seterr(**orig_err)</span>

        <span class="s1">ang1 = streamline_ang + (self.angle)</span>
        <span class="s1">ang2 = streamline_ang - (self.angle)</span>

        <span class="s1">seg1_x = np.cos(ang1) * self.arrow_scale</span>
        <span class="s1">seg1_y = np.sin(ang1) * self.arrow_scale</span>
        <span class="s1">seg2_x = np.cos(ang2) * self.arrow_scale</span>
        <span class="s1">seg2_y = np.sin(ang2) * self.arrow_scale</span>

        <span class="s1">point1_x = np.empty((len(dif_x)))</span>
        <span class="s1">point1_y = np.empty((len(dif_y)))</span>
        <span class="s1">point2_x = np.empty((len(dif_x)))</span>
        <span class="s1">point2_y = np.empty((len(dif_y)))</span>

        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(len(dif_x)):</span>
            <span class="s0">if </span><span class="s1">dif_x[index] &gt;= </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">point1_x[index] = arrow_end_x[index] - seg1_x[index]</span>
                <span class="s1">point1_y[index] = arrow_end_y[index] - seg1_y[index]</span>
                <span class="s1">point2_x[index] = arrow_end_x[index] - seg2_x[index]</span>
                <span class="s1">point2_y[index] = arrow_end_y[index] - seg2_y[index]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">point1_x[index] = arrow_end_x[index] + seg1_x[index]</span>
                <span class="s1">point1_y[index] = arrow_end_y[index] + seg1_y[index]</span>
                <span class="s1">point2_x[index] = arrow_end_x[index] + seg2_x[index]</span>
                <span class="s1">point2_y[index] = arrow_end_y[index] + seg2_y[index]</span>

        <span class="s1">space = np.empty((len(point1_x)))</span>
        <span class="s1">space[:] = np.nan</span>

        <span class="s5"># Combine arrays into matrix</span>
        <span class="s1">arrows_x = np.matrix([point1_x</span><span class="s0">, </span><span class="s1">arrow_end_x</span><span class="s0">, </span><span class="s1">point2_x</span><span class="s0">, </span><span class="s1">space])</span>
        <span class="s1">arrows_x = np.array(arrows_x)</span>
        <span class="s1">arrows_x = arrows_x.flatten(</span><span class="s2">&quot;F&quot;</span><span class="s1">)</span>
        <span class="s1">arrows_x = arrows_x.tolist()</span>

        <span class="s5"># Combine arrays into matrix</span>
        <span class="s1">arrows_y = np.matrix([point1_y</span><span class="s0">, </span><span class="s1">arrow_end_y</span><span class="s0">, </span><span class="s1">point2_y</span><span class="s0">, </span><span class="s1">space])</span>
        <span class="s1">arrows_y = np.array(arrows_y)</span>
        <span class="s1">arrows_y = arrows_y.flatten(</span><span class="s2">&quot;F&quot;</span><span class="s1">)</span>
        <span class="s1">arrows_y = arrows_y.tolist()</span>

        <span class="s0">return </span><span class="s1">arrows_x</span><span class="s0">, </span><span class="s1">arrows_y</span>

    <span class="s0">def </span><span class="s1">sum_streamlines(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Makes all streamlines readable as a single trace. 
 
        :rtype (list, list): streamline_x: all x values for each streamline 
            combined into single list and streamline_y: all y values for each 
            streamline combined into single list 
        &quot;&quot;&quot;</span>
        <span class="s1">streamline_x = sum(self.st_x</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">streamline_y = sum(self.st_y</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s0">return </span><span class="s1">streamline_x</span><span class="s0">, </span><span class="s1">streamline_y</span>
</pre>
</body>
</html>