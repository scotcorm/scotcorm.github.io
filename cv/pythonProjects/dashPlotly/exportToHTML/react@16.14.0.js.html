<html>
<head>
<title>react@16.14.0.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
react@16.14.0.js</font>
</center></td></tr></table>
<pre><span class="s0">/** @license React v16.14.0 
 * react.development.js 
 * 
 * Copyright (c) Facebook, Inc. and its affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s1">(</span><span class="s3">function </span><span class="s1">(global, factory) {</span>
  <span class="s3">typeof </span><span class="s1">exports === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">module !== </span><span class="s2">'undefined' </span><span class="s1">? factory(exports) :</span>
  <span class="s3">typeof </span><span class="s1">define === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; define.amd ? define([</span><span class="s2">'exports'</span><span class="s1">], factory) :</span>
  <span class="s1">(global = global || self, factory(global.React = {}));</span>
<span class="s1">}(</span><span class="s3">this</span><span class="s1">, (</span><span class="s3">function </span><span class="s1">(exports) { </span><span class="s2">'use strict'</span><span class="s1">;</span>

  <span class="s3">var </span><span class="s1">ReactVersion = </span><span class="s2">'16.14.0'</span><span class="s1">;</span>

  <span class="s0">// The Symbol used to tag the ReactElement-like types. If there is no native Symbol</span>
  <span class="s0">// nor polyfill, then a plain number is used for performance.</span>
  <span class="s3">var </span><span class="s1">hasSymbol = </span><span class="s3">typeof </span><span class="s1">Symbol === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; Symbol.</span><span class="s3">for</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">REACT_ELEMENT_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.element'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xeac7;</span>
  <span class="s3">var </span><span class="s1">REACT_PORTAL_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.portal'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xeaca;</span>
  <span class="s3">var </span><span class="s1">REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.fragment'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xeacb;</span>
  <span class="s3">var </span><span class="s1">REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.strict_mode'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xeacc;</span>
  <span class="s3">var </span><span class="s1">REACT_PROFILER_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.profiler'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead2;</span>
  <span class="s3">var </span><span class="s1">REACT_PROVIDER_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.provider'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xeacd;</span>
  <span class="s3">var </span><span class="s1">REACT_CONTEXT_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.context'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xeace; </span><span class="s0">// TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary</span>
  <span class="s3">var </span><span class="s1">REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.concurrent_mode'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xeacf;</span>
  <span class="s3">var </span><span class="s1">REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.forward_ref'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead0;</span>
  <span class="s3">var </span><span class="s1">REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.suspense'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead1;</span>
  <span class="s3">var </span><span class="s1">REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.suspense_list'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead8;</span>
  <span class="s3">var </span><span class="s1">REACT_MEMO_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.memo'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead3;</span>
  <span class="s3">var </span><span class="s1">REACT_LAZY_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.lazy'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead4;</span>
  <span class="s3">var </span><span class="s1">REACT_BLOCK_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.block'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead9;</span>
  <span class="s3">var </span><span class="s1">REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.fundamental'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead5;</span>
  <span class="s3">var </span><span class="s1">REACT_RESPONDER_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.responder'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead6;</span>
  <span class="s3">var </span><span class="s1">REACT_SCOPE_TYPE = hasSymbol ? Symbol.</span><span class="s3">for</span><span class="s1">(</span><span class="s2">'react.scope'</span><span class="s1">) : </span><span class="s4">0</span><span class="s1">xead7;</span>
  <span class="s3">var </span><span class="s1">MAYBE_ITERATOR_SYMBOL = </span><span class="s3">typeof </span><span class="s1">Symbol === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; Symbol.iterator;</span>
  <span class="s3">var </span><span class="s1">FAUX_ITERATOR_SYMBOL = </span><span class="s2">'@@iterator'</span><span class="s1">;</span>
  <span class="s3">function </span><span class="s1">getIteratorFn(maybeIterable) {</span>
    <span class="s3">if </span><span class="s1">(maybeIterable === </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">maybeIterable !== </span><span class="s2">'object'</span><span class="s1">) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">maybeIterator = MAYBE_ITERATOR_SYMBOL &amp;&amp; maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">maybeIterator === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">maybeIterator;</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/* 
  object-assign 
  (c) Sindre Sorhus 
  @license MIT 
  */</span>
  <span class="s0">/* eslint-disable no-unused-vars */</span>
  <span class="s3">var </span><span class="s1">getOwnPropertySymbols = Object.getOwnPropertySymbols;</span>
  <span class="s3">var </span><span class="s1">hasOwnProperty = Object.prototype.hasOwnProperty;</span>
  <span class="s3">var </span><span class="s1">propIsEnumerable = Object.prototype.propertyIsEnumerable;</span>

  <span class="s3">function </span><span class="s1">toObject(val) {</span>
  	<span class="s3">if </span><span class="s1">(val === </span><span class="s3">null </span><span class="s1">|| val === undefined) {</span>
  		<span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s2">'Object.assign cannot be called with null or undefined'</span><span class="s1">);</span>
  	<span class="s1">}</span>

  	<span class="s3">return </span><span class="s1">Object(val);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">shouldUseNative() {</span>
  	<span class="s3">try </span><span class="s1">{</span>
  		<span class="s3">if </span><span class="s1">(!Object.assign) {</span>
  			<span class="s3">return false</span><span class="s1">;</span>
  		<span class="s1">}</span>

  		<span class="s0">// Detect buggy property enumeration order in older V8 versions.</span>

  		<span class="s0">// https://bugs.chromium.org/p/v8/issues/detail?id=4118</span>
  		<span class="s3">var </span><span class="s1">test1 = </span><span class="s3">new </span><span class="s1">String(</span><span class="s2">'abc'</span><span class="s1">);  </span><span class="s0">// eslint-disable-line no-new-wrappers</span>
  		<span class="s1">test1[</span><span class="s4">5</span><span class="s1">] = </span><span class="s2">'de'</span><span class="s1">;</span>
  		<span class="s3">if </span><span class="s1">(Object.getOwnPropertyNames(test1)[</span><span class="s4">0</span><span class="s1">] === </span><span class="s2">'5'</span><span class="s1">) {</span>
  			<span class="s3">return false</span><span class="s1">;</span>
  		<span class="s1">}</span>

  		<span class="s0">// https://bugs.chromium.org/p/v8/issues/detail?id=3056</span>
  		<span class="s3">var </span><span class="s1">test2 = {};</span>
  		<span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; </span><span class="s4">10</span><span class="s1">; i++) {</span>
  			<span class="s1">test2[</span><span class="s2">'_' </span><span class="s1">+ String.fromCharCode(i)] = i;</span>
  		<span class="s1">}</span>
  		<span class="s3">var </span><span class="s1">order2 = Object.getOwnPropertyNames(test2).map(</span><span class="s3">function </span><span class="s1">(n) {</span>
  			<span class="s3">return </span><span class="s1">test2[n];</span>
  		<span class="s1">});</span>
  		<span class="s3">if </span><span class="s1">(order2.join(</span><span class="s2">''</span><span class="s1">) !== </span><span class="s2">'0123456789'</span><span class="s1">) {</span>
  			<span class="s3">return false</span><span class="s1">;</span>
  		<span class="s1">}</span>

  		<span class="s0">// https://bugs.chromium.org/p/v8/issues/detail?id=3056</span>
  		<span class="s3">var </span><span class="s1">test3 = {};</span>
  		<span class="s2">'abcdefghijklmnopqrst'</span><span class="s1">.split(</span><span class="s2">''</span><span class="s1">).forEach(</span><span class="s3">function </span><span class="s1">(letter) {</span>
  			<span class="s1">test3[letter] = letter;</span>
  		<span class="s1">});</span>
  		<span class="s3">if </span><span class="s1">(Object.keys(Object.assign({}, test3)).join(</span><span class="s2">''</span><span class="s1">) !==</span>
  				<span class="s2">'abcdefghijklmnopqrst'</span><span class="s1">) {</span>
  			<span class="s3">return false</span><span class="s1">;</span>
  		<span class="s1">}</span>

  		<span class="s3">return true</span><span class="s1">;</span>
  	<span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
  		<span class="s0">// We don't expect any of the above to throw, but better to be safe.</span>
  		<span class="s3">return false</span><span class="s1">;</span>
  	<span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">objectAssign = shouldUseNative() ? Object.assign : </span><span class="s3">function </span><span class="s1">(target, source) {</span>
  	<span class="s3">var </span><span class="s1">from;</span>
  	<span class="s3">var </span><span class="s1">to = toObject(target);</span>
  	<span class="s3">var </span><span class="s1">symbols;</span>

  	<span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">s = </span><span class="s4">1</span><span class="s1">; s &lt; arguments.length; s++) {</span>
  		<span class="s1">from = Object(arguments[s]);</span>

  		<span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">from) {</span>
  			<span class="s3">if </span><span class="s1">(hasOwnProperty.call(from, key)) {</span>
  				<span class="s1">to[key] = from[key];</span>
  			<span class="s1">}</span>
  		<span class="s1">}</span>

  		<span class="s3">if </span><span class="s1">(getOwnPropertySymbols) {</span>
  			<span class="s1">symbols = getOwnPropertySymbols(from);</span>
  			<span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; symbols.length; i++) {</span>
  				<span class="s3">if </span><span class="s1">(propIsEnumerable.call(from, symbols[i])) {</span>
  					<span class="s1">to[symbols[i]] = from[symbols[i]];</span>
  				<span class="s1">}</span>
  			<span class="s1">}</span>
  		<span class="s1">}</span>
  	<span class="s1">}</span>

  	<span class="s3">return </span><span class="s1">to;</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Keeps track of the current dispatcher. 
   */</span>
  <span class="s3">var </span><span class="s1">ReactCurrentDispatcher = {</span>
    <span class="s0">/** 
     * @internal 
     * @type {ReactComponent} 
     */</span>
    <span class="s1">current: </span><span class="s3">null</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Keeps track of the current batch's configuration such as how long an update 
   * should suspend for if it needs to. 
   */</span>
  <span class="s3">var </span><span class="s1">ReactCurrentBatchConfig = {</span>
    <span class="s1">suspense: </span><span class="s3">null</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Keeps track of the current owner. 
   * 
   * The current owner is the component who should own any components that are 
   * currently being constructed. 
   */</span>
  <span class="s3">var </span><span class="s1">ReactCurrentOwner = {</span>
    <span class="s0">/** 
     * @internal 
     * @type {ReactComponent} 
     */</span>
    <span class="s1">current: </span><span class="s3">null</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">BEFORE_SLASH_RE = /^(.*)[\\\/]/;</span>
  <span class="s3">function </span><span class="s1">describeComponentFrame (name, source, ownerName) {</span>
    <span class="s3">var </span><span class="s1">sourceInfo = </span><span class="s2">''</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(source) {</span>
      <span class="s3">var </span><span class="s1">path = source.fileName;</span>
      <span class="s3">var </span><span class="s1">fileName = path.replace(BEFORE_SLASH_RE, </span><span class="s2">''</span><span class="s1">);</span>

      <span class="s1">{</span>
        <span class="s0">// In DEV, include code for a common special case:</span>
        <span class="s0">// prefer &quot;folder/index.js&quot; instead of just &quot;index.js&quot;.</span>
        <span class="s3">if </span><span class="s1">(/^index\./.test(fileName)) {</span>
          <span class="s3">var </span><span class="s1">match = path.match(BEFORE_SLASH_RE);</span>

          <span class="s3">if </span><span class="s1">(match) {</span>
            <span class="s3">var </span><span class="s1">pathBeforeSlash = match[</span><span class="s4">1</span><span class="s1">];</span>

            <span class="s3">if </span><span class="s1">(pathBeforeSlash) {</span>
              <span class="s3">var </span><span class="s1">folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, </span><span class="s2">''</span><span class="s1">);</span>
              <span class="s1">fileName = folderName + </span><span class="s2">'/' </span><span class="s1">+ fileName;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">sourceInfo = </span><span class="s2">' (at ' </span><span class="s1">+ fileName + </span><span class="s2">':' </span><span class="s1">+ source.lineNumber + </span><span class="s2">')'</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(ownerName) {</span>
      <span class="s1">sourceInfo = </span><span class="s2">' (created by ' </span><span class="s1">+ ownerName + </span><span class="s2">')'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s2">'</span><span class="s5">\n    </span><span class="s2">in ' </span><span class="s1">+ (name || </span><span class="s2">'Unknown'</span><span class="s1">) + sourceInfo;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">Resolved = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">function </span><span class="s1">refineResolvedLazyComponent(lazyComponent) {</span>
    <span class="s3">return </span><span class="s1">lazyComponent._status === Resolved ? lazyComponent._result : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getWrappedName(outerType, innerType, wrapperName) {</span>
    <span class="s3">var </span><span class="s1">functionName = innerType.displayName || innerType.name || </span><span class="s2">''</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">outerType.displayName || (functionName !== </span><span class="s2">'' </span><span class="s1">? wrapperName + </span><span class="s2">&quot;(&quot; </span><span class="s1">+ functionName + </span><span class="s2">&quot;)&quot; </span><span class="s1">: wrapperName);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getComponentName(type) {</span>
    <span class="s3">if </span><span class="s1">(type == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Host root, text node or just invalid type.</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type.tag === </span><span class="s2">'number'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'Received an unexpected object in getComponentName(). ' </span><span class="s1">+ </span><span class="s2">'This is likely a bug in React. Please file an issue.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">type.displayName || type.name || </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'string'</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">type;</span>
    <span class="s1">}</span>

    <span class="s3">switch </span><span class="s1">(type) {</span>
      <span class="s3">case </span><span class="s1">REACT_FRAGMENT_TYPE:</span>
        <span class="s3">return </span><span class="s2">'Fragment'</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
        <span class="s3">return </span><span class="s2">'Portal'</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">REACT_PROFILER_TYPE:</span>
        <span class="s3">return </span><span class="s2">&quot;Profiler&quot;</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">REACT_STRICT_MODE_TYPE:</span>
        <span class="s3">return </span><span class="s2">'StrictMode'</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">REACT_SUSPENSE_TYPE:</span>
        <span class="s3">return </span><span class="s2">'Suspense'</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s1">REACT_SUSPENSE_LIST_TYPE:</span>
        <span class="s3">return </span><span class="s2">'SuspenseList'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'object'</span><span class="s1">) {</span>
      <span class="s3">switch </span><span class="s1">(type.$$typeof) {</span>
        <span class="s3">case </span><span class="s1">REACT_CONTEXT_TYPE:</span>
          <span class="s3">return </span><span class="s2">'Context.Consumer'</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">REACT_PROVIDER_TYPE:</span>
          <span class="s3">return </span><span class="s2">'Context.Provider'</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s1">REACT_FORWARD_REF_TYPE:</span>
          <span class="s3">return </span><span class="s1">getWrappedName(type, type.render, </span><span class="s2">'ForwardRef'</span><span class="s1">);</span>

        <span class="s3">case </span><span class="s1">REACT_MEMO_TYPE:</span>
          <span class="s3">return </span><span class="s1">getComponentName(type.type);</span>

        <span class="s3">case </span><span class="s1">REACT_BLOCK_TYPE:</span>
          <span class="s3">return </span><span class="s1">getComponentName(type.render);</span>

        <span class="s3">case </span><span class="s1">REACT_LAZY_TYPE:</span>
          <span class="s1">{</span>
            <span class="s3">var </span><span class="s1">thenable = type;</span>
            <span class="s3">var </span><span class="s1">resolvedThenable = refineResolvedLazyComponent(thenable);</span>

            <span class="s3">if </span><span class="s1">(resolvedThenable) {</span>
              <span class="s3">return </span><span class="s1">getComponentName(resolvedThenable);</span>
            <span class="s1">}</span>

            <span class="s3">break</span><span class="s1">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">ReactDebugCurrentFrame = {};</span>
  <span class="s3">var </span><span class="s1">currentlyValidatingElement = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">function </span><span class="s1">setCurrentlyValidatingElement(element) {</span>
    <span class="s1">{</span>
      <span class="s1">currentlyValidatingElement = element;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">{</span>
    <span class="s0">// Stack implementation injected by the current renderer.</span>
    <span class="s1">ReactDebugCurrentFrame.getCurrentStack = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s1">ReactDebugCurrentFrame.getStackAddendum = </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">var </span><span class="s1">stack = </span><span class="s2">''</span><span class="s1">; </span><span class="s0">// Add an extra top frame while an element is being validated</span>

      <span class="s3">if </span><span class="s1">(currentlyValidatingElement) {</span>
        <span class="s3">var </span><span class="s1">name = getComponentName(currentlyValidatingElement.type);</span>
        <span class="s3">var </span><span class="s1">owner = currentlyValidatingElement._owner;</span>
        <span class="s1">stack += describeComponentFrame(name, currentlyValidatingElement._source, owner &amp;&amp; getComponentName(owner.type));</span>
      <span class="s1">} </span><span class="s0">// Delegate to the injected renderer-specific implementation</span>


      <span class="s3">var </span><span class="s1">impl = ReactDebugCurrentFrame.getCurrentStack;</span>

      <span class="s3">if </span><span class="s1">(impl) {</span>
        <span class="s1">stack += impl() || </span><span class="s2">''</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">stack;</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Used by act() to track whether you're inside an act() scope. 
   */</span>
  <span class="s3">var </span><span class="s1">IsSomeRendererActing = {</span>
    <span class="s1">current: </span><span class="s3">false</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">ReactSharedInternals = {</span>
    <span class="s1">ReactCurrentDispatcher: ReactCurrentDispatcher,</span>
    <span class="s1">ReactCurrentBatchConfig: ReactCurrentBatchConfig,</span>
    <span class="s1">ReactCurrentOwner: ReactCurrentOwner,</span>
    <span class="s1">IsSomeRendererActing: IsSomeRendererActing,</span>
    <span class="s0">// Used by renderers to avoid bundling object-assign twice in UMD bundles:</span>
    <span class="s1">assign: objectAssign</span>
  <span class="s1">};</span>

  <span class="s1">{</span>
    <span class="s1">objectAssign(ReactSharedInternals, {</span>
      <span class="s0">// These should not be included in production.</span>
      <span class="s1">ReactDebugCurrentFrame: ReactDebugCurrentFrame,</span>
      <span class="s0">// Shim for React DOM 16.0.0 which still destructured (but not used) this.</span>
      <span class="s0">// TODO: remove in React 17.0.</span>
      <span class="s1">ReactComponentTreeHook: {}</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s0">// by calls to these methods by a Babel plugin.</span>
  <span class="s0">//</span>
  <span class="s0">// In PROD (or in packages without access to React internals),</span>
  <span class="s0">// they are left as they are instead.</span>

  <span class="s3">function </span><span class="s1">warn(format) {</span>
    <span class="s1">{</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">_len = arguments.length, args = </span><span class="s3">new </span><span class="s1">Array(_len &gt; </span><span class="s4">1 </span><span class="s1">? _len - </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">), _key = </span><span class="s4">1</span><span class="s1">; _key &lt; _len; _key++) {</span>
        <span class="s1">args[_key - </span><span class="s4">1</span><span class="s1">] = arguments[_key];</span>
      <span class="s1">}</span>

      <span class="s1">printWarning(</span><span class="s2">'warn'</span><span class="s1">, format, args);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">error(format) {</span>
    <span class="s1">{</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">_len2 = arguments.length, args = </span><span class="s3">new </span><span class="s1">Array(_len2 &gt; </span><span class="s4">1 </span><span class="s1">? _len2 - </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">), _key2 = </span><span class="s4">1</span><span class="s1">; _key2 &lt; _len2; _key2++) {</span>
        <span class="s1">args[_key2 - </span><span class="s4">1</span><span class="s1">] = arguments[_key2];</span>
      <span class="s1">}</span>

      <span class="s1">printWarning(</span><span class="s2">'error'</span><span class="s1">, format, args);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">printWarning(level, format, args) {</span>
    <span class="s0">// When changing this logic, you might want to also</span>
    <span class="s0">// update consoleWithStackDev.www.js as well.</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">hasExistingStack = args.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">args[args.length - </span><span class="s4">1</span><span class="s1">] === </span><span class="s2">'string' </span><span class="s1">&amp;&amp; args[args.length - </span><span class="s4">1</span><span class="s1">].indexOf(</span><span class="s2">'</span><span class="s5">\n    </span><span class="s2">in'</span><span class="s1">) === </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(!hasExistingStack) {</span>
        <span class="s3">var </span><span class="s1">ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;</span>
        <span class="s3">var </span><span class="s1">stack = ReactDebugCurrentFrame.getStackAddendum();</span>

        <span class="s3">if </span><span class="s1">(stack !== </span><span class="s2">''</span><span class="s1">) {</span>
          <span class="s1">format += </span><span class="s2">'%s'</span><span class="s1">;</span>
          <span class="s1">args = args.concat([stack]);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">argsWithFormat = args.map(</span><span class="s3">function </span><span class="s1">(item) {</span>
        <span class="s3">return </span><span class="s2">'' </span><span class="s1">+ item;</span>
      <span class="s1">}); </span><span class="s0">// Careful: RN currently depends on this prefix</span>

      <span class="s1">argsWithFormat.unshift(</span><span class="s2">'Warning: ' </span><span class="s1">+ format); </span><span class="s0">// We intentionally don't use spread (or .apply) directly because it</span>
      <span class="s0">// breaks IE9: https://github.com/facebook/react/issues/13610</span>
      <span class="s0">// eslint-disable-next-line react-internal/no-production-logging</span>

      <span class="s1">Function.prototype.apply.call(console[level], console, argsWithFormat);</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s0">// --- Welcome to debugging React ---</span>
        <span class="s0">// This error was thrown as a convenience so that you can use this stack</span>
        <span class="s0">// to find the callsite that caused this warning to fire.</span>
        <span class="s3">var </span><span class="s1">argIndex = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">message = </span><span class="s2">'Warning: ' </span><span class="s1">+ format.replace(/%s/g, </span><span class="s3">function </span><span class="s1">() {</span>
          <span class="s3">return </span><span class="s1">args[argIndex++];</span>
        <span class="s1">});</span>
        <span class="s3">throw new </span><span class="s1">Error(message);</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(x) {}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">didWarnStateUpdateForUnmountedComponent = {};</span>

  <span class="s3">function </span><span class="s1">warnNoop(publicInstance, callerName) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">_constructor = publicInstance.constructor;</span>
      <span class="s3">var </span><span class="s1">componentName = _constructor &amp;&amp; (_constructor.displayName || _constructor.name) || </span><span class="s2">'ReactClass'</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">warningKey = componentName + </span><span class="s2">&quot;.&quot; </span><span class="s1">+ callerName;</span>

      <span class="s3">if </span><span class="s1">(didWarnStateUpdateForUnmountedComponent[warningKey]) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">error(</span><span class="s2">&quot;Can't call %s on a component that is not yet mounted. &quot; </span><span class="s1">+ </span><span class="s2">'This is a no-op, but it might indicate a bug in your application. ' </span><span class="s1">+ </span><span class="s2">'Instead, assign to `this.state` directly or define a `state = {};` ' </span><span class="s1">+ </span><span class="s2">'class property with the desired state in the %s component.'</span><span class="s1">, callerName, componentName);</span>

      <span class="s1">didWarnStateUpdateForUnmountedComponent[warningKey] = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * This is the abstract API for an update queue. 
   */</span>


  <span class="s3">var </span><span class="s1">ReactNoopUpdateQueue = {</span>
    <span class="s0">/** 
     * Checks whether or not this composite component is mounted. 
     * @param {ReactClass} publicInstance The instance we want to test. 
     * @return {boolean} True if mounted, false otherwise. 
     * @protected 
     * @final 
     */</span>
    <span class="s1">isMounted: </span><span class="s3">function </span><span class="s1">(publicInstance) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * Forces an update. This should only be invoked when it is known with 
     * certainty that we are **not** in a DOM transaction. 
     * 
     * You may want to call this when you know that some deeper aspect of the 
     * component's state has changed but `setState` was not called. 
     * 
     * This will not invoke `shouldComponentUpdate`, but it will invoke 
     * `componentWillUpdate` and `componentDidUpdate`. 
     * 
     * @param {ReactClass} publicInstance The instance that should rerender. 
     * @param {?function} callback Called after component is updated. 
     * @param {?string} callerName name of the calling function in the public API. 
     * @internal 
     */</span>
    <span class="s1">enqueueForceUpdate: </span><span class="s3">function </span><span class="s1">(publicInstance, callback, callerName) {</span>
      <span class="s1">warnNoop(publicInstance, </span><span class="s2">'forceUpdate'</span><span class="s1">);</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * Replaces all of the state. Always use this or `setState` to mutate state. 
     * You should treat `this.state` as immutable. 
     * 
     * There is no guarantee that `this.state` will be immediately updated, so 
     * accessing `this.state` after calling this method may return the old value. 
     * 
     * @param {ReactClass} publicInstance The instance that should rerender. 
     * @param {object} completeState Next state. 
     * @param {?function} callback Called after component is updated. 
     * @param {?string} callerName name of the calling function in the public API. 
     * @internal 
     */</span>
    <span class="s1">enqueueReplaceState: </span><span class="s3">function </span><span class="s1">(publicInstance, completeState, callback, callerName) {</span>
      <span class="s1">warnNoop(publicInstance, </span><span class="s2">'replaceState'</span><span class="s1">);</span>
    <span class="s1">},</span>

    <span class="s0">/** 
     * Sets a subset of the state. This only exists because _pendingState is 
     * internal. This provides a merging strategy that is not available to deep 
     * properties which is confusing. TODO: Expose pendingState or don't use it 
     * during the merge. 
     * 
     * @param {ReactClass} publicInstance The instance that should rerender. 
     * @param {object} partialState Next partial state to be merged with state. 
     * @param {?function} callback Called after component is updated. 
     * @param {?string} Name of the calling function in the public API. 
     * @internal 
     */</span>
    <span class="s1">enqueueSetState: </span><span class="s3">function </span><span class="s1">(publicInstance, partialState, callback, callerName) {</span>
      <span class="s1">warnNoop(publicInstance, </span><span class="s2">'setState'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">emptyObject = {};</span>

  <span class="s1">{</span>
    <span class="s1">Object.freeze(emptyObject);</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Base class helpers for the updating state of a component. 
   */</span>


  <span class="s3">function </span><span class="s1">Component(props, context, updater) {</span>
    <span class="s3">this</span><span class="s1">.props = props;</span>
    <span class="s3">this</span><span class="s1">.context = context; </span><span class="s0">// If a component has string refs, we will assign a different object later.</span>

    <span class="s3">this</span><span class="s1">.refs = emptyObject; </span><span class="s0">// We initialize the default updater but the real one gets injected by the</span>
    <span class="s0">// renderer.</span>

    <span class="s3">this</span><span class="s1">.updater = updater || ReactNoopUpdateQueue;</span>
  <span class="s1">}</span>

  <span class="s1">Component.prototype.isReactComponent = {};</span>
  <span class="s0">/** 
   * Sets a subset of the state. Always use this to mutate 
   * state. You should treat `this.state` as immutable. 
   * 
   * There is no guarantee that `this.state` will be immediately updated, so 
   * accessing `this.state` after calling this method may return the old value. 
   * 
   * There is no guarantee that calls to `setState` will run synchronously, 
   * as they may eventually be batched together.  You can provide an optional 
   * callback that will be executed when the call to setState is actually 
   * completed. 
   * 
   * When a function is provided to setState, it will be called at some point in 
   * the future (not synchronously). It will be called with the up to date 
   * component arguments (state, props, context). These values can be different 
   * from this.* because your function may be called after receiveProps but before 
   * shouldComponentUpdate, and this new state, props, and context will not yet be 
   * assigned to this. 
   * 
   * @param {object|function} partialState Next partial state or function to 
   *        produce next partial state to be merged with current state. 
   * @param {?function} callback Called after state is updated. 
   * @final 
   * @protected 
   */</span>

  <span class="s1">Component.prototype.setState = </span><span class="s3">function </span><span class="s1">(partialState, callback) {</span>
    <span class="s3">if </span><span class="s1">(!(</span><span class="s3">typeof </span><span class="s1">partialState === </span><span class="s2">'object' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">partialState === </span><span class="s2">'function' </span><span class="s1">|| partialState == </span><span class="s3">null</span><span class="s1">)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;setState(...): takes an object of state variables to update or a function which returns an object of state variables.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">this</span><span class="s1">.updater.enqueueSetState(</span><span class="s3">this</span><span class="s1">, partialState, callback, </span><span class="s2">'setState'</span><span class="s1">);</span>
  <span class="s1">};</span>
  <span class="s0">/** 
   * Forces an update. This should only be invoked when it is known with 
   * certainty that we are **not** in a DOM transaction. 
   * 
   * You may want to call this when you know that some deeper aspect of the 
   * component's state has changed but `setState` was not called. 
   * 
   * This will not invoke `shouldComponentUpdate`, but it will invoke 
   * `componentWillUpdate` and `componentDidUpdate`. 
   * 
   * @param {?function} callback Called after update is complete. 
   * @final 
   * @protected 
   */</span>


  <span class="s1">Component.prototype.forceUpdate = </span><span class="s3">function </span><span class="s1">(callback) {</span>
    <span class="s3">this</span><span class="s1">.updater.enqueueForceUpdate(</span><span class="s3">this</span><span class="s1">, callback, </span><span class="s2">'forceUpdate'</span><span class="s1">);</span>
  <span class="s1">};</span>
  <span class="s0">/** 
   * Deprecated APIs. These APIs used to exist on classic React classes but since 
   * we would like to deprecate them, we're not going to move them over to this 
   * modern base class. Instead, we define a getter that warns if it's accessed. 
   */</span>


  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">deprecatedAPIs = {</span>
      <span class="s1">isMounted: [</span><span class="s2">'isMounted'</span><span class="s1">, </span><span class="s2">'Instead, make sure to clean up subscriptions and pending requests in ' </span><span class="s1">+ </span><span class="s2">'componentWillUnmount to prevent memory leaks.'</span><span class="s1">],</span>
      <span class="s1">replaceState: [</span><span class="s2">'replaceState'</span><span class="s1">, </span><span class="s2">'Refactor your code to use setState instead (see ' </span><span class="s1">+ </span><span class="s2">'https://github.com/facebook/react/issues/3236).'</span><span class="s1">]</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">defineDeprecationWarning = </span><span class="s3">function </span><span class="s1">(methodName, info) {</span>
      <span class="s1">Object.defineProperty(Component.prototype, methodName, {</span>
        <span class="s1">get: </span><span class="s3">function </span><span class="s1">() {</span>
          <span class="s1">warn(</span><span class="s2">'%s(...) is deprecated in plain JavaScript React classes. %s'</span><span class="s1">, info[</span><span class="s4">0</span><span class="s1">], info[</span><span class="s4">1</span><span class="s1">]);</span>

          <span class="s3">return </span><span class="s1">undefined;</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
    <span class="s1">};</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">fnName </span><span class="s3">in </span><span class="s1">deprecatedAPIs) {</span>
      <span class="s3">if </span><span class="s1">(deprecatedAPIs.hasOwnProperty(fnName)) {</span>
        <span class="s1">defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">ComponentDummy() {}</span>

  <span class="s1">ComponentDummy.prototype = Component.prototype;</span>
  <span class="s0">/** 
   * Convenience component with default shallow equality check for sCU. 
   */</span>

  <span class="s3">function </span><span class="s1">PureComponent(props, context, updater) {</span>
    <span class="s3">this</span><span class="s1">.props = props;</span>
    <span class="s3">this</span><span class="s1">.context = context; </span><span class="s0">// If a component has string refs, we will assign a different object later.</span>

    <span class="s3">this</span><span class="s1">.refs = emptyObject;</span>
    <span class="s3">this</span><span class="s1">.updater = updater || ReactNoopUpdateQueue;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">pureComponentPrototype = PureComponent.prototype = </span><span class="s3">new </span><span class="s1">ComponentDummy();</span>
  <span class="s1">pureComponentPrototype.constructor = PureComponent; </span><span class="s0">// Avoid an extra prototype jump for these methods.</span>

  <span class="s1">objectAssign(pureComponentPrototype, Component.prototype);</span>

  <span class="s1">pureComponentPrototype.isPureReactComponent = </span><span class="s3">true</span><span class="s1">;</span>

  <span class="s0">// an immutable object with a single mutable value</span>
  <span class="s3">function </span><span class="s1">createRef() {</span>
    <span class="s3">var </span><span class="s1">refObject = {</span>
      <span class="s1">current: </span><span class="s3">null</span>
    <span class="s1">};</span>

    <span class="s1">{</span>
      <span class="s1">Object.seal(refObject);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">refObject;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">hasOwnProperty$1 = Object.prototype.hasOwnProperty;</span>
  <span class="s3">var </span><span class="s1">RESERVED_PROPS = {</span>
    <span class="s1">key: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">ref: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">__self: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">__source: </span><span class="s3">true</span>
  <span class="s1">};</span>
  <span class="s3">var </span><span class="s1">specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;</span>

  <span class="s1">{</span>
    <span class="s1">didWarnAboutStringRefs = {};</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">hasValidRef(config) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(hasOwnProperty$1.call(config, </span><span class="s2">'ref'</span><span class="s1">)) {</span>
        <span class="s3">var </span><span class="s1">getter = Object.getOwnPropertyDescriptor(config, </span><span class="s2">'ref'</span><span class="s1">).get;</span>

        <span class="s3">if </span><span class="s1">(getter &amp;&amp; getter.isReactWarning) {</span>
          <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">config.ref !== undefined;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">hasValidKey(config) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(hasOwnProperty$1.call(config, </span><span class="s2">'key'</span><span class="s1">)) {</span>
        <span class="s3">var </span><span class="s1">getter = Object.getOwnPropertyDescriptor(config, </span><span class="s2">'key'</span><span class="s1">).get;</span>

        <span class="s3">if </span><span class="s1">(getter &amp;&amp; getter.isReactWarning) {</span>
          <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">config.key !== undefined;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">defineKeyPropWarningGetter(props, displayName) {</span>
    <span class="s3">var </span><span class="s1">warnAboutAccessingKey = </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(!specialPropKeyWarningShown) {</span>
          <span class="s1">specialPropKeyWarningShown = </span><span class="s3">true</span><span class="s1">;</span>

          <span class="s1">error(</span><span class="s2">'%s: `key` is not a prop. Trying to access it will result ' </span><span class="s1">+ </span><span class="s2">'in `undefined` being returned. If you need to access the same ' </span><span class="s1">+ </span><span class="s2">'value within the child component, you should pass it as a different ' </span><span class="s1">+ </span><span class="s2">'prop. (https://fb.me/react-special-props)'</span><span class="s1">, displayName);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">warnAboutAccessingKey.isReactWarning = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">Object.defineProperty(props, </span><span class="s2">'key'</span><span class="s1">, {</span>
      <span class="s1">get: warnAboutAccessingKey,</span>
      <span class="s1">configurable: </span><span class="s3">true</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">defineRefPropWarningGetter(props, displayName) {</span>
    <span class="s3">var </span><span class="s1">warnAboutAccessingRef = </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(!specialPropRefWarningShown) {</span>
          <span class="s1">specialPropRefWarningShown = </span><span class="s3">true</span><span class="s1">;</span>

          <span class="s1">error(</span><span class="s2">'%s: `ref` is not a prop. Trying to access it will result ' </span><span class="s1">+ </span><span class="s2">'in `undefined` being returned. If you need to access the same ' </span><span class="s1">+ </span><span class="s2">'value within the child component, you should pass it as a different ' </span><span class="s1">+ </span><span class="s2">'prop. (https://fb.me/react-special-props)'</span><span class="s1">, displayName);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">warnAboutAccessingRef.isReactWarning = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">Object.defineProperty(props, </span><span class="s2">'ref'</span><span class="s1">, {</span>
      <span class="s1">get: warnAboutAccessingRef,</span>
      <span class="s1">configurable: </span><span class="s3">true</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">warnIfStringRefCannotBeAutoConverted(config) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">config.ref === </span><span class="s2">'string' </span><span class="s1">&amp;&amp; ReactCurrentOwner.current &amp;&amp; config.__self &amp;&amp; ReactCurrentOwner.current.stateNode !== config.__self) {</span>
        <span class="s3">var </span><span class="s1">componentName = getComponentName(ReactCurrentOwner.current.type);</span>

        <span class="s3">if </span><span class="s1">(!didWarnAboutStringRefs[componentName]) {</span>
          <span class="s1">error(</span><span class="s2">'Component &quot;%s&quot; contains the string ref &quot;%s&quot;. ' </span><span class="s1">+ </span><span class="s2">'Support for string refs will be removed in a future major release. ' </span><span class="s1">+ </span><span class="s2">'This case cannot be automatically converted to an arrow function. ' </span><span class="s1">+ </span><span class="s2">'We ask you to manually fix this case by using useRef() or createRef() instead. ' </span><span class="s1">+ </span><span class="s2">'Learn more about using refs safely here: ' </span><span class="s1">+ </span><span class="s2">'https://fb.me/react-strict-mode-string-ref'</span><span class="s1">, getComponentName(ReactCurrentOwner.current.type), config.ref);</span>

          <span class="s1">didWarnAboutStringRefs[componentName] = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Factory method to create a new React element. This no longer adheres to 
   * the class pattern, so do not use new to call it. Also, instanceof check 
   * will not work. Instead test $$typeof field against Symbol.for('react.element') to check 
   * if something is a React Element. 
   * 
   * @param {*} type 
   * @param {*} props 
   * @param {*} key 
   * @param {string|object} ref 
   * @param {*} owner 
   * @param {*} self A *temporary* helper to detect places where `this` is 
   * different from the `owner` when React.createElement is called, so that we 
   * can warn. We want to get rid of owner and replace string `ref`s with arrow 
   * functions, and as long as `this` and owner are the same, there will be no 
   * change in behavior. 
   * @param {*} source An annotation object (added by a transpiler or otherwise) 
   * indicating filename, line number, and/or other information. 
   * @internal 
   */</span>


  <span class="s3">var </span><span class="s1">ReactElement = </span><span class="s3">function </span><span class="s1">(type, key, ref, self, source, owner, props) {</span>
    <span class="s3">var </span><span class="s1">element = {</span>
      <span class="s0">// This tag allows us to uniquely identify this as a React Element</span>
      <span class="s1">$$typeof: REACT_ELEMENT_TYPE,</span>
      <span class="s0">// Built-in properties that belong on the element</span>
      <span class="s1">type: type,</span>
      <span class="s1">key: key,</span>
      <span class="s1">ref: ref,</span>
      <span class="s1">props: props,</span>
      <span class="s0">// Record the component responsible for creating this element.</span>
      <span class="s1">_owner: owner</span>
    <span class="s1">};</span>

    <span class="s1">{</span>
      <span class="s0">// The validation flag is currently mutative. We put it on</span>
      <span class="s0">// an external backing store so that we can freeze the whole object.</span>
      <span class="s0">// This can be replaced with a WeakMap once they are implemented in</span>
      <span class="s0">// commonly used development environments.</span>
      <span class="s1">element._store = {}; </span><span class="s0">// To make comparing ReactElements easier for testing purposes, we make</span>
      <span class="s0">// the validation flag non-enumerable (where possible, which should</span>
      <span class="s0">// include every environment we run tests in), so the test framework</span>
      <span class="s0">// ignores it.</span>

      <span class="s1">Object.defineProperty(element._store, </span><span class="s2">'validated'</span><span class="s1">, {</span>
        <span class="s1">configurable: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">writable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">value: </span><span class="s3">false</span>
      <span class="s1">}); </span><span class="s0">// self and source are DEV only properties.</span>

      <span class="s1">Object.defineProperty(element, </span><span class="s2">'_self'</span><span class="s1">, {</span>
        <span class="s1">configurable: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">writable: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">value: self</span>
      <span class="s1">}); </span><span class="s0">// Two elements created in two different places should be considered</span>
      <span class="s0">// equal for testing purposes and therefore we hide it from enumeration.</span>

      <span class="s1">Object.defineProperty(element, </span><span class="s2">'_source'</span><span class="s1">, {</span>
        <span class="s1">configurable: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">writable: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">value: source</span>
      <span class="s1">});</span>

      <span class="s3">if </span><span class="s1">(Object.freeze) {</span>
        <span class="s1">Object.freeze(element.props);</span>
        <span class="s1">Object.freeze(element);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">element;</span>
  <span class="s1">};</span>
  <span class="s0">/** 
   * Create and return a new ReactElement of the given type. 
   * See https://reactjs.org/docs/react-api.html#createelement 
   */</span>

  <span class="s3">function </span><span class="s1">createElement(type, config, children) {</span>
    <span class="s3">var </span><span class="s1">propName; </span><span class="s0">// Reserved names are extracted</span>

    <span class="s3">var </span><span class="s1">props = {};</span>
    <span class="s3">var </span><span class="s1">key = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">ref = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">self = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">source = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(config != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(hasValidRef(config)) {</span>
        <span class="s1">ref = config.ref;</span>

        <span class="s1">{</span>
          <span class="s1">warnIfStringRefCannotBeAutoConverted(config);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(hasValidKey(config)) {</span>
        <span class="s1">key = </span><span class="s2">'' </span><span class="s1">+ config.key;</span>
      <span class="s1">}</span>

      <span class="s1">self = config.__self === undefined ? </span><span class="s3">null </span><span class="s1">: config.__self;</span>
      <span class="s1">source = config.__source === undefined ? </span><span class="s3">null </span><span class="s1">: config.__source; </span><span class="s0">// Remaining properties are added to a new props object</span>

      <span class="s3">for </span><span class="s1">(propName </span><span class="s3">in </span><span class="s1">config) {</span>
        <span class="s3">if </span><span class="s1">(hasOwnProperty$1.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) {</span>
          <span class="s1">props[propName] = config[propName];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Children can be more than one argument, and those are transferred onto</span>
    <span class="s0">// the newly allocated props object.</span>


    <span class="s3">var </span><span class="s1">childrenLength = arguments.length - </span><span class="s4">2</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(childrenLength === </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">props.children = children;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(childrenLength &gt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">childArray = Array(childrenLength);</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; childrenLength; i++) {</span>
        <span class="s1">childArray[i] = arguments[i + </span><span class="s4">2</span><span class="s1">];</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(Object.freeze) {</span>
          <span class="s1">Object.freeze(childArray);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">props.children = childArray;</span>
    <span class="s1">} </span><span class="s0">// Resolve default props</span>


    <span class="s3">if </span><span class="s1">(type &amp;&amp; type.defaultProps) {</span>
      <span class="s3">var </span><span class="s1">defaultProps = type.defaultProps;</span>

      <span class="s3">for </span><span class="s1">(propName </span><span class="s3">in </span><span class="s1">defaultProps) {</span>
        <span class="s3">if </span><span class="s1">(props[propName] === undefined) {</span>
          <span class="s1">props[propName] = defaultProps[propName];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(key || ref) {</span>
        <span class="s3">var </span><span class="s1">displayName = </span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'function' </span><span class="s1">? type.displayName || type.name || </span><span class="s2">'Unknown' </span><span class="s1">: type;</span>

        <span class="s3">if </span><span class="s1">(key) {</span>
          <span class="s1">defineKeyPropWarningGetter(props, displayName);</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(ref) {</span>
          <span class="s1">defineRefPropWarningGetter(props, displayName);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">cloneAndReplaceKey(oldElement, newKey) {</span>
    <span class="s3">var </span><span class="s1">newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);</span>
    <span class="s3">return </span><span class="s1">newElement;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Clone and return a new ReactElement using element as the starting point. 
   * See https://reactjs.org/docs/react-api.html#cloneelement 
   */</span>

  <span class="s3">function </span><span class="s1">cloneElement(element, config, children) {</span>
    <span class="s3">if </span><span class="s1">(!!(element === </span><span class="s3">null </span><span class="s1">|| element === undefined)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;React.cloneElement(...): The argument must be a React element, but you passed &quot; </span><span class="s1">+ element + </span><span class="s2">&quot;.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">propName; </span><span class="s0">// Original props are copied</span>

    <span class="s3">var </span><span class="s1">props = objectAssign({}, element.props); </span><span class="s0">// Reserved names are extracted</span>


    <span class="s3">var </span><span class="s1">key = element.key;</span>
    <span class="s3">var </span><span class="s1">ref = element.ref; </span><span class="s0">// Self is preserved since the owner is preserved.</span>

    <span class="s3">var </span><span class="s1">self = element._self; </span><span class="s0">// Source is preserved since cloneElement is unlikely to be targeted by a</span>
    <span class="s0">// transpiler, and the original source is probably a better indicator of the</span>
    <span class="s0">// true owner.</span>

    <span class="s3">var </span><span class="s1">source = element._source; </span><span class="s0">// Owner will be preserved, unless ref is overridden</span>

    <span class="s3">var </span><span class="s1">owner = element._owner;</span>

    <span class="s3">if </span><span class="s1">(config != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(hasValidRef(config)) {</span>
        <span class="s0">// Silently steal the ref from the parent.</span>
        <span class="s1">ref = config.ref;</span>
        <span class="s1">owner = ReactCurrentOwner.current;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(hasValidKey(config)) {</span>
        <span class="s1">key = </span><span class="s2">'' </span><span class="s1">+ config.key;</span>
      <span class="s1">} </span><span class="s0">// Remaining properties override existing props</span>


      <span class="s3">var </span><span class="s1">defaultProps;</span>

      <span class="s3">if </span><span class="s1">(element.type &amp;&amp; element.type.defaultProps) {</span>
        <span class="s1">defaultProps = element.type.defaultProps;</span>
      <span class="s1">}</span>

      <span class="s3">for </span><span class="s1">(propName </span><span class="s3">in </span><span class="s1">config) {</span>
        <span class="s3">if </span><span class="s1">(hasOwnProperty$1.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) {</span>
          <span class="s3">if </span><span class="s1">(config[propName] === undefined &amp;&amp; defaultProps !== undefined) {</span>
            <span class="s0">// Resolve default props</span>
            <span class="s1">props[propName] = defaultProps[propName];</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">props[propName] = config[propName];</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Children can be more than one argument, and those are transferred onto</span>
    <span class="s0">// the newly allocated props object.</span>


    <span class="s3">var </span><span class="s1">childrenLength = arguments.length - </span><span class="s4">2</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(childrenLength === </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">props.children = children;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(childrenLength &gt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">childArray = Array(childrenLength);</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; childrenLength; i++) {</span>
        <span class="s1">childArray[i] = arguments[i + </span><span class="s4">2</span><span class="s1">];</span>
      <span class="s1">}</span>

      <span class="s1">props.children = childArray;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">ReactElement(element.type, key, ref, self, source, owner, props);</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Verifies the object is a ReactElement. 
   * See https://reactjs.org/docs/react-api.html#isvalidelement 
   * @param {?object} object 
   * @return {boolean} True if `object` is a ReactElement. 
   * @final 
   */</span>

  <span class="s3">function </span><span class="s1">isValidElement(object) {</span>
    <span class="s3">return typeof </span><span class="s1">object === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; object !== </span><span class="s3">null </span><span class="s1">&amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">SEPARATOR = </span><span class="s2">'.'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">SUBSEPARATOR = </span><span class="s2">':'</span><span class="s1">;</span>
  <span class="s0">/** 
   * Escape and wrap key so it is safe to use as a reactid 
   * 
   * @param {string} key to be escaped. 
   * @return {string} the escaped key. 
   */</span>

  <span class="s3">function </span><span class="s1">escape(key) {</span>
    <span class="s3">var </span><span class="s1">escapeRegex = /[=:]/g;</span>
    <span class="s3">var </span><span class="s1">escaperLookup = {</span>
      <span class="s2">'='</span><span class="s1">: </span><span class="s2">'=0'</span><span class="s1">,</span>
      <span class="s2">':'</span><span class="s1">: </span><span class="s2">'=2'</span>
    <span class="s1">};</span>
    <span class="s3">var </span><span class="s1">escapedString = (</span><span class="s2">'' </span><span class="s1">+ key).replace(escapeRegex, </span><span class="s3">function </span><span class="s1">(match) {</span>
      <span class="s3">return </span><span class="s1">escaperLookup[match];</span>
    <span class="s1">});</span>
    <span class="s3">return </span><span class="s2">'$' </span><span class="s1">+ escapedString;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * TODO: Test that a single child and an array with one item have the same key 
   * pattern. 
   */</span>


  <span class="s3">var </span><span class="s1">didWarnAboutMaps = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">userProvidedKeyEscapeRegex = /\/+/g;</span>

  <span class="s3">function </span><span class="s1">escapeUserProvidedKey(text) {</span>
    <span class="s3">return </span><span class="s1">(</span><span class="s2">'' </span><span class="s1">+ text).replace(userProvidedKeyEscapeRegex, </span><span class="s2">'$&amp;/'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">POOL_SIZE = </span><span class="s4">10</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">traverseContextPool = [];</span>

  <span class="s3">function </span><span class="s1">getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {</span>
    <span class="s3">if </span><span class="s1">(traverseContextPool.length) {</span>
      <span class="s3">var </span><span class="s1">traverseContext = traverseContextPool.pop();</span>
      <span class="s1">traverseContext.result = mapResult;</span>
      <span class="s1">traverseContext.keyPrefix = keyPrefix;</span>
      <span class="s1">traverseContext.func = mapFunction;</span>
      <span class="s1">traverseContext.context = mapContext;</span>
      <span class="s1">traverseContext.count = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s3">return </span><span class="s1">traverseContext;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">result: mapResult,</span>
        <span class="s1">keyPrefix: keyPrefix,</span>
        <span class="s1">func: mapFunction,</span>
        <span class="s1">context: mapContext,</span>
        <span class="s1">count: </span><span class="s4">0</span>
      <span class="s1">};</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">releaseTraverseContext(traverseContext) {</span>
    <span class="s1">traverseContext.result = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">traverseContext.keyPrefix = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">traverseContext.func = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">traverseContext.context = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">traverseContext.count = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(traverseContextPool.length &lt; POOL_SIZE) {</span>
      <span class="s1">traverseContextPool.push(traverseContext);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * @param {?*} children Children tree container. 
   * @param {!string} nameSoFar Name of the key path so far. 
   * @param {!function} callback Callback to invoke with each child found. 
   * @param {?*} traverseContext Used to pass information throughout the traversal 
   * process. 
   * @return {!number} The number of children in this subtree. 
   */</span>


  <span class="s3">function </span><span class="s1">traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {</span>
    <span class="s3">var </span><span class="s1">type = </span><span class="s3">typeof </span><span class="s1">children;</span>

    <span class="s3">if </span><span class="s1">(type === </span><span class="s2">'undefined' </span><span class="s1">|| type === </span><span class="s2">'boolean'</span><span class="s1">) {</span>
      <span class="s0">// All of the above are perceived as null.</span>
      <span class="s1">children = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">invokeCallback = </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(children === </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">invokeCallback = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">switch </span><span class="s1">(type) {</span>
        <span class="s3">case </span><span class="s2">'string'</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">'number'</span><span class="s1">:</span>
          <span class="s1">invokeCallback = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s2">'object'</span><span class="s1">:</span>
          <span class="s3">switch </span><span class="s1">(children.$$typeof) {</span>
            <span class="s3">case </span><span class="s1">REACT_ELEMENT_TYPE:</span>
            <span class="s3">case </span><span class="s1">REACT_PORTAL_TYPE:</span>
              <span class="s1">invokeCallback = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">}</span>

      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(invokeCallback) {</span>
      <span class="s1">callback(traverseContext, children, </span><span class="s0">// If it's the only child, treat the name as if it was wrapped in an array</span>
      <span class="s0">// so that it's consistent if the number of children grows.</span>
      <span class="s1">nameSoFar === </span><span class="s2">'' </span><span class="s1">? SEPARATOR + getComponentKey(children, </span><span class="s4">0</span><span class="s1">) : nameSoFar);</span>
      <span class="s3">return </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">child;</span>
    <span class="s3">var </span><span class="s1">nextName;</span>
    <span class="s3">var </span><span class="s1">subtreeCount = </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// Count of children found in the current subtree.</span>

    <span class="s3">var </span><span class="s1">nextNamePrefix = nameSoFar === </span><span class="s2">'' </span><span class="s1">? SEPARATOR : nameSoFar + SUBSEPARATOR;</span>

    <span class="s3">if </span><span class="s1">(Array.isArray(children)) {</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; children.length; i++) {</span>
        <span class="s1">child = children[i];</span>
        <span class="s1">nextName = nextNamePrefix + getComponentKey(child, i);</span>
        <span class="s1">subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">iteratorFn = getIteratorFn(children);</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">iteratorFn === </span><span class="s2">'function'</span><span class="s1">) {</span>

        <span class="s1">{</span>
          <span class="s0">// Warn about using Maps as children</span>
          <span class="s3">if </span><span class="s1">(iteratorFn === children.entries) {</span>
            <span class="s3">if </span><span class="s1">(!didWarnAboutMaps) {</span>
              <span class="s1">warn(</span><span class="s2">'Using Maps as children is deprecated and will be removed in ' </span><span class="s1">+ </span><span class="s2">'a future major release. Consider converting children to ' </span><span class="s1">+ </span><span class="s2">'an array of keyed ReactElements instead.'</span><span class="s1">);</span>
            <span class="s1">}</span>

            <span class="s1">didWarnAboutMaps = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">iterator = iteratorFn.call(children);</span>
        <span class="s3">var </span><span class="s1">step;</span>
        <span class="s3">var </span><span class="s1">ii = </span><span class="s4">0</span><span class="s1">;</span>

        <span class="s3">while </span><span class="s1">(!(step = iterator.next()).done) {</span>
          <span class="s1">child = step.value;</span>
          <span class="s1">nextName = nextNamePrefix + getComponentKey(child, ii++);</span>
          <span class="s1">subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(type === </span><span class="s2">'object'</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">addendum = </span><span class="s2">''</span><span class="s1">;</span>

        <span class="s1">{</span>
          <span class="s1">addendum = </span><span class="s2">' If you meant to render a collection of children, use an array ' </span><span class="s1">+ </span><span class="s2">'instead.' </span><span class="s1">+ ReactDebugCurrentFrame.getStackAddendum();</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">childrenString = </span><span class="s2">'' </span><span class="s1">+ children;</span>

        <span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Objects are not valid as a React child (found: &quot; </span><span class="s1">+ (childrenString === </span><span class="s2">'[object Object]' </span><span class="s1">? </span><span class="s2">'object with keys {' </span><span class="s1">+ Object.keys(children).join(</span><span class="s2">', '</span><span class="s1">) + </span><span class="s2">'}' </span><span class="s1">: childrenString) + </span><span class="s2">&quot;).&quot; </span><span class="s1">+ addendum );</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">subtreeCount;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Traverses children that are typically specified as `props.children`, but 
   * might also be specified through attributes: 
   * 
   * - `traverseAllChildren(this.props.children, ...)` 
   * - `traverseAllChildren(this.props.leftPanelChildren, ...)` 
   * 
   * The `traverseContext` is an optional argument that is passed through the 
   * entire traversal. It can be used to store accumulations or anything else that 
   * the callback might find relevant. 
   * 
   * @param {?*} children Children tree object. 
   * @param {!function} callback To invoke upon traversing each child. 
   * @param {?*} traverseContext Context for traversal. 
   * @return {!number} The number of children in this subtree. 
   */</span>


  <span class="s3">function </span><span class="s1">traverseAllChildren(children, callback, traverseContext) {</span>
    <span class="s3">if </span><span class="s1">(children == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">traverseAllChildrenImpl(children, </span><span class="s2">''</span><span class="s1">, callback, traverseContext);</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Generate a key string that identifies a component within a set. 
   * 
   * @param {*} component A component that could contain a manual key. 
   * @param {number} index Index that is used if a manual key is not provided. 
   * @return {string} 
   */</span>


  <span class="s3">function </span><span class="s1">getComponentKey(component, index) {</span>
    <span class="s0">// Do some typechecking here since we call this blindly. We want to ensure</span>
    <span class="s0">// that we don't block potential future ES APIs.</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">component === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; component !== </span><span class="s3">null </span><span class="s1">&amp;&amp; component.key != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// Explicit key</span>
      <span class="s3">return </span><span class="s1">escape(component.key);</span>
    <span class="s1">} </span><span class="s0">// Implicit key determined by the index in the set</span>


    <span class="s3">return </span><span class="s1">index.toString(</span><span class="s4">36</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">forEachSingleChild(bookKeeping, child, name) {</span>
    <span class="s3">var </span><span class="s1">func = bookKeeping.func,</span>
        <span class="s1">context = bookKeeping.context;</span>
    <span class="s1">func.call(context, child, bookKeeping.count++);</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Iterates through children that are typically specified as `props.children`. 
   * 
   * See https://reactjs.org/docs/react-api.html#reactchildrenforeach 
   * 
   * The provided forEachFunc(child, index) will be called for each 
   * leaf child. 
   * 
   * @param {?*} children Children tree container. 
   * @param {function(*, int)} forEachFunc 
   * @param {*} forEachContext Context for forEachContext. 
   */</span>


  <span class="s3">function </span><span class="s1">forEachChildren(children, forEachFunc, forEachContext) {</span>
    <span class="s3">if </span><span class="s1">(children == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">children;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">traverseContext = getPooledTraverseContext(</span><span class="s3">null</span><span class="s1">, </span><span class="s3">null</span><span class="s1">, forEachFunc, forEachContext);</span>
    <span class="s1">traverseAllChildren(children, forEachSingleChild, traverseContext);</span>
    <span class="s1">releaseTraverseContext(traverseContext);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">mapSingleChildIntoContext(bookKeeping, child, childKey) {</span>
    <span class="s3">var </span><span class="s1">result = bookKeeping.result,</span>
        <span class="s1">keyPrefix = bookKeeping.keyPrefix,</span>
        <span class="s1">func = bookKeeping.func,</span>
        <span class="s1">context = bookKeeping.context;</span>
    <span class="s3">var </span><span class="s1">mappedChild = func.call(context, child, bookKeeping.count++);</span>

    <span class="s3">if </span><span class="s1">(Array.isArray(mappedChild)) {</span>
      <span class="s1">mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, </span><span class="s3">function </span><span class="s1">(c) {</span>
        <span class="s3">return </span><span class="s1">c;</span>
      <span class="s1">});</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(mappedChild != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(isValidElement(mappedChild)) {</span>
        <span class="s1">mappedChild = cloneAndReplaceKey(mappedChild, </span><span class="s0">// Keep both the (mapped) and old keys if they differ, just as</span>
        <span class="s0">// traverseAllChildren used to do for objects as children</span>
        <span class="s1">keyPrefix + (mappedChild.key &amp;&amp; (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + </span><span class="s2">'/' </span><span class="s1">: </span><span class="s2">''</span><span class="s1">) + childKey);</span>
      <span class="s1">}</span>

      <span class="s1">result.push(mappedChild);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {</span>
    <span class="s3">var </span><span class="s1">escapedPrefix = </span><span class="s2">''</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(prefix != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">escapedPrefix = escapeUserProvidedKey(prefix) + </span><span class="s2">'/'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);</span>
    <span class="s1">traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);</span>
    <span class="s1">releaseTraverseContext(traverseContext);</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Maps children that are typically specified as `props.children`. 
   * 
   * See https://reactjs.org/docs/react-api.html#reactchildrenmap 
   * 
   * The provided mapFunction(child, key, index) will be called for each 
   * leaf child. 
   * 
   * @param {?*} children Children tree container. 
   * @param {function(*, int)} func The map function. 
   * @param {*} context Context for mapFunction. 
   * @return {object} Object containing the ordered map of results. 
   */</span>


  <span class="s3">function </span><span class="s1">mapChildren(children, func, context) {</span>
    <span class="s3">if </span><span class="s1">(children == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">children;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">result = [];</span>
    <span class="s1">mapIntoWithKeyPrefixInternal(children, result, </span><span class="s3">null</span><span class="s1">, func, context);</span>
    <span class="s3">return </span><span class="s1">result;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Count the number of children that are typically specified as 
   * `props.children`. 
   * 
   * See https://reactjs.org/docs/react-api.html#reactchildrencount 
   * 
   * @param {?*} children Children tree container. 
   * @return {number} The number of children. 
   */</span>


  <span class="s3">function </span><span class="s1">countChildren(children) {</span>
    <span class="s3">return </span><span class="s1">traverseAllChildren(children, </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}, </span><span class="s3">null</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Flatten a children object (typically specified as `props.children`) and 
   * return an array with appropriately re-keyed children. 
   * 
   * See https://reactjs.org/docs/react-api.html#reactchildrentoarray 
   */</span>


  <span class="s3">function </span><span class="s1">toArray(children) {</span>
    <span class="s3">var </span><span class="s1">result = [];</span>
    <span class="s1">mapIntoWithKeyPrefixInternal(children, result, </span><span class="s3">null</span><span class="s1">, </span><span class="s3">function </span><span class="s1">(child) {</span>
      <span class="s3">return </span><span class="s1">child;</span>
    <span class="s1">});</span>
    <span class="s3">return </span><span class="s1">result;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Returns the first child in a collection of children and verifies that there 
   * is only one child in the collection. 
   * 
   * See https://reactjs.org/docs/react-api.html#reactchildrenonly 
   * 
   * The current implementation of this function assumes that a single child gets 
   * passed without a wrapper, but the purpose of this helper function is to 
   * abstract away the particular structure of children. 
   * 
   * @param {?object} children Child collection structure. 
   * @return {ReactElement} The first and only `ReactElement` contained in the 
   * structure. 
   */</span>


  <span class="s3">function </span><span class="s1">onlyChild(children) {</span>
    <span class="s3">if </span><span class="s1">(!isValidElement(children)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;React.Children.only expected to receive a single React element child.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">children;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createContext(defaultValue, calculateChangedBits) {</span>
    <span class="s3">if </span><span class="s1">(calculateChangedBits === undefined) {</span>
      <span class="s1">calculateChangedBits = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(calculateChangedBits !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">calculateChangedBits !== </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s1">error(</span><span class="s2">'createContext: Expected the optional second argument to be a ' </span><span class="s1">+ </span><span class="s2">'function. Instead received: %s'</span><span class="s1">, calculateChangedBits);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">context = {</span>
      <span class="s1">$$typeof: REACT_CONTEXT_TYPE,</span>
      <span class="s1">_calculateChangedBits: calculateChangedBits,</span>
      <span class="s0">// As a workaround to support multiple concurrent renderers, we categorize</span>
      <span class="s0">// some renderers as primary and others as secondary. We only expect</span>
      <span class="s0">// there to be two concurrent renderers at most: React Native (primary) and</span>
      <span class="s0">// Fabric (secondary); React DOM (primary) and React ART (secondary).</span>
      <span class="s0">// Secondary renderers store their context values on separate fields.</span>
      <span class="s1">_currentValue: defaultValue,</span>
      <span class="s1">_currentValue2: defaultValue,</span>
      <span class="s0">// Used to track how many concurrent renderers this context currently</span>
      <span class="s0">// supports within in a single renderer. Such as parallel server rendering.</span>
      <span class="s1">_threadCount: </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s0">// These are circular</span>
      <span class="s1">Provider: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">Consumer: </span><span class="s3">null</span>
    <span class="s1">};</span>
    <span class="s1">context.Provider = {</span>
      <span class="s1">$$typeof: REACT_PROVIDER_TYPE,</span>
      <span class="s1">_context: context</span>
    <span class="s1">};</span>
    <span class="s3">var </span><span class="s1">hasWarnedAboutUsingNestedContextConsumers = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">hasWarnedAboutUsingConsumerProvider = </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s1">{</span>
      <span class="s0">// A separate object, but proxies back to the original context object for</span>
      <span class="s0">// backwards compatibility. It has a different $$typeof, so we can properly</span>
      <span class="s0">// warn for the incorrect usage of Context as a Consumer.</span>
      <span class="s3">var </span><span class="s1">Consumer = {</span>
        <span class="s1">$$typeof: REACT_CONTEXT_TYPE,</span>
        <span class="s1">_context: context,</span>
        <span class="s1">_calculateChangedBits: context._calculateChangedBits</span>
      <span class="s1">}; </span><span class="s0">// $FlowFixMe: Flow complains about not setting a value, which is intentional here</span>

      <span class="s1">Object.defineProperties(Consumer, {</span>
        <span class="s1">Provider: {</span>
          <span class="s1">get: </span><span class="s3">function </span><span class="s1">() {</span>
            <span class="s3">if </span><span class="s1">(!hasWarnedAboutUsingConsumerProvider) {</span>
              <span class="s1">hasWarnedAboutUsingConsumerProvider = </span><span class="s3">true</span><span class="s1">;</span>

              <span class="s1">error(</span><span class="s2">'Rendering &lt;Context.Consumer.Provider&gt; is not supported and will be removed in ' </span><span class="s1">+ </span><span class="s2">'a future major release. Did you mean to render &lt;Context.Provider&gt; instead?'</span><span class="s1">);</span>
            <span class="s1">}</span>

            <span class="s3">return </span><span class="s1">context.Provider;</span>
          <span class="s1">},</span>
          <span class="s1">set: </span><span class="s3">function </span><span class="s1">(_Provider) {</span>
            <span class="s1">context.Provider = _Provider;</span>
          <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">_currentValue: {</span>
          <span class="s1">get: </span><span class="s3">function </span><span class="s1">() {</span>
            <span class="s3">return </span><span class="s1">context._currentValue;</span>
          <span class="s1">},</span>
          <span class="s1">set: </span><span class="s3">function </span><span class="s1">(_currentValue) {</span>
            <span class="s1">context._currentValue = _currentValue;</span>
          <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">_currentValue2: {</span>
          <span class="s1">get: </span><span class="s3">function </span><span class="s1">() {</span>
            <span class="s3">return </span><span class="s1">context._currentValue2;</span>
          <span class="s1">},</span>
          <span class="s1">set: </span><span class="s3">function </span><span class="s1">(_currentValue2) {</span>
            <span class="s1">context._currentValue2 = _currentValue2;</span>
          <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">_threadCount: {</span>
          <span class="s1">get: </span><span class="s3">function </span><span class="s1">() {</span>
            <span class="s3">return </span><span class="s1">context._threadCount;</span>
          <span class="s1">},</span>
          <span class="s1">set: </span><span class="s3">function </span><span class="s1">(_threadCount) {</span>
            <span class="s1">context._threadCount = _threadCount;</span>
          <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">Consumer: {</span>
          <span class="s1">get: </span><span class="s3">function </span><span class="s1">() {</span>
            <span class="s3">if </span><span class="s1">(!hasWarnedAboutUsingNestedContextConsumers) {</span>
              <span class="s1">hasWarnedAboutUsingNestedContextConsumers = </span><span class="s3">true</span><span class="s1">;</span>

              <span class="s1">error(</span><span class="s2">'Rendering &lt;Context.Consumer.Consumer&gt; is not supported and will be removed in ' </span><span class="s1">+ </span><span class="s2">'a future major release. Did you mean to render &lt;Context.Consumer&gt; instead?'</span><span class="s1">);</span>
            <span class="s1">}</span>

            <span class="s3">return </span><span class="s1">context.Consumer;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}); </span><span class="s0">// $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty</span>

      <span class="s1">context.Consumer = Consumer;</span>
    <span class="s1">}</span>

    <span class="s1">{</span>
      <span class="s1">context._currentRenderer = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">context._currentRenderer2 = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">context;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">lazy(ctor) {</span>
    <span class="s3">var </span><span class="s1">lazyType = {</span>
      <span class="s1">$$typeof: REACT_LAZY_TYPE,</span>
      <span class="s1">_ctor: ctor,</span>
      <span class="s0">// React uses these fields to store the result.</span>
      <span class="s1">_status: -</span><span class="s4">1</span><span class="s1">,</span>
      <span class="s1">_result: </span><span class="s3">null</span>
    <span class="s1">};</span>

    <span class="s1">{</span>
      <span class="s0">// In production, this would just set it on the object.</span>
      <span class="s3">var </span><span class="s1">defaultProps;</span>
      <span class="s3">var </span><span class="s1">propTypes;</span>
      <span class="s1">Object.defineProperties(lazyType, {</span>
        <span class="s1">defaultProps: {</span>
          <span class="s1">configurable: </span><span class="s3">true</span><span class="s1">,</span>
          <span class="s1">get: </span><span class="s3">function </span><span class="s1">() {</span>
            <span class="s3">return </span><span class="s1">defaultProps;</span>
          <span class="s1">},</span>
          <span class="s1">set: </span><span class="s3">function </span><span class="s1">(newDefaultProps) {</span>
            <span class="s1">error(</span><span class="s2">'React.lazy(...): It is not supported to assign `defaultProps` to ' </span><span class="s1">+ </span><span class="s2">'a lazy component import. Either specify them where the component ' </span><span class="s1">+ </span><span class="s2">'is defined, or create a wrapping component around it.'</span><span class="s1">);</span>

            <span class="s1">defaultProps = newDefaultProps; </span><span class="s0">// Match production behavior more closely:</span>

            <span class="s1">Object.defineProperty(lazyType, </span><span class="s2">'defaultProps'</span><span class="s1">, {</span>
              <span class="s1">enumerable: </span><span class="s3">true</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">propTypes: {</span>
          <span class="s1">configurable: </span><span class="s3">true</span><span class="s1">,</span>
          <span class="s1">get: </span><span class="s3">function </span><span class="s1">() {</span>
            <span class="s3">return </span><span class="s1">propTypes;</span>
          <span class="s1">},</span>
          <span class="s1">set: </span><span class="s3">function </span><span class="s1">(newPropTypes) {</span>
            <span class="s1">error(</span><span class="s2">'React.lazy(...): It is not supported to assign `propTypes` to ' </span><span class="s1">+ </span><span class="s2">'a lazy component import. Either specify them where the component ' </span><span class="s1">+ </span><span class="s2">'is defined, or create a wrapping component around it.'</span><span class="s1">);</span>

            <span class="s1">propTypes = newPropTypes; </span><span class="s0">// Match production behavior more closely:</span>

            <span class="s1">Object.defineProperty(lazyType, </span><span class="s2">'propTypes'</span><span class="s1">, {</span>
              <span class="s1">enumerable: </span><span class="s3">true</span>
            <span class="s1">});</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">lazyType;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">forwardRef(render) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(render != </span><span class="s3">null </span><span class="s1">&amp;&amp; render.$$typeof === REACT_MEMO_TYPE) {</span>
        <span class="s1">error(</span><span class="s2">'forwardRef requires a render function but received a `memo` ' </span><span class="s1">+ </span><span class="s2">'component. Instead of forwardRef(memo(...)), use ' </span><span class="s1">+ </span><span class="s2">'memo(forwardRef(...)).'</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">render !== </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'forwardRef requires a render function but was given %s.'</span><span class="s1">, render === </span><span class="s3">null </span><span class="s1">? </span><span class="s2">'null' </span><span class="s1">: </span><span class="s3">typeof </span><span class="s1">render);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(render.length !== </span><span class="s4">0 </span><span class="s1">&amp;&amp; render.length !== </span><span class="s4">2</span><span class="s1">) {</span>
          <span class="s1">error(</span><span class="s2">'forwardRef render functions accept exactly two parameters: props and ref. %s'</span><span class="s1">, render.length === </span><span class="s4">1 </span><span class="s1">? </span><span class="s2">'Did you forget to use the ref parameter?' </span><span class="s1">: </span><span class="s2">'Any additional parameter will be undefined.'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(render != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(render.defaultProps != </span><span class="s3">null </span><span class="s1">|| render.propTypes != </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">error(</span><span class="s2">'forwardRef render functions do not support propTypes or defaultProps. ' </span><span class="s1">+ </span><span class="s2">'Did you accidentally pass a React component?'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">$$typeof: REACT_FORWARD_REF_TYPE,</span>
      <span class="s1">render: render</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">isValidElementType(type) {</span>
    <span class="s3">return typeof </span><span class="s1">type === </span><span class="s2">'string' </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'function' </span><span class="s1">|| </span><span class="s0">// Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.</span>
    <span class="s1">type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || </span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; type !== </span><span class="s3">null </span><span class="s1">&amp;&amp; (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">memo(type, compare) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!isValidElementType(type)) {</span>
        <span class="s1">error(</span><span class="s2">'memo: The first argument must be a component. Instead ' </span><span class="s1">+ </span><span class="s2">'received: %s'</span><span class="s1">, type === </span><span class="s3">null </span><span class="s1">? </span><span class="s2">'null' </span><span class="s1">: </span><span class="s3">typeof </span><span class="s1">type);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">$$typeof: REACT_MEMO_TYPE,</span>
      <span class="s1">type: type,</span>
      <span class="s1">compare: compare === undefined ? </span><span class="s3">null </span><span class="s1">: compare</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">resolveDispatcher() {</span>
    <span class="s3">var </span><span class="s1">dispatcher = ReactCurrentDispatcher.current;</span>

    <span class="s3">if </span><span class="s1">(!(dispatcher !== </span><span class="s3">null</span><span class="s1">)) {</span>
      <span class="s1">{</span>
        <span class="s3">throw </span><span class="s1">Error( </span><span class="s2">&quot;Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:</span><span class="s5">\n</span><span class="s2">1. You might have mismatching versions of React and the renderer (such as React DOM)</span><span class="s5">\n</span><span class="s2">2. You might be breaking the Rules of Hooks</span><span class="s5">\n</span><span class="s2">3. You might have more than one copy of React in the same app</span><span class="s5">\n</span><span class="s2">See https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.&quot; </span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">dispatcher;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">useContext(Context, unstable_observedBits) {</span>
    <span class="s3">var </span><span class="s1">dispatcher = resolveDispatcher();</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(unstable_observedBits !== undefined) {</span>
        <span class="s1">error(</span><span class="s2">'useContext() second argument is reserved for future ' </span><span class="s1">+ </span><span class="s2">'use in React. Passing it is not supported. ' </span><span class="s1">+ </span><span class="s2">'You passed: %s.%s'</span><span class="s1">, unstable_observedBits, </span><span class="s3">typeof </span><span class="s1">unstable_observedBits === </span><span class="s2">'number' </span><span class="s1">&amp;&amp; Array.isArray(arguments[</span><span class="s4">2</span><span class="s1">]) ? </span><span class="s2">'</span><span class="s5">\n\n</span><span class="s2">Did you call array.map(useContext)? ' </span><span class="s1">+ </span><span class="s2">'Calling Hooks inside a loop is not supported. ' </span><span class="s1">+ </span><span class="s2">'Learn more at https://fb.me/rules-of-hooks' </span><span class="s1">: </span><span class="s2">''</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s0">// TODO: add a more generic warning for invalid values.</span>


      <span class="s3">if </span><span class="s1">(Context._context !== undefined) {</span>
        <span class="s3">var </span><span class="s1">realContext = Context._context; </span><span class="s0">// Don't deduplicate because this legitimately causes bugs</span>
        <span class="s0">// and nobody should be using this in existing code.</span>

        <span class="s3">if </span><span class="s1">(realContext.Consumer === Context) {</span>
          <span class="s1">error(</span><span class="s2">'Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' </span><span class="s1">+ </span><span class="s2">'removed in a future major release. Did you mean to call useContext(Context) instead?'</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(realContext.Provider === Context) {</span>
          <span class="s1">error(</span><span class="s2">'Calling useContext(Context.Provider) is not supported. ' </span><span class="s1">+ </span><span class="s2">'Did you mean to call useContext(Context) instead?'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">dispatcher.useContext(Context, unstable_observedBits);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">useState(initialState) {</span>
    <span class="s3">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s3">return </span><span class="s1">dispatcher.useState(initialState);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">useReducer(reducer, initialArg, init) {</span>
    <span class="s3">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s3">return </span><span class="s1">dispatcher.useReducer(reducer, initialArg, init);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">useRef(initialValue) {</span>
    <span class="s3">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s3">return </span><span class="s1">dispatcher.useRef(initialValue);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">useEffect(create, deps) {</span>
    <span class="s3">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s3">return </span><span class="s1">dispatcher.useEffect(create, deps);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">useLayoutEffect(create, deps) {</span>
    <span class="s3">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s3">return </span><span class="s1">dispatcher.useLayoutEffect(create, deps);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">useCallback(callback, deps) {</span>
    <span class="s3">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s3">return </span><span class="s1">dispatcher.useCallback(callback, deps);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">useMemo(create, deps) {</span>
    <span class="s3">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s3">return </span><span class="s1">dispatcher.useMemo(create, deps);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">useImperativeHandle(ref, create, deps) {</span>
    <span class="s3">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
    <span class="s3">return </span><span class="s1">dispatcher.useImperativeHandle(ref, create, deps);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">useDebugValue(value, formatterFn) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">dispatcher = resolveDispatcher();</span>
      <span class="s3">return </span><span class="s1">dispatcher.useDebugValue(value, formatterFn);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Copyright (c) 2013-present, Facebook, Inc. 
   * 
   * This source code is licensed under the MIT license found in the 
   * LICENSE file in the root directory of this source tree. 
   */</span>

  <span class="s3">var </span><span class="s1">ReactPropTypesSecret = </span><span class="s2">'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED'</span><span class="s1">;</span>

  <span class="s3">var </span><span class="s1">ReactPropTypesSecret_1 = ReactPropTypesSecret;</span>

  <span class="s3">var </span><span class="s1">printWarning$1 = </span><span class="s3">function</span><span class="s1">() {};</span>

  <span class="s1">{</span>
    <span class="s3">var </span><span class="s1">ReactPropTypesSecret$1 = ReactPropTypesSecret_1;</span>
    <span class="s3">var </span><span class="s1">loggedTypeFailures = {};</span>
    <span class="s3">var </span><span class="s1">has = Function.call.bind(Object.prototype.hasOwnProperty);</span>

    <span class="s1">printWarning$1 = </span><span class="s3">function</span><span class="s1">(text) {</span>
      <span class="s3">var </span><span class="s1">message = </span><span class="s2">'Warning: ' </span><span class="s1">+ text;</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">console !== </span><span class="s2">'undefined'</span><span class="s1">) {</span>
        <span class="s1">console.error(message);</span>
      <span class="s1">}</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s0">// --- Welcome to debugging React ---</span>
        <span class="s0">// This error was thrown as a convenience so that you can use this stack</span>
        <span class="s0">// to find the callsite that caused this warning to fire.</span>
        <span class="s3">throw new </span><span class="s1">Error(message);</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(x) {}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Assert that the values match with the type specs. 
   * Error messages are memorized and will only be shown once. 
   * 
   * @param {object} typeSpecs Map of name to a ReactPropType 
   * @param {object} values Runtime values that need to be type-checked 
   * @param {string} location e.g. &quot;prop&quot;, &quot;context&quot;, &quot;child context&quot; 
   * @param {string} componentName Name of the component for error messages. 
   * @param {?Function} getStack Returns the component stack. 
   * @private 
   */</span>
  <span class="s3">function </span><span class="s1">checkPropTypes(typeSpecs, values, location, componentName, getStack) {</span>
    <span class="s1">{</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">typeSpecName </span><span class="s3">in </span><span class="s1">typeSpecs) {</span>
        <span class="s3">if </span><span class="s1">(has(typeSpecs, typeSpecName)) {</span>
          <span class="s3">var </span><span class="s1">error;</span>
          <span class="s0">// Prop type validation may throw. In case they do, we don't want to</span>
          <span class="s0">// fail the render phase where it didn't fail before. So we log it.</span>
          <span class="s0">// After these have been cleaned up, we'll let them throw.</span>
          <span class="s3">try </span><span class="s1">{</span>
            <span class="s0">// This is intentionally an invariant that gets caught. It's the same</span>
            <span class="s0">// behavior as without this statement except with a better message.</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">typeSpecs[typeSpecName] !== </span><span class="s2">'function'</span><span class="s1">) {</span>
              <span class="s3">var </span><span class="s1">err = Error(</span>
                <span class="s1">(componentName || </span><span class="s2">'React class'</span><span class="s1">) + </span><span class="s2">': ' </span><span class="s1">+ location + </span><span class="s2">' type `' </span><span class="s1">+ typeSpecName + </span><span class="s2">'` is invalid; ' </span><span class="s1">+</span>
                <span class="s2">'it must be a function, usually from the `prop-types` package, but received `' </span><span class="s1">+ </span><span class="s3">typeof </span><span class="s1">typeSpecs[typeSpecName] + </span><span class="s2">'`.'</span>
              <span class="s1">);</span>
              <span class="s1">err.name = </span><span class="s2">'Invariant Violation'</span><span class="s1">;</span>
              <span class="s3">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
            <span class="s1">error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, </span><span class="s3">null</span><span class="s1">, ReactPropTypesSecret$1);</span>
          <span class="s1">} </span><span class="s3">catch </span><span class="s1">(ex) {</span>
            <span class="s1">error = ex;</span>
          <span class="s1">}</span>
          <span class="s3">if </span><span class="s1">(error &amp;&amp; !(error </span><span class="s3">instanceof </span><span class="s1">Error)) {</span>
            <span class="s1">printWarning$1(</span>
              <span class="s1">(componentName || </span><span class="s2">'React class'</span><span class="s1">) + </span><span class="s2">': type specification of ' </span><span class="s1">+</span>
              <span class="s1">location + </span><span class="s2">' `' </span><span class="s1">+ typeSpecName + </span><span class="s2">'` is invalid; the type checker ' </span><span class="s1">+</span>
              <span class="s2">'function must return `null` or an `Error` but returned a ' </span><span class="s1">+ </span><span class="s3">typeof </span><span class="s1">error + </span><span class="s2">'. ' </span><span class="s1">+</span>
              <span class="s2">'You may have forgotten to pass an argument to the type checker ' </span><span class="s1">+</span>
              <span class="s2">'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' </span><span class="s1">+</span>
              <span class="s2">'shape all require an argument).'</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s3">if </span><span class="s1">(error </span><span class="s3">instanceof </span><span class="s1">Error &amp;&amp; !(error.message </span><span class="s3">in </span><span class="s1">loggedTypeFailures)) {</span>
            <span class="s0">// Only monitor this failure once because there tends to be a lot of the</span>
            <span class="s0">// same error.</span>
            <span class="s1">loggedTypeFailures[error.message] = </span><span class="s3">true</span><span class="s1">;</span>

            <span class="s3">var </span><span class="s1">stack = getStack ? getStack() : </span><span class="s2">''</span><span class="s1">;</span>

            <span class="s1">printWarning$1(</span>
              <span class="s2">'Failed ' </span><span class="s1">+ location + </span><span class="s2">' type: ' </span><span class="s1">+ error.message + (stack != </span><span class="s3">null </span><span class="s1">? stack : </span><span class="s2">''</span><span class="s1">)</span>
            <span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Resets warning cache when testing. 
   * 
   * @private 
   */</span>
  <span class="s1">checkPropTypes.resetWarningCache = </span><span class="s3">function</span><span class="s1">() {</span>
    <span class="s1">{</span>
      <span class="s1">loggedTypeFailures = {};</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s3">var </span><span class="s1">checkPropTypes_1 = checkPropTypes;</span>

  <span class="s3">var </span><span class="s1">propTypesMisspellWarningShown;</span>

  <span class="s1">{</span>
    <span class="s1">propTypesMisspellWarningShown = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getDeclarationErrorAddendum() {</span>
    <span class="s3">if </span><span class="s1">(ReactCurrentOwner.current) {</span>
      <span class="s3">var </span><span class="s1">name = getComponentName(ReactCurrentOwner.current.type);</span>

      <span class="s3">if </span><span class="s1">(name) {</span>
        <span class="s3">return </span><span class="s2">'</span><span class="s5">\n\n</span><span class="s2">Check the render method of `' </span><span class="s1">+ name + </span><span class="s2">'`.'</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s2">''</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getSourceInfoErrorAddendum(source) {</span>
    <span class="s3">if </span><span class="s1">(source !== undefined) {</span>
      <span class="s3">var </span><span class="s1">fileName = source.fileName.replace(/^.*[\\\/]/, </span><span class="s2">''</span><span class="s1">);</span>
      <span class="s3">var </span><span class="s1">lineNumber = source.lineNumber;</span>
      <span class="s3">return </span><span class="s2">'</span><span class="s5">\n\n</span><span class="s2">Check your code at ' </span><span class="s1">+ fileName + </span><span class="s2">':' </span><span class="s1">+ lineNumber + </span><span class="s2">'.'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s2">''</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getSourceInfoErrorAddendumForProps(elementProps) {</span>
    <span class="s3">if </span><span class="s1">(elementProps !== </span><span class="s3">null </span><span class="s1">&amp;&amp; elementProps !== undefined) {</span>
      <span class="s3">return </span><span class="s1">getSourceInfoErrorAddendum(elementProps.__source);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s2">''</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Warn if there's no key explicitly set on dynamic arrays of children or 
   * object keys are not valid. This allows us to keep track of children between 
   * updates. 
   */</span>


  <span class="s3">var </span><span class="s1">ownerHasKeyUseWarning = {};</span>

  <span class="s3">function </span><span class="s1">getCurrentComponentErrorInfo(parentType) {</span>
    <span class="s3">var </span><span class="s1">info = getDeclarationErrorAddendum();</span>

    <span class="s3">if </span><span class="s1">(!info) {</span>
      <span class="s3">var </span><span class="s1">parentName = </span><span class="s3">typeof </span><span class="s1">parentType === </span><span class="s2">'string' </span><span class="s1">? parentType : parentType.displayName || parentType.name;</span>

      <span class="s3">if </span><span class="s1">(parentName) {</span>
        <span class="s1">info = </span><span class="s2">&quot;</span><span class="s5">\n\n</span><span class="s2">Check the top-level render call using &lt;&quot; </span><span class="s1">+ parentName + </span><span class="s2">&quot;&gt;.&quot;</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">info;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Warn if the element doesn't have an explicit key assigned to it. 
   * This element is in an array. The array could grow and shrink or be 
   * reordered. All children that haven't already been validated are required to 
   * have a &quot;key&quot; property assigned to it. Error statuses are cached so a warning 
   * will only be shown once. 
   * 
   * @internal 
   * @param {ReactElement} element Element that requires a key. 
   * @param {*} parentType element's parent's type. 
   */</span>


  <span class="s3">function </span><span class="s1">validateExplicitKey(element, parentType) {</span>
    <span class="s3">if </span><span class="s1">(!element._store || element._store.validated || element.key != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">element._store.validated = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);</span>

    <span class="s3">if </span><span class="s1">(ownerHasKeyUseWarning[currentComponentErrorInfo]) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">ownerHasKeyUseWarning[currentComponentErrorInfo] = </span><span class="s3">true</span><span class="s1">; </span><span class="s0">// Usually the current owner is the offender, but if it accepts children as a</span>
    <span class="s0">// property, it may be the creator of the child that's responsible for</span>
    <span class="s0">// assigning it a key.</span>

    <span class="s3">var </span><span class="s1">childOwner = </span><span class="s2">''</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(element &amp;&amp; element._owner &amp;&amp; element._owner !== ReactCurrentOwner.current) {</span>
      <span class="s0">// Give the component that originally created this child.</span>
      <span class="s1">childOwner = </span><span class="s2">&quot; It was passed a child from &quot; </span><span class="s1">+ getComponentName(element._owner.type) + </span><span class="s2">&quot;.&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">setCurrentlyValidatingElement(element);</span>

    <span class="s1">{</span>
      <span class="s1">error(</span><span class="s2">'Each child in a list should have a unique &quot;key&quot; prop.' </span><span class="s1">+ </span><span class="s2">'%s%s See https://fb.me/react-warning-keys for more information.'</span><span class="s1">, currentComponentErrorInfo, childOwner);</span>
    <span class="s1">}</span>

    <span class="s1">setCurrentlyValidatingElement(</span><span class="s3">null</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Ensure that every element either is passed in a static location, in an 
   * array with an explicit keys property defined, or in an object literal 
   * with valid key property. 
   * 
   * @internal 
   * @param {ReactNode} node Statically passed child of any type. 
   * @param {*} parentType node's parent's type. 
   */</span>


  <span class="s3">function </span><span class="s1">validateChildKeys(node, parentType) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">node !== </span><span class="s2">'object'</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(Array.isArray(node)) {</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; node.length; i++) {</span>
        <span class="s3">var </span><span class="s1">child = node[i];</span>

        <span class="s3">if </span><span class="s1">(isValidElement(child)) {</span>
          <span class="s1">validateExplicitKey(child, parentType);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(isValidElement(node)) {</span>
      <span class="s0">// This element was passed in a valid location.</span>
      <span class="s3">if </span><span class="s1">(node._store) {</span>
        <span class="s1">node._store.validated = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node) {</span>
      <span class="s3">var </span><span class="s1">iteratorFn = getIteratorFn(node);</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">iteratorFn === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s0">// Entry iterators used to provide implicit keys,</span>
        <span class="s0">// but now we print a separate warning for them later.</span>
        <span class="s3">if </span><span class="s1">(iteratorFn !== node.entries) {</span>
          <span class="s3">var </span><span class="s1">iterator = iteratorFn.call(node);</span>
          <span class="s3">var </span><span class="s1">step;</span>

          <span class="s3">while </span><span class="s1">(!(step = iterator.next()).done) {</span>
            <span class="s3">if </span><span class="s1">(isValidElement(step.value)) {</span>
              <span class="s1">validateExplicitKey(step.value, parentType);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Given an element, validate that its props follow the propTypes definition, 
   * provided by the type. 
   * 
   * @param {ReactElement} element 
   */</span>


  <span class="s3">function </span><span class="s1">validatePropTypes(element) {</span>
    <span class="s1">{</span>
      <span class="s3">var </span><span class="s1">type = element.type;</span>

      <span class="s3">if </span><span class="s1">(type === </span><span class="s3">null </span><span class="s1">|| type === undefined || </span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'string'</span><span class="s1">) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">name = getComponentName(type);</span>
      <span class="s3">var </span><span class="s1">propTypes;</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s1">propTypes = type.propTypes;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; (type.$$typeof === REACT_FORWARD_REF_TYPE || </span><span class="s0">// Note: Memo only checks outer props here.</span>
      <span class="s0">// Inner props are checked in the reconciler.</span>
      <span class="s1">type.$$typeof === REACT_MEMO_TYPE)) {</span>
        <span class="s1">propTypes = type.propTypes;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(propTypes) {</span>
        <span class="s1">setCurrentlyValidatingElement(element);</span>
        <span class="s1">checkPropTypes_1(propTypes, element.props, </span><span class="s2">'prop'</span><span class="s1">, name, ReactDebugCurrentFrame.getStackAddendum);</span>
        <span class="s1">setCurrentlyValidatingElement(</span><span class="s3">null</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(type.PropTypes !== undefined &amp;&amp; !propTypesMisspellWarningShown) {</span>
        <span class="s1">propTypesMisspellWarningShown = </span><span class="s3">true</span><span class="s1">;</span>

        <span class="s1">error(</span><span class="s2">'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?'</span><span class="s1">, name || </span><span class="s2">'Unknown'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">type.getDefaultProps === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; !type.getDefaultProps.isReactClassApproved) {</span>
        <span class="s1">error(</span><span class="s2">'getDefaultProps is only used on classic React.createClass ' </span><span class="s1">+ </span><span class="s2">'definitions. Use a static property named `defaultProps` instead.'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * Given a fragment, validate that it can only be provided with fragment props 
   * @param {ReactElement} fragment 
   */</span>


  <span class="s3">function </span><span class="s1">validateFragmentProps(fragment) {</span>
    <span class="s1">{</span>
      <span class="s1">setCurrentlyValidatingElement(fragment);</span>
      <span class="s3">var </span><span class="s1">keys = Object.keys(fragment.props);</span>

      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; keys.length; i++) {</span>
        <span class="s3">var </span><span class="s1">key = keys[i];</span>

        <span class="s3">if </span><span class="s1">(key !== </span><span class="s2">'children' </span><span class="s1">&amp;&amp; key !== </span><span class="s2">'key'</span><span class="s1">) {</span>
          <span class="s1">error(</span><span class="s2">'Invalid prop `%s` supplied to `React.Fragment`. ' </span><span class="s1">+ </span><span class="s2">'React.Fragment can only have `key` and `children` props.'</span><span class="s1">, key);</span>

          <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(fragment.ref !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">error(</span><span class="s2">'Invalid attribute `ref` supplied to `React.Fragment`.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">setCurrentlyValidatingElement(</span><span class="s3">null</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">createElementWithValidation(type, props, children) {</span>
    <span class="s3">var </span><span class="s1">validType = isValidElementType(type); </span><span class="s0">// We warn in this case but don't throw. We expect the element creation to</span>
    <span class="s0">// succeed and there will likely be errors in render.</span>

    <span class="s3">if </span><span class="s1">(!validType) {</span>
      <span class="s3">var </span><span class="s1">info = </span><span class="s2">''</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(type === undefined || </span><span class="s3">typeof </span><span class="s1">type === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; type !== </span><span class="s3">null </span><span class="s1">&amp;&amp; Object.keys(type).length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">info += </span><span class="s2">' You likely forgot to export your component from the file ' </span><span class="s1">+ </span><span class="s2">&quot;it's defined in, or you might have mixed up default and named imports.&quot;</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">sourceInfo = getSourceInfoErrorAddendumForProps(props);</span>

      <span class="s3">if </span><span class="s1">(sourceInfo) {</span>
        <span class="s1">info += sourceInfo;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">info += getDeclarationErrorAddendum();</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">typeString;</span>

      <span class="s3">if </span><span class="s1">(type === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">typeString = </span><span class="s2">'null'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(Array.isArray(type)) {</span>
        <span class="s1">typeString = </span><span class="s2">'array'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(type !== undefined &amp;&amp; type.$$typeof === REACT_ELEMENT_TYPE) {</span>
        <span class="s1">typeString = </span><span class="s2">&quot;&lt;&quot; </span><span class="s1">+ (getComponentName(type.type) || </span><span class="s2">'Unknown'</span><span class="s1">) + </span><span class="s2">&quot; /&gt;&quot;</span><span class="s1">;</span>
        <span class="s1">info = </span><span class="s2">' Did you accidentally export a JSX literal instead of a component?'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">typeString = </span><span class="s3">typeof </span><span class="s1">type;</span>
      <span class="s1">}</span>

      <span class="s1">{</span>
        <span class="s1">error(</span><span class="s2">'React.createElement: type is invalid -- expected a string (for ' </span><span class="s1">+ </span><span class="s2">'built-in components) or a class/function (for composite ' </span><span class="s1">+ </span><span class="s2">'components) but got: %s.%s'</span><span class="s1">, typeString, info);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">element = createElement.apply(</span><span class="s3">this</span><span class="s1">, arguments); </span><span class="s0">// The result can be nullish if a mock or a custom function is used.</span>
    <span class="s0">// TODO: Drop this when these are no longer allowed as the type argument.</span>

    <span class="s3">if </span><span class="s1">(element == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s1">element;</span>
    <span class="s1">} </span><span class="s0">// Skip key warning if the type isn't valid since our key validation logic</span>
    <span class="s0">// doesn't expect a non-string/function type and can throw confusing errors.</span>
    <span class="s0">// We don't want exception behavior to differ between dev and prod.</span>
    <span class="s0">// (Rendering will throw with a helpful message and as soon as the type is</span>
    <span class="s0">// fixed, the key warnings will appear.)</span>


    <span class="s3">if </span><span class="s1">(validType) {</span>
      <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">2</span><span class="s1">; i &lt; arguments.length; i++) {</span>
        <span class="s1">validateChildKeys(arguments[i], type);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(type === REACT_FRAGMENT_TYPE) {</span>
      <span class="s1">validateFragmentProps(element);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">validatePropTypes(element);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">element;</span>
  <span class="s1">}</span>
  <span class="s3">var </span><span class="s1">didWarnAboutDeprecatedCreateFactory = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">function </span><span class="s1">createFactoryWithValidation(type) {</span>
    <span class="s3">var </span><span class="s1">validatedFactory = createElementWithValidation.bind(</span><span class="s3">null</span><span class="s1">, type);</span>
    <span class="s1">validatedFactory.type = type;</span>

    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(!didWarnAboutDeprecatedCreateFactory) {</span>
        <span class="s1">didWarnAboutDeprecatedCreateFactory = </span><span class="s3">true</span><span class="s1">;</span>

        <span class="s1">warn(</span><span class="s2">'React.createFactory() is deprecated and will be removed in ' </span><span class="s1">+ </span><span class="s2">'a future major release. Consider using JSX ' </span><span class="s1">+ </span><span class="s2">'or use React.createElement() directly instead.'</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s0">// Legacy hook: remove it</span>


      <span class="s1">Object.defineProperty(validatedFactory, </span><span class="s2">'type'</span><span class="s1">, {</span>
        <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">get: </span><span class="s3">function </span><span class="s1">() {</span>
          <span class="s1">warn(</span><span class="s2">'Factory.type is deprecated. Access the class directly ' </span><span class="s1">+ </span><span class="s2">'before passing it to createFactory.'</span><span class="s1">);</span>

          <span class="s1">Object.defineProperty(</span><span class="s3">this</span><span class="s1">, </span><span class="s2">'type'</span><span class="s1">, {</span>
            <span class="s1">value: type</span>
          <span class="s1">});</span>
          <span class="s3">return </span><span class="s1">type;</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">validatedFactory;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">cloneElementWithValidation(element, props, children) {</span>
    <span class="s3">var </span><span class="s1">newElement = cloneElement.apply(</span><span class="s3">this</span><span class="s1">, arguments);</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">2</span><span class="s1">; i &lt; arguments.length; i++) {</span>
      <span class="s1">validateChildKeys(arguments[i], newElement.type);</span>
    <span class="s1">}</span>

    <span class="s1">validatePropTypes(newElement);</span>
    <span class="s3">return </span><span class="s1">newElement;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">enableSchedulerDebugging = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">enableProfiling = </span><span class="s3">true</span><span class="s1">;</span>

  <span class="s3">var </span><span class="s1">requestHostCallback;</span>
  <span class="s3">var </span><span class="s1">requestHostTimeout;</span>
  <span class="s3">var </span><span class="s1">cancelHostTimeout;</span>
  <span class="s3">var </span><span class="s1">shouldYieldToHost;</span>
  <span class="s3">var </span><span class="s1">requestPaint;</span>
  <span class="s3">var </span><span class="s1">getCurrentTime;</span>
  <span class="s3">var </span><span class="s1">forceFrameRate;</span>

  <span class="s3">if </span><span class="s1">( </span><span class="s0">// If Scheduler runs in a non-DOM environment, it falls back to a naive</span>
  <span class="s0">// implementation using setTimeout.</span>
  <span class="s3">typeof </span><span class="s1">window === </span><span class="s2">'undefined' </span><span class="s1">|| </span><span class="s0">// Check if MessageChannel is supported, too.</span>
  <span class="s3">typeof </span><span class="s1">MessageChannel !== </span><span class="s2">'function'</span><span class="s1">) {</span>
    <span class="s0">// If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,</span>
    <span class="s0">// fallback to a naive implementation.</span>
    <span class="s3">var </span><span class="s1">_callback = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">_timeoutID = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">var </span><span class="s1">_flushCallback = </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">if </span><span class="s1">(_callback !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">var </span><span class="s1">currentTime = getCurrentTime();</span>
          <span class="s3">var </span><span class="s1">hasRemainingTime = </span><span class="s3">true</span><span class="s1">;</span>

          <span class="s1">_callback(hasRemainingTime, currentTime);</span>

          <span class="s1">_callback = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
          <span class="s1">setTimeout(_flushCallback, </span><span class="s4">0</span><span class="s1">);</span>
          <span class="s3">throw </span><span class="s1">e;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">initialTime = Date.now();</span>

    <span class="s1">getCurrentTime = </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">return </span><span class="s1">Date.now() - initialTime;</span>
    <span class="s1">};</span>

    <span class="s1">requestHostCallback = </span><span class="s3">function </span><span class="s1">(cb) {</span>
      <span class="s3">if </span><span class="s1">(_callback !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// Protect against re-entrancy.</span>
        <span class="s1">setTimeout(requestHostCallback, </span><span class="s4">0</span><span class="s1">, cb);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">_callback = cb;</span>
        <span class="s1">setTimeout(_flushCallback, </span><span class="s4">0</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">requestHostTimeout = </span><span class="s3">function </span><span class="s1">(cb, ms) {</span>
      <span class="s1">_timeoutID = setTimeout(cb, ms);</span>
    <span class="s1">};</span>

    <span class="s1">cancelHostTimeout = </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s1">clearTimeout(_timeoutID);</span>
    <span class="s1">};</span>

    <span class="s1">shouldYieldToHost = </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">};</span>

    <span class="s1">requestPaint = forceFrameRate = </span><span class="s3">function </span><span class="s1">() {};</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// Capture local references to native APIs, in case a polyfill overrides them.</span>
    <span class="s3">var </span><span class="s1">performance = window.performance;</span>
    <span class="s3">var </span><span class="s1">_Date = window.Date;</span>
    <span class="s3">var </span><span class="s1">_setTimeout = window.setTimeout;</span>
    <span class="s3">var </span><span class="s1">_clearTimeout = window.clearTimeout;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">console !== </span><span class="s2">'undefined'</span><span class="s1">) {</span>
      <span class="s0">// TODO: Scheduler no longer requires these methods to be polyfilled. But</span>
      <span class="s0">// maybe we want to continue warning if they don't exist, to preserve the</span>
      <span class="s0">// option to rely on it in the future?</span>
      <span class="s3">var </span><span class="s1">requestAnimationFrame = window.requestAnimationFrame;</span>
      <span class="s3">var </span><span class="s1">cancelAnimationFrame = window.cancelAnimationFrame; </span><span class="s0">// TODO: Remove fb.me link</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">requestAnimationFrame !== </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s0">// Using console['error'] to evade Babel and ESLint</span>
        <span class="s1">console[</span><span class="s2">'error'</span><span class="s1">](</span><span class="s2">&quot;This browser doesn't support requestAnimationFrame. &quot; </span><span class="s1">+ </span><span class="s2">'Make sure that you load a ' </span><span class="s1">+ </span><span class="s2">'polyfill in older browsers. https://fb.me/react-polyfills'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">cancelAnimationFrame !== </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s0">// Using console['error'] to evade Babel and ESLint</span>
        <span class="s1">console[</span><span class="s2">'error'</span><span class="s1">](</span><span class="s2">&quot;This browser doesn't support cancelAnimationFrame. &quot; </span><span class="s1">+ </span><span class="s2">'Make sure that you load a ' </span><span class="s1">+ </span><span class="s2">'polyfill in older browsers. https://fb.me/react-polyfills'</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">performance === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">performance.now === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">getCurrentTime = </span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">performance.now();</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">_initialTime = _Date.now();</span>

      <span class="s1">getCurrentTime = </span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">_Date.now() - _initialTime;</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">isMessageLoopRunning = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">scheduledHostCallback = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">taskTimeoutID = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Scheduler periodically yields in case there is other work on the main</span>
    <span class="s0">// thread, like user events. By default, it yields multiple times per frame.</span>
    <span class="s0">// It does not attempt to align with frame boundaries, since most tasks don't</span>
    <span class="s0">// need to be frame aligned; for those that do, use requestAnimationFrame.</span>

    <span class="s3">var </span><span class="s1">yieldInterval = </span><span class="s4">5</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">deadline = </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// TODO: Make this configurable</span>

    <span class="s1">{</span>
      <span class="s0">// `isInputPending` is not available. Since we have no way of knowing if</span>
      <span class="s0">// there's pending input, always yield at the end of the frame.</span>
      <span class="s1">shouldYieldToHost = </span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">getCurrentTime() &gt;= deadline;</span>
      <span class="s1">}; </span><span class="s0">// Since we yield every frame regardless, `requestPaint` has no effect.</span>


      <span class="s1">requestPaint = </span><span class="s3">function </span><span class="s1">() {};</span>
    <span class="s1">}</span>

    <span class="s1">forceFrameRate = </span><span class="s3">function </span><span class="s1">(fps) {</span>
      <span class="s3">if </span><span class="s1">(fps &lt; </span><span class="s4">0 </span><span class="s1">|| fps &gt; </span><span class="s4">125</span><span class="s1">) {</span>
        <span class="s0">// Using console['error'] to evade Babel and ESLint</span>
        <span class="s1">console[</span><span class="s2">'error'</span><span class="s1">](</span><span class="s2">'forceFrameRate takes a positive int between 0 and 125, ' </span><span class="s1">+ </span><span class="s2">'forcing framerates higher than 125 fps is not unsupported'</span><span class="s1">);</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(fps &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">yieldInterval = Math.floor(</span><span class="s4">1000 </span><span class="s1">/ fps);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// reset the framerate</span>
        <span class="s1">yieldInterval = </span><span class="s4">5</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">performWorkUntilDeadline = </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s3">if </span><span class="s1">(scheduledHostCallback !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">var </span><span class="s1">currentTime = getCurrentTime(); </span><span class="s0">// Yield after `yieldInterval` ms, regardless of where we are in the vsync</span>
        <span class="s0">// cycle. This means there's always time remaining at the beginning of</span>
        <span class="s0">// the message event.</span>

        <span class="s1">deadline = currentTime + yieldInterval;</span>
        <span class="s3">var </span><span class="s1">hasTimeRemaining = </span><span class="s3">true</span><span class="s1">;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">var </span><span class="s1">hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);</span>

          <span class="s3">if </span><span class="s1">(!hasMoreWork) {</span>
            <span class="s1">isMessageLoopRunning = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">scheduledHostCallback = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s0">// If there's more work, schedule the next message event at the end</span>
            <span class="s0">// of the preceding one.</span>
            <span class="s1">port.postMessage(</span><span class="s3">null</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
          <span class="s0">// If a scheduler task throws, exit the current browser task so the</span>
          <span class="s0">// error can be observed.</span>
          <span class="s1">port.postMessage(</span><span class="s3">null</span><span class="s1">);</span>
          <span class="s3">throw </span><span class="s1">error;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">isMessageLoopRunning = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Yielding to the browser will give it a chance to paint, so we can</span>
    <span class="s1">};</span>

    <span class="s3">var </span><span class="s1">channel = </span><span class="s3">new </span><span class="s1">MessageChannel();</span>
    <span class="s3">var </span><span class="s1">port = channel.port2;</span>
    <span class="s1">channel.port1.onmessage = performWorkUntilDeadline;</span>

    <span class="s1">requestHostCallback = </span><span class="s3">function </span><span class="s1">(callback) {</span>
      <span class="s1">scheduledHostCallback = callback;</span>

      <span class="s3">if </span><span class="s1">(!isMessageLoopRunning) {</span>
        <span class="s1">isMessageLoopRunning = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">port.postMessage(</span><span class="s3">null</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s1">requestHostTimeout = </span><span class="s3">function </span><span class="s1">(callback, ms) {</span>
      <span class="s1">taskTimeoutID = _setTimeout(</span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s1">callback(getCurrentTime());</span>
      <span class="s1">}, ms);</span>
    <span class="s1">};</span>

    <span class="s1">cancelHostTimeout = </span><span class="s3">function </span><span class="s1">() {</span>
      <span class="s1">_clearTimeout(taskTimeoutID);</span>

      <span class="s1">taskTimeoutID = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">push(heap, node) {</span>
    <span class="s3">var </span><span class="s1">index = heap.length;</span>
    <span class="s1">heap.push(node);</span>
    <span class="s1">siftUp(heap, node, index);</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">peek(heap) {</span>
    <span class="s3">var </span><span class="s1">first = heap[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s3">return </span><span class="s1">first === undefined ? </span><span class="s3">null </span><span class="s1">: first;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">pop(heap) {</span>
    <span class="s3">var </span><span class="s1">first = heap[</span><span class="s4">0</span><span class="s1">];</span>

    <span class="s3">if </span><span class="s1">(first !== undefined) {</span>
      <span class="s3">var </span><span class="s1">last = heap.pop();</span>

      <span class="s3">if </span><span class="s1">(last !== first) {</span>
        <span class="s1">heap[</span><span class="s4">0</span><span class="s1">] = last;</span>
        <span class="s1">siftDown(heap, last, </span><span class="s4">0</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">return </span><span class="s1">first;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">siftUp(heap, node, i) {</span>
    <span class="s3">var </span><span class="s1">index = i;</span>

    <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">parentIndex = index - </span><span class="s4">1 </span><span class="s1">&gt;&gt;&gt; </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">parent = heap[parentIndex];</span>

      <span class="s3">if </span><span class="s1">(parent !== undefined &amp;&amp; compare(parent, node) &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">// The parent is larger. Swap positions.</span>
        <span class="s1">heap[parentIndex] = node;</span>
        <span class="s1">heap[index] = parent;</span>
        <span class="s1">index = parentIndex;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// The parent is smaller. Exit.</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">siftDown(heap, node, i) {</span>
    <span class="s3">var </span><span class="s1">index = i;</span>
    <span class="s3">var </span><span class="s1">length = heap.length;</span>

    <span class="s3">while </span><span class="s1">(index &lt; length) {</span>
      <span class="s3">var </span><span class="s1">leftIndex = (index + </span><span class="s4">1</span><span class="s1">) * </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">left = heap[leftIndex];</span>
      <span class="s3">var </span><span class="s1">rightIndex = leftIndex + </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s3">var </span><span class="s1">right = heap[rightIndex]; </span><span class="s0">// If the left or right node is smaller, swap with the smaller of those.</span>

      <span class="s3">if </span><span class="s1">(left !== undefined &amp;&amp; compare(left, node) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(right !== undefined &amp;&amp; compare(right, left) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">heap[index] = right;</span>
          <span class="s1">heap[rightIndex] = node;</span>
          <span class="s1">index = rightIndex;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">heap[index] = left;</span>
          <span class="s1">heap[leftIndex] = node;</span>
          <span class="s1">index = leftIndex;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(right !== undefined &amp;&amp; compare(right, node) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">heap[index] = right;</span>
        <span class="s1">heap[rightIndex] = node;</span>
        <span class="s1">index = rightIndex;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Neither child is smaller. Exit.</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">compare(a, b) {</span>
    <span class="s0">// Compare sort index first, then task id.</span>
    <span class="s3">var </span><span class="s1">diff = a.sortIndex - b.sortIndex;</span>
    <span class="s3">return </span><span class="s1">diff !== </span><span class="s4">0 </span><span class="s1">? diff : a.id - b.id;</span>
  <span class="s1">}</span>

  <span class="s0">// TODO: Use symbols?</span>
  <span class="s3">var </span><span class="s1">NoPriority = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">ImmediatePriority = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">UserBlockingPriority = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">NormalPriority = </span><span class="s4">3</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">LowPriority = </span><span class="s4">4</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">IdlePriority = </span><span class="s4">5</span><span class="s1">;</span>

  <span class="s3">var </span><span class="s1">runIdCounter = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">mainThreadIdCounter = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">profilingStateSize = </span><span class="s4">4</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">sharedProfilingBuffer =  </span><span class="s0">// $FlowFixMe Flow doesn't know about SharedArrayBuffer</span>
  <span class="s3">typeof </span><span class="s1">SharedArrayBuffer === </span><span class="s2">'function' </span><span class="s1">? </span><span class="s3">new </span><span class="s1">SharedArrayBuffer(profilingStateSize * Int32Array.BYTES_PER_ELEMENT) : </span><span class="s0">// $FlowFixMe Flow doesn't know about ArrayBuffer</span>
  <span class="s3">typeof </span><span class="s1">ArrayBuffer === </span><span class="s2">'function' </span><span class="s1">? </span><span class="s3">new </span><span class="s1">ArrayBuffer(profilingStateSize * Int32Array.BYTES_PER_ELEMENT) : </span><span class="s3">null </span><span class="s0">// Don't crash the init path on IE9</span>
  <span class="s1">;</span>
  <span class="s3">var </span><span class="s1">profilingState =  sharedProfilingBuffer !== </span><span class="s3">null </span><span class="s1">? </span><span class="s3">new </span><span class="s1">Int32Array(sharedProfilingBuffer) : []; </span><span class="s0">// We can't read this but it helps save bytes for null checks</span>

  <span class="s3">var </span><span class="s1">PRIORITY = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">CURRENT_TASK_ID = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">CURRENT_RUN_ID = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">QUEUE_SIZE = </span><span class="s4">3</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s1">profilingState[PRIORITY] = NoPriority; </span><span class="s0">// This is maintained with a counter, because the size of the priority queue</span>
    <span class="s0">// array might include canceled tasks.</span>

    <span class="s1">profilingState[QUEUE_SIZE] = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">profilingState[CURRENT_TASK_ID] = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s0">// Bytes per element is 4</span>


  <span class="s3">var </span><span class="s1">INITIAL_EVENT_LOG_SIZE = </span><span class="s4">131072</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">MAX_EVENT_LOG_SIZE = </span><span class="s4">524288</span><span class="s1">; </span><span class="s0">// Equivalent to 2 megabytes</span>

  <span class="s3">var </span><span class="s1">eventLogSize = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">eventLogBuffer = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">eventLog = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">eventLogIndex = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">TaskStartEvent = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">TaskCompleteEvent = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">TaskErrorEvent = </span><span class="s4">3</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">TaskCancelEvent = </span><span class="s4">4</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">TaskRunEvent = </span><span class="s4">5</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">TaskYieldEvent = </span><span class="s4">6</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">SchedulerSuspendEvent = </span><span class="s4">7</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">SchedulerResumeEvent = </span><span class="s4">8</span><span class="s1">;</span>

  <span class="s3">function </span><span class="s1">logEvent(entries) {</span>
    <span class="s3">if </span><span class="s1">(eventLog !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">offset = eventLogIndex;</span>
      <span class="s1">eventLogIndex += entries.length;</span>

      <span class="s3">if </span><span class="s1">(eventLogIndex + </span><span class="s4">1 </span><span class="s1">&gt; eventLogSize) {</span>
        <span class="s1">eventLogSize *= </span><span class="s4">2</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(eventLogSize &gt; MAX_EVENT_LOG_SIZE) {</span>
          <span class="s0">// Using console['error'] to evade Babel and ESLint</span>
          <span class="s1">console[</span><span class="s2">'error'</span><span class="s1">](</span><span class="s2">&quot;Scheduler Profiling: Event log exceeded maximum size. Don't &quot; </span><span class="s1">+ </span><span class="s2">'forget to call `stopLoggingProfilingEvents()`.'</span><span class="s1">);</span>
          <span class="s1">stopLoggingProfilingEvents();</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">newEventLog = </span><span class="s3">new </span><span class="s1">Int32Array(eventLogSize * </span><span class="s4">4</span><span class="s1">);</span>
        <span class="s1">newEventLog.set(eventLog);</span>
        <span class="s1">eventLogBuffer = newEventLog.buffer;</span>
        <span class="s1">eventLog = newEventLog;</span>
      <span class="s1">}</span>

      <span class="s1">eventLog.set(entries, offset);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">startLoggingProfilingEvents() {</span>
    <span class="s1">eventLogSize = INITIAL_EVENT_LOG_SIZE;</span>
    <span class="s1">eventLogBuffer = </span><span class="s3">new </span><span class="s1">ArrayBuffer(eventLogSize * </span><span class="s4">4</span><span class="s1">);</span>
    <span class="s1">eventLog = </span><span class="s3">new </span><span class="s1">Int32Array(eventLogBuffer);</span>
    <span class="s1">eventLogIndex = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">stopLoggingProfilingEvents() {</span>
    <span class="s3">var </span><span class="s1">buffer = eventLogBuffer;</span>
    <span class="s1">eventLogSize = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">eventLogBuffer = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">eventLog = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">eventLogIndex = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">buffer;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">markTaskStart(task, ms) {</span>
    <span class="s1">{</span>
      <span class="s1">profilingState[QUEUE_SIZE]++;</span>

      <span class="s3">if </span><span class="s1">(eventLog !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// performance.now returns a float, representing milliseconds. When the</span>
        <span class="s0">// event is logged, it's coerced to an int. Convert to microseconds to</span>
        <span class="s0">// maintain extra degrees of precision.</span>
        <span class="s1">logEvent([TaskStartEvent, ms * </span><span class="s4">1000</span><span class="s1">, task.id, task.priorityLevel]);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">markTaskCompleted(task, ms) {</span>
    <span class="s1">{</span>
      <span class="s1">profilingState[PRIORITY] = NoPriority;</span>
      <span class="s1">profilingState[CURRENT_TASK_ID] = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">profilingState[QUEUE_SIZE]--;</span>

      <span class="s3">if </span><span class="s1">(eventLog !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">logEvent([TaskCompleteEvent, ms * </span><span class="s4">1000</span><span class="s1">, task.id]);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">markTaskCanceled(task, ms) {</span>
    <span class="s1">{</span>
      <span class="s1">profilingState[QUEUE_SIZE]--;</span>

      <span class="s3">if </span><span class="s1">(eventLog !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">logEvent([TaskCancelEvent, ms * </span><span class="s4">1000</span><span class="s1">, task.id]);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">markTaskErrored(task, ms) {</span>
    <span class="s1">{</span>
      <span class="s1">profilingState[PRIORITY] = NoPriority;</span>
      <span class="s1">profilingState[CURRENT_TASK_ID] = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">profilingState[QUEUE_SIZE]--;</span>

      <span class="s3">if </span><span class="s1">(eventLog !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">logEvent([TaskErrorEvent, ms * </span><span class="s4">1000</span><span class="s1">, task.id]);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">markTaskRun(task, ms) {</span>
    <span class="s1">{</span>
      <span class="s1">runIdCounter++;</span>
      <span class="s1">profilingState[PRIORITY] = task.priorityLevel;</span>
      <span class="s1">profilingState[CURRENT_TASK_ID] = task.id;</span>
      <span class="s1">profilingState[CURRENT_RUN_ID] = runIdCounter;</span>

      <span class="s3">if </span><span class="s1">(eventLog !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">logEvent([TaskRunEvent, ms * </span><span class="s4">1000</span><span class="s1">, task.id, runIdCounter]);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">markTaskYield(task, ms) {</span>
    <span class="s1">{</span>
      <span class="s1">profilingState[PRIORITY] = NoPriority;</span>
      <span class="s1">profilingState[CURRENT_TASK_ID] = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">profilingState[CURRENT_RUN_ID] = </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(eventLog !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">logEvent([TaskYieldEvent, ms * </span><span class="s4">1000</span><span class="s1">, task.id, runIdCounter]);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">markSchedulerSuspended(ms) {</span>
    <span class="s1">{</span>
      <span class="s1">mainThreadIdCounter++;</span>

      <span class="s3">if </span><span class="s1">(eventLog !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">logEvent([SchedulerSuspendEvent, ms * </span><span class="s4">1000</span><span class="s1">, mainThreadIdCounter]);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">markSchedulerUnsuspended(ms) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(eventLog !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">logEvent([SchedulerResumeEvent, ms * </span><span class="s4">1000</span><span class="s1">, mainThreadIdCounter]);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/* eslint-disable no-var */</span>
  <span class="s0">// Math.pow(2, 30) - 1</span>
  <span class="s0">// 0b111111111111111111111111111111</span>

  <span class="s3">var </span><span class="s1">maxSigned31BitInt = </span><span class="s4">1073741823</span><span class="s1">; </span><span class="s0">// Times out immediately</span>

  <span class="s3">var </span><span class="s1">IMMEDIATE_PRIORITY_TIMEOUT = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Eventually times out</span>

  <span class="s3">var </span><span class="s1">USER_BLOCKING_PRIORITY = </span><span class="s4">250</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">NORMAL_PRIORITY_TIMEOUT = </span><span class="s4">5000</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">LOW_PRIORITY_TIMEOUT = </span><span class="s4">10000</span><span class="s1">; </span><span class="s0">// Never times out</span>

  <span class="s3">var </span><span class="s1">IDLE_PRIORITY = maxSigned31BitInt; </span><span class="s0">// Tasks are stored on a min heap</span>

  <span class="s3">var </span><span class="s1">taskQueue = [];</span>
  <span class="s3">var </span><span class="s1">timerQueue = []; </span><span class="s0">// Incrementing id counter. Used to maintain insertion order.</span>

  <span class="s3">var </span><span class="s1">taskIdCounter = </span><span class="s4">1</span><span class="s1">; </span><span class="s0">// Pausing the scheduler is useful for debugging.</span>
  <span class="s3">var </span><span class="s1">currentTask = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">currentPriorityLevel = NormalPriority; </span><span class="s0">// This is set while performing work, to prevent re-entrancy.</span>

  <span class="s3">var </span><span class="s1">isPerformingWork = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">isHostCallbackScheduled = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">isHostTimeoutScheduled = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s3">function </span><span class="s1">advanceTimers(currentTime) {</span>
    <span class="s0">// Check for tasks that are no longer delayed and add them to the queue.</span>
    <span class="s3">var </span><span class="s1">timer = peek(timerQueue);</span>

    <span class="s3">while </span><span class="s1">(timer !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(timer.callback === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s0">// Timer was cancelled.</span>
        <span class="s1">pop(timerQueue);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(timer.startTime &lt;= currentTime) {</span>
        <span class="s0">// Timer fired. Transfer to the task queue.</span>
        <span class="s1">pop(timerQueue);</span>
        <span class="s1">timer.sortIndex = timer.expirationTime;</span>
        <span class="s1">push(taskQueue, timer);</span>

        <span class="s1">{</span>
          <span class="s1">markTaskStart(timer, currentTime);</span>
          <span class="s1">timer.isQueued = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// Remaining timers are pending.</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">timer = peek(timerQueue);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">handleTimeout(currentTime) {</span>
    <span class="s1">isHostTimeoutScheduled = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">advanceTimers(currentTime);</span>

    <span class="s3">if </span><span class="s1">(!isHostCallbackScheduled) {</span>
      <span class="s3">if </span><span class="s1">(peek(taskQueue) !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">isHostCallbackScheduled = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">requestHostCallback(flushWork);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">var </span><span class="s1">firstTimer = peek(timerQueue);</span>

        <span class="s3">if </span><span class="s1">(firstTimer !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">flushWork(hasTimeRemaining, initialTime) {</span>
    <span class="s1">{</span>
      <span class="s1">markSchedulerUnsuspended(initialTime);</span>
    <span class="s1">} </span><span class="s0">// We'll need a host callback the next time work is scheduled.</span>


    <span class="s1">isHostCallbackScheduled = </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(isHostTimeoutScheduled) {</span>
      <span class="s0">// We scheduled a timeout but it's no longer needed. Cancel it.</span>
      <span class="s1">isHostTimeoutScheduled = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">cancelHostTimeout();</span>
    <span class="s1">}</span>

    <span class="s1">isPerformingWork = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">previousPriorityLevel = currentPriorityLevel;</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(enableProfiling) {</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">workLoop(hasTimeRemaining, initialTime);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
          <span class="s3">if </span><span class="s1">(currentTask !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">currentTime = getCurrentTime();</span>
            <span class="s1">markTaskErrored(currentTask, currentTime);</span>
            <span class="s1">currentTask.isQueued = </span><span class="s3">false</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">throw </span><span class="s1">error;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// No catch in prod codepath.</span>
        <span class="s3">return </span><span class="s1">workLoop(hasTimeRemaining, initialTime);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">currentTask = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">currentPriorityLevel = previousPriorityLevel;</span>
      <span class="s1">isPerformingWork = </span><span class="s3">false</span><span class="s1">;</span>

      <span class="s1">{</span>
        <span class="s3">var </span><span class="s1">_currentTime = getCurrentTime();</span>

        <span class="s1">markSchedulerSuspended(_currentTime);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">workLoop(hasTimeRemaining, initialTime) {</span>
    <span class="s3">var </span><span class="s1">currentTime = initialTime;</span>
    <span class="s1">advanceTimers(currentTime);</span>
    <span class="s1">currentTask = peek(taskQueue);</span>

    <span class="s3">while </span><span class="s1">(currentTask !== </span><span class="s3">null </span><span class="s1">&amp;&amp; !(enableSchedulerDebugging )) {</span>
      <span class="s3">if </span><span class="s1">(currentTask.expirationTime &gt; currentTime &amp;&amp; (!hasTimeRemaining || shouldYieldToHost())) {</span>
        <span class="s0">// This currentTask hasn't expired, and we've reached the deadline.</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">callback = currentTask.callback;</span>

      <span class="s3">if </span><span class="s1">(callback !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">currentTask.callback = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">currentPriorityLevel = currentTask.priorityLevel;</span>
        <span class="s3">var </span><span class="s1">didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;</span>
        <span class="s1">markTaskRun(currentTask, currentTime);</span>
        <span class="s3">var </span><span class="s1">continuationCallback = callback(didUserCallbackTimeout);</span>
        <span class="s1">currentTime = getCurrentTime();</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">continuationCallback === </span><span class="s2">'function'</span><span class="s1">) {</span>
          <span class="s1">currentTask.callback = continuationCallback;</span>
          <span class="s1">markTaskYield(currentTask, currentTime);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">{</span>
            <span class="s1">markTaskCompleted(currentTask, currentTime);</span>
            <span class="s1">currentTask.isQueued = </span><span class="s3">false</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">if </span><span class="s1">(currentTask === peek(taskQueue)) {</span>
            <span class="s1">pop(taskQueue);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">advanceTimers(currentTime);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">pop(taskQueue);</span>
      <span class="s1">}</span>

      <span class="s1">currentTask = peek(taskQueue);</span>
    <span class="s1">} </span><span class="s0">// Return whether there's additional work</span>


    <span class="s3">if </span><span class="s1">(currentTask !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">firstTimer = peek(timerQueue);</span>

      <span class="s3">if </span><span class="s1">(firstTimer !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);</span>
      <span class="s1">}</span>

      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">unstable_runWithPriority(priorityLevel, eventHandler) {</span>
    <span class="s3">switch </span><span class="s1">(priorityLevel) {</span>
      <span class="s3">case </span><span class="s1">ImmediatePriority:</span>
      <span class="s3">case </span><span class="s1">UserBlockingPriority:</span>
      <span class="s3">case </span><span class="s1">NormalPriority:</span>
      <span class="s3">case </span><span class="s1">LowPriority:</span>
      <span class="s3">case </span><span class="s1">IdlePriority:</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s1">priorityLevel = NormalPriority;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">previousPriorityLevel = currentPriorityLevel;</span>
    <span class="s1">currentPriorityLevel = priorityLevel;</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">eventHandler();</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">currentPriorityLevel = previousPriorityLevel;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">unstable_next(eventHandler) {</span>
    <span class="s3">var </span><span class="s1">priorityLevel;</span>

    <span class="s3">switch </span><span class="s1">(currentPriorityLevel) {</span>
      <span class="s3">case </span><span class="s1">ImmediatePriority:</span>
      <span class="s3">case </span><span class="s1">UserBlockingPriority:</span>
      <span class="s3">case </span><span class="s1">NormalPriority:</span>
        <span class="s0">// Shift down to normal priority</span>
        <span class="s1">priorityLevel = NormalPriority;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s0">// Anything lower than normal priority should remain at the current level.</span>
        <span class="s1">priorityLevel = currentPriorityLevel;</span>
        <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">previousPriorityLevel = currentPriorityLevel;</span>
    <span class="s1">currentPriorityLevel = priorityLevel;</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">eventHandler();</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">currentPriorityLevel = previousPriorityLevel;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">unstable_wrapCallback(callback) {</span>
    <span class="s3">var </span><span class="s1">parentPriorityLevel = currentPriorityLevel;</span>
    <span class="s3">return function </span><span class="s1">() {</span>
      <span class="s0">// This is a fork of runWithPriority, inlined for performance.</span>
      <span class="s3">var </span><span class="s1">previousPriorityLevel = currentPriorityLevel;</span>
      <span class="s1">currentPriorityLevel = parentPriorityLevel;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">callback.apply(</span><span class="s3">this</span><span class="s1">, arguments);</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s1">currentPriorityLevel = previousPriorityLevel;</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">timeoutForPriorityLevel(priorityLevel) {</span>
    <span class="s3">switch </span><span class="s1">(priorityLevel) {</span>
      <span class="s3">case </span><span class="s1">ImmediatePriority:</span>
        <span class="s3">return </span><span class="s1">IMMEDIATE_PRIORITY_TIMEOUT;</span>

      <span class="s3">case </span><span class="s1">UserBlockingPriority:</span>
        <span class="s3">return </span><span class="s1">USER_BLOCKING_PRIORITY;</span>

      <span class="s3">case </span><span class="s1">IdlePriority:</span>
        <span class="s3">return </span><span class="s1">IDLE_PRIORITY;</span>

      <span class="s3">case </span><span class="s1">LowPriority:</span>
        <span class="s3">return </span><span class="s1">LOW_PRIORITY_TIMEOUT;</span>

      <span class="s3">case </span><span class="s1">NormalPriority:</span>
      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">NORMAL_PRIORITY_TIMEOUT;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">unstable_scheduleCallback(priorityLevel, callback, options) {</span>
    <span class="s3">var </span><span class="s1">currentTime = getCurrentTime();</span>
    <span class="s3">var </span><span class="s1">startTime;</span>
    <span class="s3">var </span><span class="s1">timeout;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">options === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; options !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">delay = options.delay;</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">delay === </span><span class="s2">'number' </span><span class="s1">&amp;&amp; delay &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">startTime = currentTime + delay;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">startTime = currentTime;</span>
      <span class="s1">}</span>

      <span class="s1">timeout = </span><span class="s3">typeof </span><span class="s1">options.timeout === </span><span class="s2">'number' </span><span class="s1">? options.timeout : timeoutForPriorityLevel(priorityLevel);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">timeout = timeoutForPriorityLevel(priorityLevel);</span>
      <span class="s1">startTime = currentTime;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">expirationTime = startTime + timeout;</span>
    <span class="s3">var </span><span class="s1">newTask = {</span>
      <span class="s1">id: taskIdCounter++,</span>
      <span class="s1">callback: callback,</span>
      <span class="s1">priorityLevel: priorityLevel,</span>
      <span class="s1">startTime: startTime,</span>
      <span class="s1">expirationTime: expirationTime,</span>
      <span class="s1">sortIndex: -</span><span class="s4">1</span>
    <span class="s1">};</span>

    <span class="s1">{</span>
      <span class="s1">newTask.isQueued = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(startTime &gt; currentTime) {</span>
      <span class="s0">// This is a delayed task.</span>
      <span class="s1">newTask.sortIndex = startTime;</span>
      <span class="s1">push(timerQueue, newTask);</span>

      <span class="s3">if </span><span class="s1">(peek(taskQueue) === </span><span class="s3">null </span><span class="s1">&amp;&amp; newTask === peek(timerQueue)) {</span>
        <span class="s0">// All tasks are delayed, and this is the task with the earliest delay.</span>
        <span class="s3">if </span><span class="s1">(isHostTimeoutScheduled) {</span>
          <span class="s0">// Cancel an existing timeout.</span>
          <span class="s1">cancelHostTimeout();</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">isHostTimeoutScheduled = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// Schedule a timeout.</span>


        <span class="s1">requestHostTimeout(handleTimeout, startTime - currentTime);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">newTask.sortIndex = expirationTime;</span>
      <span class="s1">push(taskQueue, newTask);</span>

      <span class="s1">{</span>
        <span class="s1">markTaskStart(newTask, currentTime);</span>
        <span class="s1">newTask.isQueued = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// Schedule a host callback, if needed. If we're already performing work,</span>
      <span class="s0">// wait until the next time we yield.</span>


      <span class="s3">if </span><span class="s1">(!isHostCallbackScheduled &amp;&amp; !isPerformingWork) {</span>
        <span class="s1">isHostCallbackScheduled = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">requestHostCallback(flushWork);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">newTask;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">unstable_pauseExecution() {</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">unstable_continueExecution() {</span>

    <span class="s3">if </span><span class="s1">(!isHostCallbackScheduled &amp;&amp; !isPerformingWork) {</span>
      <span class="s1">isHostCallbackScheduled = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">requestHostCallback(flushWork);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">unstable_getFirstCallbackNode() {</span>
    <span class="s3">return </span><span class="s1">peek(taskQueue);</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">unstable_cancelCallback(task) {</span>
    <span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(task.isQueued) {</span>
        <span class="s3">var </span><span class="s1">currentTime = getCurrentTime();</span>
        <span class="s1">markTaskCanceled(task, currentTime);</span>
        <span class="s1">task.isQueued = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// Null out the callback to indicate the task has been canceled. (Can't</span>
    <span class="s0">// remove from the queue because you can't remove arbitrary nodes from an</span>
    <span class="s0">// array based heap, only the first one.)</span>


    <span class="s1">task.callback = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">unstable_getCurrentPriorityLevel() {</span>
    <span class="s3">return </span><span class="s1">currentPriorityLevel;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">unstable_shouldYield() {</span>
    <span class="s3">var </span><span class="s1">currentTime = getCurrentTime();</span>
    <span class="s1">advanceTimers(currentTime);</span>
    <span class="s3">var </span><span class="s1">firstTask = peek(taskQueue);</span>
    <span class="s3">return </span><span class="s1">firstTask !== currentTask &amp;&amp; currentTask !== </span><span class="s3">null </span><span class="s1">&amp;&amp; firstTask !== </span><span class="s3">null </span><span class="s1">&amp;&amp; firstTask.callback !== </span><span class="s3">null </span><span class="s1">&amp;&amp; firstTask.startTime &lt;= currentTime &amp;&amp; firstTask.expirationTime &lt; currentTask.expirationTime || shouldYieldToHost();</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">unstable_requestPaint = requestPaint;</span>
  <span class="s3">var </span><span class="s1">unstable_Profiling =  {</span>
    <span class="s1">startLoggingProfilingEvents: startLoggingProfilingEvents,</span>
    <span class="s1">stopLoggingProfilingEvents: stopLoggingProfilingEvents,</span>
    <span class="s1">sharedProfilingBuffer: sharedProfilingBuffer</span>
  <span class="s1">} ;</span>



  <span class="s3">var </span><span class="s1">Scheduler = </span><span class="s0">/*#__PURE__*/</span><span class="s1">Object.freeze({</span>
    <span class="s1">__proto__: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">unstable_ImmediatePriority: ImmediatePriority,</span>
    <span class="s1">unstable_UserBlockingPriority: UserBlockingPriority,</span>
    <span class="s1">unstable_NormalPriority: NormalPriority,</span>
    <span class="s1">unstable_IdlePriority: IdlePriority,</span>
    <span class="s1">unstable_LowPriority: LowPriority,</span>
    <span class="s1">unstable_runWithPriority: unstable_runWithPriority,</span>
    <span class="s1">unstable_next: unstable_next,</span>
    <span class="s1">unstable_scheduleCallback: unstable_scheduleCallback,</span>
    <span class="s1">unstable_cancelCallback: unstable_cancelCallback,</span>
    <span class="s1">unstable_wrapCallback: unstable_wrapCallback,</span>
    <span class="s1">unstable_getCurrentPriorityLevel: unstable_getCurrentPriorityLevel,</span>
    <span class="s1">unstable_shouldYield: unstable_shouldYield,</span>
    <span class="s1">unstable_requestPaint: unstable_requestPaint,</span>
    <span class="s1">unstable_continueExecution: unstable_continueExecution,</span>
    <span class="s1">unstable_pauseExecution: unstable_pauseExecution,</span>
    <span class="s1">unstable_getFirstCallbackNode: unstable_getFirstCallbackNode,</span>
    <span class="s1">get unstable_now () { </span><span class="s3">return </span><span class="s1">getCurrentTime; },</span>
    <span class="s1">get unstable_forceFrameRate () { </span><span class="s3">return </span><span class="s1">forceFrameRate; },</span>
    <span class="s1">unstable_Profiling: unstable_Profiling</span>
  <span class="s1">});</span>

  <span class="s3">var </span><span class="s1">DEFAULT_THREAD_ID = </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// Counters used to generate unique IDs.</span>

  <span class="s3">var </span><span class="s1">interactionIDCounter = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">threadIDCounter = </span><span class="s4">0</span><span class="s1">; </span><span class="s0">// Set of currently traced interactions.</span>
  <span class="s0">// Interactions &quot;stack&quot;</span>
  <span class="s0">// Meaning that newly traced interactions are appended to the previously active set.</span>
  <span class="s0">// When an interaction goes out of scope, the previous set (if any) is restored.</span>

  <span class="s3">var </span><span class="s1">interactionsRef = </span><span class="s3">null</span><span class="s1">; </span><span class="s0">// Listener(s) to notify when interactions begin and end.</span>

  <span class="s3">var </span><span class="s1">subscriberRef = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s1">interactionsRef = {</span>
      <span class="s1">current: </span><span class="s3">new </span><span class="s1">Set()</span>
    <span class="s1">};</span>
    <span class="s1">subscriberRef = {</span>
      <span class="s1">current: </span><span class="s3">null</span>
    <span class="s1">};</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">unstable_clear(callback) {</span>

    <span class="s3">var </span><span class="s1">prevInteractions = interactionsRef.current;</span>
    <span class="s1">interactionsRef.current = </span><span class="s3">new </span><span class="s1">Set();</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">return </span><span class="s1">callback();</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s1">interactionsRef.current = prevInteractions;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">unstable_getCurrent() {</span>
    <span class="s1">{</span>
      <span class="s3">return </span><span class="s1">interactionsRef.current;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">unstable_getThreadID() {</span>
    <span class="s3">return </span><span class="s1">++threadIDCounter;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">unstable_trace(name, timestamp, callback) {</span>
    <span class="s3">var </span><span class="s1">threadID = arguments.length &gt; </span><span class="s4">3 </span><span class="s1">&amp;&amp; arguments[</span><span class="s4">3</span><span class="s1">] !== undefined ? arguments[</span><span class="s4">3</span><span class="s1">] : DEFAULT_THREAD_ID;</span>

    <span class="s3">var </span><span class="s1">interaction = {</span>
      <span class="s1">__count: </span><span class="s4">1</span><span class="s1">,</span>
      <span class="s1">id: interactionIDCounter++,</span>
      <span class="s1">name: name,</span>
      <span class="s1">timestamp: timestamp</span>
    <span class="s1">};</span>
    <span class="s3">var </span><span class="s1">prevInteractions = interactionsRef.current; </span><span class="s0">// Traced interactions should stack/accumulate.</span>
    <span class="s0">// To do that, clone the current interactions.</span>
    <span class="s0">// The previous set will be restored upon completion.</span>

    <span class="s3">var </span><span class="s1">interactions = </span><span class="s3">new </span><span class="s1">Set(prevInteractions);</span>
    <span class="s1">interactions.add(interaction);</span>
    <span class="s1">interactionsRef.current = interactions;</span>
    <span class="s3">var </span><span class="s1">subscriber = subscriberRef.current;</span>
    <span class="s3">var </span><span class="s1">returnValue;</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(subscriber !== </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">subscriber.onInteractionTraced(interaction);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(subscriber !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">subscriber.onWorkStarted(interactions, threadID);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s3">try </span><span class="s1">{</span>
          <span class="s1">returnValue = callback();</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s1">interactionsRef.current = prevInteractions;</span>

          <span class="s3">try </span><span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(subscriber !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s1">subscriber.onWorkStopped(interactions, threadID);</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
            <span class="s1">interaction.__count--; </span><span class="s0">// If no async work was scheduled for this interaction,</span>
            <span class="s0">// Notify subscribers that it's completed.</span>

            <span class="s3">if </span><span class="s1">(subscriber !== </span><span class="s3">null </span><span class="s1">&amp;&amp; interaction.__count === </span><span class="s4">0</span><span class="s1">) {</span>
              <span class="s1">subscriber.onInteractionScheduledWorkCompleted(interaction);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">returnValue;</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">unstable_wrap(callback) {</span>
    <span class="s3">var </span><span class="s1">threadID = arguments.length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s1">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s1">] : DEFAULT_THREAD_ID;</span>

    <span class="s3">var </span><span class="s1">wrappedInteractions = interactionsRef.current;</span>
    <span class="s3">var </span><span class="s1">subscriber = subscriberRef.current;</span>

    <span class="s3">if </span><span class="s1">(subscriber !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">subscriber.onWorkScheduled(wrappedInteractions, threadID);</span>
    <span class="s1">} </span><span class="s0">// Update the pending async work count for the current interactions.</span>
    <span class="s0">// Update after calling subscribers in case of error.</span>


    <span class="s1">wrappedInteractions.forEach(</span><span class="s3">function </span><span class="s1">(interaction) {</span>
      <span class="s1">interaction.__count++;</span>
    <span class="s1">});</span>
    <span class="s3">var </span><span class="s1">hasRun = </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s3">function </span><span class="s1">wrapped() {</span>
      <span class="s3">var </span><span class="s1">prevInteractions = interactionsRef.current;</span>
      <span class="s1">interactionsRef.current = wrappedInteractions;</span>
      <span class="s1">subscriber = subscriberRef.current;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">var </span><span class="s1">returnValue;</span>

        <span class="s3">try </span><span class="s1">{</span>
          <span class="s3">if </span><span class="s1">(subscriber !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s1">subscriber.onWorkStarted(wrappedInteractions, threadID);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
          <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">returnValue = callback.apply(undefined, arguments);</span>
          <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
            <span class="s1">interactionsRef.current = prevInteractions;</span>

            <span class="s3">if </span><span class="s1">(subscriber !== </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s1">subscriber.onWorkStopped(wrappedInteractions, threadID);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">returnValue;</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(!hasRun) {</span>
          <span class="s0">// We only expect a wrapped function to be executed once,</span>
          <span class="s0">// But in the event that it's executed more than once</span>
          <span class="s0">// Only decrement the outstanding interaction counts once.</span>
          <span class="s1">hasRun = </span><span class="s3">true</span><span class="s1">; </span><span class="s0">// Update pending async counts for all wrapped interactions.</span>
          <span class="s0">// If this was the last scheduled async work for any of them,</span>
          <span class="s0">// Mark them as completed.</span>

          <span class="s1">wrappedInteractions.forEach(</span><span class="s3">function </span><span class="s1">(interaction) {</span>
            <span class="s1">interaction.__count--;</span>

            <span class="s3">if </span><span class="s1">(subscriber !== </span><span class="s3">null </span><span class="s1">&amp;&amp; interaction.__count === </span><span class="s4">0</span><span class="s1">) {</span>
              <span class="s1">subscriber.onInteractionScheduledWorkCompleted(interaction);</span>
            <span class="s1">}</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">wrapped.cancel = </span><span class="s3">function </span><span class="s1">cancel() {</span>
      <span class="s1">subscriber = subscriberRef.current;</span>

      <span class="s3">try </span><span class="s1">{</span>
        <span class="s3">if </span><span class="s1">(subscriber !== </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s1">subscriber.onWorkCanceled(wrappedInteractions, threadID);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
        <span class="s0">// Update pending async counts for all wrapped interactions.</span>
        <span class="s0">// If this was the last scheduled async work for any of them,</span>
        <span class="s0">// Mark them as completed.</span>
        <span class="s1">wrappedInteractions.forEach(</span><span class="s3">function </span><span class="s1">(interaction) {</span>
          <span class="s1">interaction.__count--;</span>

          <span class="s3">if </span><span class="s1">(subscriber &amp;&amp; interaction.__count === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">subscriber.onInteractionScheduledWorkCompleted(interaction);</span>
          <span class="s1">}</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s3">return </span><span class="s1">wrapped;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">subscribers = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">{</span>
    <span class="s1">subscribers = </span><span class="s3">new </span><span class="s1">Set();</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">unstable_subscribe(subscriber) {</span>
    <span class="s1">{</span>
      <span class="s1">subscribers.add(subscriber);</span>

      <span class="s3">if </span><span class="s1">(subscribers.size === </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">subscriberRef.current = {</span>
          <span class="s1">onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,</span>
          <span class="s1">onInteractionTraced: onInteractionTraced,</span>
          <span class="s1">onWorkCanceled: onWorkCanceled,</span>
          <span class="s1">onWorkScheduled: onWorkScheduled,</span>
          <span class="s1">onWorkStarted: onWorkStarted,</span>
          <span class="s1">onWorkStopped: onWorkStopped</span>
        <span class="s1">};</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">function </span><span class="s1">unstable_unsubscribe(subscriber) {</span>
    <span class="s1">{</span>
      <span class="s1">subscribers.</span><span class="s3">delete</span><span class="s1">(subscriber);</span>

      <span class="s3">if </span><span class="s1">(subscribers.size === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">subscriberRef.current = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">onInteractionTraced(interaction) {</span>
    <span class="s3">var </span><span class="s1">didCatchError = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">caughtError = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">subscribers.forEach(</span><span class="s3">function </span><span class="s1">(subscriber) {</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">subscriber.onInteractionTraced(interaction);</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
        <span class="s3">if </span><span class="s1">(!didCatchError) {</span>
          <span class="s1">didCatchError = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">caughtError = error;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s3">if </span><span class="s1">(didCatchError) {</span>
      <span class="s3">throw </span><span class="s1">caughtError;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">onInteractionScheduledWorkCompleted(interaction) {</span>
    <span class="s3">var </span><span class="s1">didCatchError = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">caughtError = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">subscribers.forEach(</span><span class="s3">function </span><span class="s1">(subscriber) {</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">subscriber.onInteractionScheduledWorkCompleted(interaction);</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
        <span class="s3">if </span><span class="s1">(!didCatchError) {</span>
          <span class="s1">didCatchError = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">caughtError = error;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s3">if </span><span class="s1">(didCatchError) {</span>
      <span class="s3">throw </span><span class="s1">caughtError;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">onWorkScheduled(interactions, threadID) {</span>
    <span class="s3">var </span><span class="s1">didCatchError = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">caughtError = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">subscribers.forEach(</span><span class="s3">function </span><span class="s1">(subscriber) {</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">subscriber.onWorkScheduled(interactions, threadID);</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
        <span class="s3">if </span><span class="s1">(!didCatchError) {</span>
          <span class="s1">didCatchError = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">caughtError = error;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s3">if </span><span class="s1">(didCatchError) {</span>
      <span class="s3">throw </span><span class="s1">caughtError;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">onWorkStarted(interactions, threadID) {</span>
    <span class="s3">var </span><span class="s1">didCatchError = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">caughtError = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">subscribers.forEach(</span><span class="s3">function </span><span class="s1">(subscriber) {</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">subscriber.onWorkStarted(interactions, threadID);</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
        <span class="s3">if </span><span class="s1">(!didCatchError) {</span>
          <span class="s1">didCatchError = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">caughtError = error;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s3">if </span><span class="s1">(didCatchError) {</span>
      <span class="s3">throw </span><span class="s1">caughtError;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">onWorkStopped(interactions, threadID) {</span>
    <span class="s3">var </span><span class="s1">didCatchError = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">caughtError = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">subscribers.forEach(</span><span class="s3">function </span><span class="s1">(subscriber) {</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">subscriber.onWorkStopped(interactions, threadID);</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
        <span class="s3">if </span><span class="s1">(!didCatchError) {</span>
          <span class="s1">didCatchError = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">caughtError = error;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s3">if </span><span class="s1">(didCatchError) {</span>
      <span class="s3">throw </span><span class="s1">caughtError;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">onWorkCanceled(interactions, threadID) {</span>
    <span class="s3">var </span><span class="s1">didCatchError = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">caughtError = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">subscribers.forEach(</span><span class="s3">function </span><span class="s1">(subscriber) {</span>
      <span class="s3">try </span><span class="s1">{</span>
        <span class="s1">subscriber.onWorkCanceled(interactions, threadID);</span>
      <span class="s1">} </span><span class="s3">catch </span><span class="s1">(error) {</span>
        <span class="s3">if </span><span class="s1">(!didCatchError) {</span>
          <span class="s1">didCatchError = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s1">caughtError = error;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s3">if </span><span class="s1">(didCatchError) {</span>
      <span class="s3">throw </span><span class="s1">caughtError;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>



  <span class="s3">var </span><span class="s1">SchedulerTracing = </span><span class="s0">/*#__PURE__*/</span><span class="s1">Object.freeze({</span>
    <span class="s1">__proto__: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">get __interactionsRef () { </span><span class="s3">return </span><span class="s1">interactionsRef; },</span>
    <span class="s1">get __subscriberRef () { </span><span class="s3">return </span><span class="s1">subscriberRef; },</span>
    <span class="s1">unstable_clear: unstable_clear,</span>
    <span class="s1">unstable_getCurrent: unstable_getCurrent,</span>
    <span class="s1">unstable_getThreadID: unstable_getThreadID,</span>
    <span class="s1">unstable_trace: unstable_trace,</span>
    <span class="s1">unstable_wrap: unstable_wrap,</span>
    <span class="s1">unstable_subscribe: unstable_subscribe,</span>
    <span class="s1">unstable_unsubscribe: unstable_unsubscribe</span>
  <span class="s1">});</span>

  <span class="s3">var </span><span class="s1">ReactSharedInternals$1 = {</span>
    <span class="s1">ReactCurrentDispatcher: ReactCurrentDispatcher,</span>
    <span class="s1">ReactCurrentOwner: ReactCurrentOwner,</span>
    <span class="s1">IsSomeRendererActing: IsSomeRendererActing,</span>
    <span class="s0">// Used by renderers to avoid bundling object-assign twice in UMD bundles:</span>
    <span class="s1">assign: objectAssign</span>
  <span class="s1">};</span>

  <span class="s1">{</span>
    <span class="s1">objectAssign(ReactSharedInternals$1, {</span>
      <span class="s0">// These should not be included in production.</span>
      <span class="s1">ReactDebugCurrentFrame: ReactDebugCurrentFrame,</span>
      <span class="s0">// Shim for React DOM 16.0.0 which still destructured (but not used) this.</span>
      <span class="s0">// TODO: remove in React 17.0.</span>
      <span class="s1">ReactComponentTreeHook: {}</span>
    <span class="s1">});</span>
  <span class="s1">} </span><span class="s0">// Re-export the schedule API(s) for UMD bundles.</span>
  <span class="s0">// This avoids introducing a dependency on a new UMD global in a minor update,</span>
  <span class="s0">// Since that would be a breaking change (e.g. for all existing CodeSandboxes).</span>
  <span class="s0">// This re-export is only required for UMD bundles;</span>
  <span class="s0">// CJS bundles use the shared NPM package.</span>


  <span class="s1">objectAssign(ReactSharedInternals$1, {</span>
    <span class="s1">Scheduler: Scheduler,</span>
    <span class="s1">SchedulerTracing: SchedulerTracing</span>
  <span class="s1">});</span>

  <span class="s1">{</span>

    <span class="s3">try </span><span class="s1">{</span>
      <span class="s3">var </span><span class="s1">frozenObject = Object.freeze({});</span>
      <span class="s3">var </span><span class="s1">testMap = </span><span class="s3">new </span><span class="s1">Map([[frozenObject, </span><span class="s3">null</span><span class="s1">]]);</span>
      <span class="s3">var </span><span class="s1">testSet = </span><span class="s3">new </span><span class="s1">Set([frozenObject]); </span><span class="s0">// This is necessary for Rollup to not consider these unused.</span>
      <span class="s0">// https://github.com/rollup/rollup/issues/1771</span>
      <span class="s0">// TODO: we can remove these if Rollup fixes the bug.</span>

      <span class="s1">testMap.set(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">0</span><span class="s1">);</span>
      <span class="s1">testSet.add(</span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">createElement$1 =  createElementWithValidation ;</span>
  <span class="s3">var </span><span class="s1">cloneElement$1 =  cloneElementWithValidation ;</span>
  <span class="s3">var </span><span class="s1">createFactory =  createFactoryWithValidation ;</span>
  <span class="s3">var </span><span class="s1">Children = {</span>
    <span class="s1">map: mapChildren,</span>
    <span class="s1">forEach: forEachChildren,</span>
    <span class="s1">count: countChildren,</span>
    <span class="s1">toArray: toArray,</span>
    <span class="s1">only: onlyChild</span>
  <span class="s1">};</span>

  <span class="s1">exports.Children = Children;</span>
  <span class="s1">exports.Component = Component;</span>
  <span class="s1">exports.Fragment = REACT_FRAGMENT_TYPE;</span>
  <span class="s1">exports.Profiler = REACT_PROFILER_TYPE;</span>
  <span class="s1">exports.PureComponent = PureComponent;</span>
  <span class="s1">exports.StrictMode = REACT_STRICT_MODE_TYPE;</span>
  <span class="s1">exports.Suspense = REACT_SUSPENSE_TYPE;</span>
  <span class="s1">exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals$1;</span>
  <span class="s1">exports.cloneElement = cloneElement$1;</span>
  <span class="s1">exports.createContext = createContext;</span>
  <span class="s1">exports.createElement = createElement$1;</span>
  <span class="s1">exports.createFactory = createFactory;</span>
  <span class="s1">exports.createRef = createRef;</span>
  <span class="s1">exports.forwardRef = forwardRef;</span>
  <span class="s1">exports.isValidElement = isValidElement;</span>
  <span class="s1">exports.lazy = lazy;</span>
  <span class="s1">exports.memo = memo;</span>
  <span class="s1">exports.useCallback = useCallback;</span>
  <span class="s1">exports.useContext = useContext;</span>
  <span class="s1">exports.useDebugValue = useDebugValue;</span>
  <span class="s1">exports.useEffect = useEffect;</span>
  <span class="s1">exports.useImperativeHandle = useImperativeHandle;</span>
  <span class="s1">exports.useLayoutEffect = useLayoutEffect;</span>
  <span class="s1">exports.useMemo = useMemo;</span>
  <span class="s1">exports.useReducer = useReducer;</span>
  <span class="s1">exports.useRef = useRef;</span>
  <span class="s1">exports.useState = useState;</span>
  <span class="s1">exports.version = ReactVersion;</span>

<span class="s1">})));</span>
</pre>
</body>
</html>