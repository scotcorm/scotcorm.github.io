<html>
<head>
<title>app.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
app.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">import </span><span class="s1">logging</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">typing </span><span class="s0">as </span><span class="s1">t</span>
<span class="s0">import </span><span class="s1">weakref</span>
<span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">timedelta</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">chain</span>
<span class="s0">from </span><span class="s1">threading </span><span class="s0">import </span><span class="s1">Lock</span>
<span class="s0">from </span><span class="s1">types </span><span class="s0">import </span><span class="s1">TracebackType</span>

<span class="s0">from </span><span class="s1">werkzeug.datastructures </span><span class="s0">import </span><span class="s1">Headers</span>
<span class="s0">from </span><span class="s1">werkzeug.datastructures </span><span class="s0">import </span><span class="s1">ImmutableDict</span>
<span class="s0">from </span><span class="s1">werkzeug.exceptions </span><span class="s0">import </span><span class="s1">BadRequest</span>
<span class="s0">from </span><span class="s1">werkzeug.exceptions </span><span class="s0">import </span><span class="s1">BadRequestKeyError</span>
<span class="s0">from </span><span class="s1">werkzeug.exceptions </span><span class="s0">import </span><span class="s1">HTTPException</span>
<span class="s0">from </span><span class="s1">werkzeug.exceptions </span><span class="s0">import </span><span class="s1">InternalServerError</span>
<span class="s0">from </span><span class="s1">werkzeug.local </span><span class="s0">import </span><span class="s1">ContextVar</span>
<span class="s0">from </span><span class="s1">werkzeug.routing </span><span class="s0">import </span><span class="s1">BuildError</span>
<span class="s0">from </span><span class="s1">werkzeug.routing </span><span class="s0">import </span><span class="s1">Map</span>
<span class="s0">from </span><span class="s1">werkzeug.routing </span><span class="s0">import </span><span class="s1">MapAdapter</span>
<span class="s0">from </span><span class="s1">werkzeug.routing </span><span class="s0">import </span><span class="s1">RequestRedirect</span>
<span class="s0">from </span><span class="s1">werkzeug.routing </span><span class="s0">import </span><span class="s1">RoutingException</span>
<span class="s0">from </span><span class="s1">werkzeug.routing </span><span class="s0">import </span><span class="s1">Rule</span>
<span class="s0">from </span><span class="s1">werkzeug.wrappers </span><span class="s0">import </span><span class="s1">Response </span><span class="s0">as </span><span class="s1">BaseResponse</span>

<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">cli</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">json</span>
<span class="s0">from </span><span class="s1">.config </span><span class="s0">import </span><span class="s1">Config</span>
<span class="s0">from </span><span class="s1">.config </span><span class="s0">import </span><span class="s1">ConfigAttribute</span>
<span class="s0">from </span><span class="s1">.ctx </span><span class="s0">import </span><span class="s1">_AppCtxGlobals</span>
<span class="s0">from </span><span class="s1">.ctx </span><span class="s0">import </span><span class="s1">AppContext</span>
<span class="s0">from </span><span class="s1">.ctx </span><span class="s0">import </span><span class="s1">RequestContext</span>
<span class="s0">from </span><span class="s1">.globals </span><span class="s0">import </span><span class="s1">_request_ctx_stack</span>
<span class="s0">from </span><span class="s1">.globals </span><span class="s0">import </span><span class="s1">g</span>
<span class="s0">from </span><span class="s1">.globals </span><span class="s0">import </span><span class="s1">request</span>
<span class="s0">from </span><span class="s1">.globals </span><span class="s0">import </span><span class="s1">session</span>
<span class="s0">from </span><span class="s1">.helpers </span><span class="s0">import </span><span class="s1">_split_blueprint_path</span>
<span class="s0">from </span><span class="s1">.helpers </span><span class="s0">import </span><span class="s1">get_debug_flag</span>
<span class="s0">from </span><span class="s1">.helpers </span><span class="s0">import </span><span class="s1">get_env</span>
<span class="s0">from </span><span class="s1">.helpers </span><span class="s0">import </span><span class="s1">get_flashed_messages</span>
<span class="s0">from </span><span class="s1">.helpers </span><span class="s0">import </span><span class="s1">get_load_dotenv</span>
<span class="s0">from </span><span class="s1">.helpers </span><span class="s0">import </span><span class="s1">locked_cached_property</span>
<span class="s0">from </span><span class="s1">.helpers </span><span class="s0">import </span><span class="s1">url_for</span>
<span class="s0">from </span><span class="s1">.json </span><span class="s0">import </span><span class="s1">jsonify</span>
<span class="s0">from </span><span class="s1">.logging </span><span class="s0">import </span><span class="s1">create_logger</span>
<span class="s0">from </span><span class="s1">.scaffold </span><span class="s0">import </span><span class="s1">_endpoint_from_view_func</span>
<span class="s0">from </span><span class="s1">.scaffold </span><span class="s0">import </span><span class="s1">_sentinel</span>
<span class="s0">from </span><span class="s1">.scaffold </span><span class="s0">import </span><span class="s1">find_package</span>
<span class="s0">from </span><span class="s1">.scaffold </span><span class="s0">import </span><span class="s1">Scaffold</span>
<span class="s0">from </span><span class="s1">.scaffold </span><span class="s0">import </span><span class="s1">setupmethod</span>
<span class="s0">from </span><span class="s1">.sessions </span><span class="s0">import </span><span class="s1">SecureCookieSessionInterface</span>
<span class="s0">from </span><span class="s1">.signals </span><span class="s0">import </span><span class="s1">appcontext_tearing_down</span>
<span class="s0">from </span><span class="s1">.signals </span><span class="s0">import </span><span class="s1">got_request_exception</span>
<span class="s0">from </span><span class="s1">.signals </span><span class="s0">import </span><span class="s1">request_finished</span>
<span class="s0">from </span><span class="s1">.signals </span><span class="s0">import </span><span class="s1">request_started</span>
<span class="s0">from </span><span class="s1">.signals </span><span class="s0">import </span><span class="s1">request_tearing_down</span>
<span class="s0">from </span><span class="s1">.templating </span><span class="s0">import </span><span class="s1">DispatchingJinjaLoader</span>
<span class="s0">from </span><span class="s1">.templating </span><span class="s0">import </span><span class="s1">Environment</span>
<span class="s0">from </span><span class="s1">.typing </span><span class="s0">import </span><span class="s1">BeforeFirstRequestCallable</span>
<span class="s0">from </span><span class="s1">.typing </span><span class="s0">import </span><span class="s1">ResponseReturnValue</span>
<span class="s0">from </span><span class="s1">.typing </span><span class="s0">import </span><span class="s1">TeardownCallable</span>
<span class="s0">from </span><span class="s1">.typing </span><span class="s0">import </span><span class="s1">TemplateFilterCallable</span>
<span class="s0">from </span><span class="s1">.typing </span><span class="s0">import </span><span class="s1">TemplateGlobalCallable</span>
<span class="s0">from </span><span class="s1">.typing </span><span class="s0">import </span><span class="s1">TemplateTestCallable</span>
<span class="s0">from </span><span class="s1">.wrappers </span><span class="s0">import </span><span class="s1">Request</span>
<span class="s0">from </span><span class="s1">.wrappers </span><span class="s0">import </span><span class="s1">Response</span>

<span class="s0">if </span><span class="s1">t.TYPE_CHECKING:</span>
    <span class="s0">import </span><span class="s1">typing_extensions </span><span class="s0">as </span><span class="s1">te</span>
    <span class="s0">from </span><span class="s1">.blueprints </span><span class="s0">import </span><span class="s1">Blueprint</span>
    <span class="s0">from </span><span class="s1">.testing </span><span class="s0">import </span><span class="s1">FlaskClient</span>
    <span class="s0">from </span><span class="s1">.testing </span><span class="s0">import </span><span class="s1">FlaskCliRunner</span>
    <span class="s0">from </span><span class="s1">.typing </span><span class="s0">import </span><span class="s1">ErrorHandlerCallable</span>

<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s2">3</span><span class="s0">, </span><span class="s2">8</span><span class="s1">):</span>
    <span class="s1">iscoroutinefunction = inspect.iscoroutinefunction</span>
<span class="s0">else</span><span class="s1">:</span>

    <span class="s0">def </span><span class="s1">iscoroutinefunction(func: t.Any) -&gt; bool:</span>
        <span class="s0">while </span><span class="s1">inspect.ismethod(func):</span>
            <span class="s1">func = func.__func__</span>

        <span class="s0">while </span><span class="s1">isinstance(func</span><span class="s0">, </span><span class="s1">functools.partial):</span>
            <span class="s1">func = func.func</span>

        <span class="s0">return </span><span class="s1">inspect.iscoroutinefunction(func)</span>


<span class="s0">def </span><span class="s1">_make_timedelta(value: t.Optional[timedelta]) -&gt; t.Optional[timedelta]:</span>
    <span class="s0">if </span><span class="s1">value </span><span class="s0">is None or </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">timedelta):</span>
        <span class="s0">return </span><span class="s1">value</span>

    <span class="s0">return </span><span class="s1">timedelta(seconds=value)</span>


<span class="s0">class </span><span class="s1">Flask(Scaffold):</span>
    <span class="s3">&quot;&quot;&quot;The flask object implements a WSGI application and acts as the central 
    object.  It is passed the name of the module or package of the 
    application.  Once it is created it will act as a central registry for 
    the view functions, the URL rules, template configuration and much more. 
 
    The name of the package is used to resolve resources from inside the 
    package or the folder the module is contained in depending on if the 
    package parameter resolves to an actual python package (a folder with 
    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file). 
 
    For more information about resource loading, see :func:`open_resource`. 
 
    Usually you create a :class:`Flask` instance in your main module or 
    in the :file:`__init__.py` file of your package like this:: 
 
        from flask import Flask 
        app = Flask(__name__) 
 
    .. admonition:: About the First Parameter 
 
        The idea of the first parameter is to give Flask an idea of what 
        belongs to your application.  This name is used to find resources 
        on the filesystem, can be used by extensions to improve debugging 
        information and a lot more. 
 
        So it's important what you provide there.  If you are using a single 
        module, `__name__` is always the correct value.  If you however are 
        using a package, it's usually recommended to hardcode the name of 
        your package there. 
 
        For example if your application is defined in :file:`yourapplication/app.py` 
        you should create it with one of the two versions below:: 
 
            app = Flask('yourapplication') 
            app = Flask(__name__.split('.')[0]) 
 
        Why is that?  The application will work even with `__name__`, thanks 
        to how resources are looked up.  However it will make debugging more 
        painful.  Certain extensions can make assumptions based on the 
        import name of your application.  For example the Flask-SQLAlchemy 
        extension will look for the code in your application that triggered 
        an SQL query in debug mode.  If the import name is not properly set 
        up, that debugging information is lost.  (For example it would only 
        pick up SQL queries in `yourapplication.app` and not 
        `yourapplication.views.frontend`) 
 
    .. versionadded:: 0.7 
       The `static_url_path`, `static_folder`, and `template_folder` 
       parameters were added. 
 
    .. versionadded:: 0.8 
       The `instance_path` and `instance_relative_config` parameters were 
       added. 
 
    .. versionadded:: 0.11 
       The `root_path` parameter was added. 
 
    .. versionadded:: 1.0 
       The ``host_matching`` and ``static_host`` parameters were added. 
 
    .. versionadded:: 1.0 
       The ``subdomain_matching`` parameter was added. Subdomain 
       matching needs to be enabled manually now. Setting 
       :data:`SERVER_NAME` does not implicitly enable it. 
 
    :param import_name: the name of the application package 
    :param static_url_path: can be used to specify a different path for the 
                            static files on the web.  Defaults to the name 
                            of the `static_folder` folder. 
    :param static_folder: The folder with static files that is served at 
        ``static_url_path``. Relative to the application ``root_path`` 
        or an absolute path. Defaults to ``'static'``. 
    :param static_host: the host to use when adding the static route. 
        Defaults to None. Required when using ``host_matching=True`` 
        with a ``static_folder`` configured. 
    :param host_matching: set ``url_map.host_matching`` attribute. 
        Defaults to False. 
    :param subdomain_matching: consider the subdomain relative to 
        :data:`SERVER_NAME` when matching routes. Defaults to False. 
    :param template_folder: the folder that contains the templates that should 
                            be used by the application.  Defaults to 
                            ``'templates'`` folder in the root path of the 
                            application. 
    :param instance_path: An alternative instance path for the application. 
                          By default the folder ``'instance'`` next to the 
                          package or module is assumed to be the instance 
                          path. 
    :param instance_relative_config: if set to ``True`` relative filenames 
                                     for loading the config are assumed to 
                                     be relative to the instance path instead 
                                     of the application root. 
    :param root_path: The path to the root of the application files. 
        This should only be set manually when it can't be detected 
        automatically, such as for namespace packages. 
    &quot;&quot;&quot;</span>

    <span class="s4">#: The class that is used for request objects.  See :class:`~flask.Request`</span>
    <span class="s4">#: for more information.</span>
    <span class="s1">request_class = Request</span>

    <span class="s4">#: The class that is used for response objects.  See</span>
    <span class="s4">#: :class:`~flask.Response` for more information.</span>
    <span class="s1">response_class = Response</span>

    <span class="s4">#: The class that is used for the Jinja environment.</span>
    <span class="s4">#:</span>
    <span class="s4">#: .. versionadded:: 0.11</span>
    <span class="s1">jinja_environment = Environment</span>

    <span class="s4">#: The class that is used for the :data:`~flask.g` instance.</span>
    <span class="s4">#:</span>
    <span class="s4">#: Example use cases for a custom class:</span>
    <span class="s4">#:</span>
    <span class="s4">#: 1. Store arbitrary attributes on flask.g.</span>
    <span class="s4">#: 2. Add a property for lazy per-request database connectors.</span>
    <span class="s4">#: 3. Return None instead of AttributeError on unexpected attributes.</span>
    <span class="s4">#: 4. Raise exception if an unexpected attr is set, a &quot;controlled&quot; flask.g.</span>
    <span class="s4">#:</span>
    <span class="s4">#: In Flask 0.9 this property was called `request_globals_class` but it</span>
    <span class="s4">#: was changed in 0.10 to :attr:`app_ctx_globals_class` because the</span>
    <span class="s4">#: flask.g object is now application context scoped.</span>
    <span class="s4">#:</span>
    <span class="s4">#: .. versionadded:: 0.10</span>
    <span class="s1">app_ctx_globals_class = _AppCtxGlobals</span>

    <span class="s4">#: The class that is used for the ``config`` attribute of this app.</span>
    <span class="s4">#: Defaults to :class:`~flask.Config`.</span>
    <span class="s4">#:</span>
    <span class="s4">#: Example use cases for a custom class:</span>
    <span class="s4">#:</span>
    <span class="s4">#: 1. Default values for certain config options.</span>
    <span class="s4">#: 2. Access to config values through attributes in addition to keys.</span>
    <span class="s4">#:</span>
    <span class="s4">#: .. versionadded:: 0.11</span>
    <span class="s1">config_class = Config</span>

    <span class="s4">#: The testing flag.  Set this to ``True`` to enable the test mode of</span>
    <span class="s4">#: Flask extensions (and in the future probably also Flask itself).</span>
    <span class="s4">#: For example this might activate test helpers that have an</span>
    <span class="s4">#: additional runtime cost which should not be enabled by default.</span>
    <span class="s4">#:</span>
    <span class="s4">#: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the</span>
    <span class="s4">#: default it's implicitly enabled.</span>
    <span class="s4">#:</span>
    <span class="s4">#: This attribute can also be configured from the config with the</span>
    <span class="s4">#: ``TESTING`` configuration key.  Defaults to ``False``.</span>
    <span class="s1">testing = ConfigAttribute(</span><span class="s5">&quot;TESTING&quot;</span><span class="s1">)</span>

    <span class="s4">#: If a secret key is set, cryptographic components can use this to</span>
    <span class="s4">#: sign cookies and other things. Set this to a complex random value</span>
    <span class="s4">#: when you want to use the secure cookie for instance.</span>
    <span class="s4">#:</span>
    <span class="s4">#: This attribute can also be configured from the config with the</span>
    <span class="s4">#: :data:`SECRET_KEY` configuration key. Defaults to ``None``.</span>
    <span class="s1">secret_key = ConfigAttribute(</span><span class="s5">&quot;SECRET_KEY&quot;</span><span class="s1">)</span>

    <span class="s4">#: The secure cookie uses this for the name of the session cookie.</span>
    <span class="s4">#:</span>
    <span class="s4">#: This attribute can also be configured from the config with the</span>
    <span class="s4">#: ``SESSION_COOKIE_NAME`` configuration key.  Defaults to ``'session'``</span>
    <span class="s1">session_cookie_name = ConfigAttribute(</span><span class="s5">&quot;SESSION_COOKIE_NAME&quot;</span><span class="s1">)</span>

    <span class="s4">#: A :class:`~datetime.timedelta` which is used to set the expiration</span>
    <span class="s4">#: date of a permanent session.  The default is 31 days which makes a</span>
    <span class="s4">#: permanent session survive for roughly one month.</span>
    <span class="s4">#:</span>
    <span class="s4">#: This attribute can also be configured from the config with the</span>
    <span class="s4">#: ``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to</span>
    <span class="s4">#: ``timedelta(days=31)``</span>
    <span class="s1">permanent_session_lifetime = ConfigAttribute(</span>
        <span class="s5">&quot;PERMANENT_SESSION_LIFETIME&quot;</span><span class="s0">, </span><span class="s1">get_converter=_make_timedelta</span>
    <span class="s1">)</span>

    <span class="s4">#: A :class:`~datetime.timedelta` or number of seconds which is used</span>
    <span class="s4">#: as the default ``max_age`` for :func:`send_file`. The default is</span>
    <span class="s4">#: ``None``, which tells the browser to use conditional requests</span>
    <span class="s4">#: instead of a timed cache.</span>
    <span class="s4">#:</span>
    <span class="s4">#: Configured with the :data:`SEND_FILE_MAX_AGE_DEFAULT`</span>
    <span class="s4">#: configuration key.</span>
    <span class="s4">#:</span>
    <span class="s4">#: .. versionchanged:: 2.0</span>
    <span class="s4">#:     Defaults to ``None`` instead of 12 hours.</span>
    <span class="s1">send_file_max_age_default = ConfigAttribute(</span>
        <span class="s5">&quot;SEND_FILE_MAX_AGE_DEFAULT&quot;</span><span class="s0">, </span><span class="s1">get_converter=_make_timedelta</span>
    <span class="s1">)</span>

    <span class="s4">#: Enable this if you want to use the X-Sendfile feature.  Keep in</span>
    <span class="s4">#: mind that the server has to support this.  This only affects files</span>
    <span class="s4">#: sent with the :func:`send_file` method.</span>
    <span class="s4">#:</span>
    <span class="s4">#: .. versionadded:: 0.2</span>
    <span class="s4">#:</span>
    <span class="s4">#: This attribute can also be configured from the config with the</span>
    <span class="s4">#: ``USE_X_SENDFILE`` configuration key.  Defaults to ``False``.</span>
    <span class="s1">use_x_sendfile = ConfigAttribute(</span><span class="s5">&quot;USE_X_SENDFILE&quot;</span><span class="s1">)</span>

    <span class="s4">#: The JSON encoder class to use.  Defaults to :class:`~flask.json.JSONEncoder`.</span>
    <span class="s4">#:</span>
    <span class="s4">#: .. versionadded:: 0.10</span>
    <span class="s1">json_encoder = json.JSONEncoder</span>

    <span class="s4">#: The JSON decoder class to use.  Defaults to :class:`~flask.json.JSONDecoder`.</span>
    <span class="s4">#:</span>
    <span class="s4">#: .. versionadded:: 0.10</span>
    <span class="s1">json_decoder = json.JSONDecoder</span>

    <span class="s4">#: Options that are passed to the Jinja environment in</span>
    <span class="s4">#: :meth:`create_jinja_environment`. Changing these options after</span>
    <span class="s4">#: the environment is created (accessing :attr:`jinja_env`) will</span>
    <span class="s4">#: have no effect.</span>
    <span class="s4">#:</span>
    <span class="s4">#: .. versionchanged:: 1.1.0</span>
    <span class="s4">#:     This is a ``dict`` instead of an ``ImmutableDict`` to allow</span>
    <span class="s4">#:     easier configuration.</span>
    <span class="s4">#:</span>
    <span class="s1">jinja_options: dict = {}</span>

    <span class="s4">#: Default configuration parameters.</span>
    <span class="s1">default_config = ImmutableDict(</span>
        <span class="s1">{</span>
            <span class="s5">&quot;ENV&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s5">&quot;DEBUG&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s5">&quot;TESTING&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s5">&quot;PROPAGATE_EXCEPTIONS&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s5">&quot;PRESERVE_CONTEXT_ON_EXCEPTION&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s5">&quot;SECRET_KEY&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s5">&quot;PERMANENT_SESSION_LIFETIME&quot;</span><span class="s1">: timedelta(days=</span><span class="s2">31</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s5">&quot;USE_X_SENDFILE&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s5">&quot;SERVER_NAME&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s5">&quot;APPLICATION_ROOT&quot;</span><span class="s1">: </span><span class="s5">&quot;/&quot;</span><span class="s0">,</span>
            <span class="s5">&quot;SESSION_COOKIE_NAME&quot;</span><span class="s1">: </span><span class="s5">&quot;session&quot;</span><span class="s0">,</span>
            <span class="s5">&quot;SESSION_COOKIE_DOMAIN&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s5">&quot;SESSION_COOKIE_PATH&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s5">&quot;SESSION_COOKIE_HTTPONLY&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s5">&quot;SESSION_COOKIE_SECURE&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s5">&quot;SESSION_COOKIE_SAMESITE&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s5">&quot;SESSION_REFRESH_EACH_REQUEST&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s5">&quot;MAX_CONTENT_LENGTH&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s5">&quot;SEND_FILE_MAX_AGE_DEFAULT&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s5">&quot;TRAP_BAD_REQUEST_ERRORS&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s5">&quot;TRAP_HTTP_EXCEPTIONS&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s5">&quot;EXPLAIN_TEMPLATE_LOADING&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s5">&quot;PREFERRED_URL_SCHEME&quot;</span><span class="s1">: </span><span class="s5">&quot;http&quot;</span><span class="s0">,</span>
            <span class="s5">&quot;JSON_AS_ASCII&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s5">&quot;JSON_SORT_KEYS&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s5">&quot;JSONIFY_PRETTYPRINT_REGULAR&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s5">&quot;JSONIFY_MIMETYPE&quot;</span><span class="s1">: </span><span class="s5">&quot;application/json&quot;</span><span class="s0">,</span>
            <span class="s5">&quot;TEMPLATES_AUTO_RELOAD&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s5">&quot;MAX_COOKIE_SIZE&quot;</span><span class="s1">: </span><span class="s2">4093</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>

    <span class="s4">#: The rule object to use for URL rules created.  This is used by</span>
    <span class="s4">#: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.</span>
    <span class="s4">#:</span>
    <span class="s4">#: .. versionadded:: 0.7</span>
    <span class="s1">url_rule_class = Rule</span>

    <span class="s4">#: The map object to use for storing the URL rules and routing</span>
    <span class="s4">#: configuration parameters. Defaults to :class:`werkzeug.routing.Map`.</span>
    <span class="s4">#:</span>
    <span class="s4">#: .. versionadded:: 1.1.0</span>
    <span class="s1">url_map_class = Map</span>

    <span class="s4">#: The :meth:`test_client` method creates an instance of this test</span>
    <span class="s4">#: client class. Defaults to :class:`~flask.testing.FlaskClient`.</span>
    <span class="s4">#:</span>
    <span class="s4">#: .. versionadded:: 0.7</span>
    <span class="s1">test_client_class: t.Optional[t.Type[</span><span class="s5">&quot;FlaskClient&quot;</span><span class="s1">]] = </span><span class="s0">None</span>

    <span class="s4">#: The :class:`~click.testing.CliRunner` subclass, by default</span>
    <span class="s4">#: :class:`~flask.testing.FlaskCliRunner` that is used by</span>
    <span class="s4">#: :meth:`test_cli_runner`. Its ``__init__`` method should take a</span>
    <span class="s4">#: Flask app object as the first argument.</span>
    <span class="s4">#:</span>
    <span class="s4">#: .. versionadded:: 1.0</span>
    <span class="s1">test_cli_runner_class: t.Optional[t.Type[</span><span class="s5">&quot;FlaskCliRunner&quot;</span><span class="s1">]] = </span><span class="s0">None</span>

    <span class="s4">#: the session interface to use.  By default an instance of</span>
    <span class="s4">#: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.</span>
    <span class="s4">#:</span>
    <span class="s4">#: .. versionadded:: 0.8</span>
    <span class="s1">session_interface = SecureCookieSessionInterface()</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">import_name: str</span><span class="s0">,</span>
        <span class="s1">static_url_path: t.Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">static_folder: t.Optional[t.Union[str</span><span class="s0">, </span><span class="s1">os.PathLike]] = </span><span class="s5">&quot;static&quot;</span><span class="s0">,</span>
        <span class="s1">static_host: t.Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">host_matching: bool = </span><span class="s0">False,</span>
        <span class="s1">subdomain_matching: bool = </span><span class="s0">False,</span>
        <span class="s1">template_folder: t.Optional[str] = </span><span class="s5">&quot;templates&quot;</span><span class="s0">,</span>
        <span class="s1">instance_path: t.Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">instance_relative_config: bool = </span><span class="s0">False,</span>
        <span class="s1">root_path: t.Optional[str] = </span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">import_name=import_name</span><span class="s0">,</span>
            <span class="s1">static_folder=static_folder</span><span class="s0">,</span>
            <span class="s1">static_url_path=static_url_path</span><span class="s0">,</span>
            <span class="s1">template_folder=template_folder</span><span class="s0">,</span>
            <span class="s1">root_path=root_path</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">instance_path </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">instance_path = self.auto_find_instance_path()</span>
        <span class="s0">elif not </span><span class="s1">os.path.isabs(instance_path):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s5">&quot;If an instance path is provided it must be absolute.&quot;</span>
                <span class="s5">&quot; A relative path was given instead.&quot;</span>
            <span class="s1">)</span>

        <span class="s4">#: Holds the path to the instance folder.</span>
        <span class="s4">#:</span>
        <span class="s4">#: .. versionadded:: 0.8</span>
        <span class="s1">self.instance_path = instance_path</span>

        <span class="s4">#: The configuration dictionary as :class:`Config`.  This behaves</span>
        <span class="s4">#: exactly like a regular dictionary but supports additional methods</span>
        <span class="s4">#: to load a config from files.</span>
        <span class="s1">self.config = self.make_config(instance_relative_config)</span>

        <span class="s4">#: A list of functions that are called when :meth:`url_for` raises a</span>
        <span class="s4">#: :exc:`~werkzeug.routing.BuildError`.  Each function registered here</span>
        <span class="s4">#: is called with `error`, `endpoint` and `values`.  If a function</span>
        <span class="s4">#: returns ``None`` or raises a :exc:`BuildError` the next function is</span>
        <span class="s4">#: tried.</span>
        <span class="s4">#:</span>
        <span class="s4">#: .. versionadded:: 0.9</span>
        <span class="s1">self.url_build_error_handlers: t.List[</span>
            <span class="s1">t.Callable[[Exception</span><span class="s0">, </span><span class="s1">str</span><span class="s0">, </span><span class="s1">dict]</span><span class="s0">, </span><span class="s1">str]</span>
        <span class="s1">] = []</span>

        <span class="s4">#: A list of functions that will be called at the beginning of the</span>
        <span class="s4">#: first request to this instance. To register a function, use the</span>
        <span class="s4">#: :meth:`before_first_request` decorator.</span>
        <span class="s4">#:</span>
        <span class="s4">#: .. versionadded:: 0.8</span>
        <span class="s1">self.before_first_request_funcs: t.List[BeforeFirstRequestCallable] = []</span>

        <span class="s4">#: A list of functions that are called when the application context</span>
        <span class="s4">#: is destroyed.  Since the application context is also torn down</span>
        <span class="s4">#: if the request ends this is the place to store code that disconnects</span>
        <span class="s4">#: from databases.</span>
        <span class="s4">#:</span>
        <span class="s4">#: .. versionadded:: 0.9</span>
        <span class="s1">self.teardown_appcontext_funcs: t.List[TeardownCallable] = []</span>

        <span class="s4">#: A list of shell context processor functions that should be run</span>
        <span class="s4">#: when a shell context is created.</span>
        <span class="s4">#:</span>
        <span class="s4">#: .. versionadded:: 0.11</span>
        <span class="s1">self.shell_context_processors: t.List[t.Callable[[]</span><span class="s0">, </span><span class="s1">t.Dict[str</span><span class="s0">, </span><span class="s1">t.Any]]] = []</span>

        <span class="s4">#: Maps registered blueprint names to blueprint objects. The</span>
        <span class="s4">#: dict retains the order the blueprints were registered in.</span>
        <span class="s4">#: Blueprints can be registered multiple times, this dict does</span>
        <span class="s4">#: not track how often they were attached.</span>
        <span class="s4">#:</span>
        <span class="s4">#: .. versionadded:: 0.7</span>
        <span class="s1">self.blueprints: t.Dict[str</span><span class="s0">, </span><span class="s5">&quot;Blueprint&quot;</span><span class="s1">] = {}</span>

        <span class="s4">#: a place where extensions can store application specific state.  For</span>
        <span class="s4">#: example this is where an extension could store database engines and</span>
        <span class="s4">#: similar things.</span>
        <span class="s4">#:</span>
        <span class="s4">#: The key must match the name of the extension module. For example in</span>
        <span class="s4">#: case of a &quot;Flask-Foo&quot; extension in `flask_foo`, the key would be</span>
        <span class="s4">#: ``'foo'``.</span>
        <span class="s4">#:</span>
        <span class="s4">#: .. versionadded:: 0.7</span>
        <span class="s1">self.extensions: dict = {}</span>

        <span class="s4">#: The :class:`~werkzeug.routing.Map` for this instance.  You can use</span>
        <span class="s4">#: this to change the routing converters after the class was created</span>
        <span class="s4">#: but before any routes are connected.  Example::</span>
        <span class="s4">#:</span>
        <span class="s4">#:    from werkzeug.routing import BaseConverter</span>
        <span class="s4">#:</span>
        <span class="s4">#:    class ListConverter(BaseConverter):</span>
        <span class="s4">#:        def to_python(self, value):</span>
        <span class="s4">#:            return value.split(',')</span>
        <span class="s4">#:        def to_url(self, values):</span>
        <span class="s4">#:            return ','.join(super(ListConverter, self).to_url(value)</span>
        <span class="s4">#:                            for value in values)</span>
        <span class="s4">#:</span>
        <span class="s4">#:    app = Flask(__name__)</span>
        <span class="s4">#:    app.url_map.converters['list'] = ListConverter</span>
        <span class="s1">self.url_map = self.url_map_class()</span>

        <span class="s1">self.url_map.host_matching = host_matching</span>
        <span class="s1">self.subdomain_matching = subdomain_matching</span>

        <span class="s4"># tracks internally if the application already handled at least one</span>
        <span class="s4"># request.</span>
        <span class="s1">self._got_first_request = </span><span class="s0">False</span>
        <span class="s1">self._before_request_lock = Lock()</span>

        <span class="s4"># Add a static route using the provided static_url_path, static_host,</span>
        <span class="s4"># and static_folder if there is a configured static_folder.</span>
        <span class="s4"># Note we do this without checking if static_folder exists.</span>
        <span class="s4"># For one, it might be created while the server is running (e.g. during</span>
        <span class="s4"># development). Also, Google App Engine stores static files somewhere</span>
        <span class="s0">if </span><span class="s1">self.has_static_folder:</span>
            <span class="s0">assert </span><span class="s1">(</span>
                <span class="s1">bool(static_host) == host_matching</span>
            <span class="s1">)</span><span class="s0">, </span><span class="s5">&quot;Invalid static_host/host_matching combination&quot;</span>
            <span class="s4"># Use a weakref to avoid creating a reference cycle between the app</span>
            <span class="s4"># and the view function (see #3761).</span>
            <span class="s1">self_ref = weakref.ref(self)</span>
            <span class="s1">self.add_url_rule(</span>
                <span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">self.static_url_path</span><span class="s0">}</span><span class="s5">/&lt;path:filename&gt;&quot;</span><span class="s0">,</span>
                <span class="s1">endpoint=</span><span class="s5">&quot;static&quot;</span><span class="s0">,</span>
                <span class="s1">host=static_host</span><span class="s0">,</span>
                <span class="s1">view_func=</span><span class="s0">lambda </span><span class="s1">**kw: self_ref().send_static_file(**kw)</span><span class="s0">,  </span><span class="s4"># type: ignore # noqa: B950</span>
            <span class="s1">)</span>

        <span class="s4"># Set the name of the Click group in case someone wants to add</span>
        <span class="s4"># the app's commands to another CLI tool.</span>
        <span class="s1">self.cli.name = self.name</span>

    <span class="s0">def </span><span class="s1">_is_setup_finished(self) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">self.debug </span><span class="s0">and </span><span class="s1">self._got_first_request</span>

    <span class="s1">@locked_cached_property</span>
    <span class="s0">def </span><span class="s1">name(self) -&gt; str:  </span><span class="s4"># type: ignore</span>
        <span class="s3">&quot;&quot;&quot;The name of the application.  This is usually the import name 
        with the difference that it's guessed from the run file if the 
        import name is main.  This name is used as a display name when 
        Flask needs the name of the application.  It can be set and overridden 
        to change the value. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.import_name == </span><span class="s5">&quot;__main__&quot;</span><span class="s1">:</span>
            <span class="s1">fn = getattr(sys.modules[</span><span class="s5">&quot;__main__&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s5">&quot;__file__&quot;</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">fn </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s5">&quot;__main__&quot;</span>
            <span class="s0">return </span><span class="s1">os.path.splitext(os.path.basename(fn))[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">self.import_name</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">propagate_exceptions(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;Returns the value of the ``PROPAGATE_EXCEPTIONS`` configuration 
        value in case it's set, otherwise a sensible default is returned. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s1">rv = self.config[</span><span class="s5">&quot;PROPAGATE_EXCEPTIONS&quot;</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">rv </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">rv</span>
        <span class="s0">return </span><span class="s1">self.testing </span><span class="s0">or </span><span class="s1">self.debug</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">preserve_context_on_exception(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;Returns the value of the ``PRESERVE_CONTEXT_ON_EXCEPTION`` 
        configuration value in case it's set, otherwise a sensible default 
        is returned. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s1">rv = self.config[</span><span class="s5">&quot;PRESERVE_CONTEXT_ON_EXCEPTION&quot;</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">rv </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">rv</span>
        <span class="s0">return </span><span class="s1">self.debug</span>

    <span class="s1">@locked_cached_property</span>
    <span class="s0">def </span><span class="s1">logger(self) -&gt; logging.Logger:</span>
        <span class="s3">&quot;&quot;&quot;A standard Python :class:`~logging.Logger` for the app, with 
        the same name as :attr:`name`. 
 
        In debug mode, the logger's :attr:`~logging.Logger.level` will 
        be set to :data:`~logging.DEBUG`. 
 
        If there are no handlers configured, a default handler will be 
        added. See :doc:`/logging` for more information. 
 
        .. versionchanged:: 1.1.0 
            The logger takes the same name as :attr:`name` rather than 
            hard-coding ``&quot;flask.app&quot;``. 
 
        .. versionchanged:: 1.0.0 
            Behavior was simplified. The logger is always named 
            ``&quot;flask.app&quot;``. The level is only set during configuration, 
            it doesn't check ``app.debug`` each time. Only one format is 
            used, not different ones depending on ``app.debug``. No 
            handlers are removed, and a handler is only added if no 
            handlers are already configured. 
 
        .. versionadded:: 0.3 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">create_logger(self)</span>

    <span class="s1">@locked_cached_property</span>
    <span class="s0">def </span><span class="s1">jinja_env(self) -&gt; Environment:</span>
        <span class="s3">&quot;&quot;&quot;The Jinja environment used to load templates. 
 
        The environment is created the first time this property is 
        accessed. Changing :attr:`jinja_options` after that will have no 
        effect. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.create_jinja_environment()</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">got_first_request(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;This attribute is set to ``True`` if the application started 
        handling the first request. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._got_first_request</span>

    <span class="s0">def </span><span class="s1">make_config(self</span><span class="s0">, </span><span class="s1">instance_relative: bool = </span><span class="s0">False</span><span class="s1">) -&gt; Config:</span>
        <span class="s3">&quot;&quot;&quot;Used to create the config attribute by the Flask constructor. 
        The `instance_relative` parameter is passed in from the constructor 
        of Flask (there named `instance_relative_config`) and indicates if 
        the config should be relative to the instance path or the root path 
        of the application. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s1">root_path = self.root_path</span>
        <span class="s0">if </span><span class="s1">instance_relative:</span>
            <span class="s1">root_path = self.instance_path</span>
        <span class="s1">defaults = dict(self.default_config)</span>
        <span class="s1">defaults[</span><span class="s5">&quot;ENV&quot;</span><span class="s1">] = get_env()</span>
        <span class="s1">defaults[</span><span class="s5">&quot;DEBUG&quot;</span><span class="s1">] = get_debug_flag()</span>
        <span class="s0">return </span><span class="s1">self.config_class(root_path</span><span class="s0">, </span><span class="s1">defaults)</span>

    <span class="s0">def </span><span class="s1">auto_find_instance_path(self) -&gt; str:</span>
        <span class="s3">&quot;&quot;&quot;Tries to locate the instance path if it was not provided to the 
        constructor of the application class.  It will basically calculate 
        the path to a folder named ``instance`` next to your main file or 
        the package. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s1">prefix</span><span class="s0">, </span><span class="s1">package_path = find_package(self.import_name)</span>
        <span class="s0">if </span><span class="s1">prefix </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">os.path.join(package_path</span><span class="s0">, </span><span class="s5">&quot;instance&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">os.path.join(prefix</span><span class="s0">, </span><span class="s5">&quot;var&quot;</span><span class="s0">, </span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">self.name</span><span class="s0">}</span><span class="s5">-instance&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">open_instance_resource(self</span><span class="s0">, </span><span class="s1">resource: str</span><span class="s0">, </span><span class="s1">mode: str = </span><span class="s5">&quot;rb&quot;</span><span class="s1">) -&gt; t.IO[t.AnyStr]:</span>
        <span class="s3">&quot;&quot;&quot;Opens a resource from the application's instance folder 
        (:attr:`instance_path`).  Otherwise works like 
        :meth:`open_resource`.  Instance resources can also be opened for 
        writing. 
 
        :param resource: the name of the resource.  To access resources within 
                         subfolders use forward slashes as separator. 
        :param mode: resource file opening mode, default is 'rb'. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">open(os.path.join(self.instance_path</span><span class="s0">, </span><span class="s1">resource)</span><span class="s0">, </span><span class="s1">mode)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">templates_auto_reload(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;Reload templates when they are changed. Used by 
        :meth:`create_jinja_environment`. 
 
        This attribute can be configured with :data:`TEMPLATES_AUTO_RELOAD`. If 
        not set, it will be enabled in debug mode. 
 
        .. versionadded:: 1.0 
            This property was added but the underlying config and behavior 
            already existed. 
        &quot;&quot;&quot;</span>
        <span class="s1">rv = self.config[</span><span class="s5">&quot;TEMPLATES_AUTO_RELOAD&quot;</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">rv </span><span class="s0">if </span><span class="s1">rv </span><span class="s0">is not None else </span><span class="s1">self.debug</span>

    <span class="s1">@templates_auto_reload.setter</span>
    <span class="s0">def </span><span class="s1">templates_auto_reload(self</span><span class="s0">, </span><span class="s1">value: bool) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.config[</span><span class="s5">&quot;TEMPLATES_AUTO_RELOAD&quot;</span><span class="s1">] = value</span>

    <span class="s0">def </span><span class="s1">create_jinja_environment(self) -&gt; Environment:</span>
        <span class="s3">&quot;&quot;&quot;Create the Jinja environment based on :attr:`jinja_options` 
        and the various Jinja-related methods of the app. Changing 
        :attr:`jinja_options` after this will have no effect. Also adds 
        Flask-related globals and filters to the environment. 
 
        .. versionchanged:: 0.11 
           ``Environment.auto_reload`` set in accordance with 
           ``TEMPLATES_AUTO_RELOAD`` configuration option. 
 
        .. versionadded:: 0.5 
        &quot;&quot;&quot;</span>
        <span class="s1">options = dict(self.jinja_options)</span>

        <span class="s0">if </span><span class="s5">&quot;autoescape&quot; </span><span class="s0">not in </span><span class="s1">options:</span>
            <span class="s1">options[</span><span class="s5">&quot;autoescape&quot;</span><span class="s1">] = self.select_jinja_autoescape</span>

        <span class="s0">if </span><span class="s5">&quot;auto_reload&quot; </span><span class="s0">not in </span><span class="s1">options:</span>
            <span class="s1">options[</span><span class="s5">&quot;auto_reload&quot;</span><span class="s1">] = self.templates_auto_reload</span>

        <span class="s1">rv = self.jinja_environment(self</span><span class="s0">, </span><span class="s1">**options)</span>
        <span class="s1">rv.globals.update(</span>
            <span class="s1">url_for=url_for</span><span class="s0">,</span>
            <span class="s1">get_flashed_messages=get_flashed_messages</span><span class="s0">,</span>
            <span class="s1">config=self.config</span><span class="s0">,</span>
            <span class="s4"># request, session and g are normally added with the</span>
            <span class="s4"># context processor for efficiency reasons but for imported</span>
            <span class="s4"># templates we also want the proxies in there.</span>
            <span class="s1">request=request</span><span class="s0">,</span>
            <span class="s1">session=session</span><span class="s0">,</span>
            <span class="s1">g=g</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">rv.policies[</span><span class="s5">&quot;json.dumps_function&quot;</span><span class="s1">] = json.dumps</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">create_global_jinja_loader(self) -&gt; DispatchingJinjaLoader:</span>
        <span class="s3">&quot;&quot;&quot;Creates the loader for the Jinja2 environment.  Can be used to 
        override just the loader and keeping the rest unchanged.  It's 
        discouraged to override this function.  Instead one should override 
        the :meth:`jinja_loader` function instead. 
 
        The global loader dispatches between the loaders of the application 
        and the individual blueprints. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">DispatchingJinjaLoader(self)</span>

    <span class="s0">def </span><span class="s1">select_jinja_autoescape(self</span><span class="s0">, </span><span class="s1">filename: str) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;Returns ``True`` if autoescaping should be active for the given 
        template name. If no template name is given, returns `True`. 
 
        .. versionadded:: 0.5 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">filename </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return True</span>
        <span class="s0">return </span><span class="s1">filename.endswith((</span><span class="s5">&quot;.html&quot;</span><span class="s0">, </span><span class="s5">&quot;.htm&quot;</span><span class="s0">, </span><span class="s5">&quot;.xml&quot;</span><span class="s0">, </span><span class="s5">&quot;.xhtml&quot;</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">update_template_context(self</span><span class="s0">, </span><span class="s1">context: dict) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Update the template context with some commonly used variables. 
        This injects request, session, config and g into the template 
        context as well as everything template context processors want 
        to inject.  Note that the as of Flask 0.6, the original values 
        in the context will not be overridden if a context processor 
        decides to return a value with the same key. 
 
        :param context: the context as a dictionary that is updated in place 
                        to add extra variables. 
        &quot;&quot;&quot;</span>
        <span class="s1">names: t.Iterable[t.Optional[str]] = (</span><span class="s0">None,</span><span class="s1">)</span>

        <span class="s4"># A template may be rendered outside a request context.</span>
        <span class="s0">if </span><span class="s1">request:</span>
            <span class="s1">names = chain(names</span><span class="s0">, </span><span class="s1">reversed(request.blueprints))</span>

        <span class="s4"># The values passed to render_template take precedence. Keep a</span>
        <span class="s4"># copy to re-apply after all context functions.</span>
        <span class="s1">orig_ctx = context.copy()</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names:</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self.template_context_processors:</span>
                <span class="s0">for </span><span class="s1">func </span><span class="s0">in </span><span class="s1">self.template_context_processors[name]:</span>
                    <span class="s1">context.update(func())</span>

        <span class="s1">context.update(orig_ctx)</span>

    <span class="s0">def </span><span class="s1">make_shell_context(self) -&gt; dict:</span>
        <span class="s3">&quot;&quot;&quot;Returns the shell context for an interactive shell for this 
        application.  This runs all the registered shell context 
        processors. 
 
        .. versionadded:: 0.11 
        &quot;&quot;&quot;</span>
        <span class="s1">rv = {</span><span class="s5">&quot;app&quot;</span><span class="s1">: self</span><span class="s0">, </span><span class="s5">&quot;g&quot;</span><span class="s1">: g}</span>
        <span class="s0">for </span><span class="s1">processor </span><span class="s0">in </span><span class="s1">self.shell_context_processors:</span>
            <span class="s1">rv.update(processor())</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s4">#: What environment the app is running in. Flask and extensions may</span>
    <span class="s4">#: enable behaviors based on the environment, such as enabling debug</span>
    <span class="s4">#: mode. This maps to the :data:`ENV` config key. This is set by the</span>
    <span class="s4">#: :envvar:`FLASK_ENV` environment variable and may not behave as</span>
    <span class="s4">#: expected if set in code.</span>
    <span class="s4">#:</span>
    <span class="s4">#: **Do not enable development when deploying in production.**</span>
    <span class="s4">#:</span>
    <span class="s4">#: Default: ``'production'``</span>
    <span class="s1">env = ConfigAttribute(</span><span class="s5">&quot;ENV&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">debug(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;Whether debug mode is enabled. When using ``flask run`` to start 
        the development server, an interactive debugger will be shown for 
        unhandled exceptions, and the server will be reloaded when code 
        changes. This maps to the :data:`DEBUG` config key. This is 
        enabled when :attr:`env` is ``'development'`` and is overridden 
        by the ``FLASK_DEBUG`` environment variable. It may not behave as 
        expected if set in code. 
 
        **Do not enable debug mode when deploying in production.** 
 
        Default: ``True`` if :attr:`env` is ``'development'``, or 
        ``False`` otherwise. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.config[</span><span class="s5">&quot;DEBUG&quot;</span><span class="s1">]</span>

    <span class="s1">@debug.setter</span>
    <span class="s0">def </span><span class="s1">debug(self</span><span class="s0">, </span><span class="s1">value: bool) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.config[</span><span class="s5">&quot;DEBUG&quot;</span><span class="s1">] = value</span>
        <span class="s1">self.jinja_env.auto_reload = self.templates_auto_reload</span>

    <span class="s0">def </span><span class="s1">run(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">host: t.Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">port: t.Optional[int] = </span><span class="s0">None,</span>
        <span class="s1">debug: t.Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">load_dotenv: bool = </span><span class="s0">True,</span>
        <span class="s1">**options: t.Any</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Runs the application on a local development server. 
 
        Do not use ``run()`` in a production setting. It is not intended to 
        meet security and performance requirements for a production server. 
        Instead, see :doc:`/deploying/index` for WSGI server recommendations. 
 
        If the :attr:`debug` flag is set the server will automatically reload 
        for code changes and show a debugger in case an exception happened. 
 
        If you want to run the application in debug mode, but disable the 
        code execution on the interactive debugger, you can pass 
        ``use_evalex=False`` as parameter.  This will keep the debugger's 
        traceback screen active, but disable code execution. 
 
        It is not recommended to use this function for development with 
        automatic reloading as this is badly supported.  Instead you should 
        be using the :command:`flask` command line script's ``run`` support. 
 
        .. admonition:: Keep in Mind 
 
           Flask will suppress any server error with a generic error page 
           unless it is in debug mode.  As such to enable just the 
           interactive debugger without the code reloading, you have to 
           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``. 
           Setting ``use_debugger`` to ``True`` without being in debug mode 
           won't catch any exceptions because there won't be any to 
           catch. 
 
        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to 
            have the server available externally as well. Defaults to 
            ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable 
            if present. 
        :param port: the port of the webserver. Defaults to ``5000`` or the 
            port defined in the ``SERVER_NAME`` config variable if present. 
        :param debug: if given, enable or disable debug mode. See 
            :attr:`debug`. 
        :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv` 
            files to set environment variables. Will also change the working 
            directory to the directory containing the first file found. 
        :param options: the options to be forwarded to the underlying Werkzeug 
            server. See :func:`werkzeug.serving.run_simple` for more 
            information. 
 
        .. versionchanged:: 1.0 
            If installed, python-dotenv will be used to load environment 
            variables from :file:`.env` and :file:`.flaskenv` files. 
 
            If set, the :envvar:`FLASK_ENV` and :envvar:`FLASK_DEBUG` 
            environment variables will override :attr:`env` and 
            :attr:`debug`. 
 
            Threaded mode is enabled by default. 
 
        .. versionchanged:: 0.10 
            The default port is now picked from the ``SERVER_NAME`` 
            variable. 
        &quot;&quot;&quot;</span>
        <span class="s4"># Change this into a no-op if the server is invoked from the</span>
        <span class="s4"># command line. Have a look at cli.py for more information.</span>
        <span class="s0">if </span><span class="s1">os.environ.get(</span><span class="s5">&quot;FLASK_RUN_FROM_CLI&quot;</span><span class="s1">) == </span><span class="s5">&quot;true&quot;</span><span class="s1">:</span>
            <span class="s0">from </span><span class="s1">.debughelpers </span><span class="s0">import </span><span class="s1">explain_ignored_app_run</span>

            <span class="s1">explain_ignored_app_run()</span>
            <span class="s0">return</span>

        <span class="s0">if </span><span class="s1">get_load_dotenv(load_dotenv):</span>
            <span class="s1">cli.load_dotenv()</span>

            <span class="s4"># if set, let env vars override previous values</span>
            <span class="s0">if </span><span class="s5">&quot;FLASK_ENV&quot; </span><span class="s0">in </span><span class="s1">os.environ:</span>
                <span class="s1">self.env = get_env()</span>
                <span class="s1">self.debug = get_debug_flag()</span>
            <span class="s0">elif </span><span class="s5">&quot;FLASK_DEBUG&quot; </span><span class="s0">in </span><span class="s1">os.environ:</span>
                <span class="s1">self.debug = get_debug_flag()</span>

        <span class="s4"># debug passed to method overrides all other sources</span>
        <span class="s0">if </span><span class="s1">debug </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.debug = bool(debug)</span>

        <span class="s1">server_name = self.config.get(</span><span class="s5">&quot;SERVER_NAME&quot;</span><span class="s1">)</span>
        <span class="s1">sn_host = sn_port = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">server_name:</span>
            <span class="s1">sn_host</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">sn_port = server_name.partition(</span><span class="s5">&quot;:&quot;</span><span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">host:</span>
            <span class="s0">if </span><span class="s1">sn_host:</span>
                <span class="s1">host = sn_host</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">host = </span><span class="s5">&quot;127.0.0.1&quot;</span>

        <span class="s0">if </span><span class="s1">port </span><span class="s0">or </span><span class="s1">port == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">port = int(port)</span>
        <span class="s0">elif </span><span class="s1">sn_port:</span>
            <span class="s1">port = int(sn_port)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">port = </span><span class="s2">5000</span>

        <span class="s1">options.setdefault(</span><span class="s5">&quot;use_reloader&quot;</span><span class="s0">, </span><span class="s1">self.debug)</span>
        <span class="s1">options.setdefault(</span><span class="s5">&quot;use_debugger&quot;</span><span class="s0">, </span><span class="s1">self.debug)</span>
        <span class="s1">options.setdefault(</span><span class="s5">&quot;threaded&quot;</span><span class="s0">, True</span><span class="s1">)</span>

        <span class="s1">cli.show_server_banner(self.env</span><span class="s0">, </span><span class="s1">self.debug</span><span class="s0">, </span><span class="s1">self.name</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s0">from </span><span class="s1">werkzeug.serving </span><span class="s0">import </span><span class="s1">run_simple</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">run_simple(t.cast(str</span><span class="s0">, </span><span class="s1">host)</span><span class="s0">, </span><span class="s1">port</span><span class="s0">, </span><span class="s1">self</span><span class="s0">, </span><span class="s1">**options)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s4"># reset the first request information if the development server</span>
            <span class="s4"># reset normally.  This makes it possible to restart the server</span>
            <span class="s4"># without reloader and that stuff from an interactive shell.</span>
            <span class="s1">self._got_first_request = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">test_client(self</span><span class="s0">, </span><span class="s1">use_cookies: bool = </span><span class="s0">True, </span><span class="s1">**kwargs: t.Any) -&gt; </span><span class="s5">&quot;FlaskClient&quot;</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Creates a test client for this application.  For information 
        about unit testing head over to :doc:`/testing`. 
 
        Note that if you are testing for assertions or exceptions in your 
        application code, you must set ``app.testing = True`` in order for the 
        exceptions to propagate to the test client.  Otherwise, the exception 
        will be handled by the application (not visible to the test client) and 
        the only indication of an AssertionError or other exception will be a 
        500 status code response to the test client.  See the :attr:`testing` 
        attribute.  For example:: 
 
            app.testing = True 
            client = app.test_client() 
 
        The test client can be used in a ``with`` block to defer the closing down 
        of the context until the end of the ``with`` block.  This is useful if 
        you want to access the context locals for testing:: 
 
            with app.test_client() as c: 
                rv = c.get('/?vodka=42') 
                assert request.args['vodka'] == '42' 
 
        Additionally, you may pass optional keyword arguments that will then 
        be passed to the application's :attr:`test_client_class` constructor. 
        For example:: 
 
            from flask.testing import FlaskClient 
 
            class CustomClient(FlaskClient): 
                def __init__(self, *args, **kwargs): 
                    self._authentication = kwargs.pop(&quot;authentication&quot;) 
                    super(CustomClient,self).__init__( *args, **kwargs) 
 
            app.test_client_class = CustomClient 
            client = app.test_client(authentication='Basic ....') 
 
        See :class:`~flask.testing.FlaskClient` for more information. 
 
        .. versionchanged:: 0.4 
           added support for ``with`` block usage for the client. 
 
        .. versionadded:: 0.7 
           The `use_cookies` parameter was added as well as the ability 
           to override the client to be used by setting the 
           :attr:`test_client_class` attribute. 
 
        .. versionchanged:: 0.11 
           Added `**kwargs` to support passing additional keyword arguments to 
           the constructor of :attr:`test_client_class`. 
        &quot;&quot;&quot;</span>
        <span class="s1">cls = self.test_client_class</span>
        <span class="s0">if </span><span class="s1">cls </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">from </span><span class="s1">.testing </span><span class="s0">import </span><span class="s1">FlaskClient </span><span class="s0">as </span><span class="s1">cls  </span><span class="s4"># type: ignore</span>
        <span class="s0">return </span><span class="s1">cls(  </span><span class="s4"># type: ignore</span>
            <span class="s1">self</span><span class="s0">, </span><span class="s1">self.response_class</span><span class="s0">, </span><span class="s1">use_cookies=use_cookies</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_cli_runner(self</span><span class="s0">, </span><span class="s1">**kwargs: t.Any) -&gt; </span><span class="s5">&quot;FlaskCliRunner&quot;</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Create a CLI runner for testing CLI commands. 
        See :ref:`testing-cli`. 
 
        Returns an instance of :attr:`test_cli_runner_class`, by default 
        :class:`~flask.testing.FlaskCliRunner`. The Flask app object is 
        passed as the first argument. 
 
        .. versionadded:: 1.0 
        &quot;&quot;&quot;</span>
        <span class="s1">cls = self.test_cli_runner_class</span>

        <span class="s0">if </span><span class="s1">cls </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">from </span><span class="s1">.testing </span><span class="s0">import </span><span class="s1">FlaskCliRunner </span><span class="s0">as </span><span class="s1">cls  </span><span class="s4"># type: ignore</span>

        <span class="s0">return </span><span class="s1">cls(self</span><span class="s0">, </span><span class="s1">**kwargs)  </span><span class="s4"># type: ignore</span>

    <span class="s1">@setupmethod</span>
    <span class="s0">def </span><span class="s1">register_blueprint(self</span><span class="s0">, </span><span class="s1">blueprint: </span><span class="s5">&quot;Blueprint&quot;</span><span class="s0">, </span><span class="s1">**options: t.Any) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Register a :class:`~flask.Blueprint` on the application. Keyword 
        arguments passed to this method will override the defaults set on the 
        blueprint. 
 
        Calls the blueprint's :meth:`~flask.Blueprint.register` method after 
        recording the blueprint in the application's :attr:`blueprints`. 
 
        :param blueprint: The blueprint to register. 
        :param url_prefix: Blueprint routes will be prefixed with this. 
        :param subdomain: Blueprint routes will match on this subdomain. 
        :param url_defaults: Blueprint routes will use these default values for 
            view arguments. 
        :param options: Additional keyword arguments are passed to 
            :class:`~flask.blueprints.BlueprintSetupState`. They can be 
            accessed in :meth:`~flask.Blueprint.record` callbacks. 
 
        .. versionchanged:: 2.0.1 
            The ``name`` option can be used to change the (pre-dotted) 
            name the blueprint is registered with. This allows the same 
            blueprint to be registered multiple times with unique names 
            for ``url_for``. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s1">blueprint.register(self</span><span class="s0">, </span><span class="s1">options)</span>

    <span class="s0">def </span><span class="s1">iter_blueprints(self) -&gt; t.ValuesView[</span><span class="s5">&quot;Blueprint&quot;</span><span class="s1">]:</span>
        <span class="s3">&quot;&quot;&quot;Iterates over all blueprints by the order they were registered. 
 
        .. versionadded:: 0.11 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.blueprints.values()</span>

    <span class="s1">@setupmethod</span>
    <span class="s0">def </span><span class="s1">add_url_rule(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">rule: str</span><span class="s0">,</span>
        <span class="s1">endpoint: t.Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">view_func: t.Optional[t.Callable] = </span><span class="s0">None,</span>
        <span class="s1">provide_automatic_options: t.Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">**options: t.Any</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">endpoint </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">endpoint = _endpoint_from_view_func(view_func)  </span><span class="s4"># type: ignore</span>
        <span class="s1">options[</span><span class="s5">&quot;endpoint&quot;</span><span class="s1">] = endpoint</span>
        <span class="s1">methods = options.pop(</span><span class="s5">&quot;methods&quot;</span><span class="s0">, None</span><span class="s1">)</span>

        <span class="s4"># if the methods are not given and the view_func object knows its</span>
        <span class="s4"># methods we can use that instead.  If neither exists, we go with</span>
        <span class="s4"># a tuple of only ``GET`` as default.</span>
        <span class="s0">if </span><span class="s1">methods </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">methods = getattr(view_func</span><span class="s0">, </span><span class="s5">&quot;methods&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(</span><span class="s5">&quot;GET&quot;</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">isinstance(methods</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s5">&quot;Allowed methods must be a list of strings, for&quot;</span>
                <span class="s5">' example: @app.route(..., methods=[&quot;POST&quot;])'</span>
            <span class="s1">)</span>
        <span class="s1">methods = {item.upper() </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">methods}</span>

        <span class="s4"># Methods that should always be added</span>
        <span class="s1">required_methods = set(getattr(view_func</span><span class="s0">, </span><span class="s5">&quot;required_methods&quot;</span><span class="s0">, </span><span class="s1">()))</span>

        <span class="s4"># starting with Flask 0.8 the view_func object can disable and</span>
        <span class="s4"># force-enable the automatic options handling.</span>
        <span class="s0">if </span><span class="s1">provide_automatic_options </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">provide_automatic_options = getattr(</span>
                <span class="s1">view_func</span><span class="s0">, </span><span class="s5">&quot;provide_automatic_options&quot;</span><span class="s0">, None</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">provide_automatic_options </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s5">&quot;OPTIONS&quot; </span><span class="s0">not in </span><span class="s1">methods:</span>
                <span class="s1">provide_automatic_options = </span><span class="s0">True</span>
                <span class="s1">required_methods.add(</span><span class="s5">&quot;OPTIONS&quot;</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">provide_automatic_options = </span><span class="s0">False</span>

        <span class="s4"># Add the required methods now.</span>
        <span class="s1">methods |= required_methods</span>

        <span class="s1">rule = self.url_rule_class(rule</span><span class="s0">, </span><span class="s1">methods=methods</span><span class="s0">, </span><span class="s1">**options)</span>
        <span class="s1">rule.provide_automatic_options = provide_automatic_options  </span><span class="s4"># type: ignore</span>

        <span class="s1">self.url_map.add(rule)</span>
        <span class="s0">if </span><span class="s1">view_func </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">old_func = self.view_functions.get(endpoint)</span>
            <span class="s0">if </span><span class="s1">old_func </span><span class="s0">is not None and </span><span class="s1">old_func != view_func:</span>
                <span class="s0">raise </span><span class="s1">AssertionError(</span>
                    <span class="s5">&quot;View function mapping is overwriting an existing&quot;</span>
                    <span class="s5">f&quot; endpoint function: </span><span class="s0">{</span><span class="s1">endpoint</span><span class="s0">}</span><span class="s5">&quot;</span>
                <span class="s1">)</span>
            <span class="s1">self.view_functions[endpoint] = view_func</span>

    <span class="s1">@setupmethod</span>
    <span class="s0">def </span><span class="s1">template_filter(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">name: t.Optional[str] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; t.Callable[[TemplateFilterCallable]</span><span class="s0">, </span><span class="s1">TemplateFilterCallable]:</span>
        <span class="s3">&quot;&quot;&quot;A decorator that is used to register custom template filter. 
        You can specify a name for the filter, otherwise the function 
        name will be used. Example:: 
 
          @app.template_filter() 
          def reverse(s): 
              return s[::-1] 
 
        :param name: the optional name of the filter, otherwise the 
                     function name will be used. 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">decorator(f: TemplateFilterCallable) -&gt; TemplateFilterCallable:</span>
            <span class="s1">self.add_template_filter(f</span><span class="s0">, </span><span class="s1">name=name)</span>
            <span class="s0">return </span><span class="s1">f</span>

        <span class="s0">return </span><span class="s1">decorator</span>

    <span class="s1">@setupmethod</span>
    <span class="s0">def </span><span class="s1">add_template_filter(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">f: TemplateFilterCallable</span><span class="s0">, </span><span class="s1">name: t.Optional[str] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Register a custom template filter.  Works exactly like the 
        :meth:`template_filter` decorator. 
 
        :param name: the optional name of the filter, otherwise the 
                     function name will be used. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.jinja_env.filters[name </span><span class="s0">or </span><span class="s1">f.__name__] = f</span>

    <span class="s1">@setupmethod</span>
    <span class="s0">def </span><span class="s1">template_test(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">name: t.Optional[str] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; t.Callable[[TemplateTestCallable]</span><span class="s0">, </span><span class="s1">TemplateTestCallable]:</span>
        <span class="s3">&quot;&quot;&quot;A decorator that is used to register custom template test. 
        You can specify a name for the test, otherwise the function 
        name will be used. Example:: 
 
          @app.template_test() 
          def is_prime(n): 
              if n == 2: 
                  return True 
              for i in range(2, int(math.ceil(math.sqrt(n))) + 1): 
                  if n % i == 0: 
                      return False 
              return True 
 
        .. versionadded:: 0.10 
 
        :param name: the optional name of the test, otherwise the 
                     function name will be used. 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">decorator(f: TemplateTestCallable) -&gt; TemplateTestCallable:</span>
            <span class="s1">self.add_template_test(f</span><span class="s0">, </span><span class="s1">name=name)</span>
            <span class="s0">return </span><span class="s1">f</span>

        <span class="s0">return </span><span class="s1">decorator</span>

    <span class="s1">@setupmethod</span>
    <span class="s0">def </span><span class="s1">add_template_test(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">f: TemplateTestCallable</span><span class="s0">, </span><span class="s1">name: t.Optional[str] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Register a custom template test.  Works exactly like the 
        :meth:`template_test` decorator. 
 
        .. versionadded:: 0.10 
 
        :param name: the optional name of the test, otherwise the 
                     function name will be used. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.jinja_env.tests[name </span><span class="s0">or </span><span class="s1">f.__name__] = f</span>

    <span class="s1">@setupmethod</span>
    <span class="s0">def </span><span class="s1">template_global(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">name: t.Optional[str] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; t.Callable[[TemplateGlobalCallable]</span><span class="s0">, </span><span class="s1">TemplateGlobalCallable]:</span>
        <span class="s3">&quot;&quot;&quot;A decorator that is used to register a custom template global function. 
        You can specify a name for the global function, otherwise the function 
        name will be used. Example:: 
 
            @app.template_global() 
            def double(n): 
                return 2 * n 
 
        .. versionadded:: 0.10 
 
        :param name: the optional name of the global function, otherwise the 
                     function name will be used. 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">decorator(f: TemplateGlobalCallable) -&gt; TemplateGlobalCallable:</span>
            <span class="s1">self.add_template_global(f</span><span class="s0">, </span><span class="s1">name=name)</span>
            <span class="s0">return </span><span class="s1">f</span>

        <span class="s0">return </span><span class="s1">decorator</span>

    <span class="s1">@setupmethod</span>
    <span class="s0">def </span><span class="s1">add_template_global(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">f: TemplateGlobalCallable</span><span class="s0">, </span><span class="s1">name: t.Optional[str] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Register a custom template global function. Works exactly like the 
        :meth:`template_global` decorator. 
 
        .. versionadded:: 0.10 
 
        :param name: the optional name of the global function, otherwise the 
                     function name will be used. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.jinja_env.globals[name </span><span class="s0">or </span><span class="s1">f.__name__] = f</span>

    <span class="s1">@setupmethod</span>
    <span class="s0">def </span><span class="s1">before_first_request(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">f: BeforeFirstRequestCallable</span>
    <span class="s1">) -&gt; BeforeFirstRequestCallable:</span>
        <span class="s3">&quot;&quot;&quot;Registers a function to be run before the first request to this 
        instance of the application. 
 
        The function will be called without any arguments and its return 
        value is ignored. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s1">self.before_first_request_funcs.append(f)</span>
        <span class="s0">return </span><span class="s1">f</span>

    <span class="s1">@setupmethod</span>
    <span class="s0">def </span><span class="s1">teardown_appcontext(self</span><span class="s0">, </span><span class="s1">f: TeardownCallable) -&gt; TeardownCallable:</span>
        <span class="s3">&quot;&quot;&quot;Registers a function to be called when the application context 
        ends.  These functions are typically also called when the request 
        context is popped. 
 
        Example:: 
 
            ctx = app.app_context() 
            ctx.push() 
            ... 
            ctx.pop() 
 
        When ``ctx.pop()`` is executed in the above example, the teardown 
        functions are called just before the app context moves from the 
        stack of active contexts.  This becomes relevant if you are using 
        such constructs in tests. 
 
        Since a request context typically also manages an application 
        context it would also be called when you pop a request context. 
 
        When a teardown function was called because of an unhandled exception 
        it will be passed an error object. If an :meth:`errorhandler` is 
        registered, it will handle the exception and the teardown will not 
        receive it. 
 
        The return values of teardown functions are ignored. 
 
        .. versionadded:: 0.9 
        &quot;&quot;&quot;</span>
        <span class="s1">self.teardown_appcontext_funcs.append(f)</span>
        <span class="s0">return </span><span class="s1">f</span>

    <span class="s1">@setupmethod</span>
    <span class="s0">def </span><span class="s1">shell_context_processor(self</span><span class="s0">, </span><span class="s1">f: t.Callable) -&gt; t.Callable:</span>
        <span class="s3">&quot;&quot;&quot;Registers a shell context processor function. 
 
        .. versionadded:: 0.11 
        &quot;&quot;&quot;</span>
        <span class="s1">self.shell_context_processors.append(f)</span>
        <span class="s0">return </span><span class="s1">f</span>

    <span class="s0">def </span><span class="s1">_find_error_handler(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">e: Exception</span>
    <span class="s1">) -&gt; t.Optional[</span><span class="s5">&quot;ErrorHandlerCallable[Exception]&quot;</span><span class="s1">]:</span>
        <span class="s3">&quot;&quot;&quot;Return a registered error handler for an exception in this order: 
        blueprint handler for a specific code, app handler for a specific code, 
        blueprint handler for an exception class, app handler for an exception 
        class, or ``None`` if a suitable handler is not found. 
        &quot;&quot;&quot;</span>
        <span class="s1">exc_class</span><span class="s0">, </span><span class="s1">code = self._get_exc_class_and_code(type(e))</span>
        <span class="s1">names = (*request.blueprints</span><span class="s0">, None</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">(code</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">if </span><span class="s1">code </span><span class="s0">is not None else </span><span class="s1">(</span><span class="s0">None,</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names:</span>
                <span class="s1">handler_map = self.error_handler_spec[name][c]</span>

                <span class="s0">if not </span><span class="s1">handler_map:</span>
                    <span class="s0">continue</span>

                <span class="s0">for </span><span class="s1">cls </span><span class="s0">in </span><span class="s1">exc_class.__mro__:</span>
                    <span class="s1">handler = handler_map.get(cls)</span>

                    <span class="s0">if </span><span class="s1">handler </span><span class="s0">is not None</span><span class="s1">:</span>
                        <span class="s0">return </span><span class="s1">handler</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">handle_http_exception(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">e: HTTPException</span>
    <span class="s1">) -&gt; t.Union[HTTPException</span><span class="s0">, </span><span class="s1">ResponseReturnValue]:</span>
        <span class="s3">&quot;&quot;&quot;Handles an HTTP exception.  By default this will invoke the 
        registered error handlers and fall back to returning the 
        exception as response. 
 
        .. versionchanged:: 1.0.3 
            ``RoutingException``, used internally for actions such as 
             slash redirects during routing, is not passed to error 
             handlers. 
 
        .. versionchanged:: 1.0 
            Exceptions are looked up by code *and* by MRO, so 
            ``HTTPException`` subclasses can be handled with a catch-all 
            handler for the base ``HTTPException``. 
 
        .. versionadded:: 0.3 
        &quot;&quot;&quot;</span>
        <span class="s4"># Proxy exceptions don't have error codes.  We want to always return</span>
        <span class="s4"># those unchanged as errors</span>
        <span class="s0">if </span><span class="s1">e.code </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">e</span>

        <span class="s4"># RoutingExceptions are used internally to trigger routing</span>
        <span class="s4"># actions, such as slash redirects raising RequestRedirect. They</span>
        <span class="s4"># are not raised or handled in user code.</span>
        <span class="s0">if </span><span class="s1">isinstance(e</span><span class="s0">, </span><span class="s1">RoutingException):</span>
            <span class="s0">return </span><span class="s1">e</span>

        <span class="s1">handler = self._find_error_handler(e)</span>
        <span class="s0">if </span><span class="s1">handler </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">e</span>
        <span class="s0">return </span><span class="s1">self.ensure_sync(handler)(e)</span>

    <span class="s0">def </span><span class="s1">trap_http_exception(self</span><span class="s0">, </span><span class="s1">e: Exception) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;Checks if an HTTP exception should be trapped or not.  By default 
        this will return ``False`` for all exceptions except for a bad request 
        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It 
        also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``. 
 
        This is called for all HTTP exceptions raised by a view function. 
        If it returns ``True`` for any exception the error handler for this 
        exception is not called and it shows up as regular exception in the 
        traceback.  This is helpful for debugging implicitly raised HTTP 
        exceptions. 
 
        .. versionchanged:: 1.0 
            Bad request errors are not trapped by default in debug mode. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.config[</span><span class="s5">&quot;TRAP_HTTP_EXCEPTIONS&quot;</span><span class="s1">]:</span>
            <span class="s0">return True</span>

        <span class="s1">trap_bad_request = self.config[</span><span class="s5">&quot;TRAP_BAD_REQUEST_ERRORS&quot;</span><span class="s1">]</span>

        <span class="s4"># if unset, trap key errors in debug mode</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">trap_bad_request </span><span class="s0">is None</span>
            <span class="s0">and </span><span class="s1">self.debug</span>
            <span class="s0">and </span><span class="s1">isinstance(e</span><span class="s0">, </span><span class="s1">BadRequestKeyError)</span>
        <span class="s1">):</span>
            <span class="s0">return True</span>

        <span class="s0">if </span><span class="s1">trap_bad_request:</span>
            <span class="s0">return </span><span class="s1">isinstance(e</span><span class="s0">, </span><span class="s1">BadRequest)</span>

        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">handle_user_exception(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">e: Exception</span>
    <span class="s1">) -&gt; t.Union[HTTPException</span><span class="s0">, </span><span class="s1">ResponseReturnValue]:</span>
        <span class="s3">&quot;&quot;&quot;This method is called whenever an exception occurs that 
        should be handled. A special case is :class:`~werkzeug 
        .exceptions.HTTPException` which is forwarded to the 
        :meth:`handle_http_exception` method. This function will either 
        return a response value or reraise the exception with the same 
        traceback. 
 
        .. versionchanged:: 1.0 
            Key errors raised from request data like ``form`` show the 
            bad key in debug mode rather than a generic bad request 
            message. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(e</span><span class="s0">, </span><span class="s1">BadRequestKeyError) </span><span class="s0">and </span><span class="s1">(</span>
            <span class="s1">self.debug </span><span class="s0">or </span><span class="s1">self.config[</span><span class="s5">&quot;TRAP_BAD_REQUEST_ERRORS&quot;</span><span class="s1">]</span>
        <span class="s1">):</span>
            <span class="s1">e.show_exception = </span><span class="s0">True</span>

        <span class="s0">if </span><span class="s1">isinstance(e</span><span class="s0">, </span><span class="s1">HTTPException) </span><span class="s0">and not </span><span class="s1">self.trap_http_exception(e):</span>
            <span class="s0">return </span><span class="s1">self.handle_http_exception(e)</span>

        <span class="s1">handler = self._find_error_handler(e)</span>

        <span class="s0">if </span><span class="s1">handler </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise</span>

        <span class="s0">return </span><span class="s1">self.ensure_sync(handler)(e)</span>

    <span class="s0">def </span><span class="s1">handle_exception(self</span><span class="s0">, </span><span class="s1">e: Exception) -&gt; Response:</span>
        <span class="s3">&quot;&quot;&quot;Handle an exception that did not have an error handler 
        associated with it, or that was raised from an error handler. 
        This always causes a 500 ``InternalServerError``. 
 
        Always sends the :data:`got_request_exception` signal. 
 
        If :attr:`propagate_exceptions` is ``True``, such as in debug 
        mode, the error will be re-raised so that the debugger can 
        display it. Otherwise, the original exception is logged, and 
        an :exc:`~werkzeug.exceptions.InternalServerError` is returned. 
 
        If an error handler is registered for ``InternalServerError`` or 
        ``500``, it will be used. For consistency, the handler will 
        always receive the ``InternalServerError``. The original 
        unhandled exception is available as ``e.original_exception``. 
 
        .. versionchanged:: 1.1.0 
            Always passes the ``InternalServerError`` instance to the 
            handler, setting ``original_exception`` to the unhandled 
            error. 
 
        .. versionchanged:: 1.1.0 
            ``after_request`` functions and other finalization is done 
            even for the default 500 response when there is no handler. 
 
        .. versionadded:: 0.3 
        &quot;&quot;&quot;</span>
        <span class="s1">exc_info = sys.exc_info()</span>
        <span class="s1">got_request_exception.send(self</span><span class="s0">, </span><span class="s1">exception=e)</span>

        <span class="s0">if </span><span class="s1">self.propagate_exceptions:</span>
            <span class="s4"># Re-raise if called with an active exception, otherwise</span>
            <span class="s4"># raise the passed in exception.</span>
            <span class="s0">if </span><span class="s1">exc_info[</span><span class="s2">1</span><span class="s1">] </span><span class="s0">is </span><span class="s1">e:</span>
                <span class="s0">raise</span>

            <span class="s0">raise </span><span class="s1">e</span>

        <span class="s1">self.log_exception(exc_info)</span>
        <span class="s1">server_error: t.Union[InternalServerError</span><span class="s0">, </span><span class="s1">ResponseReturnValue]</span>
        <span class="s1">server_error = InternalServerError(original_exception=e)</span>
        <span class="s1">handler = self._find_error_handler(server_error)</span>

        <span class="s0">if </span><span class="s1">handler </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">server_error = self.ensure_sync(handler)(server_error)</span>

        <span class="s0">return </span><span class="s1">self.finalize_request(server_error</span><span class="s0">, </span><span class="s1">from_error_handler=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">log_exception(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">exc_info: t.Union[</span>
            <span class="s1">t.Tuple[type</span><span class="s0">, </span><span class="s1">BaseException</span><span class="s0">, </span><span class="s1">TracebackType]</span><span class="s0">, </span><span class="s1">t.Tuple[</span><span class="s0">None, None, None</span><span class="s1">]</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Logs an exception.  This is called by :meth:`handle_exception` 
        if debugging is disabled and right before the handler is called. 
        The default implementation logs the exception as error on the 
        :attr:`logger`. 
 
        .. versionadded:: 0.8 
        &quot;&quot;&quot;</span>
        <span class="s1">self.logger.error(</span>
            <span class="s5">f&quot;Exception on </span><span class="s0">{</span><span class="s1">request.path</span><span class="s0">} </span><span class="s5">[</span><span class="s0">{</span><span class="s1">request.method</span><span class="s0">}</span><span class="s5">]&quot;</span><span class="s0">, </span><span class="s1">exc_info=exc_info</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">raise_routing_exception(self</span><span class="s0">, </span><span class="s1">request: Request) -&gt; </span><span class="s5">&quot;te.NoReturn&quot;</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Exceptions that are recording during routing are reraised with 
        this method.  During debug we are not reraising redirect requests 
        for non ``GET``, ``HEAD``, or ``OPTIONS`` requests and we're raising 
        a different error instead to help debug situations. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s0">not </span><span class="s1">self.debug</span>
            <span class="s0">or not </span><span class="s1">isinstance(request.routing_exception</span><span class="s0">, </span><span class="s1">RequestRedirect)</span>
            <span class="s0">or </span><span class="s1">request.method </span><span class="s0">in </span><span class="s1">(</span><span class="s5">&quot;GET&quot;</span><span class="s0">, </span><span class="s5">&quot;HEAD&quot;</span><span class="s0">, </span><span class="s5">&quot;OPTIONS&quot;</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">request.routing_exception  </span><span class="s4"># type: ignore</span>

        <span class="s0">from </span><span class="s1">.debughelpers </span><span class="s0">import </span><span class="s1">FormDataRoutingRedirect</span>

        <span class="s0">raise </span><span class="s1">FormDataRoutingRedirect(request)</span>

    <span class="s0">def </span><span class="s1">dispatch_request(self) -&gt; ResponseReturnValue:</span>
        <span class="s3">&quot;&quot;&quot;Does the request dispatching.  Matches the URL and returns the 
        return value of the view or error handler.  This does not have to 
        be a response object.  In order to convert the return value to a 
        proper response object, call :func:`make_response`. 
 
        .. versionchanged:: 0.7 
           This no longer does the exception handling, this code was 
           moved to the new :meth:`full_dispatch_request`. 
        &quot;&quot;&quot;</span>
        <span class="s1">req = _request_ctx_stack.top.request</span>
        <span class="s0">if </span><span class="s1">req.routing_exception </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.raise_routing_exception(req)</span>
        <span class="s1">rule = req.url_rule</span>
        <span class="s4"># if we provide automatic options for this URL and the</span>
        <span class="s4"># request came with the OPTIONS method, reply automatically</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">getattr(rule</span><span class="s0">, </span><span class="s5">&quot;provide_automatic_options&quot;</span><span class="s0">, False</span><span class="s1">)</span>
            <span class="s0">and </span><span class="s1">req.method == </span><span class="s5">&quot;OPTIONS&quot;</span>
        <span class="s1">):</span>
            <span class="s0">return </span><span class="s1">self.make_default_options_response()</span>
        <span class="s4"># otherwise dispatch to the handler for that endpoint</span>
        <span class="s0">return </span><span class="s1">self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)</span>

    <span class="s0">def </span><span class="s1">full_dispatch_request(self) -&gt; Response:</span>
        <span class="s3">&quot;&quot;&quot;Dispatches the request and on top of that performs request 
        pre and postprocessing as well as HTTP exception catching and 
        error handling. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s1">self.try_trigger_before_first_request_functions()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">request_started.send(self)</span>
            <span class="s1">rv = self.preprocess_request()</span>
            <span class="s0">if </span><span class="s1">rv </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">rv = self.dispatch_request()</span>
        <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">rv = self.handle_user_exception(e)</span>
        <span class="s0">return </span><span class="s1">self.finalize_request(rv)</span>

    <span class="s0">def </span><span class="s1">finalize_request(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">rv: t.Union[ResponseReturnValue</span><span class="s0">, </span><span class="s1">HTTPException]</span><span class="s0">,</span>
        <span class="s1">from_error_handler: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; Response:</span>
        <span class="s3">&quot;&quot;&quot;Given the return value from a view function this finalizes 
        the request by converting it into a response and invoking the 
        postprocessing functions.  This is invoked for both normal 
        request dispatching as well as error handlers. 
 
        Because this means that it might be called as a result of a 
        failure a special safe mode is available which can be enabled 
        with the `from_error_handler` flag.  If enabled, failures in 
        response processing will be logged and otherwise ignored. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s1">response = self.make_response(rv)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">response = self.process_response(response)</span>
            <span class="s1">request_finished.send(self</span><span class="s0">, </span><span class="s1">response=response)</span>
        <span class="s0">except </span><span class="s1">Exception:</span>
            <span class="s0">if not </span><span class="s1">from_error_handler:</span>
                <span class="s0">raise</span>
            <span class="s1">self.logger.exception(</span>
                <span class="s5">&quot;Request finalizing failed with an error while handling an error&quot;</span>
            <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">response</span>

    <span class="s0">def </span><span class="s1">try_trigger_before_first_request_functions(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Called before each request and will ensure that it triggers 
        the :attr:`before_first_request_funcs` and only exactly once per 
        application instance (which means process usually). 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._got_first_request:</span>
            <span class="s0">return</span>
        <span class="s0">with </span><span class="s1">self._before_request_lock:</span>
            <span class="s0">if </span><span class="s1">self._got_first_request:</span>
                <span class="s0">return</span>
            <span class="s0">for </span><span class="s1">func </span><span class="s0">in </span><span class="s1">self.before_first_request_funcs:</span>
                <span class="s1">self.ensure_sync(func)()</span>
            <span class="s1">self._got_first_request = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">make_default_options_response(self) -&gt; Response:</span>
        <span class="s3">&quot;&quot;&quot;This method is called to create the default ``OPTIONS`` response. 
        This can be changed through subclassing to change the default 
        behavior of ``OPTIONS`` responses. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s1">adapter = _request_ctx_stack.top.url_adapter</span>
        <span class="s1">methods = adapter.allowed_methods()</span>
        <span class="s1">rv = self.response_class()</span>
        <span class="s1">rv.allow.update(methods)</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">should_ignore_error(self</span><span class="s0">, </span><span class="s1">error: t.Optional[BaseException]) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;This is called to figure out if an error should be ignored 
        or not as far as the teardown system is concerned.  If this 
        function returns ``True`` then the teardown handlers will not be 
        passed the error. 
 
        .. versionadded:: 0.10 
        &quot;&quot;&quot;</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">ensure_sync(self</span><span class="s0">, </span><span class="s1">func: t.Callable) -&gt; t.Callable:</span>
        <span class="s3">&quot;&quot;&quot;Ensure that the function is synchronous for WSGI workers. 
        Plain ``def`` functions are returned as-is. ``async def`` 
        functions are wrapped to run and wait for the response. 
 
        Override this method to change how the app runs async views. 
 
        .. versionadded:: 2.0 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">iscoroutinefunction(func):</span>
            <span class="s0">return </span><span class="s1">self.async_to_sync(func)</span>

        <span class="s0">return </span><span class="s1">func</span>

    <span class="s0">def </span><span class="s1">async_to_sync(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">func: t.Callable[...</span><span class="s0">, </span><span class="s1">t.Coroutine]</span>
    <span class="s1">) -&gt; t.Callable[...</span><span class="s0">, </span><span class="s1">t.Any]:</span>
        <span class="s3">&quot;&quot;&quot;Return a sync function that will run the coroutine function. 
 
        .. code-block:: python 
 
            result = app.async_to_sync(func)(*args, **kwargs) 
 
        Override this method to change how the app converts async code 
        to be synchronously callable. 
 
        .. versionadded:: 2.0 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">from </span><span class="s1">asgiref.sync </span><span class="s0">import </span><span class="s1">async_to_sync </span><span class="s0">as </span><span class="s1">asgiref_async_to_sync</span>
        <span class="s0">except </span><span class="s1">ImportError:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span>
                <span class="s5">&quot;Install Flask with the 'async' extra in order to use async views.&quot;</span>
            <span class="s1">) </span><span class="s0">from None</span>

        <span class="s4"># Check that Werkzeug isn't using its fallback ContextVar class.</span>
        <span class="s0">if </span><span class="s1">ContextVar.__module__ == </span><span class="s5">&quot;werkzeug.local&quot;</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span>
                <span class="s5">&quot;Async cannot be used with this combination of Python &quot;</span>
                <span class="s5">&quot;and Greenlet versions.&quot;</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">asgiref_async_to_sync(func)</span>

    <span class="s0">def </span><span class="s1">make_response(self</span><span class="s0">, </span><span class="s1">rv: ResponseReturnValue) -&gt; Response:</span>
        <span class="s3">&quot;&quot;&quot;Convert the return value from a view function to an instance of 
        :attr:`response_class`. 
 
        :param rv: the return value from the view function. The view function 
            must return a response. Returning ``None``, or the view ending 
            without returning, is not allowed. The following types are allowed 
            for ``view_rv``: 
 
            ``str`` 
                A response object is created with the string encoded to UTF-8 
                as the body. 
 
            ``bytes`` 
                A response object is created with the bytes as the body. 
 
            ``dict`` 
                A dictionary that will be jsonify'd before being returned. 
 
            ``tuple`` 
                Either ``(body, status, headers)``, ``(body, status)``, or 
                ``(body, headers)``, where ``body`` is any of the other types 
                allowed here, ``status`` is a string or an integer, and 
                ``headers`` is a dictionary or a list of ``(key, value)`` 
                tuples. If ``body`` is a :attr:`response_class` instance, 
                ``status`` overwrites the exiting value and ``headers`` are 
                extended. 
 
            :attr:`response_class` 
                The object is returned unchanged. 
 
            other :class:`~werkzeug.wrappers.Response` class 
                The object is coerced to :attr:`response_class`. 
 
            :func:`callable` 
                The function is called as a WSGI application. The result is 
                used to create a response object. 
 
        .. versionchanged:: 0.9 
           Previously a tuple was interpreted as the arguments for the 
           response object. 
        &quot;&quot;&quot;</span>

        <span class="s1">status = headers = </span><span class="s0">None</span>

        <span class="s4"># unpack tuple returns</span>
        <span class="s0">if </span><span class="s1">isinstance(rv</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s1">len_rv = len(rv)</span>

            <span class="s4"># a 3-tuple is unpacked directly</span>
            <span class="s0">if </span><span class="s1">len_rv == </span><span class="s2">3</span><span class="s1">:</span>
                <span class="s1">rv</span><span class="s0">, </span><span class="s1">status</span><span class="s0">, </span><span class="s1">headers = rv</span>
            <span class="s4"># decide if a 2-tuple has status or headers</span>
            <span class="s0">elif </span><span class="s1">len_rv == </span><span class="s2">2</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">isinstance(rv[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(Headers</span><span class="s0">, </span><span class="s1">dict</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">list)):</span>
                    <span class="s1">rv</span><span class="s0">, </span><span class="s1">headers = rv</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">rv</span><span class="s0">, </span><span class="s1">status = rv</span>
            <span class="s4"># other sized tuples are not allowed</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s5">&quot;The view function did not return a valid response tuple.&quot;</span>
                    <span class="s5">&quot; The tuple must have the form (body, status, headers),&quot;</span>
                    <span class="s5">&quot; (body, status), or (body, headers).&quot;</span>
                <span class="s1">)</span>

        <span class="s4"># the body must not be None</span>
        <span class="s0">if </span><span class="s1">rv </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s5">f&quot;The view function for </span><span class="s0">{</span><span class="s1">request.endpoint</span><span class="s0">!r} </span><span class="s5">did not&quot;</span>
                <span class="s5">&quot; return a valid response. The function either returned&quot;</span>
                <span class="s5">&quot; None or ended without a return statement.&quot;</span>
            <span class="s1">)</span>

        <span class="s4"># make sure the body is an instance of the response class</span>
        <span class="s0">if not </span><span class="s1">isinstance(rv</span><span class="s0">, </span><span class="s1">self.response_class):</span>
            <span class="s0">if </span><span class="s1">isinstance(rv</span><span class="s0">, </span><span class="s1">(str</span><span class="s0">, </span><span class="s1">bytes</span><span class="s0">, </span><span class="s1">bytearray)):</span>
                <span class="s4"># let the response class set the status and headers instead of</span>
                <span class="s4"># waiting to do it manually, so that the class can handle any</span>
                <span class="s4"># special logic</span>
                <span class="s1">rv = self.response_class(rv</span><span class="s0">, </span><span class="s1">status=status</span><span class="s0">, </span><span class="s1">headers=headers)</span>
                <span class="s1">status = headers = </span><span class="s0">None</span>
            <span class="s0">elif </span><span class="s1">isinstance(rv</span><span class="s0">, </span><span class="s1">dict):</span>
                <span class="s1">rv = jsonify(rv)</span>
            <span class="s0">elif </span><span class="s1">isinstance(rv</span><span class="s0">, </span><span class="s1">BaseResponse) </span><span class="s0">or </span><span class="s1">callable(rv):</span>
                <span class="s4"># evaluate a WSGI callable, or coerce a different response</span>
                <span class="s4"># class to the correct type</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">rv = self.response_class.force_type(rv</span><span class="s0">, </span><span class="s1">request.environ)  </span><span class="s4"># type: ignore  # noqa: B950</span>
                <span class="s0">except </span><span class="s1">TypeError </span><span class="s0">as </span><span class="s1">e:</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span>
                        <span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">e</span><span class="s0">}\n</span><span class="s5">The view function did not return a valid&quot;</span>
                        <span class="s5">&quot; response. The return type must be a string,&quot;</span>
                        <span class="s5">&quot; dict, tuple, Response instance, or WSGI&quot;</span>
                        <span class="s5">f&quot; callable, but it was a </span><span class="s0">{</span><span class="s1">type(rv).__name__</span><span class="s0">}</span><span class="s5">.&quot;</span>
                    <span class="s1">).with_traceback(sys.exc_info()[</span><span class="s2">2</span><span class="s1">]) </span><span class="s0">from None</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s5">&quot;The view function did not return a valid&quot;</span>
                    <span class="s5">&quot; response. The return type must be a string,&quot;</span>
                    <span class="s5">&quot; dict, tuple, Response instance, or WSGI&quot;</span>
                    <span class="s5">f&quot; callable, but it was a </span><span class="s0">{</span><span class="s1">type(rv).__name__</span><span class="s0">}</span><span class="s5">.&quot;</span>
                <span class="s1">)</span>

        <span class="s1">rv = t.cast(Response</span><span class="s0">, </span><span class="s1">rv)</span>
        <span class="s4"># prefer the status if it was provided</span>
        <span class="s0">if </span><span class="s1">status </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(status</span><span class="s0">, </span><span class="s1">(str</span><span class="s0">, </span><span class="s1">bytes</span><span class="s0">, </span><span class="s1">bytearray)):</span>
                <span class="s1">rv.status = status  </span><span class="s4"># type: ignore</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">rv.status_code = status</span>

        <span class="s4"># extend existing headers with provided headers</span>
        <span class="s0">if </span><span class="s1">headers:</span>
            <span class="s1">rv.headers.update(headers)</span>

        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">create_url_adapter(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">request: t.Optional[Request]</span>
    <span class="s1">) -&gt; t.Optional[MapAdapter]:</span>
        <span class="s3">&quot;&quot;&quot;Creates a URL adapter for the given request. The URL adapter 
        is created at a point where the request context is not yet set 
        up so the request is passed explicitly. 
 
        .. versionadded:: 0.6 
 
        .. versionchanged:: 0.9 
           This can now also be called without a request object when the 
           URL adapter is created for the application context. 
 
        .. versionchanged:: 1.0 
            :data:`SERVER_NAME` no longer implicitly enables subdomain 
            matching. Use :attr:`subdomain_matching` instead. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">request </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s4"># If subdomain matching is disabled (the default), use the</span>
            <span class="s4"># default subdomain in all cases. This should be the default</span>
            <span class="s4"># in Werkzeug but it currently does not have that feature.</span>
            <span class="s0">if not </span><span class="s1">self.subdomain_matching:</span>
                <span class="s1">subdomain = self.url_map.default_subdomain </span><span class="s0">or None</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">subdomain = </span><span class="s0">None</span>

            <span class="s0">return </span><span class="s1">self.url_map.bind_to_environ(</span>
                <span class="s1">request.environ</span><span class="s0">,</span>
                <span class="s1">server_name=self.config[</span><span class="s5">&quot;SERVER_NAME&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">subdomain=subdomain</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s4"># We need at the very least the server name to be set for this</span>
        <span class="s4"># to work.</span>
        <span class="s0">if </span><span class="s1">self.config[</span><span class="s5">&quot;SERVER_NAME&quot;</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.url_map.bind(</span>
                <span class="s1">self.config[</span><span class="s5">&quot;SERVER_NAME&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">script_name=self.config[</span><span class="s5">&quot;APPLICATION_ROOT&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">url_scheme=self.config[</span><span class="s5">&quot;PREFERRED_URL_SCHEME&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">inject_url_defaults(self</span><span class="s0">, </span><span class="s1">endpoint: str</span><span class="s0">, </span><span class="s1">values: dict) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Injects the URL defaults for the given endpoint directly into 
        the values dictionary passed.  This is used internally and 
        automatically called on URL building. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s1">names: t.Iterable[t.Optional[str]] = (</span><span class="s0">None,</span><span class="s1">)</span>

        <span class="s4"># url_for may be called outside a request context, parse the</span>
        <span class="s4"># passed endpoint instead of using request.blueprints.</span>
        <span class="s0">if </span><span class="s5">&quot;.&quot; </span><span class="s0">in </span><span class="s1">endpoint:</span>
            <span class="s1">names = chain(</span>
                <span class="s1">names</span><span class="s0">, </span><span class="s1">reversed(_split_blueprint_path(endpoint.rpartition(</span><span class="s5">&quot;.&quot;</span><span class="s1">)[</span><span class="s2">0</span><span class="s1">]))</span>
            <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names:</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self.url_default_functions:</span>
                <span class="s0">for </span><span class="s1">func </span><span class="s0">in </span><span class="s1">self.url_default_functions[name]:</span>
                    <span class="s1">func(endpoint</span><span class="s0">, </span><span class="s1">values)</span>

    <span class="s0">def </span><span class="s1">handle_url_build_error(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">error: Exception</span><span class="s0">, </span><span class="s1">endpoint: str</span><span class="s0">, </span><span class="s1">values: dict</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s3">&quot;&quot;&quot;Handle :class:`~werkzeug.routing.BuildError` on 
        :meth:`url_for`. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">handler </span><span class="s0">in </span><span class="s1">self.url_build_error_handlers:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">rv = handler(error</span><span class="s0">, </span><span class="s1">endpoint</span><span class="s0">, </span><span class="s1">values)</span>
            <span class="s0">except </span><span class="s1">BuildError </span><span class="s0">as </span><span class="s1">e:</span>
                <span class="s4"># make error available outside except block</span>
                <span class="s1">error = e</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">rv </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">rv</span>

        <span class="s4"># Re-raise if called with an active exception, otherwise raise</span>
        <span class="s4"># the passed in exception.</span>
        <span class="s0">if </span><span class="s1">error </span><span class="s0">is </span><span class="s1">sys.exc_info()[</span><span class="s2">1</span><span class="s1">]:</span>
            <span class="s0">raise</span>

        <span class="s0">raise </span><span class="s1">error</span>

    <span class="s0">def </span><span class="s1">preprocess_request(self) -&gt; t.Optional[ResponseReturnValue]:</span>
        <span class="s3">&quot;&quot;&quot;Called before the request is dispatched. Calls 
        :attr:`url_value_preprocessors` registered with the app and the 
        current blueprint (if any). Then calls :attr:`before_request_funcs` 
        registered with the app and the blueprint. 
 
        If any :meth:`before_request` handler returns a non-None value, the 
        value is handled as if it was the return value from the view, and 
        further request handling is stopped. 
        &quot;&quot;&quot;</span>
        <span class="s1">names = (</span><span class="s0">None, </span><span class="s1">*reversed(request.blueprints))</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names:</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self.url_value_preprocessors:</span>
                <span class="s0">for </span><span class="s1">url_func </span><span class="s0">in </span><span class="s1">self.url_value_preprocessors[name]:</span>
                    <span class="s1">url_func(request.endpoint</span><span class="s0">, </span><span class="s1">request.view_args)</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names:</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self.before_request_funcs:</span>
                <span class="s0">for </span><span class="s1">before_func </span><span class="s0">in </span><span class="s1">self.before_request_funcs[name]:</span>
                    <span class="s1">rv = self.ensure_sync(before_func)()</span>

                    <span class="s0">if </span><span class="s1">rv </span><span class="s0">is not None</span><span class="s1">:</span>
                        <span class="s0">return </span><span class="s1">rv</span>

        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">process_response(self</span><span class="s0">, </span><span class="s1">response: Response) -&gt; Response:</span>
        <span class="s3">&quot;&quot;&quot;Can be overridden in order to modify the response object 
        before it's sent to the WSGI server.  By default this will 
        call all the :meth:`after_request` decorated functions. 
 
        .. versionchanged:: 0.5 
           As of Flask 0.5 the functions registered for after request 
           execution are called in reverse order of registration. 
 
        :param response: a :attr:`response_class` object. 
        :return: a new response object or the same, has to be an 
                 instance of :attr:`response_class`. 
        &quot;&quot;&quot;</span>
        <span class="s1">ctx = _request_ctx_stack.top</span>

        <span class="s0">for </span><span class="s1">func </span><span class="s0">in </span><span class="s1">ctx._after_request_functions:</span>
            <span class="s1">response = self.ensure_sync(func)(response)</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">chain(request.blueprints</span><span class="s0">, </span><span class="s1">(</span><span class="s0">None,</span><span class="s1">)):</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self.after_request_funcs:</span>
                <span class="s0">for </span><span class="s1">func </span><span class="s0">in </span><span class="s1">reversed(self.after_request_funcs[name]):</span>
                    <span class="s1">response = self.ensure_sync(func)(response)</span>

        <span class="s0">if not </span><span class="s1">self.session_interface.is_null_session(ctx.session):</span>
            <span class="s1">self.session_interface.save_session(self</span><span class="s0">, </span><span class="s1">ctx.session</span><span class="s0">, </span><span class="s1">response)</span>

        <span class="s0">return </span><span class="s1">response</span>

    <span class="s0">def </span><span class="s1">do_teardown_request(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">exc: t.Optional[BaseException] = _sentinel  </span><span class="s4"># type: ignore</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Called after the request is dispatched and the response is 
        returned, right before the request context is popped. 
 
        This calls all functions decorated with 
        :meth:`teardown_request`, and :meth:`Blueprint.teardown_request` 
        if a blueprint handled the request. Finally, the 
        :data:`request_tearing_down` signal is sent. 
 
        This is called by 
        :meth:`RequestContext.pop() &lt;flask.ctx.RequestContext.pop&gt;`, 
        which may be delayed during testing to maintain access to 
        resources. 
 
        :param exc: An unhandled exception raised while dispatching the 
            request. Detected from the current exception information if 
            not passed. Passed to each teardown function. 
 
        .. versionchanged:: 0.9 
            Added the ``exc`` argument. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">exc </span><span class="s0">is </span><span class="s1">_sentinel:</span>
            <span class="s1">exc = sys.exc_info()[</span><span class="s2">1</span><span class="s1">]</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">chain(request.blueprints</span><span class="s0">, </span><span class="s1">(</span><span class="s0">None,</span><span class="s1">)):</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self.teardown_request_funcs:</span>
                <span class="s0">for </span><span class="s1">func </span><span class="s0">in </span><span class="s1">reversed(self.teardown_request_funcs[name]):</span>
                    <span class="s1">self.ensure_sync(func)(exc)</span>

        <span class="s1">request_tearing_down.send(self</span><span class="s0">, </span><span class="s1">exc=exc)</span>

    <span class="s0">def </span><span class="s1">do_teardown_appcontext(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">exc: t.Optional[BaseException] = _sentinel  </span><span class="s4"># type: ignore</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Called right before the application context is popped. 
 
        When handling a request, the application context is popped 
        after the request context. See :meth:`do_teardown_request`. 
 
        This calls all functions decorated with 
        :meth:`teardown_appcontext`. Then the 
        :data:`appcontext_tearing_down` signal is sent. 
 
        This is called by 
        :meth:`AppContext.pop() &lt;flask.ctx.AppContext.pop&gt;`. 
 
        .. versionadded:: 0.9 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">exc </span><span class="s0">is </span><span class="s1">_sentinel:</span>
            <span class="s1">exc = sys.exc_info()[</span><span class="s2">1</span><span class="s1">]</span>

        <span class="s0">for </span><span class="s1">func </span><span class="s0">in </span><span class="s1">reversed(self.teardown_appcontext_funcs):</span>
            <span class="s1">self.ensure_sync(func)(exc)</span>

        <span class="s1">appcontext_tearing_down.send(self</span><span class="s0">, </span><span class="s1">exc=exc)</span>

    <span class="s0">def </span><span class="s1">app_context(self) -&gt; AppContext:</span>
        <span class="s3">&quot;&quot;&quot;Create an :class:`~flask.ctx.AppContext`. Use as a ``with`` 
        block to push the context, which will make :data:`current_app` 
        point at this application. 
 
        An application context is automatically pushed by 
        :meth:`RequestContext.push() &lt;flask.ctx.RequestContext.push&gt;` 
        when handling a request, and when running a CLI command. Use 
        this to manually create a context outside of these situations. 
 
        :: 
 
            with app.app_context(): 
                init_db() 
 
        See :doc:`/appcontext`. 
 
        .. versionadded:: 0.9 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">AppContext(self)</span>

    <span class="s0">def </span><span class="s1">request_context(self</span><span class="s0">, </span><span class="s1">environ: dict) -&gt; RequestContext:</span>
        <span class="s3">&quot;&quot;&quot;Create a :class:`~flask.ctx.RequestContext` representing a 
        WSGI environment. Use a ``with`` block to push the context, 
        which will make :data:`request` point at this request. 
 
        See :doc:`/reqcontext`. 
 
        Typically you should not call this from your own code. A request 
        context is automatically pushed by the :meth:`wsgi_app` when 
        handling a request. Use :meth:`test_request_context` to create 
        an environment and context instead of this method. 
 
        :param environ: a WSGI environment 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">RequestContext(self</span><span class="s0">, </span><span class="s1">environ)</span>

    <span class="s0">def </span><span class="s1">test_request_context(self</span><span class="s0">, </span><span class="s1">*args: t.Any</span><span class="s0">, </span><span class="s1">**kwargs: t.Any) -&gt; RequestContext:</span>
        <span class="s3">&quot;&quot;&quot;Create a :class:`~flask.ctx.RequestContext` for a WSGI 
        environment created from the given values. This is mostly useful 
        during testing, where you may want to run a function that uses 
        request data without dispatching a full request. 
 
        See :doc:`/reqcontext`. 
 
        Use a ``with`` block to push the context, which will make 
        :data:`request` point at the request for the created 
        environment. :: 
 
            with test_request_context(...): 
                generate_report() 
 
        When using the shell, it may be easier to push and pop the 
        context manually to avoid indentation. :: 
 
            ctx = app.test_request_context(...) 
            ctx.push() 
            ... 
            ctx.pop() 
 
        Takes the same arguments as Werkzeug's 
        :class:`~werkzeug.test.EnvironBuilder`, with some defaults from 
        the application. See the linked Werkzeug docs for most of the 
        available arguments. Flask-specific behavior is listed here. 
 
        :param path: URL path being requested. 
        :param base_url: Base URL where the app is being served, which 
            ``path`` is relative to. If not given, built from 
            :data:`PREFERRED_URL_SCHEME`, ``subdomain``, 
            :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`. 
        :param subdomain: Subdomain name to append to 
            :data:`SERVER_NAME`. 
        :param url_scheme: Scheme to use instead of 
            :data:`PREFERRED_URL_SCHEME`. 
        :param data: The request body, either as a string or a dict of 
            form keys and values. 
        :param json: If given, this is serialized as JSON and passed as 
            ``data``. Also defaults ``content_type`` to 
            ``application/json``. 
        :param args: other positional arguments passed to 
            :class:`~werkzeug.test.EnvironBuilder`. 
        :param kwargs: other keyword arguments passed to 
            :class:`~werkzeug.test.EnvironBuilder`. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">.testing </span><span class="s0">import </span><span class="s1">EnvironBuilder</span>

        <span class="s1">builder = EnvironBuilder(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.request_context(builder.get_environ())</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">builder.close()</span>

    <span class="s0">def </span><span class="s1">wsgi_app(self</span><span class="s0">, </span><span class="s1">environ: dict</span><span class="s0">, </span><span class="s1">start_response: t.Callable) -&gt; t.Any:</span>
        <span class="s3">&quot;&quot;&quot;The actual WSGI application. This is not implemented in 
        :meth:`__call__` so that middlewares can be applied without 
        losing a reference to the app object. Instead of doing this:: 
 
            app = MyMiddleware(app) 
 
        It's a better idea to do this instead:: 
 
            app.wsgi_app = MyMiddleware(app.wsgi_app) 
 
        Then you still have the original application object around and 
        can continue to call methods on it. 
 
        .. versionchanged:: 0.7 
            Teardown events for the request and app contexts are called 
            even if an unhandled error occurs. Other events may not be 
            called depending on when an error occurs during dispatch. 
            See :ref:`callbacks-and-errors`. 
 
        :param environ: A WSGI environment. 
        :param start_response: A callable accepting a status code, 
            a list of headers, and an optional exception context to 
            start the response. 
        &quot;&quot;&quot;</span>
        <span class="s1">ctx = self.request_context(environ)</span>
        <span class="s1">error: t.Optional[BaseException] = </span><span class="s0">None</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">ctx.push()</span>
                <span class="s1">response = self.full_dispatch_request()</span>
            <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e:</span>
                <span class="s1">error = e</span>
                <span class="s1">response = self.handle_exception(e)</span>
            <span class="s0">except</span><span class="s1">:  </span><span class="s4"># noqa: B001</span>
                <span class="s1">error = sys.exc_info()[</span><span class="s2">1</span><span class="s1">]</span>
                <span class="s0">raise</span>
            <span class="s0">return </span><span class="s1">response(environ</span><span class="s0">, </span><span class="s1">start_response)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.should_ignore_error(error):</span>
                <span class="s1">error = </span><span class="s0">None</span>
            <span class="s1">ctx.auto_pop(error)</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">environ: dict</span><span class="s0">, </span><span class="s1">start_response: t.Callable) -&gt; t.Any:</span>
        <span class="s3">&quot;&quot;&quot;The WSGI server calls the Flask application object as the 
        WSGI application. This calls :meth:`wsgi_app`, which can be 
        wrapped to apply middleware. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.wsgi_app(environ</span><span class="s0">, </span><span class="s1">start_response)</span>
</pre>
</body>
</html>