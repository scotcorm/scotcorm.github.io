<html>
<head>
<title>latex.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
latex.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Module for formatting output data in Latex. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">abc </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ABC</span><span class="s2">,</span>
    <span class="s1">abstractmethod</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Iterator</span><span class="s2">,</span>
    <span class="s1">Sequence</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.generic </span><span class="s2">import </span><span class="s1">ABCMultiIndex</span>

<span class="s2">from </span><span class="s1">pandas.io.formats.format </span><span class="s2">import </span><span class="s1">DataFrameFormatter</span>


<span class="s2">def </span><span class="s1">_split_into_full_short_caption(</span>
    <span class="s1">caption: str | tuple[str</span><span class="s2">, </span><span class="s1">str] | </span><span class="s2">None</span>
<span class="s1">) -&gt; tuple[str</span><span class="s2">, </span><span class="s1">str]:</span>
    <span class="s0">&quot;&quot;&quot;Extract full and short captions from caption string/tuple. 
 
    Parameters 
    ---------- 
    caption : str or tuple, optional 
        Either table caption string or tuple (full_caption, short_caption). 
        If string is provided, then it is treated as table full caption, 
        while short_caption is considered an empty string. 
 
    Returns 
    ------- 
    full_caption, short_caption : tuple 
        Tuple of full_caption, short_caption strings. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">caption:</span>
        <span class="s2">if </span><span class="s1">isinstance(caption</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">full_caption = caption</span>
            <span class="s1">short_caption = </span><span class="s3">&quot;&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">full_caption</span><span class="s2">, </span><span class="s1">short_caption = caption</span>
            <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s1">msg = </span><span class="s3">&quot;caption must be either a string or a tuple of two strings&quot;</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg) </span><span class="s2">from </span><span class="s1">err</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">full_caption = </span><span class="s3">&quot;&quot;</span>
        <span class="s1">short_caption = </span><span class="s3">&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">full_caption</span><span class="s2">, </span><span class="s1">short_caption</span>


<span class="s2">class </span><span class="s1">RowStringConverter(ABC):</span>
    <span class="s0">r&quot;&quot;&quot;Converter for dataframe rows into LaTeX strings. 
 
    Parameters 
    ---------- 
    formatter : `DataFrameFormatter` 
        Instance of `DataFrameFormatter`. 
    multicolumn: bool, optional 
        Whether to use \multicolumn macro. 
    multicolumn_format: str, optional 
        Multicolumn format. 
    multirow: bool, optional 
        Whether to use \multirow macro. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">formatter: DataFrameFormatter</span><span class="s2">,</span>
        <span class="s1">multicolumn: bool = </span><span class="s2">False,</span>
        <span class="s1">multicolumn_format: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">multirow: bool = </span><span class="s2">False,</span>
    <span class="s1">):</span>
        <span class="s1">self.fmt = formatter</span>
        <span class="s1">self.frame = self.fmt.frame</span>
        <span class="s1">self.multicolumn = multicolumn</span>
        <span class="s1">self.multicolumn_format = multicolumn_format</span>
        <span class="s1">self.multirow = multirow</span>
        <span class="s1">self.clinebuf: list[list[int]] = []</span>
        <span class="s1">self.strcols = self._get_strcols()</span>
        <span class="s1">self.strrows = list(zip(*self.strcols))</span>

    <span class="s2">def </span><span class="s1">get_strrow(self</span><span class="s2">, </span><span class="s1">row_num: int) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Get string representation of the row.&quot;&quot;&quot;</span>
        <span class="s1">row = self.strrows[row_num]</span>

        <span class="s1">is_multicol = (</span>
            <span class="s1">row_num &lt; self.column_levels </span><span class="s2">and </span><span class="s1">self.fmt.header </span><span class="s2">and </span><span class="s1">self.multicolumn</span>
        <span class="s1">)</span>

        <span class="s1">is_multirow = (</span>
            <span class="s1">row_num &gt;= self.header_levels</span>
            <span class="s2">and </span><span class="s1">self.fmt.index</span>
            <span class="s2">and </span><span class="s1">self.multirow</span>
            <span class="s2">and </span><span class="s1">self.index_levels &gt; </span><span class="s4">1</span>
        <span class="s1">)</span>

        <span class="s1">is_cline_maybe_required = is_multirow </span><span class="s2">and </span><span class="s1">row_num &lt; len(self.strrows) - </span><span class="s4">1</span>

        <span class="s1">crow = self._preprocess_row(row)</span>

        <span class="s2">if </span><span class="s1">is_multicol:</span>
            <span class="s1">crow = self._format_multicolumn(crow)</span>
        <span class="s2">if </span><span class="s1">is_multirow:</span>
            <span class="s1">crow = self._format_multirow(crow</span><span class="s2">, </span><span class="s1">row_num)</span>

        <span class="s1">lst = []</span>
        <span class="s1">lst.append(</span><span class="s3">&quot; &amp; &quot;</span><span class="s1">.join(crow))</span>
        <span class="s1">lst.append(</span><span class="s3">&quot; </span><span class="s2">\\\\</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">is_cline_maybe_required:</span>
            <span class="s1">cline = self._compose_cline(row_num</span><span class="s2">, </span><span class="s1">len(self.strcols))</span>
            <span class="s1">lst.append(cline)</span>
        <span class="s2">return </span><span class="s3">&quot;&quot;</span><span class="s1">.join(lst)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_header_row_num(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;Number of rows in header.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.header_levels </span><span class="s2">if </span><span class="s1">self.fmt.header </span><span class="s2">else </span><span class="s4">0</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">index_levels(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;Integer number of levels in index.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.frame.index.nlevels</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">column_levels(self) -&gt; int:</span>
        <span class="s2">return </span><span class="s1">self.frame.columns.nlevels</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">header_levels(self) -&gt; int:</span>
        <span class="s1">nlevels = self.column_levels</span>
        <span class="s2">if </span><span class="s1">self.fmt.has_index_names </span><span class="s2">and </span><span class="s1">self.fmt.show_index_names:</span>
            <span class="s1">nlevels += </span><span class="s4">1</span>
        <span class="s2">return </span><span class="s1">nlevels</span>

    <span class="s2">def </span><span class="s1">_get_strcols(self) -&gt; list[list[str]]:</span>
        <span class="s0">&quot;&quot;&quot;String representation of the columns.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.fmt.frame.empty:</span>
            <span class="s1">strcols = [[self._empty_info_line]]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">strcols = self.fmt.get_strcols()</span>

        <span class="s5"># reestablish the MultiIndex that has been joined by get_strcols()</span>
        <span class="s2">if </span><span class="s1">self.fmt.index </span><span class="s2">and </span><span class="s1">isinstance(self.frame.index</span><span class="s2">, </span><span class="s1">ABCMultiIndex):</span>
            <span class="s1">out = self.frame.index.format(</span>
                <span class="s1">adjoin=</span><span class="s2">False,</span>
                <span class="s1">sparsify=self.fmt.sparsify</span><span class="s2">,</span>
                <span class="s1">names=self.fmt.has_index_names</span><span class="s2">,</span>
                <span class="s1">na_rep=self.fmt.na_rep</span><span class="s2">,</span>
            <span class="s1">)</span>

            <span class="s5"># index.format will sparsify repeated entries with empty strings</span>
            <span class="s5"># so pad these with some empty space</span>
            <span class="s2">def </span><span class="s1">pad_empties(x):</span>
                <span class="s2">for </span><span class="s1">pad </span><span class="s2">in </span><span class="s1">reversed(x):</span>
                    <span class="s2">if </span><span class="s1">pad:</span>
                        <span class="s2">break</span>
                <span class="s2">return </span><span class="s1">[x[</span><span class="s4">0</span><span class="s1">]] + [i </span><span class="s2">if </span><span class="s1">i </span><span class="s2">else </span><span class="s3">&quot; &quot; </span><span class="s1">* len(pad) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">x[</span><span class="s4">1</span><span class="s1">:]]</span>

            <span class="s1">gen = (pad_empties(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">out)</span>

            <span class="s5"># Add empty spaces for each column level</span>
            <span class="s1">clevels = self.frame.columns.nlevels</span>
            <span class="s1">out = [[</span><span class="s3">&quot; &quot; </span><span class="s1">* len(i[-</span><span class="s4">1</span><span class="s1">])] * clevels + i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">gen]</span>

            <span class="s5"># Add the column names to the last index column</span>
            <span class="s1">cnames = self.frame.columns.names</span>
            <span class="s2">if </span><span class="s1">any(cnames):</span>
                <span class="s1">new_names = [i </span><span class="s2">if </span><span class="s1">i </span><span class="s2">else </span><span class="s3">&quot;{}&quot; </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">cnames]</span>
                <span class="s1">out[self.frame.index.nlevels - </span><span class="s4">1</span><span class="s1">][:clevels] = new_names</span>

            <span class="s5"># Get rid of old multiindex column and add new ones</span>
            <span class="s1">strcols = out + strcols[</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s2">return </span><span class="s1">strcols</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_empty_info_line(self):</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s3">f&quot;Empty </span><span class="s2">{</span><span class="s1">type(self.frame).__name__</span><span class="s2">}\n</span><span class="s3">&quot;</span>
            <span class="s3">f&quot;Columns: </span><span class="s2">{</span><span class="s1">self.frame.columns</span><span class="s2">}\n</span><span class="s3">&quot;</span>
            <span class="s3">f&quot;Index: </span><span class="s2">{</span><span class="s1">self.frame.index</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_preprocess_row(self</span><span class="s2">, </span><span class="s1">row: Sequence[str]) -&gt; list[str]:</span>
        <span class="s0">&quot;&quot;&quot;Preprocess elements of the row.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.fmt.escape:</span>
            <span class="s1">crow = _escape_symbols(row)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">crow = [x </span><span class="s2">if </span><span class="s1">x </span><span class="s2">else </span><span class="s3">&quot;{}&quot; </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">row]</span>
        <span class="s2">if </span><span class="s1">self.fmt.bold_rows </span><span class="s2">and </span><span class="s1">self.fmt.index:</span>
            <span class="s1">crow = _convert_to_bold(crow</span><span class="s2">, </span><span class="s1">self.index_levels)</span>
        <span class="s2">return </span><span class="s1">crow</span>

    <span class="s2">def </span><span class="s1">_format_multicolumn(self</span><span class="s2">, </span><span class="s1">row: list[str]) -&gt; list[str]:</span>
        <span class="s0">r&quot;&quot;&quot; 
        Combine columns belonging to a group to a single multicolumn entry 
        according to self.multicolumn_format 
 
        e.g.: 
        a &amp;  &amp;  &amp; b &amp; c &amp; 
        will become 
        \multicolumn{3}{l}{a} &amp; b &amp; \multicolumn{2}{l}{c} 
        &quot;&quot;&quot;</span>
        <span class="s1">row2 = row[: self.index_levels]</span>
        <span class="s1">ncol = </span><span class="s4">1</span>
        <span class="s1">coltext = </span><span class="s3">&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">append_col():</span>
            <span class="s5"># write multicolumn if needed</span>
            <span class="s2">if </span><span class="s1">ncol &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">row2.append(</span>
                    <span class="s3">f&quot;</span><span class="s2">\\</span><span class="s3">multicolumn</span><span class="s2">{{{</span><span class="s1">ncol</span><span class="s2">:</span><span class="s3">d</span><span class="s2">}}}{{{</span><span class="s1">self.multicolumn_format</span><span class="s2">}}}</span><span class="s3">&quot;</span>
                    <span class="s3">f&quot;</span><span class="s2">{{{</span><span class="s1">coltext.strip()</span><span class="s2">}}}</span><span class="s3">&quot;</span>
                <span class="s1">)</span>
            <span class="s5"># don't modify where not needed</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">row2.append(coltext)</span>

        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">row[self.index_levels :]:</span>
            <span class="s5"># if next col has text, write the previous</span>
            <span class="s2">if </span><span class="s1">c.strip():</span>
                <span class="s2">if </span><span class="s1">coltext:</span>
                    <span class="s1">append_col()</span>
                <span class="s1">coltext = c</span>
                <span class="s1">ncol = </span><span class="s4">1</span>
            <span class="s5"># if not, add it to the previous multicolumn</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">ncol += </span><span class="s4">1</span>
        <span class="s5"># write last column name</span>
        <span class="s2">if </span><span class="s1">coltext:</span>
            <span class="s1">append_col()</span>
        <span class="s2">return </span><span class="s1">row2</span>

    <span class="s2">def </span><span class="s1">_format_multirow(self</span><span class="s2">, </span><span class="s1">row: list[str]</span><span class="s2">, </span><span class="s1">i: int) -&gt; list[str]:</span>
        <span class="s0">r&quot;&quot;&quot; 
        Check following rows, whether row should be a multirow 
 
        e.g.:     becomes: 
        a &amp; 0 &amp;   \multirow{2}{*}{a} &amp; 0 &amp; 
          &amp; 1 &amp;     &amp; 1 &amp; 
        b &amp; 0 &amp;   \cline{1-2} 
                  b &amp; 0 &amp; 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(self.index_levels):</span>
            <span class="s2">if </span><span class="s1">row[j].strip():</span>
                <span class="s1">nrow = </span><span class="s4">1</span>
                <span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">self.strrows[i + </span><span class="s4">1 </span><span class="s1">:]:</span>
                    <span class="s2">if not </span><span class="s1">r[j].strip():</span>
                        <span class="s1">nrow += </span><span class="s4">1</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">break</span>
                <span class="s2">if </span><span class="s1">nrow &gt; </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s5"># overwrite non-multirow entry</span>
                    <span class="s1">row[j] = </span><span class="s3">f&quot;</span><span class="s2">\\</span><span class="s3">multirow</span><span class="s2">{{{</span><span class="s1">nrow</span><span class="s2">:</span><span class="s3">d</span><span class="s2">}}}{{</span><span class="s3">*</span><span class="s2">}}{{{</span><span class="s1">row[j].strip()</span><span class="s2">}}}</span><span class="s3">&quot;</span>
                    <span class="s5"># save when to end the current block with \cline</span>
                    <span class="s1">self.clinebuf.append([i + nrow - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">j + </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s1">row</span>

    <span class="s2">def </span><span class="s1">_compose_cline(self</span><span class="s2">, </span><span class="s1">i: int</span><span class="s2">, </span><span class="s1">icol: int) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        Create clines after multirow-blocks are finished. 
        &quot;&quot;&quot;</span>
        <span class="s1">lst = []</span>
        <span class="s2">for </span><span class="s1">cl </span><span class="s2">in </span><span class="s1">self.clinebuf:</span>
            <span class="s2">if </span><span class="s1">cl[</span><span class="s4">0</span><span class="s1">] == i:</span>
                <span class="s1">lst.append(</span><span class="s3">f&quot;</span><span class="s2">\n\\</span><span class="s3">cline</span><span class="s2">{{{</span><span class="s1">cl[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">:</span><span class="s3">d</span><span class="s2">}</span><span class="s3">-</span><span class="s2">{</span><span class="s1">icol</span><span class="s2">:</span><span class="s3">d</span><span class="s2">}}}</span><span class="s3">&quot;</span><span class="s1">)</span>
                <span class="s5"># remove entries that have been written to buffer</span>
                <span class="s1">self.clinebuf = [x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self.clinebuf </span><span class="s2">if </span><span class="s1">x[</span><span class="s4">0</span><span class="s1">] != i]</span>
        <span class="s2">return </span><span class="s3">&quot;&quot;</span><span class="s1">.join(lst)</span>


<span class="s2">class </span><span class="s1">RowStringIterator(RowStringConverter):</span>
    <span class="s0">&quot;&quot;&quot;Iterator over rows of the header or the body of the table.&quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s2">def </span><span class="s1">__iter__(self) -&gt; Iterator[str]:</span>
        <span class="s0">&quot;&quot;&quot;Iterate over LaTeX string representations of rows.&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">RowHeaderIterator(RowStringIterator):</span>
    <span class="s0">&quot;&quot;&quot;Iterator for the table header rows.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__iter__(self) -&gt; Iterator[str]:</span>
        <span class="s2">for </span><span class="s1">row_num </span><span class="s2">in </span><span class="s1">range(len(self.strrows)):</span>
            <span class="s2">if </span><span class="s1">row_num &lt; self._header_row_num:</span>
                <span class="s2">yield </span><span class="s1">self.get_strrow(row_num)</span>


<span class="s2">class </span><span class="s1">RowBodyIterator(RowStringIterator):</span>
    <span class="s0">&quot;&quot;&quot;Iterator for the table body rows.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__iter__(self) -&gt; Iterator[str]:</span>
        <span class="s2">for </span><span class="s1">row_num </span><span class="s2">in </span><span class="s1">range(len(self.strrows)):</span>
            <span class="s2">if </span><span class="s1">row_num &gt;= self._header_row_num:</span>
                <span class="s2">yield </span><span class="s1">self.get_strrow(row_num)</span>


<span class="s2">class </span><span class="s1">TableBuilderAbstract(ABC):</span>
    <span class="s0">&quot;&quot;&quot; 
    Abstract table builder producing string representation of LaTeX table. 
 
    Parameters 
    ---------- 
    formatter : `DataFrameFormatter` 
        Instance of `DataFrameFormatter`. 
    column_format: str, optional 
        Column format, for example, 'rcl' for three columns. 
    multicolumn: bool, optional 
        Use multicolumn to enhance MultiIndex columns. 
    multicolumn_format: str, optional 
        The alignment for multicolumns, similar to column_format. 
    multirow: bool, optional 
        Use multirow to enhance MultiIndex rows. 
    caption: str, optional 
        Table caption. 
    short_caption: str, optional 
        Table short caption. 
    label: str, optional 
        LaTeX label. 
    position: str, optional 
        Float placement specifier, for example, 'htb'. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">formatter: DataFrameFormatter</span><span class="s2">,</span>
        <span class="s1">column_format: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">multicolumn: bool = </span><span class="s2">False,</span>
        <span class="s1">multicolumn_format: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">multirow: bool = </span><span class="s2">False,</span>
        <span class="s1">caption: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">short_caption: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">label: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">position: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">self.fmt = formatter</span>
        <span class="s1">self.column_format = column_format</span>
        <span class="s1">self.multicolumn = multicolumn</span>
        <span class="s1">self.multicolumn_format = multicolumn_format</span>
        <span class="s1">self.multirow = multirow</span>
        <span class="s1">self.caption = caption</span>
        <span class="s1">self.short_caption = short_caption</span>
        <span class="s1">self.label = label</span>
        <span class="s1">self.position = position</span>

    <span class="s2">def </span><span class="s1">get_result(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;String representation of LaTeX table.&quot;&quot;&quot;</span>
        <span class="s1">elements = [</span>
            <span class="s1">self.env_begin</span><span class="s2">,</span>
            <span class="s1">self.top_separator</span><span class="s2">,</span>
            <span class="s1">self.header</span><span class="s2">,</span>
            <span class="s1">self.middle_separator</span><span class="s2">,</span>
            <span class="s1">self.env_body</span><span class="s2">,</span>
            <span class="s1">self.bottom_separator</span><span class="s2">,</span>
            <span class="s1">self.env_end</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">result = </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join([item </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">elements </span><span class="s2">if </span><span class="s1">item])</span>
        <span class="s1">trailing_newline = </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
        <span class="s1">result += trailing_newline</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s1">@property</span>
    <span class="s1">@abstractmethod</span>
    <span class="s2">def </span><span class="s1">env_begin(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Beginning of the environment.&quot;&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s1">@abstractmethod</span>
    <span class="s2">def </span><span class="s1">top_separator(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Top level separator.&quot;&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s1">@abstractmethod</span>
    <span class="s2">def </span><span class="s1">header(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Header lines.&quot;&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s1">@abstractmethod</span>
    <span class="s2">def </span><span class="s1">middle_separator(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Middle level separator.&quot;&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s1">@abstractmethod</span>
    <span class="s2">def </span><span class="s1">env_body(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Environment body.&quot;&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s1">@abstractmethod</span>
    <span class="s2">def </span><span class="s1">bottom_separator(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Bottom level separator.&quot;&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s1">@abstractmethod</span>
    <span class="s2">def </span><span class="s1">env_end(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;End of the environment.&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">GenericTableBuilder(TableBuilderAbstract):</span>
    <span class="s0">&quot;&quot;&quot;Table builder producing string representation of LaTeX table.&quot;&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">header(self) -&gt; str:</span>
        <span class="s1">iterator = self._create_row_iterator(over=</span><span class="s3">&quot;header&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(list(iterator))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">top_separator(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">toprule&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">middle_separator(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">midrule&quot; </span><span class="s2">if </span><span class="s1">self._is_separator_required() </span><span class="s2">else </span><span class="s3">&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">env_body(self) -&gt; str:</span>
        <span class="s1">iterator = self._create_row_iterator(over=</span><span class="s3">&quot;body&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(list(iterator))</span>

    <span class="s2">def </span><span class="s1">_is_separator_required(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">bool(self.header </span><span class="s2">and </span><span class="s1">self.env_body)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_position_macro(self) -&gt; str:</span>
        <span class="s0">r&quot;&quot;&quot;Position macro, extracted from self.position, like [h].&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">f&quot;[</span><span class="s2">{</span><span class="s1">self.position</span><span class="s2">}</span><span class="s3">]&quot; </span><span class="s2">if </span><span class="s1">self.position </span><span class="s2">else </span><span class="s3">&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_caption_macro(self) -&gt; str:</span>
        <span class="s0">r&quot;&quot;&quot;Caption macro, extracted from self.caption. 
 
        With short caption: 
            \caption[short_caption]{caption_string}. 
 
        Without short caption: 
            \caption{caption_string}. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.caption:</span>
            <span class="s2">return </span><span class="s3">&quot;&quot;</span><span class="s1">.join(</span>
                <span class="s1">[</span>
                    <span class="s3">r&quot;\caption&quot;</span><span class="s2">,</span>
                    <span class="s3">f&quot;[</span><span class="s2">{</span><span class="s1">self.short_caption</span><span class="s2">}</span><span class="s3">]&quot; </span><span class="s2">if </span><span class="s1">self.short_caption </span><span class="s2">else </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
                    <span class="s3">f&quot;</span><span class="s2">{{{</span><span class="s1">self.caption</span><span class="s2">}}}</span><span class="s3">&quot;</span><span class="s2">,</span>
                <span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s3">&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_label_macro(self) -&gt; str:</span>
        <span class="s0">r&quot;&quot;&quot;Label macro, extracted from self.label, like \label{ref}.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">\\</span><span class="s3">label</span><span class="s2">{{{</span><span class="s1">self.label</span><span class="s2">}}}</span><span class="s3">&quot; </span><span class="s2">if </span><span class="s1">self.label </span><span class="s2">else </span><span class="s3">&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_create_row_iterator(self</span><span class="s2">, </span><span class="s1">over: str) -&gt; RowStringIterator:</span>
        <span class="s0">&quot;&quot;&quot;Create iterator over header or body of the table. 
 
        Parameters 
        ---------- 
        over : {'body', 'header'} 
            Over what to iterate. 
 
        Returns 
        ------- 
        RowStringIterator 
            Iterator over body or header. 
        &quot;&quot;&quot;</span>
        <span class="s1">iterator_kind = self._select_iterator(over)</span>
        <span class="s2">return </span><span class="s1">iterator_kind(</span>
            <span class="s1">formatter=self.fmt</span><span class="s2">,</span>
            <span class="s1">multicolumn=self.multicolumn</span><span class="s2">,</span>
            <span class="s1">multicolumn_format=self.multicolumn_format</span><span class="s2">,</span>
            <span class="s1">multirow=self.multirow</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_select_iterator(self</span><span class="s2">, </span><span class="s1">over: str) -&gt; type[RowStringIterator]:</span>
        <span class="s0">&quot;&quot;&quot;Select proper iterator over table rows.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">over == </span><span class="s3">&quot;header&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">RowHeaderIterator</span>
        <span class="s2">elif </span><span class="s1">over == </span><span class="s3">&quot;body&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">RowBodyIterator</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">f&quot;'over' must be either 'header' or 'body', but </span><span class="s2">{</span><span class="s1">over</span><span class="s2">} </span><span class="s3">was provided&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>


<span class="s2">class </span><span class="s1">LongTableBuilder(GenericTableBuilder):</span>
    <span class="s0">&quot;&quot;&quot;Concrete table builder for longtable. 
 
    &gt;&gt;&gt; from pandas.io.formats import format as fmt 
    &gt;&gt;&gt; df = pd.DataFrame({&quot;a&quot;: [1, 2], &quot;b&quot;: [&quot;b1&quot;, &quot;b2&quot;]}) 
    &gt;&gt;&gt; formatter = fmt.DataFrameFormatter(df) 
    &gt;&gt;&gt; builder = LongTableBuilder(formatter, caption='a long table', 
    ...                            label='tab:long', column_format='lrl') 
    &gt;&gt;&gt; table = builder.get_result() 
    &gt;&gt;&gt; print(table) 
    \\begin{longtable}{lrl} 
    \\caption{a long table} 
    \\label{tab:long}\\\\ 
    \\toprule 
    {} &amp;  a &amp;   b \\\\ 
    \\midrule 
    \\endfirsthead 
    \\caption[]{a long table} \\\\ 
    \\toprule 
    {} &amp;  a &amp;   b \\\\ 
    \\midrule 
    \\endhead 
    \\midrule 
    \\multicolumn{3}{r}{{Continued on next page}} \\\\ 
    \\midrule 
    \\endfoot 
    &lt;BLANKLINE&gt; 
    \\bottomrule 
    \\endlastfoot 
    0 &amp;  1 &amp;  b1 \\\\ 
    1 &amp;  2 &amp;  b2 \\\\ 
    \\end{longtable} 
    &lt;BLANKLINE&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">env_begin(self) -&gt; str:</span>
        <span class="s1">first_row = (</span>
            <span class="s3">f&quot;</span><span class="s2">\\</span><span class="s3">begin</span><span class="s2">{{</span><span class="s3">longtable</span><span class="s2">}}{</span><span class="s1">self._position_macro</span><span class="s2">}{{{</span><span class="s1">self.column_format</span><span class="s2">}}}</span><span class="s3">&quot;</span>
        <span class="s1">)</span>
        <span class="s1">elements = [first_row</span><span class="s2">, </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self._caption_and_label()</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join([item </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">elements </span><span class="s2">if </span><span class="s1">item])</span>

    <span class="s2">def </span><span class="s1">_caption_and_label(self) -&gt; str:</span>
        <span class="s2">if </span><span class="s1">self.caption </span><span class="s2">or </span><span class="s1">self.label:</span>
            <span class="s1">double_backslash = </span><span class="s3">&quot;</span><span class="s2">\\\\</span><span class="s3">&quot;</span>
            <span class="s1">elements = [</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self._caption_macro</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self._label_macro</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">]</span>
            <span class="s1">caption_and_label = </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join([item </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">elements </span><span class="s2">if </span><span class="s1">item])</span>
            <span class="s1">caption_and_label += double_backslash</span>
            <span class="s2">return </span><span class="s1">caption_and_label</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">middle_separator(self) -&gt; str:</span>
        <span class="s1">iterator = self._create_row_iterator(over=</span><span class="s3">&quot;header&quot;</span><span class="s1">)</span>

        <span class="s5"># the content between \endfirsthead and \endhead commands</span>
        <span class="s5"># mitigates repeated List of Tables entries in the final LaTeX</span>
        <span class="s5"># document when dealing with longtable environments; GH #34360</span>
        <span class="s1">elements = [</span>
            <span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">midrule&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">endfirsthead&quot;</span><span class="s2">,</span>
            <span class="s3">f&quot;</span><span class="s2">\\</span><span class="s3">caption[]</span><span class="s2">{{{</span><span class="s1">self.caption</span><span class="s2">}}} \\\\</span><span class="s3">&quot; </span><span class="s2">if </span><span class="s1">self.caption </span><span class="s2">else </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
            <span class="s1">self.top_separator</span><span class="s2">,</span>
            <span class="s1">self.header</span><span class="s2">,</span>
            <span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">midrule&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">endhead&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">midrule&quot;</span><span class="s2">,</span>
            <span class="s3">f&quot;</span><span class="s2">\\</span><span class="s3">multicolumn</span><span class="s2">{{{</span><span class="s1">len(iterator.strcols)</span><span class="s2">}}}{{</span><span class="s3">r</span><span class="s2">}}</span><span class="s3">&quot;</span>
            <span class="s3">&quot;{{Continued on next page}} </span><span class="s2">\\\\</span><span class="s3">&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">midrule&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">endfoot</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">bottomrule&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">endlastfoot&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self._is_separator_required():</span>
            <span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(elements)</span>
        <span class="s2">return </span><span class="s3">&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">bottom_separator(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">env_end(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">end{longtable}&quot;</span>


<span class="s2">class </span><span class="s1">RegularTableBuilder(GenericTableBuilder):</span>
    <span class="s0">&quot;&quot;&quot;Concrete table builder for regular table. 
 
    &gt;&gt;&gt; from pandas.io.formats import format as fmt 
    &gt;&gt;&gt; df = pd.DataFrame({&quot;a&quot;: [1, 2], &quot;b&quot;: [&quot;b1&quot;, &quot;b2&quot;]}) 
    &gt;&gt;&gt; formatter = fmt.DataFrameFormatter(df) 
    &gt;&gt;&gt; builder = RegularTableBuilder(formatter, caption='caption', label='lab', 
    ...                               column_format='lrc') 
    &gt;&gt;&gt; table = builder.get_result() 
    &gt;&gt;&gt; print(table) 
    \\begin{table} 
    \\centering 
    \\caption{caption} 
    \\label{lab} 
    \\begin{tabular}{lrc} 
    \\toprule 
    {} &amp;  a &amp;   b \\\\ 
    \\midrule 
    0 &amp;  1 &amp;  b1 \\\\ 
    1 &amp;  2 &amp;  b2 \\\\ 
    \\bottomrule 
    \\end{tabular} 
    \\end{table} 
    &lt;BLANKLINE&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">env_begin(self) -&gt; str:</span>
        <span class="s1">elements = [</span>
            <span class="s3">f&quot;</span><span class="s2">\\</span><span class="s3">begin</span><span class="s2">{{</span><span class="s3">table</span><span class="s2">}}{</span><span class="s1">self._position_macro</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">centering&quot;</span><span class="s2">,</span>
            <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self._caption_macro</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">,</span>
            <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self._label_macro</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">,</span>
            <span class="s3">f&quot;</span><span class="s2">\\</span><span class="s3">begin</span><span class="s2">{{</span><span class="s3">tabular</span><span class="s2">}}{{{</span><span class="s1">self.column_format</span><span class="s2">}}}</span><span class="s3">&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join([item </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">elements </span><span class="s2">if </span><span class="s1">item])</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">bottom_separator(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">bottomrule&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">env_end(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join([</span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">end{tabular}&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">end{table}&quot;</span><span class="s1">])</span>


<span class="s2">class </span><span class="s1">TabularBuilder(GenericTableBuilder):</span>
    <span class="s0">&quot;&quot;&quot;Concrete table builder for tabular environment. 
 
    &gt;&gt;&gt; from pandas.io.formats import format as fmt 
    &gt;&gt;&gt; df = pd.DataFrame({&quot;a&quot;: [1, 2], &quot;b&quot;: [&quot;b1&quot;, &quot;b2&quot;]}) 
    &gt;&gt;&gt; formatter = fmt.DataFrameFormatter(df) 
    &gt;&gt;&gt; builder = TabularBuilder(formatter, column_format='lrc') 
    &gt;&gt;&gt; table = builder.get_result() 
    &gt;&gt;&gt; print(table) 
    \\begin{tabular}{lrc} 
    \\toprule 
    {} &amp;  a &amp;   b \\\\ 
    \\midrule 
    0 &amp;  1 &amp;  b1 \\\\ 
    1 &amp;  2 &amp;  b2 \\\\ 
    \\bottomrule 
    \\end{tabular} 
    &lt;BLANKLINE&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">env_begin(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">\\</span><span class="s3">begin</span><span class="s2">{{</span><span class="s3">tabular</span><span class="s2">}}{{{</span><span class="s1">self.column_format</span><span class="s2">}}}</span><span class="s3">&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">bottom_separator(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">bottomrule&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">env_end(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">end{tabular}&quot;</span>


<span class="s2">class </span><span class="s1">LatexFormatter:</span>
    <span class="s0">r&quot;&quot;&quot; 
    Used to render a DataFrame to a LaTeX tabular/longtable environment output. 
 
    Parameters 
    ---------- 
    formatter : `DataFrameFormatter` 
    longtable : bool, default False 
        Use longtable environment. 
    column_format : str, default None 
        The columns format as specified in `LaTeX table format 
        &lt;https://en.wikibooks.org/wiki/LaTeX/Tables&gt;`__ e.g 'rcl' for 3 columns 
    multicolumn : bool, default False 
        Use \multicolumn to enhance MultiIndex columns. 
    multicolumn_format : str, default 'l' 
        The alignment for multicolumns, similar to `column_format` 
    multirow : bool, default False 
        Use \multirow to enhance MultiIndex rows. 
    caption : str or tuple, optional 
        Tuple (full_caption, short_caption), 
        which results in \caption[short_caption]{full_caption}; 
        if a single string is passed, no short caption will be set. 
    label : str, optional 
        The LaTeX label to be placed inside ``\label{}`` in the output. 
    position : str, optional 
        The LaTeX positional argument for tables, to be placed after 
        ``\begin{}`` in the output. 
 
    See Also 
    -------- 
    HTMLFormatter 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">formatter: DataFrameFormatter</span><span class="s2">,</span>
        <span class="s1">longtable: bool = </span><span class="s2">False,</span>
        <span class="s1">column_format: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">multicolumn: bool = </span><span class="s2">False,</span>
        <span class="s1">multicolumn_format: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">multirow: bool = </span><span class="s2">False,</span>
        <span class="s1">caption: str | tuple[str</span><span class="s2">, </span><span class="s1">str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">label: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">position: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">self.fmt = formatter</span>
        <span class="s1">self.frame = self.fmt.frame</span>
        <span class="s1">self.longtable = longtable</span>
        <span class="s1">self.column_format = column_format</span>
        <span class="s1">self.multicolumn = multicolumn</span>
        <span class="s1">self.multicolumn_format = multicolumn_format</span>
        <span class="s1">self.multirow = multirow</span>
        <span class="s1">self.caption</span><span class="s2">, </span><span class="s1">self.short_caption = _split_into_full_short_caption(caption)</span>
        <span class="s1">self.label = label</span>
        <span class="s1">self.position = position</span>

    <span class="s2">def </span><span class="s1">to_string(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        Render a DataFrame to a LaTeX tabular, longtable, or table/tabular 
        environment output. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.builder.get_result()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">builder(self) -&gt; TableBuilderAbstract:</span>
        <span class="s0">&quot;&quot;&quot;Concrete table builder. 
 
        Returns 
        ------- 
        TableBuilder 
        &quot;&quot;&quot;</span>
        <span class="s1">builder = self._select_builder()</span>
        <span class="s2">return </span><span class="s1">builder(</span>
            <span class="s1">formatter=self.fmt</span><span class="s2">,</span>
            <span class="s1">column_format=self.column_format</span><span class="s2">,</span>
            <span class="s1">multicolumn=self.multicolumn</span><span class="s2">,</span>
            <span class="s1">multicolumn_format=self.multicolumn_format</span><span class="s2">,</span>
            <span class="s1">multirow=self.multirow</span><span class="s2">,</span>
            <span class="s1">caption=self.caption</span><span class="s2">,</span>
            <span class="s1">short_caption=self.short_caption</span><span class="s2">,</span>
            <span class="s1">label=self.label</span><span class="s2">,</span>
            <span class="s1">position=self.position</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_select_builder(self) -&gt; type[TableBuilderAbstract]:</span>
        <span class="s0">&quot;&quot;&quot;Select proper table builder.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.longtable:</span>
            <span class="s2">return </span><span class="s1">LongTableBuilder</span>
        <span class="s2">if </span><span class="s1">any([self.caption</span><span class="s2">, </span><span class="s1">self.label</span><span class="s2">, </span><span class="s1">self.position]):</span>
            <span class="s2">return </span><span class="s1">RegularTableBuilder</span>
        <span class="s2">return </span><span class="s1">TabularBuilder</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">column_format(self) -&gt; str | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Column format.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._column_format</span>

    <span class="s1">@column_format.setter</span>
    <span class="s2">def </span><span class="s1">column_format(self</span><span class="s2">, </span><span class="s1">input_column_format: str | </span><span class="s2">None</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Setter for column format.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">input_column_format </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._column_format = (</span>
                <span class="s1">self._get_index_format() + self._get_column_format_based_on_dtypes()</span>
            <span class="s1">)</span>
        <span class="s2">elif not </span><span class="s1">isinstance(input_column_format</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">f&quot;column_format must be str or unicode, &quot;</span>
                <span class="s3">f&quot;not </span><span class="s2">{</span><span class="s1">type(input_column_format)</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._column_format = input_column_format</span>

    <span class="s2">def </span><span class="s1">_get_column_format_based_on_dtypes(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Get column format based on data type. 
 
        Right alignment for numbers and left - for strings. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">get_col_type(dtype):</span>
            <span class="s2">if </span><span class="s1">issubclass(dtype.type</span><span class="s2">, </span><span class="s1">np.number):</span>
                <span class="s2">return </span><span class="s3">&quot;r&quot;</span>
            <span class="s2">return </span><span class="s3">&quot;l&quot;</span>

        <span class="s1">dtypes = self.frame.dtypes._values</span>
        <span class="s2">return </span><span class="s3">&quot;&quot;</span><span class="s1">.join(map(get_col_type</span><span class="s2">, </span><span class="s1">dtypes))</span>

    <span class="s2">def </span><span class="s1">_get_index_format(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Get index column format.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">&quot;l&quot; </span><span class="s1">* self.frame.index.nlevels </span><span class="s2">if </span><span class="s1">self.fmt.index </span><span class="s2">else </span><span class="s3">&quot;&quot;</span>


<span class="s2">def </span><span class="s1">_escape_symbols(row: Sequence[str]) -&gt; list[str]:</span>
    <span class="s0">&quot;&quot;&quot;Carry out string replacements for special symbols. 
 
    Parameters 
    ---------- 
    row : list 
        List of string, that may contain special symbols. 
 
    Returns 
    ------- 
    list 
        list of strings with the special symbols replaced. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s1">x.replace(</span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">textbackslash &quot;</span><span class="s1">)</span>
            <span class="s1">.replace(</span><span class="s3">&quot;_&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">_&quot;</span><span class="s1">)</span>
            <span class="s1">.replace(</span><span class="s3">&quot;%&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">%&quot;</span><span class="s1">)</span>
            <span class="s1">.replace(</span><span class="s3">&quot;$&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">$&quot;</span><span class="s1">)</span>
            <span class="s1">.replace(</span><span class="s3">&quot;#&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">#&quot;</span><span class="s1">)</span>
            <span class="s1">.replace(</span><span class="s3">&quot;{&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">{&quot;</span><span class="s1">)</span>
            <span class="s1">.replace(</span><span class="s3">&quot;}&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">}&quot;</span><span class="s1">)</span>
            <span class="s1">.replace(</span><span class="s3">&quot;~&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">textasciitilde &quot;</span><span class="s1">)</span>
            <span class="s1">.replace(</span><span class="s3">&quot;^&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">textasciicircum &quot;</span><span class="s1">)</span>
            <span class="s1">.replace(</span><span class="s3">&quot;&amp;&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">&amp;&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">(x </span><span class="s2">and </span><span class="s1">x != </span><span class="s3">&quot;{}&quot;</span><span class="s1">)</span>
            <span class="s2">else </span><span class="s3">&quot;{}&quot;</span>
        <span class="s1">)</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">row</span>
    <span class="s1">]</span>


<span class="s2">def </span><span class="s1">_convert_to_bold(crow: Sequence[str]</span><span class="s2">, </span><span class="s1">ilevels: int) -&gt; list[str]:</span>
    <span class="s0">&quot;&quot;&quot;Convert elements in ``crow`` to bold.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">[</span>
        <span class="s3">f&quot;</span><span class="s2">\\</span><span class="s3">textbf</span><span class="s2">{{{</span><span class="s1">x</span><span class="s2">}}}</span><span class="s3">&quot; </span><span class="s2">if </span><span class="s1">j &lt; ilevels </span><span class="s2">and </span><span class="s1">x.strip() </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s3">&quot;{}&quot;</span><span class="s1">] </span><span class="s2">else </span><span class="s1">x</span>
        <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate(crow)</span>
    <span class="s1">]</span>


<span class="s2">if </span><span class="s1">__name__ == </span><span class="s3">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">doctest</span>

    <span class="s1">doctest.testmod()</span>
</pre>
</body>
</html>