<html>
<head>
<title>holiday.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
holiday.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">datetime</span><span class="s0">,</span>
    <span class="s1">timedelta</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">from </span><span class="s1">dateutil.relativedelta </span><span class="s0">import </span><span class="s1">(  </span><span class="s2"># noqa:F401</span>
    <span class="s1">FR</span><span class="s0">,</span>
    <span class="s1">MO</span><span class="s0">,</span>
    <span class="s1">SA</span><span class="s0">,</span>
    <span class="s1">SU</span><span class="s0">,</span>
    <span class="s1">TH</span><span class="s0">,</span>
    <span class="s1">TU</span><span class="s0">,</span>
    <span class="s1">WE</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas.errors </span><span class="s0">import </span><span class="s1">PerformanceWarning</span>

<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DateOffset</span><span class="s0">,</span>
    <span class="s1">DatetimeIndex</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">Timestamp</span><span class="s0">,</span>
    <span class="s1">concat</span><span class="s0">,</span>
    <span class="s1">date_range</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">pandas.tseries.offsets </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Day</span><span class="s0">,</span>
    <span class="s1">Easter</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s0">def </span><span class="s1">next_monday(dt: datetime) -&gt; datetime:</span>
    <span class="s3">&quot;&quot;&quot; 
    If holiday falls on Saturday, use following Monday instead; 
    if holiday falls on Sunday, use Monday instead 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">dt.weekday() == </span><span class="s4">5</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">dt + timedelta(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">dt.weekday() == </span><span class="s4">6</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">dt + timedelta(</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">dt</span>


<span class="s0">def </span><span class="s1">next_monday_or_tuesday(dt: datetime) -&gt; datetime:</span>
    <span class="s3">&quot;&quot;&quot; 
    For second holiday of two adjacent ones! 
    If holiday falls on Saturday, use following Monday instead; 
    if holiday falls on Sunday or Monday, use following Tuesday instead 
    (because Monday is already taken by adjacent holiday on the day before) 
    &quot;&quot;&quot;</span>
    <span class="s1">dow = dt.weekday()</span>
    <span class="s0">if </span><span class="s1">dow == </span><span class="s4">5 </span><span class="s0">or </span><span class="s1">dow == </span><span class="s4">6</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">dt + timedelta(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">dow == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">dt + timedelta(</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">dt</span>


<span class="s0">def </span><span class="s1">previous_friday(dt: datetime) -&gt; datetime:</span>
    <span class="s3">&quot;&quot;&quot; 
    If holiday falls on Saturday or Sunday, use previous Friday instead. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">dt.weekday() == </span><span class="s4">5</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">dt - timedelta(</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">dt.weekday() == </span><span class="s4">6</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">dt - timedelta(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">dt</span>


<span class="s0">def </span><span class="s1">sunday_to_monday(dt: datetime) -&gt; datetime:</span>
    <span class="s3">&quot;&quot;&quot; 
    If holiday falls on Sunday, use day thereafter (Monday) instead. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">dt.weekday() == </span><span class="s4">6</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">dt + timedelta(</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">dt</span>


<span class="s0">def </span><span class="s1">weekend_to_monday(dt: datetime) -&gt; datetime:</span>
    <span class="s3">&quot;&quot;&quot; 
    If holiday falls on Sunday or Saturday, 
    use day thereafter (Monday) instead. 
    Needed for holidays such as Christmas observation in Europe 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">dt.weekday() == </span><span class="s4">6</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">dt + timedelta(</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">dt.weekday() == </span><span class="s4">5</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">dt + timedelta(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">dt</span>


<span class="s0">def </span><span class="s1">nearest_workday(dt: datetime) -&gt; datetime:</span>
    <span class="s3">&quot;&quot;&quot; 
    If holiday falls on Saturday, use day before (Friday) instead; 
    if holiday falls on Sunday, use day thereafter (Monday) instead. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">dt.weekday() == </span><span class="s4">5</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">dt - timedelta(</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">dt.weekday() == </span><span class="s4">6</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">dt + timedelta(</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">dt</span>


<span class="s0">def </span><span class="s1">next_workday(dt: datetime) -&gt; datetime:</span>
    <span class="s3">&quot;&quot;&quot; 
    returns next weekday used for observances 
    &quot;&quot;&quot;</span>
    <span class="s1">dt += timedelta(days=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">while </span><span class="s1">dt.weekday() &gt; </span><span class="s4">4</span><span class="s1">:</span>
        <span class="s2"># Mon-Fri are 0-4</span>
        <span class="s1">dt += timedelta(days=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">dt</span>


<span class="s0">def </span><span class="s1">previous_workday(dt: datetime) -&gt; datetime:</span>
    <span class="s3">&quot;&quot;&quot; 
    returns previous weekday used for observances 
    &quot;&quot;&quot;</span>
    <span class="s1">dt -= timedelta(days=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">while </span><span class="s1">dt.weekday() &gt; </span><span class="s4">4</span><span class="s1">:</span>
        <span class="s2"># Mon-Fri are 0-4</span>
        <span class="s1">dt -= timedelta(days=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">dt</span>


<span class="s0">def </span><span class="s1">before_nearest_workday(dt: datetime) -&gt; datetime:</span>
    <span class="s3">&quot;&quot;&quot; 
    returns previous workday after nearest workday 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">previous_workday(nearest_workday(dt))</span>


<span class="s0">def </span><span class="s1">after_nearest_workday(dt: datetime) -&gt; datetime:</span>
    <span class="s3">&quot;&quot;&quot; 
    returns next workday after nearest workday 
    needed for Boxing day or multiple holidays in a series 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">next_workday(nearest_workday(dt))</span>


<span class="s0">class </span><span class="s1">Holiday:</span>
    <span class="s3">&quot;&quot;&quot; 
    Class that defines a holiday with start/end dates and rules 
    for observance. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">name</span><span class="s0">,</span>
        <span class="s1">year=</span><span class="s0">None,</span>
        <span class="s1">month=</span><span class="s0">None,</span>
        <span class="s1">day=</span><span class="s0">None,</span>
        <span class="s1">offset=</span><span class="s0">None,</span>
        <span class="s1">observance=</span><span class="s0">None,</span>
        <span class="s1">start_date=</span><span class="s0">None,</span>
        <span class="s1">end_date=</span><span class="s0">None,</span>
        <span class="s1">days_of_week=</span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        name : str 
            Name of the holiday , defaults to class name 
        offset : array of pandas.tseries.offsets or 
                class from pandas.tseries.offsets 
            computes offset from date 
        observance: function 
            computes when holiday is given a pandas Timestamp 
        days_of_week: 
            provide a tuple of days e.g  (0,1,2,3,) for Monday Through Thursday 
            Monday=0,..,Sunday=6 
 
        Examples 
        -------- 
        &gt;&gt;&gt; from pandas.tseries.holiday import Holiday, nearest_workday 
        &gt;&gt;&gt; from dateutil.relativedelta import MO 
 
        &gt;&gt;&gt; USMemorialDay = Holiday( 
        ...     &quot;Memorial Day&quot;, month=5, day=31, offset=pd.DateOffset(weekday=MO(-1)) 
        ... ) 
        &gt;&gt;&gt; USMemorialDay 
        Holiday: Memorial Day (month=5, day=31, offset=&lt;DateOffset: weekday=MO(-1)&gt;) 
 
        &gt;&gt;&gt; USLaborDay = Holiday( 
        ...     &quot;Labor Day&quot;, month=9, day=1, offset=pd.DateOffset(weekday=MO(1)) 
        ... ) 
        &gt;&gt;&gt; USLaborDay 
        Holiday: Labor Day (month=9, day=1, offset=&lt;DateOffset: weekday=MO(+1)&gt;) 
 
        &gt;&gt;&gt; July3rd = Holiday(&quot;July 3rd&quot;, month=7, day=3) 
        &gt;&gt;&gt; July3rd 
        Holiday: July 3rd (month=7, day=3, ) 
 
        &gt;&gt;&gt; NewYears = Holiday( 
        ...     &quot;New Years Day&quot;, month=1,  day=1, 
        ...      observance=nearest_workday 
        ... ) 
        &gt;&gt;&gt; NewYears  # doctest: +SKIP 
        Holiday: New Years Day ( 
            month=1, day=1, observance=&lt;function nearest_workday at 0x66545e9bc440&gt; 
        ) 
 
        &gt;&gt;&gt; July3rd = Holiday(&quot;July 3rd&quot;, month=7, day=3, days_of_week=(0, 1, 2, 3)) 
        &gt;&gt;&gt; July3rd 
        Holiday: July 3rd (month=7, day=3, ) 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">offset </span><span class="s0">is not None and </span><span class="s1">observance </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s5">&quot;Cannot use both offset and observance.&quot;</span><span class="s1">)</span>

        <span class="s1">self.name = name</span>
        <span class="s1">self.year = year</span>
        <span class="s1">self.month = month</span>
        <span class="s1">self.day = day</span>
        <span class="s1">self.offset = offset</span>
        <span class="s1">self.start_date = (</span>
            <span class="s1">Timestamp(start_date) </span><span class="s0">if </span><span class="s1">start_date </span><span class="s0">is not None else </span><span class="s1">start_date</span>
        <span class="s1">)</span>
        <span class="s1">self.end_date = Timestamp(end_date) </span><span class="s0">if </span><span class="s1">end_date </span><span class="s0">is not None else </span><span class="s1">end_date</span>
        <span class="s1">self.observance = observance</span>
        <span class="s0">assert </span><span class="s1">days_of_week </span><span class="s0">is None or </span><span class="s1">type(days_of_week) == tuple</span>
        <span class="s1">self.days_of_week = days_of_week</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s1">info = </span><span class="s5">&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.year </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">info += </span><span class="s5">f&quot;year=</span><span class="s0">{</span><span class="s1">self.year</span><span class="s0">}</span><span class="s5">, &quot;</span>
        <span class="s1">info += </span><span class="s5">f&quot;month=</span><span class="s0">{</span><span class="s1">self.month</span><span class="s0">}</span><span class="s5">, day=</span><span class="s0">{</span><span class="s1">self.day</span><span class="s0">}</span><span class="s5">, &quot;</span>

        <span class="s0">if </span><span class="s1">self.offset </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">info += </span><span class="s5">f&quot;offset=</span><span class="s0">{</span><span class="s1">self.offset</span><span class="s0">}</span><span class="s5">&quot;</span>

        <span class="s0">if </span><span class="s1">self.observance </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">info += </span><span class="s5">f&quot;observance=</span><span class="s0">{</span><span class="s1">self.observance</span><span class="s0">}</span><span class="s5">&quot;</span>

        <span class="s1">repr = </span><span class="s5">f&quot;Holiday: </span><span class="s0">{</span><span class="s1">self.name</span><span class="s0">} </span><span class="s5">(</span><span class="s0">{</span><span class="s1">info</span><span class="s0">}</span><span class="s5">)&quot;</span>
        <span class="s0">return </span><span class="s1">repr</span>

    <span class="s0">def </span><span class="s1">dates(self</span><span class="s0">, </span><span class="s1">start_date</span><span class="s0">, </span><span class="s1">end_date</span><span class="s0">, </span><span class="s1">return_name=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Calculate holidays observed between start date and end date 
 
        Parameters 
        ---------- 
        start_date : starting date, datetime-like, optional 
        end_date : ending date, datetime-like, optional 
        return_name : bool, optional, default=False 
            If True, return a series that has dates and holiday names. 
            False will only return dates. 
        &quot;&quot;&quot;</span>
        <span class="s1">start_date = Timestamp(start_date)</span>
        <span class="s1">end_date = Timestamp(end_date)</span>

        <span class="s1">filter_start_date = start_date</span>
        <span class="s1">filter_end_date = end_date</span>

        <span class="s0">if </span><span class="s1">self.year </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">dt = Timestamp(datetime(self.year</span><span class="s0">, </span><span class="s1">self.month</span><span class="s0">, </span><span class="s1">self.day))</span>
            <span class="s0">if </span><span class="s1">return_name:</span>
                <span class="s0">return </span><span class="s1">Series(self.name</span><span class="s0">, </span><span class="s1">index=[dt])</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">[dt]</span>

        <span class="s1">dates = self._reference_dates(start_date</span><span class="s0">, </span><span class="s1">end_date)</span>
        <span class="s1">holiday_dates = self._apply_rule(dates)</span>
        <span class="s0">if </span><span class="s1">self.days_of_week </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">holiday_dates = holiday_dates[</span>
                <span class="s1">np.in1d(holiday_dates.dayofweek</span><span class="s0">, </span><span class="s1">self.days_of_week)</span>
            <span class="s1">]</span>

        <span class="s0">if </span><span class="s1">self.start_date </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">filter_start_date = max(</span>
                <span class="s1">self.start_date.tz_localize(filter_start_date.tz)</span><span class="s0">, </span><span class="s1">filter_start_date</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self.end_date </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">filter_end_date = min(</span>
                <span class="s1">self.end_date.tz_localize(filter_end_date.tz)</span><span class="s0">, </span><span class="s1">filter_end_date</span>
            <span class="s1">)</span>
        <span class="s1">holiday_dates = holiday_dates[</span>
            <span class="s1">(holiday_dates &gt;= filter_start_date) &amp; (holiday_dates &lt;= filter_end_date)</span>
        <span class="s1">]</span>
        <span class="s0">if </span><span class="s1">return_name:</span>
            <span class="s0">return </span><span class="s1">Series(self.name</span><span class="s0">, </span><span class="s1">index=holiday_dates)</span>
        <span class="s0">return </span><span class="s1">holiday_dates</span>

    <span class="s0">def </span><span class="s1">_reference_dates(self</span><span class="s0">, </span><span class="s1">start_date</span><span class="s0">, </span><span class="s1">end_date):</span>
        <span class="s3">&quot;&quot;&quot; 
        Get reference dates for the holiday. 
 
        Return reference dates for the holiday also returning the year 
        prior to the start_date and year following the end_date.  This ensures 
        that any offsets to be applied will yield the holidays within 
        the passed in dates. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.start_date </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">start_date = self.start_date.tz_localize(start_date.tz)</span>

        <span class="s0">if </span><span class="s1">self.end_date </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">end_date = self.end_date.tz_localize(start_date.tz)</span>

        <span class="s1">year_offset = DateOffset(years=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">reference_start_date = Timestamp(</span>
            <span class="s1">datetime(start_date.year - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">self.month</span><span class="s0">, </span><span class="s1">self.day)</span>
        <span class="s1">)</span>

        <span class="s1">reference_end_date = Timestamp(</span>
            <span class="s1">datetime(end_date.year + </span><span class="s4">1</span><span class="s0">, </span><span class="s1">self.month</span><span class="s0">, </span><span class="s1">self.day)</span>
        <span class="s1">)</span>
        <span class="s2"># Don't process unnecessary holidays</span>
        <span class="s1">dates = date_range(</span>
            <span class="s1">start=reference_start_date</span><span class="s0">,</span>
            <span class="s1">end=reference_end_date</span><span class="s0">,</span>
            <span class="s1">freq=year_offset</span><span class="s0">,</span>
            <span class="s1">tz=start_date.tz</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">dates</span>

    <span class="s0">def </span><span class="s1">_apply_rule(self</span><span class="s0">, </span><span class="s1">dates):</span>
        <span class="s3">&quot;&quot;&quot; 
        Apply the given offset/observance to a DatetimeIndex of dates. 
 
        Parameters 
        ---------- 
        dates : DatetimeIndex 
            Dates to apply the given offset/observance rule 
 
        Returns 
        ------- 
        Dates with rules applied 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.observance </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">dates.map(</span><span class="s0">lambda </span><span class="s1">d: self.observance(d))</span>

        <span class="s0">if </span><span class="s1">self.offset </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">isinstance(self.offset</span><span class="s0">, </span><span class="s1">list):</span>
                <span class="s1">offsets = [self.offset]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">offsets = self.offset</span>
            <span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">offsets:</span>

                <span class="s2"># if we are adding a non-vectorized value</span>
                <span class="s2"># ignore the PerformanceWarnings:</span>
                <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
                    <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">PerformanceWarning)</span>
                    <span class="s1">dates += offset</span>
        <span class="s0">return </span><span class="s1">dates</span>


<span class="s1">holiday_calendars = {}</span>


<span class="s0">def </span><span class="s1">register(cls):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">name = cls.name</span>
    <span class="s0">except </span><span class="s1">AttributeError:</span>
        <span class="s1">name = cls.__name__</span>
    <span class="s1">holiday_calendars[name] = cls</span>


<span class="s0">def </span><span class="s1">get_calendar(name):</span>
    <span class="s3">&quot;&quot;&quot; 
    Return an instance of a calendar based on its name. 
 
    Parameters 
    ---------- 
    name : str 
        Calendar name to return an instance of 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">holiday_calendars[name]()</span>


<span class="s0">class </span><span class="s1">HolidayCalendarMetaClass(type):</span>
    <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">clsname</span><span class="s0">, </span><span class="s1">bases</span><span class="s0">, </span><span class="s1">attrs):</span>
        <span class="s1">calendar_class = super().__new__(cls</span><span class="s0">, </span><span class="s1">clsname</span><span class="s0">, </span><span class="s1">bases</span><span class="s0">, </span><span class="s1">attrs)</span>
        <span class="s1">register(calendar_class)</span>
        <span class="s0">return </span><span class="s1">calendar_class</span>


<span class="s0">class </span><span class="s1">AbstractHolidayCalendar(metaclass=HolidayCalendarMetaClass):</span>
    <span class="s3">&quot;&quot;&quot; 
    Abstract interface to create holidays following certain rules. 
    &quot;&quot;&quot;</span>

    <span class="s1">rules: list[Holiday] = []</span>
    <span class="s1">start_date = Timestamp(datetime(</span><span class="s4">1970</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">end_date = Timestamp(datetime(</span><span class="s4">2200</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">31</span><span class="s1">))</span>
    <span class="s1">_cache = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None, </span><span class="s1">rules=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Initializes holiday object with a given set a rules.  Normally 
        classes just have the rules defined within them. 
 
        Parameters 
        ---------- 
        name : str 
            Name of the holiday calendar, defaults to class name 
        rules : array of Holiday objects 
            A set of rules used to create the holidays. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">name = type(self).__name__</span>
        <span class="s1">self.name = name</span>

        <span class="s0">if </span><span class="s1">rules </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.rules = rules</span>

    <span class="s0">def </span><span class="s1">rule_from_name(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s0">for </span><span class="s1">rule </span><span class="s0">in </span><span class="s1">self.rules:</span>
            <span class="s0">if </span><span class="s1">rule.name == name:</span>
                <span class="s0">return </span><span class="s1">rule</span>

        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">holidays(self</span><span class="s0">, </span><span class="s1">start=</span><span class="s0">None, </span><span class="s1">end=</span><span class="s0">None, </span><span class="s1">return_name=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns a curve with holidays between start_date and end_date 
 
        Parameters 
        ---------- 
        start : starting date, datetime-like, optional 
        end : ending date, datetime-like, optional 
        return_name : bool, optional 
            If True, return a series that has dates and holiday names. 
            False will only return a DatetimeIndex of dates. 
 
        Returns 
        ------- 
            DatetimeIndex of holidays 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.rules </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">Exception(</span>
                <span class="s5">f&quot;Holiday Calendar </span><span class="s0">{</span><span class="s1">self.name</span><span class="s0">} </span><span class="s5">does not have any rules specified&quot;</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">start </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">start = AbstractHolidayCalendar.start_date</span>

        <span class="s0">if </span><span class="s1">end </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">end = AbstractHolidayCalendar.end_date</span>

        <span class="s1">start = Timestamp(start)</span>
        <span class="s1">end = Timestamp(end)</span>

        <span class="s2"># If we don't have a cache or the dates are outside the prior cache, we</span>
        <span class="s2"># get them again</span>
        <span class="s0">if </span><span class="s1">self._cache </span><span class="s0">is None or </span><span class="s1">start &lt; self._cache[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">or </span><span class="s1">end &gt; self._cache[</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s1">pre_holidays = [</span>
                <span class="s1">rule.dates(start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">return_name=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">for </span><span class="s1">rule </span><span class="s0">in </span><span class="s1">self.rules</span>
            <span class="s1">]</span>
            <span class="s0">if </span><span class="s1">pre_holidays:</span>
                <span class="s1">holidays = concat(pre_holidays)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">holidays = Series(index=DatetimeIndex([])</span><span class="s0">, </span><span class="s1">dtype=object)</span>

            <span class="s1">self._cache = (start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">holidays.sort_index())</span>

        <span class="s1">holidays = self._cache[</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">holidays = holidays[start:end]</span>

        <span class="s0">if </span><span class="s1">return_name:</span>
            <span class="s0">return </span><span class="s1">holidays</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">holidays.index</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">merge_class(base</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s3">&quot;&quot;&quot; 
        Merge holiday calendars together. The base calendar 
        will take precedence to other. The merge will be done 
        based on each holiday's name. 
 
        Parameters 
        ---------- 
        base : AbstractHolidayCalendar 
          instance/subclass or array of Holiday objects 
        other : AbstractHolidayCalendar 
          instance/subclass or array of Holiday objects 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">other = other.rules</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s0">pass</span>

        <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">list):</span>
            <span class="s1">other = [other]</span>
        <span class="s1">other_holidays = {holiday.name: holiday </span><span class="s0">for </span><span class="s1">holiday </span><span class="s0">in </span><span class="s1">other}</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">base = base.rules</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s0">pass</span>

        <span class="s0">if not </span><span class="s1">isinstance(base</span><span class="s0">, </span><span class="s1">list):</span>
            <span class="s1">base = [base]</span>
        <span class="s1">base_holidays = {holiday.name: holiday </span><span class="s0">for </span><span class="s1">holiday </span><span class="s0">in </span><span class="s1">base}</span>

        <span class="s1">other_holidays.update(base_holidays)</span>
        <span class="s0">return </span><span class="s1">list(other_holidays.values())</span>

    <span class="s0">def </span><span class="s1">merge(self</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Merge holiday calendars together.  The caller's class 
        rules take precedence.  The merge will be done 
        based on each holiday's name. 
 
        Parameters 
        ---------- 
        other : holiday calendar 
        inplace : bool (default=False) 
            If True set rule_table to holidays, else return array of Holidays 
        &quot;&quot;&quot;</span>
        <span class="s1">holidays = self.merge_class(self</span><span class="s0">, </span><span class="s1">other)</span>
        <span class="s0">if </span><span class="s1">inplace:</span>
            <span class="s1">self.rules = holidays</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">holidays</span>


<span class="s1">USMemorialDay = Holiday(</span>
    <span class="s5">&quot;Memorial Day&quot;</span><span class="s0">, </span><span class="s1">month=</span><span class="s4">5</span><span class="s0">, </span><span class="s1">day=</span><span class="s4">31</span><span class="s0">, </span><span class="s1">offset=DateOffset(weekday=MO(-</span><span class="s4">1</span><span class="s1">))</span>
<span class="s1">)</span>
<span class="s1">USLaborDay = Holiday(</span><span class="s5">&quot;Labor Day&quot;</span><span class="s0">, </span><span class="s1">month=</span><span class="s4">9</span><span class="s0">, </span><span class="s1">day=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">offset=DateOffset(weekday=MO(</span><span class="s4">1</span><span class="s1">)))</span>
<span class="s1">USColumbusDay = Holiday(</span>
    <span class="s5">&quot;Columbus Day&quot;</span><span class="s0">, </span><span class="s1">month=</span><span class="s4">10</span><span class="s0">, </span><span class="s1">day=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">offset=DateOffset(weekday=MO(</span><span class="s4">2</span><span class="s1">))</span>
<span class="s1">)</span>
<span class="s1">USThanksgivingDay = Holiday(</span>
    <span class="s5">&quot;Thanksgiving Day&quot;</span><span class="s0">, </span><span class="s1">month=</span><span class="s4">11</span><span class="s0">, </span><span class="s1">day=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">offset=DateOffset(weekday=TH(</span><span class="s4">4</span><span class="s1">))</span>
<span class="s1">)</span>
<span class="s1">USMartinLutherKingJr = Holiday(</span>
    <span class="s5">&quot;Birthday of Martin Luther King, Jr.&quot;</span><span class="s0">,</span>
    <span class="s1">start_date=datetime(</span><span class="s4">1986</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">month=</span><span class="s4">1</span><span class="s0">,</span>
    <span class="s1">day=</span><span class="s4">1</span><span class="s0">,</span>
    <span class="s1">offset=DateOffset(weekday=MO(</span><span class="s4">3</span><span class="s1">))</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">USPresidentsDay = Holiday(</span>
    <span class="s5">&quot;Washington’s Birthday&quot;</span><span class="s0">, </span><span class="s1">month=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">day=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">offset=DateOffset(weekday=MO(</span><span class="s4">3</span><span class="s1">))</span>
<span class="s1">)</span>
<span class="s1">GoodFriday = Holiday(</span><span class="s5">&quot;Good Friday&quot;</span><span class="s0">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">day=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">offset=[Easter()</span><span class="s0">, </span><span class="s1">Day(-</span><span class="s4">2</span><span class="s1">)])</span>

<span class="s1">EasterMonday = Holiday(</span><span class="s5">&quot;Easter Monday&quot;</span><span class="s0">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">day=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">offset=[Easter()</span><span class="s0">, </span><span class="s1">Day(</span><span class="s4">1</span><span class="s1">)])</span>


<span class="s0">class </span><span class="s1">USFederalHolidayCalendar(AbstractHolidayCalendar):</span>
    <span class="s3">&quot;&quot;&quot; 
    US Federal Government Holiday Calendar based on rules specified by: 
    https://www.opm.gov/policy-data-oversight/ 
       snow-dismissal-procedures/federal-holidays/ 
    &quot;&quot;&quot;</span>

    <span class="s1">rules = [</span>
        <span class="s1">Holiday(</span><span class="s5">&quot;New Year's Day&quot;</span><span class="s0">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">day=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">observance=nearest_workday)</span><span class="s0">,</span>
        <span class="s1">USMartinLutherKingJr</span><span class="s0">,</span>
        <span class="s1">USPresidentsDay</span><span class="s0">,</span>
        <span class="s1">USMemorialDay</span><span class="s0">,</span>
        <span class="s1">Holiday(</span>
            <span class="s5">&quot;Juneteenth National Independence Day&quot;</span><span class="s0">,</span>
            <span class="s1">month=</span><span class="s4">6</span><span class="s0">,</span>
            <span class="s1">day=</span><span class="s4">19</span><span class="s0">,</span>
            <span class="s1">start_date=</span><span class="s5">&quot;2021-06-18&quot;</span><span class="s0">,</span>
            <span class="s1">observance=nearest_workday</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">Holiday(</span><span class="s5">&quot;Independence Day&quot;</span><span class="s0">, </span><span class="s1">month=</span><span class="s4">7</span><span class="s0">, </span><span class="s1">day=</span><span class="s4">4</span><span class="s0">, </span><span class="s1">observance=nearest_workday)</span><span class="s0">,</span>
        <span class="s1">USLaborDay</span><span class="s0">,</span>
        <span class="s1">USColumbusDay</span><span class="s0">,</span>
        <span class="s1">Holiday(</span><span class="s5">&quot;Veterans Day&quot;</span><span class="s0">, </span><span class="s1">month=</span><span class="s4">11</span><span class="s0">, </span><span class="s1">day=</span><span class="s4">11</span><span class="s0">, </span><span class="s1">observance=nearest_workday)</span><span class="s0">,</span>
        <span class="s1">USThanksgivingDay</span><span class="s0">,</span>
        <span class="s1">Holiday(</span><span class="s5">&quot;Christmas Day&quot;</span><span class="s0">, </span><span class="s1">month=</span><span class="s4">12</span><span class="s0">, </span><span class="s1">day=</span><span class="s4">25</span><span class="s0">, </span><span class="s1">observance=nearest_workday)</span><span class="s0">,</span>
    <span class="s1">]</span>


<span class="s0">def </span><span class="s1">HolidayCalendarFactory(name</span><span class="s0">, </span><span class="s1">base</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">base_class=AbstractHolidayCalendar):</span>
    <span class="s1">rules = AbstractHolidayCalendar.merge_class(base</span><span class="s0">, </span><span class="s1">other)</span>
    <span class="s1">calendar_class = type(name</span><span class="s0">, </span><span class="s1">(base_class</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{</span><span class="s5">&quot;rules&quot;</span><span class="s1">: rules</span><span class="s0">, </span><span class="s5">&quot;name&quot;</span><span class="s1">: name})</span>
    <span class="s0">return </span><span class="s1">calendar_class</span>
</pre>
</body>
</html>