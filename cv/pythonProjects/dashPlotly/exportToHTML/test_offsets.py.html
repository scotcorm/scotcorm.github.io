<html>
<head>
<title>test_offsets.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_offsets.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests of pandas.tseries.offsets 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">datetime</span><span class="s2">,</span>
    <span class="s1">timedelta</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Dict</span><span class="s2">,</span>
    <span class="s1">List</span><span class="s2">,</span>
    <span class="s1">Tuple</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">pandas._libs.tslibs </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">NaT</span><span class="s2">,</span>
    <span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">conversion</span><span class="s2">,</span>
    <span class="s1">timezones</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas._libs.tslibs.offsets </span><span class="s2">as </span><span class="s1">liboffsets</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs.offsets </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_get_offset</span><span class="s2">,</span>
    <span class="s1">_offset_map</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs.period </span><span class="s2">import </span><span class="s1">INVALID_FREQ_ERR_MSG</span>
<span class="s2">from </span><span class="s1">pandas.errors </span><span class="s2">import </span><span class="s1">PerformanceWarning</span>

<span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">DatetimeIndex</span>
<span class="s2">import </span><span class="s1">pandas._testing </span><span class="s2">as </span><span class="s1">tm</span>
<span class="s2">from </span><span class="s1">pandas.tests.tseries.offsets.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Base</span><span class="s2">,</span>
    <span class="s1">WeekDay</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">import </span><span class="s1">pandas.tseries.offsets </span><span class="s2">as </span><span class="s1">offsets</span>
<span class="s2">from </span><span class="s1">pandas.tseries.offsets </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">FY5253</span><span class="s2">,</span>
    <span class="s1">BaseOffset</span><span class="s2">,</span>
    <span class="s1">BDay</span><span class="s2">,</span>
    <span class="s1">BMonthEnd</span><span class="s2">,</span>
    <span class="s1">BusinessHour</span><span class="s2">,</span>
    <span class="s1">CustomBusinessDay</span><span class="s2">,</span>
    <span class="s1">CustomBusinessHour</span><span class="s2">,</span>
    <span class="s1">CustomBusinessMonthBegin</span><span class="s2">,</span>
    <span class="s1">CustomBusinessMonthEnd</span><span class="s2">,</span>
    <span class="s1">DateOffset</span><span class="s2">,</span>
    <span class="s1">Easter</span><span class="s2">,</span>
    <span class="s1">FY5253Quarter</span><span class="s2">,</span>
    <span class="s1">LastWeekOfMonth</span><span class="s2">,</span>
    <span class="s1">MonthBegin</span><span class="s2">,</span>
    <span class="s1">Nano</span><span class="s2">,</span>
    <span class="s1">Tick</span><span class="s2">,</span>
    <span class="s1">Week</span><span class="s2">,</span>
    <span class="s1">WeekOfMonth</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s1">_ApplyCases = List[Tuple[BaseOffset</span><span class="s2">, </span><span class="s1">Dict[datetime</span><span class="s2">, </span><span class="s1">datetime]]]</span>


<span class="s2">class </span><span class="s1">TestCommon(Base):</span>
    <span class="s3"># executed value created by Base._get_offset</span>
    <span class="s3"># are applied to 2011/01/01 09:00 (Saturday)</span>
    <span class="s3"># used for .apply and .rollforward</span>
    <span class="s1">expecteds = {</span>
        <span class="s4">&quot;Day&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-02 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;DateOffset&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-02 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;BusinessDay&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-03 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;CustomBusinessDay&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-03 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;CustomBusinessMonthEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;CustomBusinessMonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-03 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;MonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-02-01 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;BusinessMonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-03 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;MonthEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;SemiMonthEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-15 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;SemiMonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-15 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;BusinessMonthEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;YearBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2012-01-01 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;BYearBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-03 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;YearEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;BYearEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-12-30 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;QuarterBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-03-01 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;BQuarterBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-03-01 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;QuarterEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-03-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;BQuarterEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-03-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;BusinessHour&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-03 10:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;CustomBusinessHour&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-03 10:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;WeekOfMonth&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-08 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;LastWeekOfMonth&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-29 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;FY5253Quarter&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-25 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;FY5253&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-25 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;Week&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-08 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;Easter&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-04-24 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;Hour&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-01 10:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;Minute&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-01 09:01:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;Second&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-01 09:00:01&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;Milli&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-01 09:00:00.001000&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;Micro&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-01 09:00:00.000001&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">&quot;Nano&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-01T09:00:00.000000001&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">test_immutable(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s3"># GH#21341 check that __setattr__ raises</span>
        <span class="s1">offset = self._get_offset(offset_types)</span>
        <span class="s1">msg = </span><span class="s4">&quot;objects is not writable|DateOffset objects are immutable&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">offset.normalize = </span><span class="s2">True</span>
        <span class="s2">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">offset.n = </span><span class="s5">91</span>

    <span class="s2">def </span><span class="s1">test_return_type(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s1">offset = self._get_offset(offset_types)</span>

        <span class="s3"># make sure that we are returning a Timestamp</span>
        <span class="s1">result = Timestamp(</span><span class="s4">&quot;20080101&quot;</span><span class="s1">) + offset</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>

        <span class="s3"># make sure that we are returning NaT</span>
        <span class="s2">assert </span><span class="s1">NaT + offset </span><span class="s2">is </span><span class="s1">NaT</span>
        <span class="s2">assert </span><span class="s1">offset + NaT </span><span class="s2">is </span><span class="s1">NaT</span>

        <span class="s2">assert </span><span class="s1">NaT - offset </span><span class="s2">is </span><span class="s1">NaT</span>
        <span class="s2">assert </span><span class="s1">(-offset)._apply(NaT) </span><span class="s2">is </span><span class="s1">NaT</span>

    <span class="s2">def </span><span class="s1">test_offset_n(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s1">offset = self._get_offset(offset_types)</span>
        <span class="s2">assert </span><span class="s1">offset.n == </span><span class="s5">1</span>

        <span class="s1">neg_offset = offset * -</span><span class="s5">1</span>
        <span class="s2">assert </span><span class="s1">neg_offset.n == -</span><span class="s5">1</span>

        <span class="s1">mul_offset = offset * </span><span class="s5">3</span>
        <span class="s2">assert </span><span class="s1">mul_offset.n == </span><span class="s5">3</span>

    <span class="s2">def </span><span class="s1">test_offset_timedelta64_arg(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s3"># check that offset._validate_n raises TypeError on a timedelt64</span>
        <span class="s3">#  object</span>
        <span class="s1">off = self._get_offset(offset_types)</span>

        <span class="s1">td64 = np.timedelta64(</span><span class="s5">4567</span><span class="s2">, </span><span class="s4">&quot;s&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;argument must be an integer&quot;</span><span class="s1">):</span>
            <span class="s1">type(off)(n=td64</span><span class="s2">, </span><span class="s1">**off.kwds)</span>

    <span class="s2">def </span><span class="s1">test_offset_mul_ndarray(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s1">off = self._get_offset(offset_types)</span>

        <span class="s1">expected = np.array([[off</span><span class="s2">, </span><span class="s1">off * </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[off * </span><span class="s5">3</span><span class="s2">, </span><span class="s1">off * </span><span class="s5">4</span><span class="s1">]])</span>

        <span class="s1">result = np.array([[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">]]) * off</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = off * np.array([[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">]])</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_offset_freqstr(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s1">offset = self._get_offset(offset_types)</span>

        <span class="s1">freqstr = offset.freqstr</span>
        <span class="s2">if </span><span class="s1">freqstr </span><span class="s2">not in </span><span class="s1">(</span><span class="s4">&quot;&lt;Easter&gt;&quot;</span><span class="s2">, </span><span class="s4">&quot;&lt;DateOffset: days=1&gt;&quot;</span><span class="s2">, </span><span class="s4">&quot;LWOM-SAT&quot;</span><span class="s1">):</span>
            <span class="s1">code = _get_offset(freqstr)</span>
            <span class="s2">assert </span><span class="s1">offset.rule_code == code</span>

    <span class="s2">def </span><span class="s1">_check_offsetfunc_works(self</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">funcname</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">normalize=</span><span class="s2">False</span><span class="s1">):</span>

        <span class="s2">if </span><span class="s1">normalize </span><span class="s2">and </span><span class="s1">issubclass(offset</span><span class="s2">, </span><span class="s1">Tick):</span>
            <span class="s3"># normalize=True disallowed for Tick subclasses GH#21427</span>
            <span class="s2">return</span>

        <span class="s1">offset_s = self._get_offset(offset</span><span class="s2">, </span><span class="s1">normalize=normalize)</span>
        <span class="s1">func = getattr(offset_s</span><span class="s2">, </span><span class="s1">funcname)</span>

        <span class="s1">result = func(dt)</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">result = func(Timestamp(dt))</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s3"># see gh-14101</span>
        <span class="s1">exp_warning = </span><span class="s2">None</span>
        <span class="s1">ts = Timestamp(dt) + Nano(</span><span class="s5">5</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">type(offset_s).__name__ == </span><span class="s4">&quot;DateOffset&quot;</span>
            <span class="s2">and </span><span class="s1">(funcname </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;apply&quot;</span><span class="s2">, </span><span class="s4">&quot;_apply&quot;</span><span class="s1">] </span><span class="s2">or </span><span class="s1">normalize)</span>
            <span class="s2">and </span><span class="s1">ts.nanosecond &gt; </span><span class="s5">0</span>
        <span class="s1">):</span>
            <span class="s1">exp_warning = UserWarning</span>

        <span class="s3"># test nanosecond is preserved</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(exp_warning):</span>
            <span class="s1">result = func(ts)</span>

        <span class="s2">if </span><span class="s1">exp_warning </span><span class="s2">is None and </span><span class="s1">funcname == </span><span class="s4">&quot;_apply&quot;</span><span class="s1">:</span>
            <span class="s3"># GH#44522</span>
            <span class="s3"># Check in this particular case to avoid headaches with</span>
            <span class="s3">#  testing for multiple warnings produced by the same call.</span>
            <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;apply is deprecated&quot;</span><span class="s1">):</span>
                <span class="s1">res2 = offset_s.apply(ts)</span>

            <span class="s2">assert </span><span class="s1">type(res2) </span><span class="s2">is </span><span class="s1">type(result)</span>
            <span class="s2">assert </span><span class="s1">res2 == result</span>

        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
        <span class="s2">if </span><span class="s1">normalize </span><span class="s2">is False</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">result == expected + Nano(</span><span class="s5">5</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s2">if </span><span class="s1">isinstance(dt</span><span class="s2">, </span><span class="s1">np.datetime64):</span>
            <span class="s3"># test tz when input is datetime or Timestamp</span>
            <span class="s2">return</span>

        <span class="s2">for </span><span class="s1">tz </span><span class="s2">in </span><span class="s1">self.timezones:</span>
            <span class="s1">expected_localize = expected.tz_localize(tz)</span>
            <span class="s1">tz_obj = timezones.maybe_get_tz(tz)</span>
            <span class="s1">dt_tz = conversion.localize_pydatetime(dt</span><span class="s2">, </span><span class="s1">tz_obj)</span>

            <span class="s1">result = func(dt_tz)</span>
            <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
            <span class="s2">assert </span><span class="s1">result == expected_localize</span>

            <span class="s1">result = func(Timestamp(dt</span><span class="s2">, </span><span class="s1">tz=tz))</span>
            <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
            <span class="s2">assert </span><span class="s1">result == expected_localize</span>

            <span class="s3"># see gh-14101</span>
            <span class="s1">exp_warning = </span><span class="s2">None</span>
            <span class="s1">ts = Timestamp(dt</span><span class="s2">, </span><span class="s1">tz=tz) + Nano(</span><span class="s5">5</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">type(offset_s).__name__ == </span><span class="s4">&quot;DateOffset&quot;</span>
                <span class="s2">and </span><span class="s1">(funcname </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;apply&quot;</span><span class="s2">, </span><span class="s4">&quot;_apply&quot;</span><span class="s1">] </span><span class="s2">or </span><span class="s1">normalize)</span>
                <span class="s2">and </span><span class="s1">ts.nanosecond &gt; </span><span class="s5">0</span>
            <span class="s1">):</span>
                <span class="s1">exp_warning = UserWarning</span>

            <span class="s3"># test nanosecond is preserved</span>
            <span class="s2">with </span><span class="s1">tm.assert_produces_warning(exp_warning):</span>
                <span class="s1">result = func(ts)</span>
            <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
            <span class="s2">if </span><span class="s1">normalize </span><span class="s2">is False</span><span class="s1">:</span>
                <span class="s2">assert </span><span class="s1">result == expected_localize + Nano(</span><span class="s5">5</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">assert </span><span class="s1">result == expected_localize</span>

    <span class="s2">def </span><span class="s1">test_apply(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s1">sdt = datetime(</span><span class="s5">2011</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">ndt = np.datetime64(</span><span class="s4">&quot;2011-01-01 09:00&quot;</span><span class="s1">)</span>

        <span class="s1">expected = self.expecteds[offset_types.__name__]</span>
        <span class="s1">expected_norm = Timestamp(expected.date())</span>

        <span class="s2">for </span><span class="s1">dt </span><span class="s2">in </span><span class="s1">[sdt</span><span class="s2">, </span><span class="s1">ndt]:</span>
            <span class="s1">self._check_offsetfunc_works(offset_types</span><span class="s2">, </span><span class="s4">&quot;_apply&quot;</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">expected)</span>

            <span class="s1">self._check_offsetfunc_works(</span>
                <span class="s1">offset_types</span><span class="s2">, </span><span class="s4">&quot;_apply&quot;</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">expected_norm</span><span class="s2">, </span><span class="s1">normalize=</span><span class="s2">True</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rollforward(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s1">expecteds = self.expecteds.copy()</span>

        <span class="s3"># result will not be changed if the target is on the offset</span>
        <span class="s1">no_changes = [</span>
            <span class="s4">&quot;Day&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;MonthBegin&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;SemiMonthBegin&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;YearBegin&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;Week&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;Hour&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;Minute&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;Second&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;Milli&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;Micro&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;Nano&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;DateOffset&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">no_changes:</span>
            <span class="s1">expecteds[n] = Timestamp(</span><span class="s4">&quot;2011/01/01 09:00&quot;</span><span class="s1">)</span>

        <span class="s1">expecteds[</span><span class="s4">&quot;BusinessHour&quot;</span><span class="s1">] = Timestamp(</span><span class="s4">&quot;2011-01-03 09:00:00&quot;</span><span class="s1">)</span>
        <span class="s1">expecteds[</span><span class="s4">&quot;CustomBusinessHour&quot;</span><span class="s1">] = Timestamp(</span><span class="s4">&quot;2011-01-03 09:00:00&quot;</span><span class="s1">)</span>

        <span class="s3"># but be changed when normalize=True</span>
        <span class="s1">norm_expected = expecteds.copy()</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">norm_expected:</span>
            <span class="s1">norm_expected[k] = Timestamp(norm_expected[k].date())</span>

        <span class="s1">normalized = {</span>
            <span class="s4">&quot;Day&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-02 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;DateOffset&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-02 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;MonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-02-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;SemiMonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-15 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;YearBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2012-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;Week&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-08 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;Hour&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;Minute&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;Second&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;Milli&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;Micro&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s1">norm_expected.update(normalized)</span>

        <span class="s1">sdt = datetime(</span><span class="s5">2011</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">ndt = np.datetime64(</span><span class="s4">&quot;2011-01-01 09:00&quot;</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">dt </span><span class="s2">in </span><span class="s1">[sdt</span><span class="s2">, </span><span class="s1">ndt]:</span>
            <span class="s1">expected = expecteds[offset_types.__name__]</span>
            <span class="s1">self._check_offsetfunc_works(offset_types</span><span class="s2">, </span><span class="s4">&quot;rollforward&quot;</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">expected)</span>
            <span class="s1">expected = norm_expected[offset_types.__name__]</span>
            <span class="s1">self._check_offsetfunc_works(</span>
                <span class="s1">offset_types</span><span class="s2">, </span><span class="s4">&quot;rollforward&quot;</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">normalize=</span><span class="s2">True</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rollback(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s1">expecteds = {</span>
            <span class="s4">&quot;BusinessDay&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;CustomBusinessDay&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;CustomBusinessMonthEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;CustomBusinessMonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-01 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;BusinessMonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-01 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;MonthEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;SemiMonthEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;BusinessMonthEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;BYearBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-01-01 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;YearEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;BYearEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;QuarterBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-01 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;BQuarterBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-01 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;QuarterEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;BQuarterEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;BusinessHour&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-31 17:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;CustomBusinessHour&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-31 17:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;WeekOfMonth&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-11 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;LastWeekOfMonth&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-25 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;FY5253Quarter&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-10-26 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;FY5253&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-01-26 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;Easter&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-04-04 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">}</span>

        <span class="s3"># result will not be changed if the target is on the offset</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s4">&quot;Day&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;MonthBegin&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;SemiMonthBegin&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;YearBegin&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;Week&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;Hour&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;Minute&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;Second&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;Milli&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;Micro&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;Nano&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;DateOffset&quot;</span><span class="s2">,</span>
        <span class="s1">]:</span>
            <span class="s1">expecteds[n] = Timestamp(</span><span class="s4">&quot;2011/01/01 09:00&quot;</span><span class="s1">)</span>

        <span class="s3"># but be changed when normalize=True</span>
        <span class="s1">norm_expected = expecteds.copy()</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">norm_expected:</span>
            <span class="s1">norm_expected[k] = Timestamp(norm_expected[k].date())</span>

        <span class="s1">normalized = {</span>
            <span class="s4">&quot;Day&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-31 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;DateOffset&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-31 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;MonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;SemiMonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-15 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;YearBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;Week&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2010-12-25 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;Hour&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;Minute&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;Second&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;Milli&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">&quot;Micro&quot;</span><span class="s1">: Timestamp(</span><span class="s4">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s1">norm_expected.update(normalized)</span>

        <span class="s1">sdt = datetime(</span><span class="s5">2011</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">ndt = np.datetime64(</span><span class="s4">&quot;2011-01-01 09:00&quot;</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">dt </span><span class="s2">in </span><span class="s1">[sdt</span><span class="s2">, </span><span class="s1">ndt]:</span>
            <span class="s1">expected = expecteds[offset_types.__name__]</span>
            <span class="s1">self._check_offsetfunc_works(offset_types</span><span class="s2">, </span><span class="s4">&quot;rollback&quot;</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">expected)</span>

            <span class="s1">expected = norm_expected[offset_types.__name__]</span>
            <span class="s1">self._check_offsetfunc_works(</span>
                <span class="s1">offset_types</span><span class="s2">, </span><span class="s4">&quot;rollback&quot;</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">normalize=</span><span class="s2">True</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_on_offset(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s1">dt = self.expecteds[offset_types.__name__]</span>
        <span class="s1">offset_s = self._get_offset(offset_types)</span>
        <span class="s2">assert </span><span class="s1">offset_s.is_on_offset(dt)</span>

        <span class="s3"># when normalize=True, is_on_offset checks time is 00:00:00</span>
        <span class="s2">if </span><span class="s1">issubclass(offset_types</span><span class="s2">, </span><span class="s1">Tick):</span>
            <span class="s3"># normalize=True disallowed for Tick subclasses GH#21427</span>
            <span class="s2">return</span>
        <span class="s1">offset_n = self._get_offset(offset_types</span><span class="s2">, </span><span class="s1">normalize=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">assert not </span><span class="s1">offset_n.is_on_offset(dt)</span>

        <span class="s2">if </span><span class="s1">offset_types </span><span class="s2">in </span><span class="s1">(BusinessHour</span><span class="s2">, </span><span class="s1">CustomBusinessHour):</span>
            <span class="s3"># In default BusinessHour (9:00-17:00), normalized time</span>
            <span class="s3"># cannot be in business hour range</span>
            <span class="s2">return</span>
        <span class="s1">date = datetime(dt.year</span><span class="s2">, </span><span class="s1">dt.month</span><span class="s2">, </span><span class="s1">dt.day)</span>
        <span class="s2">assert </span><span class="s1">offset_n.is_on_offset(date)</span>

    <span class="s2">def </span><span class="s1">test_add(self</span><span class="s2">, </span><span class="s1">offset_types</span><span class="s2">, </span><span class="s1">tz_naive_fixture):</span>
        <span class="s1">tz = tz_naive_fixture</span>
        <span class="s1">dt = datetime(</span><span class="s5">2011</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">offset_s = self._get_offset(offset_types)</span>
        <span class="s1">expected = self.expecteds[offset_types.__name__]</span>

        <span class="s1">result_dt = dt + offset_s</span>
        <span class="s1">result_ts = Timestamp(dt) + offset_s</span>
        <span class="s2">for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">[result_dt</span><span class="s2">, </span><span class="s1">result_ts]:</span>
            <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
            <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">expected_localize = expected.tz_localize(tz)</span>
        <span class="s1">result = Timestamp(dt</span><span class="s2">, </span><span class="s1">tz=tz) + offset_s</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
        <span class="s2">assert </span><span class="s1">result == expected_localize</span>

        <span class="s3"># normalize=True, disallowed for Tick subclasses GH#21427</span>
        <span class="s2">if </span><span class="s1">issubclass(offset_types</span><span class="s2">, </span><span class="s1">Tick):</span>
            <span class="s2">return</span>
        <span class="s1">offset_s = self._get_offset(offset_types</span><span class="s2">, </span><span class="s1">normalize=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">expected = Timestamp(expected.date())</span>

        <span class="s1">result_dt = dt + offset_s</span>
        <span class="s1">result_ts = Timestamp(dt) + offset_s</span>
        <span class="s2">for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">[result_dt</span><span class="s2">, </span><span class="s1">result_ts]:</span>
            <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
            <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">expected_localize = expected.tz_localize(tz)</span>
        <span class="s1">result = Timestamp(dt</span><span class="s2">, </span><span class="s1">tz=tz) + offset_s</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
        <span class="s2">assert </span><span class="s1">result == expected_localize</span>

    <span class="s2">def </span><span class="s1">test_add_empty_datetimeindex(self</span><span class="s2">, </span><span class="s1">offset_types</span><span class="s2">, </span><span class="s1">tz_naive_fixture):</span>
        <span class="s3"># GH#12724, GH#30336</span>
        <span class="s1">offset_s = self._get_offset(offset_types)</span>

        <span class="s1">dti = DatetimeIndex([]</span><span class="s2">, </span><span class="s1">tz=tz_naive_fixture)</span>

        <span class="s1">warn = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">isinstance(</span>
            <span class="s1">offset_s</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">Easter</span><span class="s2">,</span>
                <span class="s1">WeekOfMonth</span><span class="s2">,</span>
                <span class="s1">LastWeekOfMonth</span><span class="s2">,</span>
                <span class="s1">CustomBusinessDay</span><span class="s2">,</span>
                <span class="s1">BusinessHour</span><span class="s2">,</span>
                <span class="s1">CustomBusinessHour</span><span class="s2">,</span>
                <span class="s1">CustomBusinessMonthBegin</span><span class="s2">,</span>
                <span class="s1">CustomBusinessMonthEnd</span><span class="s2">,</span>
                <span class="s1">FY5253</span><span class="s2">,</span>
                <span class="s1">FY5253Quarter</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s3"># We don't have an optimized apply_index</span>
            <span class="s1">warn = PerformanceWarning</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(warn):</span>
            <span class="s1">result = dti + offset_s</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">dti)</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(warn):</span>
            <span class="s1">result = offset_s + dti</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">dti)</span>

        <span class="s1">dta = dti._data</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(warn):</span>
            <span class="s1">result = dta + offset_s</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">dta)</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(warn):</span>
            <span class="s1">result = offset_s + dta</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">dta)</span>

    <span class="s2">def </span><span class="s1">test_pickle_roundtrip(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s1">off = self._get_offset(offset_types)</span>
        <span class="s1">res = tm.round_trip_pickle(off)</span>
        <span class="s2">assert </span><span class="s1">off == res</span>
        <span class="s2">if </span><span class="s1">type(off) </span><span class="s2">is not </span><span class="s1">DateOffset:</span>
            <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">off._attributes:</span>
                <span class="s2">if </span><span class="s1">attr == </span><span class="s4">&quot;calendar&quot;</span><span class="s1">:</span>
                    <span class="s3"># np.busdaycalendar __eq__ will return False;</span>
                    <span class="s3">#  we check holidays and weekmask attrs so are OK</span>
                    <span class="s2">continue</span>
                <span class="s3"># Make sure nothings got lost from _params (which __eq__) is based on</span>
                <span class="s2">assert </span><span class="s1">getattr(off</span><span class="s2">, </span><span class="s1">attr) == getattr(res</span><span class="s2">, </span><span class="s1">attr)</span>

    <span class="s2">def </span><span class="s1">test_pickle_dateoffset_odd_inputs(self):</span>
        <span class="s3"># GH#34511</span>
        <span class="s1">off = DateOffset(months=</span><span class="s5">12</span><span class="s1">)</span>
        <span class="s1">res = tm.round_trip_pickle(off)</span>
        <span class="s2">assert </span><span class="s1">off == res</span>

        <span class="s1">base_dt = datetime(</span><span class="s5">2020</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">base_dt + off == base_dt + res</span>

    <span class="s2">def </span><span class="s1">test_onOffset_deprecated(self</span><span class="s2">, </span><span class="s1">offset_types</span><span class="s2">, </span><span class="s1">fixed_now_ts):</span>
        <span class="s3"># GH#30340 use idiomatic naming</span>
        <span class="s1">off = self._get_offset(offset_types)</span>

        <span class="s1">ts = fixed_now_ts</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
            <span class="s1">result = off.onOffset(ts)</span>

        <span class="s1">expected = off.is_on_offset(ts)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_isAnchored_deprecated(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s3"># GH#30340 use idiomatic naming</span>
        <span class="s1">off = self._get_offset(offset_types)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
            <span class="s1">result = off.isAnchored()</span>

        <span class="s1">expected = off.is_anchored()</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_offsets_hashable(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s3"># GH: 37267</span>
        <span class="s1">off = self._get_offset(offset_types)</span>
        <span class="s2">assert </span><span class="s1">hash(off) </span><span class="s2">is not None</span>


<span class="s2">class </span><span class="s1">TestDateOffset(Base):</span>
    <span class="s2">def </span><span class="s1">setup_method(self</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s1">self.d = Timestamp(datetime(</span><span class="s5">2008</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">_offset_map.clear()</span>

    <span class="s2">def </span><span class="s1">test_repr(self):</span>
        <span class="s1">repr(DateOffset())</span>
        <span class="s1">repr(DateOffset(</span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">repr(</span><span class="s5">2 </span><span class="s1">* DateOffset())</span>
        <span class="s1">repr(</span><span class="s5">2 </span><span class="s1">* DateOffset(months=</span><span class="s5">2</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_mul(self):</span>
        <span class="s2">assert </span><span class="s1">DateOffset(</span><span class="s5">2</span><span class="s1">) == </span><span class="s5">2 </span><span class="s1">* DateOffset(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">DateOffset(</span><span class="s5">2</span><span class="s1">) == DateOffset(</span><span class="s5">1</span><span class="s1">) * </span><span class="s5">2</span>

    <span class="s2">def </span><span class="s1">test_constructor(self):</span>

        <span class="s2">assert </span><span class="s1">(self.d + DateOffset(months=</span><span class="s5">2</span><span class="s1">)) == datetime(</span><span class="s5">2008</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">(self.d - DateOffset(months=</span><span class="s5">2</span><span class="s1">)) == datetime(</span><span class="s5">2007</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">(self.d + DateOffset(</span><span class="s5">2</span><span class="s1">)) == datetime(</span><span class="s5">2008</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>

        <span class="s2">assert not </span><span class="s1">DateOffset(</span><span class="s5">2</span><span class="s1">).is_anchored()</span>
        <span class="s2">assert </span><span class="s1">DateOffset(</span><span class="s5">1</span><span class="s1">).is_anchored()</span>

        <span class="s1">d = datetime(</span><span class="s5">2008</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">31</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">(d + DateOffset(months=</span><span class="s5">1</span><span class="s1">)) == datetime(</span><span class="s5">2008</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">29</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_copy(self):</span>
        <span class="s2">assert </span><span class="s1">DateOffset(months=</span><span class="s5">2</span><span class="s1">).copy() == DateOffset(months=</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_eq(self):</span>
        <span class="s1">offset1 = DateOffset(days=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">offset2 = DateOffset(days=</span><span class="s5">365</span><span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">offset1 != offset2</span>


<span class="s2">class </span><span class="s1">TestOffsetNames:</span>
    <span class="s2">def </span><span class="s1">test_get_offset_name(self):</span>
        <span class="s2">assert </span><span class="s1">BDay().freqstr == </span><span class="s4">&quot;B&quot;</span>
        <span class="s2">assert </span><span class="s1">BDay(</span><span class="s5">2</span><span class="s1">).freqstr == </span><span class="s4">&quot;2B&quot;</span>
        <span class="s2">assert </span><span class="s1">BMonthEnd().freqstr == </span><span class="s4">&quot;BM&quot;</span>
        <span class="s2">assert </span><span class="s1">Week(weekday=</span><span class="s5">0</span><span class="s1">).freqstr == </span><span class="s4">&quot;W-MON&quot;</span>
        <span class="s2">assert </span><span class="s1">Week(weekday=</span><span class="s5">1</span><span class="s1">).freqstr == </span><span class="s4">&quot;W-TUE&quot;</span>
        <span class="s2">assert </span><span class="s1">Week(weekday=</span><span class="s5">2</span><span class="s1">).freqstr == </span><span class="s4">&quot;W-WED&quot;</span>
        <span class="s2">assert </span><span class="s1">Week(weekday=</span><span class="s5">3</span><span class="s1">).freqstr == </span><span class="s4">&quot;W-THU&quot;</span>
        <span class="s2">assert </span><span class="s1">Week(weekday=</span><span class="s5">4</span><span class="s1">).freqstr == </span><span class="s4">&quot;W-FRI&quot;</span>

        <span class="s2">assert </span><span class="s1">LastWeekOfMonth(weekday=WeekDay.SUN).freqstr == </span><span class="s4">&quot;LWOM-SUN&quot;</span>


<span class="s2">def </span><span class="s1">test_get_offset():</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=INVALID_FREQ_ERR_MSG):</span>
        <span class="s1">_get_offset(</span><span class="s4">&quot;gibberish&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=INVALID_FREQ_ERR_MSG):</span>
        <span class="s1">_get_offset(</span><span class="s4">&quot;QS-JAN-B&quot;</span><span class="s1">)</span>

    <span class="s1">pairs = [</span>
        <span class="s1">(</span><span class="s4">&quot;B&quot;</span><span class="s2">, </span><span class="s1">BDay())</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;b&quot;</span><span class="s2">, </span><span class="s1">BDay())</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;bm&quot;</span><span class="s2">, </span><span class="s1">BMonthEnd())</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;Bm&quot;</span><span class="s2">, </span><span class="s1">BMonthEnd())</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;W-MON&quot;</span><span class="s2">, </span><span class="s1">Week(weekday=</span><span class="s5">0</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;W-TUE&quot;</span><span class="s2">, </span><span class="s1">Week(weekday=</span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;W-WED&quot;</span><span class="s2">, </span><span class="s1">Week(weekday=</span><span class="s5">2</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;W-THU&quot;</span><span class="s2">, </span><span class="s1">Week(weekday=</span><span class="s5">3</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;W-FRI&quot;</span><span class="s2">, </span><span class="s1">Week(weekday=</span><span class="s5">4</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">expected </span><span class="s2">in </span><span class="s1">pairs:</span>
        <span class="s1">offset = _get_offset(name)</span>
        <span class="s2">assert </span><span class="s1">offset == expected</span><span class="s2">, </span><span class="s1">(</span>
            <span class="s4">f&quot;Expected </span><span class="s2">{</span><span class="s1">repr(name)</span><span class="s2">} </span><span class="s4">to yield </span><span class="s2">{</span><span class="s1">repr(expected)</span><span class="s2">} </span><span class="s4">&quot;</span>
            <span class="s4">f&quot;(actual: </span><span class="s2">{</span><span class="s1">repr(offset)</span><span class="s2">}</span><span class="s4">)&quot;</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_get_offset_legacy():</span>
    <span class="s1">pairs = [(</span><span class="s4">&quot;w@Sat&quot;</span><span class="s2">, </span><span class="s1">Week(weekday=</span><span class="s5">5</span><span class="s1">))]</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">expected </span><span class="s2">in </span><span class="s1">pairs:</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=INVALID_FREQ_ERR_MSG):</span>
            <span class="s1">_get_offset(name)</span>


<span class="s2">class </span><span class="s1">TestOffsetAliases:</span>
    <span class="s2">def </span><span class="s1">setup_method(self</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s1">_offset_map.clear()</span>

    <span class="s2">def </span><span class="s1">test_alias_equality(self):</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">_offset_map.items():</span>
            <span class="s2">if </span><span class="s1">v </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s2">assert </span><span class="s1">k == v.copy()</span>

    <span class="s2">def </span><span class="s1">test_rule_code(self):</span>
        <span class="s1">lst = [</span><span class="s4">&quot;M&quot;</span><span class="s2">, </span><span class="s4">&quot;MS&quot;</span><span class="s2">, </span><span class="s4">&quot;BM&quot;</span><span class="s2">, </span><span class="s4">&quot;BMS&quot;</span><span class="s2">, </span><span class="s4">&quot;D&quot;</span><span class="s2">, </span><span class="s4">&quot;B&quot;</span><span class="s2">, </span><span class="s4">&quot;H&quot;</span><span class="s2">, </span><span class="s4">&quot;T&quot;</span><span class="s2">, </span><span class="s4">&quot;S&quot;</span><span class="s2">, </span><span class="s4">&quot;L&quot;</span><span class="s2">, </span><span class="s4">&quot;U&quot;</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">lst:</span>
            <span class="s2">assert </span><span class="s1">k == _get_offset(k).rule_code</span>
            <span class="s3"># should be cached - this is kind of an internals test...</span>
            <span class="s2">assert </span><span class="s1">k </span><span class="s2">in </span><span class="s1">_offset_map</span>
            <span class="s2">assert </span><span class="s1">k == (_get_offset(k) * </span><span class="s5">3</span><span class="s1">).rule_code</span>

        <span class="s1">suffix_lst = [</span><span class="s4">&quot;MON&quot;</span><span class="s2">, </span><span class="s4">&quot;TUE&quot;</span><span class="s2">, </span><span class="s4">&quot;WED&quot;</span><span class="s2">, </span><span class="s4">&quot;THU&quot;</span><span class="s2">, </span><span class="s4">&quot;FRI&quot;</span><span class="s2">, </span><span class="s4">&quot;SAT&quot;</span><span class="s2">, </span><span class="s4">&quot;SUN&quot;</span><span class="s1">]</span>
        <span class="s1">base = </span><span class="s4">&quot;W&quot;</span>
        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">suffix_lst:</span>
            <span class="s1">alias = </span><span class="s4">&quot;-&quot;</span><span class="s1">.join([base</span><span class="s2">, </span><span class="s1">v])</span>
            <span class="s2">assert </span><span class="s1">alias == _get_offset(alias).rule_code</span>
            <span class="s2">assert </span><span class="s1">alias == (_get_offset(alias) * </span><span class="s5">5</span><span class="s1">).rule_code</span>

        <span class="s1">suffix_lst = [</span>
            <span class="s4">&quot;JAN&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;FEB&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;MAR&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;APR&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;MAY&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;JUN&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;JUL&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;AUG&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;SEP&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;OCT&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;NOV&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;DEC&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">base_lst = [</span><span class="s4">&quot;A&quot;</span><span class="s2">, </span><span class="s4">&quot;AS&quot;</span><span class="s2">, </span><span class="s4">&quot;BA&quot;</span><span class="s2">, </span><span class="s4">&quot;BAS&quot;</span><span class="s2">, </span><span class="s4">&quot;Q&quot;</span><span class="s2">, </span><span class="s4">&quot;QS&quot;</span><span class="s2">, </span><span class="s4">&quot;BQ&quot;</span><span class="s2">, </span><span class="s4">&quot;BQS&quot;</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">base </span><span class="s2">in </span><span class="s1">base_lst:</span>
            <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">suffix_lst:</span>
                <span class="s1">alias = </span><span class="s4">&quot;-&quot;</span><span class="s1">.join([base</span><span class="s2">, </span><span class="s1">v])</span>
                <span class="s2">assert </span><span class="s1">alias == _get_offset(alias).rule_code</span>
                <span class="s2">assert </span><span class="s1">alias == (_get_offset(alias) * </span><span class="s5">5</span><span class="s1">).rule_code</span>


<span class="s2">def </span><span class="s1">test_freq_offsets():</span>
    <span class="s1">off = BDay(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">offset=timedelta(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1800</span><span class="s1">))</span>
    <span class="s2">assert </span><span class="s1">off.freqstr == </span><span class="s4">&quot;B+30Min&quot;</span>

    <span class="s1">off = BDay(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">offset=timedelta(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1800</span><span class="s1">))</span>
    <span class="s2">assert </span><span class="s1">off.freqstr == </span><span class="s4">&quot;B-30Min&quot;</span>


<span class="s2">class </span><span class="s1">TestReprNames:</span>
    <span class="s2">def </span><span class="s1">test_str_for_named_is_name(self):</span>
        <span class="s3"># look at all the amazing combinations!</span>
        <span class="s1">month_prefixes = [</span><span class="s4">&quot;A&quot;</span><span class="s2">, </span><span class="s4">&quot;AS&quot;</span><span class="s2">, </span><span class="s4">&quot;BA&quot;</span><span class="s2">, </span><span class="s4">&quot;BAS&quot;</span><span class="s2">, </span><span class="s4">&quot;Q&quot;</span><span class="s2">, </span><span class="s4">&quot;BQ&quot;</span><span class="s2">, </span><span class="s4">&quot;BQS&quot;</span><span class="s2">, </span><span class="s4">&quot;QS&quot;</span><span class="s1">]</span>
        <span class="s1">names = [</span>
            <span class="s1">prefix + </span><span class="s4">&quot;-&quot; </span><span class="s1">+ month</span>
            <span class="s2">for </span><span class="s1">prefix </span><span class="s2">in </span><span class="s1">month_prefixes</span>
            <span class="s2">for </span><span class="s1">month </span><span class="s2">in </span><span class="s1">[</span>
                <span class="s4">&quot;JAN&quot;</span><span class="s2">,</span>
                <span class="s4">&quot;FEB&quot;</span><span class="s2">,</span>
                <span class="s4">&quot;MAR&quot;</span><span class="s2">,</span>
                <span class="s4">&quot;APR&quot;</span><span class="s2">,</span>
                <span class="s4">&quot;MAY&quot;</span><span class="s2">,</span>
                <span class="s4">&quot;JUN&quot;</span><span class="s2">,</span>
                <span class="s4">&quot;JUL&quot;</span><span class="s2">,</span>
                <span class="s4">&quot;AUG&quot;</span><span class="s2">,</span>
                <span class="s4">&quot;SEP&quot;</span><span class="s2">,</span>
                <span class="s4">&quot;OCT&quot;</span><span class="s2">,</span>
                <span class="s4">&quot;NOV&quot;</span><span class="s2">,</span>
                <span class="s4">&quot;DEC&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">]</span>
        <span class="s1">days = [</span><span class="s4">&quot;MON&quot;</span><span class="s2">, </span><span class="s4">&quot;TUE&quot;</span><span class="s2">, </span><span class="s4">&quot;WED&quot;</span><span class="s2">, </span><span class="s4">&quot;THU&quot;</span><span class="s2">, </span><span class="s4">&quot;FRI&quot;</span><span class="s2">, </span><span class="s4">&quot;SAT&quot;</span><span class="s2">, </span><span class="s4">&quot;SUN&quot;</span><span class="s1">]</span>
        <span class="s1">names += [</span><span class="s4">&quot;W-&quot; </span><span class="s1">+ day </span><span class="s2">for </span><span class="s1">day </span><span class="s2">in </span><span class="s1">days]</span>
        <span class="s1">names += [</span><span class="s4">&quot;WOM-&quot; </span><span class="s1">+ week + day </span><span class="s2">for </span><span class="s1">week </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;1&quot;</span><span class="s2">, </span><span class="s4">&quot;2&quot;</span><span class="s2">, </span><span class="s4">&quot;3&quot;</span><span class="s2">, </span><span class="s4">&quot;4&quot;</span><span class="s1">) </span><span class="s2">for </span><span class="s1">day </span><span class="s2">in </span><span class="s1">days]</span>
        <span class="s1">_offset_map.clear()</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names:</span>
            <span class="s1">offset = _get_offset(name)</span>
            <span class="s2">assert </span><span class="s1">offset.freqstr == name</span>


<span class="s2">def </span><span class="s1">get_utc_offset_hours(ts):</span>
    <span class="s3"># take a Timestamp and compute total hours of utc offset</span>
    <span class="s1">o = ts.utcoffset()</span>
    <span class="s2">return </span><span class="s1">(o.days * </span><span class="s5">24 </span><span class="s1">* </span><span class="s5">3600 </span><span class="s1">+ o.seconds) / </span><span class="s5">3600.0</span>


<span class="s3"># ---------------------------------------------------------------------</span>


<span class="s2">def </span><span class="s1">test_valid_default_arguments(offset_types):</span>
    <span class="s3"># GH#19142 check that the calling the constructors without passing</span>
    <span class="s3"># any keyword arguments produce valid offsets</span>
    <span class="s1">cls = offset_types</span>
    <span class="s1">cls()</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;kwd&quot;</span><span class="s2">, </span><span class="s1">sorted(liboffsets._relativedelta_kwds))</span>
<span class="s2">def </span><span class="s1">test_valid_month_attributes(kwd</span><span class="s2">, </span><span class="s1">month_classes):</span>
    <span class="s3"># GH#18226</span>
    <span class="s1">cls = month_classes</span>
    <span class="s3"># check that we cannot create e.g. MonthEnd(weeks=3)</span>
    <span class="s1">msg = </span><span class="s4">rf&quot;__init__\(\) got an unexpected keyword argument '</span><span class="s2">{</span><span class="s1">kwd</span><span class="s2">}</span><span class="s4">'&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">cls(**{kwd: </span><span class="s5">3</span><span class="s1">})</span>


<span class="s2">def </span><span class="s1">test_month_offset_name(month_classes):</span>
    <span class="s3"># GH#33757 off.name with n != 1 should not raise AttributeError</span>
    <span class="s1">obj = month_classes(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">obj2 = month_classes(</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">obj2.name == obj.name</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;kwd&quot;</span><span class="s2">, </span><span class="s1">sorted(liboffsets._relativedelta_kwds))</span>
<span class="s2">def </span><span class="s1">test_valid_relativedelta_kwargs(kwd):</span>
    <span class="s3"># Check that all the arguments specified in liboffsets._relativedelta_kwds</span>
    <span class="s3"># are in fact valid relativedelta keyword args</span>
    <span class="s1">DateOffset(**{kwd: </span><span class="s5">1</span><span class="s1">})</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;kwd&quot;</span><span class="s2">, </span><span class="s1">sorted(liboffsets._relativedelta_kwds))</span>
<span class="s2">def </span><span class="s1">test_valid_tick_attributes(kwd</span><span class="s2">, </span><span class="s1">tick_classes):</span>
    <span class="s3"># GH#18226</span>
    <span class="s1">cls = tick_classes</span>
    <span class="s3"># check that we cannot create e.g. Hour(weeks=3)</span>
    <span class="s1">msg = </span><span class="s4">rf&quot;__init__\(\) got an unexpected keyword argument '</span><span class="s2">{</span><span class="s1">kwd</span><span class="s2">}</span><span class="s4">'&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">cls(**{kwd: </span><span class="s5">3</span><span class="s1">})</span>


<span class="s2">def </span><span class="s1">test_validate_n_error():</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;argument must be an integer&quot;</span><span class="s1">):</span>
        <span class="s1">DateOffset(n=</span><span class="s4">&quot;Doh!&quot;</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;argument must be an integer&quot;</span><span class="s1">):</span>
        <span class="s1">MonthBegin(n=timedelta(</span><span class="s5">1</span><span class="s1">))</span>

    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;argument must be an integer&quot;</span><span class="s1">):</span>
        <span class="s1">BDay(n=np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.int64))</span>


<span class="s2">def </span><span class="s1">test_require_integers(offset_types):</span>
    <span class="s1">cls = offset_types</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;argument must be an integer&quot;</span><span class="s1">):</span>
        <span class="s1">cls(n=</span><span class="s5">1.5</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_tick_normalize_raises(tick_classes):</span>
    <span class="s3"># check that trying to create a Tick object with normalize=True raises</span>
    <span class="s3"># GH#21427</span>
    <span class="s1">cls = tick_classes</span>
    <span class="s1">msg = </span><span class="s4">&quot;Tick offset with `normalize=True` are not allowed.&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">cls(n=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">normalize=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;offset_kwargs, expected_arg&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">({</span><span class="s4">&quot;nanoseconds&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span><span class="s2">, </span><span class="s4">&quot;1970-01-01 00:00:00.000000001&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s4">&quot;nanoseconds&quot;</span><span class="s1">: </span><span class="s5">5</span><span class="s1">}</span><span class="s2">, </span><span class="s4">&quot;1970-01-01 00:00:00.000000005&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s4">&quot;nanoseconds&quot;</span><span class="s1">: -</span><span class="s5">1</span><span class="s1">}</span><span class="s2">, </span><span class="s4">&quot;1969-12-31 23:59:59.999999999&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s4">&quot;microseconds&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span><span class="s2">, </span><span class="s4">&quot;1970-01-01 00:00:00.000001&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s4">&quot;microseconds&quot;</span><span class="s1">: -</span><span class="s5">1</span><span class="s1">}</span><span class="s2">, </span><span class="s4">&quot;1969-12-31 23:59:59.999999&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s4">&quot;seconds&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span><span class="s2">, </span><span class="s4">&quot;1970-01-01 00:00:01&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s4">&quot;seconds&quot;</span><span class="s1">: -</span><span class="s5">1</span><span class="s1">}</span><span class="s2">, </span><span class="s4">&quot;1969-12-31 23:59:59&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s4">&quot;minutes&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span><span class="s2">, </span><span class="s4">&quot;1970-01-01 00:01:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s4">&quot;minutes&quot;</span><span class="s1">: -</span><span class="s5">1</span><span class="s1">}</span><span class="s2">, </span><span class="s4">&quot;1969-12-31 23:59:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s4">&quot;hours&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span><span class="s2">, </span><span class="s4">&quot;1970-01-01 01:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s4">&quot;hours&quot;</span><span class="s1">: -</span><span class="s5">1</span><span class="s1">}</span><span class="s2">, </span><span class="s4">&quot;1969-12-31 23:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s4">&quot;days&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span><span class="s2">, </span><span class="s4">&quot;1970-01-02 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s4">&quot;days&quot;</span><span class="s1">: -</span><span class="s5">1</span><span class="s1">}</span><span class="s2">, </span><span class="s4">&quot;1969-12-31 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s4">&quot;weeks&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span><span class="s2">, </span><span class="s4">&quot;1970-01-08 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s4">&quot;weeks&quot;</span><span class="s1">: -</span><span class="s5">1</span><span class="s1">}</span><span class="s2">, </span><span class="s4">&quot;1969-12-25 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s4">&quot;months&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span><span class="s2">, </span><span class="s4">&quot;1970-02-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s4">&quot;months&quot;</span><span class="s1">: -</span><span class="s5">1</span><span class="s1">}</span><span class="s2">, </span><span class="s4">&quot;1969-12-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s4">&quot;years&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span><span class="s2">, </span><span class="s4">&quot;1971-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s4">&quot;years&quot;</span><span class="s1">: -</span><span class="s5">1</span><span class="s1">}</span><span class="s2">, </span><span class="s4">&quot;1969-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_dateoffset_add_sub(offset_kwargs</span><span class="s2">, </span><span class="s1">expected_arg):</span>
    <span class="s1">offset = DateOffset(**offset_kwargs)</span>
    <span class="s1">ts = Timestamp(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">result = ts + offset</span>
    <span class="s1">expected = Timestamp(expected_arg)</span>
    <span class="s2">assert </span><span class="s1">result == expected</span>
    <span class="s1">result -= offset</span>
    <span class="s2">assert </span><span class="s1">result == ts</span>
    <span class="s1">result = offset + ts</span>
    <span class="s2">assert </span><span class="s1">result == expected</span>


<span class="s2">def </span><span class="s1">test_dataoffset_add_sub_timestamp_with_nano():</span>
    <span class="s1">offset = DateOffset(minutes=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">nanoseconds=</span><span class="s5">9</span><span class="s1">)</span>
    <span class="s1">ts = Timestamp(</span><span class="s5">4</span><span class="s1">)</span>
    <span class="s1">result = ts + offset</span>
    <span class="s1">expected = Timestamp(</span><span class="s4">&quot;1970-01-01 00:02:00.000000013&quot;</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">result == expected</span>
    <span class="s1">result -= offset</span>
    <span class="s2">assert </span><span class="s1">result == ts</span>
    <span class="s1">result = offset + ts</span>
    <span class="s2">assert </span><span class="s1">result == expected</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;attribute&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s4">&quot;hours&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;days&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;weeks&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;months&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;years&quot;</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_dateoffset_immutable(attribute):</span>
    <span class="s1">offset = DateOffset(**{attribute: </span><span class="s5">0</span><span class="s1">})</span>
    <span class="s1">msg = </span><span class="s4">&quot;DateOffset objects are immutable&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">setattr(offset</span><span class="s2">, </span><span class="s1">attribute</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_dateoffset_misc():</span>
    <span class="s1">oset = offsets.DateOffset(months=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">days=</span><span class="s5">4</span><span class="s1">)</span>
    <span class="s3"># it works</span>
    <span class="s1">oset.freqstr</span>

    <span class="s2">assert not </span><span class="s1">offsets.DateOffset(months=</span><span class="s5">2</span><span class="s1">) == </span><span class="s5">2</span>
</pre>
</body>
</html>