<html>
<head>
<title>test_invalid_arg.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_invalid_arg.py</font>
</center></td></tr></table>
<pre><span class="s0"># Tests specifically aimed at detecting bad arguments.</span>
<span class="s0"># This file is organized by reason for exception.</span>
<span class="s0">#     1. always invalid argument values</span>
<span class="s0">#     2. missing column(s)</span>
<span class="s0">#     3. incompatible ops/dtype/args/kwargs</span>
<span class="s0">#     4. invalid result shape/type</span>
<span class="s0"># If your test does not fit into one of these categories, add to this list.</span>

<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">chain</span>
<span class="s2">import </span><span class="s1">re</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Categorical</span><span class="s2">,</span>
    <span class="s1">DataFrame</span><span class="s2">,</span>
    <span class="s1">Series</span><span class="s2">,</span>
    <span class="s1">date_range</span><span class="s2">,</span>
    <span class="s1">notna</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas._testing </span><span class="s2">as </span><span class="s1">tm</span>
<span class="s2">from </span><span class="s1">pandas.core.base </span><span class="s2">import </span><span class="s1">SpecificationError</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;result_type&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;foo&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_result_type_error(result_type</span><span class="s2">, </span><span class="s1">int_frame_const_col):</span>
    <span class="s0"># allowed result_type</span>
    <span class="s1">df = int_frame_const_col</span>

    <span class="s1">msg = (</span>
        <span class="s3">&quot;invalid value for result_type, must be one of &quot;</span>
        <span class="s3">&quot;{None, 'reduce', 'broadcast', 'expand'}&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">df.apply(</span><span class="s2">lambda </span><span class="s1">x: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">result_type=result_type)</span>


<span class="s2">def </span><span class="s1">test_apply_invalid_axis_value():</span>
    <span class="s1">df = DataFrame([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">9</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">index=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s1">msg = </span><span class="s3">&quot;No axis named 2 for object type DataFrame&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">df.apply(</span><span class="s2">lambda </span><span class="s1">x: x</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_applymap_invalid_na_action(float_frame):</span>
    <span class="s0"># GH 23803</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;na_action must be .*Got 'abc'&quot;</span><span class="s1">):</span>
        <span class="s1">float_frame.applymap(</span><span class="s2">lambda </span><span class="s1">x: len(str(x))</span><span class="s2">, </span><span class="s1">na_action=</span><span class="s3">&quot;abc&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_agg_raises():</span>
    <span class="s0"># GH 26513</span>
    <span class="s1">df = DataFrame({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]})</span>
    <span class="s1">msg = </span><span class="s3">&quot;Must provide&quot;</span>

    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">df.agg()</span>


<span class="s2">def </span><span class="s1">test_map_with_invalid_na_action_raises():</span>
    <span class="s0"># https://github.com/pandas-dev/pandas/issues/32815</span>
    <span class="s1">s = Series([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">msg = </span><span class="s3">&quot;na_action must either be 'ignore' or None&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">s.map(</span><span class="s2">lambda </span><span class="s1">x: x</span><span class="s2">, </span><span class="s1">na_action=</span><span class="s3">&quot;____&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_map_categorical_na_action():</span>
    <span class="s1">values = Categorical(list(</span><span class="s3">&quot;ABBABCD&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">categories=list(</span><span class="s3">&quot;DCBA&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ordered=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">s = Series(values</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;XX&quot;</span><span class="s2">, </span><span class="s1">index=list(</span><span class="s3">&quot;abcdefg&quot;</span><span class="s1">))</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=tm.EMPTY_STRING_PATTERN):</span>
        <span class="s1">s.map(</span><span class="s2">lambda </span><span class="s1">x: x</span><span class="s2">, </span><span class="s1">na_action=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_map_datetimetz_na_action():</span>
    <span class="s1">values = date_range(</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-01-02&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;H&quot;</span><span class="s1">).tz_localize(</span><span class="s3">&quot;Asia/Tokyo&quot;</span><span class="s1">)</span>
    <span class="s1">s = Series(values</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;XX&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=tm.EMPTY_STRING_PATTERN):</span>
        <span class="s1">s.map(</span><span class="s2">lambda </span><span class="s1">x: x</span><span class="s2">, </span><span class="s1">na_action=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;box&quot;</span><span class="s2">, </span><span class="s1">[DataFrame</span><span class="s2">, </span><span class="s1">Series])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;method&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;apply&quot;</span><span class="s2">, </span><span class="s3">&quot;agg&quot;</span><span class="s2">, </span><span class="s3">&quot;transform&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;func&quot;</span><span class="s2">, </span><span class="s1">[{</span><span class="s3">&quot;A&quot;</span><span class="s1">: {</span><span class="s3">&quot;B&quot;</span><span class="s1">: </span><span class="s3">&quot;sum&quot;</span><span class="s1">}}</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;A&quot;</span><span class="s1">: {</span><span class="s3">&quot;B&quot;</span><span class="s1">: [</span><span class="s3">&quot;sum&quot;</span><span class="s1">]}}])</span>
<span class="s2">def </span><span class="s1">test_nested_renamer(box</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">func):</span>
    <span class="s0"># GH 35964</span>
    <span class="s1">obj = box({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s1">]})</span>
    <span class="s1">match = </span><span class="s3">&quot;nested renamer is not supported&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(SpecificationError</span><span class="s2">, </span><span class="s1">match=match):</span>
        <span class="s1">getattr(obj</span><span class="s2">, </span><span class="s1">method)(func)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;renamer&quot;</span><span class="s2">,</span>
    <span class="s1">[{</span><span class="s3">&quot;foo&quot;</span><span class="s1">: [</span><span class="s3">&quot;min&quot;</span><span class="s2">, </span><span class="s3">&quot;max&quot;</span><span class="s1">]}</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;foo&quot;</span><span class="s1">: [</span><span class="s3">&quot;min&quot;</span><span class="s2">, </span><span class="s3">&quot;max&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;bar&quot;</span><span class="s1">: [</span><span class="s3">&quot;sum&quot;</span><span class="s2">, </span><span class="s3">&quot;mean&quot;</span><span class="s1">]}]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_series_nested_renamer(renamer):</span>
    <span class="s1">s = Series(range(</span><span class="s4">6</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;series&quot;</span><span class="s1">)</span>
    <span class="s1">msg = </span><span class="s3">&quot;nested renamer is not supported&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(SpecificationError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">s.agg(renamer)</span>


<span class="s2">def </span><span class="s1">test_apply_dict_depr():</span>

    <span class="s1">tsdf = DataFrame(</span>
        <span class="s1">np.random.randn(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">columns=[</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">index=date_range(</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">msg = </span><span class="s3">&quot;nested renamer is not supported&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(SpecificationError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">tsdf.A.agg({</span><span class="s3">&quot;foo&quot;</span><span class="s1">: [</span><span class="s3">&quot;sum&quot;</span><span class="s2">, </span><span class="s3">&quot;mean&quot;</span><span class="s1">]})</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;method&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;agg&quot;</span><span class="s2">, </span><span class="s3">&quot;transform&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_dict_nested_renaming_depr(method):</span>

    <span class="s1">df = DataFrame({</span><span class="s3">&quot;A&quot;</span><span class="s1">: range(</span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: </span><span class="s4">5</span><span class="s1">})</span>

    <span class="s0"># nested renaming</span>
    <span class="s1">msg = </span><span class="s3">r&quot;nested renamer is not supported&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(SpecificationError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">getattr(df</span><span class="s2">, </span><span class="s1">method)({</span><span class="s3">&quot;A&quot;</span><span class="s1">: {</span><span class="s3">&quot;foo&quot;</span><span class="s1">: </span><span class="s3">&quot;min&quot;</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: {</span><span class="s3">&quot;bar&quot;</span><span class="s1">: </span><span class="s3">&quot;max&quot;</span><span class="s1">}})</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;method&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;apply&quot;</span><span class="s2">, </span><span class="s3">&quot;agg&quot;</span><span class="s2">, </span><span class="s3">&quot;transform&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;func&quot;</span><span class="s2">, </span><span class="s1">[{</span><span class="s3">&quot;B&quot;</span><span class="s1">: </span><span class="s3">&quot;sum&quot;</span><span class="s1">}</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;B&quot;</span><span class="s1">: [</span><span class="s3">&quot;sum&quot;</span><span class="s1">]}])</span>
<span class="s2">def </span><span class="s1">test_missing_column(method</span><span class="s2">, </span><span class="s1">func):</span>
    <span class="s0"># GH 40004</span>
    <span class="s1">obj = DataFrame({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s1">]})</span>
    <span class="s1">match = re.escape(</span><span class="s3">&quot;Column(s) ['B'] do not exist&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(KeyError</span><span class="s2">, </span><span class="s1">match=match):</span>
        <span class="s1">getattr(obj</span><span class="s2">, </span><span class="s1">method)(func)</span>


<span class="s2">def </span><span class="s1">test_transform_mixed_column_name_dtypes():</span>
    <span class="s0"># GH39025</span>
    <span class="s1">df = DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">&quot;1&quot;</span><span class="s1">]})</span>
    <span class="s1">msg = </span><span class="s3">r&quot;Column\(s\) \[1, 'b'\] do not exist&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(KeyError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">df.transform({</span><span class="s3">&quot;a&quot;</span><span class="s1">: int</span><span class="s2">, </span><span class="s4">1</span><span class="s1">: str</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">: int})</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;how, args&quot;</span><span class="s2">, </span><span class="s1">[(</span><span class="s3">&quot;pct_change&quot;</span><span class="s2">, </span><span class="s1">())</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;nsmallest&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]))</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;tail&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)]</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_apply_str_axis_1_raises(how</span><span class="s2">, </span><span class="s1">args):</span>
    <span class="s0"># GH 39211 - some ops don't support axis=1</span>
    <span class="s1">df = DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">: [</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]})</span>
    <span class="s1">msg = </span><span class="s3">f&quot;Operation </span><span class="s2">{</span><span class="s1">how</span><span class="s2">} </span><span class="s3">does not support axis=1&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">df.apply(how</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">args=args)</span>


<span class="s2">def </span><span class="s1">test_transform_axis_1_raises():</span>
    <span class="s0"># GH 35964</span>
    <span class="s1">msg = </span><span class="s3">&quot;No axis named 1 for object type Series&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">Series([</span><span class="s4">1</span><span class="s1">]).transform(</span><span class="s3">&quot;sum&quot;</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_apply_modify_traceback():</span>
    <span class="s1">data = DataFrame(</span>
        <span class="s1">{</span>
            <span class="s3">&quot;A&quot;</span><span class="s1">: [</span>
                <span class="s3">&quot;foo&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;foo&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;foo&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;foo&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;bar&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;bar&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;bar&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;bar&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;foo&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;foo&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;foo&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s3">&quot;B&quot;</span><span class="s1">: [</span>
                <span class="s3">&quot;one&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;one&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;one&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;two&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;one&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;one&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;one&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;two&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;two&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;two&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;one&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s3">&quot;C&quot;</span><span class="s1">: [</span>
                <span class="s3">&quot;dull&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;dull&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;shiny&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;dull&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;dull&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;shiny&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;shiny&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;dull&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;shiny&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;shiny&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;shiny&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s3">&quot;D&quot;</span><span class="s1">: np.random.randn(</span><span class="s4">11</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;E&quot;</span><span class="s1">: np.random.randn(</span><span class="s4">11</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;F&quot;</span><span class="s1">: np.random.randn(</span><span class="s4">11</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>

    <span class="s1">data.loc[</span><span class="s4">4</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s1">] = np.nan</span>

    <span class="s2">def </span><span class="s1">transform(row):</span>
        <span class="s2">if </span><span class="s1">row[</span><span class="s3">&quot;C&quot;</span><span class="s1">].startswith(</span><span class="s3">&quot;shin&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">row[</span><span class="s3">&quot;A&quot;</span><span class="s1">] == </span><span class="s3">&quot;foo&quot;</span><span class="s1">:</span>
            <span class="s1">row[</span><span class="s3">&quot;D&quot;</span><span class="s1">] = </span><span class="s4">7</span>
        <span class="s2">return </span><span class="s1">row</span>

    <span class="s2">def </span><span class="s1">transform2(row):</span>
        <span class="s2">if </span><span class="s1">notna(row[</span><span class="s3">&quot;C&quot;</span><span class="s1">]) </span><span class="s2">and </span><span class="s1">row[</span><span class="s3">&quot;C&quot;</span><span class="s1">].startswith(</span><span class="s3">&quot;shin&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">row[</span><span class="s3">&quot;A&quot;</span><span class="s1">] == </span><span class="s3">&quot;foo&quot;</span><span class="s1">:</span>
            <span class="s1">row[</span><span class="s3">&quot;D&quot;</span><span class="s1">] = </span><span class="s4">7</span>
        <span class="s2">return </span><span class="s1">row</span>

    <span class="s1">msg = </span><span class="s3">&quot;'float' object has no attribute 'startswith'&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">data.apply(transform</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;df, func, expected&quot;</span><span class="s2">,</span>
    <span class="s1">tm.get_cython_table_params(</span>
        <span class="s1">DataFrame([[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s1">]])</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">&quot;cumprod&quot;</span><span class="s2">, </span><span class="s1">TypeError]]</span>
    <span class="s1">)</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_agg_cython_table_raises_frame(df</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">axis):</span>
    <span class="s0"># GH 21224</span>
    <span class="s1">msg = </span><span class="s3">&quot;can't multiply sequence by non-int of type 'str'&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(expected</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">df.agg(func</span><span class="s2">, </span><span class="s1">axis=axis)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;series, func, expected&quot;</span><span class="s2">,</span>
    <span class="s1">chain(</span>
        <span class="s1">tm.get_cython_table_params(</span>
            <span class="s1">Series(</span><span class="s3">&quot;a b c&quot;</span><span class="s1">.split())</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s1">(</span><span class="s3">&quot;mean&quot;</span><span class="s2">, </span><span class="s1">TypeError)</span><span class="s2">,  </span><span class="s0"># mean raises TypeError</span>
                <span class="s1">(</span><span class="s3">&quot;prod&quot;</span><span class="s2">, </span><span class="s1">TypeError)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s3">&quot;std&quot;</span><span class="s2">, </span><span class="s1">TypeError)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s3">&quot;var&quot;</span><span class="s2">, </span><span class="s1">TypeError)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s3">&quot;median&quot;</span><span class="s2">, </span><span class="s1">TypeError)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s3">&quot;cumprod&quot;</span><span class="s2">, </span><span class="s1">TypeError)</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s1">)</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_agg_cython_table_raises_series(series</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s0"># GH21224</span>
    <span class="s1">msg = </span><span class="s3">r&quot;[Cc]ould not convert|can't multiply sequence by non-int of type&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(expected</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s0"># e.g. Series('a b'.split()).cumprod() will raise</span>
        <span class="s1">series.agg(func)</span>


<span class="s2">def </span><span class="s1">test_agg_none_to_type():</span>
    <span class="s0"># GH 40543</span>
    <span class="s1">df = DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s2">None</span><span class="s1">]})</span>
    <span class="s1">msg = re.escape(</span><span class="s3">&quot;int() argument must be a string&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">df.agg({</span><span class="s3">&quot;a&quot;</span><span class="s1">: int})</span>


<span class="s2">def </span><span class="s1">test_transform_none_to_type():</span>
    <span class="s0"># GH#34377</span>
    <span class="s1">df = DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s2">None</span><span class="s1">]})</span>
    <span class="s1">msg = </span><span class="s3">&quot;Transform function failed&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">df.transform({</span><span class="s3">&quot;a&quot;</span><span class="s1">: int})</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;func&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s2">lambda </span><span class="s1">x: np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]).reshape(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s2">lambda </span><span class="s1">x: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s2">lambda </span><span class="s1">x: Series([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_apply_broadcast_error(int_frame_const_col</span><span class="s2">, </span><span class="s1">func):</span>
    <span class="s1">df = int_frame_const_col</span>

    <span class="s0"># &gt; 1 ndim</span>
    <span class="s1">msg = </span><span class="s3">&quot;too many dims to broadcast|cannot broadcast result&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">df.apply(func</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">result_type=</span><span class="s3">&quot;broadcast&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_transform_and_agg_err_agg(axis</span><span class="s2">, </span><span class="s1">float_frame):</span>
    <span class="s0"># cannot both transform and agg</span>
    <span class="s1">msg = </span><span class="s3">&quot;cannot combine transform and aggregation operations&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">float_frame.agg([</span><span class="s3">&quot;max&quot;</span><span class="s2">, </span><span class="s3">&quot;sqrt&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">axis=axis)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;func, msg&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">([</span><span class="s3">&quot;sqrt&quot;</span><span class="s2">, </span><span class="s3">&quot;max&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;cannot combine transform and aggregation&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span>
            <span class="s1">{</span><span class="s3">&quot;foo&quot;</span><span class="s1">: np.sqrt</span><span class="s2">, </span><span class="s3">&quot;bar&quot;</span><span class="s1">: </span><span class="s3">&quot;sum&quot;</span><span class="s1">}</span><span class="s2">,</span>
            <span class="s3">&quot;cannot perform both aggregation and transformation&quot;</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_transform_and_agg_err_series(string_series</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">msg):</span>
    <span class="s0"># we are trying to transform with an aggregator</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">string_series.agg(func)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;func&quot;</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">&quot;max&quot;</span><span class="s2">, </span><span class="s3">&quot;min&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;max&quot;</span><span class="s2">, </span><span class="s3">&quot;sqrt&quot;</span><span class="s1">]])</span>
<span class="s2">def </span><span class="s1">test_transform_wont_agg_frame(axis</span><span class="s2">, </span><span class="s1">float_frame</span><span class="s2">, </span><span class="s1">func):</span>
    <span class="s0"># GH 35964</span>
    <span class="s0"># cannot both transform and agg</span>
    <span class="s1">msg = </span><span class="s3">&quot;Function did not transform&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">float_frame.transform(func</span><span class="s2">, </span><span class="s1">axis=axis)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;func&quot;</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">&quot;min&quot;</span><span class="s2">, </span><span class="s3">&quot;max&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;sqrt&quot;</span><span class="s2">, </span><span class="s3">&quot;max&quot;</span><span class="s1">]])</span>
<span class="s2">def </span><span class="s1">test_transform_wont_agg_series(string_series</span><span class="s2">, </span><span class="s1">func):</span>
    <span class="s0"># GH 35964</span>
    <span class="s0"># we are trying to transform with an aggregator</span>
    <span class="s1">msg = </span><span class="s3">&quot;Function did not transform&quot;</span>

    <span class="s1">warn = RuntimeWarning </span><span class="s2">if </span><span class="s1">func[</span><span class="s4">0</span><span class="s1">] == </span><span class="s3">&quot;sqrt&quot; </span><span class="s2">else None</span>
    <span class="s1">warn_msg = </span><span class="s3">&quot;invalid value encountered in sqrt&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(warn</span><span class="s2">, </span><span class="s1">match=warn_msg):</span>
            <span class="s1">string_series.transform(func)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;op_wrapper&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">lambda </span><span class="s1">x: x</span><span class="s2">, lambda </span><span class="s1">x: [x]</span><span class="s2">, lambda </span><span class="s1">x: {</span><span class="s3">&quot;A&quot;</span><span class="s1">: x}</span><span class="s2">, lambda </span><span class="s1">x: {</span><span class="s3">&quot;A&quot;</span><span class="s1">: [x]}]</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">&quot;ignore:.*Select only valid:FutureWarning&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_transform_reducer_raises(all_reductions</span><span class="s2">, </span><span class="s1">frame_or_series</span><span class="s2">, </span><span class="s1">op_wrapper):</span>
    <span class="s0"># GH 35964</span>
    <span class="s1">op = op_wrapper(all_reductions)</span>

    <span class="s1">obj = DataFrame({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]})</span>
    <span class="s1">obj = tm.get_obj(obj</span><span class="s2">, </span><span class="s1">frame_or_series)</span>

    <span class="s1">msg = </span><span class="s3">&quot;Function did not transform&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">obj.transform(op)</span>
</pre>
</body>
</html>