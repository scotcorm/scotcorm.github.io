<html>
<head>
<title>diskcache_manager.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
diskcache_manager.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">BaseLongCallbackManager</span>

<span class="s1">_pending_value = </span><span class="s2">&quot;__$pending__&quot;</span>


<span class="s0">class </span><span class="s1">DiskcacheLongCallbackManager(BaseLongCallbackManager):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">cache=</span><span class="s0">None, </span><span class="s1">cache_by=</span><span class="s0">None, </span><span class="s1">expire=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Long callback manager that runs callback logic in a subprocess and stores 
        results on disk using diskcache 
 
        :param cache: 
            A diskcache.Cache or diskcache.FanoutCache instance. See the diskcache 
            documentation for information on configuration options. If not provided, 
            a diskcache.Cache instance will be created with default values. 
        :param cache_by: 
            A list of zero-argument functions.  When provided, caching is enabled and 
            the return values of these functions are combined with the callback 
            function's input arguments and source code to generate cache keys. 
        :param expire: 
            If provided, a cache entry will be removed when it has not been accessed 
            for ``expire`` seconds.  If not provided, the lifetime of cache entries 
            is determined by the default behavior of the ``cache`` instance. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">import </span><span class="s1">diskcache  </span><span class="s4"># pylint: disable=import-outside-toplevel</span>
            <span class="s0">import </span><span class="s1">psutil  </span><span class="s4"># noqa: F401,E402 pylint: disable=import-outside-toplevel,unused-import,unused-variable,import-error</span>
            <span class="s0">import </span><span class="s1">multiprocess  </span><span class="s4"># noqa: F401,E402 pylint: disable=import-outside-toplevel,unused-import,unused-variable</span>
        <span class="s0">except </span><span class="s1">ImportError </span><span class="s0">as </span><span class="s1">missing_imports:</span>
            <span class="s0">raise </span><span class="s1">ImportError(</span>
                <span class="s2">&quot;&quot;&quot;</span><span class="s0">\ 
</span><span class="s2">DiskcacheLongCallbackManager requires extra dependencies which can be installed doing 
 
    $ pip install &quot;dash[diskcache]&quot;</span><span class="s0">\n</span><span class="s2">&quot;&quot;&quot;</span>
            <span class="s1">) </span><span class="s0">from </span><span class="s1">missing_imports</span>

        <span class="s0">if </span><span class="s1">cache </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.handle = diskcache.Cache()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">isinstance(cache</span><span class="s0">, </span><span class="s1">(diskcache.Cache</span><span class="s0">, </span><span class="s1">diskcache.FanoutCache)):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">&quot;First argument must be a diskcache.Cache &quot;</span>
                    <span class="s2">&quot;or diskcache.FanoutCache object&quot;</span>
                <span class="s1">)</span>
            <span class="s1">self.handle = cache</span>

        <span class="s1">super().__init__(cache_by)</span>
        <span class="s1">self.expire = expire</span>

    <span class="s0">def </span><span class="s1">terminate_job(self</span><span class="s0">, </span><span class="s1">job):</span>
        <span class="s0">import </span><span class="s1">psutil  </span><span class="s4"># pylint: disable=import-outside-toplevel,import-error</span>

        <span class="s0">if </span><span class="s1">job </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return</span>

        <span class="s4"># Use diskcache transaction so multiple process don't try to kill the</span>
        <span class="s4"># process at the same time</span>
        <span class="s0">with </span><span class="s1">self.handle.transact():</span>
            <span class="s0">if </span><span class="s1">psutil.pid_exists(job):</span>
                <span class="s1">process = psutil.Process(job)</span>

                <span class="s0">for </span><span class="s1">proc </span><span class="s0">in </span><span class="s1">process.children(recursive=</span><span class="s0">True</span><span class="s1">):</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s1">proc.kill()</span>
                    <span class="s0">except </span><span class="s1">psutil.NoSuchProcess:</span>
                        <span class="s0">pass</span>

                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">process.kill()</span>
                <span class="s0">except </span><span class="s1">psutil.NoSuchProcess:</span>
                    <span class="s0">pass</span>

                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">process.wait(</span><span class="s5">0.5</span><span class="s1">)</span>
                <span class="s0">except </span><span class="s1">(psutil.TimeoutExpired</span><span class="s0">, </span><span class="s1">psutil.NoSuchProcess):</span>
                    <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">terminate_unhealthy_job(self</span><span class="s0">, </span><span class="s1">job):</span>
        <span class="s0">import </span><span class="s1">psutil  </span><span class="s4"># pylint: disable=import-outside-toplevel,import-error</span>

        <span class="s0">if </span><span class="s1">job </span><span class="s0">and </span><span class="s1">psutil.pid_exists(job):</span>
            <span class="s0">if not </span><span class="s1">self.job_running(job):</span>
                <span class="s1">self.terminate_job(job)</span>
                <span class="s0">return True</span>

        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">job_running(self</span><span class="s0">, </span><span class="s1">job):</span>
        <span class="s0">import </span><span class="s1">psutil  </span><span class="s4"># pylint: disable=import-outside-toplevel,import-error</span>

        <span class="s0">if </span><span class="s1">job </span><span class="s0">and </span><span class="s1">psutil.pid_exists(job):</span>
            <span class="s1">proc = psutil.Process(job)</span>
            <span class="s0">return </span><span class="s1">proc.status() != psutil.STATUS_ZOMBIE</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">make_job_fn(self</span><span class="s0">, </span><span class="s1">fn</span><span class="s0">, </span><span class="s1">progress</span><span class="s0">, </span><span class="s1">args_deps):</span>
        <span class="s0">return </span><span class="s1">_make_job_fn(fn</span><span class="s0">, </span><span class="s1">self.handle</span><span class="s0">, </span><span class="s1">progress</span><span class="s0">, </span><span class="s1">args_deps)</span>

    <span class="s0">def </span><span class="s1">clear_cache_entry(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s1">self.handle.delete(key)</span>

    <span class="s0">def </span><span class="s1">call_job_fn(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">job_fn</span><span class="s0">, </span><span class="s1">args):</span>
        <span class="s4"># pylint: disable-next=import-outside-toplevel,no-name-in-module,import-error</span>
        <span class="s0">from </span><span class="s1">multiprocess </span><span class="s0">import </span><span class="s1">Process</span>

        <span class="s4"># pylint: disable-next=not-callable</span>
        <span class="s1">proc = Process(target=job_fn</span><span class="s0">, </span><span class="s1">args=(key</span><span class="s0">, </span><span class="s1">self._make_progress_key(key)</span><span class="s0">, </span><span class="s1">args))</span>
        <span class="s1">proc.start()</span>
        <span class="s0">return </span><span class="s1">proc.pid</span>

    <span class="s0">def </span><span class="s1">get_progress(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s1">progress_key = self._make_progress_key(key)</span>
        <span class="s0">return </span><span class="s1">self.handle.get(progress_key)</span>

    <span class="s0">def </span><span class="s1">result_ready(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s0">return </span><span class="s1">self.handle.get(key) </span><span class="s0">is not None</span>

    <span class="s0">def </span><span class="s1">get_result(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">job):</span>
        <span class="s4"># Get result value</span>
        <span class="s1">result = self.handle.get(key)</span>
        <span class="s0">if </span><span class="s1">result </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return None</span>

        <span class="s4"># Clear result if not caching</span>
        <span class="s0">if </span><span class="s1">self.cache_by </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.clear_cache_entry(key)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.expire:</span>
                <span class="s1">self.handle.touch(key</span><span class="s0">, </span><span class="s1">expire=self.expire)</span>

        <span class="s1">self.clear_cache_entry(self._make_progress_key(key))</span>

        <span class="s1">self.terminate_job(job)</span>
        <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">_make_job_fn(fn</span><span class="s0">, </span><span class="s1">cache</span><span class="s0">, </span><span class="s1">progress</span><span class="s0">, </span><span class="s1">args_deps):</span>
    <span class="s0">def </span><span class="s1">job_fn(result_key</span><span class="s0">, </span><span class="s1">progress_key</span><span class="s0">, </span><span class="s1">user_callback_args):</span>
        <span class="s0">def </span><span class="s1">_set_progress(progress_value):</span>
            <span class="s1">cache.set(progress_key</span><span class="s0">, </span><span class="s1">progress_value)</span>

        <span class="s1">maybe_progress = [_set_progress] </span><span class="s0">if </span><span class="s1">progress </span><span class="s0">else </span><span class="s1">[]</span>
        <span class="s0">if </span><span class="s1">isinstance(args_deps</span><span class="s0">, </span><span class="s1">dict):</span>
            <span class="s1">user_callback_output = fn(*maybe_progress</span><span class="s0">, </span><span class="s1">**user_callback_args)</span>
        <span class="s0">elif </span><span class="s1">isinstance(args_deps</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple)):</span>
            <span class="s1">user_callback_output = fn(*maybe_progress</span><span class="s0">, </span><span class="s1">*user_callback_args)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">user_callback_output = fn(*maybe_progress</span><span class="s0">, </span><span class="s1">user_callback_args)</span>
        <span class="s1">cache.set(result_key</span><span class="s0">, </span><span class="s1">user_callback_output)</span>

    <span class="s0">return </span><span class="s1">job_fn</span>
</pre>
</body>
</html>