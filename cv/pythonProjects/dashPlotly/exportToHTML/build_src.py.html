<html>
<head>
<title>build_src.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
build_src.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; Build swig and f2py sources. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">shlex</span>
<span class="s2">import </span><span class="s1">copy</span>

<span class="s2">from </span><span class="s1">distutils.command </span><span class="s2">import </span><span class="s1">build_ext</span>
<span class="s2">from </span><span class="s1">distutils.dep_util </span><span class="s2">import </span><span class="s1">newer_group</span><span class="s2">, </span><span class="s1">newer</span>
<span class="s2">from </span><span class="s1">distutils.util </span><span class="s2">import </span><span class="s1">get_platform</span>
<span class="s2">from </span><span class="s1">distutils.errors </span><span class="s2">import </span><span class="s1">DistutilsError</span><span class="s2">, </span><span class="s1">DistutilsSetupError</span>


<span class="s3"># this import can't be done here, as it uses numpy stuff only available</span>
<span class="s3"># after it's installed</span>
<span class="s3">#import numpy.f2py</span>
<span class="s2">from </span><span class="s1">numpy.distutils </span><span class="s2">import </span><span class="s1">log</span>
<span class="s2">from </span><span class="s1">numpy.distutils.misc_util </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">fortran_ext_match</span><span class="s2">, </span><span class="s1">appendpath</span><span class="s2">, </span><span class="s1">is_string</span><span class="s2">, </span><span class="s1">is_sequence</span><span class="s2">, </span><span class="s1">get_cmd</span>
    <span class="s1">)</span>
<span class="s2">from </span><span class="s1">numpy.distutils.from_template </span><span class="s2">import </span><span class="s1">process_file </span><span class="s2">as </span><span class="s1">process_f_file</span>
<span class="s2">from </span><span class="s1">numpy.distutils.conv_template </span><span class="s2">import </span><span class="s1">process_file </span><span class="s2">as </span><span class="s1">process_c_file</span>

<span class="s2">def </span><span class="s1">subst_vars(target</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">d):</span>
    <span class="s0">&quot;&quot;&quot;Substitute any occurrence of @foo@ by d['foo'] from source file into 
    target.&quot;&quot;&quot;</span>
    <span class="s1">var = re.compile(</span><span class="s4">'@([a-zA-Z_]+)@'</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">open(source</span><span class="s2">, </span><span class="s4">'r'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fs:</span>
        <span class="s2">with </span><span class="s1">open(target</span><span class="s2">, </span><span class="s4">'w'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">ft:</span>
            <span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">fs:</span>
                <span class="s1">m = var.search(l)</span>
                <span class="s2">if </span><span class="s1">m:</span>
                    <span class="s1">ft.write(l.replace(</span><span class="s4">'@%s@' </span><span class="s1">% m.group(</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">d[m.group(</span><span class="s5">1</span><span class="s1">)]))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">ft.write(l)</span>

<span class="s2">class </span><span class="s1">build_src(build_ext.build_ext):</span>

    <span class="s1">description = </span><span class="s4">&quot;build sources from SWIG, F2PY files or a function&quot;</span>

    <span class="s1">user_options = [</span>
        <span class="s1">(</span><span class="s4">'build-src='</span><span class="s2">, </span><span class="s4">'d'</span><span class="s2">, </span><span class="s4">&quot;directory to </span><span class="s2">\&quot;</span><span class="s4">build</span><span class="s2">\&quot; </span><span class="s4">sources to&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'f2py-opts='</span><span class="s2">, None, </span><span class="s4">&quot;list of f2py command line options&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'swig='</span><span class="s2">, None, </span><span class="s4">&quot;path to the SWIG executable&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'swig-opts='</span><span class="s2">, None, </span><span class="s4">&quot;list of SWIG command line options&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'swig-cpp'</span><span class="s2">, None, </span><span class="s4">&quot;make SWIG create C++ files (default is autodetected from sources)&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'f2pyflags='</span><span class="s2">, None, </span><span class="s4">&quot;additional flags to f2py (use --f2py-opts= instead)&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s3"># obsolete</span>
        <span class="s1">(</span><span class="s4">'swigflags='</span><span class="s2">, None, </span><span class="s4">&quot;additional flags to swig (use --swig-opts= instead)&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s3"># obsolete</span>
        <span class="s1">(</span><span class="s4">'force'</span><span class="s2">, </span><span class="s4">'f'</span><span class="s2">, </span><span class="s4">&quot;forcibly build everything (ignore file timestamps)&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'inplace'</span><span class="s2">, </span><span class="s4">'i'</span><span class="s2">,</span>
         <span class="s4">&quot;ignore build-lib and put compiled extensions into the source &quot; </span><span class="s1">+</span>
         <span class="s4">&quot;directory alongside your pure Python modules&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">'verbose-cfg'</span><span class="s2">, None,</span>
         <span class="s4">&quot;change logging level from WARN to INFO which will show all &quot; </span><span class="s1">+</span>
         <span class="s4">&quot;compiler output&quot;</span><span class="s1">)</span>
        <span class="s1">]</span>

    <span class="s1">boolean_options = [</span><span class="s4">'force'</span><span class="s2">, </span><span class="s4">'inplace'</span><span class="s2">, </span><span class="s4">'verbose-cfg'</span><span class="s1">]</span>

    <span class="s1">help_options = []</span>

    <span class="s2">def </span><span class="s1">initialize_options(self):</span>
        <span class="s1">self.extensions = </span><span class="s2">None</span>
        <span class="s1">self.package = </span><span class="s2">None</span>
        <span class="s1">self.py_modules = </span><span class="s2">None</span>
        <span class="s1">self.py_modules_dict = </span><span class="s2">None</span>
        <span class="s1">self.build_src = </span><span class="s2">None</span>
        <span class="s1">self.build_lib = </span><span class="s2">None</span>
        <span class="s1">self.build_base = </span><span class="s2">None</span>
        <span class="s1">self.force = </span><span class="s2">None</span>
        <span class="s1">self.inplace = </span><span class="s2">None</span>
        <span class="s1">self.package_dir = </span><span class="s2">None</span>
        <span class="s1">self.f2pyflags = </span><span class="s2">None </span><span class="s3"># obsolete</span>
        <span class="s1">self.f2py_opts = </span><span class="s2">None</span>
        <span class="s1">self.swigflags = </span><span class="s2">None </span><span class="s3"># obsolete</span>
        <span class="s1">self.swig_opts = </span><span class="s2">None</span>
        <span class="s1">self.swig_cpp = </span><span class="s2">None</span>
        <span class="s1">self.swig = </span><span class="s2">None</span>
        <span class="s1">self.verbose_cfg = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">finalize_options(self):</span>
        <span class="s1">self.set_undefined_options(</span><span class="s4">'build'</span><span class="s2">,</span>
                                   <span class="s1">(</span><span class="s4">'build_base'</span><span class="s2">, </span><span class="s4">'build_base'</span><span class="s1">)</span><span class="s2">,</span>
                                   <span class="s1">(</span><span class="s4">'build_lib'</span><span class="s2">, </span><span class="s4">'build_lib'</span><span class="s1">)</span><span class="s2">,</span>
                                   <span class="s1">(</span><span class="s4">'force'</span><span class="s2">, </span><span class="s4">'force'</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">self.package </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.package = self.distribution.ext_package</span>
        <span class="s1">self.extensions = self.distribution.ext_modules</span>
        <span class="s1">self.libraries = self.distribution.libraries </span><span class="s2">or </span><span class="s1">[]</span>
        <span class="s1">self.py_modules = self.distribution.py_modules </span><span class="s2">or </span><span class="s1">[]</span>
        <span class="s1">self.data_files = self.distribution.data_files </span><span class="s2">or </span><span class="s1">[]</span>

        <span class="s2">if </span><span class="s1">self.build_src </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">plat_specifier = </span><span class="s4">&quot;.{}-{}.{}&quot;</span><span class="s1">.format(get_platform()</span><span class="s2">, </span><span class="s1">*sys.version_info[:</span><span class="s5">2</span><span class="s1">])</span>
            <span class="s1">self.build_src = os.path.join(self.build_base</span><span class="s2">, </span><span class="s4">'src'</span><span class="s1">+plat_specifier)</span>

        <span class="s3"># py_modules_dict is used in build_py.find_package_modules</span>
        <span class="s1">self.py_modules_dict = {}</span>

        <span class="s2">if </span><span class="s1">self.f2pyflags:</span>
            <span class="s2">if </span><span class="s1">self.f2py_opts:</span>
                <span class="s1">log.warn(</span><span class="s4">'ignoring --f2pyflags as --f2py-opts already used'</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.f2py_opts = self.f2pyflags</span>
            <span class="s1">self.f2pyflags = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">self.f2py_opts </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.f2py_opts = []</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.f2py_opts = shlex.split(self.f2py_opts)</span>

        <span class="s2">if </span><span class="s1">self.swigflags:</span>
            <span class="s2">if </span><span class="s1">self.swig_opts:</span>
                <span class="s1">log.warn(</span><span class="s4">'ignoring --swigflags as --swig-opts already used'</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.swig_opts = self.swigflags</span>
            <span class="s1">self.swigflags = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">self.swig_opts </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.swig_opts = []</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.swig_opts = shlex.split(self.swig_opts)</span>

        <span class="s3"># use options from build_ext command</span>
        <span class="s1">build_ext = self.get_finalized_command(</span><span class="s4">'build_ext'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.inplace </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.inplace = build_ext.inplace</span>
        <span class="s2">if </span><span class="s1">self.swig_cpp </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.swig_cpp = build_ext.swig_cpp</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'swig'</span><span class="s2">, </span><span class="s4">'swig_opt'</span><span class="s1">]:</span>
            <span class="s1">o = </span><span class="s4">'--'</span><span class="s1">+c.replace(</span><span class="s4">'_'</span><span class="s2">, </span><span class="s4">'-'</span><span class="s1">)</span>
            <span class="s1">v = getattr(build_ext</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">v:</span>
                <span class="s2">if </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">c):</span>
                    <span class="s1">log.warn(</span><span class="s4">'both build_src and build_ext define %s option' </span><span class="s1">% (o))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">log.info(</span><span class="s4">'using &quot;%s=%s&quot; option from build_ext command' </span><span class="s1">% (o</span><span class="s2">, </span><span class="s1">v))</span>
                    <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">v)</span>

    <span class="s2">def </span><span class="s1">run(self):</span>
        <span class="s1">log.info(</span><span class="s4">&quot;build_src&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">(self.extensions </span><span class="s2">or </span><span class="s1">self.libraries):</span>
            <span class="s2">return</span>
        <span class="s1">self.build_sources()</span>

    <span class="s2">def </span><span class="s1">build_sources(self):</span>

        <span class="s2">if </span><span class="s1">self.inplace:</span>
            <span class="s1">self.get_package_dir = \</span>
                     <span class="s1">self.get_finalized_command(</span><span class="s4">'build_py'</span><span class="s1">).get_package_dir</span>

        <span class="s1">self.build_py_modules_sources()</span>

        <span class="s2">for </span><span class="s1">libname_info </span><span class="s2">in </span><span class="s1">self.libraries:</span>
            <span class="s1">self.build_library_sources(*libname_info)</span>

        <span class="s2">if </span><span class="s1">self.extensions:</span>
            <span class="s1">self.check_extensions_list(self.extensions)</span>

            <span class="s2">for </span><span class="s1">ext </span><span class="s2">in </span><span class="s1">self.extensions:</span>
                <span class="s1">self.build_extension_sources(ext)</span>

        <span class="s1">self.build_data_files_sources()</span>
        <span class="s1">self.build_npy_pkg_config()</span>

    <span class="s2">def </span><span class="s1">build_data_files_sources(self):</span>
        <span class="s2">if not </span><span class="s1">self.data_files:</span>
            <span class="s2">return</span>
        <span class="s1">log.info(</span><span class="s4">'building data_files sources'</span><span class="s1">)</span>
        <span class="s2">from </span><span class="s1">numpy.distutils.misc_util </span><span class="s2">import </span><span class="s1">get_data_files</span>
        <span class="s1">new_data_files = []</span>
        <span class="s2">for </span><span class="s1">data </span><span class="s2">in </span><span class="s1">self.data_files:</span>
            <span class="s2">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">new_data_files.append(data)</span>
            <span class="s2">elif </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">tuple):</span>
                <span class="s1">d</span><span class="s2">, </span><span class="s1">files = data</span>
                <span class="s2">if </span><span class="s1">self.inplace:</span>
                    <span class="s1">build_dir = self.get_package_dir(</span><span class="s4">'.'</span><span class="s1">.join(d.split(os.sep)))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">build_dir = os.path.join(self.build_src</span><span class="s2">, </span><span class="s1">d)</span>
                <span class="s1">funcs = [f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">files </span><span class="s2">if </span><span class="s1">hasattr(f</span><span class="s2">, </span><span class="s4">'__call__'</span><span class="s1">)]</span>
                <span class="s1">files = [f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">files </span><span class="s2">if not </span><span class="s1">hasattr(f</span><span class="s2">, </span><span class="s4">'__call__'</span><span class="s1">)]</span>
                <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">funcs:</span>
                    <span class="s2">if </span><span class="s1">f.__code__.co_argcount==</span><span class="s5">1</span><span class="s1">:</span>
                        <span class="s1">s = f(build_dir)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">s = f()</span>
                    <span class="s2">if </span><span class="s1">s </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s2">if </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">list):</span>
                            <span class="s1">files.extend(s)</span>
                        <span class="s2">elif </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">str):</span>
                            <span class="s1">files.append(s)</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s2">raise </span><span class="s1">TypeError(repr(s))</span>
                <span class="s1">filenames = get_data_files((d</span><span class="s2">, </span><span class="s1">files))</span>
                <span class="s1">new_data_files.append((d</span><span class="s2">, </span><span class="s1">filenames))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TypeError(repr(data))</span>
        <span class="s1">self.data_files[:] = new_data_files</span>


    <span class="s2">def </span><span class="s1">_build_npy_pkg_config(self</span><span class="s2">, </span><span class="s1">info</span><span class="s2">, </span><span class="s1">gd):</span>
        <span class="s1">template</span><span class="s2">, </span><span class="s1">install_dir</span><span class="s2">, </span><span class="s1">subst_dict = info</span>
        <span class="s1">template_dir = os.path.dirname(template)</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">gd.items():</span>
            <span class="s1">subst_dict[k] = v</span>

        <span class="s2">if </span><span class="s1">self.inplace == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">generated_dir = os.path.join(template_dir</span><span class="s2">, </span><span class="s1">install_dir)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">generated_dir = os.path.join(self.build_src</span><span class="s2">, </span><span class="s1">template_dir</span><span class="s2">,</span>
                    <span class="s1">install_dir)</span>
        <span class="s1">generated = os.path.basename(os.path.splitext(template)[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">generated_path = os.path.join(generated_dir</span><span class="s2">, </span><span class="s1">generated)</span>
        <span class="s2">if not </span><span class="s1">os.path.exists(generated_dir):</span>
            <span class="s1">os.makedirs(generated_dir)</span>

        <span class="s1">subst_vars(generated_path</span><span class="s2">, </span><span class="s1">template</span><span class="s2">, </span><span class="s1">subst_dict)</span>

        <span class="s3"># Where to install relatively to install prefix</span>
        <span class="s1">full_install_dir = os.path.join(template_dir</span><span class="s2">, </span><span class="s1">install_dir)</span>
        <span class="s2">return </span><span class="s1">full_install_dir</span><span class="s2">, </span><span class="s1">generated_path</span>

    <span class="s2">def </span><span class="s1">build_npy_pkg_config(self):</span>
        <span class="s1">log.info(</span><span class="s4">'build_src: building npy-pkg config files'</span><span class="s1">)</span>

        <span class="s3"># XXX: another ugly workaround to circumvent distutils brain damage. We</span>
        <span class="s3"># need the install prefix here, but finalizing the options of the</span>
        <span class="s3"># install command when only building sources cause error. Instead, we</span>
        <span class="s3"># copy the install command instance, and finalize the copy so that it</span>
        <span class="s3"># does not disrupt how distutils want to do things when with the</span>
        <span class="s3"># original install command instance.</span>
        <span class="s1">install_cmd = copy.copy(get_cmd(</span><span class="s4">'install'</span><span class="s1">))</span>
        <span class="s2">if not </span><span class="s1">install_cmd.finalized == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">install_cmd.finalize_options()</span>
        <span class="s1">build_npkg = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">self.inplace == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">top_prefix = </span><span class="s4">'.'</span>
            <span class="s1">build_npkg = </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">hasattr(install_cmd</span><span class="s2">, </span><span class="s4">'install_libbase'</span><span class="s1">):</span>
            <span class="s1">top_prefix = install_cmd.install_libbase</span>
            <span class="s1">build_npkg = </span><span class="s2">True</span>

        <span class="s2">if </span><span class="s1">build_npkg:</span>
            <span class="s2">for </span><span class="s1">pkg</span><span class="s2">, </span><span class="s1">infos </span><span class="s2">in </span><span class="s1">self.distribution.installed_pkg_config.items():</span>
                <span class="s1">pkg_path = self.distribution.package_dir[pkg]</span>
                <span class="s1">prefix = os.path.join(os.path.abspath(top_prefix)</span><span class="s2">, </span><span class="s1">pkg_path)</span>
                <span class="s1">d = {</span><span class="s4">'prefix'</span><span class="s1">: prefix}</span>
                <span class="s2">for </span><span class="s1">info </span><span class="s2">in </span><span class="s1">infos:</span>
                    <span class="s1">install_dir</span><span class="s2">, </span><span class="s1">generated = self._build_npy_pkg_config(info</span><span class="s2">, </span><span class="s1">d)</span>
                    <span class="s1">self.distribution.data_files.append((install_dir</span><span class="s2">,</span>
                        <span class="s1">[generated]))</span>

    <span class="s2">def </span><span class="s1">build_py_modules_sources(self):</span>
        <span class="s2">if not </span><span class="s1">self.py_modules:</span>
            <span class="s2">return</span>
        <span class="s1">log.info(</span><span class="s4">'building py_modules sources'</span><span class="s1">)</span>
        <span class="s1">new_py_modules = []</span>
        <span class="s2">for </span><span class="s1">source </span><span class="s2">in </span><span class="s1">self.py_modules:</span>
            <span class="s2">if </span><span class="s1">is_sequence(source) </span><span class="s2">and </span><span class="s1">len(source)==</span><span class="s5">3</span><span class="s1">:</span>
                <span class="s1">package</span><span class="s2">, </span><span class="s1">module_base</span><span class="s2">, </span><span class="s1">source = source</span>
                <span class="s2">if </span><span class="s1">self.inplace:</span>
                    <span class="s1">build_dir = self.get_package_dir(package)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">build_dir = os.path.join(self.build_src</span><span class="s2">,</span>
                                             <span class="s1">os.path.join(*package.split(</span><span class="s4">'.'</span><span class="s1">)))</span>
                <span class="s2">if </span><span class="s1">hasattr(source</span><span class="s2">, </span><span class="s4">'__call__'</span><span class="s1">):</span>
                    <span class="s1">target = os.path.join(build_dir</span><span class="s2">, </span><span class="s1">module_base + </span><span class="s4">'.py'</span><span class="s1">)</span>
                    <span class="s1">source = source(target)</span>
                <span class="s2">if </span><span class="s1">source </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">continue</span>
                <span class="s1">modules = [(package</span><span class="s2">, </span><span class="s1">module_base</span><span class="s2">, </span><span class="s1">source)]</span>
                <span class="s2">if </span><span class="s1">package </span><span class="s2">not in </span><span class="s1">self.py_modules_dict:</span>
                    <span class="s1">self.py_modules_dict[package] = []</span>
                <span class="s1">self.py_modules_dict[package] += modules</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">new_py_modules.append(source)</span>
        <span class="s1">self.py_modules[:] = new_py_modules</span>

    <span class="s2">def </span><span class="s1">build_library_sources(self</span><span class="s2">, </span><span class="s1">lib_name</span><span class="s2">, </span><span class="s1">build_info):</span>
        <span class="s1">sources = list(build_info.get(</span><span class="s4">'sources'</span><span class="s2">, </span><span class="s1">[]))</span>

        <span class="s2">if not </span><span class="s1">sources:</span>
            <span class="s2">return</span>

        <span class="s1">log.info(</span><span class="s4">'building library &quot;%s&quot; sources' </span><span class="s1">% (lib_name))</span>

        <span class="s1">sources = self.generate_sources(sources</span><span class="s2">, </span><span class="s1">(lib_name</span><span class="s2">, </span><span class="s1">build_info))</span>

        <span class="s1">sources = self.template_sources(sources</span><span class="s2">, </span><span class="s1">(lib_name</span><span class="s2">, </span><span class="s1">build_info))</span>

        <span class="s1">sources</span><span class="s2">, </span><span class="s1">h_files = self.filter_h_files(sources)</span>

        <span class="s2">if </span><span class="s1">h_files:</span>
            <span class="s1">log.info(</span><span class="s4">'%s - nothing done with h_files = %s'</span><span class="s2">,</span>
                     <span class="s1">self.package</span><span class="s2">, </span><span class="s1">h_files)</span>

        <span class="s3">#for f in h_files:</span>
        <span class="s3">#    self.distribution.headers.append((lib_name,f))</span>

        <span class="s1">build_info[</span><span class="s4">'sources'</span><span class="s1">] = sources</span>
        <span class="s2">return</span>

    <span class="s2">def </span><span class="s1">build_extension_sources(self</span><span class="s2">, </span><span class="s1">ext):</span>

        <span class="s1">sources = list(ext.sources)</span>

        <span class="s1">log.info(</span><span class="s4">'building extension &quot;%s&quot; sources' </span><span class="s1">% (ext.name))</span>

        <span class="s1">fullname = self.get_ext_fullname(ext.name)</span>

        <span class="s1">modpath = fullname.split(</span><span class="s4">'.'</span><span class="s1">)</span>
        <span class="s1">package = </span><span class="s4">'.'</span><span class="s1">.join(modpath[</span><span class="s5">0</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">])</span>

        <span class="s2">if </span><span class="s1">self.inplace:</span>
            <span class="s1">self.ext_target_dir = self.get_package_dir(package)</span>

        <span class="s1">sources = self.generate_sources(sources</span><span class="s2">, </span><span class="s1">ext)</span>
        <span class="s1">sources = self.template_sources(sources</span><span class="s2">, </span><span class="s1">ext)</span>
        <span class="s1">sources = self.swig_sources(sources</span><span class="s2">, </span><span class="s1">ext)</span>
        <span class="s1">sources = self.f2py_sources(sources</span><span class="s2">, </span><span class="s1">ext)</span>
        <span class="s1">sources = self.pyrex_sources(sources</span><span class="s2">, </span><span class="s1">ext)</span>

        <span class="s1">sources</span><span class="s2">, </span><span class="s1">py_files = self.filter_py_files(sources)</span>

        <span class="s2">if </span><span class="s1">package </span><span class="s2">not in </span><span class="s1">self.py_modules_dict:</span>
            <span class="s1">self.py_modules_dict[package] = []</span>
        <span class="s1">modules = []</span>
        <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">py_files:</span>
            <span class="s1">module = os.path.splitext(os.path.basename(f))[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">modules.append((package</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">f))</span>
        <span class="s1">self.py_modules_dict[package] += modules</span>

        <span class="s1">sources</span><span class="s2">, </span><span class="s1">h_files = self.filter_h_files(sources)</span>

        <span class="s2">if </span><span class="s1">h_files:</span>
            <span class="s1">log.info(</span><span class="s4">'%s - nothing done with h_files = %s'</span><span class="s2">,</span>
                     <span class="s1">package</span><span class="s2">, </span><span class="s1">h_files)</span>
        <span class="s3">#for f in h_files:</span>
        <span class="s3">#    self.distribution.headers.append((package,f))</span>

        <span class="s1">ext.sources = sources</span>

    <span class="s2">def </span><span class="s1">generate_sources(self</span><span class="s2">, </span><span class="s1">sources</span><span class="s2">, </span><span class="s1">extension):</span>
        <span class="s1">new_sources = []</span>
        <span class="s1">func_sources = []</span>
        <span class="s2">for </span><span class="s1">source </span><span class="s2">in </span><span class="s1">sources:</span>
            <span class="s2">if </span><span class="s1">is_string(source):</span>
                <span class="s1">new_sources.append(source)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">func_sources.append(source)</span>
        <span class="s2">if not </span><span class="s1">func_sources:</span>
            <span class="s2">return </span><span class="s1">new_sources</span>
        <span class="s2">if </span><span class="s1">self.inplace </span><span class="s2">and not </span><span class="s1">is_sequence(extension):</span>
            <span class="s1">build_dir = self.ext_target_dir</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">is_sequence(extension):</span>
                <span class="s1">name = extension[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3">#    if 'include_dirs' not in extension[1]:</span>
            <span class="s3">#        extension[1]['include_dirs'] = []</span>
            <span class="s3">#    incl_dirs = extension[1]['include_dirs']</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">name = extension.name</span>
            <span class="s3">#    incl_dirs = extension.include_dirs</span>
            <span class="s3">#if self.build_src not in incl_dirs:</span>
            <span class="s3">#    incl_dirs.append(self.build_src)</span>
            <span class="s1">build_dir = os.path.join(*([self.build_src]</span>
                                       <span class="s1">+name.split(</span><span class="s4">'.'</span><span class="s1">)[:-</span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s1">self.mkpath(build_dir)</span>

        <span class="s2">if </span><span class="s1">self.verbose_cfg:</span>
            <span class="s1">new_level = log.INFO</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">new_level = log.WARN</span>
        <span class="s1">old_level = log.set_threshold(new_level)</span>

        <span class="s2">for </span><span class="s1">func </span><span class="s2">in </span><span class="s1">func_sources:</span>
            <span class="s1">source = func(extension</span><span class="s2">, </span><span class="s1">build_dir)</span>
            <span class="s2">if not </span><span class="s1">source:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">is_sequence(source):</span>
                <span class="s1">[log.info(</span><span class="s4">&quot;  adding '%s' to sources.&quot; </span><span class="s1">% (s</span><span class="s2">,</span><span class="s1">)) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">source]</span>
                <span class="s1">new_sources.extend(source)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">log.info(</span><span class="s4">&quot;  adding '%s' to sources.&quot; </span><span class="s1">% (source</span><span class="s2">,</span><span class="s1">))</span>
                <span class="s1">new_sources.append(source)</span>
        <span class="s1">log.set_threshold(old_level)</span>
        <span class="s2">return </span><span class="s1">new_sources</span>

    <span class="s2">def </span><span class="s1">filter_py_files(self</span><span class="s2">, </span><span class="s1">sources):</span>
        <span class="s2">return </span><span class="s1">self.filter_files(sources</span><span class="s2">, </span><span class="s1">[</span><span class="s4">'.py'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">filter_h_files(self</span><span class="s2">, </span><span class="s1">sources):</span>
        <span class="s2">return </span><span class="s1">self.filter_files(sources</span><span class="s2">, </span><span class="s1">[</span><span class="s4">'.h'</span><span class="s2">, </span><span class="s4">'.hpp'</span><span class="s2">, </span><span class="s4">'.inc'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">filter_files(self</span><span class="s2">, </span><span class="s1">sources</span><span class="s2">, </span><span class="s1">exts = []):</span>
        <span class="s1">new_sources = []</span>
        <span class="s1">files = []</span>
        <span class="s2">for </span><span class="s1">source </span><span class="s2">in </span><span class="s1">sources:</span>
            <span class="s1">(base</span><span class="s2">, </span><span class="s1">ext) = os.path.splitext(source)</span>
            <span class="s2">if </span><span class="s1">ext </span><span class="s2">in </span><span class="s1">exts:</span>
                <span class="s1">files.append(source)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">new_sources.append(source)</span>
        <span class="s2">return </span><span class="s1">new_sources</span><span class="s2">, </span><span class="s1">files</span>

    <span class="s2">def </span><span class="s1">template_sources(self</span><span class="s2">, </span><span class="s1">sources</span><span class="s2">, </span><span class="s1">extension):</span>
        <span class="s1">new_sources = []</span>
        <span class="s2">if </span><span class="s1">is_sequence(extension):</span>
            <span class="s1">depends = extension[</span><span class="s5">1</span><span class="s1">].get(</span><span class="s4">'depends'</span><span class="s1">)</span>
            <span class="s1">include_dirs = extension[</span><span class="s5">1</span><span class="s1">].get(</span><span class="s4">'include_dirs'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">depends = extension.depends</span>
            <span class="s1">include_dirs = extension.include_dirs</span>
        <span class="s2">for </span><span class="s1">source </span><span class="s2">in </span><span class="s1">sources:</span>
            <span class="s1">(base</span><span class="s2">, </span><span class="s1">ext) = os.path.splitext(source)</span>
            <span class="s2">if </span><span class="s1">ext == </span><span class="s4">'.src'</span><span class="s1">:  </span><span class="s3"># Template file</span>
                <span class="s2">if </span><span class="s1">self.inplace:</span>
                    <span class="s1">target_dir = os.path.dirname(base)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">target_dir = appendpath(self.build_src</span><span class="s2">, </span><span class="s1">os.path.dirname(base))</span>
                <span class="s1">self.mkpath(target_dir)</span>
                <span class="s1">target_file = os.path.join(target_dir</span><span class="s2">, </span><span class="s1">os.path.basename(base))</span>
                <span class="s2">if </span><span class="s1">(self.force </span><span class="s2">or </span><span class="s1">newer_group([source] + depends</span><span class="s2">, </span><span class="s1">target_file)):</span>
                    <span class="s2">if </span><span class="s1">_f_pyf_ext_match(base):</span>
                        <span class="s1">log.info(</span><span class="s4">&quot;from_template:&gt; %s&quot; </span><span class="s1">% (target_file))</span>
                        <span class="s1">outstr = process_f_file(source)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">log.info(</span><span class="s4">&quot;conv_template:&gt; %s&quot; </span><span class="s1">% (target_file))</span>
                        <span class="s1">outstr = process_c_file(source)</span>
                    <span class="s2">with </span><span class="s1">open(target_file</span><span class="s2">, </span><span class="s4">'w'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fid:</span>
                        <span class="s1">fid.write(outstr)</span>
                <span class="s2">if </span><span class="s1">_header_ext_match(target_file):</span>
                    <span class="s1">d = os.path.dirname(target_file)</span>
                    <span class="s2">if </span><span class="s1">d </span><span class="s2">not in </span><span class="s1">include_dirs:</span>
                        <span class="s1">log.info(</span><span class="s4">&quot;  adding '%s' to include_dirs.&quot; </span><span class="s1">% (d))</span>
                        <span class="s1">include_dirs.append(d)</span>
                <span class="s1">new_sources.append(target_file)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">new_sources.append(source)</span>
        <span class="s2">return </span><span class="s1">new_sources</span>

    <span class="s2">def </span><span class="s1">pyrex_sources(self</span><span class="s2">, </span><span class="s1">sources</span><span class="s2">, </span><span class="s1">extension):</span>
        <span class="s0">&quot;&quot;&quot;Pyrex not supported; this remains for Cython support (see below)&quot;&quot;&quot;</span>
        <span class="s1">new_sources = []</span>
        <span class="s1">ext_name = extension.name.split(</span><span class="s4">'.'</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">source </span><span class="s2">in </span><span class="s1">sources:</span>
            <span class="s1">(base</span><span class="s2">, </span><span class="s1">ext) = os.path.splitext(source)</span>
            <span class="s2">if </span><span class="s1">ext == </span><span class="s4">'.pyx'</span><span class="s1">:</span>
                <span class="s1">target_file = self.generate_a_pyrex_source(base</span><span class="s2">, </span><span class="s1">ext_name</span><span class="s2">,</span>
                                                           <span class="s1">source</span><span class="s2">,</span>
                                                           <span class="s1">extension)</span>
                <span class="s1">new_sources.append(target_file)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">new_sources.append(source)</span>
        <span class="s2">return </span><span class="s1">new_sources</span>

    <span class="s2">def </span><span class="s1">generate_a_pyrex_source(self</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">ext_name</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">extension):</span>
        <span class="s0">&quot;&quot;&quot;Pyrex is not supported, but some projects monkeypatch this method. 
 
        That allows compiling Cython code, see gh-6955. 
        This method will remain here for compatibility reasons. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">f2py_sources(self</span><span class="s2">, </span><span class="s1">sources</span><span class="s2">, </span><span class="s1">extension):</span>
        <span class="s1">new_sources = []</span>
        <span class="s1">f2py_sources = []</span>
        <span class="s1">f_sources = []</span>
        <span class="s1">f2py_targets = {}</span>
        <span class="s1">target_dirs = []</span>
        <span class="s1">ext_name = extension.name.split(</span><span class="s4">'.'</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">skip_f2py = </span><span class="s5">0</span>

        <span class="s2">for </span><span class="s1">source </span><span class="s2">in </span><span class="s1">sources:</span>
            <span class="s1">(base</span><span class="s2">, </span><span class="s1">ext) = os.path.splitext(source)</span>
            <span class="s2">if </span><span class="s1">ext == </span><span class="s4">'.pyf'</span><span class="s1">: </span><span class="s3"># F2PY interface file</span>
                <span class="s2">if </span><span class="s1">self.inplace:</span>
                    <span class="s1">target_dir = os.path.dirname(base)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">target_dir = appendpath(self.build_src</span><span class="s2">, </span><span class="s1">os.path.dirname(base))</span>
                <span class="s2">if </span><span class="s1">os.path.isfile(source):</span>
                    <span class="s1">name = get_f2py_modulename(source)</span>
                    <span class="s2">if </span><span class="s1">name != ext_name:</span>
                        <span class="s2">raise </span><span class="s1">DistutilsSetupError(</span><span class="s4">'mismatch of extension names: %s '</span>
                                                  <span class="s4">'provides %r but expected %r' </span><span class="s1">% (</span>
                            <span class="s1">source</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">ext_name))</span>
                    <span class="s1">target_file = os.path.join(target_dir</span><span class="s2">, </span><span class="s1">name+</span><span class="s4">'module.c'</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">log.debug(</span><span class="s4">'  source %s does not exist: skipping f2py</span><span class="s2">\'</span><span class="s4">ing.' </span><span class="s1">\</span>
                              <span class="s1">% (source))</span>
                    <span class="s1">name = ext_name</span>
                    <span class="s1">skip_f2py = </span><span class="s5">1</span>
                    <span class="s1">target_file = os.path.join(target_dir</span><span class="s2">, </span><span class="s1">name+</span><span class="s4">'module.c'</span><span class="s1">)</span>
                    <span class="s2">if not </span><span class="s1">os.path.isfile(target_file):</span>
                        <span class="s1">log.warn(</span><span class="s4">'  target %s does not exist:</span><span class="s2">\n   </span><span class="s4">'</span><span class="s1">\</span>
                                 <span class="s4">'Assuming %smodule.c was generated with '</span><span class="s1">\</span>
                                 <span class="s4">'&quot;build_src --inplace&quot; command.' </span><span class="s1">\</span>
                                 <span class="s1">% (target_file</span><span class="s2">, </span><span class="s1">name))</span>
                        <span class="s1">target_dir = os.path.dirname(base)</span>
                        <span class="s1">target_file = os.path.join(target_dir</span><span class="s2">, </span><span class="s1">name+</span><span class="s4">'module.c'</span><span class="s1">)</span>
                        <span class="s2">if not </span><span class="s1">os.path.isfile(target_file):</span>
                            <span class="s2">raise </span><span class="s1">DistutilsSetupError(</span><span class="s4">&quot;%r missing&quot; </span><span class="s1">% (target_file</span><span class="s2">,</span><span class="s1">))</span>
                        <span class="s1">log.info(</span><span class="s4">'   Yes! Using %r as up-to-date target.' </span><span class="s1">\</span>
                                 <span class="s1">% (target_file))</span>
                <span class="s1">target_dirs.append(target_dir)</span>
                <span class="s1">f2py_sources.append(source)</span>
                <span class="s1">f2py_targets[source] = target_file</span>
                <span class="s1">new_sources.append(target_file)</span>
            <span class="s2">elif </span><span class="s1">fortran_ext_match(ext):</span>
                <span class="s1">f_sources.append(source)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">new_sources.append(source)</span>

        <span class="s2">if not </span><span class="s1">(f2py_sources </span><span class="s2">or </span><span class="s1">f_sources):</span>
            <span class="s2">return </span><span class="s1">new_sources</span>

        <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">target_dirs:</span>
            <span class="s1">self.mkpath(d)</span>

        <span class="s1">f2py_options = extension.f2py_options + self.f2py_opts</span>

        <span class="s2">if </span><span class="s1">self.distribution.libraries:</span>
            <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">build_info </span><span class="s2">in </span><span class="s1">self.distribution.libraries:</span>
                <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">extension.libraries:</span>
                    <span class="s1">f2py_options.extend(build_info.get(</span><span class="s4">'f2py_options'</span><span class="s2">, </span><span class="s1">[]))</span>

        <span class="s1">log.info(</span><span class="s4">&quot;f2py options: %s&quot; </span><span class="s1">% (f2py_options))</span>

        <span class="s2">if </span><span class="s1">f2py_sources:</span>
            <span class="s2">if </span><span class="s1">len(f2py_sources) != </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">DistutilsSetupError(</span>
                    <span class="s4">'only one .pyf file is allowed per extension module but got'</span><span class="s1">\</span>
                    <span class="s4">' more: %r' </span><span class="s1">% (f2py_sources</span><span class="s2">,</span><span class="s1">))</span>
            <span class="s1">source = f2py_sources[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">target_file = f2py_targets[source]</span>
            <span class="s1">target_dir = os.path.dirname(target_file) </span><span class="s2">or </span><span class="s4">'.'</span>
            <span class="s1">depends = [source] + extension.depends</span>
            <span class="s2">if </span><span class="s1">(self.force </span><span class="s2">or </span><span class="s1">newer_group(depends</span><span class="s2">, </span><span class="s1">target_file</span><span class="s2">, </span><span class="s4">'newer'</span><span class="s1">)) \</span>
                   <span class="s2">and not </span><span class="s1">skip_f2py:</span>
                <span class="s1">log.info(</span><span class="s4">&quot;f2py: %s&quot; </span><span class="s1">% (source))</span>
                <span class="s2">import </span><span class="s1">numpy.f2py</span>
                <span class="s1">numpy.f2py.run_main(f2py_options</span>
                                    <span class="s1">+ [</span><span class="s4">'--build-dir'</span><span class="s2">, </span><span class="s1">target_dir</span><span class="s2">, </span><span class="s1">source])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">log.debug(</span><span class="s4">&quot;  skipping '%s' f2py interface (up-to-date)&quot; </span><span class="s1">% (source))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3">#XXX TODO: --inplace support for sdist command</span>
            <span class="s2">if </span><span class="s1">is_sequence(extension):</span>
                <span class="s1">name = extension[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">: name = extension.name</span>
            <span class="s1">target_dir = os.path.join(*([self.build_src]</span>
                                        <span class="s1">+name.split(</span><span class="s4">'.'</span><span class="s1">)[:-</span><span class="s5">1</span><span class="s1">]))</span>
            <span class="s1">target_file = os.path.join(target_dir</span><span class="s2">, </span><span class="s1">ext_name + </span><span class="s4">'module.c'</span><span class="s1">)</span>
            <span class="s1">new_sources.append(target_file)</span>
            <span class="s1">depends = f_sources + extension.depends</span>
            <span class="s2">if </span><span class="s1">(self.force </span><span class="s2">or </span><span class="s1">newer_group(depends</span><span class="s2">, </span><span class="s1">target_file</span><span class="s2">, </span><span class="s4">'newer'</span><span class="s1">)) \</span>
                   <span class="s2">and not </span><span class="s1">skip_f2py:</span>
                <span class="s1">log.info(</span><span class="s4">&quot;f2py:&gt; %s&quot; </span><span class="s1">% (target_file))</span>
                <span class="s1">self.mkpath(target_dir)</span>
                <span class="s2">import </span><span class="s1">numpy.f2py</span>
                <span class="s1">numpy.f2py.run_main(f2py_options + [</span><span class="s4">'--lower'</span><span class="s2">,</span>
                                                <span class="s4">'--build-dir'</span><span class="s2">, </span><span class="s1">target_dir]+\</span>
                                <span class="s1">[</span><span class="s4">'-m'</span><span class="s2">, </span><span class="s1">ext_name]+f_sources)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">log.debug(</span><span class="s4">&quot;  skipping f2py fortran files for '%s' (up-to-date)&quot;</span><span class="s1">\</span>
                          <span class="s1">% (target_file))</span>

        <span class="s2">if not </span><span class="s1">os.path.isfile(target_file):</span>
            <span class="s2">raise </span><span class="s1">DistutilsError(</span><span class="s4">&quot;f2py target file %r not generated&quot; </span><span class="s1">% (target_file</span><span class="s2">,</span><span class="s1">))</span>

        <span class="s1">build_dir = os.path.join(self.build_src</span><span class="s2">, </span><span class="s1">target_dir)</span>
        <span class="s1">target_c = os.path.join(build_dir</span><span class="s2">, </span><span class="s4">'fortranobject.c'</span><span class="s1">)</span>
        <span class="s1">target_h = os.path.join(build_dir</span><span class="s2">, </span><span class="s4">'fortranobject.h'</span><span class="s1">)</span>
        <span class="s1">log.info(</span><span class="s4">&quot;  adding '%s' to sources.&quot; </span><span class="s1">% (target_c))</span>
        <span class="s1">new_sources.append(target_c)</span>
        <span class="s2">if </span><span class="s1">build_dir </span><span class="s2">not in </span><span class="s1">extension.include_dirs:</span>
            <span class="s1">log.info(</span><span class="s4">&quot;  adding '%s' to include_dirs.&quot; </span><span class="s1">% (build_dir))</span>
            <span class="s1">extension.include_dirs.append(build_dir)</span>

        <span class="s2">if not </span><span class="s1">skip_f2py:</span>
            <span class="s2">import </span><span class="s1">numpy.f2py</span>
            <span class="s1">d = os.path.dirname(numpy.f2py.__file__)</span>
            <span class="s1">source_c = os.path.join(d</span><span class="s2">, </span><span class="s4">'src'</span><span class="s2">, </span><span class="s4">'fortranobject.c'</span><span class="s1">)</span>
            <span class="s1">source_h = os.path.join(d</span><span class="s2">, </span><span class="s4">'src'</span><span class="s2">, </span><span class="s4">'fortranobject.h'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">newer(source_c</span><span class="s2">, </span><span class="s1">target_c) </span><span class="s2">or </span><span class="s1">newer(source_h</span><span class="s2">, </span><span class="s1">target_h):</span>
                <span class="s1">self.mkpath(os.path.dirname(target_c))</span>
                <span class="s1">self.copy_file(source_c</span><span class="s2">, </span><span class="s1">target_c)</span>
                <span class="s1">self.copy_file(source_h</span><span class="s2">, </span><span class="s1">target_h)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">os.path.isfile(target_c):</span>
                <span class="s2">raise </span><span class="s1">DistutilsSetupError(</span><span class="s4">&quot;f2py target_c file %r not found&quot; </span><span class="s1">% (target_c</span><span class="s2">,</span><span class="s1">))</span>
            <span class="s2">if not </span><span class="s1">os.path.isfile(target_h):</span>
                <span class="s2">raise </span><span class="s1">DistutilsSetupError(</span><span class="s4">&quot;f2py target_h file %r not found&quot; </span><span class="s1">% (target_h</span><span class="s2">,</span><span class="s1">))</span>

        <span class="s2">for </span><span class="s1">name_ext </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'-f2pywrappers.f'</span><span class="s2">, </span><span class="s4">'-f2pywrappers2.f90'</span><span class="s1">]:</span>
            <span class="s1">filename = os.path.join(target_dir</span><span class="s2">, </span><span class="s1">ext_name + name_ext)</span>
            <span class="s2">if </span><span class="s1">os.path.isfile(filename):</span>
                <span class="s1">log.info(</span><span class="s4">&quot;  adding '%s' to sources.&quot; </span><span class="s1">% (filename))</span>
                <span class="s1">f_sources.append(filename)</span>

        <span class="s2">return </span><span class="s1">new_sources + f_sources</span>

    <span class="s2">def </span><span class="s1">swig_sources(self</span><span class="s2">, </span><span class="s1">sources</span><span class="s2">, </span><span class="s1">extension):</span>
        <span class="s3"># Assuming SWIG 1.3.14 or later. See compatibility note in</span>
        <span class="s3">#   http://www.swig.org/Doc1.3/Python.html#Python_nn6</span>

        <span class="s1">new_sources = []</span>
        <span class="s1">swig_sources = []</span>
        <span class="s1">swig_targets = {}</span>
        <span class="s1">target_dirs = []</span>
        <span class="s1">py_files = []     </span><span class="s3"># swig generated .py files</span>
        <span class="s1">target_ext = </span><span class="s4">'.c'</span>
        <span class="s2">if </span><span class="s4">'-c++' </span><span class="s2">in </span><span class="s1">extension.swig_opts:</span>
            <span class="s1">typ = </span><span class="s4">'c++'</span>
            <span class="s1">is_cpp = </span><span class="s2">True</span>
            <span class="s1">extension.swig_opts.remove(</span><span class="s4">'-c++'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">self.swig_cpp:</span>
            <span class="s1">typ = </span><span class="s4">'c++'</span>
            <span class="s1">is_cpp = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">typ = </span><span class="s2">None</span>
            <span class="s1">is_cpp = </span><span class="s2">False</span>
        <span class="s1">skip_swig = </span><span class="s5">0</span>
        <span class="s1">ext_name = extension.name.split(</span><span class="s4">'.'</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s2">for </span><span class="s1">source </span><span class="s2">in </span><span class="s1">sources:</span>
            <span class="s1">(base</span><span class="s2">, </span><span class="s1">ext) = os.path.splitext(source)</span>
            <span class="s2">if </span><span class="s1">ext == </span><span class="s4">'.i'</span><span class="s1">: </span><span class="s3"># SWIG interface file</span>
                <span class="s3"># the code below assumes that the sources list</span>
                <span class="s3"># contains not more than one .i SWIG interface file</span>
                <span class="s2">if </span><span class="s1">self.inplace:</span>
                    <span class="s1">target_dir = os.path.dirname(base)</span>
                    <span class="s1">py_target_dir = self.ext_target_dir</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">target_dir = appendpath(self.build_src</span><span class="s2">, </span><span class="s1">os.path.dirname(base))</span>
                    <span class="s1">py_target_dir = target_dir</span>
                <span class="s2">if </span><span class="s1">os.path.isfile(source):</span>
                    <span class="s1">name = get_swig_modulename(source)</span>
                    <span class="s2">if </span><span class="s1">name != ext_name[</span><span class="s5">1</span><span class="s1">:]:</span>
                        <span class="s2">raise </span><span class="s1">DistutilsSetupError(</span>
                            <span class="s4">'mismatch of extension names: %s provides %r'</span>
                            <span class="s4">' but expected %r' </span><span class="s1">% (source</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">ext_name[</span><span class="s5">1</span><span class="s1">:]))</span>
                    <span class="s2">if </span><span class="s1">typ </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s1">typ = get_swig_target(source)</span>
                        <span class="s1">is_cpp = typ==</span><span class="s4">'c++'</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">typ2 = get_swig_target(source)</span>
                        <span class="s2">if </span><span class="s1">typ2 </span><span class="s2">is None</span><span class="s1">:</span>
                            <span class="s1">log.warn(</span><span class="s4">'source %r does not define swig target, assuming %s swig target' </span><span class="s1">\</span>
                                     <span class="s1">% (source</span><span class="s2">, </span><span class="s1">typ))</span>
                        <span class="s2">elif </span><span class="s1">typ!=typ2:</span>
                            <span class="s1">log.warn(</span><span class="s4">'expected %r but source %r defines %r swig target' </span><span class="s1">\</span>
                                     <span class="s1">% (typ</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">typ2))</span>
                            <span class="s2">if </span><span class="s1">typ2==</span><span class="s4">'c++'</span><span class="s1">:</span>
                                <span class="s1">log.warn(</span><span class="s4">'resetting swig target to c++ (some targets may have .c extension)'</span><span class="s1">)</span>
                                <span class="s1">is_cpp = </span><span class="s2">True</span>
                            <span class="s2">else</span><span class="s1">:</span>
                                <span class="s1">log.warn(</span><span class="s4">'assuming that %r has c++ swig target' </span><span class="s1">% (source))</span>
                    <span class="s2">if </span><span class="s1">is_cpp:</span>
                        <span class="s1">target_ext = </span><span class="s4">'.cpp'</span>
                    <span class="s1">target_file = os.path.join(target_dir</span><span class="s2">, </span><span class="s4">'%s_wrap%s' </span><span class="s1">\</span>
                                               <span class="s1">% (name</span><span class="s2">, </span><span class="s1">target_ext))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">log.warn(</span><span class="s4">'  source %s does not exist: skipping swig</span><span class="s2">\'</span><span class="s4">ing.' </span><span class="s1">\</span>
                             <span class="s1">% (source))</span>
                    <span class="s1">name = ext_name[</span><span class="s5">1</span><span class="s1">:]</span>
                    <span class="s1">skip_swig = </span><span class="s5">1</span>
                    <span class="s1">target_file = _find_swig_target(target_dir</span><span class="s2">, </span><span class="s1">name)</span>
                    <span class="s2">if not </span><span class="s1">os.path.isfile(target_file):</span>
                        <span class="s1">log.warn(</span><span class="s4">'  target %s does not exist:</span><span class="s2">\n   </span><span class="s4">'</span><span class="s1">\</span>
                                 <span class="s4">'Assuming %s_wrap.{c,cpp} was generated with '</span><span class="s1">\</span>
                                 <span class="s4">'&quot;build_src --inplace&quot; command.' </span><span class="s1">\</span>
                                 <span class="s1">% (target_file</span><span class="s2">, </span><span class="s1">name))</span>
                        <span class="s1">target_dir = os.path.dirname(base)</span>
                        <span class="s1">target_file = _find_swig_target(target_dir</span><span class="s2">, </span><span class="s1">name)</span>
                        <span class="s2">if not </span><span class="s1">os.path.isfile(target_file):</span>
                            <span class="s2">raise </span><span class="s1">DistutilsSetupError(</span><span class="s4">&quot;%r missing&quot; </span><span class="s1">% (target_file</span><span class="s2">,</span><span class="s1">))</span>
                        <span class="s1">log.warn(</span><span class="s4">'   Yes! Using %r as up-to-date target.' </span><span class="s1">\</span>
                                 <span class="s1">% (target_file))</span>
                <span class="s1">target_dirs.append(target_dir)</span>
                <span class="s1">new_sources.append(target_file)</span>
                <span class="s1">py_files.append(os.path.join(py_target_dir</span><span class="s2">, </span><span class="s1">name+</span><span class="s4">'.py'</span><span class="s1">))</span>
                <span class="s1">swig_sources.append(source)</span>
                <span class="s1">swig_targets[source] = new_sources[-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">new_sources.append(source)</span>

        <span class="s2">if not </span><span class="s1">swig_sources:</span>
            <span class="s2">return </span><span class="s1">new_sources</span>

        <span class="s2">if </span><span class="s1">skip_swig:</span>
            <span class="s2">return </span><span class="s1">new_sources + py_files</span>

        <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">target_dirs:</span>
            <span class="s1">self.mkpath(d)</span>

        <span class="s1">swig = self.swig </span><span class="s2">or </span><span class="s1">self.find_swig()</span>
        <span class="s1">swig_cmd = [swig</span><span class="s2">, </span><span class="s4">&quot;-python&quot;</span><span class="s1">] + extension.swig_opts</span>
        <span class="s2">if </span><span class="s1">is_cpp:</span>
            <span class="s1">swig_cmd.append(</span><span class="s4">'-c++'</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">extension.include_dirs:</span>
            <span class="s1">swig_cmd.append(</span><span class="s4">'-I'</span><span class="s1">+d)</span>
        <span class="s2">for </span><span class="s1">source </span><span class="s2">in </span><span class="s1">swig_sources:</span>
            <span class="s1">target = swig_targets[source]</span>
            <span class="s1">depends = [source] + extension.depends</span>
            <span class="s2">if </span><span class="s1">self.force </span><span class="s2">or </span><span class="s1">newer_group(depends</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s4">'newer'</span><span class="s1">):</span>
                <span class="s1">log.info(</span><span class="s4">&quot;%s: %s&quot; </span><span class="s1">% (os.path.basename(swig) \</span>
                                     <span class="s1">+ (is_cpp </span><span class="s2">and </span><span class="s4">'++' </span><span class="s2">or </span><span class="s4">''</span><span class="s1">)</span><span class="s2">, </span><span class="s1">source))</span>
                <span class="s1">self.spawn(swig_cmd + self.swig_opts \</span>
                           <span class="s1">+ [</span><span class="s4">&quot;-o&quot;</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s4">'-outdir'</span><span class="s2">, </span><span class="s1">py_target_dir</span><span class="s2">, </span><span class="s1">source])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">log.debug(</span><span class="s4">&quot;  skipping '%s' swig interface (up-to-date)&quot; </span><span class="s1">\</span>
                         <span class="s1">% (source))</span>

        <span class="s2">return </span><span class="s1">new_sources + py_files</span>

<span class="s1">_f_pyf_ext_match = re.compile(</span><span class="s4">r'.*\.(f90|f95|f77|for|ftn|f|pyf)\Z'</span><span class="s2">, </span><span class="s1">re.I).match</span>
<span class="s1">_header_ext_match = re.compile(</span><span class="s4">r'.*\.(inc|h|hpp)\Z'</span><span class="s2">, </span><span class="s1">re.I).match</span>

<span class="s3">#### SWIG related auxiliary functions ####</span>
<span class="s1">_swig_module_name_match = re.compile(</span><span class="s4">r'\s*%module\s*(.*\(\s*package\s*=\s*&quot;(?P&lt;package&gt;[\w_]+)&quot;.*\)|)\s*(?P&lt;name&gt;[\w_]+)'</span><span class="s2">,</span>
                                     <span class="s1">re.I).match</span>
<span class="s1">_has_c_header = re.compile(</span><span class="s4">r'-\*-\s*c\s*-\*-'</span><span class="s2">, </span><span class="s1">re.I).search</span>
<span class="s1">_has_cpp_header = re.compile(</span><span class="s4">r'-\*-\s*c\+\+\s*-\*-'</span><span class="s2">, </span><span class="s1">re.I).search</span>

<span class="s2">def </span><span class="s1">get_swig_target(source):</span>
    <span class="s2">with </span><span class="s1">open(source</span><span class="s2">, </span><span class="s4">'r'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s1">result = </span><span class="s2">None</span>
        <span class="s1">line = f.readline()</span>
        <span class="s2">if </span><span class="s1">_has_cpp_header(line):</span>
            <span class="s1">result = </span><span class="s4">'c++'</span>
        <span class="s2">if </span><span class="s1">_has_c_header(line):</span>
            <span class="s1">result = </span><span class="s4">'c'</span>
    <span class="s2">return </span><span class="s1">result</span>

<span class="s2">def </span><span class="s1">get_swig_modulename(source):</span>
    <span class="s2">with </span><span class="s1">open(source</span><span class="s2">, </span><span class="s4">'r'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s1">name = </span><span class="s2">None</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">f:</span>
            <span class="s1">m = _swig_module_name_match(line)</span>
            <span class="s2">if </span><span class="s1">m:</span>
                <span class="s1">name = m.group(</span><span class="s4">'name'</span><span class="s1">)</span>
                <span class="s2">break</span>
    <span class="s2">return </span><span class="s1">name</span>

<span class="s2">def </span><span class="s1">_find_swig_target(target_dir</span><span class="s2">, </span><span class="s1">name):</span>
    <span class="s2">for </span><span class="s1">ext </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'.cpp'</span><span class="s2">, </span><span class="s4">'.c'</span><span class="s1">]:</span>
        <span class="s1">target = os.path.join(target_dir</span><span class="s2">, </span><span class="s4">'%s_wrap%s' </span><span class="s1">% (name</span><span class="s2">, </span><span class="s1">ext))</span>
        <span class="s2">if </span><span class="s1">os.path.isfile(target):</span>
            <span class="s2">break</span>
    <span class="s2">return </span><span class="s1">target</span>

<span class="s3">#### F2PY related auxiliary functions ####</span>

<span class="s1">_f2py_module_name_match = re.compile(</span><span class="s4">r'\s*python\s*module\s*(?P&lt;name&gt;[\w_]+)'</span><span class="s2">,</span>
                                     <span class="s1">re.I).match</span>
<span class="s1">_f2py_user_module_name_match = re.compile(</span><span class="s4">r'\s*python\s*module\s*(?P&lt;name&gt;[\w_]*?'</span>
                                          <span class="s4">r'__user__[\w_]*)'</span><span class="s2">, </span><span class="s1">re.I).match</span>

<span class="s2">def </span><span class="s1">get_f2py_modulename(source):</span>
    <span class="s1">name = </span><span class="s2">None</span>
    <span class="s2">with </span><span class="s1">open(source) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">f:</span>
            <span class="s1">m = _f2py_module_name_match(line)</span>
            <span class="s2">if </span><span class="s1">m:</span>
                <span class="s2">if </span><span class="s1">_f2py_user_module_name_match(line): </span><span class="s3"># skip *__user__* names</span>
                    <span class="s2">continue</span>
                <span class="s1">name = m.group(</span><span class="s4">'name'</span><span class="s1">)</span>
                <span class="s2">break</span>
    <span class="s2">return </span><span class="s1">name</span>

<span class="s3">##########################################</span>
</pre>
</body>
</html>