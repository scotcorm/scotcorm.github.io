<html>
<head>
<title>typing_extensions.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
typing_extensions.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">abc</span>
<span class="s0">import </span><span class="s1">collections</span>
<span class="s0">import </span><span class="s1">collections.abc</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">typing</span>

<span class="s2"># After PEP 560, internal typing API was substantially reworked.</span>
<span class="s2"># This is especially important for Protocol class which uses internal APIs</span>
<span class="s2"># quite extensively.</span>
<span class="s1">PEP_560 = sys.version_info[:</span><span class="s3">3</span><span class="s1">] &gt;= (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

<span class="s0">if </span><span class="s1">PEP_560:</span>
    <span class="s1">GenericMeta = type</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s2"># 3.6</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">GenericMeta</span><span class="s0">, </span><span class="s1">_type_vars  </span><span class="s2"># noqa</span>

<span class="s2"># The two functions below are copies of typing internal helpers.</span>
<span class="s2"># They are needed by _ProtocolMeta</span>


<span class="s0">def </span><span class="s1">_no_slots_copy(dct):</span>
    <span class="s1">dict_copy = dict(dct)</span>
    <span class="s0">if </span><span class="s4">'__slots__' </span><span class="s0">in </span><span class="s1">dict_copy:</span>
        <span class="s0">for </span><span class="s1">slot </span><span class="s0">in </span><span class="s1">dict_copy[</span><span class="s4">'__slots__'</span><span class="s1">]:</span>
            <span class="s1">dict_copy.pop(slot</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">dict_copy</span>


<span class="s0">def </span><span class="s1">_check_generic(cls</span><span class="s0">, </span><span class="s1">parameters):</span>
    <span class="s0">if not </span><span class="s1">cls.__parameters__:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">cls</span><span class="s0">} </span><span class="s4">is not a generic class&quot;</span><span class="s1">)</span>
    <span class="s1">alen = len(parameters)</span>
    <span class="s1">elen = len(cls.__parameters__)</span>
    <span class="s0">if </span><span class="s1">alen != elen:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;Too </span><span class="s0">{</span><span class="s4">'many' </span><span class="s0">if </span><span class="s1">alen &gt; elen </span><span class="s0">else </span><span class="s4">'few'</span><span class="s0">} </span><span class="s4">arguments for </span><span class="s0">{</span><span class="s1">cls</span><span class="s0">}</span><span class="s4">;&quot;</span>
                        <span class="s4">f&quot; actual </span><span class="s0">{</span><span class="s1">alen</span><span class="s0">}</span><span class="s4">, expected </span><span class="s0">{</span><span class="s1">elen</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>


<span class="s2"># Please keep __all__ alphabetized within each category.</span>
<span class="s1">__all__ = [</span>
    <span class="s2"># Super-special typing primitives.</span>
    <span class="s4">'ClassVar'</span><span class="s0">,</span>
    <span class="s4">'Concatenate'</span><span class="s0">,</span>
    <span class="s4">'Final'</span><span class="s0">,</span>
    <span class="s4">'ParamSpec'</span><span class="s0">,</span>
    <span class="s4">'Self'</span><span class="s0">,</span>
    <span class="s4">'Type'</span><span class="s0">,</span>

    <span class="s2"># ABCs (from collections.abc).</span>
    <span class="s4">'Awaitable'</span><span class="s0">,</span>
    <span class="s4">'AsyncIterator'</span><span class="s0">,</span>
    <span class="s4">'AsyncIterable'</span><span class="s0">,</span>
    <span class="s4">'Coroutine'</span><span class="s0">,</span>
    <span class="s4">'AsyncGenerator'</span><span class="s0">,</span>
    <span class="s4">'AsyncContextManager'</span><span class="s0">,</span>
    <span class="s4">'ChainMap'</span><span class="s0">,</span>

    <span class="s2"># Concrete collection types.</span>
    <span class="s4">'ContextManager'</span><span class="s0">,</span>
    <span class="s4">'Counter'</span><span class="s0">,</span>
    <span class="s4">'Deque'</span><span class="s0">,</span>
    <span class="s4">'DefaultDict'</span><span class="s0">,</span>
    <span class="s4">'OrderedDict'</span><span class="s0">,</span>
    <span class="s4">'TypedDict'</span><span class="s0">,</span>

    <span class="s2"># Structural checks, a.k.a. protocols.</span>
    <span class="s4">'SupportsIndex'</span><span class="s0">,</span>

    <span class="s2"># One-off things.</span>
    <span class="s4">'Annotated'</span><span class="s0">,</span>
    <span class="s4">'final'</span><span class="s0">,</span>
    <span class="s4">'IntVar'</span><span class="s0">,</span>
    <span class="s4">'Literal'</span><span class="s0">,</span>
    <span class="s4">'NewType'</span><span class="s0">,</span>
    <span class="s4">'overload'</span><span class="s0">,</span>
    <span class="s4">'Protocol'</span><span class="s0">,</span>
    <span class="s4">'runtime'</span><span class="s0">,</span>
    <span class="s4">'runtime_checkable'</span><span class="s0">,</span>
    <span class="s4">'Text'</span><span class="s0">,</span>
    <span class="s4">'TypeAlias'</span><span class="s0">,</span>
    <span class="s4">'TypeGuard'</span><span class="s0">,</span>
    <span class="s4">'TYPE_CHECKING'</span><span class="s0">,</span>
<span class="s1">]</span>

<span class="s0">if </span><span class="s1">PEP_560:</span>
    <span class="s1">__all__.extend([</span><span class="s4">&quot;get_args&quot;</span><span class="s0">, </span><span class="s4">&quot;get_origin&quot;</span><span class="s0">, </span><span class="s4">&quot;get_type_hints&quot;</span><span class="s1">])</span>

<span class="s2"># 3.6.2+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'NoReturn'</span><span class="s1">):</span>
    <span class="s1">NoReturn = typing.NoReturn</span>
<span class="s2"># 3.6.0-3.6.1</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_NoReturn(typing._FinalTypingBase</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Special type indicating functions that never return. 
        Example:: 
 
          from typing import NoReturn 
 
          def stop() -&gt; NoReturn: 
              raise Exception('no way') 
 
        This type is invalid in other positions, e.g., ``List[NoReturn]`` 
        will fail in static type checkers. 
        &quot;&quot;&quot;</span>
        <span class="s1">__slots__ = ()</span>

        <span class="s0">def </span><span class="s1">__instancecheck__(self</span><span class="s0">, </span><span class="s1">obj):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;NoReturn cannot be used with isinstance().&quot;</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__subclasscheck__(self</span><span class="s0">, </span><span class="s1">cls):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;NoReturn cannot be used with issubclass().&quot;</span><span class="s1">)</span>

    <span class="s1">NoReturn = _NoReturn(_root=</span><span class="s0">True</span><span class="s1">)</span>

<span class="s2"># Some unconstrained type variables.  These are used by the container types.</span>
<span class="s2"># (These are not for export.)</span>
<span class="s1">T = typing.TypeVar(</span><span class="s4">'T'</span><span class="s1">)  </span><span class="s2"># Any type.</span>
<span class="s1">KT = typing.TypeVar(</span><span class="s4">'KT'</span><span class="s1">)  </span><span class="s2"># Key type.</span>
<span class="s1">VT = typing.TypeVar(</span><span class="s4">'VT'</span><span class="s1">)  </span><span class="s2"># Value type.</span>
<span class="s1">T_co = typing.TypeVar(</span><span class="s4">'T_co'</span><span class="s0">, </span><span class="s1">covariant=</span><span class="s0">True</span><span class="s1">)  </span><span class="s2"># Any type covariant containers.</span>
<span class="s1">T_contra = typing.TypeVar(</span><span class="s4">'T_contra'</span><span class="s0">, </span><span class="s1">contravariant=</span><span class="s0">True</span><span class="s1">)  </span><span class="s2"># Ditto contravariant.</span>

<span class="s1">ClassVar = typing.ClassVar</span>

<span class="s2"># On older versions of typing there is an internal class named &quot;Final&quot;.</span>
<span class="s2"># 3.8+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'Final'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">sys.version_info[:</span><span class="s3">2</span><span class="s1">] &gt;= (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">7</span><span class="s1">):</span>
    <span class="s1">Final = typing.Final</span>
<span class="s2"># 3.7</span>
<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s3">2</span><span class="s1">] &gt;= (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">7</span><span class="s1">):</span>
    <span class="s0">class </span><span class="s1">_FinalForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s4">'typing_extensions.' </span><span class="s1">+ self._name</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s1">item = typing._type_check(parameters</span><span class="s0">,</span>
                                      <span class="s4">f'</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">} </span><span class="s4">accepts only single type'</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s1">Final = _FinalForm(</span><span class="s4">'Final'</span><span class="s0">,</span>
                       <span class="s1">doc=</span><span class="s4">&quot;&quot;&quot;A special typing construct to indicate that a name 
                       cannot be re-assigned or overridden in a subclass. 
                       For example: 
 
                           MAX_SIZE: Final = 9000 
                           MAX_SIZE += 1  # Error reported by type checker 
 
                           class Connection: 
                               TIMEOUT: Final[int] = 10 
                           class FastConnector(Connection): 
                               TIMEOUT = 1  # Error reported by type checker 
 
                       There is no runtime checking of these properties.&quot;&quot;&quot;</span><span class="s1">)</span>
<span class="s2"># 3.6</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_Final(typing._FinalTypingBase</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;A special typing construct to indicate that a name 
        cannot be re-assigned or overridden in a subclass. 
        For example: 
 
            MAX_SIZE: Final = 9000 
            MAX_SIZE += 1  # Error reported by type checker 
 
            class Connection: 
                TIMEOUT: Final[int] = 10 
            class FastConnector(Connection): 
                TIMEOUT = 1  # Error reported by type checker 
 
        There is no runtime checking of these properties. 
        &quot;&quot;&quot;</span>

        <span class="s1">__slots__ = (</span><span class="s4">'__type__'</span><span class="s0">,</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">tp=</span><span class="s0">None, </span><span class="s1">**kwds):</span>
            <span class="s1">self.__type__ = tp</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">item):</span>
            <span class="s1">cls = type(self)</span>
            <span class="s0">if </span><span class="s1">self.__type__ </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">cls(typing._type_check(item</span><span class="s0">,</span>
                           <span class="s4">f'</span><span class="s0">{</span><span class="s1">cls.__name__[</span><span class="s3">1</span><span class="s1">:]</span><span class="s0">} </span><span class="s4">accepts only single type.'</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">_root=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f'</span><span class="s0">{</span><span class="s1">cls.__name__[</span><span class="s3">1</span><span class="s1">:]</span><span class="s0">} </span><span class="s4">cannot be further subscripted'</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">_eval_type(self</span><span class="s0">, </span><span class="s1">globalns</span><span class="s0">, </span><span class="s1">localns):</span>
            <span class="s1">new_tp = typing._eval_type(self.__type__</span><span class="s0">, </span><span class="s1">globalns</span><span class="s0">, </span><span class="s1">localns)</span>
            <span class="s0">if </span><span class="s1">new_tp == self.__type__:</span>
                <span class="s0">return </span><span class="s1">self</span>
            <span class="s0">return </span><span class="s1">type(self)(new_tp</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s1">r = super().__repr__()</span>
            <span class="s0">if </span><span class="s1">self.__type__ </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">r += </span><span class="s4">f'[</span><span class="s0">{</span><span class="s1">typing._type_repr(self.__type__)</span><span class="s0">}</span><span class="s4">]'</span>
            <span class="s0">return </span><span class="s1">r</span>

        <span class="s0">def </span><span class="s1">__hash__(self):</span>
            <span class="s0">return </span><span class="s1">hash((type(self).__name__</span><span class="s0">, </span><span class="s1">self.__type__))</span>

        <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">_Final):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
            <span class="s0">if </span><span class="s1">self.__type__ </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self.__type__ == other.__type__</span>
            <span class="s0">return </span><span class="s1">self </span><span class="s0">is </span><span class="s1">other</span>

    <span class="s1">Final = _Final(_root=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s2"># 3.8+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'final'</span><span class="s1">):</span>
    <span class="s1">final = typing.final</span>
<span class="s2"># 3.6-3.7</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">final(f):</span>
        <span class="s5">&quot;&quot;&quot;This decorator can be used to indicate to type checkers that 
        the decorated method cannot be overridden, and decorated class 
        cannot be subclassed. For example: 
 
            class Base: 
                @final 
                def done(self) -&gt; None: 
                    ... 
            class Sub(Base): 
                def done(self) -&gt; None:  # Error reported by type checker 
                    ... 
            @final 
            class Leaf: 
                ... 
            class Other(Leaf):  # Error reported by type checker 
                ... 
 
        There is no runtime checking of these properties. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">f</span>


<span class="s0">def </span><span class="s1">IntVar(name):</span>
    <span class="s0">return </span><span class="s1">typing.TypeVar(name)</span>


<span class="s2"># 3.8+:</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'Literal'</span><span class="s1">):</span>
    <span class="s1">Literal = typing.Literal</span>
<span class="s2"># 3.7:</span>
<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s3">2</span><span class="s1">] &gt;= (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">7</span><span class="s1">):</span>
    <span class="s0">class </span><span class="s1">_LiteralForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s4">'typing_extensions.' </span><span class="s1">+ self._name</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">parameters)</span>

    <span class="s1">Literal = _LiteralForm(</span><span class="s4">'Literal'</span><span class="s0">,</span>
                           <span class="s1">doc=</span><span class="s4">&quot;&quot;&quot;A type that can be used to indicate to type checkers 
                           that the corresponding value has a value literally equivalent 
                           to the provided parameter. For example: 
 
                               var: Literal[4] = 4 
 
                           The type checker understands that 'var' is literally equal to 
                           the value 4 and no other value. 
 
                           Literal[...] cannot be subclassed. There is no runtime 
                           checking verifying that the parameter is actually a value 
                           instead of a type.&quot;&quot;&quot;</span><span class="s1">)</span>
<span class="s2"># 3.6:</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_Literal(typing._FinalTypingBase</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;A type that can be used to indicate to type checkers that the 
        corresponding value has a value literally equivalent to the 
        provided parameter. For example: 
 
            var: Literal[4] = 4 
 
        The type checker understands that 'var' is literally equal to the 
        value 4 and no other value. 
 
        Literal[...] cannot be subclassed. There is no runtime checking 
        verifying that the parameter is actually a value instead of a type. 
        &quot;&quot;&quot;</span>

        <span class="s1">__slots__ = (</span><span class="s4">'__values__'</span><span class="s0">,</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">values=</span><span class="s0">None, </span><span class="s1">**kwds):</span>
            <span class="s1">self.__values__ = values</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">values):</span>
            <span class="s1">cls = type(self)</span>
            <span class="s0">if </span><span class="s1">self.__values__ </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">if not </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">tuple):</span>
                    <span class="s1">values = (values</span><span class="s0">,</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">cls(values</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f'</span><span class="s0">{</span><span class="s1">cls.__name__[</span><span class="s3">1</span><span class="s1">:]</span><span class="s0">} </span><span class="s4">cannot be further subscripted'</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">_eval_type(self</span><span class="s0">, </span><span class="s1">globalns</span><span class="s0">, </span><span class="s1">localns):</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s1">r = super().__repr__()</span>
            <span class="s0">if </span><span class="s1">self.__values__ </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">r += </span><span class="s4">f'[</span><span class="s0">{</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(map(typing._type_repr</span><span class="s0">, </span><span class="s1">self.__values__))</span><span class="s0">}</span><span class="s4">]'</span>
            <span class="s0">return </span><span class="s1">r</span>

        <span class="s0">def </span><span class="s1">__hash__(self):</span>
            <span class="s0">return </span><span class="s1">hash((type(self).__name__</span><span class="s0">, </span><span class="s1">self.__values__))</span>

        <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">_Literal):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
            <span class="s0">if </span><span class="s1">self.__values__ </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self.__values__ == other.__values__</span>
            <span class="s0">return </span><span class="s1">self </span><span class="s0">is </span><span class="s1">other</span>

    <span class="s1">Literal = _Literal(_root=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s1">_overload_dummy = typing._overload_dummy  </span><span class="s2"># noqa</span>
<span class="s1">overload = typing.overload</span>


<span class="s2"># This is not a real generic class.  Don't use outside annotations.</span>
<span class="s1">Type = typing.Type</span>

<span class="s2"># Various ABCs mimicking those in collections.abc.</span>
<span class="s2"># A few are simply re-exported for completeness.</span>


<span class="s0">class </span><span class="s1">_ExtensionsGenericMeta(GenericMeta):</span>
    <span class="s0">def </span><span class="s1">__subclasscheck__(self</span><span class="s0">, </span><span class="s1">subclass):</span>
        <span class="s5">&quot;&quot;&quot;This mimics a more modern GenericMeta.__subclasscheck__() logic 
        (that does not have problems with recursion) to work around interactions 
        between collections, typing, and typing_extensions on older 
        versions of Python, see https://github.com/python/typing/issues/501. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.__origin__ </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">sys._getframe(</span><span class="s3">1</span><span class="s1">).f_globals[</span><span class="s4">'__name__'</span><span class="s1">] </span><span class="s0">not in </span><span class="s1">[</span><span class="s4">'abc'</span><span class="s0">, </span><span class="s4">'functools'</span><span class="s1">]:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Parameterized generics cannot be used with class &quot;</span>
                                <span class="s4">&quot;or instance checks&quot;</span><span class="s1">)</span>
            <span class="s0">return False</span>
        <span class="s0">if not </span><span class="s1">self.__extra__:</span>
            <span class="s0">return </span><span class="s1">super().__subclasscheck__(subclass)</span>
        <span class="s1">res = self.__extra__.__subclasshook__(subclass)</span>
        <span class="s0">if </span><span class="s1">res </span><span class="s0">is not </span><span class="s1">NotImplemented:</span>
            <span class="s0">return </span><span class="s1">res</span>
        <span class="s0">if </span><span class="s1">self.__extra__ </span><span class="s0">in </span><span class="s1">subclass.__mro__:</span>
            <span class="s0">return True</span>
        <span class="s0">for </span><span class="s1">scls </span><span class="s0">in </span><span class="s1">self.__extra__.__subclasses__():</span>
            <span class="s0">if </span><span class="s1">isinstance(scls</span><span class="s0">, </span><span class="s1">GenericMeta):</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">issubclass(subclass</span><span class="s0">, </span><span class="s1">scls):</span>
                <span class="s0">return True</span>
        <span class="s0">return False</span>


<span class="s1">Awaitable = typing.Awaitable</span>
<span class="s1">Coroutine = typing.Coroutine</span>
<span class="s1">AsyncIterable = typing.AsyncIterable</span>
<span class="s1">AsyncIterator = typing.AsyncIterator</span>

<span class="s2"># 3.6.1+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'Deque'</span><span class="s1">):</span>
    <span class="s1">Deque = typing.Deque</span>
<span class="s2"># 3.6.0</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">Deque(collections.deque</span><span class="s0">, </span><span class="s1">typing.MutableSequence[T]</span><span class="s0">,</span>
                <span class="s1">metaclass=_ExtensionsGenericMeta</span><span class="s0">,</span>
                <span class="s1">extra=collections.deque):</span>
        <span class="s1">__slots__ = ()</span>

        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds):</span>
            <span class="s0">if </span><span class="s1">cls._gorg </span><span class="s0">is </span><span class="s1">Deque:</span>
                <span class="s0">return </span><span class="s1">collections.deque(*args</span><span class="s0">, </span><span class="s1">**kwds)</span>
            <span class="s0">return </span><span class="s1">typing._generic_new(collections.deque</span><span class="s0">, </span><span class="s1">cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds)</span>

<span class="s1">ContextManager = typing.ContextManager</span>
<span class="s2"># 3.6.2+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'AsyncContextManager'</span><span class="s1">):</span>
    <span class="s1">AsyncContextManager = typing.AsyncContextManager</span>
<span class="s2"># 3.6.0-3.6.1</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">from </span><span class="s1">_collections_abc </span><span class="s0">import </span><span class="s1">_check_methods </span><span class="s0">as </span><span class="s1">_check_methods_in_mro  </span><span class="s2"># noqa</span>

    <span class="s0">class </span><span class="s1">AsyncContextManager(typing.Generic[T_co]):</span>
        <span class="s1">__slots__ = ()</span>

        <span class="s0">async def </span><span class="s1">__aenter__(self):</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s1">@abc.abstractmethod</span>
        <span class="s0">async def </span><span class="s1">__aexit__(self</span><span class="s0">, </span><span class="s1">exc_type</span><span class="s0">, </span><span class="s1">exc_value</span><span class="s0">, </span><span class="s1">traceback):</span>
            <span class="s0">return None</span>

        <span class="s1">@classmethod</span>
        <span class="s0">def </span><span class="s1">__subclasshook__(cls</span><span class="s0">, </span><span class="s1">C):</span>
            <span class="s0">if </span><span class="s1">cls </span><span class="s0">is </span><span class="s1">AsyncContextManager:</span>
                <span class="s0">return </span><span class="s1">_check_methods_in_mro(C</span><span class="s0">, </span><span class="s4">&quot;__aenter__&quot;</span><span class="s0">, </span><span class="s4">&quot;__aexit__&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">NotImplemented</span>

<span class="s1">DefaultDict = typing.DefaultDict</span>

<span class="s2"># 3.7.2+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'OrderedDict'</span><span class="s1">):</span>
    <span class="s1">OrderedDict = typing.OrderedDict</span>
<span class="s2"># 3.7.0-3.7.2</span>
<span class="s0">elif </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">0</span><span class="s1">) &lt;= sys.version_info[:</span><span class="s3">3</span><span class="s1">] &lt; (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">2</span><span class="s1">):</span>
    <span class="s1">OrderedDict = typing._alias(collections.OrderedDict</span><span class="s0">, </span><span class="s1">(KT</span><span class="s0">, </span><span class="s1">VT))</span>
<span class="s2"># 3.6</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">OrderedDict(collections.OrderedDict</span><span class="s0">, </span><span class="s1">typing.MutableMapping[KT</span><span class="s0">, </span><span class="s1">VT]</span><span class="s0">,</span>
                      <span class="s1">metaclass=_ExtensionsGenericMeta</span><span class="s0">,</span>
                      <span class="s1">extra=collections.OrderedDict):</span>

        <span class="s1">__slots__ = ()</span>

        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds):</span>
            <span class="s0">if </span><span class="s1">cls._gorg </span><span class="s0">is </span><span class="s1">OrderedDict:</span>
                <span class="s0">return </span><span class="s1">collections.OrderedDict(*args</span><span class="s0">, </span><span class="s1">**kwds)</span>
            <span class="s0">return </span><span class="s1">typing._generic_new(collections.OrderedDict</span><span class="s0">, </span><span class="s1">cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds)</span>

<span class="s2"># 3.6.2+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'Counter'</span><span class="s1">):</span>
    <span class="s1">Counter = typing.Counter</span>
<span class="s2"># 3.6.0-3.6.1</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">Counter(collections.Counter</span><span class="s0">,</span>
                  <span class="s1">typing.Dict[T</span><span class="s0">, </span><span class="s1">int]</span><span class="s0">,</span>
                  <span class="s1">metaclass=_ExtensionsGenericMeta</span><span class="s0">, </span><span class="s1">extra=collections.Counter):</span>

        <span class="s1">__slots__ = ()</span>

        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds):</span>
            <span class="s0">if </span><span class="s1">cls._gorg </span><span class="s0">is </span><span class="s1">Counter:</span>
                <span class="s0">return </span><span class="s1">collections.Counter(*args</span><span class="s0">, </span><span class="s1">**kwds)</span>
            <span class="s0">return </span><span class="s1">typing._generic_new(collections.Counter</span><span class="s0">, </span><span class="s1">cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds)</span>

<span class="s2"># 3.6.1+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'ChainMap'</span><span class="s1">):</span>
    <span class="s1">ChainMap = typing.ChainMap</span>
<span class="s0">elif </span><span class="s1">hasattr(collections</span><span class="s0">, </span><span class="s4">'ChainMap'</span><span class="s1">):</span>
    <span class="s0">class </span><span class="s1">ChainMap(collections.ChainMap</span><span class="s0">, </span><span class="s1">typing.MutableMapping[KT</span><span class="s0">, </span><span class="s1">VT]</span><span class="s0">,</span>
                   <span class="s1">metaclass=_ExtensionsGenericMeta</span><span class="s0">,</span>
                   <span class="s1">extra=collections.ChainMap):</span>

        <span class="s1">__slots__ = ()</span>

        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds):</span>
            <span class="s0">if </span><span class="s1">cls._gorg </span><span class="s0">is </span><span class="s1">ChainMap:</span>
                <span class="s0">return </span><span class="s1">collections.ChainMap(*args</span><span class="s0">, </span><span class="s1">**kwds)</span>
            <span class="s0">return </span><span class="s1">typing._generic_new(collections.ChainMap</span><span class="s0">, </span><span class="s1">cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds)</span>

<span class="s2"># 3.6.1+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'AsyncGenerator'</span><span class="s1">):</span>
    <span class="s1">AsyncGenerator = typing.AsyncGenerator</span>
<span class="s2"># 3.6.0</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">AsyncGenerator(AsyncIterator[T_co]</span><span class="s0">, </span><span class="s1">typing.Generic[T_co</span><span class="s0">, </span><span class="s1">T_contra]</span><span class="s0">,</span>
                         <span class="s1">metaclass=_ExtensionsGenericMeta</span><span class="s0">,</span>
                         <span class="s1">extra=collections.abc.AsyncGenerator):</span>
        <span class="s1">__slots__ = ()</span>

<span class="s1">NewType = typing.NewType</span>
<span class="s1">Text = typing.Text</span>
<span class="s1">TYPE_CHECKING = typing.TYPE_CHECKING</span>


<span class="s0">def </span><span class="s1">_gorg(cls):</span>
    <span class="s5">&quot;&quot;&quot;This function exists for compatibility with old typing versions.&quot;&quot;&quot;</span>
    <span class="s0">assert </span><span class="s1">isinstance(cls</span><span class="s0">, </span><span class="s1">GenericMeta)</span>
    <span class="s0">if </span><span class="s1">hasattr(cls</span><span class="s0">, </span><span class="s4">'_gorg'</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">cls._gorg</span>
    <span class="s0">while </span><span class="s1">cls.__origin__ </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">cls = cls.__origin__</span>
    <span class="s0">return </span><span class="s1">cls</span>


<span class="s1">_PROTO_WHITELIST = [</span><span class="s4">'Callable'</span><span class="s0">, </span><span class="s4">'Awaitable'</span><span class="s0">,</span>
                    <span class="s4">'Iterable'</span><span class="s0">, </span><span class="s4">'Iterator'</span><span class="s0">, </span><span class="s4">'AsyncIterable'</span><span class="s0">, </span><span class="s4">'AsyncIterator'</span><span class="s0">,</span>
                    <span class="s4">'Hashable'</span><span class="s0">, </span><span class="s4">'Sized'</span><span class="s0">, </span><span class="s4">'Container'</span><span class="s0">, </span><span class="s4">'Collection'</span><span class="s0">, </span><span class="s4">'Reversible'</span><span class="s0">,</span>
                    <span class="s4">'ContextManager'</span><span class="s0">, </span><span class="s4">'AsyncContextManager'</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">_get_protocol_attrs(cls):</span>
    <span class="s1">attrs = set()</span>
    <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">cls.__mro__[:-</span><span class="s3">1</span><span class="s1">]:  </span><span class="s2"># without object</span>
        <span class="s0">if </span><span class="s1">base.__name__ </span><span class="s0">in </span><span class="s1">(</span><span class="s4">'Protocol'</span><span class="s0">, </span><span class="s4">'Generic'</span><span class="s1">):</span>
            <span class="s0">continue</span>
        <span class="s1">annotations = getattr(base</span><span class="s0">, </span><span class="s4">'__annotations__'</span><span class="s0">, </span><span class="s1">{})</span>
        <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">list(base.__dict__.keys()) + list(annotations.keys()):</span>
            <span class="s0">if </span><span class="s1">(</span><span class="s0">not </span><span class="s1">attr.startswith(</span><span class="s4">'_abc_'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">attr </span><span class="s0">not in </span><span class="s1">(</span>
                    <span class="s4">'__abstractmethods__'</span><span class="s0">, </span><span class="s4">'__annotations__'</span><span class="s0">, </span><span class="s4">'__weakref__'</span><span class="s0">,</span>
                    <span class="s4">'_is_protocol'</span><span class="s0">, </span><span class="s4">'_is_runtime_protocol'</span><span class="s0">, </span><span class="s4">'__dict__'</span><span class="s0">,</span>
                    <span class="s4">'__args__'</span><span class="s0">, </span><span class="s4">'__slots__'</span><span class="s0">,</span>
                    <span class="s4">'__next_in_mro__'</span><span class="s0">, </span><span class="s4">'__parameters__'</span><span class="s0">, </span><span class="s4">'__origin__'</span><span class="s0">,</span>
                    <span class="s4">'__orig_bases__'</span><span class="s0">, </span><span class="s4">'__extra__'</span><span class="s0">, </span><span class="s4">'__tree_hash__'</span><span class="s0">,</span>
                    <span class="s4">'__doc__'</span><span class="s0">, </span><span class="s4">'__subclasshook__'</span><span class="s0">, </span><span class="s4">'__init__'</span><span class="s0">, </span><span class="s4">'__new__'</span><span class="s0">,</span>
                    <span class="s4">'__module__'</span><span class="s0">, </span><span class="s4">'_MutableMapping__marker'</span><span class="s0">, </span><span class="s4">'_gorg'</span><span class="s1">)):</span>
                <span class="s1">attrs.add(attr)</span>
    <span class="s0">return </span><span class="s1">attrs</span>


<span class="s0">def </span><span class="s1">_is_callable_members_only(cls):</span>
    <span class="s0">return </span><span class="s1">all(callable(getattr(cls</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, None</span><span class="s1">)) </span><span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">_get_protocol_attrs(cls))</span>


<span class="s2"># 3.8+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'Protocol'</span><span class="s1">):</span>
    <span class="s1">Protocol = typing.Protocol</span>
<span class="s2"># 3.7</span>
<span class="s0">elif </span><span class="s1">PEP_560:</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">_collect_type_vars  </span><span class="s2"># noqa</span>

    <span class="s0">def </span><span class="s1">_no_init(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s1">type(self)._is_protocol:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Protocols cannot be instantiated'</span><span class="s1">)</span>

    <span class="s0">class </span><span class="s1">_ProtocolMeta(abc.ABCMeta):</span>
        <span class="s2"># This metaclass is a bit unfortunate and exists only because of the lack</span>
        <span class="s2"># of __instancehook__.</span>
        <span class="s0">def </span><span class="s1">__instancecheck__(cls</span><span class="s0">, </span><span class="s1">instance):</span>
            <span class="s2"># We need this method for situations where attributes are</span>
            <span class="s2"># assigned in __init__.</span>
            <span class="s0">if </span><span class="s1">((</span><span class="s0">not </span><span class="s1">getattr(cls</span><span class="s0">, </span><span class="s4">'_is_protocol'</span><span class="s0">, False</span><span class="s1">) </span><span class="s0">or</span>
                 <span class="s1">_is_callable_members_only(cls)) </span><span class="s0">and</span>
                    <span class="s1">issubclass(instance.__class__</span><span class="s0">, </span><span class="s1">cls)):</span>
                <span class="s0">return True</span>
            <span class="s0">if </span><span class="s1">cls._is_protocol:</span>
                <span class="s0">if </span><span class="s1">all(hasattr(instance</span><span class="s0">, </span><span class="s1">attr) </span><span class="s0">and</span>
                       <span class="s1">(</span><span class="s0">not </span><span class="s1">callable(getattr(cls</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, None</span><span class="s1">)) </span><span class="s0">or</span>
                        <span class="s1">getattr(instance</span><span class="s0">, </span><span class="s1">attr) </span><span class="s0">is not None</span><span class="s1">)</span>
                       <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">_get_protocol_attrs(cls)):</span>
                    <span class="s0">return True</span>
            <span class="s0">return </span><span class="s1">super().__instancecheck__(instance)</span>

    <span class="s0">class </span><span class="s1">Protocol(metaclass=_ProtocolMeta):</span>
        <span class="s2"># There is quite a lot of overlapping code with typing.Generic.</span>
        <span class="s2"># Unfortunately it is hard to avoid this while these live in two different</span>
        <span class="s2"># modules. The duplicated code will be removed when Protocol is moved to typing.</span>
        <span class="s5">&quot;&quot;&quot;Base class for protocol classes. Protocol classes are defined as:: 
 
            class Proto(Protocol): 
                def meth(self) -&gt; int: 
                    ... 
 
        Such classes are primarily used with static type checkers that recognize 
        structural subtyping (static duck-typing), for example:: 
 
            class C: 
                def meth(self) -&gt; int: 
                    return 0 
 
            def func(x: Proto) -&gt; int: 
                return x.meth() 
 
            func(C())  # Passes static type check 
 
        See PEP 544 for details. Protocol classes decorated with 
        @typing_extensions.runtime act as simple-minded runtime protocol that checks 
        only the presence of given attributes, ignoring their type signatures. 
 
        Protocol classes can be generic, they are defined as:: 
 
            class GenProto(Protocol[T]): 
                def meth(self) -&gt; T: 
                    ... 
        &quot;&quot;&quot;</span>
        <span class="s1">__slots__ = ()</span>
        <span class="s1">_is_protocol = </span><span class="s0">True</span>

        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds):</span>
            <span class="s0">if </span><span class="s1">cls </span><span class="s0">is </span><span class="s1">Protocol:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Type Protocol cannot be instantiated; &quot;</span>
                                <span class="s4">&quot;it can only be used as a base class&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">super().__new__(cls)</span>

        <span class="s1">@typing._tp_cache</span>
        <span class="s0">def </span><span class="s1">__class_getitem__(cls</span><span class="s0">, </span><span class="s1">params):</span>
            <span class="s0">if not </span><span class="s1">isinstance(params</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">params = (params</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s0">if not </span><span class="s1">params </span><span class="s0">and </span><span class="s1">cls </span><span class="s0">is not </span><span class="s1">typing.Tuple:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">f&quot;Parameter list to </span><span class="s0">{</span><span class="s1">cls.__qualname__</span><span class="s0">}</span><span class="s4">[...] cannot be empty&quot;</span><span class="s1">)</span>
            <span class="s1">msg = </span><span class="s4">&quot;Parameters to generic types must be types.&quot;</span>
            <span class="s1">params = tuple(typing._type_check(p</span><span class="s0">, </span><span class="s1">msg) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">params)  </span><span class="s2"># noqa</span>
            <span class="s0">if </span><span class="s1">cls </span><span class="s0">is </span><span class="s1">Protocol:</span>
                <span class="s2"># Generic can only be subscripted with unique type variables.</span>
                <span class="s0">if not </span><span class="s1">all(isinstance(p</span><span class="s0">, </span><span class="s1">typing.TypeVar) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">params):</span>
                    <span class="s1">i = </span><span class="s3">0</span>
                    <span class="s0">while </span><span class="s1">isinstance(params[i]</span><span class="s0">, </span><span class="s1">typing.TypeVar):</span>
                        <span class="s1">i += </span><span class="s3">1</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span>
                        <span class="s4">&quot;Parameters to Protocol[...] must all be type variables.&quot;</span>
                        <span class="s4">f&quot; Parameter </span><span class="s0">{</span><span class="s1">i + </span><span class="s3">1</span><span class="s0">} </span><span class="s4">is </span><span class="s0">{</span><span class="s1">params[i]</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">len(set(params)) != len(params):</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span>
                        <span class="s4">&quot;Parameters to Protocol[...] must all be unique&quot;</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># Subscripting a regular Generic subclass.</span>
                <span class="s1">_check_generic(cls</span><span class="s0">, </span><span class="s1">params)</span>
            <span class="s0">return </span><span class="s1">typing._GenericAlias(cls</span><span class="s0">, </span><span class="s1">params)</span>

        <span class="s0">def </span><span class="s1">__init_subclass__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s1">tvars = []</span>
            <span class="s0">if </span><span class="s4">'__orig_bases__' </span><span class="s0">in </span><span class="s1">cls.__dict__:</span>
                <span class="s1">error = typing.Generic </span><span class="s0">in </span><span class="s1">cls.__orig_bases__</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">error = typing.Generic </span><span class="s0">in </span><span class="s1">cls.__bases__</span>
            <span class="s0">if </span><span class="s1">error:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot inherit from plain Generic&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s4">'__orig_bases__' </span><span class="s0">in </span><span class="s1">cls.__dict__:</span>
                <span class="s1">tvars = _collect_type_vars(cls.__orig_bases__)</span>
                <span class="s2"># Look for Generic[T1, ..., Tn] or Protocol[T1, ..., Tn].</span>
                <span class="s2"># If found, tvars must be a subset of it.</span>
                <span class="s2"># If not found, tvars is it.</span>
                <span class="s2"># Also check for and reject plain Generic,</span>
                <span class="s2"># and reject multiple Generic[...] and/or Protocol[...].</span>
                <span class="s1">gvars = </span><span class="s0">None</span>
                <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">cls.__orig_bases__:</span>
                    <span class="s0">if </span><span class="s1">(isinstance(base</span><span class="s0">, </span><span class="s1">typing._GenericAlias) </span><span class="s0">and</span>
                            <span class="s1">base.__origin__ </span><span class="s0">in </span><span class="s1">(typing.Generic</span><span class="s0">, </span><span class="s1">Protocol)):</span>
                        <span class="s2"># for error messages</span>
                        <span class="s1">the_base = base.__origin__.__name__</span>
                        <span class="s0">if </span><span class="s1">gvars </span><span class="s0">is not None</span><span class="s1">:</span>
                            <span class="s0">raise </span><span class="s1">TypeError(</span>
                                <span class="s4">&quot;Cannot inherit from Generic[...]&quot;</span>
                                <span class="s4">&quot; and/or Protocol[...] multiple types.&quot;</span><span class="s1">)</span>
                        <span class="s1">gvars = base.__parameters__</span>
                <span class="s0">if </span><span class="s1">gvars </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">gvars = tvars</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">tvarset = set(tvars)</span>
                    <span class="s1">gvarset = set(gvars)</span>
                    <span class="s0">if not </span><span class="s1">tvarset &lt;= gvarset:</span>
                        <span class="s1">s_vars = </span><span class="s4">', '</span><span class="s1">.join(str(t) </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">tvars </span><span class="s0">if </span><span class="s1">t </span><span class="s0">not in </span><span class="s1">gvarset)</span>
                        <span class="s1">s_args = </span><span class="s4">', '</span><span class="s1">.join(str(g) </span><span class="s0">for </span><span class="s1">g </span><span class="s0">in </span><span class="s1">gvars)</span>
                        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;Some type variables (</span><span class="s0">{</span><span class="s1">s_vars</span><span class="s0">}</span><span class="s4">) are&quot;</span>
                                        <span class="s4">f&quot; not listed in </span><span class="s0">{</span><span class="s1">the_base</span><span class="s0">}</span><span class="s4">[</span><span class="s0">{</span><span class="s1">s_args</span><span class="s0">}</span><span class="s4">]&quot;</span><span class="s1">)</span>
                    <span class="s1">tvars = gvars</span>
            <span class="s1">cls.__parameters__ = tuple(tvars)</span>

            <span class="s2"># Determine if this is a protocol or a concrete subclass.</span>
            <span class="s0">if not </span><span class="s1">cls.__dict__.get(</span><span class="s4">'_is_protocol'</span><span class="s0">, None</span><span class="s1">):</span>
                <span class="s1">cls._is_protocol = any(b </span><span class="s0">is </span><span class="s1">Protocol </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">cls.__bases__)</span>

            <span class="s2"># Set (or override) the protocol subclass hook.</span>
            <span class="s0">def </span><span class="s1">_proto_hook(other):</span>
                <span class="s0">if not </span><span class="s1">cls.__dict__.get(</span><span class="s4">'_is_protocol'</span><span class="s0">, None</span><span class="s1">):</span>
                    <span class="s0">return </span><span class="s1">NotImplemented</span>
                <span class="s0">if not </span><span class="s1">getattr(cls</span><span class="s0">, </span><span class="s4">'_is_runtime_protocol'</span><span class="s0">, False</span><span class="s1">):</span>
                    <span class="s0">if </span><span class="s1">sys._getframe(</span><span class="s3">2</span><span class="s1">).f_globals[</span><span class="s4">'__name__'</span><span class="s1">] </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'abc'</span><span class="s0">, </span><span class="s4">'functools'</span><span class="s1">]:</span>
                        <span class="s0">return </span><span class="s1">NotImplemented</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Instance and class checks can only be used with&quot;</span>
                                    <span class="s4">&quot; @runtime protocols&quot;</span><span class="s1">)</span>
                <span class="s0">if not </span><span class="s1">_is_callable_members_only(cls):</span>
                    <span class="s0">if </span><span class="s1">sys._getframe(</span><span class="s3">2</span><span class="s1">).f_globals[</span><span class="s4">'__name__'</span><span class="s1">] </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'abc'</span><span class="s0">, </span><span class="s4">'functools'</span><span class="s1">]:</span>
                        <span class="s0">return </span><span class="s1">NotImplemented</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Protocols with non-method members&quot;</span>
                                    <span class="s4">&quot; don't support issubclass()&quot;</span><span class="s1">)</span>
                <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">type):</span>
                    <span class="s2"># Same error as for issubclass(1, int)</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'issubclass() arg 1 must be a class'</span><span class="s1">)</span>
                <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">_get_protocol_attrs(cls):</span>
                    <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">other.__mro__:</span>
                        <span class="s0">if </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">base.__dict__:</span>
                            <span class="s0">if </span><span class="s1">base.__dict__[attr] </span><span class="s0">is None</span><span class="s1">:</span>
                                <span class="s0">return </span><span class="s1">NotImplemented</span>
                            <span class="s0">break</span>
                        <span class="s1">annotations = getattr(base</span><span class="s0">, </span><span class="s4">'__annotations__'</span><span class="s0">, </span><span class="s1">{})</span>
                        <span class="s0">if </span><span class="s1">(isinstance(annotations</span><span class="s0">, </span><span class="s1">typing.Mapping) </span><span class="s0">and</span>
                                <span class="s1">attr </span><span class="s0">in </span><span class="s1">annotations </span><span class="s0">and</span>
                                <span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">_ProtocolMeta) </span><span class="s0">and</span>
                                <span class="s1">other._is_protocol):</span>
                            <span class="s0">break</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s0">return </span><span class="s1">NotImplemented</span>
                <span class="s0">return True</span>
            <span class="s0">if </span><span class="s4">'__subclasshook__' </span><span class="s0">not in </span><span class="s1">cls.__dict__:</span>
                <span class="s1">cls.__subclasshook__ = _proto_hook</span>

            <span class="s2"># We have nothing more to do for non-protocols.</span>
            <span class="s0">if not </span><span class="s1">cls._is_protocol:</span>
                <span class="s0">return</span>

            <span class="s2"># Check consistency of bases.</span>
            <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">cls.__bases__:</span>
                <span class="s0">if not </span><span class="s1">(base </span><span class="s0">in </span><span class="s1">(object</span><span class="s0">, </span><span class="s1">typing.Generic) </span><span class="s0">or</span>
                        <span class="s1">base.__module__ == </span><span class="s4">'collections.abc' </span><span class="s0">and</span>
                        <span class="s1">base.__name__ </span><span class="s0">in </span><span class="s1">_PROTO_WHITELIST </span><span class="s0">or</span>
                        <span class="s1">isinstance(base</span><span class="s0">, </span><span class="s1">_ProtocolMeta) </span><span class="s0">and </span><span class="s1">base._is_protocol):</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Protocols can only inherit from other'</span>
                                    <span class="s4">f' protocols, got </span><span class="s0">{</span><span class="s1">repr(base)</span><span class="s0">}</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">cls.__init__ = _no_init</span>
<span class="s2"># 3.6</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">_next_in_mro</span><span class="s0">, </span><span class="s1">_type_check  </span><span class="s2"># noqa</span>

    <span class="s0">def </span><span class="s1">_no_init(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s1">type(self)._is_protocol:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Protocols cannot be instantiated'</span><span class="s1">)</span>

    <span class="s0">class </span><span class="s1">_ProtocolMeta(GenericMeta):</span>
        <span class="s5">&quot;&quot;&quot;Internal metaclass for Protocol. 
 
        This exists so Protocol classes can be generic without deriving 
        from Generic. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">bases</span><span class="s0">, </span><span class="s1">namespace</span><span class="s0">,</span>
                    <span class="s1">tvars=</span><span class="s0">None, </span><span class="s1">args=</span><span class="s0">None, </span><span class="s1">origin=</span><span class="s0">None, </span><span class="s1">extra=</span><span class="s0">None, </span><span class="s1">orig_bases=</span><span class="s0">None</span><span class="s1">):</span>
            <span class="s2"># This is just a version copied from GenericMeta.__new__ that</span>
            <span class="s2"># includes &quot;Protocol&quot; special treatment. (Comments removed for brevity.)</span>
            <span class="s0">assert </span><span class="s1">extra </span><span class="s0">is None  </span><span class="s2"># Protocols should not have extra</span>
            <span class="s0">if </span><span class="s1">tvars </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">assert </span><span class="s1">origin </span><span class="s0">is not None</span>
                <span class="s0">assert </span><span class="s1">all(isinstance(t</span><span class="s0">, </span><span class="s1">typing.TypeVar) </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">tvars)</span><span class="s0">, </span><span class="s1">tvars</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">tvars = _type_vars(bases)</span>
                <span class="s1">gvars = </span><span class="s0">None</span>
                <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">bases:</span>
                    <span class="s0">if </span><span class="s1">base </span><span class="s0">is </span><span class="s1">typing.Generic:</span>
                        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot inherit from plain Generic&quot;</span><span class="s1">)</span>
                    <span class="s0">if </span><span class="s1">(isinstance(base</span><span class="s0">, </span><span class="s1">GenericMeta) </span><span class="s0">and</span>
                            <span class="s1">base.__origin__ </span><span class="s0">in </span><span class="s1">(typing.Generic</span><span class="s0">, </span><span class="s1">Protocol)):</span>
                        <span class="s0">if </span><span class="s1">gvars </span><span class="s0">is not None</span><span class="s1">:</span>
                            <span class="s0">raise </span><span class="s1">TypeError(</span>
                                <span class="s4">&quot;Cannot inherit from Generic[...] or&quot;</span>
                                <span class="s4">&quot; Protocol[...] multiple times.&quot;</span><span class="s1">)</span>
                        <span class="s1">gvars = base.__parameters__</span>
                <span class="s0">if </span><span class="s1">gvars </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">gvars = tvars</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">tvarset = set(tvars)</span>
                    <span class="s1">gvarset = set(gvars)</span>
                    <span class="s0">if not </span><span class="s1">tvarset &lt;= gvarset:</span>
                        <span class="s1">s_vars = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(str(t) </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">tvars </span><span class="s0">if </span><span class="s1">t </span><span class="s0">not in </span><span class="s1">gvarset)</span>
                        <span class="s1">s_args = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(str(g) </span><span class="s0">for </span><span class="s1">g </span><span class="s0">in </span><span class="s1">gvars)</span>
                        <span class="s1">cls_name = </span><span class="s4">&quot;Generic&quot; </span><span class="s0">if </span><span class="s1">any(b.__origin__ </span><span class="s0">is </span><span class="s1">typing.Generic</span>
                                                    <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">bases) </span><span class="s0">else </span><span class="s4">&quot;Protocol&quot;</span>
                        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;Some type variables (</span><span class="s0">{</span><span class="s1">s_vars</span><span class="s0">}</span><span class="s4">) are&quot;</span>
                                        <span class="s4">f&quot; not listed in </span><span class="s0">{</span><span class="s1">cls_name</span><span class="s0">}</span><span class="s4">[</span><span class="s0">{</span><span class="s1">s_args</span><span class="s0">}</span><span class="s4">]&quot;</span><span class="s1">)</span>
                    <span class="s1">tvars = gvars</span>

            <span class="s1">initial_bases = bases</span>
            <span class="s0">if </span><span class="s1">(extra </span><span class="s0">is not None and </span><span class="s1">type(extra) </span><span class="s0">is </span><span class="s1">abc.ABCMeta </span><span class="s0">and</span>
                    <span class="s1">extra </span><span class="s0">not in </span><span class="s1">bases):</span>
                <span class="s1">bases = (extra</span><span class="s0">,</span><span class="s1">) + bases</span>
            <span class="s1">bases = tuple(_gorg(b) </span><span class="s0">if </span><span class="s1">isinstance(b</span><span class="s0">, </span><span class="s1">GenericMeta) </span><span class="s0">else </span><span class="s1">b</span>
                          <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">bases)</span>
            <span class="s0">if </span><span class="s1">any(isinstance(b</span><span class="s0">, </span><span class="s1">GenericMeta) </span><span class="s0">and </span><span class="s1">b </span><span class="s0">is not </span><span class="s1">typing.Generic </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">bases):</span>
                <span class="s1">bases = tuple(b </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">bases </span><span class="s0">if </span><span class="s1">b </span><span class="s0">is not </span><span class="s1">typing.Generic)</span>
            <span class="s1">namespace.update({</span><span class="s4">'__origin__'</span><span class="s1">: origin</span><span class="s0">, </span><span class="s4">'__extra__'</span><span class="s1">: extra})</span>
            <span class="s1">self = super(GenericMeta</span><span class="s0">, </span><span class="s1">cls).__new__(cls</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">bases</span><span class="s0">, </span><span class="s1">namespace</span><span class="s0">,</span>
                                                   <span class="s1">_root=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">super(GenericMeta</span><span class="s0">, </span><span class="s1">self).__setattr__(</span><span class="s4">'_gorg'</span><span class="s0">,</span>
                                                 <span class="s1">self </span><span class="s0">if not </span><span class="s1">origin </span><span class="s0">else</span>
                                                 <span class="s1">_gorg(origin))</span>
            <span class="s1">self.__parameters__ = tvars</span>
            <span class="s1">self.__args__ = tuple(... </span><span class="s0">if </span><span class="s1">a </span><span class="s0">is </span><span class="s1">typing._TypingEllipsis </span><span class="s0">else</span>
                                  <span class="s1">() </span><span class="s0">if </span><span class="s1">a </span><span class="s0">is </span><span class="s1">typing._TypingEmpty </span><span class="s0">else</span>
                                  <span class="s1">a </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">args) </span><span class="s0">if </span><span class="s1">args </span><span class="s0">else None</span>
            <span class="s1">self.__next_in_mro__ = _next_in_mro(self)</span>
            <span class="s0">if </span><span class="s1">orig_bases </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">self.__orig_bases__ = initial_bases</span>
            <span class="s0">elif </span><span class="s1">origin </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">self._abc_registry = origin._abc_registry</span>
                <span class="s1">self._abc_cache = origin._abc_cache</span>
            <span class="s0">if </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s4">'_subs_tree'</span><span class="s1">):</span>
                <span class="s1">self.__tree_hash__ = (hash(self._subs_tree()) </span><span class="s0">if </span><span class="s1">origin </span><span class="s0">else</span>
                                      <span class="s1">super(GenericMeta</span><span class="s0">, </span><span class="s1">self).__hash__())</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s0">def </span><span class="s1">__init__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s1">super().__init__(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">if not </span><span class="s1">cls.__dict__.get(</span><span class="s4">'_is_protocol'</span><span class="s0">, None</span><span class="s1">):</span>
                <span class="s1">cls._is_protocol = any(b </span><span class="s0">is </span><span class="s1">Protocol </span><span class="s0">or</span>
                                       <span class="s1">isinstance(b</span><span class="s0">, </span><span class="s1">_ProtocolMeta) </span><span class="s0">and</span>
                                       <span class="s1">b.__origin__ </span><span class="s0">is </span><span class="s1">Protocol</span>
                                       <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">cls.__bases__)</span>
            <span class="s0">if </span><span class="s1">cls._is_protocol:</span>
                <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">cls.__mro__[</span><span class="s3">1</span><span class="s1">:]:</span>
                    <span class="s0">if not </span><span class="s1">(base </span><span class="s0">in </span><span class="s1">(object</span><span class="s0">, </span><span class="s1">typing.Generic) </span><span class="s0">or</span>
                            <span class="s1">base.__module__ == </span><span class="s4">'collections.abc' </span><span class="s0">and</span>
                            <span class="s1">base.__name__ </span><span class="s0">in </span><span class="s1">_PROTO_WHITELIST </span><span class="s0">or</span>
                            <span class="s1">isinstance(base</span><span class="s0">, </span><span class="s1">typing.TypingMeta) </span><span class="s0">and </span><span class="s1">base._is_protocol </span><span class="s0">or</span>
                            <span class="s1">isinstance(base</span><span class="s0">, </span><span class="s1">GenericMeta) </span><span class="s0">and</span>
                            <span class="s1">base.__origin__ </span><span class="s0">is </span><span class="s1">typing.Generic):</span>
                        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f'Protocols can only inherit from other'</span>
                                        <span class="s4">f' protocols, got </span><span class="s0">{</span><span class="s1">repr(base)</span><span class="s0">}</span><span class="s4">'</span><span class="s1">)</span>

                <span class="s1">cls.__init__ = _no_init</span>

            <span class="s0">def </span><span class="s1">_proto_hook(other):</span>
                <span class="s0">if not </span><span class="s1">cls.__dict__.get(</span><span class="s4">'_is_protocol'</span><span class="s0">, None</span><span class="s1">):</span>
                    <span class="s0">return </span><span class="s1">NotImplemented</span>
                <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">type):</span>
                    <span class="s2"># Same error as for issubclass(1, int)</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'issubclass() arg 1 must be a class'</span><span class="s1">)</span>
                <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">_get_protocol_attrs(cls):</span>
                    <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">other.__mro__:</span>
                        <span class="s0">if </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">base.__dict__:</span>
                            <span class="s0">if </span><span class="s1">base.__dict__[attr] </span><span class="s0">is None</span><span class="s1">:</span>
                                <span class="s0">return </span><span class="s1">NotImplemented</span>
                            <span class="s0">break</span>
                        <span class="s1">annotations = getattr(base</span><span class="s0">, </span><span class="s4">'__annotations__'</span><span class="s0">, </span><span class="s1">{})</span>
                        <span class="s0">if </span><span class="s1">(isinstance(annotations</span><span class="s0">, </span><span class="s1">typing.Mapping) </span><span class="s0">and</span>
                                <span class="s1">attr </span><span class="s0">in </span><span class="s1">annotations </span><span class="s0">and</span>
                                <span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">_ProtocolMeta) </span><span class="s0">and</span>
                                <span class="s1">other._is_protocol):</span>
                            <span class="s0">break</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s0">return </span><span class="s1">NotImplemented</span>
                <span class="s0">return True</span>
            <span class="s0">if </span><span class="s4">'__subclasshook__' </span><span class="s0">not in </span><span class="s1">cls.__dict__:</span>
                <span class="s1">cls.__subclasshook__ = _proto_hook</span>

        <span class="s0">def </span><span class="s1">__instancecheck__(self</span><span class="s0">, </span><span class="s1">instance):</span>
            <span class="s2"># We need this method for situations where attributes are</span>
            <span class="s2"># assigned in __init__.</span>
            <span class="s0">if </span><span class="s1">((</span><span class="s0">not </span><span class="s1">getattr(self</span><span class="s0">, </span><span class="s4">'_is_protocol'</span><span class="s0">, False</span><span class="s1">) </span><span class="s0">or</span>
                    <span class="s1">_is_callable_members_only(self)) </span><span class="s0">and</span>
                    <span class="s1">issubclass(instance.__class__</span><span class="s0">, </span><span class="s1">self)):</span>
                <span class="s0">return True</span>
            <span class="s0">if </span><span class="s1">self._is_protocol:</span>
                <span class="s0">if </span><span class="s1">all(hasattr(instance</span><span class="s0">, </span><span class="s1">attr) </span><span class="s0">and</span>
                        <span class="s1">(</span><span class="s0">not </span><span class="s1">callable(getattr(self</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, None</span><span class="s1">)) </span><span class="s0">or</span>
                         <span class="s1">getattr(instance</span><span class="s0">, </span><span class="s1">attr) </span><span class="s0">is not None</span><span class="s1">)</span>
                        <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">_get_protocol_attrs(self)):</span>
                    <span class="s0">return True</span>
            <span class="s0">return </span><span class="s1">super(GenericMeta</span><span class="s0">, </span><span class="s1">self).__instancecheck__(instance)</span>

        <span class="s0">def </span><span class="s1">__subclasscheck__(self</span><span class="s0">, </span><span class="s1">cls):</span>
            <span class="s0">if </span><span class="s1">self.__origin__ </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">sys._getframe(</span><span class="s3">1</span><span class="s1">).f_globals[</span><span class="s4">'__name__'</span><span class="s1">] </span><span class="s0">not in </span><span class="s1">[</span><span class="s4">'abc'</span><span class="s0">, </span><span class="s4">'functools'</span><span class="s1">]:</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Parameterized generics cannot be used with class &quot;</span>
                                    <span class="s4">&quot;or instance checks&quot;</span><span class="s1">)</span>
                <span class="s0">return False</span>
            <span class="s0">if </span><span class="s1">(self.__dict__.get(</span><span class="s4">'_is_protocol'</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">and</span>
                    <span class="s0">not </span><span class="s1">self.__dict__.get(</span><span class="s4">'_is_runtime_protocol'</span><span class="s0">, None</span><span class="s1">)):</span>
                <span class="s0">if </span><span class="s1">sys._getframe(</span><span class="s3">1</span><span class="s1">).f_globals[</span><span class="s4">'__name__'</span><span class="s1">] </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'abc'</span><span class="s0">,</span>
                                                              <span class="s4">'functools'</span><span class="s0">,</span>
                                                              <span class="s4">'typing'</span><span class="s1">]:</span>
                    <span class="s0">return False</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Instance and class checks can only be used with&quot;</span>
                                <span class="s4">&quot; @runtime protocols&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">(self.__dict__.get(</span><span class="s4">'_is_runtime_protocol'</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">and</span>
                    <span class="s0">not </span><span class="s1">_is_callable_members_only(self)):</span>
                <span class="s0">if </span><span class="s1">sys._getframe(</span><span class="s3">1</span><span class="s1">).f_globals[</span><span class="s4">'__name__'</span><span class="s1">] </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'abc'</span><span class="s0">,</span>
                                                              <span class="s4">'functools'</span><span class="s0">,</span>
                                                              <span class="s4">'typing'</span><span class="s1">]:</span>
                    <span class="s0">return </span><span class="s1">super(GenericMeta</span><span class="s0">, </span><span class="s1">self).__subclasscheck__(cls)</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Protocols with non-method members&quot;</span>
                                <span class="s4">&quot; don't support issubclass()&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">super(GenericMeta</span><span class="s0">, </span><span class="s1">self).__subclasscheck__(cls)</span>

        <span class="s1">@typing._tp_cache</span>
        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">params):</span>
            <span class="s2"># We also need to copy this from GenericMeta.__getitem__ to get</span>
            <span class="s2"># special treatment of &quot;Protocol&quot;. (Comments removed for brevity.)</span>
            <span class="s0">if not </span><span class="s1">isinstance(params</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">params = (params</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s0">if not </span><span class="s1">params </span><span class="s0">and </span><span class="s1">_gorg(self) </span><span class="s0">is not </span><span class="s1">typing.Tuple:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">f&quot;Parameter list to </span><span class="s0">{</span><span class="s1">self.__qualname__</span><span class="s0">}</span><span class="s4">[...] cannot be empty&quot;</span><span class="s1">)</span>
            <span class="s1">msg = </span><span class="s4">&quot;Parameters to generic types must be types.&quot;</span>
            <span class="s1">params = tuple(_type_check(p</span><span class="s0">, </span><span class="s1">msg) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">params)</span>
            <span class="s0">if </span><span class="s1">self </span><span class="s0">in </span><span class="s1">(typing.Generic</span><span class="s0">, </span><span class="s1">Protocol):</span>
                <span class="s0">if not </span><span class="s1">all(isinstance(p</span><span class="s0">, </span><span class="s1">typing.TypeVar) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">params):</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span>
                        <span class="s4">f&quot;Parameters to </span><span class="s0">{</span><span class="s1">repr(self)</span><span class="s0">}</span><span class="s4">[...] must all be type variables&quot;</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">len(set(params)) != len(params):</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span>
                        <span class="s4">f&quot;Parameters to </span><span class="s0">{</span><span class="s1">repr(self)</span><span class="s0">}</span><span class="s4">[...] must all be unique&quot;</span><span class="s1">)</span>
                <span class="s1">tvars = params</span>
                <span class="s1">args = params</span>
            <span class="s0">elif </span><span class="s1">self </span><span class="s0">in </span><span class="s1">(typing.Tuple</span><span class="s0">, </span><span class="s1">typing.Callable):</span>
                <span class="s1">tvars = _type_vars(params)</span>
                <span class="s1">args = params</span>
            <span class="s0">elif </span><span class="s1">self.__origin__ </span><span class="s0">in </span><span class="s1">(typing.Generic</span><span class="s0">, </span><span class="s1">Protocol):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;Cannot subscript already-subscripted </span><span class="s0">{</span><span class="s1">repr(self)</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">_check_generic(self</span><span class="s0">, </span><span class="s1">params)</span>
                <span class="s1">tvars = _type_vars(params)</span>
                <span class="s1">args = params</span>

            <span class="s1">prepend = (self</span><span class="s0">,</span><span class="s1">) </span><span class="s0">if </span><span class="s1">self.__origin__ </span><span class="s0">is None else </span><span class="s1">()</span>
            <span class="s0">return </span><span class="s1">self.__class__(self.__name__</span><span class="s0">,</span>
                                  <span class="s1">prepend + self.__bases__</span><span class="s0">,</span>
                                  <span class="s1">_no_slots_copy(self.__dict__)</span><span class="s0">,</span>
                                  <span class="s1">tvars=tvars</span><span class="s0">,</span>
                                  <span class="s1">args=args</span><span class="s0">,</span>
                                  <span class="s1">origin=self</span><span class="s0">,</span>
                                  <span class="s1">extra=self.__extra__</span><span class="s0">,</span>
                                  <span class="s1">orig_bases=self.__orig_bases__)</span>

    <span class="s0">class </span><span class="s1">Protocol(metaclass=_ProtocolMeta):</span>
        <span class="s5">&quot;&quot;&quot;Base class for protocol classes. Protocol classes are defined as:: 
 
          class Proto(Protocol): 
              def meth(self) -&gt; int: 
                  ... 
 
        Such classes are primarily used with static type checkers that recognize 
        structural subtyping (static duck-typing), for example:: 
 
          class C: 
              def meth(self) -&gt; int: 
                  return 0 
 
          def func(x: Proto) -&gt; int: 
              return x.meth() 
 
          func(C())  # Passes static type check 
 
        See PEP 544 for details. Protocol classes decorated with 
        @typing_extensions.runtime act as simple-minded runtime protocol that checks 
        only the presence of given attributes, ignoring their type signatures. 
 
        Protocol classes can be generic, they are defined as:: 
 
          class GenProto(Protocol[T]): 
              def meth(self) -&gt; T: 
                  ... 
        &quot;&quot;&quot;</span>
        <span class="s1">__slots__ = ()</span>
        <span class="s1">_is_protocol = </span><span class="s0">True</span>

        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds):</span>
            <span class="s0">if </span><span class="s1">_gorg(cls) </span><span class="s0">is </span><span class="s1">Protocol:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Type Protocol cannot be instantiated; &quot;</span>
                                <span class="s4">&quot;it can be used only as a base class&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">typing._generic_new(cls.__next_in_mro__</span><span class="s0">, </span><span class="s1">cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds)</span>


<span class="s2"># 3.8+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'runtime_checkable'</span><span class="s1">):</span>
    <span class="s1">runtime_checkable = typing.runtime_checkable</span>
<span class="s2"># 3.6-3.7</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">runtime_checkable(cls):</span>
        <span class="s5">&quot;&quot;&quot;Mark a protocol class as a runtime protocol, so that it 
        can be used with isinstance() and issubclass(). Raise TypeError 
        if applied to a non-protocol class. 
 
        This allows a simple-minded structural check very similar to the 
        one-offs in collections.abc such as Hashable. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(cls</span><span class="s0">, </span><span class="s1">_ProtocolMeta) </span><span class="s0">or not </span><span class="s1">cls._is_protocol:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'@runtime_checkable can be only applied to protocol classes,'</span>
                            <span class="s4">f' got </span><span class="s0">{</span><span class="s1">cls</span><span class="s0">!r}</span><span class="s4">'</span><span class="s1">)</span>
        <span class="s1">cls._is_runtime_protocol = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">cls</span>


<span class="s2"># Exists for backwards compatibility.</span>
<span class="s1">runtime = runtime_checkable</span>


<span class="s2"># 3.8+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'SupportsIndex'</span><span class="s1">):</span>
    <span class="s1">SupportsIndex = typing.SupportsIndex</span>
<span class="s2"># 3.6-3.7</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">@runtime_checkable</span>
    <span class="s0">class </span><span class="s1">SupportsIndex(Protocol):</span>
        <span class="s1">__slots__ = ()</span>

        <span class="s1">@abc.abstractmethod</span>
        <span class="s0">def </span><span class="s1">__index__(self) -&gt; int:</span>
            <span class="s0">pass</span>


<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">2</span><span class="s1">):</span>
    <span class="s2"># The standard library TypedDict in Python 3.8 does not store runtime information</span>
    <span class="s2"># about which (if any) keys are optional.  See https://bugs.python.org/issue38834</span>
    <span class="s2"># The standard library TypedDict in Python 3.9.0/1 does not honour the &quot;total&quot;</span>
    <span class="s2"># keyword with old-style TypedDict().  See https://bugs.python.org/issue42059</span>
    <span class="s1">TypedDict = typing.TypedDict</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">_check_fails(cls</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">sys._getframe(</span><span class="s3">1</span><span class="s1">).f_globals[</span><span class="s4">'__name__'</span><span class="s1">] </span><span class="s0">not in </span><span class="s1">[</span><span class="s4">'abc'</span><span class="s0">,</span>
                                                              <span class="s4">'functools'</span><span class="s0">,</span>
                                                              <span class="s4">'typing'</span><span class="s1">]:</span>
                <span class="s2"># Typed dicts are only for static structural subtyping.</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'TypedDict does not support instance and class checks'</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
            <span class="s0">pass</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">_dict_new(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">if not </span><span class="s1">args:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'TypedDict.__new__(): not enough arguments'</span><span class="s1">)</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">args = args[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s3">1</span><span class="s1">:]  </span><span class="s2"># allow the &quot;cls&quot; keyword be passed</span>
        <span class="s0">return </span><span class="s1">dict(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s1">_dict_new.__text_signature__ = </span><span class="s4">'($cls, _typename, _fields=None, /, **kwargs)'</span>

    <span class="s0">def </span><span class="s1">_typeddict_new(*args</span><span class="s0">, </span><span class="s1">total=</span><span class="s0">True, </span><span class="s1">**kwargs):</span>
        <span class="s0">if not </span><span class="s1">args:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'TypedDict.__new__(): not enough arguments'</span><span class="s1">)</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">args = args[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s3">1</span><span class="s1">:]  </span><span class="s2"># allow the &quot;cls&quot; keyword be passed</span>
        <span class="s0">if </span><span class="s1">args:</span>
            <span class="s1">typename</span><span class="s0">, </span><span class="s1">args = args[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s3">1</span><span class="s1">:]  </span><span class="s2"># allow the &quot;_typename&quot; keyword be passed</span>
        <span class="s0">elif </span><span class="s4">'_typename' </span><span class="s0">in </span><span class="s1">kwargs:</span>
            <span class="s1">typename = kwargs.pop(</span><span class="s4">'_typename'</span><span class="s1">)</span>
            <span class="s0">import </span><span class="s1">warnings</span>
            <span class="s1">warnings.warn(</span><span class="s4">&quot;Passing '_typename' as keyword argument is deprecated&quot;</span><span class="s0">,</span>
                          <span class="s1">DeprecationWarning</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;TypedDict.__new__() missing 1 required positional &quot;</span>
                            <span class="s4">&quot;argument: '_typename'&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">args:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">fields</span><span class="s0">, </span><span class="s1">= args  </span><span class="s2"># allow the &quot;_fields&quot; keyword be passed</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'TypedDict.__new__() takes from 2 to 3 '</span>
                                <span class="s4">f'positional arguments but </span><span class="s0">{</span><span class="s1">len(args) + </span><span class="s3">2</span><span class="s0">} </span><span class="s4">'</span>
                                <span class="s4">'were given'</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s4">'_fields' </span><span class="s0">in </span><span class="s1">kwargs </span><span class="s0">and </span><span class="s1">len(kwargs) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">fields = kwargs.pop(</span><span class="s4">'_fields'</span><span class="s1">)</span>
            <span class="s0">import </span><span class="s1">warnings</span>
            <span class="s1">warnings.warn(</span><span class="s4">&quot;Passing '_fields' as keyword argument is deprecated&quot;</span><span class="s0">,</span>
                          <span class="s1">DeprecationWarning</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">fields = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">fields </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">fields = kwargs</span>
        <span class="s0">elif </span><span class="s1">kwargs:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;TypedDict takes either a dict or keyword arguments,&quot;</span>
                            <span class="s4">&quot; but not both&quot;</span><span class="s1">)</span>

        <span class="s1">ns = {</span><span class="s4">'__annotations__'</span><span class="s1">: dict(fields)}</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s2"># Setting correct module is necessary to make typed dict classes pickleable.</span>
            <span class="s1">ns[</span><span class="s4">'__module__'</span><span class="s1">] = sys._getframe(</span><span class="s3">1</span><span class="s1">).f_globals.get(</span><span class="s4">'__name__'</span><span class="s0">, </span><span class="s4">'__main__'</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
            <span class="s0">pass</span>

        <span class="s0">return </span><span class="s1">_TypedDictMeta(typename</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">ns</span><span class="s0">, </span><span class="s1">total=total)</span>

    <span class="s1">_typeddict_new.__text_signature__ = (</span><span class="s4">'($cls, _typename, _fields=None,'</span>
                                         <span class="s4">' /, *, total=True, **kwargs)'</span><span class="s1">)</span>

    <span class="s0">class </span><span class="s1">_TypedDictMeta(type):</span>
        <span class="s0">def </span><span class="s1">__init__(cls</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">bases</span><span class="s0">, </span><span class="s1">ns</span><span class="s0">, </span><span class="s1">total=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s1">super().__init__(name</span><span class="s0">, </span><span class="s1">bases</span><span class="s0">, </span><span class="s1">ns)</span>

        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">bases</span><span class="s0">, </span><span class="s1">ns</span><span class="s0">, </span><span class="s1">total=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s2"># Create new typed dict class object.</span>
            <span class="s2"># This method is called directly when TypedDict is subclassed,</span>
            <span class="s2"># or via _typeddict_new when TypedDict is instantiated. This way</span>
            <span class="s2"># TypedDict supports all three syntaxes described in its docstring.</span>
            <span class="s2"># Subclasses and instances of TypedDict return actual dictionaries</span>
            <span class="s2"># via _dict_new.</span>
            <span class="s1">ns[</span><span class="s4">'__new__'</span><span class="s1">] = _typeddict_new </span><span class="s0">if </span><span class="s1">name == </span><span class="s4">'TypedDict' </span><span class="s0">else </span><span class="s1">_dict_new</span>
            <span class="s1">tp_dict = super().__new__(cls</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">(dict</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ns)</span>

            <span class="s1">annotations = {}</span>
            <span class="s1">own_annotations = ns.get(</span><span class="s4">'__annotations__'</span><span class="s0">, </span><span class="s1">{})</span>
            <span class="s1">own_annotation_keys = set(own_annotations.keys())</span>
            <span class="s1">msg = </span><span class="s4">&quot;TypedDict('Name', {f0: t0, f1: t1, ...}); each t must be a type&quot;</span>
            <span class="s1">own_annotations = {</span>
                <span class="s1">n: typing._type_check(tp</span><span class="s0">, </span><span class="s1">msg) </span><span class="s0">for </span><span class="s1">n</span><span class="s0">, </span><span class="s1">tp </span><span class="s0">in </span><span class="s1">own_annotations.items()</span>
            <span class="s1">}</span>
            <span class="s1">required_keys = set()</span>
            <span class="s1">optional_keys = set()</span>

            <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">bases:</span>
                <span class="s1">annotations.update(base.__dict__.get(</span><span class="s4">'__annotations__'</span><span class="s0">, </span><span class="s1">{}))</span>
                <span class="s1">required_keys.update(base.__dict__.get(</span><span class="s4">'__required_keys__'</span><span class="s0">, </span><span class="s1">()))</span>
                <span class="s1">optional_keys.update(base.__dict__.get(</span><span class="s4">'__optional_keys__'</span><span class="s0">, </span><span class="s1">()))</span>

            <span class="s1">annotations.update(own_annotations)</span>
            <span class="s0">if </span><span class="s1">total:</span>
                <span class="s1">required_keys.update(own_annotation_keys)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">optional_keys.update(own_annotation_keys)</span>

            <span class="s1">tp_dict.__annotations__ = annotations</span>
            <span class="s1">tp_dict.__required_keys__ = frozenset(required_keys)</span>
            <span class="s1">tp_dict.__optional_keys__ = frozenset(optional_keys)</span>
            <span class="s0">if not </span><span class="s1">hasattr(tp_dict</span><span class="s0">, </span><span class="s4">'__total__'</span><span class="s1">):</span>
                <span class="s1">tp_dict.__total__ = total</span>
            <span class="s0">return </span><span class="s1">tp_dict</span>

        <span class="s1">__instancecheck__ = __subclasscheck__ = _check_fails</span>

    <span class="s1">TypedDict = _TypedDictMeta(</span><span class="s4">'TypedDict'</span><span class="s0">, </span><span class="s1">(dict</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{})</span>
    <span class="s1">TypedDict.__module__ = __name__</span>
    <span class="s1">TypedDict.__doc__ = \</span>
        <span class="s4">&quot;&quot;&quot;A simple typed name space. At runtime it is equivalent to a plain dict. 
 
        TypedDict creates a dictionary type that expects all of its 
        instances to have a certain set of keys, with each key 
        associated with a value of a consistent type. This expectation 
        is not checked at runtime but is only enforced by type checkers. 
        Usage:: 
 
            class Point2D(TypedDict): 
                x: int 
                y: int 
                label: str 
 
            a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK 
            b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check 
 
            assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first') 
 
        The type info can be accessed via the Point2D.__annotations__ dict, and 
        the Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets. 
        TypedDict supports two additional equivalent forms:: 
 
            Point2D = TypedDict('Point2D', x=int, y=int, label=str) 
            Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str}) 
 
        The class syntax is only supported in Python 3.6+, while two other 
        syntax forms work for Python 2.7 and 3.2+ 
        &quot;&quot;&quot;</span>


<span class="s2"># Python 3.9+ has PEP 593 (Annotated and modified get_type_hints)</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'Annotated'</span><span class="s1">):</span>
    <span class="s1">Annotated = typing.Annotated</span>
    <span class="s1">get_type_hints = typing.get_type_hints</span>
    <span class="s2"># Not exported and not a public API, but needed for get_origin() and get_args()</span>
    <span class="s2"># to work.</span>
    <span class="s1">_AnnotatedAlias = typing._AnnotatedAlias</span>
<span class="s2"># 3.7-3.8</span>
<span class="s0">elif </span><span class="s1">PEP_560:</span>
    <span class="s0">class </span><span class="s1">_AnnotatedAlias(typing._GenericAlias</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Runtime representation of an annotated type. 
 
        At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't' 
        with extra annotations. The alias behaves like a normal typing alias, 
        instantiating is the same as instantiating the underlying type, binding 
        it to types is also the same. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">origin</span><span class="s0">, </span><span class="s1">metadata):</span>
            <span class="s0">if </span><span class="s1">isinstance(origin</span><span class="s0">, </span><span class="s1">_AnnotatedAlias):</span>
                <span class="s1">metadata = origin.__metadata__ + metadata</span>
                <span class="s1">origin = origin.__origin__</span>
            <span class="s1">super().__init__(origin</span><span class="s0">, </span><span class="s1">origin)</span>
            <span class="s1">self.__metadata__ = metadata</span>

        <span class="s0">def </span><span class="s1">copy_with(self</span><span class="s0">, </span><span class="s1">params):</span>
            <span class="s0">assert </span><span class="s1">len(params) == </span><span class="s3">1</span>
            <span class="s1">new_type = params[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s0">return </span><span class="s1">_AnnotatedAlias(new_type</span><span class="s0">, </span><span class="s1">self.__metadata__)</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s1">(</span><span class="s4">f&quot;typing_extensions.Annotated[</span><span class="s0">{</span><span class="s1">typing._type_repr(self.__origin__)</span><span class="s0">}</span><span class="s4">, &quot;</span>
                    <span class="s4">f&quot;</span><span class="s0">{</span><span class="s4">', '</span><span class="s1">.join(repr(a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">self.__metadata__)</span><span class="s0">}</span><span class="s4">]&quot;</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__reduce__(self):</span>
            <span class="s0">return </span><span class="s1">operator.getitem</span><span class="s0">, </span><span class="s1">(</span>
                <span class="s1">Annotated</span><span class="s0">, </span><span class="s1">(self.__origin__</span><span class="s0">,</span><span class="s1">) + self.__metadata__</span>
            <span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">_AnnotatedAlias):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
            <span class="s0">if </span><span class="s1">self.__origin__ != other.__origin__:</span>
                <span class="s0">return False</span>
            <span class="s0">return </span><span class="s1">self.__metadata__ == other.__metadata__</span>

        <span class="s0">def </span><span class="s1">__hash__(self):</span>
            <span class="s0">return </span><span class="s1">hash((self.__origin__</span><span class="s0">, </span><span class="s1">self.__metadata__))</span>

    <span class="s0">class </span><span class="s1">Annotated:</span>
        <span class="s5">&quot;&quot;&quot;Add context specific metadata to a type. 
 
        Example: Annotated[int, runtime_check.Unsigned] indicates to the 
        hypothetical runtime_check module that this type is an unsigned int. 
        Every other consumer of this type can ignore this metadata and treat 
        this type as int. 
 
        The first argument to Annotated must be a valid type (and will be in 
        the __origin__ field), the remaining arguments are kept as a tuple in 
        the __extra__ field. 
 
        Details: 
 
        - It's an error to call `Annotated` with less than two arguments. 
        - Nested Annotated are flattened:: 
 
            Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3] 
 
        - Instantiating an annotated type is equivalent to instantiating the 
        underlying type:: 
 
            Annotated[C, Ann1](5) == C(5) 
 
        - Annotated can be used as a generic type alias:: 
 
            Optimized = Annotated[T, runtime.Optimize()] 
            Optimized[int] == Annotated[int, runtime.Optimize()] 
 
            OptimizedList = Annotated[List[T], runtime.Optimize()] 
            OptimizedList[int] == Annotated[List[int], runtime.Optimize()] 
        &quot;&quot;&quot;</span>

        <span class="s1">__slots__ = ()</span>

        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Type Annotated cannot be instantiated.&quot;</span><span class="s1">)</span>

        <span class="s1">@typing._tp_cache</span>
        <span class="s0">def </span><span class="s1">__class_getitem__(cls</span><span class="s0">, </span><span class="s1">params):</span>
            <span class="s0">if not </span><span class="s1">isinstance(params</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">or </span><span class="s1">len(params) &lt; </span><span class="s3">2</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Annotated[...] should be used &quot;</span>
                                <span class="s4">&quot;with at least two arguments (a type and an &quot;</span>
                                <span class="s4">&quot;annotation).&quot;</span><span class="s1">)</span>
            <span class="s1">msg = </span><span class="s4">&quot;Annotated[t, ...]: t must be a type.&quot;</span>
            <span class="s1">origin = typing._type_check(params[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">metadata = tuple(params[</span><span class="s3">1</span><span class="s1">:])</span>
            <span class="s0">return </span><span class="s1">_AnnotatedAlias(origin</span><span class="s0">, </span><span class="s1">metadata)</span>

        <span class="s0">def </span><span class="s1">__init_subclass__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s4">f&quot;Cannot subclass </span><span class="s0">{</span><span class="s1">cls.__module__</span><span class="s0">}</span><span class="s4">.Annotated&quot;</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_strip_annotations(t):</span>
        <span class="s5">&quot;&quot;&quot;Strips the annotations from a given type. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(t</span><span class="s0">, </span><span class="s1">_AnnotatedAlias):</span>
            <span class="s0">return </span><span class="s1">_strip_annotations(t.__origin__)</span>
        <span class="s0">if </span><span class="s1">isinstance(t</span><span class="s0">, </span><span class="s1">typing._GenericAlias):</span>
            <span class="s1">stripped_args = tuple(_strip_annotations(a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">t.__args__)</span>
            <span class="s0">if </span><span class="s1">stripped_args == t.__args__:</span>
                <span class="s0">return </span><span class="s1">t</span>
            <span class="s1">res = t.copy_with(stripped_args)</span>
            <span class="s1">res._special = t._special</span>
            <span class="s0">return </span><span class="s1">res</span>
        <span class="s0">return </span><span class="s1">t</span>

    <span class="s0">def </span><span class="s1">get_type_hints(obj</span><span class="s0">, </span><span class="s1">globalns=</span><span class="s0">None, </span><span class="s1">localns=</span><span class="s0">None, </span><span class="s1">include_extras=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Return type hints for an object. 
 
        This is often the same as obj.__annotations__, but it handles 
        forward references encoded as string literals, adds Optional[t] if a 
        default value equal to None is set and recursively replaces all 
        'Annotated[T, ...]' with 'T' (unless 'include_extras=True'). 
 
        The argument may be a module, class, method, or function. The annotations 
        are returned as a dictionary. For classes, annotations include also 
        inherited members. 
 
        TypeError is raised if the argument is not of a type that can contain 
        annotations, and an empty dictionary is returned if no annotations are 
        present. 
 
        BEWARE -- the behavior of globalns and localns is counterintuitive 
        (unless you are familiar with how eval() and exec() work).  The 
        search order is locals first, then globals. 
 
        - If no dict arguments are passed, an attempt is made to use the 
          globals from obj (or the respective module's globals for classes), 
          and these are also used as the locals.  If the object does not appear 
          to have globals, an empty dictionary is used. 
 
        - If one dict argument is passed, it is used for both globals and 
          locals. 
 
        - If two dict arguments are passed, they specify globals and 
          locals, respectively. 
        &quot;&quot;&quot;</span>
        <span class="s1">hint = typing.get_type_hints(obj</span><span class="s0">, </span><span class="s1">globalns=globalns</span><span class="s0">, </span><span class="s1">localns=localns)</span>
        <span class="s0">if </span><span class="s1">include_extras:</span>
            <span class="s0">return </span><span class="s1">hint</span>
        <span class="s0">return </span><span class="s1">{k: _strip_annotations(t) </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">hint.items()}</span>
<span class="s2"># 3.6</span>
<span class="s0">else</span><span class="s1">:</span>

    <span class="s0">def </span><span class="s1">_is_dunder(name):</span>
        <span class="s5">&quot;&quot;&quot;Returns True if name is a __dunder_variable_name__.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">len(name) &gt; </span><span class="s3">4 </span><span class="s0">and </span><span class="s1">name.startswith(</span><span class="s4">'__'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">name.endswith(</span><span class="s4">'__'</span><span class="s1">)</span>

    <span class="s2"># Prior to Python 3.7 types did not have `copy_with`. A lot of the equality</span>
    <span class="s2"># checks, argument expansion etc. are done on the _subs_tre. As a result we</span>
    <span class="s2"># can't provide a get_type_hints function that strips out annotations.</span>

    <span class="s0">class </span><span class="s1">AnnotatedMeta(typing.GenericMeta):</span>
        <span class="s5">&quot;&quot;&quot;Metaclass for Annotated&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">bases</span><span class="s0">, </span><span class="s1">namespace</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">if </span><span class="s1">any(b </span><span class="s0">is not </span><span class="s1">object </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">bases):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot subclass &quot; </span><span class="s1">+ str(Annotated))</span>
            <span class="s0">return </span><span class="s1">super().__new__(cls</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">bases</span><span class="s0">, </span><span class="s1">namespace</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s1">@property</span>
        <span class="s0">def </span><span class="s1">__metadata__(self):</span>
            <span class="s0">return </span><span class="s1">self._subs_tree()[</span><span class="s3">2</span><span class="s1">]</span>

        <span class="s0">def </span><span class="s1">_tree_repr(self</span><span class="s0">, </span><span class="s1">tree):</span>
            <span class="s1">cls</span><span class="s0">, </span><span class="s1">origin</span><span class="s0">, </span><span class="s1">metadata = tree</span>
            <span class="s0">if not </span><span class="s1">isinstance(origin</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">tp_repr = typing._type_repr(origin)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">tp_repr = origin[</span><span class="s3">0</span><span class="s1">]._tree_repr(origin)</span>
            <span class="s1">metadata_reprs = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(repr(arg) </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">metadata)</span>
            <span class="s0">return </span><span class="s4">f'</span><span class="s0">{</span><span class="s1">cls</span><span class="s0">}</span><span class="s4">[</span><span class="s0">{</span><span class="s1">tp_repr</span><span class="s0">}</span><span class="s4">, </span><span class="s0">{</span><span class="s1">metadata_reprs</span><span class="s0">}</span><span class="s4">]'</span>

        <span class="s0">def </span><span class="s1">_subs_tree(self</span><span class="s0">, </span><span class="s1">tvars=</span><span class="s0">None, </span><span class="s1">args=</span><span class="s0">None</span><span class="s1">):  </span><span class="s2"># noqa</span>
            <span class="s0">if </span><span class="s1">self </span><span class="s0">is </span><span class="s1">Annotated:</span>
                <span class="s0">return </span><span class="s1">Annotated</span>
            <span class="s1">res = super()._subs_tree(tvars=tvars</span><span class="s0">, </span><span class="s1">args=args)</span>
            <span class="s2"># Flatten nested Annotated</span>
            <span class="s0">if </span><span class="s1">isinstance(res[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">and </span><span class="s1">res[</span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] </span><span class="s0">is </span><span class="s1">Annotated:</span>
                <span class="s1">sub_tp = res[</span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">]</span>
                <span class="s1">sub_annot = res[</span><span class="s3">1</span><span class="s1">][</span><span class="s3">2</span><span class="s1">]</span>
                <span class="s0">return </span><span class="s1">(Annotated</span><span class="s0">, </span><span class="s1">sub_tp</span><span class="s0">, </span><span class="s1">sub_annot + res[</span><span class="s3">2</span><span class="s1">])</span>
            <span class="s0">return </span><span class="s1">res</span>

        <span class="s0">def </span><span class="s1">_get_cons(self):</span>
            <span class="s5">&quot;&quot;&quot;Return the class used to create instance of this type.&quot;&quot;&quot;</span>
            <span class="s0">if </span><span class="s1">self.__origin__ </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot get the underlying type of a &quot;</span>
                                <span class="s4">&quot;non-specialized Annotated type.&quot;</span><span class="s1">)</span>
            <span class="s1">tree = self._subs_tree()</span>
            <span class="s0">while </span><span class="s1">isinstance(tree</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">and </span><span class="s1">tree[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">is </span><span class="s1">Annotated:</span>
                <span class="s1">tree = tree[</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">isinstance(tree</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s0">return </span><span class="s1">tree[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">tree</span>

        <span class="s1">@typing._tp_cache</span>
        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">params):</span>
            <span class="s0">if not </span><span class="s1">isinstance(params</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">params = (params</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">self.__origin__ </span><span class="s0">is not None</span><span class="s1">:  </span><span class="s2"># specializing an instantiated type</span>
                <span class="s0">return </span><span class="s1">super().__getitem__(params)</span>
            <span class="s0">elif not </span><span class="s1">isinstance(params</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">or </span><span class="s1">len(params) &lt; </span><span class="s3">2</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Annotated[...] should be instantiated &quot;</span>
                                <span class="s4">&quot;with at least two arguments (a type and an &quot;</span>
                                <span class="s4">&quot;annotation).&quot;</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s4">&quot;Annotated[t, ...]: t must be a type.&quot;</span>
                <span class="s1">tp = typing._type_check(params[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">metadata = tuple(params[</span><span class="s3">1</span><span class="s1">:])</span>
            <span class="s0">return </span><span class="s1">self.__class__(</span>
                <span class="s1">self.__name__</span><span class="s0">,</span>
                <span class="s1">self.__bases__</span><span class="s0">,</span>
                <span class="s1">_no_slots_copy(self.__dict__)</span><span class="s0">,</span>
                <span class="s1">tvars=_type_vars((tp</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,</span>
                <span class="s2"># Metadata is a tuple so it won't be touched by _replace_args et al.</span>
                <span class="s1">args=(tp</span><span class="s0">, </span><span class="s1">metadata)</span><span class="s0">,</span>
                <span class="s1">origin=self</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s1">cons = self._get_cons()</span>
            <span class="s1">result = cons(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">result.__orig_class__ = self</span>
            <span class="s0">except </span><span class="s1">AttributeError:</span>
                <span class="s0">pass</span>
            <span class="s0">return </span><span class="s1">result</span>

        <span class="s0">def </span><span class="s1">__getattr__(self</span><span class="s0">, </span><span class="s1">attr):</span>
            <span class="s2"># For simplicity we just don't relay all dunder names</span>
            <span class="s0">if </span><span class="s1">self.__origin__ </span><span class="s0">is not None and not </span><span class="s1">_is_dunder(attr):</span>
                <span class="s0">return </span><span class="s1">getattr(self._get_cons()</span><span class="s0">, </span><span class="s1">attr)</span>
            <span class="s0">raise </span><span class="s1">AttributeError(attr)</span>

        <span class="s0">def </span><span class="s1">__setattr__(self</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, </span><span class="s1">value):</span>
            <span class="s0">if </span><span class="s1">_is_dunder(attr) </span><span class="s0">or </span><span class="s1">attr.startswith(</span><span class="s4">'_abc_'</span><span class="s1">):</span>
                <span class="s1">super().__setattr__(attr</span><span class="s0">, </span><span class="s1">value)</span>
            <span class="s0">elif </span><span class="s1">self.__origin__ </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">AttributeError(attr)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">setattr(self._get_cons()</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, </span><span class="s1">value)</span>

        <span class="s0">def </span><span class="s1">__instancecheck__(self</span><span class="s0">, </span><span class="s1">obj):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Annotated cannot be used with isinstance().&quot;</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__subclasscheck__(self</span><span class="s0">, </span><span class="s1">cls):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Annotated cannot be used with issubclass().&quot;</span><span class="s1">)</span>

    <span class="s0">class </span><span class="s1">Annotated(metaclass=AnnotatedMeta):</span>
        <span class="s5">&quot;&quot;&quot;Add context specific metadata to a type. 
 
        Example: Annotated[int, runtime_check.Unsigned] indicates to the 
        hypothetical runtime_check module that this type is an unsigned int. 
        Every other consumer of this type can ignore this metadata and treat 
        this type as int. 
 
        The first argument to Annotated must be a valid type, the remaining 
        arguments are kept as a tuple in the __metadata__ field. 
 
        Details: 
 
        - It's an error to call `Annotated` with less than two arguments. 
        - Nested Annotated are flattened:: 
 
            Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3] 
 
        - Instantiating an annotated type is equivalent to instantiating the 
        underlying type:: 
 
            Annotated[C, Ann1](5) == C(5) 
 
        - Annotated can be used as a generic type alias:: 
 
            Optimized = Annotated[T, runtime.Optimize()] 
            Optimized[int] == Annotated[int, runtime.Optimize()] 
 
            OptimizedList = Annotated[List[T], runtime.Optimize()] 
            OptimizedList[int] == Annotated[List[int], runtime.Optimize()] 
        &quot;&quot;&quot;</span>

<span class="s2"># Python 3.8 has get_origin() and get_args() but those implementations aren't</span>
<span class="s2"># Annotated-aware, so we can't use those. Python 3.9's versions don't support</span>
<span class="s2"># ParamSpecArgs and ParamSpecKwargs, so only Python 3.10's versions will do.</span>
<span class="s0">if </span><span class="s1">sys.version_info[:</span><span class="s3">2</span><span class="s1">] &gt;= (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">10</span><span class="s1">):</span>
    <span class="s1">get_origin = typing.get_origin</span>
    <span class="s1">get_args = typing.get_args</span>
<span class="s2"># 3.7-3.9</span>
<span class="s0">elif </span><span class="s1">PEP_560:</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s2"># 3.9+</span>
        <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">_BaseGenericAlias</span>
    <span class="s0">except </span><span class="s1">ImportError:</span>
        <span class="s1">_BaseGenericAlias = typing._GenericAlias</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s2"># 3.9+</span>
        <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">GenericAlias</span>
    <span class="s0">except </span><span class="s1">ImportError:</span>
        <span class="s1">GenericAlias = typing._GenericAlias</span>

    <span class="s0">def </span><span class="s1">get_origin(tp):</span>
        <span class="s5">&quot;&quot;&quot;Get the unsubscripted version of a type. 
 
        This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar 
        and Annotated. Return None for unsupported types. Examples:: 
 
            get_origin(Literal[42]) is Literal 
            get_origin(int) is None 
            get_origin(ClassVar[int]) is ClassVar 
            get_origin(Generic) is Generic 
            get_origin(Generic[T]) is Generic 
            get_origin(Union[T, int]) is Union 
            get_origin(List[Tuple[T, T]][int]) == list 
            get_origin(P.args) is P 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(tp</span><span class="s0">, </span><span class="s1">_AnnotatedAlias):</span>
            <span class="s0">return </span><span class="s1">Annotated</span>
        <span class="s0">if </span><span class="s1">isinstance(tp</span><span class="s0">, </span><span class="s1">(typing._GenericAlias</span><span class="s0">, </span><span class="s1">GenericAlias</span><span class="s0">, </span><span class="s1">_BaseGenericAlias</span><span class="s0">,</span>
                           <span class="s1">ParamSpecArgs</span><span class="s0">, </span><span class="s1">ParamSpecKwargs)):</span>
            <span class="s0">return </span><span class="s1">tp.__origin__</span>
        <span class="s0">if </span><span class="s1">tp </span><span class="s0">is </span><span class="s1">typing.Generic:</span>
            <span class="s0">return </span><span class="s1">typing.Generic</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">get_args(tp):</span>
        <span class="s5">&quot;&quot;&quot;Get type arguments with all substitutions performed. 
 
        For unions, basic simplifications used by Union constructor are performed. 
        Examples:: 
            get_args(Dict[str, int]) == (str, int) 
            get_args(int) == () 
            get_args(Union[int, Union[T, int], str][int]) == (int, str) 
            get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int]) 
            get_args(Callable[[], T][int]) == ([], int) 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(tp</span><span class="s0">, </span><span class="s1">_AnnotatedAlias):</span>
            <span class="s0">return </span><span class="s1">(tp.__origin__</span><span class="s0">,</span><span class="s1">) + tp.__metadata__</span>
        <span class="s0">if </span><span class="s1">isinstance(tp</span><span class="s0">, </span><span class="s1">(typing._GenericAlias</span><span class="s0">, </span><span class="s1">GenericAlias)):</span>
            <span class="s0">if </span><span class="s1">getattr(tp</span><span class="s0">, </span><span class="s4">&quot;_special&quot;</span><span class="s0">, False</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s1">()</span>
            <span class="s1">res = tp.__args__</span>
            <span class="s0">if </span><span class="s1">get_origin(tp) </span><span class="s0">is </span><span class="s1">collections.abc.Callable </span><span class="s0">and </span><span class="s1">res[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">is not </span><span class="s1">Ellipsis:</span>
                <span class="s1">res = (list(res[:-</span><span class="s3">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">res[-</span><span class="s3">1</span><span class="s1">])</span>
            <span class="s0">return </span><span class="s1">res</span>
        <span class="s0">return </span><span class="s1">()</span>


<span class="s2"># 3.10+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'TypeAlias'</span><span class="s1">):</span>
    <span class="s1">TypeAlias = typing.TypeAlias</span>
<span class="s2"># 3.9</span>
<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s3">2</span><span class="s1">] &gt;= (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">9</span><span class="s1">):</span>
    <span class="s0">class </span><span class="s1">_TypeAliasForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s4">'typing_extensions.' </span><span class="s1">+ self._name</span>

    <span class="s1">@_TypeAliasForm</span>
    <span class="s0">def </span><span class="s1">TypeAlias(self</span><span class="s0">, </span><span class="s1">parameters):</span>
        <span class="s5">&quot;&quot;&quot;Special marker indicating that an assignment should 
        be recognized as a proper type alias definition by type 
        checkers. 
 
        For example:: 
 
            Predicate: TypeAlias = Callable[..., bool] 
 
        It's invalid when used anywhere except as in the example above. 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">is not subscriptable&quot;</span><span class="s1">)</span>
<span class="s2"># 3.7-3.8</span>
<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s3">2</span><span class="s1">] &gt;= (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">7</span><span class="s1">):</span>
    <span class="s0">class </span><span class="s1">_TypeAliasForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s4">'typing_extensions.' </span><span class="s1">+ self._name</span>

    <span class="s1">TypeAlias = _TypeAliasForm(</span><span class="s4">'TypeAlias'</span><span class="s0">,</span>
                               <span class="s1">doc=</span><span class="s4">&quot;&quot;&quot;Special marker indicating that an assignment should 
                               be recognized as a proper type alias definition by type 
                               checkers. 
 
                               For example:: 
 
                                   Predicate: TypeAlias = Callable[..., bool] 
 
                               It's invalid when used anywhere except as in the example 
                               above.&quot;&quot;&quot;</span><span class="s1">)</span>
<span class="s2"># 3.6</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_TypeAliasMeta(typing.TypingMeta):</span>
        <span class="s5">&quot;&quot;&quot;Metaclass for TypeAlias&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s4">'typing_extensions.TypeAlias'</span>

    <span class="s0">class </span><span class="s1">_TypeAliasBase(typing._FinalTypingBase</span><span class="s0">, </span><span class="s1">metaclass=_TypeAliasMeta</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Special marker indicating that an assignment should 
        be recognized as a proper type alias definition by type 
        checkers. 
 
        For example:: 
 
            Predicate: TypeAlias = Callable[..., bool] 
 
        It's invalid when used anywhere except as in the example above. 
        &quot;&quot;&quot;</span>
        <span class="s1">__slots__ = ()</span>

        <span class="s0">def </span><span class="s1">__instancecheck__(self</span><span class="s0">, </span><span class="s1">obj):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;TypeAlias cannot be used with isinstance().&quot;</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__subclasscheck__(self</span><span class="s0">, </span><span class="s1">cls):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;TypeAlias cannot be used with issubclass().&quot;</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s4">'typing_extensions.TypeAlias'</span>

    <span class="s1">TypeAlias = _TypeAliasBase(_root=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s2"># Python 3.10+ has PEP 612</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'ParamSpecArgs'</span><span class="s1">):</span>
    <span class="s1">ParamSpecArgs = typing.ParamSpecArgs</span>
    <span class="s1">ParamSpecKwargs = typing.ParamSpecKwargs</span>
<span class="s2"># 3.6-3.9</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_Immutable:</span>
        <span class="s5">&quot;&quot;&quot;Mixin to indicate that object should not be copied.&quot;&quot;&quot;</span>
        <span class="s1">__slots__ = ()</span>

        <span class="s0">def </span><span class="s1">__copy__(self):</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s0">def </span><span class="s1">__deepcopy__(self</span><span class="s0">, </span><span class="s1">memo):</span>
            <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">class </span><span class="s1">ParamSpecArgs(_Immutable):</span>
        <span class="s5">&quot;&quot;&quot;The args for a ParamSpec object. 
 
        Given a ParamSpec object P, P.args is an instance of ParamSpecArgs. 
 
        ParamSpecArgs objects have a reference back to their ParamSpec: 
 
        P.args.__origin__ is P 
 
        This type is meant for runtime introspection and has no special meaning to 
        static type checkers. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">origin):</span>
            <span class="s1">self.__origin__ = origin</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self.__origin__.__name__</span><span class="s0">}</span><span class="s4">.args&quot;</span>

    <span class="s0">class </span><span class="s1">ParamSpecKwargs(_Immutable):</span>
        <span class="s5">&quot;&quot;&quot;The kwargs for a ParamSpec object. 
 
        Given a ParamSpec object P, P.kwargs is an instance of ParamSpecKwargs. 
 
        ParamSpecKwargs objects have a reference back to their ParamSpec: 
 
        P.kwargs.__origin__ is P 
 
        This type is meant for runtime introspection and has no special meaning to 
        static type checkers. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">origin):</span>
            <span class="s1">self.__origin__ = origin</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self.__origin__.__name__</span><span class="s0">}</span><span class="s4">.kwargs&quot;</span>

<span class="s2"># 3.10+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'ParamSpec'</span><span class="s1">):</span>
    <span class="s1">ParamSpec = typing.ParamSpec</span>
<span class="s2"># 3.6-3.9</span>
<span class="s0">else</span><span class="s1">:</span>

    <span class="s2"># Inherits from list as a workaround for Callable checks in Python &lt; 3.9.2.</span>
    <span class="s0">class </span><span class="s1">ParamSpec(list):</span>
        <span class="s5">&quot;&quot;&quot;Parameter specification variable. 
 
        Usage:: 
 
           P = ParamSpec('P') 
 
        Parameter specification variables exist primarily for the benefit of static 
        type checkers.  They are used to forward the parameter types of one 
        callable to another callable, a pattern commonly found in higher order 
        functions and decorators.  They are only valid when used in ``Concatenate``, 
        or s the first argument to ``Callable``. In Python 3.10 and higher, 
        they are also supported in user-defined Generics at runtime. 
        See class Generic for more information on generic types.  An 
        example for annotating a decorator:: 
 
           T = TypeVar('T') 
           P = ParamSpec('P') 
 
           def add_logging(f: Callable[P, T]) -&gt; Callable[P, T]: 
               '''A type-safe decorator to add logging to a function.''' 
               def inner(*args: P.args, **kwargs: P.kwargs) -&gt; T: 
                   logging.info(f'{f.__name__} was called') 
                   return f(*args, **kwargs) 
               return inner 
 
           @add_logging 
           def add_two(x: float, y: float) -&gt; float: 
               '''Add two numbers together.''' 
               return x + y 
 
        Parameter specification variables defined with covariant=True or 
        contravariant=True can be used to declare covariant or contravariant 
        generic types.  These keyword arguments are valid, but their actual semantics 
        are yet to be decided.  See PEP 612 for details. 
 
        Parameter specification variables can be introspected. e.g.: 
 
           P.__name__ == 'T' 
           P.__bound__ == None 
           P.__covariant__ == False 
           P.__contravariant__ == False 
 
        Note that only parameter specification variables defined in global scope can 
        be pickled. 
        &quot;&quot;&quot;</span>

        <span class="s2"># Trick Generic __parameters__.</span>
        <span class="s1">__class__ = typing.TypeVar</span>

        <span class="s1">@property</span>
        <span class="s0">def </span><span class="s1">args(self):</span>
            <span class="s0">return </span><span class="s1">ParamSpecArgs(self)</span>

        <span class="s1">@property</span>
        <span class="s0">def </span><span class="s1">kwargs(self):</span>
            <span class="s0">return </span><span class="s1">ParamSpecKwargs(self)</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">bound=</span><span class="s0">None, </span><span class="s1">covariant=</span><span class="s0">False, </span><span class="s1">contravariant=</span><span class="s0">False</span><span class="s1">):</span>
            <span class="s1">super().__init__([self])</span>
            <span class="s1">self.__name__ = name</span>
            <span class="s1">self.__covariant__ = bool(covariant)</span>
            <span class="s1">self.__contravariant__ = bool(contravariant)</span>
            <span class="s0">if </span><span class="s1">bound:</span>
                <span class="s1">self.__bound__ = typing._type_check(bound</span><span class="s0">, </span><span class="s4">'Bound must be a type.'</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.__bound__ = </span><span class="s0">None</span>

            <span class="s2"># for pickling:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">def_mod = sys._getframe(</span><span class="s3">1</span><span class="s1">).f_globals.get(</span><span class="s4">'__name__'</span><span class="s0">, </span><span class="s4">'__main__'</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
                <span class="s1">def_mod = </span><span class="s0">None</span>
            <span class="s0">if </span><span class="s1">def_mod != </span><span class="s4">'typing_extensions'</span><span class="s1">:</span>
                <span class="s1">self.__module__ = def_mod</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">if </span><span class="s1">self.__covariant__:</span>
                <span class="s1">prefix = </span><span class="s4">'+'</span>
            <span class="s0">elif </span><span class="s1">self.__contravariant__:</span>
                <span class="s1">prefix = </span><span class="s4">'-'</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">prefix = </span><span class="s4">'~'</span>
            <span class="s0">return </span><span class="s1">prefix + self.__name__</span>

        <span class="s0">def </span><span class="s1">__hash__(self):</span>
            <span class="s0">return </span><span class="s1">object.__hash__(self)</span>

        <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">return </span><span class="s1">self </span><span class="s0">is </span><span class="s1">other</span>

        <span class="s0">def </span><span class="s1">__reduce__(self):</span>
            <span class="s0">return </span><span class="s1">self.__name__</span>

        <span class="s2"># Hack to get typing._type_check to pass.</span>
        <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">pass</span>

        <span class="s0">if not </span><span class="s1">PEP_560:</span>
            <span class="s2"># Only needed in 3.6.</span>
            <span class="s0">def </span><span class="s1">_get_type_vars(self</span><span class="s0">, </span><span class="s1">tvars):</span>
                <span class="s0">if </span><span class="s1">self </span><span class="s0">not in </span><span class="s1">tvars:</span>
                    <span class="s1">tvars.append(self)</span>


<span class="s2"># 3.6-3.9</span>
<span class="s0">if not </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'Concatenate'</span><span class="s1">):</span>
    <span class="s2"># Inherits from list as a workaround for Callable checks in Python &lt; 3.9.2.</span>
    <span class="s0">class </span><span class="s1">_ConcatenateGenericAlias(list):</span>

        <span class="s2"># Trick Generic into looking into this for __parameters__.</span>
        <span class="s0">if </span><span class="s1">PEP_560:</span>
            <span class="s1">__class__ = typing._GenericAlias</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">__class__ = typing._TypingBase</span>

        <span class="s2"># Flag in 3.8.</span>
        <span class="s1">_special = </span><span class="s0">False</span>
        <span class="s2"># Attribute in 3.6 and earlier.</span>
        <span class="s1">_gorg = typing.Generic</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">origin</span><span class="s0">, </span><span class="s1">args):</span>
            <span class="s1">super().__init__(args)</span>
            <span class="s1">self.__origin__ = origin</span>
            <span class="s1">self.__args__ = args</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s1">_type_repr = typing._type_repr</span>
            <span class="s0">return </span><span class="s1">(</span><span class="s4">f'</span><span class="s0">{</span><span class="s1">_type_repr(self.__origin__)</span><span class="s0">}</span><span class="s4">'</span>
                    <span class="s4">f'[</span><span class="s0">{</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(_type_repr(arg) </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">self.__args__)</span><span class="s0">}</span><span class="s4">]'</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__hash__(self):</span>
            <span class="s0">return </span><span class="s1">hash((self.__origin__</span><span class="s0">, </span><span class="s1">self.__args__))</span>

        <span class="s2"># Hack to get typing._type_check to pass in Generic.</span>
        <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">pass</span>

        <span class="s1">@property</span>
        <span class="s0">def </span><span class="s1">__parameters__(self):</span>
            <span class="s0">return </span><span class="s1">tuple(</span>
                <span class="s1">tp </span><span class="s0">for </span><span class="s1">tp </span><span class="s0">in </span><span class="s1">self.__args__ </span><span class="s0">if </span><span class="s1">isinstance(tp</span><span class="s0">, </span><span class="s1">(typing.TypeVar</span><span class="s0">, </span><span class="s1">ParamSpec))</span>
            <span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">PEP_560:</span>
            <span class="s2"># Only required in 3.6.</span>
            <span class="s0">def </span><span class="s1">_get_type_vars(self</span><span class="s0">, </span><span class="s1">tvars):</span>
                <span class="s0">if </span><span class="s1">self.__origin__ </span><span class="s0">and </span><span class="s1">self.__parameters__:</span>
                    <span class="s1">typing._get_type_vars(self.__parameters__</span><span class="s0">, </span><span class="s1">tvars)</span>


<span class="s2"># 3.6-3.9</span>
<span class="s1">@typing._tp_cache</span>
<span class="s0">def </span><span class="s1">_concatenate_getitem(self</span><span class="s0">, </span><span class="s1">parameters):</span>
    <span class="s0">if </span><span class="s1">parameters == ():</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot take a Concatenate of no types.&quot;</span><span class="s1">)</span>
    <span class="s0">if not </span><span class="s1">isinstance(parameters</span><span class="s0">, </span><span class="s1">tuple):</span>
        <span class="s1">parameters = (parameters</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">if not </span><span class="s1">isinstance(parameters[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ParamSpec):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;The last parameter to Concatenate should be a &quot;</span>
                        <span class="s4">&quot;ParamSpec variable.&quot;</span><span class="s1">)</span>
    <span class="s1">msg = </span><span class="s4">&quot;Concatenate[arg, ...]: each arg must be a type.&quot;</span>
    <span class="s1">parameters = tuple(typing._type_check(p</span><span class="s0">, </span><span class="s1">msg) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">parameters)</span>
    <span class="s0">return </span><span class="s1">_ConcatenateGenericAlias(self</span><span class="s0">, </span><span class="s1">parameters)</span>


<span class="s2"># 3.10+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'Concatenate'</span><span class="s1">):</span>
    <span class="s1">Concatenate = typing.Concatenate</span>
    <span class="s1">_ConcatenateGenericAlias = typing._ConcatenateGenericAlias </span><span class="s2"># noqa</span>
<span class="s2"># 3.9</span>
<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s3">2</span><span class="s1">] &gt;= (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">9</span><span class="s1">):</span>
    <span class="s1">@_TypeAliasForm</span>
    <span class="s0">def </span><span class="s1">Concatenate(self</span><span class="s0">, </span><span class="s1">parameters):</span>
        <span class="s5">&quot;&quot;&quot;Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a 
        higher order function which adds, removes or transforms parameters of a 
        callable. 
 
        For example:: 
 
           Callable[Concatenate[int, P], int] 
 
        See PEP 612 for detailed information. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_concatenate_getitem(self</span><span class="s0">, </span><span class="s1">parameters)</span>
<span class="s2"># 3.7-8</span>
<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s3">2</span><span class="s1">] &gt;= (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">7</span><span class="s1">):</span>
    <span class="s0">class </span><span class="s1">_ConcatenateForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s4">'typing_extensions.' </span><span class="s1">+ self._name</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s0">return </span><span class="s1">_concatenate_getitem(self</span><span class="s0">, </span><span class="s1">parameters)</span>

    <span class="s1">Concatenate = _ConcatenateForm(</span>
        <span class="s4">'Concatenate'</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s4">&quot;&quot;&quot;Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a 
        higher order function which adds, removes or transforms parameters of a 
        callable. 
 
        For example:: 
 
           Callable[Concatenate[int, P], int] 
 
        See PEP 612 for detailed information. 
        &quot;&quot;&quot;</span><span class="s1">)</span>
<span class="s2"># 3.6</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_ConcatenateAliasMeta(typing.TypingMeta):</span>
        <span class="s5">&quot;&quot;&quot;Metaclass for Concatenate.&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s4">'typing_extensions.Concatenate'</span>

    <span class="s0">class </span><span class="s1">_ConcatenateAliasBase(typing._FinalTypingBase</span><span class="s0">,</span>
                                <span class="s1">metaclass=_ConcatenateAliasMeta</span><span class="s0">,</span>
                                <span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a 
        higher order function which adds, removes or transforms parameters of a 
        callable. 
 
        For example:: 
 
           Callable[Concatenate[int, P], int] 
 
        See PEP 612 for detailed information. 
        &quot;&quot;&quot;</span>
        <span class="s1">__slots__ = ()</span>

        <span class="s0">def </span><span class="s1">__instancecheck__(self</span><span class="s0">, </span><span class="s1">obj):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Concatenate cannot be used with isinstance().&quot;</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__subclasscheck__(self</span><span class="s0">, </span><span class="s1">cls):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Concatenate cannot be used with issubclass().&quot;</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s4">'typing_extensions.Concatenate'</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s0">return </span><span class="s1">_concatenate_getitem(self</span><span class="s0">, </span><span class="s1">parameters)</span>

    <span class="s1">Concatenate = _ConcatenateAliasBase(_root=</span><span class="s0">True</span><span class="s1">)</span>

<span class="s2"># 3.10+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'TypeGuard'</span><span class="s1">):</span>
    <span class="s1">TypeGuard = typing.TypeGuard</span>
<span class="s2"># 3.9</span>
<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s3">2</span><span class="s1">] &gt;= (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">9</span><span class="s1">):</span>
    <span class="s0">class </span><span class="s1">_TypeGuardForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s4">'typing_extensions.' </span><span class="s1">+ self._name</span>

    <span class="s1">@_TypeGuardForm</span>
    <span class="s0">def </span><span class="s1">TypeGuard(self</span><span class="s0">, </span><span class="s1">parameters):</span>
        <span class="s5">&quot;&quot;&quot;Special typing form used to annotate the return type of a user-defined 
        type guard function.  ``TypeGuard`` only accepts a single type argument. 
        At runtime, functions marked this way should return a boolean. 
 
        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static 
        type checkers to determine a more precise type of an expression within a 
        program's code flow.  Usually type narrowing is done by analyzing 
        conditional code flow and applying the narrowing to a block of code.  The 
        conditional expression here is sometimes referred to as a &quot;type guard&quot;. 
 
        Sometimes it would be convenient to use a user-defined boolean function 
        as a type guard.  Such a function should use ``TypeGuard[...]`` as its 
        return type to alert static type checkers to this intention. 
 
        Using  ``-&gt; TypeGuard`` tells the static type checker that for a given 
        function: 
 
        1. The return value is a boolean. 
        2. If the return value is ``True``, the type of its argument 
        is the type inside ``TypeGuard``. 
 
        For example:: 
 
            def is_str(val: Union[str, float]): 
                # &quot;isinstance&quot; type guard 
                if isinstance(val, str): 
                    # Type of ``val`` is narrowed to ``str`` 
                    ... 
                else: 
                    # Else, type of ``val`` is narrowed to ``float``. 
                    ... 
 
        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower 
        form of ``TypeA`` (it can even be a wider form) and this may lead to 
        type-unsafe results.  The main reason is to allow for things like 
        narrowing ``List[object]`` to ``List[str]`` even though the latter is not 
        a subtype of the former, since ``List`` is invariant.  The responsibility of 
        writing type-safe type guards is left to the user. 
 
        ``TypeGuard`` also works with type variables.  For more information, see 
        PEP 647 (User-Defined Type Guards). 
        &quot;&quot;&quot;</span>
        <span class="s1">item = typing._type_check(parameters</span><span class="s0">, </span><span class="s4">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">accepts only single type.'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>
<span class="s2"># 3.7-3.8</span>
<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s3">2</span><span class="s1">] &gt;= (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">7</span><span class="s1">):</span>
    <span class="s0">class </span><span class="s1">_TypeGuardForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s4">'typing_extensions.' </span><span class="s1">+ self._name</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s1">item = typing._type_check(parameters</span><span class="s0">,</span>
                                      <span class="s4">f'</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">} </span><span class="s4">accepts only a single type'</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s1">TypeGuard = _TypeGuardForm(</span>
        <span class="s4">'TypeGuard'</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s4">&quot;&quot;&quot;Special typing form used to annotate the return type of a user-defined 
        type guard function.  ``TypeGuard`` only accepts a single type argument. 
        At runtime, functions marked this way should return a boolean. 
 
        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static 
        type checkers to determine a more precise type of an expression within a 
        program's code flow.  Usually type narrowing is done by analyzing 
        conditional code flow and applying the narrowing to a block of code.  The 
        conditional expression here is sometimes referred to as a &quot;type guard&quot;. 
 
        Sometimes it would be convenient to use a user-defined boolean function 
        as a type guard.  Such a function should use ``TypeGuard[...]`` as its 
        return type to alert static type checkers to this intention. 
 
        Using  ``-&gt; TypeGuard`` tells the static type checker that for a given 
        function: 
 
        1. The return value is a boolean. 
        2. If the return value is ``True``, the type of its argument 
        is the type inside ``TypeGuard``. 
 
        For example:: 
 
            def is_str(val: Union[str, float]): 
                # &quot;isinstance&quot; type guard 
                if isinstance(val, str): 
                    # Type of ``val`` is narrowed to ``str`` 
                    ... 
                else: 
                    # Else, type of ``val`` is narrowed to ``float``. 
                    ... 
 
        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower 
        form of ``TypeA`` (it can even be a wider form) and this may lead to 
        type-unsafe results.  The main reason is to allow for things like 
        narrowing ``List[object]`` to ``List[str]`` even though the latter is not 
        a subtype of the former, since ``List`` is invariant.  The responsibility of 
        writing type-safe type guards is left to the user. 
 
        ``TypeGuard`` also works with type variables.  For more information, see 
        PEP 647 (User-Defined Type Guards). 
        &quot;&quot;&quot;</span><span class="s1">)</span>
<span class="s2"># 3.6</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_TypeGuard(typing._FinalTypingBase</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Special typing form used to annotate the return type of a user-defined 
        type guard function.  ``TypeGuard`` only accepts a single type argument. 
        At runtime, functions marked this way should return a boolean. 
 
        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static 
        type checkers to determine a more precise type of an expression within a 
        program's code flow.  Usually type narrowing is done by analyzing 
        conditional code flow and applying the narrowing to a block of code.  The 
        conditional expression here is sometimes referred to as a &quot;type guard&quot;. 
 
        Sometimes it would be convenient to use a user-defined boolean function 
        as a type guard.  Such a function should use ``TypeGuard[...]`` as its 
        return type to alert static type checkers to this intention. 
 
        Using  ``-&gt; TypeGuard`` tells the static type checker that for a given 
        function: 
 
        1. The return value is a boolean. 
        2. If the return value is ``True``, the type of its argument 
        is the type inside ``TypeGuard``. 
 
        For example:: 
 
            def is_str(val: Union[str, float]): 
                # &quot;isinstance&quot; type guard 
                if isinstance(val, str): 
                    # Type of ``val`` is narrowed to ``str`` 
                    ... 
                else: 
                    # Else, type of ``val`` is narrowed to ``float``. 
                    ... 
 
        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower 
        form of ``TypeA`` (it can even be a wider form) and this may lead to 
        type-unsafe results.  The main reason is to allow for things like 
        narrowing ``List[object]`` to ``List[str]`` even though the latter is not 
        a subtype of the former, since ``List`` is invariant.  The responsibility of 
        writing type-safe type guards is left to the user. 
 
        ``TypeGuard`` also works with type variables.  For more information, see 
        PEP 647 (User-Defined Type Guards). 
        &quot;&quot;&quot;</span>

        <span class="s1">__slots__ = (</span><span class="s4">'__type__'</span><span class="s0">,</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">tp=</span><span class="s0">None, </span><span class="s1">**kwds):</span>
            <span class="s1">self.__type__ = tp</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">item):</span>
            <span class="s1">cls = type(self)</span>
            <span class="s0">if </span><span class="s1">self.__type__ </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">cls(typing._type_check(item</span><span class="s0">,</span>
                           <span class="s4">f'</span><span class="s0">{</span><span class="s1">cls.__name__[</span><span class="s3">1</span><span class="s1">:]</span><span class="s0">} </span><span class="s4">accepts only a single type.'</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">_root=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f'</span><span class="s0">{</span><span class="s1">cls.__name__[</span><span class="s3">1</span><span class="s1">:]</span><span class="s0">} </span><span class="s4">cannot be further subscripted'</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">_eval_type(self</span><span class="s0">, </span><span class="s1">globalns</span><span class="s0">, </span><span class="s1">localns):</span>
            <span class="s1">new_tp = typing._eval_type(self.__type__</span><span class="s0">, </span><span class="s1">globalns</span><span class="s0">, </span><span class="s1">localns)</span>
            <span class="s0">if </span><span class="s1">new_tp == self.__type__:</span>
                <span class="s0">return </span><span class="s1">self</span>
            <span class="s0">return </span><span class="s1">type(self)(new_tp</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s1">r = super().__repr__()</span>
            <span class="s0">if </span><span class="s1">self.__type__ </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">r += </span><span class="s4">f'[</span><span class="s0">{</span><span class="s1">typing._type_repr(self.__type__)</span><span class="s0">}</span><span class="s4">]'</span>
            <span class="s0">return </span><span class="s1">r</span>

        <span class="s0">def </span><span class="s1">__hash__(self):</span>
            <span class="s0">return </span><span class="s1">hash((type(self).__name__</span><span class="s0">, </span><span class="s1">self.__type__))</span>

        <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">_TypeGuard):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
            <span class="s0">if </span><span class="s1">self.__type__ </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self.__type__ == other.__type__</span>
            <span class="s0">return </span><span class="s1">self </span><span class="s0">is </span><span class="s1">other</span>

    <span class="s1">TypeGuard = _TypeGuard(_root=</span><span class="s0">True</span><span class="s1">)</span>

<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">&quot;Self&quot;</span><span class="s1">):</span>
    <span class="s1">Self = typing.Self</span>
<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s3">2</span><span class="s1">] &gt;= (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">7</span><span class="s1">):</span>
    <span class="s2"># Vendored from cpython typing._SpecialFrom</span>
    <span class="s0">class </span><span class="s1">_SpecialForm(typing._Final</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s1">__slots__ = (</span><span class="s4">'_name'</span><span class="s0">, </span><span class="s4">'__doc__'</span><span class="s0">, </span><span class="s4">'_getitem'</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">getitem):</span>
            <span class="s1">self._getitem = getitem</span>
            <span class="s1">self._name = getitem.__name__</span>
            <span class="s1">self.__doc__ = getitem.__doc__</span>

        <span class="s0">def </span><span class="s1">__getattr__(self</span><span class="s0">, </span><span class="s1">item):</span>
            <span class="s0">if </span><span class="s1">item </span><span class="s0">in </span><span class="s1">{</span><span class="s4">'__name__'</span><span class="s0">, </span><span class="s4">'__qualname__'</span><span class="s1">}:</span>
                <span class="s0">return </span><span class="s1">self._name</span>

            <span class="s0">raise </span><span class="s1">AttributeError(item)</span>

        <span class="s0">def </span><span class="s1">__mro_entries__(self</span><span class="s0">, </span><span class="s1">bases):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;Cannot subclass </span><span class="s0">{</span><span class="s1">self</span><span class="s0">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s4">f'typing_extensions.</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">}</span><span class="s4">'</span>

        <span class="s0">def </span><span class="s1">__reduce__(self):</span>
            <span class="s0">return </span><span class="s1">self._name</span>

        <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;Cannot instantiate </span><span class="s0">{</span><span class="s1">self</span><span class="s0">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__or__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">return </span><span class="s1">typing.Union[self</span><span class="s0">, </span><span class="s1">other]</span>

        <span class="s0">def </span><span class="s1">__ror__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">return </span><span class="s1">typing.Union[other</span><span class="s0">, </span><span class="s1">self]</span>

        <span class="s0">def </span><span class="s1">__instancecheck__(self</span><span class="s0">, </span><span class="s1">obj):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">cannot be used with isinstance()&quot;</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__subclasscheck__(self</span><span class="s0">, </span><span class="s1">cls):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">cannot be used with issubclass()&quot;</span><span class="s1">)</span>

        <span class="s1">@typing._tp_cache</span>
        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s0">return </span><span class="s1">self._getitem(self</span><span class="s0">, </span><span class="s1">parameters)</span>

    <span class="s1">@_SpecialForm</span>
    <span class="s0">def </span><span class="s1">Self(self</span><span class="s0">, </span><span class="s1">params):</span>
        <span class="s5">&quot;&quot;&quot;Used to spell the type of &quot;self&quot; in classes. 
 
        Example:: 
 
          from typing import Self 
 
          class ReturnsSelf: 
              def parse(self, data: bytes) -&gt; Self: 
                  ... 
                  return self 
 
        &quot;&quot;&quot;</span>

        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">is not subscriptable&quot;</span><span class="s1">)</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_Self(typing._FinalTypingBase</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Used to spell the type of &quot;self&quot; in classes. 
 
        Example:: 
 
          from typing import Self 
 
          class ReturnsSelf: 
              def parse(self, data: bytes) -&gt; Self: 
                  ... 
                  return self 
 
        &quot;&quot;&quot;</span>

        <span class="s1">__slots__ = ()</span>

        <span class="s0">def </span><span class="s1">__instancecheck__(self</span><span class="s0">, </span><span class="s1">obj):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">cannot be used with isinstance().&quot;</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__subclasscheck__(self</span><span class="s0">, </span><span class="s1">cls):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">cannot be used with issubclass().&quot;</span><span class="s1">)</span>

    <span class="s1">Self = _Self(_root=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s4">'Required'</span><span class="s1">):</span>
    <span class="s1">Required = typing.Required</span>
    <span class="s1">NotRequired = typing.NotRequired</span>
<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s3">2</span><span class="s1">] &gt;= (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">9</span><span class="s1">):</span>
    <span class="s0">class </span><span class="s1">_ExtensionsSpecialForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s4">'typing_extensions.' </span><span class="s1">+ self._name</span>

    <span class="s1">@_ExtensionsSpecialForm</span>
    <span class="s0">def </span><span class="s1">Required(self</span><span class="s0">, </span><span class="s1">parameters):</span>
        <span class="s5">&quot;&quot;&quot;A special typing construct to mark a key of a total=False TypedDict 
        as required. For example: 
 
            class Movie(TypedDict, total=False): 
                title: Required[str] 
                year: int 
 
            m = Movie( 
                title='The Matrix',  # typechecker error if key is omitted 
                year=1999, 
            ) 
 
        There is no runtime checking that a required key is actually provided 
        when instantiating a related TypedDict. 
        &quot;&quot;&quot;</span>
        <span class="s1">item = typing._type_check(parameters</span><span class="s0">, </span><span class="s4">f'</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">} </span><span class="s4">accepts only single type'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s1">@_ExtensionsSpecialForm</span>
    <span class="s0">def </span><span class="s1">NotRequired(self</span><span class="s0">, </span><span class="s1">parameters):</span>
        <span class="s5">&quot;&quot;&quot;A special typing construct to mark a key of a TypedDict as 
        potentially missing. For example: 
 
            class Movie(TypedDict): 
                title: str 
                year: NotRequired[int] 
 
            m = Movie( 
                title='The Matrix',  # typechecker error if key is omitted 
                year=1999, 
            ) 
        &quot;&quot;&quot;</span>
        <span class="s1">item = typing._type_check(parameters</span><span class="s0">, </span><span class="s4">f'</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">} </span><span class="s4">accepts only single type'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>

<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s3">2</span><span class="s1">] &gt;= (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">7</span><span class="s1">):</span>
    <span class="s0">class </span><span class="s1">_RequiredForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s4">'typing_extensions.' </span><span class="s1">+ self._name</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s1">item = typing._type_check(parameters</span><span class="s0">,</span>
                                      <span class="s4">'{} accepts only single type'</span><span class="s1">.format(self._name))</span>
            <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s1">Required = _RequiredForm(</span>
        <span class="s4">'Required'</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s4">&quot;&quot;&quot;A special typing construct to mark a key of a total=False TypedDict 
        as required. For example: 
 
            class Movie(TypedDict, total=False): 
                title: Required[str] 
                year: int 
 
            m = Movie( 
                title='The Matrix',  # typechecker error if key is omitted 
                year=1999, 
            ) 
 
        There is no runtime checking that a required key is actually provided 
        when instantiating a related TypedDict. 
        &quot;&quot;&quot;</span><span class="s1">)</span>
    <span class="s1">NotRequired = _RequiredForm(</span>
        <span class="s4">'NotRequired'</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s4">&quot;&quot;&quot;A special typing construct to mark a key of a TypedDict as 
        potentially missing. For example: 
 
            class Movie(TypedDict): 
                title: str 
                year: NotRequired[int] 
 
            m = Movie( 
                title='The Matrix',  # typechecker error if key is omitted 
                year=1999, 
            ) 
        &quot;&quot;&quot;</span><span class="s1">)</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s2"># NOTE: Modeled after _Final's implementation when _FinalTypingBase available</span>
    <span class="s0">class </span><span class="s1">_MaybeRequired(typing._FinalTypingBase</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s1">__slots__ = (</span><span class="s4">'__type__'</span><span class="s0">,</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">tp=</span><span class="s0">None, </span><span class="s1">**kwds):</span>
            <span class="s1">self.__type__ = tp</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">item):</span>
            <span class="s1">cls = type(self)</span>
            <span class="s0">if </span><span class="s1">self.__type__ </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">cls(typing._type_check(item</span><span class="s0">,</span>
                           <span class="s4">'{} accepts only single type.'</span><span class="s1">.format(cls.__name__[</span><span class="s3">1</span><span class="s1">:]))</span><span class="s0">,</span>
                           <span class="s1">_root=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'{} cannot be further subscripted'</span>
                            <span class="s1">.format(cls.__name__[</span><span class="s3">1</span><span class="s1">:]))</span>

        <span class="s0">def </span><span class="s1">_eval_type(self</span><span class="s0">, </span><span class="s1">globalns</span><span class="s0">, </span><span class="s1">localns):</span>
            <span class="s1">new_tp = typing._eval_type(self.__type__</span><span class="s0">, </span><span class="s1">globalns</span><span class="s0">, </span><span class="s1">localns)</span>
            <span class="s0">if </span><span class="s1">new_tp == self.__type__:</span>
                <span class="s0">return </span><span class="s1">self</span>
            <span class="s0">return </span><span class="s1">type(self)(new_tp</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s1">r = super().__repr__()</span>
            <span class="s0">if </span><span class="s1">self.__type__ </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">r += </span><span class="s4">'[{}]'</span><span class="s1">.format(typing._type_repr(self.__type__))</span>
            <span class="s0">return </span><span class="s1">r</span>

        <span class="s0">def </span><span class="s1">__hash__(self):</span>
            <span class="s0">return </span><span class="s1">hash((type(self).__name__</span><span class="s0">, </span><span class="s1">self.__type__))</span>

        <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">type(self)):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
            <span class="s0">if </span><span class="s1">self.__type__ </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self.__type__ == other.__type__</span>
            <span class="s0">return </span><span class="s1">self </span><span class="s0">is </span><span class="s1">other</span>

    <span class="s0">class </span><span class="s1">_Required(_MaybeRequired</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;A special typing construct to mark a key of a total=False TypedDict 
        as required. For example: 
 
            class Movie(TypedDict, total=False): 
                title: Required[str] 
                year: int 
 
            m = Movie( 
                title='The Matrix',  # typechecker error if key is omitted 
                year=1999, 
            ) 
 
        There is no runtime checking that a required key is actually provided 
        when instantiating a related TypedDict. 
        &quot;&quot;&quot;</span>

    <span class="s0">class </span><span class="s1">_NotRequired(_MaybeRequired</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;A special typing construct to mark a key of a TypedDict as 
        potentially missing. For example: 
 
            class Movie(TypedDict): 
                title: str 
                year: NotRequired[int] 
 
            m = Movie( 
                title='The Matrix',  # typechecker error if key is omitted 
                year=1999, 
            ) 
        &quot;&quot;&quot;</span>

    <span class="s1">Required = _Required(_root=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">NotRequired = _NotRequired(_root=</span><span class="s0">True</span><span class="s1">)</span>
</pre>
</body>
</html>