<html>
<head>
<title>test_to_numeric.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_to_numeric.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">decimal</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy </span><span class="s0">import </span><span class="s1">iinfo</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">pandas.compat </span><span class="s0">import </span><span class="s1">is_platform_arm</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s0">,</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">to_numeric</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s0">None, </span><span class="s2">&quot;ignore&quot;</span><span class="s0">, </span><span class="s2">&quot;raise&quot;</span><span class="s0">, </span><span class="s2">&quot;coerce&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">errors(request):</span>
    <span class="s0">return </span><span class="s1">request.param</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">signed(request):</span>
    <span class="s0">return </span><span class="s1">request.param</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s0">lambda </span><span class="s1">x: x</span><span class="s0">, </span><span class="s1">str]</span><span class="s0">, </span><span class="s1">ids=[</span><span class="s2">&quot;identity&quot;</span><span class="s0">, </span><span class="s2">&quot;str&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">transform(request):</span>
    <span class="s0">return </span><span class="s1">request.param</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s3">47393996303418497800</span><span class="s0">, </span><span class="s3">100000000000000000000</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">large_val(request):</span>
    <span class="s0">return </span><span class="s1">request.param</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">multiple_elts(request):</span>
    <span class="s0">return </span><span class="s1">request.param</span>


<span class="s1">@pytest.fixture(</span>
    <span class="s1">params=[</span>
        <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: Index(x</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;idx&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">tm.assert_index_equal)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: Series(x</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;ser&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">tm.assert_series_equal)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: np.array(Index(x).values)</span><span class="s0">, </span><span class="s1">tm.assert_numpy_array_equal)</span><span class="s0">,</span>
    <span class="s1">]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">transform_assert_equal(request):</span>
    <span class="s0">return </span><span class="s1">request.param</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;input_kwargs,result_kwargs&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">({}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;dtype&quot;</span><span class="s1">: np.int64})</span><span class="s0">,</span>
        <span class="s1">({</span><span class="s2">&quot;errors&quot;</span><span class="s1">: </span><span class="s2">&quot;coerce&quot;</span><span class="s0">, </span><span class="s2">&quot;downcast&quot;</span><span class="s1">: </span><span class="s2">&quot;integer&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;dtype&quot;</span><span class="s1">: np.int8})</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_empty(input_kwargs</span><span class="s0">, </span><span class="s1">result_kwargs):</span>
    <span class="s4"># see gh-16302</span>
    <span class="s1">ser = Series([]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
    <span class="s1">result = to_numeric(ser</span><span class="s0">, </span><span class="s1">**input_kwargs)</span>

    <span class="s1">expected = Series([]</span><span class="s0">, </span><span class="s1">**result_kwargs)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;last_val&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;7&quot;</span><span class="s0">, </span><span class="s3">7</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_series(last_val):</span>
    <span class="s1">ser = Series([</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s2">&quot;-3.14&quot;</span><span class="s0">, </span><span class="s1">last_val])</span>
    <span class="s1">result = to_numeric(ser)</span>

    <span class="s1">expected = Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3.14</span><span class="s0">, </span><span class="s3">7</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;data&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">5.0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s4"># Bool is regarded as numeric.</span>
        <span class="s1">[</span><span class="s0">True, False, True, True</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_series_numeric(data):</span>
    <span class="s1">ser = Series(data</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;ABCD&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;EFG&quot;</span><span class="s1">)</span>

    <span class="s1">result = to_numeric(ser)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">ser)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;data,msg&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">([</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3.14</span><span class="s0">, </span><span class="s2">&quot;apple&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'Unable to parse string &quot;apple&quot; at position 2'</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">[</span><span class="s2">&quot;orange&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3.14</span><span class="s0">, </span><span class="s2">&quot;apple&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">'Unable to parse string &quot;orange&quot; at position 0'</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_error(data</span><span class="s0">, </span><span class="s1">msg):</span>
    <span class="s1">ser = Series(data)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">to_numeric(ser</span><span class="s0">, </span><span class="s1">errors=</span><span class="s2">&quot;raise&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;errors,exp_data&quot;</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3.14</span><span class="s0">, </span><span class="s2">&quot;apple&quot;</span><span class="s1">])</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;coerce&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3.14</span><span class="s0">, </span><span class="s1">np.nan])]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_ignore_error(errors</span><span class="s0">, </span><span class="s1">exp_data):</span>
    <span class="s1">ser = Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3.14</span><span class="s0">, </span><span class="s2">&quot;apple&quot;</span><span class="s1">])</span>
    <span class="s1">result = to_numeric(ser</span><span class="s0">, </span><span class="s1">errors=errors)</span>

    <span class="s1">expected = Series(exp_data)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;errors,exp&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s2">&quot;raise&quot;</span><span class="s0">, </span><span class="s2">'Unable to parse string &quot;apple&quot; at position 2'</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False, </span><span class="s2">&quot;apple&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s4"># Coerces to float.</span>
        <span class="s1">(</span><span class="s2">&quot;coerce&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">np.nan])</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_bool_handling(errors</span><span class="s0">, </span><span class="s1">exp):</span>
    <span class="s1">ser = Series([</span><span class="s0">True, False, </span><span class="s2">&quot;apple&quot;</span><span class="s1">])</span>

    <span class="s0">if </span><span class="s1">isinstance(exp</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=exp):</span>
            <span class="s1">to_numeric(ser</span><span class="s0">, </span><span class="s1">errors=errors)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result = to_numeric(ser</span><span class="s0">, </span><span class="s1">errors=errors)</span>
        <span class="s1">expected = Series(exp)</span>

        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_list():</span>
    <span class="s1">ser = [</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s2">&quot;-3.14&quot;</span><span class="s0">, </span><span class="s2">&quot;7&quot;</span><span class="s1">]</span>
    <span class="s1">res = to_numeric(ser)</span>

    <span class="s1">expected = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3.14</span><span class="s0">, </span><span class="s3">7</span><span class="s1">])</span>
    <span class="s1">tm.assert_numpy_array_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;data,arr_kwargs&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;dtype&quot;</span><span class="s1">: np.int64})</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">5.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">,</span>
        <span class="s4"># Boolean is regarded as numeric.</span>
        <span class="s1">([</span><span class="s0">True, False, True, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_list_numeric(data</span><span class="s0">, </span><span class="s1">arr_kwargs):</span>
    <span class="s1">result = to_numeric(data)</span>
    <span class="s1">expected = np.array(data</span><span class="s0">, </span><span class="s1">**arr_kwargs)</span>
    <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;kwargs&quot;</span><span class="s0">, </span><span class="s1">[{</span><span class="s2">&quot;dtype&quot;</span><span class="s1">: </span><span class="s2">&quot;O&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{}])</span>
<span class="s0">def </span><span class="s1">test_numeric(kwargs):</span>
    <span class="s1">data = [</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3.14</span><span class="s0">, </span><span class="s3">7</span><span class="s1">]</span>

    <span class="s1">ser = Series(data</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s1">result = to_numeric(ser)</span>

    <span class="s1">expected = Series(data)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;columns&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s4"># One column.</span>
        <span class="s2">&quot;a&quot;</span><span class="s0">,</span>
        <span class="s4"># Multiple columns.</span>
        <span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_numeric_df_columns(columns):</span>
    <span class="s4"># see gh-14827</span>
    <span class="s1">df = DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1.2</span><span class="s0">, </span><span class="s1">decimal.Decimal(</span><span class="s3">3.14</span><span class="s1">)</span><span class="s0">, </span><span class="s1">decimal.Decimal(</span><span class="s2">&quot;infinity&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;0.1&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">4.0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>

    <span class="s1">expected = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1.2</span><span class="s0">, </span><span class="s3">3.14</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s3">0.1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">4.0</span><span class="s1">]})</span>

    <span class="s1">df_copy = df.copy()</span>
    <span class="s1">df_copy[columns] = df_copy[columns].apply(to_numeric)</span>

    <span class="s1">tm.assert_frame_equal(df_copy</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;data,exp_data&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s1">[[decimal.Decimal(</span><span class="s3">3.14</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal.Decimal(</span><span class="s3">1.6</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0.1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[[</span><span class="s3">3.14</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1.6</span><span class="s0">, </span><span class="s3">0.1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([np.array([decimal.Decimal(</span><span class="s3">3.14</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">])</span><span class="s0">, </span><span class="s3">0.1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">3.14</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0.1</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_numeric_embedded_arr_likes(data</span><span class="s0">, </span><span class="s1">exp_data):</span>
    <span class="s4"># Test to_numeric with embedded lists and arrays</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: data})</span>
    <span class="s1">df[</span><span class="s2">&quot;a&quot;</span><span class="s1">] = df[</span><span class="s2">&quot;a&quot;</span><span class="s1">].apply(to_numeric)</span>

    <span class="s1">expected = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: exp_data})</span>
    <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_all_nan():</span>
    <span class="s1">ser = Series([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s1">result = to_numeric(ser</span><span class="s0">, </span><span class="s1">errors=</span><span class="s2">&quot;coerce&quot;</span><span class="s1">)</span>

    <span class="s1">expected = Series([np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan])</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_type_check(errors):</span>
    <span class="s4"># see gh-11776</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3.14</span><span class="s0">, </span><span class="s3">7</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s2">&quot;4&quot;</span><span class="s0">, </span><span class="s2">&quot;5&quot;</span><span class="s0">, </span><span class="s2">&quot;6&quot;</span><span class="s1">]})</span>
    <span class="s1">kwargs = {</span><span class="s2">&quot;errors&quot;</span><span class="s1">: errors} </span><span class="s0">if </span><span class="s1">errors </span><span class="s0">is not None else </span><span class="s1">{}</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;1-d array&quot;</span><span class="s1">):</span>
        <span class="s1">to_numeric(df</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;val&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1.1</span><span class="s0">, </span><span class="s3">20001</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_scalar(val</span><span class="s0">, </span><span class="s1">signed</span><span class="s0">, </span><span class="s1">transform):</span>
    <span class="s1">val = -val </span><span class="s0">if </span><span class="s1">signed </span><span class="s0">else </span><span class="s1">val</span>
    <span class="s0">assert </span><span class="s1">to_numeric(transform(val)) == float(val)</span>


<span class="s0">def </span><span class="s1">test_really_large_scalar(large_val</span><span class="s0">, </span><span class="s1">signed</span><span class="s0">, </span><span class="s1">transform</span><span class="s0">, </span><span class="s1">errors):</span>
    <span class="s4"># see gh-24910</span>
    <span class="s1">kwargs = {</span><span class="s2">&quot;errors&quot;</span><span class="s1">: errors} </span><span class="s0">if </span><span class="s1">errors </span><span class="s0">is not None else </span><span class="s1">{}</span>
    <span class="s1">val = -large_val </span><span class="s0">if </span><span class="s1">signed </span><span class="s0">else </span><span class="s1">large_val</span>

    <span class="s1">val = transform(val)</span>
    <span class="s1">val_is_string = isinstance(val</span><span class="s0">, </span><span class="s1">str)</span>

    <span class="s0">if </span><span class="s1">val_is_string </span><span class="s0">and </span><span class="s1">errors </span><span class="s0">in </span><span class="s1">(</span><span class="s0">None, </span><span class="s2">&quot;raise&quot;</span><span class="s1">):</span>
        <span class="s1">msg = </span><span class="s2">&quot;Integer out of range. at position 0&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_numeric(val</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">expected = float(val) </span><span class="s0">if </span><span class="s1">(errors == </span><span class="s2">&quot;coerce&quot; </span><span class="s0">and </span><span class="s1">val_is_string) </span><span class="s0">else </span><span class="s1">val</span>
        <span class="s1">tm.assert_almost_equal(to_numeric(val</span><span class="s0">, </span><span class="s1">**kwargs)</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_really_large_in_arr(large_val</span><span class="s0">, </span><span class="s1">signed</span><span class="s0">, </span><span class="s1">transform</span><span class="s0">, </span><span class="s1">multiple_elts</span><span class="s0">, </span><span class="s1">errors):</span>
    <span class="s4"># see gh-24910</span>
    <span class="s1">kwargs = {</span><span class="s2">&quot;errors&quot;</span><span class="s1">: errors} </span><span class="s0">if </span><span class="s1">errors </span><span class="s0">is not None else </span><span class="s1">{}</span>
    <span class="s1">val = -large_val </span><span class="s0">if </span><span class="s1">signed </span><span class="s0">else </span><span class="s1">large_val</span>
    <span class="s1">val = transform(val)</span>

    <span class="s1">extra_elt = </span><span class="s2">&quot;string&quot;</span>
    <span class="s1">arr = [val] + multiple_elts * [extra_elt]</span>

    <span class="s1">val_is_string = isinstance(val</span><span class="s0">, </span><span class="s1">str)</span>
    <span class="s1">coercing = errors == </span><span class="s2">&quot;coerce&quot;</span>

    <span class="s0">if </span><span class="s1">errors </span><span class="s0">in </span><span class="s1">(</span><span class="s0">None, </span><span class="s2">&quot;raise&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(val_is_string </span><span class="s0">or </span><span class="s1">multiple_elts):</span>
        <span class="s0">if </span><span class="s1">val_is_string:</span>
            <span class="s1">msg = </span><span class="s2">&quot;Integer out of range. at position 0&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">'Unable to parse string &quot;string&quot; at position 1'</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_numeric(arr</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result = to_numeric(arr</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s1">exp_val = float(val) </span><span class="s0">if </span><span class="s1">(coercing </span><span class="s0">and </span><span class="s1">val_is_string) </span><span class="s0">else </span><span class="s1">val</span>
        <span class="s1">expected = [exp_val]</span>

        <span class="s0">if </span><span class="s1">multiple_elts:</span>
            <span class="s0">if </span><span class="s1">coercing:</span>
                <span class="s1">expected.append(np.nan)</span>
                <span class="s1">exp_dtype = float</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected.append(extra_elt)</span>
                <span class="s1">exp_dtype = object</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">exp_dtype = float </span><span class="s0">if </span><span class="s1">isinstance(exp_val</span><span class="s0">, </span><span class="s1">(int</span><span class="s0">, </span><span class="s1">float)) </span><span class="s0">else </span><span class="s1">object</span>

        <span class="s1">tm.assert_almost_equal(result</span><span class="s0">, </span><span class="s1">np.array(expected</span><span class="s0">, </span><span class="s1">dtype=exp_dtype))</span>


<span class="s0">def </span><span class="s1">test_really_large_in_arr_consistent(large_val</span><span class="s0">, </span><span class="s1">signed</span><span class="s0">, </span><span class="s1">multiple_elts</span><span class="s0">, </span><span class="s1">errors):</span>
    <span class="s4"># see gh-24910</span>
    <span class="s4">#</span>
    <span class="s4"># Even if we discover that we have to hold float, does not mean</span>
    <span class="s4"># we should be lenient on subsequent elements that fail to be integer.</span>
    <span class="s1">kwargs = {</span><span class="s2">&quot;errors&quot;</span><span class="s1">: errors} </span><span class="s0">if </span><span class="s1">errors </span><span class="s0">is not None else </span><span class="s1">{}</span>
    <span class="s1">arr = [str(-large_val </span><span class="s0">if </span><span class="s1">signed </span><span class="s0">else </span><span class="s1">large_val)]</span>

    <span class="s0">if </span><span class="s1">multiple_elts:</span>
        <span class="s1">arr.insert(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">large_val)</span>

    <span class="s0">if </span><span class="s1">errors </span><span class="s0">in </span><span class="s1">(</span><span class="s0">None, </span><span class="s2">&quot;raise&quot;</span><span class="s1">):</span>
        <span class="s1">index = int(multiple_elts)</span>
        <span class="s1">msg = </span><span class="s2">f&quot;Integer out of range. at position </span><span class="s0">{</span><span class="s1">index</span><span class="s0">}</span><span class="s2">&quot;</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_numeric(arr</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result = to_numeric(arr</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s0">if </span><span class="s1">errors == </span><span class="s2">&quot;coerce&quot;</span><span class="s1">:</span>
            <span class="s1">expected = [float(i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">arr]</span>
            <span class="s1">exp_dtype = float</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expected = arr</span>
            <span class="s1">exp_dtype = object</span>

        <span class="s1">tm.assert_almost_equal(result</span><span class="s0">, </span><span class="s1">np.array(expected</span><span class="s0">, </span><span class="s1">dtype=exp_dtype))</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;errors,checker&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s2">&quot;raise&quot;</span><span class="s0">, </span><span class="s2">'Unable to parse string &quot;fail&quot; at position 0'</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;ignore&quot;</span><span class="s0">, lambda </span><span class="s1">x: x == </span><span class="s2">&quot;fail&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;coerce&quot;</span><span class="s0">, lambda </span><span class="s1">x: np.isnan(x))</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_scalar_fail(errors</span><span class="s0">, </span><span class="s1">checker):</span>
    <span class="s1">scalar = </span><span class="s2">&quot;fail&quot;</span>

    <span class="s0">if </span><span class="s1">isinstance(checker</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=checker):</span>
            <span class="s1">to_numeric(scalar</span><span class="s0">, </span><span class="s1">errors=errors)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">checker(to_numeric(scalar</span><span class="s0">, </span><span class="s1">errors=errors))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s1">np.nan]])</span>
<span class="s0">def </span><span class="s1">test_numeric_dtypes(data</span><span class="s0">, </span><span class="s1">transform_assert_equal):</span>
    <span class="s1">transform</span><span class="s0">, </span><span class="s1">assert_equal = transform_assert_equal</span>
    <span class="s1">data = transform(data)</span>

    <span class="s1">result = to_numeric(data)</span>
    <span class="s1">assert_equal(result</span><span class="s0">, </span><span class="s1">data)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;data,exp&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">([</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s0">, </span><span class="s2">&quot;3&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s2">&quot;1.5&quot;</span><span class="s0">, </span><span class="s2">&quot;2.7&quot;</span><span class="s0">, </span><span class="s2">&quot;3.4&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">2.7</span><span class="s0">, </span><span class="s3">3.4</span><span class="s1">]))</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_str(data</span><span class="s0">, </span><span class="s1">exp</span><span class="s0">, </span><span class="s1">transform_assert_equal):</span>
    <span class="s1">transform</span><span class="s0">, </span><span class="s1">assert_equal = transform_assert_equal</span>
    <span class="s1">result = to_numeric(transform(data))</span>

    <span class="s1">expected = transform(exp)</span>
    <span class="s1">assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_datetime_like(tz_naive_fixture</span><span class="s0">, </span><span class="s1">transform_assert_equal):</span>
    <span class="s1">transform</span><span class="s0">, </span><span class="s1">assert_equal = transform_assert_equal</span>
    <span class="s1">idx = pd.date_range(</span><span class="s2">&quot;20130101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">tz=tz_naive_fixture)</span>

    <span class="s1">result = to_numeric(transform(idx))</span>
    <span class="s1">expected = transform(idx.asi8)</span>
    <span class="s1">assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_timedelta(transform_assert_equal):</span>
    <span class="s1">transform</span><span class="s0">, </span><span class="s1">assert_equal = transform_assert_equal</span>
    <span class="s1">idx = pd.timedelta_range(</span><span class="s2">&quot;1 days&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;D&quot;</span><span class="s1">)</span>

    <span class="s1">result = to_numeric(transform(idx))</span>
    <span class="s1">expected = transform(idx.asi8)</span>
    <span class="s1">assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_period(transform_assert_equal):</span>
    <span class="s1">transform</span><span class="s0">, </span><span class="s1">assert_equal = transform_assert_equal</span>

    <span class="s1">idx = pd.period_range(</span><span class="s2">&quot;2011-01&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;M&quot;</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
    <span class="s1">inp = transform(idx)</span>

    <span class="s0">if </span><span class="s1">isinstance(inp</span><span class="s0">, </span><span class="s1">Index):</span>
        <span class="s1">result = to_numeric(inp)</span>
        <span class="s1">expected = transform(idx.asi8)</span>
        <span class="s1">assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s4"># TODO: PeriodDtype, so support it in to_numeric.</span>
        <span class="s1">pytest.skip(</span><span class="s2">&quot;Missing PeriodDtype support in to_numeric&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;errors,expected&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s2">&quot;raise&quot;</span><span class="s0">, </span><span class="s2">&quot;Invalid object type at position 0&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">Series([[</span><span class="s3">10.0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s2">&quot;apple&quot;</span><span class="s1">]))</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;coerce&quot;</span><span class="s0">, </span><span class="s1">Series([np.nan</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">np.nan]))</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_non_hashable(errors</span><span class="s0">, </span><span class="s1">expected):</span>
    <span class="s4"># see gh-13324</span>
    <span class="s1">ser = Series([[</span><span class="s3">10.0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s2">&quot;apple&quot;</span><span class="s1">])</span>

    <span class="s0">if </span><span class="s1">isinstance(expected</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=expected):</span>
            <span class="s1">to_numeric(ser</span><span class="s0">, </span><span class="s1">errors=errors)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result = to_numeric(ser</span><span class="s0">, </span><span class="s1">errors=errors)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_downcast_invalid_cast():</span>
    <span class="s4"># see gh-13352</span>
    <span class="s1">data = [</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">invalid_downcast = </span><span class="s2">&quot;unsigned-integer&quot;</span>
    <span class="s1">msg = </span><span class="s2">&quot;invalid downcasting method provided&quot;</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">to_numeric(data</span><span class="s0">, </span><span class="s1">downcast=invalid_downcast)</span>


<span class="s0">def </span><span class="s1">test_errors_invalid_value():</span>
    <span class="s4"># see gh-26466</span>
    <span class="s1">data = [</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">invalid_error_value = </span><span class="s2">&quot;invalid&quot;</span>
    <span class="s1">msg = </span><span class="s2">&quot;invalid error value specified&quot;</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">to_numeric(data</span><span class="s0">, </span><span class="s1">errors=invalid_error_value)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;data&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">np.array([</span><span class="s2">&quot;1970-01-02&quot;</span><span class="s0">, </span><span class="s2">&quot;1970-01-03&quot;</span><span class="s0">, </span><span class="s2">&quot;1970-01-04&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;datetime64[D]&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;kwargs,exp_dtype&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s4"># Basic function tests.</span>
        <span class="s1">({}</span><span class="s0">, </span><span class="s1">np.int64)</span><span class="s0">,</span>
        <span class="s1">({</span><span class="s2">&quot;downcast&quot;</span><span class="s1">: </span><span class="s0">None</span><span class="s1">}</span><span class="s0">, </span><span class="s1">np.int64)</span><span class="s0">,</span>
        <span class="s4"># Support below np.float32 is rare and far between.</span>
        <span class="s1">({</span><span class="s2">&quot;downcast&quot;</span><span class="s1">: </span><span class="s2">&quot;float&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s1">np.dtype(np.float32).char)</span><span class="s0">,</span>
        <span class="s4"># Basic dtype support.</span>
        <span class="s1">({</span><span class="s2">&quot;downcast&quot;</span><span class="s1">: </span><span class="s2">&quot;unsigned&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s1">np.dtype(np.typecodes[</span><span class="s2">&quot;UnsignedInteger&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]))</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_downcast_basic(data</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">exp_dtype):</span>
    <span class="s4"># see gh-13352</span>
    <span class="s1">result = to_numeric(data</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s1">expected = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=exp_dtype)</span>
    <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;signed_downcast&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s2">&quot;signed&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;data&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">[</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">np.array([</span><span class="s2">&quot;1970-01-02&quot;</span><span class="s0">, </span><span class="s2">&quot;1970-01-03&quot;</span><span class="s0">, </span><span class="s2">&quot;1970-01-04&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;datetime64[D]&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_signed_downcast(data</span><span class="s0">, </span><span class="s1">signed_downcast):</span>
    <span class="s4"># see gh-13352</span>
    <span class="s1">smallest_int_dtype = np.dtype(np.typecodes[</span><span class="s2">&quot;Integer&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">])</span>
    <span class="s1">expected = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=smallest_int_dtype)</span>

    <span class="s1">res = to_numeric(data</span><span class="s0">, </span><span class="s1">downcast=signed_downcast)</span>
    <span class="s1">tm.assert_numpy_array_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_ignore_downcast_invalid_data():</span>
    <span class="s4"># If we can't successfully cast the given</span>
    <span class="s4"># data to a numeric dtype, do not bother</span>
    <span class="s4"># with the downcast parameter.</span>
    <span class="s1">data = [</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">expected = np.array(data</span><span class="s0">, </span><span class="s1">dtype=object)</span>

    <span class="s1">res = to_numeric(data</span><span class="s0">, </span><span class="s1">errors=</span><span class="s2">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">downcast=</span><span class="s2">&quot;unsigned&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_numpy_array_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_ignore_downcast_neg_to_unsigned():</span>
    <span class="s4"># Cannot cast to an unsigned integer</span>
    <span class="s4"># because we have a negative number.</span>
    <span class="s1">data = [</span><span class="s2">&quot;-1&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">expected = np.array([-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.int64)</span>

    <span class="s1">res = to_numeric(data</span><span class="s0">, </span><span class="s1">downcast=</span><span class="s2">&quot;unsigned&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_numpy_array_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;downcast&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s2">&quot;signed&quot;</span><span class="s0">, </span><span class="s2">&quot;unsigned&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;data,expected&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">([</span><span class="s2">&quot;1.1&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s3">1.1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float64))</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">[</span><span class="s3">10000.0</span><span class="s0">, </span><span class="s3">20000</span><span class="s0">, </span><span class="s3">3000</span><span class="s0">, </span><span class="s3">40000.36</span><span class="s0">, </span><span class="s3">50000</span><span class="s0">, </span><span class="s3">50000.00</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">np.array(</span>
                <span class="s1">[</span><span class="s3">10000.0</span><span class="s0">, </span><span class="s3">20000</span><span class="s0">, </span><span class="s3">3000</span><span class="s0">, </span><span class="s3">40000.36</span><span class="s0">, </span><span class="s3">50000</span><span class="s0">, </span><span class="s3">50000.00</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float64</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_ignore_downcast_cannot_convert_float(data</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">downcast):</span>
    <span class="s4"># Cannot cast to an integer (signed or unsigned)</span>
    <span class="s4"># because we have a float number.</span>
    <span class="s1">res = to_numeric(data</span><span class="s0">, </span><span class="s1">downcast=downcast)</span>
    <span class="s1">tm.assert_numpy_array_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;downcast,expected_dtype&quot;</span><span class="s0">,</span>
    <span class="s1">[(</span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s1">np.int16)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;signed&quot;</span><span class="s0">, </span><span class="s1">np.int16)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;unsigned&quot;</span><span class="s0">, </span><span class="s1">np.uint16)]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_downcast_not8bit(downcast</span><span class="s0">, </span><span class="s1">expected_dtype):</span>
    <span class="s4"># the smallest integer dtype need not be np.(u)int8</span>
    <span class="s1">data = [</span><span class="s2">&quot;256&quot;</span><span class="s0">, </span><span class="s3">257</span><span class="s0">, </span><span class="s3">258</span><span class="s1">]</span>

    <span class="s1">expected = np.array([</span><span class="s3">256</span><span class="s0">, </span><span class="s3">257</span><span class="s0">, </span><span class="s3">258</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=expected_dtype)</span>
    <span class="s1">res = to_numeric(data</span><span class="s0">, </span><span class="s1">downcast=downcast)</span>
    <span class="s1">tm.assert_numpy_array_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;dtype,downcast,min_max&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s2">&quot;int8&quot;</span><span class="s0">, </span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s1">[iinfo(np.int8).min</span><span class="s0">, </span><span class="s1">iinfo(np.int8).max])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;int16&quot;</span><span class="s0">, </span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s1">[iinfo(np.int16).min</span><span class="s0">, </span><span class="s1">iinfo(np.int16).max])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;int32&quot;</span><span class="s0">, </span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s1">[iinfo(np.int32).min</span><span class="s0">, </span><span class="s1">iinfo(np.int32).max])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;int64&quot;</span><span class="s0">, </span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s1">[iinfo(np.int64).min</span><span class="s0">, </span><span class="s1">iinfo(np.int64).max])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;uint8&quot;</span><span class="s0">, </span><span class="s2">&quot;unsigned&quot;</span><span class="s0">, </span><span class="s1">[iinfo(np.uint8).min</span><span class="s0">, </span><span class="s1">iinfo(np.uint8).max])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;uint16&quot;</span><span class="s0">, </span><span class="s2">&quot;unsigned&quot;</span><span class="s0">, </span><span class="s1">[iinfo(np.uint16).min</span><span class="s0">, </span><span class="s1">iinfo(np.uint16).max])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;uint32&quot;</span><span class="s0">, </span><span class="s2">&quot;unsigned&quot;</span><span class="s0">, </span><span class="s1">[iinfo(np.uint32).min</span><span class="s0">, </span><span class="s1">iinfo(np.uint32).max])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;uint64&quot;</span><span class="s0">, </span><span class="s2">&quot;unsigned&quot;</span><span class="s0">, </span><span class="s1">[iinfo(np.uint64).min</span><span class="s0">, </span><span class="s1">iinfo(np.uint64).max])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;int16&quot;</span><span class="s0">, </span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s1">[iinfo(np.int8).min</span><span class="s0">, </span><span class="s1">iinfo(np.int8).max + </span><span class="s3">1</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;int32&quot;</span><span class="s0">, </span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s1">[iinfo(np.int16).min</span><span class="s0">, </span><span class="s1">iinfo(np.int16).max + </span><span class="s3">1</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;int64&quot;</span><span class="s0">, </span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s1">[iinfo(np.int32).min</span><span class="s0">, </span><span class="s1">iinfo(np.int32).max + </span><span class="s3">1</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;int16&quot;</span><span class="s0">, </span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s1">[iinfo(np.int8).min - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">iinfo(np.int16).max])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;int32&quot;</span><span class="s0">, </span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s1">[iinfo(np.int16).min - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">iinfo(np.int32).max])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;int64&quot;</span><span class="s0">, </span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s1">[iinfo(np.int32).min - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">iinfo(np.int64).max])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;uint16&quot;</span><span class="s0">, </span><span class="s2">&quot;unsigned&quot;</span><span class="s0">, </span><span class="s1">[iinfo(np.uint8).min</span><span class="s0">, </span><span class="s1">iinfo(np.uint8).max + </span><span class="s3">1</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;uint32&quot;</span><span class="s0">, </span><span class="s2">&quot;unsigned&quot;</span><span class="s0">, </span><span class="s1">[iinfo(np.uint16).min</span><span class="s0">, </span><span class="s1">iinfo(np.uint16).max + </span><span class="s3">1</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;uint64&quot;</span><span class="s0">, </span><span class="s2">&quot;unsigned&quot;</span><span class="s0">, </span><span class="s1">[iinfo(np.uint32).min</span><span class="s0">, </span><span class="s1">iinfo(np.uint32).max + </span><span class="s3">1</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_downcast_limits(dtype</span><span class="s0">, </span><span class="s1">downcast</span><span class="s0">, </span><span class="s1">min_max):</span>
    <span class="s4"># see gh-14404: test the limits of each downcast.</span>
    <span class="s1">series = to_numeric(Series(min_max)</span><span class="s0">, </span><span class="s1">downcast=downcast)</span>
    <span class="s0">assert </span><span class="s1">series.dtype == dtype</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;ser,expected&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s1">Series([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">9223372036854775808</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">Series([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">9223372036854775808</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.uint64)</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_downcast_uint64(ser</span><span class="s0">, </span><span class="s1">expected):</span>
    <span class="s4"># see gh-14422:</span>
    <span class="s4"># BUG: to_numeric doesn't work uint64 numbers</span>

    <span class="s1">result = to_numeric(ser</span><span class="s0">, </span><span class="s1">downcast=</span><span class="s2">&quot;unsigned&quot;</span><span class="s1">)</span>

    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;data,exp_data&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s1">[</span><span class="s3">200</span><span class="s0">, </span><span class="s3">300</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;NaN&quot;</span><span class="s0">, </span><span class="s3">30000000000000000000</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s3">200</span><span class="s0">, </span><span class="s3">300</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">30000000000000000000</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">[</span><span class="s2">&quot;12345678901234567890&quot;</span><span class="s0">, </span><span class="s2">&quot;1234567890&quot;</span><span class="s0">, </span><span class="s2">&quot;ITEM&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s3">12345678901234567890</span><span class="s0">, </span><span class="s3">1234567890</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_coerce_uint64_conflict(data</span><span class="s0">, </span><span class="s1">exp_data):</span>
    <span class="s4"># see gh-17007 and gh-17125</span>
    <span class="s4">#</span>
    <span class="s4"># Still returns float despite the uint64-nan conflict,</span>
    <span class="s4"># which would normally force the casting to object.</span>
    <span class="s1">result = to_numeric(Series(data)</span><span class="s0">, </span><span class="s1">errors=</span><span class="s2">&quot;coerce&quot;</span><span class="s1">)</span>
    <span class="s1">expected = Series(exp_data</span><span class="s0">, </span><span class="s1">dtype=float)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;errors,exp&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s2">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">Series([</span><span class="s2">&quot;12345678901234567890&quot;</span><span class="s0">, </span><span class="s2">&quot;1234567890&quot;</span><span class="s0">, </span><span class="s2">&quot;ITEM&quot;</span><span class="s1">]))</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">&quot;raise&quot;</span><span class="s0">, </span><span class="s2">&quot;Unable to parse string&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_non_coerce_uint64_conflict(errors</span><span class="s0">, </span><span class="s1">exp):</span>
    <span class="s4"># see gh-17007 and gh-17125</span>
    <span class="s4">#</span>
    <span class="s4"># For completeness.</span>
    <span class="s1">ser = Series([</span><span class="s2">&quot;12345678901234567890&quot;</span><span class="s0">, </span><span class="s2">&quot;1234567890&quot;</span><span class="s0">, </span><span class="s2">&quot;ITEM&quot;</span><span class="s1">])</span>

    <span class="s0">if </span><span class="s1">isinstance(exp</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=exp):</span>
            <span class="s1">to_numeric(ser</span><span class="s0">, </span><span class="s1">errors=errors)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result = to_numeric(ser</span><span class="s0">, </span><span class="s1">errors=errors)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">ser)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dc1&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s2">&quot;float&quot;</span><span class="s0">, </span><span class="s2">&quot;unsigned&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dc2&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s2">&quot;float&quot;</span><span class="s0">, </span><span class="s2">&quot;unsigned&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_downcast_empty(dc1</span><span class="s0">, </span><span class="s1">dc2):</span>
    <span class="s4"># GH32493</span>

    <span class="s1">tm.assert_numpy_array_equal(</span>
        <span class="s1">to_numeric([]</span><span class="s0">, </span><span class="s1">downcast=dc1)</span><span class="s0">,</span>
        <span class="s1">to_numeric([]</span><span class="s0">, </span><span class="s1">downcast=dc2)</span><span class="s0">,</span>
        <span class="s1">check_dtype=</span><span class="s0">False,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_failure_to_convert_uint64_string_to_NaN():</span>
    <span class="s4"># GH 32394</span>
    <span class="s1">result = to_numeric(</span><span class="s2">&quot;uint64&quot;</span><span class="s0">, </span><span class="s1">errors=</span><span class="s2">&quot;coerce&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.isnan(result)</span>

    <span class="s1">ser = Series([</span><span class="s3">32</span><span class="s0">, </span><span class="s3">64</span><span class="s0">, </span><span class="s1">np.nan])</span>
    <span class="s1">result = to_numeric(Series([</span><span class="s2">&quot;32&quot;</span><span class="s0">, </span><span class="s2">&quot;64&quot;</span><span class="s0">, </span><span class="s2">&quot;uint64&quot;</span><span class="s1">])</span><span class="s0">, </span><span class="s1">errors=</span><span class="s2">&quot;coerce&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">ser)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;strrep&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s2">&quot;243.164&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;245.968&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;249.585&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;259.745&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;265.742&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;272.567&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;279.196&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;280.366&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;275.034&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;271.351&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;272.889&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;270.627&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;280.828&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;290.383&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;308.153&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;319.945&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;336.0&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;344.09&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;351.385&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;356.178&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;359.82&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;361.03&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;367.701&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;380.812&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;387.98&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;391.749&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;391.171&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;385.97&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;385.345&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;386.121&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;390.996&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;399.734&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;413.073&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;421.532&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;430.221&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;437.092&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;439.746&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;446.01&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;451.191&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;460.463&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;469.779&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;472.025&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;479.49&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;474.864&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;467.54&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;471.978&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_precision_float_conversion(strrep):</span>
    <span class="s4"># GH 31364</span>
    <span class="s1">result = to_numeric(strrep)</span>

    <span class="s0">assert </span><span class="s1">result == float(strrep)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;values, expected&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">([</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">, </span><span class="s1">Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">np.nan]))</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s0">, </span><span class="s2">&quot;3&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]))</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]))</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s0">, </span><span class="s3">3.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3.5</span><span class="s1">]))</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s2">&quot;1&quot;</span><span class="s0">, None, </span><span class="s3">3.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">3.5</span><span class="s1">]))</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s0">, </span><span class="s2">&quot;3.5&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3.5</span><span class="s1">]))</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_to_numeric_from_nullable_string(values</span><span class="s0">, </span><span class="s1">nullable_string_dtype</span><span class="s0">, </span><span class="s1">expected):</span>
    <span class="s4"># https://github.com/pandas-dev/pandas/issues/37262</span>
    <span class="s1">s = Series(values</span><span class="s0">, </span><span class="s1">dtype=nullable_string_dtype)</span>
    <span class="s1">result = to_numeric(s)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;data, input_dtype, downcast, expected_dtype&quot;</span><span class="s0">,</span>
    <span class="s1">(</span>
        <span class="s1">([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s2">&quot;Int8&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">pd.NA]</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s0">, </span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s2">&quot;Int8&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s0">, </span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">1</span><span class="s0">, </span><span class="s1">pd.NA]</span><span class="s0">, </span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s2">&quot;Int8&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">450</span><span class="s0">, </span><span class="s3">300</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s2">&quot;Int16&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s0">, </span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s2">&quot;Int8&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([np.iinfo(np.int64).max - </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;integer&quot;</span><span class="s0">, </span><span class="s2">&quot;Int64&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;signed&quot;</span><span class="s0">, </span><span class="s2">&quot;Int8&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;Float32&quot;</span><span class="s0">, </span><span class="s2">&quot;signed&quot;</span><span class="s0">, </span><span class="s2">&quot;Int8&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s0">, </span><span class="s2">&quot;signed&quot;</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">1</span><span class="s0">, </span><span class="s1">pd.NA]</span><span class="s0">, </span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;signed&quot;</span><span class="s0">, </span><span class="s2">&quot;Int8&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">450</span><span class="s0">, </span><span class="s1">-</span><span class="s3">300</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;signed&quot;</span><span class="s0">, </span><span class="s2">&quot;Int16&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">pytest.param(</span>
            <span class="s1">[np.iinfo(np.uint64).max - </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;UInt64&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;signed&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;UInt64&quot;</span><span class="s0">,</span>
            <span class="s1">marks=pytest.mark.xfail(</span><span class="s0">not </span><span class="s1">is_platform_arm()</span><span class="s0">, </span><span class="s1">reason=</span><span class="s2">&quot;GH38798&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;unsigned&quot;</span><span class="s0">, </span><span class="s2">&quot;UInt8&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;Float32&quot;</span><span class="s0">, </span><span class="s2">&quot;unsigned&quot;</span><span class="s0">, </span><span class="s2">&quot;UInt8&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s0">, </span><span class="s2">&quot;unsigned&quot;</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">1</span><span class="s0">, </span><span class="s1">pd.NA]</span><span class="s0">, </span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;unsigned&quot;</span><span class="s0">, </span><span class="s2">&quot;UInt8&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">450</span><span class="s0">, </span><span class="s1">-</span><span class="s3">300</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;unsigned&quot;</span><span class="s0">, </span><span class="s2">&quot;Int64&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;Int32&quot;</span><span class="s0">, </span><span class="s2">&quot;unsigned&quot;</span><span class="s0">, </span><span class="s2">&quot;Int32&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s0">, </span><span class="s2">&quot;float&quot;</span><span class="s0">, </span><span class="s2">&quot;Float32&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1.1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s0">, </span><span class="s2">&quot;float&quot;</span><span class="s0">, </span><span class="s2">&quot;Float32&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_downcast_nullable_numeric(data</span><span class="s0">, </span><span class="s1">input_dtype</span><span class="s0">, </span><span class="s1">downcast</span><span class="s0">, </span><span class="s1">expected_dtype):</span>
    <span class="s1">arr = pd.array(data</span><span class="s0">, </span><span class="s1">dtype=input_dtype)</span>
    <span class="s1">result = to_numeric(arr</span><span class="s0">, </span><span class="s1">downcast=downcast)</span>
    <span class="s1">expected = pd.array(data</span><span class="s0">, </span><span class="s1">dtype=expected_dtype)</span>
    <span class="s1">tm.assert_extension_array_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_downcast_nullable_mask_is_copied():</span>
    <span class="s4"># GH38974</span>

    <span class="s1">arr = pd.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">pd.NA]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;Int64&quot;</span><span class="s1">)</span>

    <span class="s1">result = to_numeric(arr</span><span class="s0">, </span><span class="s1">downcast=</span><span class="s2">&quot;integer&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">pd.NA]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;Int8&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_extension_array_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">arr[</span><span class="s3">1</span><span class="s1">] = pd.NA  </span><span class="s4"># should not modify result</span>
    <span class="s1">tm.assert_extension_array_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_to_numeric_scientific_notation():</span>
    <span class="s4"># GH 15898</span>
    <span class="s1">result = to_numeric(</span><span class="s2">&quot;1.7e+308&quot;</span><span class="s1">)</span>
    <span class="s1">expected = np.float64(</span><span class="s3">1.7e308</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">result == expected</span>
</pre>
</body>
</html>