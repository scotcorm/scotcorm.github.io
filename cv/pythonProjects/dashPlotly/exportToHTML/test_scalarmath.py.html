<html>
<head>
<title>test_scalarmath.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_scalarmath.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">contextlib</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">import </span><span class="s1">platform</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">hypothesis </span><span class="s0">import </span><span class="s1">given</span><span class="s0">, </span><span class="s1">settings</span><span class="s0">, </span><span class="s1">Verbosity</span>
<span class="s0">from </span><span class="s1">hypothesis.strategies </span><span class="s0">import </span><span class="s1">sampled_from</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">assert_</span><span class="s0">, </span><span class="s1">assert_equal</span><span class="s0">, </span><span class="s1">assert_raises</span><span class="s0">, </span><span class="s1">assert_almost_equal</span><span class="s0">,</span>
    <span class="s1">assert_array_equal</span><span class="s0">, </span><span class="s1">IS_PYPY</span><span class="s0">, </span><span class="s1">suppress_warnings</span><span class="s0">, </span><span class="s1">_gen_alignment_data</span><span class="s0">,</span>
    <span class="s1">assert_warns</span><span class="s0">,</span>
    <span class="s1">)</span>

<span class="s1">types = [np.bool_</span><span class="s0">, </span><span class="s1">np.byte</span><span class="s0">, </span><span class="s1">np.ubyte</span><span class="s0">, </span><span class="s1">np.short</span><span class="s0">, </span><span class="s1">np.ushort</span><span class="s0">, </span><span class="s1">np.intc</span><span class="s0">, </span><span class="s1">np.uintc</span><span class="s0">,</span>
         <span class="s1">np.int_</span><span class="s0">, </span><span class="s1">np.uint</span><span class="s0">, </span><span class="s1">np.longlong</span><span class="s0">, </span><span class="s1">np.ulonglong</span><span class="s0">,</span>
         <span class="s1">np.single</span><span class="s0">, </span><span class="s1">np.double</span><span class="s0">, </span><span class="s1">np.longdouble</span><span class="s0">, </span><span class="s1">np.csingle</span><span class="s0">,</span>
         <span class="s1">np.cdouble</span><span class="s0">, </span><span class="s1">np.clongdouble]</span>

<span class="s1">floating_types = np.floating.__subclasses__()</span>
<span class="s1">complex_floating_types = np.complexfloating.__subclasses__()</span>


<span class="s2"># This compares scalarmath against ufuncs.</span>

<span class="s0">class </span><span class="s1">TestTypes:</span>
    <span class="s0">def </span><span class="s1">test_types(self):</span>
        <span class="s0">for </span><span class="s1">atype </span><span class="s0">in </span><span class="s1">types:</span>
            <span class="s1">a = atype(</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">assert_(a == </span><span class="s3">1</span><span class="s0">, </span><span class="s4">&quot;error with %r: got %r&quot; </span><span class="s1">% (atype</span><span class="s0">, </span><span class="s1">a))</span>

    <span class="s0">def </span><span class="s1">test_type_add(self):</span>
        <span class="s2"># list of types</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">atype </span><span class="s0">in </span><span class="s1">enumerate(types):</span>
            <span class="s1">a_scalar = atype(</span><span class="s3">3</span><span class="s1">)</span>
            <span class="s1">a_array = np.array([</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=atype)</span>
            <span class="s0">for </span><span class="s1">l</span><span class="s0">, </span><span class="s1">btype </span><span class="s0">in </span><span class="s1">enumerate(types):</span>
                <span class="s1">b_scalar = btype(</span><span class="s3">1</span><span class="s1">)</span>
                <span class="s1">b_array = np.array([</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=btype)</span>
                <span class="s1">c_scalar = a_scalar + b_scalar</span>
                <span class="s1">c_array = a_array + b_array</span>
                <span class="s2"># It was comparing the type numbers, but the new ufunc</span>
                <span class="s2"># function-finding mechanism finds the lowest function</span>
                <span class="s2"># to which both inputs can be cast - which produces 'l'</span>
                <span class="s2"># when you do 'q' + 'b'.  The old function finding mechanism</span>
                <span class="s2"># skipped ahead based on the first argument, but that</span>
                <span class="s2"># does not produce properly symmetric results...</span>
                <span class="s1">assert_equal(c_scalar.dtype</span><span class="s0">, </span><span class="s1">c_array.dtype</span><span class="s0">,</span>
                           <span class="s4">&quot;error with types (%d/'%c' + %d/'%c')&quot; </span><span class="s1">%</span>
                            <span class="s1">(k</span><span class="s0">, </span><span class="s1">np.dtype(atype).char</span><span class="s0">, </span><span class="s1">l</span><span class="s0">, </span><span class="s1">np.dtype(btype).char))</span>

    <span class="s0">def </span><span class="s1">test_type_create(self):</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">atype </span><span class="s0">in </span><span class="s1">enumerate(types):</span>
            <span class="s1">a = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atype)</span>
            <span class="s1">b = atype([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
            <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s0">def </span><span class="s1">test_leak(self):</span>
        <span class="s2"># test leak of scalar objects</span>
        <span class="s2"># a leak would show up in valgrind as still-reachable of ~2.6MB</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">200000</span><span class="s1">):</span>
            <span class="s1">np.add(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestBaseMath:</span>
    <span class="s0">def </span><span class="s1">test_blocked(self):</span>
        <span class="s2"># test alignments offsets for simd instructions</span>
        <span class="s2"># alignments for vz + 2 * (vs - 1) + 1</span>
        <span class="s0">for </span><span class="s1">dt</span><span class="s0">, </span><span class="s1">sz </span><span class="s0">in </span><span class="s1">[(np.float32</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(np.float64</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(np.int32</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)]:</span>
            <span class="s0">for </span><span class="s1">out</span><span class="s0">, </span><span class="s1">inp1</span><span class="s0">, </span><span class="s1">inp2</span><span class="s0">, </span><span class="s1">msg </span><span class="s0">in </span><span class="s1">_gen_alignment_data(dtype=dt</span><span class="s0">,</span>
                                                            <span class="s1">type=</span><span class="s4">'binary'</span><span class="s0">,</span>
                                                            <span class="s1">max_size=sz):</span>
                <span class="s1">exp1 = np.ones_like(inp1)</span>
                <span class="s1">inp1[...] = np.ones_like(inp1)</span>
                <span class="s1">inp2[...] = np.zeros_like(inp2)</span>
                <span class="s1">assert_almost_equal(np.add(inp1</span><span class="s0">, </span><span class="s1">inp2)</span><span class="s0">, </span><span class="s1">exp1</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
                <span class="s1">assert_almost_equal(np.add(inp1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">exp1 + </span><span class="s3">2</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
                <span class="s1">assert_almost_equal(np.add(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">inp2)</span><span class="s0">, </span><span class="s1">exp1</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

                <span class="s1">np.add(inp1</span><span class="s0">, </span><span class="s1">inp2</span><span class="s0">, </span><span class="s1">out=out)</span>
                <span class="s1">assert_almost_equal(out</span><span class="s0">, </span><span class="s1">exp1</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

                <span class="s1">inp2[...] += np.arange(inp2.size</span><span class="s0">, </span><span class="s1">dtype=dt) + </span><span class="s3">1</span>
                <span class="s1">assert_almost_equal(np.square(inp2)</span><span class="s0">,</span>
                                    <span class="s1">np.multiply(inp2</span><span class="s0">, </span><span class="s1">inp2)</span><span class="s0">,  </span><span class="s1">err_msg=msg)</span>
                <span class="s2"># skip true divide for ints</span>
                <span class="s0">if </span><span class="s1">dt != np.int32:</span>
                    <span class="s1">assert_almost_equal(np.reciprocal(inp2)</span><span class="s0">,</span>
                                        <span class="s1">np.divide(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">inp2)</span><span class="s0">,  </span><span class="s1">err_msg=msg)</span>

                <span class="s1">inp1[...] = np.ones_like(inp1)</span>
                <span class="s1">np.add(inp1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">out=out)</span>
                <span class="s1">assert_almost_equal(out</span><span class="s0">, </span><span class="s1">exp1 + </span><span class="s3">2</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
                <span class="s1">inp2[...] = np.ones_like(inp2)</span>
                <span class="s1">np.add(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">inp2</span><span class="s0">, </span><span class="s1">out=out)</span>
                <span class="s1">assert_almost_equal(out</span><span class="s0">, </span><span class="s1">exp1 + </span><span class="s3">2</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

    <span class="s0">def </span><span class="s1">test_lower_align(self):</span>
        <span class="s2"># check data that is not aligned to element size</span>
        <span class="s2"># i.e doubles are aligned to 4 bytes on i386</span>
        <span class="s1">d = np.zeros(</span><span class="s3">23 </span><span class="s1">* </span><span class="s3">8</span><span class="s0">, </span><span class="s1">dtype=np.int8)[</span><span class="s3">4</span><span class="s1">:-</span><span class="s3">4</span><span class="s1">].view(np.float64)</span>
        <span class="s1">o = np.zeros(</span><span class="s3">23 </span><span class="s1">* </span><span class="s3">8</span><span class="s0">, </span><span class="s1">dtype=np.int8)[</span><span class="s3">4</span><span class="s1">:-</span><span class="s3">4</span><span class="s1">].view(np.float64)</span>
        <span class="s1">assert_almost_equal(d + d</span><span class="s0">, </span><span class="s1">d * </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">np.add(d</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">out=o)</span>
        <span class="s1">np.add(np.ones_like(d)</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">out=o)</span>
        <span class="s1">np.add(d</span><span class="s0">, </span><span class="s1">np.ones_like(d)</span><span class="s0">, </span><span class="s1">out=o)</span>
        <span class="s1">np.add(np.ones_like(d)</span><span class="s0">, </span><span class="s1">d)</span>
        <span class="s1">np.add(d</span><span class="s0">, </span><span class="s1">np.ones_like(d))</span>


<span class="s0">class </span><span class="s1">TestPower:</span>
    <span class="s0">def </span><span class="s1">test_small_types(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">[np.int8</span><span class="s0">, </span><span class="s1">np.int16</span><span class="s0">, </span><span class="s1">np.float16]:</span>
            <span class="s1">a = t(</span><span class="s3">3</span><span class="s1">)</span>
            <span class="s1">b = a ** </span><span class="s3">4</span>
            <span class="s1">assert_(b == </span><span class="s3">81</span><span class="s0">, </span><span class="s4">&quot;error with %r: got %r&quot; </span><span class="s1">% (t</span><span class="s0">, </span><span class="s1">b))</span>

    <span class="s0">def </span><span class="s1">test_large_types(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">[np.int32</span><span class="s0">, </span><span class="s1">np.int64</span><span class="s0">, </span><span class="s1">np.float32</span><span class="s0">, </span><span class="s1">np.float64</span><span class="s0">, </span><span class="s1">np.longdouble]:</span>
            <span class="s1">a = t(</span><span class="s3">51</span><span class="s1">)</span>
            <span class="s1">b = a ** </span><span class="s3">4</span>
            <span class="s1">msg = </span><span class="s4">&quot;error with %r: got %r&quot; </span><span class="s1">% (t</span><span class="s0">, </span><span class="s1">b)</span>
            <span class="s0">if </span><span class="s1">np.issubdtype(t</span><span class="s0">, </span><span class="s1">np.integer):</span>
                <span class="s1">assert_(b == </span><span class="s3">6765201</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assert_almost_equal(b</span><span class="s0">, </span><span class="s3">6765201</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

    <span class="s0">def </span><span class="s1">test_integers_to_negative_integer_power(self):</span>
        <span class="s2"># Note that the combination of uint64 with a signed integer</span>
        <span class="s2"># has common type np.float64. The other combinations should all</span>
        <span class="s2"># raise a ValueError for integer ** negative integer.</span>
        <span class="s1">exp = [np.array(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dt)[()] </span><span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s4">'bhilq'</span><span class="s1">]</span>

        <span class="s2"># 1 ** -1 possible special case</span>
        <span class="s1">base = [np.array(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dt)[()] </span><span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s4">'bhilqBHILQ'</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">i1</span><span class="s0">, </span><span class="s1">i2 </span><span class="s0">in </span><span class="s1">itertools.product(base</span><span class="s0">, </span><span class="s1">exp):</span>
            <span class="s0">if </span><span class="s1">i1.dtype != np.uint64:</span>
                <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">operator.pow</span><span class="s0">, </span><span class="s1">i1</span><span class="s0">, </span><span class="s1">i2)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">res = operator.pow(i1</span><span class="s0">, </span><span class="s1">i2)</span>
                <span class="s1">assert_(res.dtype.type </span><span class="s0">is </span><span class="s1">np.float64)</span>
                <span class="s1">assert_almost_equal(res</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">)</span>

        <span class="s2"># -1 ** -1 possible special case</span>
        <span class="s1">base = [np.array(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dt)[()] </span><span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s4">'bhilq'</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">i1</span><span class="s0">, </span><span class="s1">i2 </span><span class="s0">in </span><span class="s1">itertools.product(base</span><span class="s0">, </span><span class="s1">exp):</span>
            <span class="s0">if </span><span class="s1">i1.dtype != np.uint64:</span>
                <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">operator.pow</span><span class="s0">, </span><span class="s1">i1</span><span class="s0">, </span><span class="s1">i2)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">res = operator.pow(i1</span><span class="s0">, </span><span class="s1">i2)</span>
                <span class="s1">assert_(res.dtype.type </span><span class="s0">is </span><span class="s1">np.float64)</span>
                <span class="s1">assert_almost_equal(res</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.</span><span class="s1">)</span>

        <span class="s2"># 2 ** -1 perhaps generic</span>
        <span class="s1">base = [np.array(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">dt)[()] </span><span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s4">'bhilqBHILQ'</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">i1</span><span class="s0">, </span><span class="s1">i2 </span><span class="s0">in </span><span class="s1">itertools.product(base</span><span class="s0">, </span><span class="s1">exp):</span>
            <span class="s0">if </span><span class="s1">i1.dtype != np.uint64:</span>
                <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">operator.pow</span><span class="s0">, </span><span class="s1">i1</span><span class="s0">, </span><span class="s1">i2)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">res = operator.pow(i1</span><span class="s0">, </span><span class="s1">i2)</span>
                <span class="s1">assert_(res.dtype.type </span><span class="s0">is </span><span class="s1">np.float64)</span>
                <span class="s1">assert_almost_equal(res</span><span class="s0">, </span><span class="s3">.5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_mixed_types(self):</span>
        <span class="s1">typelist = [np.int8</span><span class="s0">, </span><span class="s1">np.int16</span><span class="s0">, </span><span class="s1">np.float16</span><span class="s0">,</span>
                    <span class="s1">np.float32</span><span class="s0">, </span><span class="s1">np.float64</span><span class="s0">, </span><span class="s1">np.int8</span><span class="s0">,</span>
                    <span class="s1">np.int16</span><span class="s0">, </span><span class="s1">np.int32</span><span class="s0">, </span><span class="s1">np.int64]</span>
        <span class="s0">for </span><span class="s1">t1 </span><span class="s0">in </span><span class="s1">typelist:</span>
            <span class="s0">for </span><span class="s1">t2 </span><span class="s0">in </span><span class="s1">typelist:</span>
                <span class="s1">a = t1(</span><span class="s3">3</span><span class="s1">)</span>
                <span class="s1">b = t2(</span><span class="s3">2</span><span class="s1">)</span>
                <span class="s1">result = a**b</span>
                <span class="s1">msg = (</span><span class="s4">&quot;error with %r and %r:&quot;</span>
                       <span class="s4">&quot;got %r, expected %r&quot;</span><span class="s1">) % (t1</span><span class="s0">, </span><span class="s1">t2</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">np.issubdtype(np.dtype(result)</span><span class="s0">, </span><span class="s1">np.integer):</span>
                    <span class="s1">assert_(result == </span><span class="s3">9</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">assert_almost_equal(result</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

    <span class="s0">def </span><span class="s1">test_modular_power(self):</span>
        <span class="s2"># modular power is not implemented, so ensure it errors</span>
        <span class="s1">a = </span><span class="s3">5</span>
        <span class="s1">b = </span><span class="s3">4</span>
        <span class="s1">c = </span><span class="s3">10</span>
        <span class="s1">expected = pow(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c)  </span><span class="s2"># noqa: F841</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">(np.int32</span><span class="s0">, </span><span class="s1">np.float32</span><span class="s0">, </span><span class="s1">np.complex64):</span>
            <span class="s2"># note that 3-operand power only dispatches on the first argument</span>
            <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">operator.pow</span><span class="s0">, </span><span class="s1">t(a)</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c)</span>
            <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">operator.pow</span><span class="s0">, </span><span class="s1">np.array(t(a))</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c)</span>


<span class="s0">def </span><span class="s1">floordiv_and_mod(x</span><span class="s0">, </span><span class="s1">y):</span>
    <span class="s0">return </span><span class="s1">(x // y</span><span class="s0">, </span><span class="s1">x % y)</span>


<span class="s0">def </span><span class="s1">_signs(dt):</span>
    <span class="s0">if </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">np.typecodes[</span><span class="s4">'UnsignedInteger'</span><span class="s1">]:</span>
        <span class="s0">return </span><span class="s1">(+</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">(+</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestModulus:</span>

    <span class="s0">def </span><span class="s1">test_modulus_basic(self):</span>
        <span class="s1">dt = np.typecodes[</span><span class="s4">'AllInteger'</span><span class="s1">] + np.typecodes[</span><span class="s4">'Float'</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">[floordiv_and_mod</span><span class="s0">, </span><span class="s1">divmod]:</span>
            <span class="s0">for </span><span class="s1">dt1</span><span class="s0">, </span><span class="s1">dt2 </span><span class="s0">in </span><span class="s1">itertools.product(dt</span><span class="s0">, </span><span class="s1">dt):</span>
                <span class="s0">for </span><span class="s1">sg1</span><span class="s0">, </span><span class="s1">sg2 </span><span class="s0">in </span><span class="s1">itertools.product(_signs(dt1)</span><span class="s0">, </span><span class="s1">_signs(dt2)):</span>
                    <span class="s1">fmt = </span><span class="s4">'op: %s, dt1: %s, dt2: %s, sg1: %s, sg2: %s'</span>
                    <span class="s1">msg = fmt % (op.__name__</span><span class="s0">, </span><span class="s1">dt1</span><span class="s0">, </span><span class="s1">dt2</span><span class="s0">, </span><span class="s1">sg1</span><span class="s0">, </span><span class="s1">sg2)</span>
                    <span class="s1">a = np.array(sg1*</span><span class="s3">71</span><span class="s0">, </span><span class="s1">dtype=dt1)[()]</span>
                    <span class="s1">b = np.array(sg2*</span><span class="s3">19</span><span class="s0">, </span><span class="s1">dtype=dt2)[()]</span>
                    <span class="s1">div</span><span class="s0">, </span><span class="s1">rem = op(a</span><span class="s0">, </span><span class="s1">b)</span>
                    <span class="s1">assert_equal(div*b + rem</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
                    <span class="s0">if </span><span class="s1">sg2 == -</span><span class="s3">1</span><span class="s1">:</span>
                        <span class="s1">assert_(b &lt; rem &lt;= </span><span class="s3">0</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">assert_(b &gt; rem &gt;= </span><span class="s3">0</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_float_modulus_exact(self):</span>
        <span class="s2"># test that float results are exact for small integers. This also</span>
        <span class="s2"># holds for the same integers scaled by powers of two.</span>
        <span class="s1">nlst = list(range(-</span><span class="s3">127</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">plst = list(range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">128</span><span class="s1">))</span>
        <span class="s1">dividend = nlst + [</span><span class="s3">0</span><span class="s1">] + plst</span>
        <span class="s1">divisor = nlst + plst</span>
        <span class="s1">arg = list(itertools.product(dividend</span><span class="s0">, </span><span class="s1">divisor))</span>
        <span class="s1">tgt = list(divmod(*t) </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">arg)</span>

        <span class="s1">a</span><span class="s0">, </span><span class="s1">b = np.array(arg</span><span class="s0">, </span><span class="s1">dtype=int).T</span>
        <span class="s2"># convert exact integer results from Python to float so that</span>
        <span class="s2"># signed zero can be used, it is checked.</span>
        <span class="s1">tgtdiv</span><span class="s0">, </span><span class="s1">tgtrem = np.array(tgt</span><span class="s0">, </span><span class="s1">dtype=float).T</span>
        <span class="s1">tgtdiv = np.where((tgtdiv == </span><span class="s3">0.0</span><span class="s1">) &amp; ((b &lt; </span><span class="s3">0</span><span class="s1">) ^ (a &lt; </span><span class="s3">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">tgtdiv)</span>
        <span class="s1">tgtrem = np.where((tgtrem == </span><span class="s3">0.0</span><span class="s1">) &amp; (b &lt; </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">tgtrem)</span>

        <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">[floordiv_and_mod</span><span class="s0">, </span><span class="s1">divmod]:</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">np.typecodes[</span><span class="s4">'Float'</span><span class="s1">]:</span>
                <span class="s1">msg = </span><span class="s4">'op: %s, dtype: %s' </span><span class="s1">% (op.__name__</span><span class="s0">, </span><span class="s1">dt)</span>
                <span class="s1">fa = a.astype(dt)</span>
                <span class="s1">fb = b.astype(dt)</span>
                <span class="s2"># use list comprehension so a_ and b_ are scalars</span>
                <span class="s1">div</span><span class="s0">, </span><span class="s1">rem = zip(*[op(a_</span><span class="s0">, </span><span class="s1">b_) </span><span class="s0">for  </span><span class="s1">a_</span><span class="s0">, </span><span class="s1">b_ </span><span class="s0">in </span><span class="s1">zip(fa</span><span class="s0">, </span><span class="s1">fb)])</span>
                <span class="s1">assert_equal(div</span><span class="s0">, </span><span class="s1">tgtdiv</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
                <span class="s1">assert_equal(rem</span><span class="s0">, </span><span class="s1">tgtrem</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

    <span class="s0">def </span><span class="s1">test_float_modulus_roundoff(self):</span>
        <span class="s2"># gh-6127</span>
        <span class="s1">dt = np.typecodes[</span><span class="s4">'Float'</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">[floordiv_and_mod</span><span class="s0">, </span><span class="s1">divmod]:</span>
            <span class="s0">for </span><span class="s1">dt1</span><span class="s0">, </span><span class="s1">dt2 </span><span class="s0">in </span><span class="s1">itertools.product(dt</span><span class="s0">, </span><span class="s1">dt):</span>
                <span class="s0">for </span><span class="s1">sg1</span><span class="s0">, </span><span class="s1">sg2 </span><span class="s0">in </span><span class="s1">itertools.product((+</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(+</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)):</span>
                    <span class="s1">fmt = </span><span class="s4">'op: %s, dt1: %s, dt2: %s, sg1: %s, sg2: %s'</span>
                    <span class="s1">msg = fmt % (op.__name__</span><span class="s0">, </span><span class="s1">dt1</span><span class="s0">, </span><span class="s1">dt2</span><span class="s0">, </span><span class="s1">sg1</span><span class="s0">, </span><span class="s1">sg2)</span>
                    <span class="s1">a = np.array(sg1*</span><span class="s3">78</span><span class="s1">*</span><span class="s3">6e-8</span><span class="s0">, </span><span class="s1">dtype=dt1)[()]</span>
                    <span class="s1">b = np.array(sg2*</span><span class="s3">6e-8</span><span class="s0">, </span><span class="s1">dtype=dt2)[()]</span>
                    <span class="s1">div</span><span class="s0">, </span><span class="s1">rem = op(a</span><span class="s0">, </span><span class="s1">b)</span>
                    <span class="s2"># Equal assertion should hold when fmod is used</span>
                    <span class="s1">assert_equal(div*b + rem</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
                    <span class="s0">if </span><span class="s1">sg2 == -</span><span class="s3">1</span><span class="s1">:</span>
                        <span class="s1">assert_(b &lt; rem &lt;= </span><span class="s3">0</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">assert_(b &gt; rem &gt;= </span><span class="s3">0</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_float_modulus_corner_cases(self):</span>
        <span class="s2"># Check remainder magnitude.</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">np.typecodes[</span><span class="s4">'Float'</span><span class="s1">]:</span>
            <span class="s1">b = np.array(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">a = np.nextafter(np.array(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">dtype=dt)</span><span class="s0">, </span><span class="s1">-b)</span>
            <span class="s1">rem = operator.mod(a</span><span class="s0">, </span><span class="s1">b)</span>
            <span class="s1">assert_(rem &lt;= b</span><span class="s0">, </span><span class="s4">'dt: %s' </span><span class="s1">% dt)</span>
            <span class="s1">rem = operator.mod(-a</span><span class="s0">, </span><span class="s1">-b)</span>
            <span class="s1">assert_(rem &gt;= -b</span><span class="s0">, </span><span class="s4">'dt: %s' </span><span class="s1">% dt)</span>

        <span class="s2"># Check nans, inf</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in remainder&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;divide by zero encountered in remainder&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;divide by zero encountered in floor_divide&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;divide by zero encountered in divmod&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in divmod&quot;</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">np.typecodes[</span><span class="s4">'Float'</span><span class="s1">]:</span>
                <span class="s1">fone = np.array(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">fzer = np.array(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">finf = np.array(np.inf</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">fnan = np.array(np.nan</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">rem = operator.mod(fone</span><span class="s0">, </span><span class="s1">fzer)</span>
                <span class="s1">assert_(np.isnan(rem)</span><span class="s0">, </span><span class="s4">'dt: %s' </span><span class="s1">% dt)</span>
                <span class="s2"># MSVC 2008 returns NaN here, so disable the check.</span>
                <span class="s2">#rem = operator.mod(fone, finf)</span>
                <span class="s2">#assert_(rem == fone, 'dt: %s' % dt)</span>
                <span class="s1">rem = operator.mod(fone</span><span class="s0">, </span><span class="s1">fnan)</span>
                <span class="s1">assert_(np.isnan(rem)</span><span class="s0">, </span><span class="s4">'dt: %s' </span><span class="s1">% dt)</span>
                <span class="s1">rem = operator.mod(finf</span><span class="s0">, </span><span class="s1">fone)</span>
                <span class="s1">assert_(np.isnan(rem)</span><span class="s0">, </span><span class="s4">'dt: %s' </span><span class="s1">% dt)</span>
                <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">[floordiv_and_mod</span><span class="s0">, </span><span class="s1">divmod]:</span>
                    <span class="s1">div</span><span class="s0">, </span><span class="s1">mod = op(fone</span><span class="s0">, </span><span class="s1">fzer)</span>
                    <span class="s1">assert_(np.isinf(div)) </span><span class="s0">and </span><span class="s1">assert_(np.isnan(mod))</span>

    <span class="s0">def </span><span class="s1">test_inplace_floordiv_handling(self):</span>
        <span class="s2"># issue gh-12927</span>
        <span class="s2"># this only applies to in-place floordiv //=, because the output type</span>
        <span class="s2"># promotes to float which does not fit</span>
        <span class="s1">a = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.int64)</span>
        <span class="s1">b = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.uint64)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">,</span>
                <span class="s1">match=</span><span class="s4">r&quot;Cannot cast ufunc 'floor_divide' output from&quot;</span><span class="s1">):</span>
            <span class="s1">a //= b</span>


<span class="s0">class </span><span class="s1">TestComplexDivision:</span>
    <span class="s0">def </span><span class="s1">test_zero_division(self):</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s4">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">[np.complex64</span><span class="s0">, </span><span class="s1">np.complex128]:</span>
                <span class="s1">a = t(</span><span class="s3">0.0</span><span class="s1">)</span>
                <span class="s1">b = t(</span><span class="s3">1.0</span><span class="s1">)</span>
                <span class="s1">assert_(np.isinf(b/a))</span>
                <span class="s1">b = t(complex(np.inf</span><span class="s0">, </span><span class="s1">np.inf))</span>
                <span class="s1">assert_(np.isinf(b/a))</span>
                <span class="s1">b = t(complex(np.inf</span><span class="s0">, </span><span class="s1">np.nan))</span>
                <span class="s1">assert_(np.isinf(b/a))</span>
                <span class="s1">b = t(complex(np.nan</span><span class="s0">, </span><span class="s1">np.inf))</span>
                <span class="s1">assert_(np.isinf(b/a))</span>
                <span class="s1">b = t(complex(np.nan</span><span class="s0">, </span><span class="s1">np.nan))</span>
                <span class="s1">assert_(np.isnan(b/a))</span>
                <span class="s1">b = t(</span><span class="s3">0.</span><span class="s1">)</span>
                <span class="s1">assert_(np.isnan(b/a))</span>

    <span class="s0">def </span><span class="s1">test_signed_zeros(self):</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s4">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">[np.complex64</span><span class="s0">, </span><span class="s1">np.complex128]:</span>
                <span class="s2"># tupled (numerator, denominator, expected)</span>
                <span class="s2"># for testing as expected == numerator/denominator</span>
                <span class="s1">data = (</span>
                    <span class="s1">(( </span><span class="s3">0.0</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">( </span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1.0</span><span class="s0">,</span><span class="s1">-</span><span class="s3">0.0</span><span class="s1">))</span><span class="s0">,</span>
                    <span class="s1">(( </span><span class="s3">0.0</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">( </span><span class="s3">0.0</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">( </span><span class="s3">1.0</span><span class="s0">,</span><span class="s1">-</span><span class="s3">0.0</span><span class="s1">))</span><span class="s0">,</span>
                    <span class="s1">(( </span><span class="s3">0.0</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">0.0</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">( </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">))</span><span class="s0">,</span>
                    <span class="s1">(( </span><span class="s3">0.0</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">))</span><span class="s0">,</span>
                    <span class="s1">(( </span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">( </span><span class="s3">0.0</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">))</span><span class="s0">,</span>
                    <span class="s1">(( </span><span class="s3">0.0</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">( </span><span class="s3">0.0</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">( </span><span class="s3">1.0</span><span class="s0">,</span><span class="s1">-</span><span class="s3">0.0</span><span class="s1">))</span><span class="s0">,</span>
                    <span class="s1">((-</span><span class="s3">0.0</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">( </span><span class="s3">0.0</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">( </span><span class="s3">1.0</span><span class="s0">,</span><span class="s1">-</span><span class="s3">0.0</span><span class="s1">))</span><span class="s0">,</span>
                    <span class="s1">((-</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">( </span><span class="s3">0.0</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1.0</span><span class="s0">,</span><span class="s1">-</span><span class="s3">0.0</span><span class="s1">))</span>
                <span class="s1">)</span>
                <span class="s0">for </span><span class="s1">cases </span><span class="s0">in </span><span class="s1">data:</span>
                    <span class="s1">n = cases[</span><span class="s3">0</span><span class="s1">]</span>
                    <span class="s1">d = cases[</span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s1">ex = cases[</span><span class="s3">2</span><span class="s1">]</span>
                    <span class="s1">result = t(complex(n[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">n[</span><span class="s3">1</span><span class="s1">])) / t(complex(d[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">d[</span><span class="s3">1</span><span class="s1">]))</span>
                    <span class="s2"># check real and imag parts separately to avoid comparison</span>
                    <span class="s2"># in array context, which does not account for signed zeros</span>
                    <span class="s1">assert_equal(result.real</span><span class="s0">, </span><span class="s1">ex[</span><span class="s3">0</span><span class="s1">])</span>
                    <span class="s1">assert_equal(result.imag</span><span class="s0">, </span><span class="s1">ex[</span><span class="s3">1</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_branches(self):</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s4">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">[np.complex64</span><span class="s0">, </span><span class="s1">np.complex128]:</span>
                <span class="s2"># tupled (numerator, denominator, expected)</span>
                <span class="s2"># for testing as expected == numerator/denominator</span>
                <span class="s1">data = list()</span>

                <span class="s2"># trigger branch: real(fabs(denom)) &gt; imag(fabs(denom))</span>
                <span class="s2"># followed by else condition as neither are == 0</span>
                <span class="s1">data.append((( </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">( </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">)))</span>

                <span class="s2"># trigger branch: real(fabs(denom)) &gt; imag(fabs(denom))</span>
                <span class="s2"># followed by if condition as both are == 0</span>
                <span class="s2"># is performed in test_zero_division(), so this is skipped</span>

                <span class="s2"># trigger else if branch: real(fabs(denom)) &lt; imag(fabs(denom))</span>
                <span class="s1">data.append((( </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">( </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">)))</span>

                <span class="s0">for </span><span class="s1">cases </span><span class="s0">in </span><span class="s1">data:</span>
                    <span class="s1">n = cases[</span><span class="s3">0</span><span class="s1">]</span>
                    <span class="s1">d = cases[</span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s1">ex = cases[</span><span class="s3">2</span><span class="s1">]</span>
                    <span class="s1">result = t(complex(n[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">n[</span><span class="s3">1</span><span class="s1">])) / t(complex(d[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">d[</span><span class="s3">1</span><span class="s1">]))</span>
                    <span class="s2"># check real and imag parts separately to avoid comparison</span>
                    <span class="s2"># in array context, which does not account for signed zeros</span>
                    <span class="s1">assert_equal(result.real</span><span class="s0">, </span><span class="s1">ex[</span><span class="s3">0</span><span class="s1">])</span>
                    <span class="s1">assert_equal(result.imag</span><span class="s0">, </span><span class="s1">ex[</span><span class="s3">1</span><span class="s1">])</span>


<span class="s0">class </span><span class="s1">TestConversion:</span>
    <span class="s0">def </span><span class="s1">test_int_from_long(self):</span>
        <span class="s1">l = [</span><span class="s3">1e6</span><span class="s0">, </span><span class="s3">1e12</span><span class="s0">, </span><span class="s3">1e18</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1e6</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1e12</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1e18</span><span class="s1">]</span>
        <span class="s1">li = [</span><span class="s3">10</span><span class="s1">**</span><span class="s3">6</span><span class="s0">, </span><span class="s3">10</span><span class="s1">**</span><span class="s3">12</span><span class="s0">, </span><span class="s3">10</span><span class="s1">**</span><span class="s3">18</span><span class="s0">, </span><span class="s1">-</span><span class="s3">10</span><span class="s1">**</span><span class="s3">6</span><span class="s0">, </span><span class="s1">-</span><span class="s3">10</span><span class="s1">**</span><span class="s3">12</span><span class="s0">, </span><span class="s1">-</span><span class="s3">10</span><span class="s1">**</span><span class="s3">18</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">T </span><span class="s0">in </span><span class="s1">[</span><span class="s0">None, </span><span class="s1">np.float64</span><span class="s0">, </span><span class="s1">np.int64]:</span>
            <span class="s1">a = np.array(l</span><span class="s0">, </span><span class="s1">dtype=T)</span>
            <span class="s1">assert_equal([int(_m) </span><span class="s0">for </span><span class="s1">_m </span><span class="s0">in </span><span class="s1">a]</span><span class="s0">, </span><span class="s1">li)</span>

        <span class="s1">a = np.array(l[:</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.uint64)</span>
        <span class="s1">assert_equal([int(_m) </span><span class="s0">for </span><span class="s1">_m </span><span class="s0">in </span><span class="s1">a]</span><span class="s0">, </span><span class="s1">li[:</span><span class="s3">3</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_iinfo_long_values(self):</span>
        <span class="s0">for </span><span class="s1">code </span><span class="s0">in </span><span class="s4">'bBhH'</span><span class="s1">:</span>
            <span class="s1">res = np.array(np.iinfo(code).max + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=code)</span>
            <span class="s1">tgt = np.iinfo(code).min</span>
            <span class="s1">assert_(res == tgt)</span>

        <span class="s0">for </span><span class="s1">code </span><span class="s0">in </span><span class="s1">np.typecodes[</span><span class="s4">'AllInteger'</span><span class="s1">]:</span>
            <span class="s1">res = np.array(np.iinfo(code).max</span><span class="s0">, </span><span class="s1">dtype=code)</span>
            <span class="s1">tgt = np.iinfo(code).max</span>
            <span class="s1">assert_(res == tgt)</span>

        <span class="s0">for </span><span class="s1">code </span><span class="s0">in </span><span class="s1">np.typecodes[</span><span class="s4">'AllInteger'</span><span class="s1">]:</span>
            <span class="s1">res = np.dtype(code).type(np.iinfo(code).max)</span>
            <span class="s1">tgt = np.iinfo(code).max</span>
            <span class="s1">assert_(res == tgt)</span>

    <span class="s0">def </span><span class="s1">test_int_raise_behaviour(self):</span>
        <span class="s0">def </span><span class="s1">overflow_error_func(dtype):</span>
            <span class="s1">dtype(np.iinfo(dtype).max + </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">code </span><span class="s0">in </span><span class="s1">[np.int_</span><span class="s0">, </span><span class="s1">np.uint</span><span class="s0">, </span><span class="s1">np.longlong</span><span class="s0">, </span><span class="s1">np.ulonglong]:</span>
            <span class="s1">assert_raises(OverflowError</span><span class="s0">, </span><span class="s1">overflow_error_func</span><span class="s0">, </span><span class="s1">code)</span>

    <span class="s0">def </span><span class="s1">test_int_from_infinite_longdouble(self):</span>
        <span class="s2"># gh-627</span>
        <span class="s1">x = np.longdouble(np.inf)</span>
        <span class="s1">assert_raises(OverflowError</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.record(np.ComplexWarning)</span>
            <span class="s1">x = np.clongdouble(np.inf)</span>
            <span class="s1">assert_raises(OverflowError</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">x)</span>
            <span class="s1">assert_equal(len(sup.log)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">IS_PYPY</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;Test is PyPy only (gh-9972)&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_int_from_infinite_longdouble___int__(self):</span>
        <span class="s1">x = np.longdouble(np.inf)</span>
        <span class="s1">assert_raises(OverflowError</span><span class="s0">, </span><span class="s1">x.__int__)</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.record(np.ComplexWarning)</span>
            <span class="s1">x = np.clongdouble(np.inf)</span>
            <span class="s1">assert_raises(OverflowError</span><span class="s0">, </span><span class="s1">x.__int__)</span>
            <span class="s1">assert_equal(len(sup.log)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.skipif(np.finfo(np.double) == np.finfo(np.longdouble)</span><span class="s0">,</span>
                        <span class="s1">reason=</span><span class="s4">&quot;long double is same as double&quot;</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.skipif(platform.machine().startswith(</span><span class="s4">&quot;ppc&quot;</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">reason=</span><span class="s4">&quot;IBM double double&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_int_from_huge_longdouble(self):</span>
        <span class="s2"># Produce a longdouble that would overflow a double,</span>
        <span class="s2"># use exponent that avoids bug in Darwin pow function.</span>
        <span class="s1">exp = np.finfo(np.double).maxexp - </span><span class="s3">1</span>
        <span class="s1">huge_ld = </span><span class="s3">2 </span><span class="s1">* </span><span class="s3">1234 </span><span class="s1">* np.longdouble(</span><span class="s3">2</span><span class="s1">) ** exp</span>
        <span class="s1">huge_i = </span><span class="s3">2 </span><span class="s1">* </span><span class="s3">1234 </span><span class="s1">* </span><span class="s3">2 </span><span class="s1">** exp</span>
        <span class="s1">assert_(huge_ld != np.inf)</span>
        <span class="s1">assert_equal(int(huge_ld)</span><span class="s0">, </span><span class="s1">huge_i)</span>

    <span class="s0">def </span><span class="s1">test_int_from_longdouble(self):</span>
        <span class="s1">x = np.longdouble(</span><span class="s3">1.5</span><span class="s1">)</span>
        <span class="s1">assert_equal(int(x)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">x = np.longdouble(-</span><span class="s3">10.5</span><span class="s1">)</span>
        <span class="s1">assert_equal(int(x)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">10</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_numpy_scalar_relational_operators(self):</span>
        <span class="s2"># All integer</span>
        <span class="s0">for </span><span class="s1">dt1 </span><span class="s0">in </span><span class="s1">np.typecodes[</span><span class="s4">'AllInteger'</span><span class="s1">]:</span>
            <span class="s1">assert_(</span><span class="s3">1 </span><span class="s1">&gt; np.array(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">dtype=dt1)[()]</span><span class="s0">, </span><span class="s4">&quot;type %s failed&quot; </span><span class="s1">% (dt1</span><span class="s0">,</span><span class="s1">))</span>
            <span class="s1">assert_(</span><span class="s0">not </span><span class="s3">1 </span><span class="s1">&lt; np.array(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">dtype=dt1)[()]</span><span class="s0">, </span><span class="s4">&quot;type %s failed&quot; </span><span class="s1">% (dt1</span><span class="s0">,</span><span class="s1">))</span>

            <span class="s0">for </span><span class="s1">dt2 </span><span class="s0">in </span><span class="s1">np.typecodes[</span><span class="s4">'AllInteger'</span><span class="s1">]:</span>
                <span class="s1">assert_(np.array(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt1)[()] &gt; np.array(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">dtype=dt2)[()]</span><span class="s0">,</span>
                        <span class="s4">&quot;type %s and %s failed&quot; </span><span class="s1">% (dt1</span><span class="s0">, </span><span class="s1">dt2))</span>
                <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">np.array(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt1)[()] &lt; np.array(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">dtype=dt2)[()]</span><span class="s0">,</span>
                        <span class="s4">&quot;type %s and %s failed&quot; </span><span class="s1">% (dt1</span><span class="s0">, </span><span class="s1">dt2))</span>

        <span class="s2">#Unsigned integers</span>
        <span class="s0">for </span><span class="s1">dt1 </span><span class="s0">in </span><span class="s4">'BHILQP'</span><span class="s1">:</span>
            <span class="s1">assert_(-</span><span class="s3">1 </span><span class="s1">&lt; np.array(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt1)[()]</span><span class="s0">, </span><span class="s4">&quot;type %s failed&quot; </span><span class="s1">% (dt1</span><span class="s0">,</span><span class="s1">))</span>
            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">-</span><span class="s3">1 </span><span class="s1">&gt; np.array(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt1)[()]</span><span class="s0">, </span><span class="s4">&quot;type %s failed&quot; </span><span class="s1">% (dt1</span><span class="s0">,</span><span class="s1">))</span>
            <span class="s1">assert_(-</span><span class="s3">1 </span><span class="s1">!= np.array(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt1)[()]</span><span class="s0">, </span><span class="s4">&quot;type %s failed&quot; </span><span class="s1">% (dt1</span><span class="s0">,</span><span class="s1">))</span>

            <span class="s2">#unsigned vs signed</span>
            <span class="s0">for </span><span class="s1">dt2 </span><span class="s0">in </span><span class="s4">'bhilqp'</span><span class="s1">:</span>
                <span class="s1">assert_(np.array(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt1)[()] &gt; np.array(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt2)[()]</span><span class="s0">,</span>
                        <span class="s4">&quot;type %s and %s failed&quot; </span><span class="s1">% (dt1</span><span class="s0">, </span><span class="s1">dt2))</span>
                <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">np.array(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt1)[()] &lt; np.array(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt2)[()]</span><span class="s0">,</span>
                        <span class="s4">&quot;type %s and %s failed&quot; </span><span class="s1">% (dt1</span><span class="s0">, </span><span class="s1">dt2))</span>
                <span class="s1">assert_(np.array(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt1)[()] != np.array(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt2)[()]</span><span class="s0">,</span>
                        <span class="s4">&quot;type %s and %s failed&quot; </span><span class="s1">% (dt1</span><span class="s0">, </span><span class="s1">dt2))</span>

        <span class="s2">#Signed integers and floats</span>
        <span class="s0">for </span><span class="s1">dt1 </span><span class="s0">in </span><span class="s4">'bhlqp' </span><span class="s1">+ np.typecodes[</span><span class="s4">'Float'</span><span class="s1">]:</span>
            <span class="s1">assert_(</span><span class="s3">1 </span><span class="s1">&gt; np.array(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt1)[()]</span><span class="s0">, </span><span class="s4">&quot;type %s failed&quot; </span><span class="s1">% (dt1</span><span class="s0">,</span><span class="s1">))</span>
            <span class="s1">assert_(</span><span class="s0">not </span><span class="s3">1 </span><span class="s1">&lt; np.array(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt1)[()]</span><span class="s0">, </span><span class="s4">&quot;type %s failed&quot; </span><span class="s1">% (dt1</span><span class="s0">,</span><span class="s1">))</span>
            <span class="s1">assert_(-</span><span class="s3">1 </span><span class="s1">== np.array(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt1)[()]</span><span class="s0">, </span><span class="s4">&quot;type %s failed&quot; </span><span class="s1">% (dt1</span><span class="s0">,</span><span class="s1">))</span>

            <span class="s0">for </span><span class="s1">dt2 </span><span class="s0">in </span><span class="s4">'bhlqp' </span><span class="s1">+ np.typecodes[</span><span class="s4">'Float'</span><span class="s1">]:</span>
                <span class="s1">assert_(np.array(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt1)[()] &gt; np.array(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt2)[()]</span><span class="s0">,</span>
                        <span class="s4">&quot;type %s and %s failed&quot; </span><span class="s1">% (dt1</span><span class="s0">, </span><span class="s1">dt2))</span>
                <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">np.array(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt1)[()] &lt; np.array(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt2)[()]</span><span class="s0">,</span>
                        <span class="s4">&quot;type %s and %s failed&quot; </span><span class="s1">% (dt1</span><span class="s0">, </span><span class="s1">dt2))</span>
                <span class="s1">assert_(np.array(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt1)[()] == np.array(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt2)[()]</span><span class="s0">,</span>
                        <span class="s4">&quot;type %s and %s failed&quot; </span><span class="s1">% (dt1</span><span class="s0">, </span><span class="s1">dt2))</span>

    <span class="s0">def </span><span class="s1">test_scalar_comparison_to_none(self):</span>
        <span class="s2"># Scalars should just return False and not give a warnings.</span>
        <span class="s2"># The comparisons are flagged by pep8, ignore that.</span>
        <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">as </span><span class="s1">w:</span>
            <span class="s1">warnings.filterwarnings(</span><span class="s4">'always'</span><span class="s0">, </span><span class="s4">''</span><span class="s0">, </span><span class="s1">FutureWarning)</span>
            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">np.float32(</span><span class="s3">1</span><span class="s1">) == </span><span class="s0">None</span><span class="s1">)</span>
            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">np.str_(</span><span class="s4">'test'</span><span class="s1">) == </span><span class="s0">None</span><span class="s1">)</span>
            <span class="s2"># This is dubious (see below):</span>
            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">np.datetime64(</span><span class="s4">'NaT'</span><span class="s1">) == </span><span class="s0">None</span><span class="s1">)</span>

            <span class="s1">assert_(np.float32(</span><span class="s3">1</span><span class="s1">) != </span><span class="s0">None</span><span class="s1">)</span>
            <span class="s1">assert_(np.str_(</span><span class="s4">'test'</span><span class="s1">) != </span><span class="s0">None</span><span class="s1">)</span>
            <span class="s2"># This is dubious (see below):</span>
            <span class="s1">assert_(np.datetime64(</span><span class="s4">'NaT'</span><span class="s1">) != </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">assert_(len(w) == </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s2"># For documentation purposes, this is why the datetime is dubious.</span>
        <span class="s2"># At the time of deprecation this was no behaviour change, but</span>
        <span class="s2"># it has to be considered when the deprecations are done.</span>
        <span class="s1">assert_(np.equal(np.datetime64(</span><span class="s4">'NaT'</span><span class="s1">)</span><span class="s0">, None</span><span class="s1">))</span>


<span class="s2">#class TestRepr:</span>
<span class="s2">#    def test_repr(self):</span>
<span class="s2">#        for t in types:</span>
<span class="s2">#            val = t(1197346475.0137341)</span>
<span class="s2">#            val_repr = repr(val)</span>
<span class="s2">#            val2 = eval(val_repr)</span>
<span class="s2">#            assert_equal( val, val2 )</span>


<span class="s0">class </span><span class="s1">TestRepr:</span>
    <span class="s0">def </span><span class="s1">_test_type_repr(self</span><span class="s0">, </span><span class="s1">t):</span>
        <span class="s1">finfo = np.finfo(t)</span>
        <span class="s1">last_fraction_bit_idx = finfo.nexp + finfo.nmant</span>
        <span class="s1">last_exponent_bit_idx = finfo.nexp</span>
        <span class="s1">storage_bytes = np.dtype(t).itemsize*</span><span class="s3">8</span>
        <span class="s2"># could add some more types to the list below</span>
        <span class="s0">for </span><span class="s1">which </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'small denorm'</span><span class="s0">, </span><span class="s4">'small norm'</span><span class="s1">]:</span>
            <span class="s2"># Values from https://en.wikipedia.org/wiki/IEEE_754</span>
            <span class="s1">constr = np.array([</span><span class="s3">0x00</span><span class="s1">]*storage_bytes</span><span class="s0">, </span><span class="s1">dtype=np.uint8)</span>
            <span class="s0">if </span><span class="s1">which == </span><span class="s4">'small denorm'</span><span class="s1">:</span>
                <span class="s1">byte = last_fraction_bit_idx // </span><span class="s3">8</span>
                <span class="s1">bytebit = </span><span class="s3">7</span><span class="s1">-(last_fraction_bit_idx % </span><span class="s3">8</span><span class="s1">)</span>
                <span class="s1">constr[byte] = </span><span class="s3">1 </span><span class="s1">&lt;&lt; bytebit</span>
            <span class="s0">elif </span><span class="s1">which == </span><span class="s4">'small norm'</span><span class="s1">:</span>
                <span class="s1">byte = last_exponent_bit_idx // </span><span class="s3">8</span>
                <span class="s1">bytebit = </span><span class="s3">7</span><span class="s1">-(last_exponent_bit_idx % </span><span class="s3">8</span><span class="s1">)</span>
                <span class="s1">constr[byte] = </span><span class="s3">1 </span><span class="s1">&lt;&lt; bytebit</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'hmm'</span><span class="s1">)</span>
            <span class="s1">val = constr.view(t)[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">val_repr = repr(val)</span>
            <span class="s1">val2 = t(eval(val_repr))</span>
            <span class="s0">if not </span><span class="s1">(val2 == </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">val &lt; </span><span class="s3">1e-100</span><span class="s1">):</span>
                <span class="s1">assert_equal(val</span><span class="s0">, </span><span class="s1">val2)</span>

    <span class="s0">def </span><span class="s1">test_float_repr(self):</span>
        <span class="s2"># long double test cannot work, because eval goes through a python</span>
        <span class="s2"># float</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">[np.float32</span><span class="s0">, </span><span class="s1">np.float64]:</span>
            <span class="s1">self._test_type_repr(t)</span>


<span class="s0">if not </span><span class="s1">IS_PYPY:</span>
    <span class="s2"># sys.getsizeof() is not valid on PyPy</span>
    <span class="s0">class </span><span class="s1">TestSizeOf:</span>

        <span class="s0">def </span><span class="s1">test_equal_nbytes(self):</span>
            <span class="s0">for </span><span class="s1">type </span><span class="s0">in </span><span class="s1">types:</span>
                <span class="s1">x = type(</span><span class="s3">0</span><span class="s1">)</span>
                <span class="s1">assert_(sys.getsizeof(x) &gt; x.nbytes)</span>

        <span class="s0">def </span><span class="s1">test_error(self):</span>
            <span class="s1">d = np.float32()</span>
            <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">d.__sizeof__</span><span class="s0">, </span><span class="s4">&quot;a&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestMultiply:</span>
    <span class="s0">def </span><span class="s1">test_seq_repeat(self):</span>
        <span class="s2"># Test that basic sequences get repeated when multiplied with</span>
        <span class="s2"># numpy integers. And errors are raised when multiplied with others.</span>
        <span class="s2"># Some of this behaviour may be controversial and could be open for</span>
        <span class="s2"># change.</span>
        <span class="s1">accepted_types = set(np.typecodes[</span><span class="s4">&quot;AllInteger&quot;</span><span class="s1">])</span>
        <span class="s1">deprecated_types = {</span><span class="s4">'?'</span><span class="s1">}</span>
        <span class="s1">forbidden_types = (</span>
            <span class="s1">set(np.typecodes[</span><span class="s4">&quot;All&quot;</span><span class="s1">]) - accepted_types - deprecated_types)</span>
        <span class="s1">forbidden_types -= {</span><span class="s4">'V'</span><span class="s1">}  </span><span class="s2"># can't default-construct void scalars</span>

        <span class="s0">for </span><span class="s1">seq_type </span><span class="s0">in </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s1">seq = seq_type([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
            <span class="s0">for </span><span class="s1">numpy_type </span><span class="s0">in </span><span class="s1">accepted_types:</span>
                <span class="s1">i = np.dtype(numpy_type).type(</span><span class="s3">2</span><span class="s1">)</span>
                <span class="s1">assert_equal(seq * i</span><span class="s0">, </span><span class="s1">seq * int(i))</span>
                <span class="s1">assert_equal(i * seq</span><span class="s0">, </span><span class="s1">int(i) * seq)</span>

            <span class="s0">for </span><span class="s1">numpy_type </span><span class="s0">in </span><span class="s1">deprecated_types:</span>
                <span class="s1">i = np.dtype(numpy_type).type()</span>
                <span class="s1">assert_equal(</span>
                    <span class="s1">assert_warns(DeprecationWarning</span><span class="s0">, </span><span class="s1">operator.mul</span><span class="s0">, </span><span class="s1">seq</span><span class="s0">, </span><span class="s1">i)</span><span class="s0">,</span>
                    <span class="s1">seq * int(i))</span>
                <span class="s1">assert_equal(</span>
                    <span class="s1">assert_warns(DeprecationWarning</span><span class="s0">, </span><span class="s1">operator.mul</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">seq)</span><span class="s0">,</span>
                    <span class="s1">int(i) * seq)</span>

            <span class="s0">for </span><span class="s1">numpy_type </span><span class="s0">in </span><span class="s1">forbidden_types:</span>
                <span class="s1">i = np.dtype(numpy_type).type()</span>
                <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">operator.mul</span><span class="s0">, </span><span class="s1">seq</span><span class="s0">, </span><span class="s1">i)</span>
                <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">operator.mul</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">seq)</span>

    <span class="s0">def </span><span class="s1">test_no_seq_repeat_basic_array_like(self):</span>
        <span class="s2"># Test that an array-like which does not know how to be multiplied</span>
        <span class="s2"># does not attempt sequence repeat (raise TypeError).</span>
        <span class="s2"># See also gh-7428.</span>
        <span class="s0">class </span><span class="s1">ArrayLike:</span>
            <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">arr):</span>
                <span class="s1">self.arr = arr</span>
            <span class="s0">def </span><span class="s1">__array__(self):</span>
                <span class="s0">return </span><span class="s1">self.arr</span>

        <span class="s2"># Test for simple ArrayLike above and memoryviews (original report)</span>
        <span class="s0">for </span><span class="s1">arr_like </span><span class="s0">in </span><span class="s1">(ArrayLike(np.ones(</span><span class="s3">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">memoryview(np.ones(</span><span class="s3">3</span><span class="s1">))):</span>
            <span class="s1">assert_array_equal(arr_like * np.float32(</span><span class="s3">3.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.full(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3.</span><span class="s1">))</span>
            <span class="s1">assert_array_equal(np.float32(</span><span class="s3">3.</span><span class="s1">) * arr_like</span><span class="s0">, </span><span class="s1">np.full(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3.</span><span class="s1">))</span>
            <span class="s1">assert_array_equal(arr_like * np.int_(</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.full(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
            <span class="s1">assert_array_equal(np.int_(</span><span class="s3">3</span><span class="s1">) * arr_like</span><span class="s0">, </span><span class="s1">np.full(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>


<span class="s0">class </span><span class="s1">TestNegative:</span>
    <span class="s0">def </span><span class="s1">test_exceptions(self):</span>
        <span class="s1">a = np.ones(()</span><span class="s0">, </span><span class="s1">dtype=np.bool_)[()]</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">operator.neg</span><span class="s0">, </span><span class="s1">a)</span>

    <span class="s0">def </span><span class="s1">test_result(self):</span>
        <span class="s1">types = np.typecodes[</span><span class="s4">'AllInteger'</span><span class="s1">] + np.typecodes[</span><span class="s4">'AllFloat'</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(RuntimeWarning)</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">types:</span>
                <span class="s1">a = np.ones(()</span><span class="s0">, </span><span class="s1">dtype=dt)[()]</span>
                <span class="s1">assert_equal(operator.neg(a) + a</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestSubtract:</span>
    <span class="s0">def </span><span class="s1">test_exceptions(self):</span>
        <span class="s1">a = np.ones(()</span><span class="s0">, </span><span class="s1">dtype=np.bool_)[()]</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">operator.sub</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a)</span>

    <span class="s0">def </span><span class="s1">test_result(self):</span>
        <span class="s1">types = np.typecodes[</span><span class="s4">'AllInteger'</span><span class="s1">] + np.typecodes[</span><span class="s4">'AllFloat'</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(RuntimeWarning)</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">types:</span>
                <span class="s1">a = np.ones(()</span><span class="s0">, </span><span class="s1">dtype=dt)[()]</span>
                <span class="s1">assert_equal(operator.sub(a</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestAbs:</span>
    <span class="s0">def </span><span class="s1">_test_abs_func(self</span><span class="s0">, </span><span class="s1">absfunc</span><span class="s0">, </span><span class="s1">test_dtype):</span>
        <span class="s1">x = test_dtype(-</span><span class="s3">1.5</span><span class="s1">)</span>
        <span class="s1">assert_equal(absfunc(x)</span><span class="s0">, </span><span class="s3">1.5</span><span class="s1">)</span>
        <span class="s1">x = test_dtype(</span><span class="s3">0.0</span><span class="s1">)</span>
        <span class="s1">res = absfunc(x)</span>
        <span class="s2"># assert_equal() checks zero signedness</span>
        <span class="s1">assert_equal(res</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">)</span>
        <span class="s1">x = test_dtype(-</span><span class="s3">0.0</span><span class="s1">)</span>
        <span class="s1">res = absfunc(x)</span>
        <span class="s1">assert_equal(res</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">)</span>

        <span class="s1">x = test_dtype(np.finfo(test_dtype).max)</span>
        <span class="s1">assert_equal(absfunc(x)</span><span class="s0">, </span><span class="s1">x.real)</span>

        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning)</span>
            <span class="s1">x = test_dtype(np.finfo(test_dtype).tiny)</span>
            <span class="s1">assert_equal(absfunc(x)</span><span class="s0">, </span><span class="s1">x.real)</span>

        <span class="s1">x = test_dtype(np.finfo(test_dtype).min)</span>
        <span class="s1">assert_equal(absfunc(x)</span><span class="s0">, </span><span class="s1">-x.real)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">floating_types + complex_floating_types)</span>
    <span class="s0">def </span><span class="s1">test_builtin_abs(self</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s0">if </span><span class="s1">sys.platform == </span><span class="s4">&quot;cygwin&quot; </span><span class="s0">and </span><span class="s1">dtype == np.clongdouble:</span>
            <span class="s1">pytest.xfail(</span>
                <span class="s1">reason=</span><span class="s4">&quot;absl is computed in double precision on cygwin&quot;</span>
            <span class="s1">)</span>
        <span class="s1">self._test_abs_func(abs</span><span class="s0">, </span><span class="s1">dtype)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">floating_types + complex_floating_types)</span>
    <span class="s0">def </span><span class="s1">test_numpy_abs(self</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s0">if </span><span class="s1">sys.platform == </span><span class="s4">&quot;cygwin&quot; </span><span class="s0">and </span><span class="s1">dtype == np.clongdouble:</span>
            <span class="s1">pytest.xfail(</span>
                <span class="s1">reason=</span><span class="s4">&quot;absl is computed in double precision on cygwin&quot;</span>
            <span class="s1">)</span>
        <span class="s1">self._test_abs_func(np.abs</span><span class="s0">, </span><span class="s1">dtype)</span>

<span class="s0">class </span><span class="s1">TestBitShifts:</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'type_code'</span><span class="s0">, </span><span class="s1">np.typecodes[</span><span class="s4">'AllInteger'</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'op'</span><span class="s0">,</span>
        <span class="s1">[operator.rshift</span><span class="s0">, </span><span class="s1">operator.lshift]</span><span class="s0">, </span><span class="s1">ids=[</span><span class="s4">'&gt;&gt;'</span><span class="s0">, </span><span class="s4">'&lt;&lt;'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_shift_all_bits(self</span><span class="s0">, </span><span class="s1">type_code</span><span class="s0">, </span><span class="s1">op):</span>
        <span class="s5">&quot;&quot;&quot; Shifts where the shift amount is the width of the type or wider &quot;&quot;&quot;</span>
        <span class="s2"># gh-2449</span>
        <span class="s1">dt = np.dtype(type_code)</span>
        <span class="s1">nbits = dt.itemsize * </span><span class="s3">8</span>
        <span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">[</span><span class="s3">5</span><span class="s0">, </span><span class="s1">-</span><span class="s3">5</span><span class="s1">]:</span>
            <span class="s0">for </span><span class="s1">shift </span><span class="s0">in </span><span class="s1">[nbits</span><span class="s0">, </span><span class="s1">nbits + </span><span class="s3">4</span><span class="s1">]:</span>
                <span class="s1">val_scl = dt.type(val)</span>
                <span class="s1">shift_scl = dt.type(shift)</span>
                <span class="s1">res_scl = op(val_scl</span><span class="s0">, </span><span class="s1">shift_scl)</span>
                <span class="s0">if </span><span class="s1">val_scl &lt; </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">op </span><span class="s0">is </span><span class="s1">operator.rshift:</span>
                    <span class="s2"># sign bit is preserved</span>
                    <span class="s1">assert_equal(res_scl</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">assert_equal(res_scl</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

                <span class="s2"># Result on scalars should be the same as on arrays</span>
                <span class="s1">val_arr = np.array([val]*</span><span class="s3">32</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">shift_arr = np.array([shift]*</span><span class="s3">32</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">res_arr = op(val_arr</span><span class="s0">, </span><span class="s1">shift_arr)</span>
                <span class="s1">assert_equal(res_arr</span><span class="s0">, </span><span class="s1">res_scl)</span>


<span class="s0">class </span><span class="s1">TestHash:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;type_code&quot;</span><span class="s0">, </span><span class="s1">np.typecodes[</span><span class="s4">'AllInteger'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_integer_hashes(self</span><span class="s0">, </span><span class="s1">type_code):</span>
        <span class="s1">scalar = np.dtype(type_code).type</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">128</span><span class="s1">):</span>
            <span class="s0">assert </span><span class="s1">hash(i) == hash(scalar(i))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;type_code&quot;</span><span class="s0">, </span><span class="s1">np.typecodes[</span><span class="s4">'AllFloat'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_float_and_complex_hashes(self</span><span class="s0">, </span><span class="s1">type_code):</span>
        <span class="s1">scalar = np.dtype(type_code).type</span>
        <span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">[np.pi</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">6.</span><span class="s1">]:</span>
            <span class="s1">numpy_val = scalar(val)</span>
            <span class="s2"># Cast back to Python, in case the NumPy scalar has less precision</span>
            <span class="s0">if </span><span class="s1">numpy_val.dtype.kind == </span><span class="s4">'c'</span><span class="s1">:</span>
                <span class="s1">val = complex(numpy_val)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">val = float(numpy_val)</span>
            <span class="s0">assert </span><span class="s1">val == numpy_val</span>
            <span class="s1">print(repr(numpy_val)</span><span class="s0">, </span><span class="s1">repr(val))</span>
            <span class="s0">assert </span><span class="s1">hash(val) == hash(numpy_val)</span>

        <span class="s0">if </span><span class="s1">hash(float(np.nan)) != hash(float(np.nan)):</span>
            <span class="s2"># If Python distinguises different NaNs we do so too (gh-18833)</span>
            <span class="s0">assert </span><span class="s1">hash(scalar(np.nan)) != hash(scalar(np.nan))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;type_code&quot;</span><span class="s0">, </span><span class="s1">np.typecodes[</span><span class="s4">'Complex'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_complex_hashes(self</span><span class="s0">, </span><span class="s1">type_code):</span>
        <span class="s2"># Test some complex valued hashes specifically:</span>
        <span class="s1">scalar = np.dtype(type_code).type</span>
        <span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">[np.pi+</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">np.inf-</span><span class="s3">3j</span><span class="s0">, </span><span class="s3">3j</span><span class="s0">, </span><span class="s3">6.</span><span class="s1">+</span><span class="s3">1j</span><span class="s1">]:</span>
            <span class="s1">numpy_val = scalar(val)</span>
            <span class="s0">assert </span><span class="s1">hash(complex(numpy_val)) == hash(numpy_val)</span>


<span class="s1">@contextlib.contextmanager</span>
<span class="s0">def </span><span class="s1">recursionlimit(n):</span>
    <span class="s1">o = sys.getrecursionlimit()</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">sys.setrecursionlimit(n)</span>
        <span class="s0">yield</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s1">sys.setrecursionlimit(o)</span>


<span class="s1">objecty_things = [object()</span><span class="s0">, None</span><span class="s1">]</span>
<span class="s1">reasonable_operators_for_scalars = [</span>
    <span class="s1">operator.lt</span><span class="s0">, </span><span class="s1">operator.le</span><span class="s0">, </span><span class="s1">operator.eq</span><span class="s0">, </span><span class="s1">operator.ne</span><span class="s0">, </span><span class="s1">operator.ge</span><span class="s0">,</span>
    <span class="s1">operator.gt</span><span class="s0">, </span><span class="s1">operator.add</span><span class="s0">, </span><span class="s1">operator.floordiv</span><span class="s0">, </span><span class="s1">operator.mod</span><span class="s0">,</span>
    <span class="s1">operator.mul</span><span class="s0">, </span><span class="s1">operator.matmul</span><span class="s0">, </span><span class="s1">operator.pow</span><span class="s0">, </span><span class="s1">operator.sub</span><span class="s0">,</span>
    <span class="s1">operator.truediv</span><span class="s0">,</span>
<span class="s1">]</span>


<span class="s1">@given(sampled_from(objecty_things)</span><span class="s0">,</span>
       <span class="s1">sampled_from(reasonable_operators_for_scalars)</span><span class="s0">,</span>
       <span class="s1">sampled_from(types))</span>
<span class="s1">@settings(verbosity=Verbosity.verbose)</span>
<span class="s0">def </span><span class="s1">test_operator_object_left(o</span><span class="s0">, </span><span class="s1">op</span><span class="s0">, </span><span class="s1">type_):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">with </span><span class="s1">recursionlimit(</span><span class="s3">200</span><span class="s1">):</span>
            <span class="s1">op(o</span><span class="s0">, </span><span class="s1">type_(</span><span class="s3">1</span><span class="s1">))</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">pass</span>


<span class="s1">@given(sampled_from(objecty_things)</span><span class="s0">,</span>
       <span class="s1">sampled_from(reasonable_operators_for_scalars)</span><span class="s0">,</span>
       <span class="s1">sampled_from(types))</span>
<span class="s0">def </span><span class="s1">test_operator_object_right(o</span><span class="s0">, </span><span class="s1">op</span><span class="s0">, </span><span class="s1">type_):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">with </span><span class="s1">recursionlimit(</span><span class="s3">200</span><span class="s1">):</span>
            <span class="s1">op(type_(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">o)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">pass</span>


<span class="s1">@given(sampled_from(reasonable_operators_for_scalars)</span><span class="s0">,</span>
       <span class="s1">sampled_from(types)</span><span class="s0">,</span>
       <span class="s1">sampled_from(types))</span>
<span class="s0">def </span><span class="s1">test_operator_scalars(op</span><span class="s0">, </span><span class="s1">type1</span><span class="s0">, </span><span class="s1">type2):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">op(type1(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">type2(</span><span class="s3">1</span><span class="s1">))</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">pass</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;op&quot;</span><span class="s0">, </span><span class="s1">reasonable_operators_for_scalars)</span>
<span class="s0">def </span><span class="s1">test_longdouble_inf_loop(op):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">op(np.longdouble(</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">pass</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">op(</span><span class="s0">None, </span><span class="s1">np.longdouble(</span><span class="s3">3</span><span class="s1">))</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">pass</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;op&quot;</span><span class="s0">, </span><span class="s1">reasonable_operators_for_scalars)</span>
<span class="s0">def </span><span class="s1">test_clongdouble_inf_loop(op):</span>
    <span class="s0">if </span><span class="s1">op </span><span class="s0">in </span><span class="s1">{operator.mod} </span><span class="s0">and False</span><span class="s1">:</span>
        <span class="s1">pytest.xfail(</span><span class="s4">&quot;The modulo operator is known to be broken&quot;</span><span class="s1">)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">op(np.clongdouble(</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">pass</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">op(</span><span class="s0">None, </span><span class="s1">np.longdouble(</span><span class="s3">3</span><span class="s1">))</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">pass</span>
</pre>
</body>
</html>