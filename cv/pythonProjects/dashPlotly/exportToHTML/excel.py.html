<html>
<head>
<title>excel.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
excel.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Utilities for conversion to writer-agnostic Excel representation. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">reduce</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">Hashable</span><span class="s2">,</span>
    <span class="s1">Iterable</span><span class="s2">,</span>
    <span class="s1">Mapping</span><span class="s2">,</span>
    <span class="s1">Sequence</span><span class="s2">,</span>
    <span class="s1">cast</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">pandas._libs.lib </span><span class="s2">import </span><span class="s1">is_list_like</span>
<span class="s2">from </span><span class="s1">pandas._typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">IndexLabel</span><span class="s2">,</span>
    <span class="s1">StorageOptions</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.util._decorators </span><span class="s2">import </span><span class="s1">doc</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes </span><span class="s2">import </span><span class="s1">missing</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">is_float</span><span class="s2">,</span>
    <span class="s1">is_scalar</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s2">,</span>
    <span class="s1">Index</span><span class="s2">,</span>
    <span class="s1">MultiIndex</span><span class="s2">,</span>
    <span class="s1">PeriodIndex</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas.core.common </span><span class="s2">as </span><span class="s1">com</span>
<span class="s2">from </span><span class="s1">pandas.core.shared_docs </span><span class="s2">import </span><span class="s1">_shared_docs</span>

<span class="s2">from </span><span class="s1">pandas.io.formats._color_data </span><span class="s2">import </span><span class="s1">CSS4_COLORS</span>
<span class="s2">from </span><span class="s1">pandas.io.formats.css </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">CSSResolver</span><span class="s2">,</span>
    <span class="s1">CSSWarning</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.io.formats.format </span><span class="s2">import </span><span class="s1">get_level_lengths</span>
<span class="s2">from </span><span class="s1">pandas.io.formats.printing </span><span class="s2">import </span><span class="s1">pprint_thing</span>


<span class="s2">class </span><span class="s1">ExcelCell:</span>
    <span class="s1">__fields__ = (</span><span class="s3">&quot;row&quot;</span><span class="s2">, </span><span class="s3">&quot;col&quot;</span><span class="s2">, </span><span class="s3">&quot;val&quot;</span><span class="s2">, </span><span class="s3">&quot;style&quot;</span><span class="s2">, </span><span class="s3">&quot;mergestart&quot;</span><span class="s2">, </span><span class="s3">&quot;mergeend&quot;</span><span class="s1">)</span>
    <span class="s1">__slots__ = __fields__</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">row: int</span><span class="s2">,</span>
        <span class="s1">col: int</span><span class="s2">,</span>
        <span class="s1">val</span><span class="s2">,</span>
        <span class="s1">style=</span><span class="s2">None,</span>
        <span class="s1">mergestart: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">mergeend: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">self.row = row</span>
        <span class="s1">self.col = col</span>
        <span class="s1">self.val = val</span>
        <span class="s1">self.style = style</span>
        <span class="s1">self.mergestart = mergestart</span>
        <span class="s1">self.mergeend = mergeend</span>


<span class="s2">class </span><span class="s1">CssExcelCell(ExcelCell):</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">row: int</span><span class="s2">,</span>
        <span class="s1">col: int</span><span class="s2">,</span>
        <span class="s1">val</span><span class="s2">,</span>
        <span class="s1">style: dict | </span><span class="s2">None,</span>
        <span class="s1">css_styles: dict[tuple[int</span><span class="s2">, </span><span class="s1">int]</span><span class="s2">, </span><span class="s1">list[tuple[str</span><span class="s2">, </span><span class="s1">Any]]] | </span><span class="s2">None,</span>
        <span class="s1">css_row: int</span><span class="s2">,</span>
        <span class="s1">css_col: int</span><span class="s2">,</span>
        <span class="s1">css_converter: Callable | </span><span class="s2">None,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s2">if </span><span class="s1">css_styles </span><span class="s2">and </span><span class="s1">css_converter:</span>
            <span class="s1">css = </span><span class="s3">&quot;;&quot;</span><span class="s1">.join(a + </span><span class="s3">&quot;:&quot; </span><span class="s1">+ str(v) </span><span class="s2">for </span><span class="s1">(a</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">in </span><span class="s1">css_styles[css_row</span><span class="s2">, </span><span class="s1">css_col])</span>
            <span class="s1">style = css_converter(css)</span>

        <span class="s2">return </span><span class="s1">super().__init__(row=row</span><span class="s2">, </span><span class="s1">col=col</span><span class="s2">, </span><span class="s1">val=val</span><span class="s2">, </span><span class="s1">style=style</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">CSSToExcelConverter:</span>
    <span class="s0">&quot;&quot;&quot; 
    A callable for converting CSS declarations to ExcelWriter styles 
 
    Supports parts of CSS 2.2, with minimal CSS 3.0 support (e.g. text-shadow), 
    focusing on font styling, backgrounds, borders and alignment. 
 
    Operates by first computing CSS styles in a fairly generic 
    way (see :meth:`compute_css`) then determining Excel style 
    properties from CSS properties (see :meth:`build_xlstyle`). 
 
    Parameters 
    ---------- 
    inherited : str, optional 
        CSS declarations understood to be the containing scope for the 
        CSS processed by :meth:`__call__`. 
    &quot;&quot;&quot;</span>

    <span class="s1">NAMED_COLORS = CSS4_COLORS</span>

    <span class="s1">VERTICAL_MAP = {</span>
        <span class="s3">&quot;top&quot;</span><span class="s1">: </span><span class="s3">&quot;top&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;text-top&quot;</span><span class="s1">: </span><span class="s3">&quot;top&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;middle&quot;</span><span class="s1">: </span><span class="s3">&quot;center&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;baseline&quot;</span><span class="s1">: </span><span class="s3">&quot;bottom&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;bottom&quot;</span><span class="s1">: </span><span class="s3">&quot;bottom&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;text-bottom&quot;</span><span class="s1">: </span><span class="s3">&quot;bottom&quot;</span><span class="s2">,</span>
        <span class="s4"># OpenXML also has 'justify', 'distributed'</span>
    <span class="s1">}</span>

    <span class="s1">BOLD_MAP = {</span>
        <span class="s3">&quot;bold&quot;</span><span class="s1">: </span><span class="s2">True,</span>
        <span class="s3">&quot;bolder&quot;</span><span class="s1">: </span><span class="s2">True,</span>
        <span class="s3">&quot;600&quot;</span><span class="s1">: </span><span class="s2">True,</span>
        <span class="s3">&quot;700&quot;</span><span class="s1">: </span><span class="s2">True,</span>
        <span class="s3">&quot;800&quot;</span><span class="s1">: </span><span class="s2">True,</span>
        <span class="s3">&quot;900&quot;</span><span class="s1">: </span><span class="s2">True,</span>
        <span class="s3">&quot;normal&quot;</span><span class="s1">: </span><span class="s2">False,</span>
        <span class="s3">&quot;lighter&quot;</span><span class="s1">: </span><span class="s2">False,</span>
        <span class="s3">&quot;100&quot;</span><span class="s1">: </span><span class="s2">False,</span>
        <span class="s3">&quot;200&quot;</span><span class="s1">: </span><span class="s2">False,</span>
        <span class="s3">&quot;300&quot;</span><span class="s1">: </span><span class="s2">False,</span>
        <span class="s3">&quot;400&quot;</span><span class="s1">: </span><span class="s2">False,</span>
        <span class="s3">&quot;500&quot;</span><span class="s1">: </span><span class="s2">False,</span>
    <span class="s1">}</span>

    <span class="s1">ITALIC_MAP = {</span>
        <span class="s3">&quot;normal&quot;</span><span class="s1">: </span><span class="s2">False,</span>
        <span class="s3">&quot;italic&quot;</span><span class="s1">: </span><span class="s2">True,</span>
        <span class="s3">&quot;oblique&quot;</span><span class="s1">: </span><span class="s2">True,</span>
    <span class="s1">}</span>

    <span class="s1">FAMILY_MAP = {</span>
        <span class="s3">&quot;serif&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s2">,  </span><span class="s4"># roman</span>
        <span class="s3">&quot;sans-serif&quot;</span><span class="s1">: </span><span class="s5">2</span><span class="s2">,  </span><span class="s4"># swiss</span>
        <span class="s3">&quot;cursive&quot;</span><span class="s1">: </span><span class="s5">4</span><span class="s2">,  </span><span class="s4"># script</span>
        <span class="s3">&quot;fantasy&quot;</span><span class="s1">: </span><span class="s5">5</span><span class="s2">,  </span><span class="s4"># decorative</span>
    <span class="s1">}</span>

    <span class="s4"># NB: Most of the methods here could be classmethods, as only __init__</span>
    <span class="s4">#     and __call__ make use of instance attributes.  We leave them as</span>
    <span class="s4">#     instancemethods so that users can easily experiment with extensions</span>
    <span class="s4">#     without monkey-patching.</span>
    <span class="s1">inherited: dict[str</span><span class="s2">, </span><span class="s1">str] | </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">inherited: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">inherited </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.inherited = self.compute_css(inherited)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.inherited = </span><span class="s2">None</span>

    <span class="s1">compute_css = CSSResolver()</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">declarations_str: str) -&gt; dict[str</span><span class="s2">, </span><span class="s1">dict[str</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert CSS declarations to ExcelWriter style. 
 
        Parameters 
        ---------- 
        declarations_str : str 
            List of CSS declarations. 
            e.g. &quot;font-weight: bold; background: blue&quot; 
 
        Returns 
        ------- 
        xlstyle : dict 
            A style as interpreted by ExcelWriter when found in 
            ExcelCell.style. 
        &quot;&quot;&quot;</span>
        <span class="s4"># TODO: memoize?</span>
        <span class="s1">properties = self.compute_css(declarations_str</span><span class="s2">, </span><span class="s1">self.inherited)</span>
        <span class="s2">return </span><span class="s1">self.build_xlstyle(properties)</span>

    <span class="s2">def </span><span class="s1">build_xlstyle(self</span><span class="s2">, </span><span class="s1">props: Mapping[str</span><span class="s2">, </span><span class="s1">str]) -&gt; dict[str</span><span class="s2">, </span><span class="s1">dict[str</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s1">out = {</span>
            <span class="s3">&quot;alignment&quot;</span><span class="s1">: self.build_alignment(props)</span><span class="s2">,</span>
            <span class="s3">&quot;border&quot;</span><span class="s1">: self.build_border(props)</span><span class="s2">,</span>
            <span class="s3">&quot;fill&quot;</span><span class="s1">: self.build_fill(props)</span><span class="s2">,</span>
            <span class="s3">&quot;font&quot;</span><span class="s1">: self.build_font(props)</span><span class="s2">,</span>
            <span class="s3">&quot;number_format&quot;</span><span class="s1">: self.build_number_format(props)</span><span class="s2">,</span>
        <span class="s1">}</span>

        <span class="s4"># TODO: handle cell width and height: needs support in pandas.io.excel</span>

        <span class="s2">def </span><span class="s1">remove_none(d: dict[str</span><span class="s2">, </span><span class="s1">str]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s0">&quot;&quot;&quot;Remove key where value is None, through nested dicts&quot;&quot;&quot;</span>
            <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">list(d.items()):</span>
                <span class="s2">if </span><span class="s1">v </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">del </span><span class="s1">d[k]</span>
                <span class="s2">elif </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">dict):</span>
                    <span class="s1">remove_none(v)</span>
                    <span class="s2">if not </span><span class="s1">v:</span>
                        <span class="s2">del </span><span class="s1">d[k]</span>

        <span class="s1">remove_none(out)</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">build_alignment(self</span><span class="s2">, </span><span class="s1">props: Mapping[str</span><span class="s2">, </span><span class="s1">str]) -&gt; dict[str</span><span class="s2">, </span><span class="s1">bool | str | </span><span class="s2">None</span><span class="s1">]:</span>
        <span class="s4"># TODO: text-indent, padding-left -&gt; alignment.indent</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s3">&quot;horizontal&quot;</span><span class="s1">: props.get(</span><span class="s3">&quot;text-align&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;vertical&quot;</span><span class="s1">: self._get_vertical_alignment(props)</span><span class="s2">,</span>
            <span class="s3">&quot;wrap_text&quot;</span><span class="s1">: self._get_is_wrap_text(props)</span><span class="s2">,</span>
        <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">_get_vertical_alignment(self</span><span class="s2">, </span><span class="s1">props: Mapping[str</span><span class="s2">, </span><span class="s1">str]) -&gt; str | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">vertical_align = props.get(</span><span class="s3">&quot;vertical-align&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">vertical_align:</span>
            <span class="s2">return </span><span class="s1">self.VERTICAL_MAP.get(vertical_align)</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_get_is_wrap_text(self</span><span class="s2">, </span><span class="s1">props: Mapping[str</span><span class="s2">, </span><span class="s1">str]) -&gt; bool | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">props.get(</span><span class="s3">&quot;white-space&quot;</span><span class="s1">) </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s1">bool(props[</span><span class="s3">&quot;white-space&quot;</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">&quot;nowrap&quot;</span><span class="s2">, </span><span class="s3">&quot;pre&quot;</span><span class="s2">, </span><span class="s3">&quot;pre-line&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">build_border(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">props: Mapping[str</span><span class="s2">, </span><span class="s1">str]</span>
    <span class="s1">) -&gt; dict[str</span><span class="s2">, </span><span class="s1">dict[str</span><span class="s2">, </span><span class="s1">str | </span><span class="s2">None</span><span class="s1">]]:</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">side: {</span>
                <span class="s3">&quot;style&quot;</span><span class="s1">: self._border_style(</span>
                    <span class="s1">props.get(</span><span class="s3">f&quot;border-</span><span class="s2">{</span><span class="s1">side</span><span class="s2">}</span><span class="s3">-style&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">props.get(</span><span class="s3">f&quot;border-</span><span class="s2">{</span><span class="s1">side</span><span class="s2">}</span><span class="s3">-width&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;color&quot;</span><span class="s1">: self.color_to_excel(props.get(</span><span class="s3">f&quot;border-</span><span class="s2">{</span><span class="s1">side</span><span class="s2">}</span><span class="s3">-color&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">side </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;top&quot;</span><span class="s2">, </span><span class="s3">&quot;right&quot;</span><span class="s2">, </span><span class="s3">&quot;bottom&quot;</span><span class="s2">, </span><span class="s3">&quot;left&quot;</span><span class="s1">]</span>
        <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">_border_style(self</span><span class="s2">, </span><span class="s1">style: str | </span><span class="s2">None, </span><span class="s1">width: str | </span><span class="s2">None</span><span class="s1">):</span>
        <span class="s4"># convert styles and widths to openxml, one of:</span>
        <span class="s4">#       'dashDot'</span>
        <span class="s4">#       'dashDotDot'</span>
        <span class="s4">#       'dashed'</span>
        <span class="s4">#       'dotted'</span>
        <span class="s4">#       'double'</span>
        <span class="s4">#       'hair'</span>
        <span class="s4">#       'medium'</span>
        <span class="s4">#       'mediumDashDot'</span>
        <span class="s4">#       'mediumDashDotDot'</span>
        <span class="s4">#       'mediumDashed'</span>
        <span class="s4">#       'slantDashDot'</span>
        <span class="s4">#       'thick'</span>
        <span class="s4">#       'thin'</span>
        <span class="s2">if </span><span class="s1">width </span><span class="s2">is None and </span><span class="s1">style </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return None</span>
        <span class="s2">if </span><span class="s1">style == </span><span class="s3">&quot;none&quot; </span><span class="s2">or </span><span class="s1">style == </span><span class="s3">&quot;hidden&quot;</span><span class="s1">:</span>
            <span class="s2">return None</span>

        <span class="s1">width_name = self._get_width_name(width)</span>
        <span class="s2">if </span><span class="s1">width_name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return None</span>

        <span class="s2">if </span><span class="s1">style </span><span class="s2">in </span><span class="s1">(</span><span class="s2">None, </span><span class="s3">&quot;groove&quot;</span><span class="s2">, </span><span class="s3">&quot;ridge&quot;</span><span class="s2">, </span><span class="s3">&quot;inset&quot;</span><span class="s2">, </span><span class="s3">&quot;outset&quot;</span><span class="s2">, </span><span class="s3">&quot;solid&quot;</span><span class="s1">):</span>
            <span class="s4"># not handled</span>
            <span class="s2">return </span><span class="s1">width_name</span>

        <span class="s2">if </span><span class="s1">style == </span><span class="s3">&quot;double&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">&quot;double&quot;</span>
        <span class="s2">if </span><span class="s1">style == </span><span class="s3">&quot;dotted&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">width_name </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;hair&quot;</span><span class="s2">, </span><span class="s3">&quot;thin&quot;</span><span class="s1">):</span>
                <span class="s2">return </span><span class="s3">&quot;dotted&quot;</span>
            <span class="s2">return </span><span class="s3">&quot;mediumDashDotDot&quot;</span>
        <span class="s2">if </span><span class="s1">style == </span><span class="s3">&quot;dashed&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">width_name </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;hair&quot;</span><span class="s2">, </span><span class="s3">&quot;thin&quot;</span><span class="s1">):</span>
                <span class="s2">return </span><span class="s3">&quot;dashed&quot;</span>
            <span class="s2">return </span><span class="s3">&quot;mediumDashed&quot;</span>

    <span class="s2">def </span><span class="s1">_get_width_name(self</span><span class="s2">, </span><span class="s1">width_input: str | </span><span class="s2">None</span><span class="s1">) -&gt; str | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">width = self._width_to_float(width_input)</span>
        <span class="s2">if </span><span class="s1">width &lt; </span><span class="s5">1e-5</span><span class="s1">:</span>
            <span class="s2">return None</span>
        <span class="s2">elif </span><span class="s1">width &lt; </span><span class="s5">1.3</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">&quot;thin&quot;</span>
        <span class="s2">elif </span><span class="s1">width &lt; </span><span class="s5">2.8</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">&quot;medium&quot;</span>
        <span class="s2">return </span><span class="s3">&quot;thick&quot;</span>

    <span class="s2">def </span><span class="s1">_width_to_float(self</span><span class="s2">, </span><span class="s1">width: str | </span><span class="s2">None</span><span class="s1">) -&gt; float:</span>
        <span class="s2">if </span><span class="s1">width </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">width = </span><span class="s3">&quot;2pt&quot;</span>
        <span class="s2">return </span><span class="s1">self._pt_to_float(width)</span>

    <span class="s2">def </span><span class="s1">_pt_to_float(self</span><span class="s2">, </span><span class="s1">pt_string: str) -&gt; float:</span>
        <span class="s2">assert </span><span class="s1">pt_string.endswith(</span><span class="s3">&quot;pt&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">float(pt_string.rstrip(</span><span class="s3">&quot;pt&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">build_fill(self</span><span class="s2">, </span><span class="s1">props: Mapping[str</span><span class="s2">, </span><span class="s1">str]):</span>
        <span class="s4"># TODO: perhaps allow for special properties</span>
        <span class="s4">#       -excel-pattern-bgcolor and -excel-pattern-type</span>
        <span class="s1">fill_color = props.get(</span><span class="s3">&quot;background-color&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">fill_color </span><span class="s2">not in </span><span class="s1">(</span><span class="s2">None, </span><span class="s3">&quot;transparent&quot;</span><span class="s2">, </span><span class="s3">&quot;none&quot;</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">{</span><span class="s3">&quot;fgColor&quot;</span><span class="s1">: self.color_to_excel(fill_color)</span><span class="s2">, </span><span class="s3">&quot;patternType&quot;</span><span class="s1">: </span><span class="s3">&quot;solid&quot;</span><span class="s1">}</span>

    <span class="s2">def </span><span class="s1">build_number_format(self</span><span class="s2">, </span><span class="s1">props: Mapping[str</span><span class="s2">, </span><span class="s1">str]) -&gt; dict[str</span><span class="s2">, </span><span class="s1">str | </span><span class="s2">None</span><span class="s1">]:</span>
        <span class="s2">return </span><span class="s1">{</span><span class="s3">&quot;format_code&quot;</span><span class="s1">: props.get(</span><span class="s3">&quot;number-format&quot;</span><span class="s1">)}</span>

    <span class="s2">def </span><span class="s1">build_font(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">props: Mapping[str</span><span class="s2">, </span><span class="s1">str]</span>
    <span class="s1">) -&gt; dict[str</span><span class="s2">, </span><span class="s1">bool | int | float | str | </span><span class="s2">None</span><span class="s1">]:</span>
        <span class="s1">font_names = self._get_font_names(props)</span>
        <span class="s1">decoration = self._get_decoration(props)</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s3">&quot;name&quot;</span><span class="s1">: font_names[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">if </span><span class="s1">font_names </span><span class="s2">else None,</span>
            <span class="s3">&quot;family&quot;</span><span class="s1">: self._select_font_family(font_names)</span><span class="s2">,</span>
            <span class="s3">&quot;size&quot;</span><span class="s1">: self._get_font_size(props)</span><span class="s2">,</span>
            <span class="s3">&quot;bold&quot;</span><span class="s1">: self._get_is_bold(props)</span><span class="s2">,</span>
            <span class="s3">&quot;italic&quot;</span><span class="s1">: self._get_is_italic(props)</span><span class="s2">,</span>
            <span class="s3">&quot;underline&quot;</span><span class="s1">: (</span><span class="s3">&quot;single&quot; </span><span class="s2">if </span><span class="s3">&quot;underline&quot; </span><span class="s2">in </span><span class="s1">decoration </span><span class="s2">else None</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;strike&quot;</span><span class="s1">: (</span><span class="s3">&quot;line-through&quot; </span><span class="s2">in </span><span class="s1">decoration) </span><span class="s2">or None,</span>
            <span class="s3">&quot;color&quot;</span><span class="s1">: self.color_to_excel(props.get(</span><span class="s3">&quot;color&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s4"># shadow if nonzero digit before shadow color</span>
            <span class="s3">&quot;shadow&quot;</span><span class="s1">: self._get_shadow(props)</span><span class="s2">,</span>
        <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">_get_is_bold(self</span><span class="s2">, </span><span class="s1">props: Mapping[str</span><span class="s2">, </span><span class="s1">str]) -&gt; bool | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">weight = props.get(</span><span class="s3">&quot;font-weight&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">weight:</span>
            <span class="s2">return </span><span class="s1">self.BOLD_MAP.get(weight)</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_get_is_italic(self</span><span class="s2">, </span><span class="s1">props: Mapping[str</span><span class="s2">, </span><span class="s1">str]) -&gt; bool | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">font_style = props.get(</span><span class="s3">&quot;font-style&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">font_style:</span>
            <span class="s2">return </span><span class="s1">self.ITALIC_MAP.get(font_style)</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_get_decoration(self</span><span class="s2">, </span><span class="s1">props: Mapping[str</span><span class="s2">, </span><span class="s1">str]) -&gt; Sequence[str]:</span>
        <span class="s1">decoration = props.get(</span><span class="s3">&quot;text-decoration&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">decoration </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">decoration.split()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">()</span>

    <span class="s2">def </span><span class="s1">_get_underline(self</span><span class="s2">, </span><span class="s1">decoration: Sequence[str]) -&gt; str | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s3">&quot;underline&quot; </span><span class="s2">in </span><span class="s1">decoration:</span>
            <span class="s2">return </span><span class="s3">&quot;single&quot;</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_get_shadow(self</span><span class="s2">, </span><span class="s1">props: Mapping[str</span><span class="s2">, </span><span class="s1">str]) -&gt; bool | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s3">&quot;text-shadow&quot; </span><span class="s2">in </span><span class="s1">props:</span>
            <span class="s2">return </span><span class="s1">bool(re.search(</span><span class="s3">&quot;^[^#(]*[1-9]&quot;</span><span class="s2">, </span><span class="s1">props[</span><span class="s3">&quot;text-shadow&quot;</span><span class="s1">]))</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_get_font_names(self</span><span class="s2">, </span><span class="s1">props: Mapping[str</span><span class="s2">, </span><span class="s1">str]) -&gt; Sequence[str]:</span>
        <span class="s1">font_names_tmp = re.findall(</span>
            <span class="s3">r&quot;&quot;&quot;(?x) 
            ( 
            &quot;(?:[^&quot;]|\\&quot;)+&quot; 
            | 
            '(?:[^']|\\')+' 
            | 
            [^'&quot;,]+ 
            )(?=,|\s*$) 
        &quot;&quot;&quot;</span><span class="s2">,</span>
            <span class="s1">props.get(</span><span class="s3">&quot;font-family&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">font_names = []</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">font_names_tmp:</span>
            <span class="s2">if </span><span class="s1">name[:</span><span class="s5">1</span><span class="s1">] == </span><span class="s3">'&quot;'</span><span class="s1">:</span>
                <span class="s1">name = name[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">].replace(</span><span class="s3">'</span><span class="s2">\\</span><span class="s3">&quot;'</span><span class="s2">, </span><span class="s3">'&quot;'</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">name[:</span><span class="s5">1</span><span class="s1">] == </span><span class="s3">&quot;'&quot;</span><span class="s1">:</span>
                <span class="s1">name = name[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">].replace(</span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">'&quot;</span><span class="s2">, </span><span class="s3">&quot;'&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">name = name.strip()</span>
            <span class="s2">if </span><span class="s1">name:</span>
                <span class="s1">font_names.append(name)</span>
        <span class="s2">return </span><span class="s1">font_names</span>

    <span class="s2">def </span><span class="s1">_get_font_size(self</span><span class="s2">, </span><span class="s1">props: Mapping[str</span><span class="s2">, </span><span class="s1">str]) -&gt; float | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">size = props.get(</span><span class="s3">&quot;font-size&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">size</span>
        <span class="s2">return </span><span class="s1">self._pt_to_float(size)</span>

    <span class="s2">def </span><span class="s1">_select_font_family(self</span><span class="s2">, </span><span class="s1">font_names) -&gt; int | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">family = </span><span class="s2">None</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">font_names:</span>
            <span class="s1">family = self.FAMILY_MAP.get(name)</span>
            <span class="s2">if </span><span class="s1">family:</span>
                <span class="s2">break</span>

        <span class="s2">return </span><span class="s1">family</span>

    <span class="s2">def </span><span class="s1">color_to_excel(self</span><span class="s2">, </span><span class="s1">val: str | </span><span class="s2">None</span><span class="s1">) -&gt; str | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">val </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return None</span>

        <span class="s2">if </span><span class="s1">self._is_hex_color(val):</span>
            <span class="s2">return </span><span class="s1">self._convert_hex_to_excel(val)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.NAMED_COLORS[val]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s1">warnings.warn(</span><span class="s3">f&quot;Unhandled color format: </span><span class="s2">{</span><span class="s1">repr(val)</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">CSSWarning)</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_is_hex_color(self</span><span class="s2">, </span><span class="s1">color_string: str) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">bool(color_string.startswith(</span><span class="s3">&quot;#&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_convert_hex_to_excel(self</span><span class="s2">, </span><span class="s1">color_string: str) -&gt; str:</span>
        <span class="s1">code = color_string.lstrip(</span><span class="s3">&quot;#&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self._is_shorthand_color(color_string):</span>
            <span class="s2">return </span><span class="s1">(code[</span><span class="s5">0</span><span class="s1">] * </span><span class="s5">2 </span><span class="s1">+ code[</span><span class="s5">1</span><span class="s1">] * </span><span class="s5">2 </span><span class="s1">+ code[</span><span class="s5">2</span><span class="s1">] * </span><span class="s5">2</span><span class="s1">).upper()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">code.upper()</span>

    <span class="s2">def </span><span class="s1">_is_shorthand_color(self</span><span class="s2">, </span><span class="s1">color_string: str) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Check if color code is shorthand. 
 
        #FFF is a shorthand as opposed to full #FFFFFF. 
        &quot;&quot;&quot;</span>
        <span class="s1">code = color_string.lstrip(</span><span class="s3">&quot;#&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(code) == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s2">return True</span>
        <span class="s2">elif </span><span class="s1">len(code) == </span><span class="s5">6</span><span class="s1">:</span>
            <span class="s2">return False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Unexpected color </span><span class="s2">{</span><span class="s1">color_string</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">ExcelFormatter:</span>
    <span class="s0">&quot;&quot;&quot; 
    Class for formatting a DataFrame to a list of ExcelCells, 
 
    Parameters 
    ---------- 
    df : DataFrame or Styler 
    na_rep: na representation 
    float_format : str, default None 
        Format string for floating point numbers 
    cols : sequence, optional 
        Columns to write 
    header : bool or sequence of str, default True 
        Write out column names. If a list of string is given it is 
        assumed to be aliases for the column names 
    index : bool, default True 
        output row names (index) 
    index_label : str or sequence, default None 
        Column label for index column(s) if desired. If None is given, and 
        `header` and `index` are True, then the index names are used. A 
        sequence should be given if the DataFrame uses MultiIndex. 
    merge_cells : bool, default False 
        Format MultiIndex and Hierarchical Rows as merged cells. 
    inf_rep : str, default `'inf'` 
        representation for np.inf values (which aren't representable in Excel) 
        A `'-'` sign will be added in front of -inf. 
    style_converter : callable, optional 
        This translates Styler styles (CSS) into ExcelWriter styles. 
        Defaults to ``CSSToExcelConverter()``. 
        It should have signature css_declarations string -&gt; excel style. 
        This is only called for body cells. 
    &quot;&quot;&quot;</span>

    <span class="s1">max_rows = </span><span class="s5">2 </span><span class="s1">** </span><span class="s5">20</span>
    <span class="s1">max_cols = </span><span class="s5">2 </span><span class="s1">** </span><span class="s5">14</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">df</span><span class="s2">,</span>
        <span class="s1">na_rep: str = </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
        <span class="s1">float_format: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">cols: Sequence[Hashable] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">header: Sequence[Hashable] | bool = </span><span class="s2">True,</span>
        <span class="s1">index: bool = </span><span class="s2">True,</span>
        <span class="s1">index_label: IndexLabel | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">merge_cells: bool = </span><span class="s2">False,</span>
        <span class="s1">inf_rep: str = </span><span class="s3">&quot;inf&quot;</span><span class="s2">,</span>
        <span class="s1">style_converter: Callable | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">self.rowcounter = </span><span class="s5">0</span>
        <span class="s1">self.na_rep = na_rep</span>
        <span class="s2">if not </span><span class="s1">isinstance(df</span><span class="s2">, </span><span class="s1">DataFrame):</span>
            <span class="s1">self.styler = df</span>
            <span class="s1">self.styler._compute()  </span><span class="s4"># calculate applied styles</span>
            <span class="s1">df = df.data</span>
            <span class="s2">if </span><span class="s1">style_converter </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">style_converter = CSSToExcelConverter()</span>
            <span class="s1">self.style_converter: Callable | </span><span class="s2">None </span><span class="s1">= style_converter</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.styler = </span><span class="s2">None</span>
            <span class="s1">self.style_converter = </span><span class="s2">None</span>
        <span class="s1">self.df = df</span>
        <span class="s2">if </span><span class="s1">cols </span><span class="s2">is not None</span><span class="s1">:</span>

            <span class="s4"># all missing, raise</span>
            <span class="s2">if not </span><span class="s1">len(Index(cols).intersection(df.columns)):</span>
                <span class="s2">raise </span><span class="s1">KeyError(</span><span class="s3">&quot;passes columns are not ALL present dataframe&quot;</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">len(Index(cols).intersection(df.columns)) != len(set(cols)):</span>
                <span class="s4"># Deprecated in GH#17295, enforced in 1.0.0</span>
                <span class="s2">raise </span><span class="s1">KeyError(</span><span class="s3">&quot;Not all names specified in 'columns' are found&quot;</span><span class="s1">)</span>

            <span class="s1">self.df = df.reindex(columns=cols)</span>

        <span class="s1">self.columns = self.df.columns</span>
        <span class="s1">self.float_format = float_format</span>
        <span class="s1">self.index = index</span>
        <span class="s1">self.index_label = index_label</span>
        <span class="s1">self.header = header</span>
        <span class="s1">self.merge_cells = merge_cells</span>
        <span class="s1">self.inf_rep = inf_rep</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">header_style(self):</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s3">&quot;font&quot;</span><span class="s1">: {</span><span class="s3">&quot;bold&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">}</span><span class="s2">,</span>
            <span class="s3">&quot;borders&quot;</span><span class="s1">: {</span>
                <span class="s3">&quot;top&quot;</span><span class="s1">: </span><span class="s3">&quot;thin&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;right&quot;</span><span class="s1">: </span><span class="s3">&quot;thin&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;bottom&quot;</span><span class="s1">: </span><span class="s3">&quot;thin&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;left&quot;</span><span class="s1">: </span><span class="s3">&quot;thin&quot;</span><span class="s2">,</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s3">&quot;alignment&quot;</span><span class="s1">: {</span><span class="s3">&quot;horizontal&quot;</span><span class="s1">: </span><span class="s3">&quot;center&quot;</span><span class="s2">, </span><span class="s3">&quot;vertical&quot;</span><span class="s1">: </span><span class="s3">&quot;top&quot;</span><span class="s1">}</span><span class="s2">,</span>
        <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">_format_value(self</span><span class="s2">, </span><span class="s1">val):</span>
        <span class="s2">if </span><span class="s1">is_scalar(val) </span><span class="s2">and </span><span class="s1">missing.isna(val):</span>
            <span class="s1">val = self.na_rep</span>
        <span class="s2">elif </span><span class="s1">is_float(val):</span>
            <span class="s2">if </span><span class="s1">missing.isposinf_scalar(val):</span>
                <span class="s1">val = self.inf_rep</span>
            <span class="s2">elif </span><span class="s1">missing.isneginf_scalar(val):</span>
                <span class="s1">val = </span><span class="s3">f&quot;-</span><span class="s2">{</span><span class="s1">self.inf_rep</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s2">elif </span><span class="s1">self.float_format </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">val = float(self.float_format % val)</span>
        <span class="s2">if </span><span class="s1">getattr(val</span><span class="s2">, </span><span class="s3">&quot;tzinfo&quot;</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Excel does not support datetimes with &quot;</span>
                <span class="s3">&quot;timezones. Please ensure that datetimes &quot;</span>
                <span class="s3">&quot;are timezone unaware before writing to Excel.&quot;</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">val</span>

    <span class="s2">def </span><span class="s1">_format_header_mi(self) -&gt; Iterable[ExcelCell]:</span>
        <span class="s2">if </span><span class="s1">self.columns.nlevels &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">self.index:</span>
                <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
                    <span class="s3">&quot;Writing to Excel with MultiIndex columns and no &quot;</span>
                    <span class="s3">&quot;index ('index'=False) is not yet implemented.&quot;</span>
                <span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">(self._has_aliases </span><span class="s2">or </span><span class="s1">self.header):</span>
            <span class="s2">return</span>

        <span class="s1">columns = self.columns</span>
        <span class="s1">level_strs = columns.format(</span>
            <span class="s1">sparsify=self.merge_cells</span><span class="s2">, </span><span class="s1">adjoin=</span><span class="s2">False, </span><span class="s1">names=</span><span class="s2">False</span>
        <span class="s1">)</span>
        <span class="s1">level_lengths = get_level_lengths(level_strs)</span>
        <span class="s1">coloffset = </span><span class="s5">0</span>
        <span class="s1">lnum = </span><span class="s5">0</span>

        <span class="s2">if </span><span class="s1">self.index </span><span class="s2">and </span><span class="s1">isinstance(self.df.index</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
            <span class="s1">coloffset = len(self.df.index[</span><span class="s5">0</span><span class="s1">]) - </span><span class="s5">1</span>

        <span class="s2">if </span><span class="s1">self.merge_cells:</span>
            <span class="s4"># Format multi-index as a merged cells.</span>
            <span class="s2">for </span><span class="s1">lnum</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">enumerate(columns.names):</span>
                <span class="s2">yield </span><span class="s1">ExcelCell(</span>
                    <span class="s1">row=lnum</span><span class="s2">,</span>
                    <span class="s1">col=coloffset</span><span class="s2">,</span>
                    <span class="s1">val=name</span><span class="s2">,</span>
                    <span class="s1">style=self.header_style</span><span class="s2">,</span>
                <span class="s1">)</span>

            <span class="s2">for </span><span class="s1">lnum</span><span class="s2">, </span><span class="s1">(spans</span><span class="s2">, </span><span class="s1">levels</span><span class="s2">, </span><span class="s1">level_codes) </span><span class="s2">in </span><span class="s1">enumerate(</span>
                <span class="s1">zip(level_lengths</span><span class="s2">, </span><span class="s1">columns.levels</span><span class="s2">, </span><span class="s1">columns.codes)</span>
            <span class="s1">):</span>
                <span class="s1">values = levels.take(level_codes)</span>
                <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">span_val </span><span class="s2">in </span><span class="s1">spans.items():</span>
                    <span class="s1">mergestart</span><span class="s2">, </span><span class="s1">mergeend = </span><span class="s2">None, None</span>
                    <span class="s2">if </span><span class="s1">span_val &gt; </span><span class="s5">1</span><span class="s1">:</span>
                        <span class="s1">mergestart</span><span class="s2">, </span><span class="s1">mergeend = lnum</span><span class="s2">, </span><span class="s1">coloffset + i + span_val</span>
                    <span class="s2">yield </span><span class="s1">CssExcelCell(</span>
                        <span class="s1">row=lnum</span><span class="s2">,</span>
                        <span class="s1">col=coloffset + i + </span><span class="s5">1</span><span class="s2">,</span>
                        <span class="s1">val=values[i]</span><span class="s2">,</span>
                        <span class="s1">style=self.header_style</span><span class="s2">,</span>
                        <span class="s1">css_styles=getattr(self.styler</span><span class="s2">, </span><span class="s3">&quot;ctx_columns&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">css_row=lnum</span><span class="s2">,</span>
                        <span class="s1">css_col=i</span><span class="s2">,</span>
                        <span class="s1">css_converter=self.style_converter</span><span class="s2">,</span>
                        <span class="s1">mergestart=mergestart</span><span class="s2">,</span>
                        <span class="s1">mergeend=mergeend</span><span class="s2">,</span>
                    <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># Format in legacy format with dots to indicate levels.</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">values </span><span class="s2">in </span><span class="s1">enumerate(zip(*level_strs)):</span>
                <span class="s1">v = </span><span class="s3">&quot;.&quot;</span><span class="s1">.join(map(pprint_thing</span><span class="s2">, </span><span class="s1">values))</span>
                <span class="s2">yield </span><span class="s1">CssExcelCell(</span>
                    <span class="s1">row=lnum</span><span class="s2">,</span>
                    <span class="s1">col=coloffset + i + </span><span class="s5">1</span><span class="s2">,</span>
                    <span class="s1">val=v</span><span class="s2">,</span>
                    <span class="s1">style=self.header_style</span><span class="s2">,</span>
                    <span class="s1">css_styles=getattr(self.styler</span><span class="s2">, </span><span class="s3">&quot;ctx_columns&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">css_row=lnum</span><span class="s2">,</span>
                    <span class="s1">css_col=i</span><span class="s2">,</span>
                    <span class="s1">css_converter=self.style_converter</span><span class="s2">,</span>
                <span class="s1">)</span>

        <span class="s1">self.rowcounter = lnum</span>

    <span class="s2">def </span><span class="s1">_format_header_regular(self) -&gt; Iterable[ExcelCell]:</span>
        <span class="s2">if </span><span class="s1">self._has_aliases </span><span class="s2">or </span><span class="s1">self.header:</span>
            <span class="s1">coloffset = </span><span class="s5">0</span>

            <span class="s2">if </span><span class="s1">self.index:</span>
                <span class="s1">coloffset = </span><span class="s5">1</span>
                <span class="s2">if </span><span class="s1">isinstance(self.df.index</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
                    <span class="s1">coloffset = len(self.df.index[</span><span class="s5">0</span><span class="s1">])</span>

            <span class="s1">colnames = self.columns</span>
            <span class="s2">if </span><span class="s1">self._has_aliases:</span>
                <span class="s1">self.header = cast(Sequence</span><span class="s2">, </span><span class="s1">self.header)</span>
                <span class="s2">if </span><span class="s1">len(self.header) != len(self.columns):</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">f&quot;Writing </span><span class="s2">{</span><span class="s1">len(self.columns)</span><span class="s2">} </span><span class="s3">cols &quot;</span>
                        <span class="s3">f&quot;but got </span><span class="s2">{</span><span class="s1">len(self.header)</span><span class="s2">} </span><span class="s3">aliases&quot;</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">colnames = self.header</span>

            <span class="s2">for </span><span class="s1">colindex</span><span class="s2">, </span><span class="s1">colname </span><span class="s2">in </span><span class="s1">enumerate(colnames):</span>
                <span class="s2">yield </span><span class="s1">CssExcelCell(</span>
                    <span class="s1">row=self.rowcounter</span><span class="s2">,</span>
                    <span class="s1">col=colindex + coloffset</span><span class="s2">,</span>
                    <span class="s1">val=colname</span><span class="s2">,</span>
                    <span class="s1">style=self.header_style</span><span class="s2">,</span>
                    <span class="s1">css_styles=getattr(self.styler</span><span class="s2">, </span><span class="s3">&quot;ctx_columns&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">css_row=</span><span class="s5">0</span><span class="s2">,</span>
                    <span class="s1">css_col=colindex</span><span class="s2">,</span>
                    <span class="s1">css_converter=self.style_converter</span><span class="s2">,</span>
                <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_format_header(self) -&gt; Iterable[ExcelCell]:</span>
        <span class="s2">if </span><span class="s1">isinstance(self.columns</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
            <span class="s1">gen = self._format_header_mi()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">gen = self._format_header_regular()</span>

        <span class="s1">gen2 = ()</span>
        <span class="s2">if </span><span class="s1">self.df.index.names:</span>
            <span class="s1">row = [x </span><span class="s2">if </span><span class="s1">x </span><span class="s2">is not None else </span><span class="s3">&quot;&quot; </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self.df.index.names] + [</span>
                <span class="s3">&quot;&quot;</span>
            <span class="s1">] * len(self.columns)</span>
            <span class="s2">if </span><span class="s1">reduce(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y: x </span><span class="s2">and </span><span class="s1">y</span><span class="s2">, </span><span class="s1">map(</span><span class="s2">lambda </span><span class="s1">x: x != </span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">row)):</span>
                <span class="s4"># error: Incompatible types in assignment (expression has type</span>
                <span class="s4"># &quot;Generator[ExcelCell, None, None]&quot;, variable has type &quot;Tuple[]&quot;)</span>
                <span class="s1">gen2 = (  </span><span class="s4"># type: ignore[assignment]</span>
                    <span class="s1">ExcelCell(self.rowcounter</span><span class="s2">, </span><span class="s1">colindex</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">self.header_style)</span>
                    <span class="s2">for </span><span class="s1">colindex</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">enumerate(row)</span>
                <span class="s1">)</span>
                <span class="s1">self.rowcounter += </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">itertools.chain(gen</span><span class="s2">, </span><span class="s1">gen2)</span>

    <span class="s2">def </span><span class="s1">_format_body(self) -&gt; Iterable[ExcelCell]:</span>
        <span class="s2">if </span><span class="s1">isinstance(self.df.index</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
            <span class="s2">return </span><span class="s1">self._format_hierarchical_rows()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._format_regular_rows()</span>

    <span class="s2">def </span><span class="s1">_format_regular_rows(self) -&gt; Iterable[ExcelCell]:</span>
        <span class="s2">if </span><span class="s1">self._has_aliases </span><span class="s2">or </span><span class="s1">self.header:</span>
            <span class="s1">self.rowcounter += </span><span class="s5">1</span>

        <span class="s4"># output index and index_label?</span>
        <span class="s2">if </span><span class="s1">self.index:</span>
            <span class="s4"># check aliases</span>
            <span class="s4"># if list only take first as this is not a MultiIndex</span>
            <span class="s2">if </span><span class="s1">self.index_label </span><span class="s2">and </span><span class="s1">isinstance(</span>
                <span class="s1">self.index_label</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">np.ndarray</span><span class="s2">, </span><span class="s1">Index)</span>
            <span class="s1">):</span>
                <span class="s1">index_label = self.index_label[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s4"># if string good to go</span>
            <span class="s2">elif </span><span class="s1">self.index_label </span><span class="s2">and </span><span class="s1">isinstance(self.index_label</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">index_label = self.index_label</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">index_label = self.df.index.names[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s2">if </span><span class="s1">isinstance(self.columns</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
                <span class="s1">self.rowcounter += </span><span class="s5">1</span>

            <span class="s2">if </span><span class="s1">index_label </span><span class="s2">and </span><span class="s1">self.header </span><span class="s2">is not False</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s1">ExcelCell(self.rowcounter - </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">index_label</span><span class="s2">, </span><span class="s1">self.header_style)</span>

            <span class="s4"># write index_values</span>
            <span class="s1">index_values = self.df.index</span>
            <span class="s2">if </span><span class="s1">isinstance(self.df.index</span><span class="s2">, </span><span class="s1">PeriodIndex):</span>
                <span class="s1">index_values = self.df.index.to_timestamp()</span>

            <span class="s2">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">idxval </span><span class="s2">in </span><span class="s1">enumerate(index_values):</span>
                <span class="s2">yield </span><span class="s1">CssExcelCell(</span>
                    <span class="s1">row=self.rowcounter + idx</span><span class="s2">,</span>
                    <span class="s1">col=</span><span class="s5">0</span><span class="s2">,</span>
                    <span class="s1">val=idxval</span><span class="s2">,</span>
                    <span class="s1">style=self.header_style</span><span class="s2">,</span>
                    <span class="s1">css_styles=getattr(self.styler</span><span class="s2">, </span><span class="s3">&quot;ctx_index&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">css_row=idx</span><span class="s2">,</span>
                    <span class="s1">css_col=</span><span class="s5">0</span><span class="s2">,</span>
                    <span class="s1">css_converter=self.style_converter</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">coloffset = </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">coloffset = </span><span class="s5">0</span>

        <span class="s2">yield from </span><span class="s1">self._generate_body(coloffset)</span>

    <span class="s2">def </span><span class="s1">_format_hierarchical_rows(self) -&gt; Iterable[ExcelCell]:</span>
        <span class="s2">if </span><span class="s1">self._has_aliases </span><span class="s2">or </span><span class="s1">self.header:</span>
            <span class="s1">self.rowcounter += </span><span class="s5">1</span>

        <span class="s1">gcolidx = </span><span class="s5">0</span>

        <span class="s2">if </span><span class="s1">self.index:</span>
            <span class="s1">index_labels = self.df.index.names</span>
            <span class="s4"># check for aliases</span>
            <span class="s2">if </span><span class="s1">self.index_label </span><span class="s2">and </span><span class="s1">isinstance(</span>
                <span class="s1">self.index_label</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">np.ndarray</span><span class="s2">, </span><span class="s1">Index)</span>
            <span class="s1">):</span>
                <span class="s1">index_labels = self.index_label</span>

            <span class="s4"># MultiIndex columns require an extra row</span>
            <span class="s4"># with index names (blank if None) for</span>
            <span class="s4"># unambiguous round-trip, unless not merging,</span>
            <span class="s4"># in which case the names all go on one row Issue #11328</span>
            <span class="s2">if </span><span class="s1">isinstance(self.columns</span><span class="s2">, </span><span class="s1">MultiIndex) </span><span class="s2">and </span><span class="s1">self.merge_cells:</span>
                <span class="s1">self.rowcounter += </span><span class="s5">1</span>

            <span class="s4"># if index labels are not empty go ahead and dump</span>
            <span class="s2">if </span><span class="s1">com.any_not_none(*index_labels) </span><span class="s2">and </span><span class="s1">self.header </span><span class="s2">is not False</span><span class="s1">:</span>

                <span class="s2">for </span><span class="s1">cidx</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">enumerate(index_labels):</span>
                    <span class="s2">yield </span><span class="s1">ExcelCell(self.rowcounter - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">cidx</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">self.header_style)</span>

            <span class="s2">if </span><span class="s1">self.merge_cells:</span>
                <span class="s4"># Format hierarchical rows as merged cells.</span>
                <span class="s1">level_strs = self.df.index.format(</span>
                    <span class="s1">sparsify=</span><span class="s2">True, </span><span class="s1">adjoin=</span><span class="s2">False, </span><span class="s1">names=</span><span class="s2">False</span>
                <span class="s1">)</span>
                <span class="s1">level_lengths = get_level_lengths(level_strs)</span>

                <span class="s2">for </span><span class="s1">spans</span><span class="s2">, </span><span class="s1">levels</span><span class="s2">, </span><span class="s1">level_codes </span><span class="s2">in </span><span class="s1">zip(</span>
                    <span class="s1">level_lengths</span><span class="s2">, </span><span class="s1">self.df.index.levels</span><span class="s2">, </span><span class="s1">self.df.index.codes</span>
                <span class="s1">):</span>

                    <span class="s1">values = levels.take(</span>
                        <span class="s1">level_codes</span><span class="s2">,</span>
                        <span class="s1">allow_fill=levels._can_hold_na</span><span class="s2">,</span>
                        <span class="s1">fill_value=levels._na_value</span><span class="s2">,</span>
                    <span class="s1">)</span>

                    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">span_val </span><span class="s2">in </span><span class="s1">spans.items():</span>
                        <span class="s1">mergestart</span><span class="s2">, </span><span class="s1">mergeend = </span><span class="s2">None, None</span>
                        <span class="s2">if </span><span class="s1">span_val &gt; </span><span class="s5">1</span><span class="s1">:</span>
                            <span class="s1">mergestart = self.rowcounter + i + span_val - </span><span class="s5">1</span>
                            <span class="s1">mergeend = gcolidx</span>
                        <span class="s2">yield </span><span class="s1">CssExcelCell(</span>
                            <span class="s1">row=self.rowcounter + i</span><span class="s2">,</span>
                            <span class="s1">col=gcolidx</span><span class="s2">,</span>
                            <span class="s1">val=values[i]</span><span class="s2">,</span>
                            <span class="s1">style=self.header_style</span><span class="s2">,</span>
                            <span class="s1">css_styles=getattr(self.styler</span><span class="s2">, </span><span class="s3">&quot;ctx_index&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">css_row=i</span><span class="s2">,</span>
                            <span class="s1">css_col=gcolidx</span><span class="s2">,</span>
                            <span class="s1">css_converter=self.style_converter</span><span class="s2">,</span>
                            <span class="s1">mergestart=mergestart</span><span class="s2">,</span>
                            <span class="s1">mergeend=mergeend</span><span class="s2">,</span>
                        <span class="s1">)</span>
                    <span class="s1">gcolidx += </span><span class="s5">1</span>

            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># Format hierarchical rows with non-merged values.</span>
                <span class="s2">for </span><span class="s1">indexcolvals </span><span class="s2">in </span><span class="s1">zip(*self.df.index):</span>
                    <span class="s2">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">indexcolval </span><span class="s2">in </span><span class="s1">enumerate(indexcolvals):</span>
                        <span class="s2">yield </span><span class="s1">CssExcelCell(</span>
                            <span class="s1">row=self.rowcounter + idx</span><span class="s2">,</span>
                            <span class="s1">col=gcolidx</span><span class="s2">,</span>
                            <span class="s1">val=indexcolval</span><span class="s2">,</span>
                            <span class="s1">style=self.header_style</span><span class="s2">,</span>
                            <span class="s1">css_styles=getattr(self.styler</span><span class="s2">, </span><span class="s3">&quot;ctx_index&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">css_row=idx</span><span class="s2">,</span>
                            <span class="s1">css_col=gcolidx</span><span class="s2">,</span>
                            <span class="s1">css_converter=self.style_converter</span><span class="s2">,</span>
                        <span class="s1">)</span>
                    <span class="s1">gcolidx += </span><span class="s5">1</span>

        <span class="s2">yield from </span><span class="s1">self._generate_body(gcolidx)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_has_aliases(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Whether the aliases for column names are present.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">is_list_like(self.header)</span>

    <span class="s2">def </span><span class="s1">_generate_body(self</span><span class="s2">, </span><span class="s1">coloffset: int) -&gt; Iterable[ExcelCell]:</span>
        <span class="s4"># Write the body of the frame data series by series.</span>
        <span class="s2">for </span><span class="s1">colidx </span><span class="s2">in </span><span class="s1">range(len(self.columns)):</span>
            <span class="s1">series = self.df.iloc[:</span><span class="s2">, </span><span class="s1">colidx]</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">enumerate(series):</span>
                <span class="s2">yield </span><span class="s1">CssExcelCell(</span>
                    <span class="s1">row=self.rowcounter + i</span><span class="s2">,</span>
                    <span class="s1">col=colidx + coloffset</span><span class="s2">,</span>
                    <span class="s1">val=val</span><span class="s2">,</span>
                    <span class="s1">style=</span><span class="s2">None,</span>
                    <span class="s1">css_styles=getattr(self.styler</span><span class="s2">, </span><span class="s3">&quot;ctx&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">css_row=i</span><span class="s2">,</span>
                    <span class="s1">css_col=colidx</span><span class="s2">,</span>
                    <span class="s1">css_converter=self.style_converter</span><span class="s2">,</span>
                <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_formatted_cells(self) -&gt; Iterable[ExcelCell]:</span>
        <span class="s2">for </span><span class="s1">cell </span><span class="s2">in </span><span class="s1">itertools.chain(self._format_header()</span><span class="s2">, </span><span class="s1">self._format_body()):</span>
            <span class="s1">cell.val = self._format_value(cell.val)</span>
            <span class="s2">yield </span><span class="s1">cell</span>

    <span class="s1">@doc(storage_options=_shared_docs[</span><span class="s3">&quot;storage_options&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">write(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">writer</span><span class="s2">,</span>
        <span class="s1">sheet_name=</span><span class="s3">&quot;Sheet1&quot;</span><span class="s2">,</span>
        <span class="s1">startrow=</span><span class="s5">0</span><span class="s2">,</span>
        <span class="s1">startcol=</span><span class="s5">0</span><span class="s2">,</span>
        <span class="s1">freeze_panes=</span><span class="s2">None,</span>
        <span class="s1">engine=</span><span class="s2">None,</span>
        <span class="s1">storage_options: StorageOptions = </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        writer : path-like, file-like, or ExcelWriter object 
            File path or existing ExcelWriter 
        sheet_name : str, default 'Sheet1' 
            Name of sheet which will contain DataFrame 
        startrow : 
            upper left cell row to dump data frame 
        startcol : 
            upper left cell column to dump data frame 
        freeze_panes : tuple of integer (length 2), default None 
            Specifies the one-based bottommost row and rightmost column that 
            is to be frozen 
        engine : string, default None 
            write engine to use if writer is a path - you can also set this 
            via the options ``io.excel.xlsx.writer``, ``io.excel.xls.writer``, 
            and ``io.excel.xlsm.writer``. 
 
            .. deprecated:: 1.2.0 
 
                As the `xlwt &lt;https://pypi.org/project/xlwt/&gt;`__ package is no longer 
                maintained, the ``xlwt`` engine will be removed in a future 
                version of pandas. 
 
        {storage_options} 
 
            .. versionadded:: 1.2.0 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas.io.excel </span><span class="s2">import </span><span class="s1">ExcelWriter</span>

        <span class="s1">num_rows</span><span class="s2">, </span><span class="s1">num_cols = self.df.shape</span>
        <span class="s2">if </span><span class="s1">num_rows &gt; self.max_rows </span><span class="s2">or </span><span class="s1">num_cols &gt; self.max_cols:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">f&quot;This sheet is too large! Your sheet size is: </span><span class="s2">{</span><span class="s1">num_rows</span><span class="s2">}</span><span class="s3">, </span><span class="s2">{</span><span class="s1">num_cols</span><span class="s2">} </span><span class="s3">&quot;</span>
                <span class="s3">f&quot;Max sheet size is: </span><span class="s2">{</span><span class="s1">self.max_rows</span><span class="s2">}</span><span class="s3">, </span><span class="s2">{</span><span class="s1">self.max_cols</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s1">)</span>

        <span class="s1">formatted_cells = self.get_formatted_cells()</span>
        <span class="s2">if </span><span class="s1">isinstance(writer</span><span class="s2">, </span><span class="s1">ExcelWriter):</span>
            <span class="s1">need_save = </span><span class="s2">False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># error: Cannot instantiate abstract class 'ExcelWriter' with abstract</span>
            <span class="s4"># attributes 'engine', 'save', 'supported_extensions' and 'write_cells'</span>
            <span class="s1">writer = ExcelWriter(  </span><span class="s4"># type: ignore[abstract]</span>
                <span class="s1">writer</span><span class="s2">, </span><span class="s1">engine=engine</span><span class="s2">, </span><span class="s1">storage_options=storage_options</span>
            <span class="s1">)</span>
            <span class="s1">need_save = </span><span class="s2">True</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">writer.write_cells(</span>
                <span class="s1">formatted_cells</span><span class="s2">,</span>
                <span class="s1">sheet_name</span><span class="s2">,</span>
                <span class="s1">startrow=startrow</span><span class="s2">,</span>
                <span class="s1">startcol=startcol</span><span class="s2">,</span>
                <span class="s1">freeze_panes=freeze_panes</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s4"># make sure to close opened file handles</span>
            <span class="s2">if </span><span class="s1">need_save:</span>
                <span class="s1">writer.close()</span>
</pre>
</body>
</html>