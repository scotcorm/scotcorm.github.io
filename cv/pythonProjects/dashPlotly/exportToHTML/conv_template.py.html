<html>
<head>
<title>conv_template.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
conv_template.py</font>
</center></td></tr></table>
<pre><span class="s0">#!/usr/bin/env python3</span>
<span class="s2">&quot;&quot;&quot; 
takes templated file .xxx.src and produces .xxx file  where .xxx is 
.i or .c or .h, using the following template rules 
 
/**begin repeat  -- on a line by itself marks the start of a repeated code 
                    segment 
/**end repeat**/ -- on a line by itself marks it's end 
 
After the /**begin repeat and before the */, all the named templates are placed 
these should all have the same number of replacements 
 
Repeat blocks can be nested, with each nested block labeled with its depth, 
i.e. 
/**begin repeat1 
 *.... 
 */ 
/**end repeat1**/ 
 
When using nested loops, you can optionally exclude particular 
combinations of the variables using (inside the comment portion of the inner loop): 
 
 :exclude: var1=value1, var2=value2, ... 
 
This will exclude the pattern where var1 is value1 and var2 is value2 when 
the result is being generated. 
 
 
In the main body each replace will use one entry from the list of named replacements 
 
 Note that all #..# forms in a block must have the same number of 
   comma-separated entries. 
 
Example: 
 
    An input file containing 
 
        /**begin repeat 
         * #a = 1,2,3# 
         * #b = 1,2,3# 
         */ 
 
        /**begin repeat1 
         * #c = ted, jim# 
         */ 
        @a@, @b@, @c@ 
        /**end repeat1**/ 
 
        /**end repeat**/ 
 
    produces 
 
        line 1 &quot;template.c.src&quot; 
 
        /* 
         ********************************************************************* 
         **       This file was autogenerated from a template  DO NOT EDIT!!** 
         **       Changes should be made to the original source (.src) file ** 
         ********************************************************************* 
         */ 
 
        #line 9 
        1, 1, ted 
 
        #line 9 
        1, 1, jim 
 
        #line 9 
        2, 2, ted 
 
        #line 9 
        2, 2, jim 
 
        #line 9 
        3, 3, ted 
 
        #line 9 
        3, 3, jim 
 
&quot;&quot;&quot;</span>

<span class="s1">__all__ = [</span><span class="s3">'process_str'</span><span class="s4">, </span><span class="s3">'process_file'</span><span class="s1">]</span>

<span class="s4">import </span><span class="s1">os</span>
<span class="s4">import </span><span class="s1">sys</span>
<span class="s4">import </span><span class="s1">re</span>

<span class="s0"># names for replacement that are already global.</span>
<span class="s1">global_names = {}</span>

<span class="s0"># header placed at the front of head processed file</span>
<span class="s1">header =\</span>
<span class="s3">&quot;&quot;&quot; 
/* 
 ***************************************************************************** 
 **       This file was autogenerated from a template  DO NOT EDIT!!!!      ** 
 **       Changes should be made to the original source (.src) file         ** 
 ***************************************************************************** 
 */ 
 
&quot;&quot;&quot;</span>
<span class="s0"># Parse string for repeat loops</span>
<span class="s4">def </span><span class="s1">parse_structure(astr</span><span class="s4">, </span><span class="s1">level):</span>
    <span class="s2">&quot;&quot;&quot; 
    The returned line number is from the beginning of the string, starting 
    at zero. Returns an empty list if no loops found. 
 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">level == </span><span class="s5">0 </span><span class="s1">:</span>
        <span class="s1">loopbeg = </span><span class="s3">&quot;/**begin repeat&quot;</span>
        <span class="s1">loopend = </span><span class="s3">&quot;/**end repeat**/&quot;</span>
    <span class="s4">else </span><span class="s1">:</span>
        <span class="s1">loopbeg = </span><span class="s3">&quot;/**begin repeat%d&quot; </span><span class="s1">% level</span>
        <span class="s1">loopend = </span><span class="s3">&quot;/**end repeat%d**/&quot; </span><span class="s1">% level</span>

    <span class="s1">ind = </span><span class="s5">0</span>
    <span class="s1">line = </span><span class="s5">0</span>
    <span class="s1">spanlist = []</span>
    <span class="s4">while True</span><span class="s1">:</span>
        <span class="s1">start = astr.find(loopbeg</span><span class="s4">, </span><span class="s1">ind)</span>
        <span class="s4">if </span><span class="s1">start == -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">break</span>
        <span class="s1">start2 = astr.find(</span><span class="s3">&quot;*/&quot;</span><span class="s4">, </span><span class="s1">start)</span>
        <span class="s1">start2 = astr.find(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s4">, </span><span class="s1">start2)</span>
        <span class="s1">fini1 = astr.find(loopend</span><span class="s4">, </span><span class="s1">start2)</span>
        <span class="s1">fini2 = astr.find(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s4">, </span><span class="s1">fini1)</span>
        <span class="s1">line += astr.count(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s4">, </span><span class="s1">ind</span><span class="s4">, </span><span class="s1">start2+</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">spanlist.append((start</span><span class="s4">, </span><span class="s1">start2+</span><span class="s5">1</span><span class="s4">, </span><span class="s1">fini1</span><span class="s4">, </span><span class="s1">fini2+</span><span class="s5">1</span><span class="s4">, </span><span class="s1">line))</span>
        <span class="s1">line += astr.count(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s4">, </span><span class="s1">start2+</span><span class="s5">1</span><span class="s4">, </span><span class="s1">fini2)</span>
        <span class="s1">ind = fini2</span>
    <span class="s1">spanlist.sort()</span>
    <span class="s4">return </span><span class="s1">spanlist</span>


<span class="s4">def </span><span class="s1">paren_repl(obj):</span>
    <span class="s1">torep = obj.group(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">numrep = obj.group(</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s4">return </span><span class="s3">','</span><span class="s1">.join([torep]*int(numrep))</span>

<span class="s1">parenrep = re.compile(</span><span class="s3">r&quot;\(([^)]*)\)\*(\d+)&quot;</span><span class="s1">)</span>
<span class="s1">plainrep = re.compile(</span><span class="s3">r&quot;([^*]+)\*(\d+)&quot;</span><span class="s1">)</span>
<span class="s4">def </span><span class="s1">parse_values(astr):</span>
    <span class="s0"># replaces all occurrences of '(a,b,c)*4' in astr</span>
    <span class="s0"># with 'a,b,c,a,b,c,a,b,c,a,b,c'. Empty braces generate</span>
    <span class="s0"># empty values, i.e., ()*4 yields ',,,'. The result is</span>
    <span class="s0"># split at ',' and a list of values returned.</span>
    <span class="s1">astr = parenrep.sub(paren_repl</span><span class="s4">, </span><span class="s1">astr)</span>
    <span class="s0"># replaces occurrences of xxx*3 with xxx, xxx, xxx</span>
    <span class="s1">astr = </span><span class="s3">','</span><span class="s1">.join([plainrep.sub(paren_repl</span><span class="s4">, </span><span class="s1">x.strip())</span>
                     <span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">astr.split(</span><span class="s3">','</span><span class="s1">)])</span>
    <span class="s4">return </span><span class="s1">astr.split(</span><span class="s3">','</span><span class="s1">)</span>


<span class="s1">stripast = re.compile(</span><span class="s3">r&quot;\n\s*\*?&quot;</span><span class="s1">)</span>
<span class="s1">named_re = re.compile(</span><span class="s3">r&quot;#\s*(\w*)\s*=([^#]*)#&quot;</span><span class="s1">)</span>
<span class="s1">exclude_vars_re = re.compile(</span><span class="s3">r&quot;(\w*)=(\w*)&quot;</span><span class="s1">)</span>
<span class="s1">exclude_re = re.compile(</span><span class="s3">&quot;:exclude:&quot;</span><span class="s1">)</span>
<span class="s4">def </span><span class="s1">parse_loop_header(loophead) :</span>
    <span class="s2">&quot;&quot;&quot;Find all named replacements in the header 
 
    Returns a list of dictionaries, one for each loop iteration, 
    where each key is a name to be substituted and the corresponding 
    value is the replacement string. 
 
    Also return a list of exclusions.  The exclusions are dictionaries 
     of key value pairs. There can be more than one exclusion. 
     [{'var1':'value1', 'var2', 'value2'[,...]}, ...] 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># Strip out '\n' and leading '*', if any, in continuation lines.</span>
    <span class="s0"># This should not effect code previous to this change as</span>
    <span class="s0"># continuation lines were not allowed.</span>
    <span class="s1">loophead = stripast.sub(</span><span class="s3">&quot;&quot;</span><span class="s4">, </span><span class="s1">loophead)</span>
    <span class="s0"># parse out the names and lists of values</span>
    <span class="s1">names = []</span>
    <span class="s1">reps = named_re.findall(loophead)</span>
    <span class="s1">nsub = </span><span class="s4">None</span>
    <span class="s4">for </span><span class="s1">rep </span><span class="s4">in </span><span class="s1">reps:</span>
        <span class="s1">name = rep[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">vals = parse_values(rep[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">size = len(vals)</span>
        <span class="s4">if </span><span class="s1">nsub </span><span class="s4">is None </span><span class="s1">:</span>
            <span class="s1">nsub = size</span>
        <span class="s4">elif </span><span class="s1">nsub != size :</span>
            <span class="s1">msg = </span><span class="s3">&quot;Mismatch in number of values, %d != %d</span><span class="s4">\n</span><span class="s3">%s = %s&quot;</span>
            <span class="s4">raise </span><span class="s1">ValueError(msg % (nsub</span><span class="s4">, </span><span class="s1">size</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">vals))</span>
        <span class="s1">names.append((name</span><span class="s4">, </span><span class="s1">vals))</span>


    <span class="s0"># Find any exclude variables</span>
    <span class="s1">excludes = []</span>

    <span class="s4">for </span><span class="s1">obj </span><span class="s4">in </span><span class="s1">exclude_re.finditer(loophead):</span>
        <span class="s1">span = obj.span()</span>
        <span class="s0"># find next newline</span>
        <span class="s1">endline = loophead.find(</span><span class="s3">'</span><span class="s4">\n</span><span class="s3">'</span><span class="s4">, </span><span class="s1">span[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">substr = loophead[span[</span><span class="s5">1</span><span class="s1">]:endline]</span>
        <span class="s1">ex_names = exclude_vars_re.findall(substr)</span>
        <span class="s1">excludes.append(dict(ex_names))</span>

    <span class="s0"># generate list of dictionaries, one for each template iteration</span>
    <span class="s1">dlist = []</span>
    <span class="s4">if </span><span class="s1">nsub </span><span class="s4">is None </span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;No substitution variables found&quot;</span><span class="s1">)</span>
    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(nsub):</span>
        <span class="s1">tmp = {name: vals[i] </span><span class="s4">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">vals </span><span class="s4">in </span><span class="s1">names}</span>
        <span class="s1">dlist.append(tmp)</span>
    <span class="s4">return </span><span class="s1">dlist</span>

<span class="s1">replace_re = re.compile(</span><span class="s3">r&quot;@(\w+)@&quot;</span><span class="s1">)</span>
<span class="s4">def </span><span class="s1">parse_string(astr</span><span class="s4">, </span><span class="s1">env</span><span class="s4">, </span><span class="s1">level</span><span class="s4">, </span><span class="s1">line) :</span>
    <span class="s1">lineno = </span><span class="s3">&quot;#line %d</span><span class="s4">\n</span><span class="s3">&quot; </span><span class="s1">% line</span>

    <span class="s0"># local function for string replacement, uses env</span>
    <span class="s4">def </span><span class="s1">replace(match):</span>
        <span class="s1">name = match.group(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s4">try </span><span class="s1">:</span>
            <span class="s1">val = env[name]</span>
        <span class="s4">except </span><span class="s1">KeyError:</span>
            <span class="s1">msg = </span><span class="s3">'line %d: no definition of key &quot;%s&quot;'</span><span class="s1">%(line</span><span class="s4">, </span><span class="s1">name)</span>
            <span class="s4">raise </span><span class="s1">ValueError(msg) </span><span class="s4">from None</span>
        <span class="s4">return </span><span class="s1">val</span>

    <span class="s1">code = [lineno]</span>
    <span class="s1">struct = parse_structure(astr</span><span class="s4">, </span><span class="s1">level)</span>
    <span class="s4">if </span><span class="s1">struct :</span>
        <span class="s0"># recurse over inner loops</span>
        <span class="s1">oldend = </span><span class="s5">0</span>
        <span class="s1">newlevel = level + </span><span class="s5">1</span>
        <span class="s4">for </span><span class="s1">sub </span><span class="s4">in </span><span class="s1">struct:</span>
            <span class="s1">pref = astr[oldend:sub[</span><span class="s5">0</span><span class="s1">]]</span>
            <span class="s1">head = astr[sub[</span><span class="s5">0</span><span class="s1">]:sub[</span><span class="s5">1</span><span class="s1">]]</span>
            <span class="s1">text = astr[sub[</span><span class="s5">1</span><span class="s1">]:sub[</span><span class="s5">2</span><span class="s1">]]</span>
            <span class="s1">oldend = sub[</span><span class="s5">3</span><span class="s1">]</span>
            <span class="s1">newline = line + sub[</span><span class="s5">4</span><span class="s1">]</span>
            <span class="s1">code.append(replace_re.sub(replace</span><span class="s4">, </span><span class="s1">pref))</span>
            <span class="s4">try </span><span class="s1">:</span>
                <span class="s1">envlist = parse_loop_header(head)</span>
            <span class="s4">except </span><span class="s1">ValueError </span><span class="s4">as </span><span class="s1">e:</span>
                <span class="s1">msg = </span><span class="s3">&quot;line %d: %s&quot; </span><span class="s1">% (newline</span><span class="s4">, </span><span class="s1">e)</span>
                <span class="s4">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s4">for </span><span class="s1">newenv </span><span class="s4">in </span><span class="s1">envlist :</span>
                <span class="s1">newenv.update(env)</span>
                <span class="s1">newcode = parse_string(text</span><span class="s4">, </span><span class="s1">newenv</span><span class="s4">, </span><span class="s1">newlevel</span><span class="s4">, </span><span class="s1">newline)</span>
                <span class="s1">code.extend(newcode)</span>
        <span class="s1">suff = astr[oldend:]</span>
        <span class="s1">code.append(replace_re.sub(replace</span><span class="s4">, </span><span class="s1">suff))</span>
    <span class="s4">else </span><span class="s1">:</span>
        <span class="s0"># replace keys</span>
        <span class="s1">code.append(replace_re.sub(replace</span><span class="s4">, </span><span class="s1">astr))</span>
    <span class="s1">code.append(</span><span class="s3">'</span><span class="s4">\n</span><span class="s3">'</span><span class="s1">)</span>
    <span class="s4">return </span><span class="s3">''</span><span class="s1">.join(code)</span>

<span class="s4">def </span><span class="s1">process_str(astr):</span>
    <span class="s1">code = [header]</span>
    <span class="s1">code.extend(parse_string(astr</span><span class="s4">, </span><span class="s1">global_names</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s1">))</span>
    <span class="s4">return </span><span class="s3">''</span><span class="s1">.join(code)</span>


<span class="s1">include_src_re = re.compile(</span><span class="s3">r&quot;(\n|\A)#include\s*['\&quot;]&quot;</span>
                            <span class="s3">r&quot;(?P&lt;name&gt;[\w\d./\\]+[.]src)['\&quot;]&quot;</span><span class="s4">, </span><span class="s1">re.I)</span>

<span class="s4">def </span><span class="s1">resolve_includes(source):</span>
    <span class="s1">d = os.path.dirname(source)</span>
    <span class="s4">with </span><span class="s1">open(source) </span><span class="s4">as </span><span class="s1">fid:</span>
        <span class="s1">lines = []</span>
        <span class="s4">for </span><span class="s1">line </span><span class="s4">in </span><span class="s1">fid:</span>
            <span class="s1">m = include_src_re.match(line)</span>
            <span class="s4">if </span><span class="s1">m:</span>
                <span class="s1">fn = m.group(</span><span class="s3">'name'</span><span class="s1">)</span>
                <span class="s4">if not </span><span class="s1">os.path.isabs(fn):</span>
                    <span class="s1">fn = os.path.join(d</span><span class="s4">, </span><span class="s1">fn)</span>
                <span class="s4">if </span><span class="s1">os.path.isfile(fn):</span>
                    <span class="s1">lines.extend(resolve_includes(fn))</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">lines.append(line)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">lines.append(line)</span>
    <span class="s4">return </span><span class="s1">lines</span>

<span class="s4">def </span><span class="s1">process_file(source):</span>
    <span class="s1">lines = resolve_includes(source)</span>
    <span class="s1">sourcefile = os.path.normcase(source).replace(</span><span class="s3">&quot;</span><span class="s4">\\</span><span class="s3">&quot;</span><span class="s4">, </span><span class="s3">&quot;</span><span class="s4">\\\\</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s4">try</span><span class="s1">:</span>
        <span class="s1">code = process_str(</span><span class="s3">''</span><span class="s1">.join(lines))</span>
    <span class="s4">except </span><span class="s1">ValueError </span><span class="s4">as </span><span class="s1">e:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'In &quot;%s&quot; loop at %s' </span><span class="s1">% (sourcefile</span><span class="s4">, </span><span class="s1">e)) </span><span class="s4">from None</span>
    <span class="s4">return </span><span class="s3">'#line 1 &quot;%s&quot;</span><span class="s4">\n</span><span class="s3">%s' </span><span class="s1">% (sourcefile</span><span class="s4">, </span><span class="s1">code)</span>


<span class="s4">def </span><span class="s1">unique_key(adict):</span>
    <span class="s0"># this obtains a unique key given a dictionary</span>
    <span class="s0"># currently it works by appending together n of the letters of the</span>
    <span class="s0">#   current keys and increasing n until a unique key is found</span>
    <span class="s0"># -- not particularly quick</span>
    <span class="s1">allkeys = list(adict.keys())</span>
    <span class="s1">done = </span><span class="s4">False</span>
    <span class="s1">n = </span><span class="s5">1</span>
    <span class="s4">while not </span><span class="s1">done:</span>
        <span class="s1">newkey = </span><span class="s3">&quot;&quot;</span><span class="s1">.join([x[:n] </span><span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">allkeys])</span>
        <span class="s4">if </span><span class="s1">newkey </span><span class="s4">in </span><span class="s1">allkeys:</span>
            <span class="s1">n += </span><span class="s5">1</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">done = </span><span class="s4">True</span>
    <span class="s4">return </span><span class="s1">newkey</span>


<span class="s4">def </span><span class="s1">main():</span>
    <span class="s4">try</span><span class="s1">:</span>
        <span class="s1">file = sys.argv[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s4">except </span><span class="s1">IndexError:</span>
        <span class="s1">fid = sys.stdin</span>
        <span class="s1">outfile = sys.stdout</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">fid = open(file</span><span class="s4">, </span><span class="s3">'r'</span><span class="s1">)</span>
        <span class="s1">(base</span><span class="s4">, </span><span class="s1">ext) = os.path.splitext(file)</span>
        <span class="s1">newname = base</span>
        <span class="s1">outfile = open(newname</span><span class="s4">, </span><span class="s3">'w'</span><span class="s1">)</span>

    <span class="s1">allstr = fid.read()</span>
    <span class="s4">try</span><span class="s1">:</span>
        <span class="s1">writestr = process_str(allstr)</span>
    <span class="s4">except </span><span class="s1">ValueError </span><span class="s4">as </span><span class="s1">e:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;In %s loop at %s&quot; </span><span class="s1">% (file</span><span class="s4">, </span><span class="s1">e)) </span><span class="s4">from None</span>

    <span class="s1">outfile.write(writestr)</span>

<span class="s4">if </span><span class="s1">__name__ == </span><span class="s3">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s1">main()</span>
</pre>
</body>
</html>