<html>
<head>
<title>png.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
png.py</font>
</center></td></tr></table>
<pre><span class="s0">#!/usr/bin/env python</span>

<span class="s0"># Vendored code from pypng https://github.com/drj11/pypng</span>
<span class="s0"># png.py - PNG encoder/decoder in pure Python</span>
<span class="s0">#</span>
<span class="s0"># Copyright (C) 2006 Johann C. Rocholl &lt;johann@browsershots.org&gt;</span>
<span class="s0"># Portions Copyright (C) 2009 David Jones &lt;drj@pobox.com&gt;</span>
<span class="s0"># And probably portions Copyright (C) 2006 Nicko van Someren &lt;nicko@nicko.org&gt;</span>
<span class="s0">#</span>
<span class="s0"># Original concept by Johann C. Rocholl.</span>
<span class="s0">#</span>
<span class="s0"># LICENCE (MIT)</span>
<span class="s0">#</span>
<span class="s0"># Permission is hereby granted, free of charge, to any person</span>
<span class="s0"># obtaining a copy of this software and associated documentation files</span>
<span class="s0"># (the &quot;Software&quot;), to deal in the Software without restriction,</span>
<span class="s0"># including without limitation the rights to use, copy, modify, merge,</span>
<span class="s0"># publish, distribute, sublicense, and/or sell copies of the Software,</span>
<span class="s0"># and to permit persons to whom the Software is furnished to do so,</span>
<span class="s0"># subject to the following conditions:</span>
<span class="s0">#</span>
<span class="s0"># The above copyright notice and this permission notice shall be</span>
<span class="s0"># included in all copies or substantial portions of the Software.</span>
<span class="s0">#</span>
<span class="s0"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="s0"># EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s0"># MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="s0"># NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="s0"># BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="s0"># ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="s0"># CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="s0"># SOFTWARE.</span>

<span class="s2">&quot;&quot;&quot; 
The ``png`` module can read and write PNG files. 
 
Installation and Overview 
------------------------- 
 
``pip install pypng`` 
 
For help, type ``import png; help(png)`` in your python interpreter. 
 
A good place to start is the :class:`Reader` and :class:`Writer` classes. 
 
Coverage of PNG formats is fairly complete; 
all allowable bit depths (1/2/4/8/16/24/32/48/64 bits per pixel) and 
colour combinations are supported: 
 
- greyscale (1/2/4/8/16 bit); 
- RGB, RGBA, LA (greyscale with alpha) with 8/16 bits per channel; 
- colour mapped images (1/2/4/8 bit). 
 
Interlaced images, 
which support a progressive display when downloading, 
are supported for both reading and writing. 
 
A number of optional chunks can be specified (when writing) 
and understood (when reading): ``tRNS``, ``bKGD``, ``gAMA``. 
 
The ``sBIT`` chunk can be used to specify precision for 
non-native bit depths. 
 
Requires Python 3.5 or higher. 
Installation is trivial, 
but see the ``README.txt`` file (with the source distribution) for details. 
 
Full use of all features will need some reading of the PNG specification 
http://www.w3.org/TR/2003/REC-PNG-20031110/. 
 
The package also comes with command line utilities. 
 
- ``pripamtopng`` converts 
  `Netpbm &lt;http://netpbm.sourceforge.net/&gt;`_ PAM/PNM files to PNG; 
- ``pripngtopam`` converts PNG to file PAM/PNM. 
 
There are a few more for simple PNG manipulations. 
 
Spelling and Terminology 
------------------------ 
 
Generally British English spelling is used in the documentation. 
So that's &quot;greyscale&quot; and &quot;colour&quot;. 
This not only matches the author's native language, 
it's also used by the PNG specification. 
 
Colour Models 
------------- 
 
The major colour models supported by PNG (and hence by PyPNG) are: 
 
- greyscale; 
- greyscale--alpha; 
- RGB; 
- RGB--alpha. 
 
Also referred to using the abbreviations: L, LA, RGB, RGBA. 
Each letter codes a single channel: 
*L* is for Luminance or Luma or Lightness (greyscale images); 
*A* stands for Alpha, the opacity channel 
(used for transparency effects, but higher values are more opaque, 
so it makes sense to call it opacity); 
*R*, *G*, *B* stand for Red, Green, Blue (colour image). 
 
Lists, arrays, sequences, and so on 
----------------------------------- 
 
When getting pixel data out of this module (reading) and 
presenting data to this module (writing) there are 
a number of ways the data could be represented as a Python value. 
 
The preferred format is a sequence of *rows*, 
which each row being a sequence of *values*. 
In this format, the values are in pixel order, 
with all the values from all the pixels in a row 
being concatenated into a single sequence for that row. 
 
Consider an image that is 3 pixels wide by 2 pixels high, and each pixel 
has RGB components: 
 
Sequence of rows:: 
 
  list([R,G,B, R,G,B, R,G,B], 
       [R,G,B, R,G,B, R,G,B]) 
 
Each row appears as its own list, 
but the pixels are flattened so that three values for one pixel 
simply follow the three values for the previous pixel. 
 
This is the preferred because 
it provides a good compromise between space and convenience. 
PyPNG regards itself as at liberty to replace any sequence type with 
any sufficiently compatible other sequence type; 
in practice each row is an array (``bytearray`` or ``array.array``). 
 
To allow streaming the outer list is sometimes 
an iterator rather than an explicit list. 
 
An alternative format is a single array holding all the values. 
 
Array of values:: 
 
  [R,G,B, R,G,B, R,G,B, 
   R,G,B, R,G,B, R,G,B] 
 
The entire image is one single giant sequence of colour values. 
Generally an array will be used (to save space), not a list. 
 
The top row comes first, 
and within each row the pixels are ordered from left-to-right. 
Within a pixel the values appear in the order R-G-B-A 
(or L-A for greyscale--alpha). 
 
There is another format, which should only be used with caution. 
It is mentioned because it is used internally, 
is close to what lies inside a PNG file itself, 
and has some support from the public API. 
This format is called *packed*. 
When packed, each row is a sequence of bytes (integers from 0 to 255), 
just as it is before PNG scanline filtering is applied. 
When the bit depth is 8 this is the same as a sequence of rows; 
when the bit depth is less than 8 (1, 2 and 4), 
several pixels are packed into each byte; 
when the bit depth is 16 each pixel value is decomposed into 2 bytes 
(and `packed` is a misnomer). 
This format is used by the :meth:`Writer.write_packed` method. 
It isn't usually a convenient format, 
but may be just right if the source data for 
the PNG image comes from something that uses a similar format 
(for example, 1-bit BMPs, or another PNG file). 
&quot;&quot;&quot;</span>

<span class="s1">__version__ = </span><span class="s3">&quot;0.0.20&quot;</span>

<span class="s4">import </span><span class="s1">collections</span>
<span class="s4">import </span><span class="s1">io  </span><span class="s0"># For io.BytesIO</span>
<span class="s4">import </span><span class="s1">itertools</span>
<span class="s4">import </span><span class="s1">math</span>

<span class="s0"># http://www.python.org/doc/2.4.4/lib/module-operator.html</span>
<span class="s4">import </span><span class="s1">operator</span>
<span class="s4">import </span><span class="s1">re</span>
<span class="s4">import </span><span class="s1">struct</span>
<span class="s4">import </span><span class="s1">sys</span>

<span class="s0"># http://www.python.org/doc/2.4.4/lib/module-warnings.html</span>
<span class="s4">import </span><span class="s1">warnings</span>
<span class="s4">import </span><span class="s1">zlib</span>

<span class="s4">from </span><span class="s1">array </span><span class="s4">import </span><span class="s1">array</span>


<span class="s1">__all__ = [</span><span class="s3">&quot;Image&quot;</span><span class="s4">, </span><span class="s3">&quot;Reader&quot;</span><span class="s4">, </span><span class="s3">&quot;Writer&quot;</span><span class="s4">, </span><span class="s3">&quot;write_chunks&quot;</span><span class="s4">, </span><span class="s3">&quot;from_array&quot;</span><span class="s1">]</span>


<span class="s0"># The PNG signature.</span>
<span class="s0"># http://www.w3.org/TR/PNG/#5PNG-file-signature</span>
<span class="s1">signature = struct.pack(</span><span class="s3">&quot;8B&quot;</span><span class="s4">, </span><span class="s5">137</span><span class="s4">, </span><span class="s5">80</span><span class="s4">, </span><span class="s5">78</span><span class="s4">, </span><span class="s5">71</span><span class="s4">, </span><span class="s5">13</span><span class="s4">, </span><span class="s5">10</span><span class="s4">, </span><span class="s5">26</span><span class="s4">, </span><span class="s5">10</span><span class="s1">)</span>

<span class="s0"># The xstart, ystart, xstep, ystep for the Adam7 interlace passes.</span>
<span class="s1">adam7 = (</span>
    <span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">8</span><span class="s4">, </span><span class="s5">8</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s5">4</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">8</span><span class="s4">, </span><span class="s5">8</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s5">8</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s5">2</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">,</span>
<span class="s1">)</span>


<span class="s4">def </span><span class="s1">adam7_generate(width</span><span class="s4">, </span><span class="s1">height):</span>
    <span class="s2">&quot;&quot;&quot; 
    Generate the coordinates for the reduced scanlines 
    of an Adam7 interlaced image 
    of size `width` by `height` pixels. 
 
    Yields a generator for each pass, 
    and each pass generator yields a series of (x, y, xstep) triples, 
    each one identifying a reduced scanline consisting of 
    pixels starting at (x, y) and taking every xstep pixel to the right. 
    &quot;&quot;&quot;</span>

    <span class="s4">for </span><span class="s1">xstart</span><span class="s4">, </span><span class="s1">ystart</span><span class="s4">, </span><span class="s1">xstep</span><span class="s4">, </span><span class="s1">ystep </span><span class="s4">in </span><span class="s1">adam7:</span>
        <span class="s4">if </span><span class="s1">xstart &gt;= width:</span>
            <span class="s4">continue</span>
        <span class="s4">yield </span><span class="s1">((xstart</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">xstep) </span><span class="s4">for </span><span class="s1">y </span><span class="s4">in </span><span class="s1">range(ystart</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">ystep))</span>


<span class="s0"># Models the 'pHYs' chunk (used by the Reader)</span>
<span class="s1">Resolution = collections.namedtuple(</span><span class="s3">&quot;_Resolution&quot;</span><span class="s4">, </span><span class="s3">&quot;x y unit_is_meter&quot;</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">group(s</span><span class="s4">, </span><span class="s1">n):</span>
    <span class="s4">return </span><span class="s1">list(zip(*[iter(s)] * n))</span>


<span class="s4">def </span><span class="s1">isarray(x):</span>
    <span class="s4">return </span><span class="s1">isinstance(x</span><span class="s4">, </span><span class="s1">array)</span>


<span class="s4">def </span><span class="s1">check_palette(palette):</span>
    <span class="s2">&quot;&quot;&quot; 
    Check a palette argument (to the :class:`Writer` class) for validity. 
    Returns the palette as a list if okay; 
    raises an exception otherwise. 
    &quot;&quot;&quot;</span>

    <span class="s0"># None is the default and is allowed.</span>
    <span class="s4">if </span><span class="s1">palette </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s4">return None</span>

    <span class="s1">p = list(palette)</span>
    <span class="s4">if not </span><span class="s1">(</span><span class="s5">0 </span><span class="s1">&lt; len(p) &lt;= </span><span class="s5">256</span><span class="s1">):</span>
        <span class="s4">raise </span><span class="s1">ProtocolError(</span>
            <span class="s3">&quot;a palette must have between 1 and 256 entries,&quot;</span>
            <span class="s3">&quot; see https://www.w3.org/TR/PNG/#11PLTE&quot;</span>
        <span class="s1">)</span>
    <span class="s1">seen_triple = </span><span class="s4">False</span>
    <span class="s4">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">t </span><span class="s4">in </span><span class="s1">enumerate(p):</span>
        <span class="s4">if </span><span class="s1">len(t) </span><span class="s4">not in </span><span class="s1">(</span><span class="s5">3</span><span class="s4">, </span><span class="s5">4</span><span class="s1">):</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;palette entry %d: entries must be 3- or 4-tuples.&quot; </span><span class="s1">% i)</span>
        <span class="s4">if </span><span class="s1">len(t) == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s1">seen_triple = </span><span class="s4">True</span>
        <span class="s4">if </span><span class="s1">seen_triple </span><span class="s4">and </span><span class="s1">len(t) == </span><span class="s5">4</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span>
                <span class="s3">&quot;palette entry %d: all 4-tuples must precede all 3-tuples&quot; </span><span class="s1">% i</span>
            <span class="s1">)</span>
        <span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">t:</span>
            <span class="s4">if </span><span class="s1">int(x) != x </span><span class="s4">or not </span><span class="s1">(</span><span class="s5">0 </span><span class="s1">&lt;= x &lt;= </span><span class="s5">255</span><span class="s1">):</span>
                <span class="s4">raise </span><span class="s1">ProtocolError(</span>
                    <span class="s3">&quot;palette entry %d: &quot; &quot;values must be integer: 0 &lt;= x &lt;= 255&quot; </span><span class="s1">% i</span>
                <span class="s1">)</span>
    <span class="s4">return </span><span class="s1">p</span>


<span class="s4">def </span><span class="s1">check_sizes(size</span><span class="s4">, </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height):</span>
    <span class="s2">&quot;&quot;&quot; 
    Check that these arguments, if supplied, are consistent. 
    Return a (width, height) pair. 
    &quot;&quot;&quot;</span>

    <span class="s4">if not </span><span class="s1">size:</span>
        <span class="s4">return </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height</span>

    <span class="s4">if </span><span class="s1">len(size) != </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;size argument should be a pair (width, height)&quot;</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">width </span><span class="s4">is not None and </span><span class="s1">width != size[</span><span class="s5">0</span><span class="s1">]:</span>
        <span class="s4">raise </span><span class="s1">ProtocolError(</span>
            <span class="s3">&quot;size[0] (%r) and width (%r) should match when both are used.&quot;</span>
            <span class="s1">% (size[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">width)</span>
        <span class="s1">)</span>
    <span class="s4">if </span><span class="s1">height </span><span class="s4">is not None and </span><span class="s1">height != size[</span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s4">raise </span><span class="s1">ProtocolError(</span>
            <span class="s3">&quot;size[1] (%r) and height (%r) should match when both are used.&quot;</span>
            <span class="s1">% (size[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s1">height)</span>
        <span class="s1">)</span>
    <span class="s4">return </span><span class="s1">size</span>


<span class="s4">def </span><span class="s1">check_color(c</span><span class="s4">, </span><span class="s1">greyscale</span><span class="s4">, </span><span class="s1">which):</span>
    <span class="s2">&quot;&quot;&quot; 
    Checks that a colour argument for transparent or background options 
    is the right form. 
    Returns the colour 
    (which, if it's a bare integer, is &quot;corrected&quot; to a 1-tuple). 
    &quot;&quot;&quot;</span>

    <span class="s4">if </span><span class="s1">c </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">c</span>
    <span class="s4">if </span><span class="s1">greyscale:</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">len(c)</span>
        <span class="s4">except </span><span class="s1">TypeError:</span>
            <span class="s1">c = (c</span><span class="s4">,</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">len(c) != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;%s for greyscale must be 1-tuple&quot; </span><span class="s1">% which)</span>
        <span class="s4">if not </span><span class="s1">is_natural(c[</span><span class="s5">0</span><span class="s1">]):</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;%s colour for greyscale must be integer&quot; </span><span class="s1">% which)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">if not </span><span class="s1">(</span>
            <span class="s1">len(c) == </span><span class="s5">3 </span><span class="s4">and </span><span class="s1">is_natural(c[</span><span class="s5">0</span><span class="s1">]) </span><span class="s4">and </span><span class="s1">is_natural(c[</span><span class="s5">1</span><span class="s1">]) </span><span class="s4">and </span><span class="s1">is_natural(c[</span><span class="s5">2</span><span class="s1">])</span>
        <span class="s1">):</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;%s colour must be a triple of integers&quot; </span><span class="s1">% which)</span>
    <span class="s4">return </span><span class="s1">c</span>


<span class="s4">class </span><span class="s1">Error(Exception):</span>
    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s4">return </span><span class="s1">self.__class__.__name__ + </span><span class="s3">&quot;: &quot; </span><span class="s1">+ </span><span class="s3">&quot; &quot;</span><span class="s1">.join(self.args)</span>


<span class="s4">class </span><span class="s1">FormatError(Error):</span>
    <span class="s2">&quot;&quot;&quot; 
    Problem with input file format. 
    In other words, PNG file does not conform to 
    the specification in some way and is invalid. 
    &quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">ProtocolError(Error):</span>
    <span class="s2">&quot;&quot;&quot; 
    Problem with the way the programming interface has been used, 
    or the data presented to it. 
    &quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">ChunkError(FormatError):</span>
    <span class="s4">pass</span>


<span class="s4">class </span><span class="s1">Default:</span>
    <span class="s2">&quot;&quot;&quot;The default for the greyscale paramter.&quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">Writer:</span>
    <span class="s2">&quot;&quot;&quot; 
    PNG encoder in pure Python. 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">width=</span><span class="s4">None,</span>
        <span class="s1">height=</span><span class="s4">None,</span>
        <span class="s1">size=</span><span class="s4">None,</span>
        <span class="s1">greyscale=Default</span><span class="s4">,</span>
        <span class="s1">alpha=</span><span class="s4">False,</span>
        <span class="s1">bitdepth=</span><span class="s5">8</span><span class="s4">,</span>
        <span class="s1">palette=</span><span class="s4">None,</span>
        <span class="s1">transparent=</span><span class="s4">None,</span>
        <span class="s1">background=</span><span class="s4">None,</span>
        <span class="s1">gamma=</span><span class="s4">None,</span>
        <span class="s1">compression=</span><span class="s4">None,</span>
        <span class="s1">interlace=</span><span class="s4">False,</span>
        <span class="s1">planes=</span><span class="s4">None,</span>
        <span class="s1">colormap=</span><span class="s4">None,</span>
        <span class="s1">maxval=</span><span class="s4">None,</span>
        <span class="s1">chunk_limit=</span><span class="s5">2 </span><span class="s1">** </span><span class="s5">20</span><span class="s4">,</span>
        <span class="s1">x_pixels_per_unit=</span><span class="s4">None,</span>
        <span class="s1">y_pixels_per_unit=</span><span class="s4">None,</span>
        <span class="s1">unit_is_meter=</span><span class="s4">False,</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create a PNG encoder object. 
 
        Arguments: 
 
        width, height 
          Image size in pixels, as two separate arguments. 
        size 
          Image size (w,h) in pixels, as single argument. 
        greyscale 
          Pixels are greyscale, not RGB. 
        alpha 
          Input data has alpha channel (RGBA or LA). 
        bitdepth 
          Bit depth: from 1 to 16 (for each channel). 
        palette 
          Create a palette for a colour mapped image (colour type 3). 
        transparent 
          Specify a transparent colour (create a ``tRNS`` chunk). 
        background 
          Specify a default background colour (create a ``bKGD`` chunk). 
        gamma 
          Specify a gamma value (create a ``gAMA`` chunk). 
        compression 
          zlib compression level: 0 (none) to 9 (more compressed); 
          default: -1 or None. 
        interlace 
          Create an interlaced image. 
        chunk_limit 
          Write multiple ``IDAT`` chunks to save memory. 
        x_pixels_per_unit 
          Number of pixels a unit along the x axis (write a 
          `pHYs` chunk). 
        y_pixels_per_unit 
          Number of pixels a unit along the y axis (write a 
          `pHYs` chunk). Along with `x_pixel_unit`, this gives 
          the pixel size ratio. 
        unit_is_meter 
          `True` to indicate that the unit (for the `pHYs` 
          chunk) is metre. 
 
        The image size (in pixels) can be specified either by using the 
        `width` and `height` arguments, or with the single `size` 
        argument. 
        If `size` is used it should be a pair (*width*, *height*). 
 
        The `greyscale` argument indicates whether input pixels 
        are greyscale (when true), or colour (when false). 
        The default is true unless `palette=` is used. 
 
        The `alpha` argument (a boolean) specifies 
        whether input pixels have an alpha channel (or not). 
 
        `bitdepth` specifies the bit depth of the source pixel values. 
        Each channel may have a different bit depth. 
        Each source pixel must have values that are 
        an integer between 0 and ``2**bitdepth-1``, where 
        `bitdepth` is the bit depth for the corresponding channel. 
        For example, 8-bit images have values between 0 and 255. 
        PNG only stores images with bit depths of 
        1,2,4,8, or 16 (the same for all channels). 
        When `bitdepth` is not one of these values or where 
        channels have different bit depths, 
        the next highest valid bit depth is selected, 
        and an ``sBIT`` (significant bits) chunk is generated 
        that specifies the original precision of the source image. 
        In this case the supplied pixel values will be rescaled to 
        fit the range of the selected bit depth. 
 
        The PNG file format supports many bit depth / colour model 
        combinations, but not all. 
        The details are somewhat arcane 
        (refer to the PNG specification for full details). 
        Briefly: 
        Bit depths &lt; 8 (1,2,4) are only allowed with greyscale and 
        colour mapped images; 
        colour mapped images cannot have bit depth 16. 
 
        For colour mapped images 
        (in other words, when the `palette` argument is specified) 
        the `bitdepth` argument must match one of 
        the valid PNG bit depths: 1, 2, 4, or 8. 
        (It is valid to have a PNG image with a palette and 
        an ``sBIT`` chunk, but the meaning is slightly different; 
        it would be awkward to use the `bitdepth` argument for this.) 
 
        The `palette` option, when specified, 
        causes a colour mapped image to be created: 
        the PNG colour type is set to 3; 
        `greyscale` must not be true; `alpha` must not be true; 
        `transparent` must not be set. 
        The bit depth must be 1,2,4, or 8. 
        When a colour mapped image is created, 
        the pixel values are palette indexes and 
        the `bitdepth` argument specifies the size of these indexes 
        (not the size of the colour values in the palette). 
 
        The palette argument value should be a sequence of 3- or 
        4-tuples. 
        3-tuples specify RGB palette entries; 
        4-tuples specify RGBA palette entries. 
        All the 4-tuples (if present) must come before all the 3-tuples. 
        A ``PLTE`` chunk is created; 
        if there are 4-tuples then a ``tRNS`` chunk is created as well. 
        The ``PLTE`` chunk will contain all the RGB triples in the same 
        sequence; 
        the ``tRNS`` chunk will contain the alpha channel for 
        all the 4-tuples, in the same sequence. 
        Palette entries are always 8-bit. 
 
        If specified, the `transparent` and `background` parameters must be 
        a tuple with one element for each channel in the image. 
        Either a 3-tuple of integer (RGB) values for a colour image, or 
        a 1-tuple of a single integer for a greyscale image. 
 
        If specified, the `gamma` parameter must be a positive number 
        (generally, a `float`). 
        A ``gAMA`` chunk will be created. 
        Note that this will not change the values of the pixels as 
        they appear in the PNG file, 
        they are assumed to have already 
        been converted appropriately for the gamma specified. 
 
        The `compression` argument specifies the compression level to 
        be used by the ``zlib`` module. 
        Values from 1 to 9 (highest) specify compression. 
        0 means no compression. 
        -1 and ``None`` both mean that the ``zlib`` module uses 
        the default level of compession (which is generally acceptable). 
 
        If `interlace` is true then an interlaced image is created 
        (using PNG's so far only interace method, *Adam7*). 
        This does not affect how the pixels should be passed in, 
        rather it changes how they are arranged into the PNG file. 
        On slow connexions interlaced images can be 
        partially decoded by the browser to give 
        a rough view of the image that is 
        successively refined as more image data appears. 
 
        .. note :: 
 
          Enabling the `interlace` option requires the entire image 
          to be processed in working memory. 
 
        `chunk_limit` is used to limit the amount of memory used whilst 
        compressing the image. 
        In order to avoid using large amounts of memory, 
        multiple ``IDAT`` chunks may be created. 
        &quot;&quot;&quot;</span>

        <span class="s0"># At the moment the `planes` argument is ignored;</span>
        <span class="s0"># its purpose is to act as a dummy so that</span>
        <span class="s0"># ``Writer(x, y, **info)`` works, where `info` is a dictionary</span>
        <span class="s0"># returned by Reader.read and friends.</span>
        <span class="s0"># Ditto for `colormap`.</span>

        <span class="s1">width</span><span class="s4">, </span><span class="s1">height = check_sizes(size</span><span class="s4">, </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height)</span>
        <span class="s4">del </span><span class="s1">size</span>

        <span class="s4">if not </span><span class="s1">is_natural(width) </span><span class="s4">or not </span><span class="s1">is_natural(height):</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;width and height must be integers&quot;</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">width &lt;= </span><span class="s5">0 </span><span class="s4">or </span><span class="s1">height &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;width and height must be greater than zero&quot;</span><span class="s1">)</span>
        <span class="s0"># http://www.w3.org/TR/PNG/#7Integers-and-byte-order</span>
        <span class="s4">if </span><span class="s1">width &gt; </span><span class="s5">2 </span><span class="s1">** </span><span class="s5">31 </span><span class="s1">- </span><span class="s5">1 </span><span class="s4">or </span><span class="s1">height &gt; </span><span class="s5">2 </span><span class="s1">** </span><span class="s5">31 </span><span class="s1">- </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;width and height cannot exceed 2**31-1&quot;</span><span class="s1">)</span>

        <span class="s4">if </span><span class="s1">alpha </span><span class="s4">and </span><span class="s1">transparent </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;transparent colour not allowed with alpha channel&quot;</span><span class="s1">)</span>

        <span class="s0"># bitdepth is either single integer, or tuple of integers.</span>
        <span class="s0"># Convert to tuple.</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">len(bitdepth)</span>
        <span class="s4">except </span><span class="s1">TypeError:</span>
            <span class="s1">bitdepth = (bitdepth</span><span class="s4">,</span><span class="s1">)</span>
        <span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">bitdepth:</span>
            <span class="s1">valid = is_natural(b) </span><span class="s4">and </span><span class="s5">1 </span><span class="s1">&lt;= b &lt;= </span><span class="s5">16</span>
            <span class="s4">if not </span><span class="s1">valid:</span>
                <span class="s4">raise </span><span class="s1">ProtocolError(</span>
                    <span class="s3">&quot;each bitdepth %r must be a positive integer &lt;= 16&quot; </span><span class="s1">% (bitdepth</span><span class="s4">,</span><span class="s1">)</span>
                <span class="s1">)</span>

        <span class="s0"># Calculate channels, and</span>
        <span class="s0"># expand bitdepth to be one element per channel.</span>
        <span class="s1">palette = check_palette(palette)</span>
        <span class="s1">alpha = bool(alpha)</span>
        <span class="s1">colormap = bool(palette)</span>
        <span class="s4">if </span><span class="s1">greyscale </span><span class="s4">is </span><span class="s1">Default </span><span class="s4">and </span><span class="s1">palette:</span>
            <span class="s1">greyscale = </span><span class="s4">False</span>
        <span class="s1">greyscale = bool(greyscale)</span>
        <span class="s4">if </span><span class="s1">colormap:</span>
            <span class="s1">color_planes = </span><span class="s5">1</span>
            <span class="s1">planes = </span><span class="s5">1</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">color_planes = (</span><span class="s5">3</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)[greyscale]</span>
            <span class="s1">planes = color_planes + alpha</span>
        <span class="s4">if </span><span class="s1">len(bitdepth) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">bitdepth *= planes</span>

        <span class="s1">bitdepth</span><span class="s4">, </span><span class="s1">self.rescale = check_bitdepth_rescale(</span>
            <span class="s1">palette</span><span class="s4">, </span><span class="s1">bitdepth</span><span class="s4">, </span><span class="s1">transparent</span><span class="s4">, </span><span class="s1">alpha</span><span class="s4">, </span><span class="s1">greyscale</span>
        <span class="s1">)</span>

        <span class="s0"># These are assertions, because above logic should have</span>
        <span class="s0"># corrected or raised all problematic cases.</span>
        <span class="s4">if </span><span class="s1">bitdepth &lt; </span><span class="s5">8</span><span class="s1">:</span>
            <span class="s4">assert </span><span class="s1">greyscale </span><span class="s4">or </span><span class="s1">palette</span>
            <span class="s4">assert not </span><span class="s1">alpha</span>
        <span class="s4">if </span><span class="s1">bitdepth &gt; </span><span class="s5">8</span><span class="s1">:</span>
            <span class="s4">assert not </span><span class="s1">palette</span>

        <span class="s1">transparent = check_color(transparent</span><span class="s4">, </span><span class="s1">greyscale</span><span class="s4">, </span><span class="s3">&quot;transparent&quot;</span><span class="s1">)</span>
        <span class="s1">background = check_color(background</span><span class="s4">, </span><span class="s1">greyscale</span><span class="s4">, </span><span class="s3">&quot;background&quot;</span><span class="s1">)</span>

        <span class="s0"># It's important that the true boolean values</span>
        <span class="s0"># (greyscale, alpha, colormap, interlace) are converted</span>
        <span class="s0"># to bool because Iverson's convention is relied upon later on.</span>
        <span class="s1">self.width = width</span>
        <span class="s1">self.height = height</span>
        <span class="s1">self.transparent = transparent</span>
        <span class="s1">self.background = background</span>
        <span class="s1">self.gamma = gamma</span>
        <span class="s1">self.greyscale = greyscale</span>
        <span class="s1">self.alpha = alpha</span>
        <span class="s1">self.colormap = colormap</span>
        <span class="s1">self.bitdepth = int(bitdepth)</span>
        <span class="s1">self.compression = compression</span>
        <span class="s1">self.chunk_limit = chunk_limit</span>
        <span class="s1">self.interlace = bool(interlace)</span>
        <span class="s1">self.palette = palette</span>
        <span class="s1">self.x_pixels_per_unit = x_pixels_per_unit</span>
        <span class="s1">self.y_pixels_per_unit = y_pixels_per_unit</span>
        <span class="s1">self.unit_is_meter = bool(unit_is_meter)</span>

        <span class="s1">self.color_type = </span><span class="s5">4 </span><span class="s1">* self.alpha + </span><span class="s5">2 </span><span class="s1">* (</span><span class="s4">not </span><span class="s1">greyscale) + </span><span class="s5">1 </span><span class="s1">* self.colormap</span>
        <span class="s4">assert </span><span class="s1">self.color_type </span><span class="s4">in </span><span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s5">6</span><span class="s1">)</span>

        <span class="s1">self.color_planes = color_planes</span>
        <span class="s1">self.planes = planes</span>
        <span class="s0"># :todo: fix for bitdepth &lt; 8</span>
        <span class="s1">self.psize = (self.bitdepth / </span><span class="s5">8</span><span class="s1">) * self.planes</span>

    <span class="s4">def </span><span class="s1">write(self</span><span class="s4">, </span><span class="s1">outfile</span><span class="s4">, </span><span class="s1">rows):</span>
        <span class="s2">&quot;&quot;&quot; 
        Write a PNG image to the output file. 
        `rows` should be an iterable that yields each row 
        (each row is a sequence of values). 
        The rows should be the rows of the original image, 
        so there should be ``self.height`` rows of 
        ``self.width * self.planes`` values. 
        If `interlace` is specified (when creating the instance), 
        then an interlaced PNG file will be written. 
        Supply the rows in the normal image order; 
        the interlacing is carried out internally. 
 
        .. note :: 
 
          Interlacing requires the entire image to be in working memory. 
        &quot;&quot;&quot;</span>

        <span class="s0"># Values per row</span>
        <span class="s1">vpr = self.width * self.planes</span>

        <span class="s4">def </span><span class="s1">check_rows(rows):</span>
            <span class="s2">&quot;&quot;&quot; 
            Yield each row in rows, 
            but check each row first (for correct width). 
            &quot;&quot;&quot;</span>
            <span class="s4">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">row </span><span class="s4">in </span><span class="s1">enumerate(rows):</span>
                <span class="s4">try</span><span class="s1">:</span>
                    <span class="s1">wrong_length = len(row) != vpr</span>
                <span class="s4">except </span><span class="s1">TypeError:</span>
                    <span class="s0"># When using an itertools.ichain object or</span>
                    <span class="s0"># other generator not supporting __len__,</span>
                    <span class="s0"># we set this to False to skip the check.</span>
                    <span class="s1">wrong_length = </span><span class="s4">False</span>
                <span class="s4">if </span><span class="s1">wrong_length:</span>
                    <span class="s0"># Note: row numbers start at 0.</span>
                    <span class="s4">raise </span><span class="s1">ProtocolError(</span>
                        <span class="s3">&quot;Expected %d values but got %d values, in row %d&quot;</span>
                        <span class="s1">% (vpr</span><span class="s4">, </span><span class="s1">len(row)</span><span class="s4">, </span><span class="s1">i)</span>
                    <span class="s1">)</span>
                <span class="s4">yield </span><span class="s1">row</span>

        <span class="s4">if </span><span class="s1">self.interlace:</span>
            <span class="s1">fmt = </span><span class="s3">&quot;BH&quot;</span><span class="s1">[self.bitdepth &gt; </span><span class="s5">8</span><span class="s1">]</span>
            <span class="s1">a = array(fmt</span><span class="s4">, </span><span class="s1">itertools.chain(*check_rows(rows)))</span>
            <span class="s4">return </span><span class="s1">self.write_array(outfile</span><span class="s4">, </span><span class="s1">a)</span>

        <span class="s1">nrows = self.write_passes(outfile</span><span class="s4">, </span><span class="s1">check_rows(rows))</span>
        <span class="s4">if </span><span class="s1">nrows != self.height:</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span>
                <span class="s3">&quot;rows supplied (%d) does not match height (%d)&quot; </span><span class="s1">% (nrows</span><span class="s4">, </span><span class="s1">self.height)</span>
            <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">write_passes(self</span><span class="s4">, </span><span class="s1">outfile</span><span class="s4">, </span><span class="s1">rows):</span>
        <span class="s2">&quot;&quot;&quot; 
        Write a PNG image to the output file. 
 
        Most users are expected to find the :meth:`write` or 
        :meth:`write_array` method more convenient. 
 
        The rows should be given to this method in the order that 
        they appear in the output file. 
        For straightlaced images, this is the usual top to bottom ordering. 
        For interlaced images the rows should have been interlaced before 
        passing them to this function. 
 
        `rows` should be an iterable that yields each row 
        (each row being a sequence of values). 
        &quot;&quot;&quot;</span>

        <span class="s0"># Ensure rows are scaled (to 4-/8-/16-bit),</span>
        <span class="s0"># and packed into bytes.</span>

        <span class="s4">if </span><span class="s1">self.rescale:</span>
            <span class="s1">rows = rescale_rows(rows</span><span class="s4">, </span><span class="s1">self.rescale)</span>

        <span class="s4">if </span><span class="s1">self.bitdepth &lt; </span><span class="s5">8</span><span class="s1">:</span>
            <span class="s1">rows = pack_rows(rows</span><span class="s4">, </span><span class="s1">self.bitdepth)</span>
        <span class="s4">elif </span><span class="s1">self.bitdepth == </span><span class="s5">16</span><span class="s1">:</span>
            <span class="s1">rows = unpack_rows(rows)</span>

        <span class="s4">return </span><span class="s1">self.write_packed(outfile</span><span class="s4">, </span><span class="s1">rows)</span>

    <span class="s4">def </span><span class="s1">write_packed(self</span><span class="s4">, </span><span class="s1">outfile</span><span class="s4">, </span><span class="s1">rows):</span>
        <span class="s2">&quot;&quot;&quot; 
        Write PNG file to `outfile`. 
        `rows` should be an iterator that yields each packed row; 
        a packed row being a sequence of packed bytes. 
 
        The rows have a filter byte prefixed and 
        are then compressed into one or more IDAT chunks. 
        They are not processed any further, 
        so if bitdepth is other than 1, 2, 4, 8, 16, 
        the pixel values should have been scaled 
        before passing them to this method. 
 
        This method does work for interlaced images but it is best avoided. 
        For interlaced images, the rows should be 
        presented in the order that they appear in the file. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.write_preamble(outfile)</span>

        <span class="s0"># http://www.w3.org/TR/PNG/#11IDAT</span>
        <span class="s4">if </span><span class="s1">self.compression </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">compressor = zlib.compressobj(self.compression)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">compressor = zlib.compressobj()</span>

        <span class="s0"># data accumulates bytes to be compressed for the IDAT chunk;</span>
        <span class="s0"># it's compressed when sufficiently large.</span>
        <span class="s1">data = bytearray()</span>

        <span class="s4">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">row </span><span class="s4">in </span><span class="s1">enumerate(rows):</span>
            <span class="s0"># Add &quot;None&quot; filter type.</span>
            <span class="s0"># Currently, it's essential that this filter type be used</span>
            <span class="s0"># for every scanline as</span>
            <span class="s0"># we do not mark the first row of a reduced pass image;</span>
            <span class="s0"># that means we could accidentally compute</span>
            <span class="s0"># the wrong filtered scanline if we used</span>
            <span class="s0"># &quot;up&quot;, &quot;average&quot;, or &quot;paeth&quot; on such a line.</span>
            <span class="s1">data.append(</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">data.extend(row)</span>
            <span class="s4">if </span><span class="s1">len(data) &gt; self.chunk_limit:</span>
                <span class="s1">compressed = compressor.compress(data)</span>
                <span class="s4">if </span><span class="s1">len(compressed):</span>
                    <span class="s1">write_chunk(outfile</span><span class="s4">, </span><span class="s6">b&quot;IDAT&quot;</span><span class="s4">, </span><span class="s1">compressed)</span>
                <span class="s1">data = bytearray()</span>

        <span class="s1">compressed = compressor.compress(bytes(data))</span>
        <span class="s1">flushed = compressor.flush()</span>
        <span class="s4">if </span><span class="s1">len(compressed) </span><span class="s4">or </span><span class="s1">len(flushed):</span>
            <span class="s1">write_chunk(outfile</span><span class="s4">, </span><span class="s6">b&quot;IDAT&quot;</span><span class="s4">, </span><span class="s1">compressed + flushed)</span>
        <span class="s0"># http://www.w3.org/TR/PNG/#11IEND</span>
        <span class="s1">write_chunk(outfile</span><span class="s4">, </span><span class="s6">b&quot;IEND&quot;</span><span class="s1">)</span>
        <span class="s4">return </span><span class="s1">i + </span><span class="s5">1</span>

    <span class="s4">def </span><span class="s1">write_preamble(self</span><span class="s4">, </span><span class="s1">outfile):</span>
        <span class="s0"># http://www.w3.org/TR/PNG/#5PNG-file-signature</span>
        <span class="s1">outfile.write(signature)</span>

        <span class="s0"># http://www.w3.org/TR/PNG/#11IHDR</span>
        <span class="s1">write_chunk(</span>
            <span class="s1">outfile</span><span class="s4">,</span>
            <span class="s6">b&quot;IHDR&quot;</span><span class="s4">,</span>
            <span class="s1">struct.pack(</span>
                <span class="s3">&quot;!2I5B&quot;</span><span class="s4">,</span>
                <span class="s1">self.width</span><span class="s4">,</span>
                <span class="s1">self.height</span><span class="s4">,</span>
                <span class="s1">self.bitdepth</span><span class="s4">,</span>
                <span class="s1">self.color_type</span><span class="s4">,</span>
                <span class="s5">0</span><span class="s4">,</span>
                <span class="s5">0</span><span class="s4">,</span>
                <span class="s1">self.interlace</span><span class="s4">,</span>
            <span class="s1">)</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s0"># See :chunk:order</span>
        <span class="s0"># http://www.w3.org/TR/PNG/#11gAMA</span>
        <span class="s4">if </span><span class="s1">self.gamma </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">write_chunk(</span>
                <span class="s1">outfile</span><span class="s4">, </span><span class="s6">b&quot;gAMA&quot;</span><span class="s4">, </span><span class="s1">struct.pack(</span><span class="s3">&quot;!L&quot;</span><span class="s4">, </span><span class="s1">int(round(self.gamma * </span><span class="s5">1e5</span><span class="s1">)))</span>
            <span class="s1">)</span>

        <span class="s0"># See :chunk:order</span>
        <span class="s0"># http://www.w3.org/TR/PNG/#11sBIT</span>
        <span class="s4">if </span><span class="s1">self.rescale:</span>
            <span class="s1">write_chunk(</span>
                <span class="s1">outfile</span><span class="s4">,</span>
                <span class="s6">b&quot;sBIT&quot;</span><span class="s4">,</span>
                <span class="s1">struct.pack(</span><span class="s3">&quot;%dB&quot; </span><span class="s1">% self.planes</span><span class="s4">, </span><span class="s1">*[s[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">for </span><span class="s1">s </span><span class="s4">in </span><span class="s1">self.rescale])</span><span class="s4">,</span>
            <span class="s1">)</span>

        <span class="s0"># :chunk:order: Without a palette (PLTE chunk),</span>
        <span class="s0"># ordering is relatively relaxed.</span>
        <span class="s0"># With one, gAMA chunk must precede PLTE chunk</span>
        <span class="s0"># which must precede tRNS and bKGD.</span>
        <span class="s0"># See http://www.w3.org/TR/PNG/#5ChunkOrdering</span>
        <span class="s4">if </span><span class="s1">self.palette:</span>
            <span class="s1">p</span><span class="s4">, </span><span class="s1">t = make_palette_chunks(self.palette)</span>
            <span class="s1">write_chunk(outfile</span><span class="s4">, </span><span class="s6">b&quot;PLTE&quot;</span><span class="s4">, </span><span class="s1">p)</span>
            <span class="s4">if </span><span class="s1">t:</span>
                <span class="s0"># tRNS chunk is optional;</span>
                <span class="s0"># Only needed if palette entries have alpha.</span>
                <span class="s1">write_chunk(outfile</span><span class="s4">, </span><span class="s6">b&quot;tRNS&quot;</span><span class="s4">, </span><span class="s1">t)</span>

        <span class="s0"># http://www.w3.org/TR/PNG/#11tRNS</span>
        <span class="s4">if </span><span class="s1">self.transparent </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">self.greyscale:</span>
                <span class="s1">fmt = </span><span class="s3">&quot;!1H&quot;</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">fmt = </span><span class="s3">&quot;!3H&quot;</span>
            <span class="s1">write_chunk(outfile</span><span class="s4">, </span><span class="s6">b&quot;tRNS&quot;</span><span class="s4">, </span><span class="s1">struct.pack(fmt</span><span class="s4">, </span><span class="s1">*self.transparent))</span>

        <span class="s0"># http://www.w3.org/TR/PNG/#11bKGD</span>
        <span class="s4">if </span><span class="s1">self.background </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">self.greyscale:</span>
                <span class="s1">fmt = </span><span class="s3">&quot;!1H&quot;</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">fmt = </span><span class="s3">&quot;!3H&quot;</span>
            <span class="s1">write_chunk(outfile</span><span class="s4">, </span><span class="s6">b&quot;bKGD&quot;</span><span class="s4">, </span><span class="s1">struct.pack(fmt</span><span class="s4">, </span><span class="s1">*self.background))</span>

        <span class="s0"># http://www.w3.org/TR/PNG/#11pHYs</span>
        <span class="s4">if </span><span class="s1">self.x_pixels_per_unit </span><span class="s4">is not None and </span><span class="s1">self.y_pixels_per_unit </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">tup = (</span>
                <span class="s1">self.x_pixels_per_unit</span><span class="s4">,</span>
                <span class="s1">self.y_pixels_per_unit</span><span class="s4">,</span>
                <span class="s1">int(self.unit_is_meter)</span><span class="s4">,</span>
            <span class="s1">)</span>
            <span class="s1">write_chunk(outfile</span><span class="s4">, </span><span class="s6">b&quot;pHYs&quot;</span><span class="s4">, </span><span class="s1">struct.pack(</span><span class="s3">&quot;!LLB&quot;</span><span class="s4">, </span><span class="s1">*tup))</span>

    <span class="s4">def </span><span class="s1">write_array(self</span><span class="s4">, </span><span class="s1">outfile</span><span class="s4">, </span><span class="s1">pixels):</span>
        <span class="s2">&quot;&quot;&quot; 
        Write an array that holds all the image values 
        as a PNG file on the output file. 
        See also :meth:`write` method. 
        &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">self.interlace:</span>
            <span class="s4">if </span><span class="s1">type(pixels) != array:</span>
                <span class="s0"># Coerce to array type</span>
                <span class="s1">fmt = </span><span class="s3">&quot;BH&quot;</span><span class="s1">[self.bitdepth &gt; </span><span class="s5">8</span><span class="s1">]</span>
                <span class="s1">pixels = array(fmt</span><span class="s4">, </span><span class="s1">pixels)</span>
            <span class="s1">self.write_passes(outfile</span><span class="s4">, </span><span class="s1">self.array_scanlines_interlace(pixels))</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">self.write_passes(outfile</span><span class="s4">, </span><span class="s1">self.array_scanlines(pixels))</span>

    <span class="s4">def </span><span class="s1">array_scanlines(self</span><span class="s4">, </span><span class="s1">pixels):</span>
        <span class="s2">&quot;&quot;&quot; 
        Generates rows (each a sequence of values) from 
        a single array of values. 
        &quot;&quot;&quot;</span>

        <span class="s0"># Values per row</span>
        <span class="s1">vpr = self.width * self.planes</span>
        <span class="s1">stop = </span><span class="s5">0</span>
        <span class="s4">for </span><span class="s1">y </span><span class="s4">in </span><span class="s1">range(self.height):</span>
            <span class="s1">start = stop</span>
            <span class="s1">stop = start + vpr</span>
            <span class="s4">yield </span><span class="s1">pixels[start:stop]</span>

    <span class="s4">def </span><span class="s1">array_scanlines_interlace(self</span><span class="s4">, </span><span class="s1">pixels):</span>
        <span class="s2">&quot;&quot;&quot; 
        Generator for interlaced scanlines from an array. 
        `pixels` is the full source image as a single array of values. 
        The generator yields each scanline of the reduced passes in turn, 
        each scanline being a sequence of values. 
        &quot;&quot;&quot;</span>

        <span class="s0"># http://www.w3.org/TR/PNG/#8InterlaceMethods</span>
        <span class="s0"># Array type.</span>
        <span class="s1">fmt = </span><span class="s3">&quot;BH&quot;</span><span class="s1">[self.bitdepth &gt; </span><span class="s5">8</span><span class="s1">]</span>
        <span class="s0"># Value per row</span>
        <span class="s1">vpr = self.width * self.planes</span>

        <span class="s0"># Each iteration generates a scanline starting at (x, y)</span>
        <span class="s0"># and consisting of every xstep pixels.</span>
        <span class="s4">for </span><span class="s1">lines </span><span class="s4">in </span><span class="s1">adam7_generate(self.width</span><span class="s4">, </span><span class="s1">self.height):</span>
            <span class="s4">for </span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">xstep </span><span class="s4">in </span><span class="s1">lines:</span>
                <span class="s0"># Pixels per row (of reduced image)</span>
                <span class="s1">ppr = int(math.ceil((self.width - x) / float(xstep)))</span>
                <span class="s0"># Values per row (of reduced image)</span>
                <span class="s1">reduced_row_len = ppr * self.planes</span>
                <span class="s4">if </span><span class="s1">xstep == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s0"># Easy case: line is a simple slice.</span>
                    <span class="s1">offset = y * vpr</span>
                    <span class="s4">yield </span><span class="s1">pixels[offset : offset + vpr]</span>
                    <span class="s4">continue</span>
                <span class="s0"># We have to step by xstep,</span>
                <span class="s0"># which we can do one plane at a time</span>
                <span class="s0"># using the step in Python slices.</span>
                <span class="s1">row = array(fmt)</span>
                <span class="s0"># There's no easier way to set the length of an array</span>
                <span class="s1">row.extend(pixels[</span><span class="s5">0</span><span class="s1">:reduced_row_len])</span>
                <span class="s1">offset = y * vpr + x * self.planes</span>
                <span class="s1">end_offset = (y + </span><span class="s5">1</span><span class="s1">) * vpr</span>
                <span class="s1">skip = self.planes * xstep</span>
                <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(self.planes):</span>
                    <span class="s1">row[i :: self.planes] = pixels[offset + i : end_offset : skip]</span>
                <span class="s4">yield </span><span class="s1">row</span>


<span class="s4">def </span><span class="s1">write_chunk(outfile</span><span class="s4">, </span><span class="s1">tag</span><span class="s4">, </span><span class="s1">data=</span><span class="s6">b&quot;&quot;</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Write a PNG chunk to the output file, including length and 
    checksum. 
    &quot;&quot;&quot;</span>

    <span class="s1">data = bytes(data)</span>
    <span class="s0"># http://www.w3.org/TR/PNG/#5Chunk-layout</span>
    <span class="s1">outfile.write(struct.pack(</span><span class="s3">&quot;!I&quot;</span><span class="s4">, </span><span class="s1">len(data)))</span>
    <span class="s1">outfile.write(tag)</span>
    <span class="s1">outfile.write(data)</span>
    <span class="s1">checksum = zlib.crc32(tag)</span>
    <span class="s1">checksum = zlib.crc32(data</span><span class="s4">, </span><span class="s1">checksum)</span>
    <span class="s1">checksum &amp;= </span><span class="s5">2 </span><span class="s1">** </span><span class="s5">32 </span><span class="s1">- </span><span class="s5">1</span>
    <span class="s1">outfile.write(struct.pack(</span><span class="s3">&quot;!I&quot;</span><span class="s4">, </span><span class="s1">checksum))</span>


<span class="s4">def </span><span class="s1">write_chunks(out</span><span class="s4">, </span><span class="s1">chunks):</span>
    <span class="s2">&quot;&quot;&quot;Create a PNG file by writing out the chunks.&quot;&quot;&quot;</span>

    <span class="s1">out.write(signature)</span>
    <span class="s4">for </span><span class="s1">chunk </span><span class="s4">in </span><span class="s1">chunks:</span>
        <span class="s1">write_chunk(out</span><span class="s4">, </span><span class="s1">*chunk)</span>


<span class="s4">def </span><span class="s1">rescale_rows(rows</span><span class="s4">, </span><span class="s1">rescale):</span>
    <span class="s2">&quot;&quot;&quot; 
    Take each row in rows (an iterator) and yield 
    a fresh row with the pixels scaled according to 
    the rescale parameters in the list `rescale`. 
    Each element of `rescale` is a tuple of 
    (source_bitdepth, target_bitdepth), 
    with one element per channel. 
    &quot;&quot;&quot;</span>

    <span class="s0"># One factor for each channel</span>
    <span class="s1">fs = [float(</span><span class="s5">2 </span><span class="s1">** s[</span><span class="s5">1</span><span class="s1">] - </span><span class="s5">1</span><span class="s1">) / float(</span><span class="s5">2 </span><span class="s1">** s[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1</span><span class="s1">) </span><span class="s4">for </span><span class="s1">s </span><span class="s4">in </span><span class="s1">rescale]</span>

    <span class="s0"># Assume all target_bitdepths are the same</span>
    <span class="s1">target_bitdepths = set(s[</span><span class="s5">1</span><span class="s1">] </span><span class="s4">for </span><span class="s1">s </span><span class="s4">in </span><span class="s1">rescale)</span>
    <span class="s4">assert </span><span class="s1">len(target_bitdepths) == </span><span class="s5">1</span>
    <span class="s1">(target_bitdepth</span><span class="s4">,</span><span class="s1">) = target_bitdepths</span>
    <span class="s1">typecode = </span><span class="s3">&quot;BH&quot;</span><span class="s1">[target_bitdepth &gt; </span><span class="s5">8</span><span class="s1">]</span>

    <span class="s0"># Number of channels</span>
    <span class="s1">n_chans = len(rescale)</span>

    <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">rows:</span>
        <span class="s1">rescaled_row = array(typecode</span><span class="s4">, </span><span class="s1">iter(row))</span>
        <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(n_chans):</span>
            <span class="s1">channel = array(typecode</span><span class="s4">, </span><span class="s1">(int(round(fs[i] * x)) </span><span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">row[i::n_chans]))</span>
            <span class="s1">rescaled_row[i::n_chans] = channel</span>
        <span class="s4">yield </span><span class="s1">rescaled_row</span>


<span class="s4">def </span><span class="s1">pack_rows(rows</span><span class="s4">, </span><span class="s1">bitdepth):</span>
    <span class="s2">&quot;&quot;&quot;Yield packed rows that are a byte array. 
    Each byte is packed with the values from several pixels. 
    &quot;&quot;&quot;</span>

    <span class="s4">assert </span><span class="s1">bitdepth &lt; </span><span class="s5">8</span>
    <span class="s4">assert </span><span class="s5">8 </span><span class="s1">% bitdepth == </span><span class="s5">0</span>

    <span class="s0"># samples per byte</span>
    <span class="s1">spb = int(</span><span class="s5">8 </span><span class="s1">/ bitdepth)</span>

    <span class="s4">def </span><span class="s1">make_byte(block):</span>
        <span class="s2">&quot;&quot;&quot;Take a block of (2, 4, or 8) values, 
        and pack them into a single byte. 
        &quot;&quot;&quot;</span>

        <span class="s1">res = </span><span class="s5">0</span>
        <span class="s4">for </span><span class="s1">v </span><span class="s4">in </span><span class="s1">block:</span>
            <span class="s1">res = (res &lt;&lt; bitdepth) + v</span>
        <span class="s4">return </span><span class="s1">res</span>

    <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">rows:</span>
        <span class="s1">a = bytearray(row)</span>
        <span class="s0"># Adding padding bytes so we can group into a whole</span>
        <span class="s0"># number of spb-tuples.</span>
        <span class="s1">n = float(len(a))</span>
        <span class="s1">extra = math.ceil(n / spb) * spb - n</span>
        <span class="s1">a.extend([</span><span class="s5">0</span><span class="s1">] * int(extra))</span>
        <span class="s0"># Pack into bytes.</span>
        <span class="s0"># Each block is the samples for one byte.</span>
        <span class="s1">blocks = group(a</span><span class="s4">, </span><span class="s1">spb)</span>
        <span class="s4">yield </span><span class="s1">bytearray(make_byte(block) </span><span class="s4">for </span><span class="s1">block </span><span class="s4">in </span><span class="s1">blocks)</span>


<span class="s4">def </span><span class="s1">unpack_rows(rows):</span>
    <span class="s2">&quot;&quot;&quot;Unpack each row from being 16-bits per value, 
    to being a sequence of bytes. 
    &quot;&quot;&quot;</span>
    <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">rows:</span>
        <span class="s1">fmt = </span><span class="s3">&quot;!%dH&quot; </span><span class="s1">% len(row)</span>
        <span class="s4">yield </span><span class="s1">bytearray(struct.pack(fmt</span><span class="s4">, </span><span class="s1">*row))</span>


<span class="s4">def </span><span class="s1">make_palette_chunks(palette):</span>
    <span class="s2">&quot;&quot;&quot; 
    Create the byte sequences for a ``PLTE`` and 
    if necessary a ``tRNS`` chunk. 
    Returned as a pair (*p*, *t*). 
    *t* will be ``None`` if no ``tRNS`` chunk is necessary. 
    &quot;&quot;&quot;</span>

    <span class="s1">p = bytearray()</span>
    <span class="s1">t = bytearray()</span>

    <span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">palette:</span>
        <span class="s1">p.extend(x[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">3</span><span class="s1">])</span>
        <span class="s4">if </span><span class="s1">len(x) &gt; </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s1">t.append(x[</span><span class="s5">3</span><span class="s1">])</span>
    <span class="s4">if </span><span class="s1">t:</span>
        <span class="s4">return </span><span class="s1">p</span><span class="s4">, </span><span class="s1">t</span>
    <span class="s4">return </span><span class="s1">p</span><span class="s4">, None</span>


<span class="s4">def </span><span class="s1">check_bitdepth_rescale(palette</span><span class="s4">, </span><span class="s1">bitdepth</span><span class="s4">, </span><span class="s1">transparent</span><span class="s4">, </span><span class="s1">alpha</span><span class="s4">, </span><span class="s1">greyscale):</span>
    <span class="s2">&quot;&quot;&quot; 
    Returns (bitdepth, rescale) pair. 
    &quot;&quot;&quot;</span>

    <span class="s4">if </span><span class="s1">palette:</span>
        <span class="s4">if </span><span class="s1">len(bitdepth) != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;with palette, only a single bitdepth may be used&quot;</span><span class="s1">)</span>
        <span class="s1">(bitdepth</span><span class="s4">,</span><span class="s1">) = bitdepth</span>
        <span class="s4">if </span><span class="s1">bitdepth </span><span class="s4">not in </span><span class="s1">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s5">8</span><span class="s1">):</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;with palette, bitdepth must be 1, 2, 4, or 8&quot;</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">transparent </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;transparent and palette not compatible&quot;</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">alpha:</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;alpha and palette not compatible&quot;</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">greyscale:</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;greyscale and palette not compatible&quot;</span><span class="s1">)</span>
        <span class="s4">return </span><span class="s1">bitdepth</span><span class="s4">, None</span>

    <span class="s0"># No palette, check for sBIT chunk generation.</span>

    <span class="s4">if </span><span class="s1">greyscale </span><span class="s4">and not </span><span class="s1">alpha:</span>
        <span class="s0"># Single channel, L.</span>
        <span class="s1">(bitdepth</span><span class="s4">,</span><span class="s1">) = bitdepth</span>
        <span class="s4">if </span><span class="s1">bitdepth </span><span class="s4">in </span><span class="s1">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s5">8</span><span class="s4">, </span><span class="s5">16</span><span class="s1">):</span>
            <span class="s4">return </span><span class="s1">bitdepth</span><span class="s4">, None</span>
        <span class="s4">if </span><span class="s1">bitdepth &gt; </span><span class="s5">8</span><span class="s1">:</span>
            <span class="s1">targetbitdepth = </span><span class="s5">16</span>
        <span class="s4">elif </span><span class="s1">bitdepth == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s1">targetbitdepth = </span><span class="s5">4</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">assert </span><span class="s1">bitdepth </span><span class="s4">in </span><span class="s1">(</span><span class="s5">5</span><span class="s4">, </span><span class="s5">6</span><span class="s4">, </span><span class="s5">7</span><span class="s1">)</span>
            <span class="s1">targetbitdepth = </span><span class="s5">8</span>
        <span class="s4">return </span><span class="s1">targetbitdepth</span><span class="s4">, </span><span class="s1">[(bitdepth</span><span class="s4">, </span><span class="s1">targetbitdepth)]</span>

    <span class="s4">assert </span><span class="s1">alpha </span><span class="s4">or not </span><span class="s1">greyscale</span>

    <span class="s1">depth_set = tuple(set(bitdepth))</span>
    <span class="s4">if </span><span class="s1">depth_set </span><span class="s4">in </span><span class="s1">[(</span><span class="s5">8</span><span class="s4">,</span><span class="s1">)</span><span class="s4">, </span><span class="s1">(</span><span class="s5">16</span><span class="s4">,</span><span class="s1">)]:</span>
        <span class="s0"># No sBIT required.</span>
        <span class="s1">(bitdepth</span><span class="s4">,</span><span class="s1">) = depth_set</span>
        <span class="s4">return </span><span class="s1">bitdepth</span><span class="s4">, None</span>

    <span class="s1">targetbitdepth = (</span><span class="s5">8</span><span class="s4">, </span><span class="s5">16</span><span class="s1">)[max(bitdepth) &gt; </span><span class="s5">8</span><span class="s1">]</span>
    <span class="s4">return </span><span class="s1">targetbitdepth</span><span class="s4">, </span><span class="s1">[(b</span><span class="s4">, </span><span class="s1">targetbitdepth) </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">bitdepth]</span>


<span class="s0"># Regex for decoding mode string</span>
<span class="s1">RegexModeDecode = re.compile(</span><span class="s3">&quot;(LA?|RGBA?);?([0-9]*)&quot;</span><span class="s4">, </span><span class="s1">flags=re.IGNORECASE)</span>


<span class="s4">def </span><span class="s1">from_array(a</span><span class="s4">, </span><span class="s1">mode=</span><span class="s4">None, </span><span class="s1">info={}):</span>
    <span class="s2">&quot;&quot;&quot; 
    Create a PNG :class:`Image` object from a 2-dimensional array. 
    One application of this function is easy PIL-style saving: 
    ``png.from_array(pixels, 'L').save('foo.png')``. 
 
    Unless they are specified using the *info* parameter, 
    the PNG's height and width are taken from the array size. 
    The first axis is the height; the second axis is the 
    ravelled width and channel index. 
    The array is treated is a sequence of rows, 
    each row being a sequence of values (``width*channels`` in number). 
    So an RGB image that is 16 pixels high and 8 wide will 
    occupy a 2-dimensional array that is 16x24 
    (each row will be 8*3 = 24 sample values). 
 
    *mode* is a string that specifies the image colour format in a 
    PIL-style mode.  It can be: 
 
    ``'L'`` 
      greyscale (1 channel) 
    ``'LA'`` 
      greyscale with alpha (2 channel) 
    ``'RGB'`` 
      colour image (3 channel) 
    ``'RGBA'`` 
      colour image with alpha (4 channel) 
 
    The mode string can also specify the bit depth 
    (overriding how this function normally derives the bit depth, 
    see below). 
    Appending ``';16'`` to the mode will cause the PNG to be 
    16 bits per channel; 
    any decimal from 1 to 16 can be used to specify the bit depth. 
 
    When a 2-dimensional array is used *mode* determines how many 
    channels the image has, and so allows the width to be derived from 
    the second array dimension. 
 
    The array is expected to be a ``numpy`` array, 
    but it can be any suitable Python sequence. 
    For example, a list of lists can be used: 
    ``png.from_array([[0, 255, 0], [255, 0, 255]], 'L')``. 
    The exact rules are: ``len(a)`` gives the first dimension, height; 
    ``len(a[0])`` gives the second dimension. 
    It's slightly more complicated than that because 
    an iterator of rows can be used, and it all still works. 
    Using an iterator allows data to be streamed efficiently. 
 
    The bit depth of the PNG is normally taken from 
    the array element's datatype 
    (but if *mode* specifies a bitdepth then that is used instead). 
    The array element's datatype is determined in a way which 
    is supposed to work both for ``numpy`` arrays and for Python 
    ``array.array`` objects. 
    A 1 byte datatype will give a bit depth of 8, 
    a 2 byte datatype will give a bit depth of 16. 
    If the datatype does not have an implicit size, 
    like the above example where it is a plain Python list of lists, 
    then a default of 8 is used. 
 
    The *info* parameter is a dictionary that can 
    be used to specify metadata (in the same style as 
    the arguments to the :class:`png.Writer` class). 
    For this function the keys that are useful are: 
 
    height 
      overrides the height derived from the array dimensions and 
      allows *a* to be an iterable. 
    width 
      overrides the width derived from the array dimensions. 
    bitdepth 
      overrides the bit depth derived from the element datatype 
      (but must match *mode* if that also specifies a bit depth). 
 
    Generally anything specified in the *info* dictionary will 
    override any implicit choices that this function would otherwise make, 
    but must match any explicit ones. 
    For example, if the *info* dictionary has a ``greyscale`` key then 
    this must be true when mode is ``'L'`` or ``'LA'`` and 
    false when mode is ``'RGB'`` or ``'RGBA'``. 
    &quot;&quot;&quot;</span>

    <span class="s0"># We abuse the *info* parameter by modifying it.  Take a copy here.</span>
    <span class="s0"># (Also typechecks *info* to some extent).</span>
    <span class="s1">info = dict(info)</span>

    <span class="s0"># Syntax check mode string.</span>
    <span class="s1">match = RegexModeDecode.match(mode)</span>
    <span class="s4">if not </span><span class="s1">match:</span>
        <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">&quot;mode string should be 'RGB' or 'L;16' or similar.&quot;</span><span class="s1">)</span>

    <span class="s1">mode</span><span class="s4">, </span><span class="s1">bitdepth = match.groups()</span>
    <span class="s4">if </span><span class="s1">bitdepth:</span>
        <span class="s1">bitdepth = int(bitdepth)</span>

    <span class="s0"># Colour format.</span>
    <span class="s4">if </span><span class="s3">&quot;greyscale&quot; </span><span class="s4">in </span><span class="s1">info:</span>
        <span class="s4">if </span><span class="s1">bool(info[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">]) != (</span><span class="s3">&quot;L&quot; </span><span class="s4">in </span><span class="s1">mode):</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;info['greyscale'] should match mode.&quot;</span><span class="s1">)</span>
    <span class="s1">info[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">] = </span><span class="s3">&quot;L&quot; </span><span class="s4">in </span><span class="s1">mode</span>

    <span class="s1">alpha = </span><span class="s3">&quot;A&quot; </span><span class="s4">in </span><span class="s1">mode</span>
    <span class="s4">if </span><span class="s3">&quot;alpha&quot; </span><span class="s4">in </span><span class="s1">info:</span>
        <span class="s4">if </span><span class="s1">bool(info[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">]) != alpha:</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;info['alpha'] should match mode.&quot;</span><span class="s1">)</span>
    <span class="s1">info[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">] = alpha</span>

    <span class="s0"># Get bitdepth from *mode* if possible.</span>
    <span class="s4">if </span><span class="s1">bitdepth:</span>
        <span class="s4">if </span><span class="s1">info.get(</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">) </span><span class="s4">and </span><span class="s1">bitdepth != info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">]:</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span>
                <span class="s3">&quot;bitdepth (%d) should match bitdepth of info (%d).&quot;</span>
                <span class="s1">% (bitdepth</span><span class="s4">, </span><span class="s1">info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">])</span>
            <span class="s1">)</span>
        <span class="s1">info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] = bitdepth</span>

    <span class="s0"># Fill in and/or check entries in *info*.</span>
    <span class="s0"># Dimensions.</span>
    <span class="s1">width</span><span class="s4">, </span><span class="s1">height = check_sizes(info.get(</span><span class="s3">&quot;size&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">info.get(</span><span class="s3">&quot;width&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">info.get(</span><span class="s3">&quot;height&quot;</span><span class="s1">))</span>
    <span class="s4">if </span><span class="s1">width:</span>
        <span class="s1">info[</span><span class="s3">&quot;width&quot;</span><span class="s1">] = width</span>
    <span class="s4">if </span><span class="s1">height:</span>
        <span class="s1">info[</span><span class="s3">&quot;height&quot;</span><span class="s1">] = height</span>

    <span class="s4">if </span><span class="s3">&quot;height&quot; </span><span class="s4">not in </span><span class="s1">info:</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">info[</span><span class="s3">&quot;height&quot;</span><span class="s1">] = len(a)</span>
        <span class="s4">except </span><span class="s1">TypeError:</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;len(a) does not work, supply info['height'] instead.&quot;</span><span class="s1">)</span>

    <span class="s1">planes = len(mode)</span>
    <span class="s4">if </span><span class="s3">&quot;planes&quot; </span><span class="s4">in </span><span class="s1">info:</span>
        <span class="s4">if </span><span class="s1">info[</span><span class="s3">&quot;planes&quot;</span><span class="s1">] != planes:</span>
            <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">&quot;info['planes'] should match mode.&quot;</span><span class="s1">)</span>

    <span class="s0"># In order to work out whether we the array is 2D or 3D we need its</span>
    <span class="s0"># first row, which requires that we take a copy of its iterator.</span>
    <span class="s0"># We may also need the first row to derive width and bitdepth.</span>
    <span class="s1">a</span><span class="s4">, </span><span class="s1">t = itertools.tee(a)</span>
    <span class="s1">row = next(t)</span>
    <span class="s4">del </span><span class="s1">t</span>

    <span class="s1">testelement = row</span>
    <span class="s4">if </span><span class="s3">&quot;width&quot; </span><span class="s4">not in </span><span class="s1">info:</span>
        <span class="s1">width = len(row) // planes</span>
        <span class="s1">info[</span><span class="s3">&quot;width&quot;</span><span class="s1">] = width</span>

    <span class="s4">if </span><span class="s3">&quot;bitdepth&quot; </span><span class="s4">not in </span><span class="s1">info:</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">dtype = testelement.dtype</span>
            <span class="s0"># goto the &quot;else:&quot; clause.  Sorry.</span>
        <span class="s4">except </span><span class="s1">AttributeError:</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s0"># Try a Python array.array.</span>
                <span class="s1">bitdepth = </span><span class="s5">8 </span><span class="s1">* testelement.itemsize</span>
            <span class="s4">except </span><span class="s1">AttributeError:</span>
                <span class="s0"># We can't determine it from the array element's datatype,</span>
                <span class="s0"># use a default of 8.</span>
                <span class="s1">bitdepth = </span><span class="s5">8</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s0"># If we got here without exception,</span>
            <span class="s0"># we now assume that the array is a numpy array.</span>
            <span class="s4">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
                <span class="s1">bitdepth = </span><span class="s5">1</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">bitdepth = </span><span class="s5">8 </span><span class="s1">* dtype.itemsize</span>
        <span class="s1">info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] = bitdepth</span>

    <span class="s4">for </span><span class="s1">thing </span><span class="s4">in </span><span class="s1">[</span><span class="s3">&quot;width&quot;</span><span class="s4">, </span><span class="s3">&quot;height&quot;</span><span class="s4">, </span><span class="s3">&quot;bitdepth&quot;</span><span class="s4">, </span><span class="s3">&quot;greyscale&quot;</span><span class="s4">, </span><span class="s3">&quot;alpha&quot;</span><span class="s1">]:</span>
        <span class="s4">assert </span><span class="s1">thing </span><span class="s4">in </span><span class="s1">info</span>

    <span class="s4">return </span><span class="s1">Image(a</span><span class="s4">, </span><span class="s1">info)</span>


<span class="s0"># So that refugee's from PIL feel more at home.  Not documented.</span>
<span class="s1">fromarray = from_array</span>


<span class="s4">class </span><span class="s1">Image:</span>
    <span class="s2">&quot;&quot;&quot;A PNG image.  You can create an :class:`Image` object from 
    an array of pixels by calling :meth:`png.from_array`.  It can be 
    saved to disk with the :meth:`save` method. 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">rows</span><span class="s4">, </span><span class="s1">info):</span>
        <span class="s2">&quot;&quot;&quot; 
        .. note :: 
 
          The constructor is not public.  Please do not call it. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.rows = rows</span>
        <span class="s1">self.info = info</span>

    <span class="s4">def </span><span class="s1">save(self</span><span class="s4">, </span><span class="s1">file):</span>
        <span class="s2">&quot;&quot;&quot;Save the image to the named *file*. 
 
        See `.write()` if you already have an open file object. 
 
        In general, you can only call this method once; 
        after it has been called the first time the PNG image is written, 
        the source data will have been streamed, and 
        cannot be streamed again. 
        &quot;&quot;&quot;</span>

        <span class="s1">w = Writer(**self.info)</span>

        <span class="s4">with </span><span class="s1">open(file</span><span class="s4">, </span><span class="s3">&quot;wb&quot;</span><span class="s1">) </span><span class="s4">as </span><span class="s1">fd:</span>
            <span class="s1">w.write(fd</span><span class="s4">, </span><span class="s1">self.rows)</span>

    <span class="s4">def </span><span class="s1">write(self</span><span class="s4">, </span><span class="s1">file):</span>
        <span class="s2">&quot;&quot;&quot;Write the image to the open file object. 
 
        See `.save()` if you have a filename. 
 
        In general, you can only call this method once; 
        after it has been called the first time the PNG image is written, 
        the source data will have been streamed, and 
        cannot be streamed again. 
        &quot;&quot;&quot;</span>

        <span class="s1">w = Writer(**self.info)</span>
        <span class="s1">w.write(file</span><span class="s4">, </span><span class="s1">self.rows)</span>


<span class="s4">class </span><span class="s1">Reader:</span>
    <span class="s2">&quot;&quot;&quot; 
    Pure Python PNG decoder in pure Python. 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">_guess=</span><span class="s4">None, </span><span class="s1">filename=</span><span class="s4">None, </span><span class="s1">file=</span><span class="s4">None, </span><span class="s1">bytes=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        The constructor expects exactly one keyword argument. 
        If you supply a positional argument instead, 
        it will guess the input type. 
        Choose from the following keyword arguments: 
 
        filename 
          Name of input file (a PNG file). 
        file 
          A file-like object (object with a read() method). 
        bytes 
          ``bytes`` or ``bytearray`` with PNG data. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">keywords_supplied = (</span>
            <span class="s1">(_guess </span><span class="s4">is not None</span><span class="s1">)</span>
            <span class="s1">+ (filename </span><span class="s4">is not None</span><span class="s1">)</span>
            <span class="s1">+ (file </span><span class="s4">is not None</span><span class="s1">)</span>
            <span class="s1">+ (bytes </span><span class="s4">is not None</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s4">if </span><span class="s1">keywords_supplied != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Reader() takes exactly 1 argument&quot;</span><span class="s1">)</span>

        <span class="s0"># Will be the first 8 bytes, later on.  See validate_signature.</span>
        <span class="s1">self.signature = </span><span class="s4">None</span>
        <span class="s1">self.transparent = </span><span class="s4">None</span>
        <span class="s0"># A pair of (len,type) if a chunk has been read but its data and</span>
        <span class="s0"># checksum have not (in other words the file position is just</span>
        <span class="s0"># past the 4 bytes that specify the chunk type).</span>
        <span class="s0"># See preamble method for how this is used.</span>
        <span class="s1">self.atchunk = </span><span class="s4">None</span>

        <span class="s4">if </span><span class="s1">_guess </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">isarray(_guess):</span>
                <span class="s1">bytes = _guess</span>
            <span class="s4">elif </span><span class="s1">isinstance(_guess</span><span class="s4">, </span><span class="s1">str):</span>
                <span class="s1">filename = _guess</span>
            <span class="s4">elif </span><span class="s1">hasattr(_guess</span><span class="s4">, </span><span class="s3">&quot;read&quot;</span><span class="s1">):</span>
                <span class="s1">file = _guess</span>

        <span class="s4">if </span><span class="s1">bytes </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">self.file = io.BytesIO(bytes)</span>
        <span class="s4">elif </span><span class="s1">filename </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">self.file = open(filename</span><span class="s4">, </span><span class="s3">&quot;rb&quot;</span><span class="s1">)</span>
        <span class="s4">elif </span><span class="s1">file </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">self.file = file</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;expecting filename, file or bytes array&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">chunk(self</span><span class="s4">, </span><span class="s1">lenient=</span><span class="s4">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Read the next PNG chunk from the input file; 
        returns a (*type*, *data*) tuple. 
        *type* is the chunk's type as a byte string 
        (all PNG chunk types are 4 bytes long). 
        *data* is the chunk's data content, as a byte string. 
 
        If the optional `lenient` argument evaluates to `True`, 
        checksum failures will raise warnings rather than exceptions. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.validate_signature()</span>

        <span class="s0"># http://www.w3.org/TR/PNG/#5Chunk-layout</span>
        <span class="s4">if not </span><span class="s1">self.atchunk:</span>
            <span class="s1">self.atchunk = self._chunk_len_type()</span>
        <span class="s4">if not </span><span class="s1">self.atchunk:</span>
            <span class="s4">raise </span><span class="s1">ChunkError(</span><span class="s3">&quot;No more chunks.&quot;</span><span class="s1">)</span>
        <span class="s1">length</span><span class="s4">, </span><span class="s1">type = self.atchunk</span>
        <span class="s1">self.atchunk = </span><span class="s4">None</span>

        <span class="s1">data = self.file.read(length)</span>
        <span class="s4">if </span><span class="s1">len(data) != length:</span>
            <span class="s4">raise </span><span class="s1">ChunkError(</span>
                <span class="s3">&quot;Chunk %s too short for required %i octets.&quot; </span><span class="s1">% (type</span><span class="s4">, </span><span class="s1">length)</span>
            <span class="s1">)</span>
        <span class="s1">checksum = self.file.read(</span><span class="s5">4</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">len(checksum) != </span><span class="s5">4</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ChunkError(</span><span class="s3">&quot;Chunk %s too short for checksum.&quot; </span><span class="s1">% type)</span>
        <span class="s1">verify = zlib.crc32(type)</span>
        <span class="s1">verify = zlib.crc32(data</span><span class="s4">, </span><span class="s1">verify)</span>
        <span class="s1">verify = struct.pack(</span><span class="s3">&quot;!I&quot;</span><span class="s4">, </span><span class="s1">verify)</span>
        <span class="s4">if </span><span class="s1">checksum != verify:</span>
            <span class="s1">(a</span><span class="s4">,</span><span class="s1">) = struct.unpack(</span><span class="s3">&quot;!I&quot;</span><span class="s4">, </span><span class="s1">checksum)</span>
            <span class="s1">(b</span><span class="s4">,</span><span class="s1">) = struct.unpack(</span><span class="s3">&quot;!I&quot;</span><span class="s4">, </span><span class="s1">verify)</span>
            <span class="s1">message = </span><span class="s3">&quot;Checksum error in %s chunk: 0x%08X != 0x%08X.&quot; </span><span class="s1">% (</span>
                <span class="s1">type.decode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span><span class="s4">,</span>
                <span class="s1">a</span><span class="s4">,</span>
                <span class="s1">b</span><span class="s4">,</span>
            <span class="s1">)</span>
            <span class="s4">if </span><span class="s1">lenient:</span>
                <span class="s1">warnings.warn(message</span><span class="s4">, </span><span class="s1">RuntimeWarning)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">ChunkError(message)</span>
        <span class="s4">return </span><span class="s1">type</span><span class="s4">, </span><span class="s1">data</span>

    <span class="s4">def </span><span class="s1">chunks(self):</span>
        <span class="s2">&quot;&quot;&quot;Return an iterator that will yield each chunk as a 
        (*chunktype*, *content*) pair. 
        &quot;&quot;&quot;</span>

        <span class="s4">while True</span><span class="s1">:</span>
            <span class="s1">t</span><span class="s4">, </span><span class="s1">v = self.chunk()</span>
            <span class="s4">yield </span><span class="s1">t</span><span class="s4">, </span><span class="s1">v</span>
            <span class="s4">if </span><span class="s1">t == </span><span class="s6">b&quot;IEND&quot;</span><span class="s1">:</span>
                <span class="s4">break</span>

    <span class="s4">def </span><span class="s1">undo_filter(self</span><span class="s4">, </span><span class="s1">filter_type</span><span class="s4">, </span><span class="s1">scanline</span><span class="s4">, </span><span class="s1">previous):</span>
        <span class="s2">&quot;&quot;&quot; 
        Undo the filter for a scanline. 
        `scanline` is a sequence of bytes that 
        does not include the initial filter type byte. 
        `previous` is decoded previous scanline 
        (for straightlaced images this is the previous pixel row, 
        but for interlaced images, it is 
        the previous scanline in the reduced image, 
        which in general is not the previous pixel row in the final image). 
        When there is no previous scanline 
        (the first row of a straightlaced image, 
        or the first row in one of the passes in an interlaced image), 
        then this argument should be ``None``. 
 
        The scanline will have the effects of filtering removed; 
        the result will be returned as a fresh sequence of bytes. 
        &quot;&quot;&quot;</span>

        <span class="s0"># :todo: Would it be better to update scanline in place?</span>
        <span class="s1">result = scanline</span>

        <span class="s4">if </span><span class="s1">filter_type == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">result</span>

        <span class="s4">if </span><span class="s1">filter_type </span><span class="s4">not in </span><span class="s1">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s5">4</span><span class="s1">):</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span>
                <span class="s3">&quot;Invalid PNG Filter Type.  &quot;</span>
                <span class="s3">&quot;See http://www.w3.org/TR/2003/REC-PNG-20031110/#9Filters .&quot;</span>
            <span class="s1">)</span>

        <span class="s0"># Filter unit.  The stride from one pixel to the corresponding</span>
        <span class="s0"># byte from the previous pixel.  Normally this is the pixel</span>
        <span class="s0"># size in bytes, but when this is smaller than 1, the previous</span>
        <span class="s0"># byte is used instead.</span>
        <span class="s1">fu = max(</span><span class="s5">1</span><span class="s4">, </span><span class="s1">self.psize)</span>

        <span class="s0"># For the first line of a pass, synthesize a dummy previous</span>
        <span class="s0"># line.  An alternative approach would be to observe that on the</span>
        <span class="s0"># first line 'up' is the same as 'null', 'paeth' is the same</span>
        <span class="s0"># as 'sub', with only 'average' requiring any special case.</span>
        <span class="s4">if not </span><span class="s1">previous:</span>
            <span class="s1">previous = bytearray([</span><span class="s5">0</span><span class="s1">] * len(scanline))</span>

        <span class="s0"># Call appropriate filter algorithm.  Note that 0 has already</span>
        <span class="s0"># been dealt with.</span>
        <span class="s1">fn = (</span>
            <span class="s4">None,</span>
            <span class="s1">undo_filter_sub</span><span class="s4">,</span>
            <span class="s1">undo_filter_up</span><span class="s4">,</span>
            <span class="s1">undo_filter_average</span><span class="s4">,</span>
            <span class="s1">undo_filter_paeth</span><span class="s4">,</span>
        <span class="s1">)[filter_type]</span>
        <span class="s1">fn(fu</span><span class="s4">, </span><span class="s1">scanline</span><span class="s4">, </span><span class="s1">previous</span><span class="s4">, </span><span class="s1">result)</span>
        <span class="s4">return </span><span class="s1">result</span>

    <span class="s4">def </span><span class="s1">_deinterlace(self</span><span class="s4">, </span><span class="s1">raw):</span>
        <span class="s2">&quot;&quot;&quot; 
        Read raw pixel data, undo filters, deinterlace, and flatten. 
        Return a single array of values. 
        &quot;&quot;&quot;</span>

        <span class="s0"># Values per row (of the target image)</span>
        <span class="s1">vpr = self.width * self.planes</span>

        <span class="s0"># Values per image</span>
        <span class="s1">vpi = vpr * self.height</span>
        <span class="s0"># Interleaving writes to the output array randomly</span>
        <span class="s0"># (well, not quite), so the entire output array must be in memory.</span>
        <span class="s0"># Make a result array, and make it big enough.</span>
        <span class="s4">if </span><span class="s1">self.bitdepth &gt; </span><span class="s5">8</span><span class="s1">:</span>
            <span class="s1">a = array(</span><span class="s3">&quot;H&quot;</span><span class="s4">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">] * vpi)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">a = bytearray([</span><span class="s5">0</span><span class="s1">] * vpi)</span>
        <span class="s1">source_offset = </span><span class="s5">0</span>

        <span class="s4">for </span><span class="s1">lines </span><span class="s4">in </span><span class="s1">adam7_generate(self.width</span><span class="s4">, </span><span class="s1">self.height):</span>
            <span class="s0"># The previous (reconstructed) scanline.</span>
            <span class="s0"># `None` at the beginning of a pass</span>
            <span class="s0"># to indicate that there is no previous line.</span>
            <span class="s1">recon = </span><span class="s4">None</span>
            <span class="s4">for </span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">xstep </span><span class="s4">in </span><span class="s1">lines:</span>
                <span class="s0"># Pixels per row (reduced pass image)</span>
                <span class="s1">ppr = int(math.ceil((self.width - x) / float(xstep)))</span>
                <span class="s0"># Row size in bytes for this pass.</span>
                <span class="s1">row_size = int(math.ceil(self.psize * ppr))</span>

                <span class="s1">filter_type = raw[source_offset]</span>
                <span class="s1">source_offset += </span><span class="s5">1</span>
                <span class="s1">scanline = raw[source_offset : source_offset + row_size]</span>
                <span class="s1">source_offset += row_size</span>
                <span class="s1">recon = self.undo_filter(filter_type</span><span class="s4">, </span><span class="s1">scanline</span><span class="s4">, </span><span class="s1">recon)</span>
                <span class="s0"># Convert so that there is one element per pixel value</span>
                <span class="s1">flat = self._bytes_to_values(recon</span><span class="s4">, </span><span class="s1">width=ppr)</span>
                <span class="s4">if </span><span class="s1">xstep == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s4">assert </span><span class="s1">x == </span><span class="s5">0</span>
                    <span class="s1">offset = y * vpr</span>
                    <span class="s1">a[offset : offset + vpr] = flat</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">offset = y * vpr + x * self.planes</span>
                    <span class="s1">end_offset = (y + </span><span class="s5">1</span><span class="s1">) * vpr</span>
                    <span class="s1">skip = self.planes * xstep</span>
                    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(self.planes):</span>
                        <span class="s1">a[offset + i : end_offset : skip] = flat[i :: self.planes]</span>

        <span class="s4">return </span><span class="s1">a</span>

    <span class="s4">def </span><span class="s1">_iter_bytes_to_values(self</span><span class="s4">, </span><span class="s1">byte_rows):</span>
        <span class="s2">&quot;&quot;&quot; 
        Iterator that yields each scanline; 
        each scanline being a sequence of values. 
        `byte_rows` should be an iterator that yields 
        the bytes of each row in turn. 
        &quot;&quot;&quot;</span>

        <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">byte_rows:</span>
            <span class="s4">yield </span><span class="s1">self._bytes_to_values(row)</span>

    <span class="s4">def </span><span class="s1">_bytes_to_values(self</span><span class="s4">, </span><span class="s1">bs</span><span class="s4">, </span><span class="s1">width=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Convert a packed row of bytes into a row of values. 
        Result will be a freshly allocated object, 
        not shared with the argument. 
        &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">self.bitdepth == </span><span class="s5">8</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">bytearray(bs)</span>
        <span class="s4">if </span><span class="s1">self.bitdepth == </span><span class="s5">16</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">array(</span><span class="s3">&quot;H&quot;</span><span class="s4">, </span><span class="s1">struct.unpack(</span><span class="s3">&quot;!%dH&quot; </span><span class="s1">% (len(bs) // </span><span class="s5">2</span><span class="s1">)</span><span class="s4">, </span><span class="s1">bs))</span>

        <span class="s4">assert </span><span class="s1">self.bitdepth &lt; </span><span class="s5">8</span>
        <span class="s4">if </span><span class="s1">width </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">width = self.width</span>
        <span class="s0"># Samples per byte</span>
        <span class="s1">spb = </span><span class="s5">8 </span><span class="s1">// self.bitdepth</span>
        <span class="s1">out = bytearray()</span>
        <span class="s1">mask = </span><span class="s5">2 </span><span class="s1">** self.bitdepth - </span><span class="s5">1</span>
        <span class="s1">shifts = [self.bitdepth * i </span><span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">reversed(list(range(spb)))]</span>
        <span class="s4">for </span><span class="s1">o </span><span class="s4">in </span><span class="s1">bs:</span>
            <span class="s1">out.extend([mask &amp; (o &gt;&gt; i) </span><span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">shifts])</span>
        <span class="s4">return </span><span class="s1">out[:width]</span>

    <span class="s4">def </span><span class="s1">_iter_straight_packed(self</span><span class="s4">, </span><span class="s1">byte_blocks):</span>
        <span class="s2">&quot;&quot;&quot;Iterator that undoes the effect of filtering; 
        yields each row as a sequence of packed bytes. 
        Assumes input is straightlaced. 
        `byte_blocks` should be an iterable that yields the raw bytes 
        in blocks of arbitrary size. 
        &quot;&quot;&quot;</span>

        <span class="s0"># length of row, in bytes</span>
        <span class="s1">rb = self.row_bytes</span>
        <span class="s1">a = bytearray()</span>
        <span class="s0"># The previous (reconstructed) scanline.</span>
        <span class="s0"># None indicates first line of image.</span>
        <span class="s1">recon = </span><span class="s4">None</span>
        <span class="s4">for </span><span class="s1">some_bytes </span><span class="s4">in </span><span class="s1">byte_blocks:</span>
            <span class="s1">a.extend(some_bytes)</span>
            <span class="s4">while </span><span class="s1">len(a) &gt;= rb + </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">filter_type = a[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s1">scanline = a[</span><span class="s5">1 </span><span class="s1">: rb + </span><span class="s5">1</span><span class="s1">]</span>
                <span class="s4">del </span><span class="s1">a[: rb + </span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">recon = self.undo_filter(filter_type</span><span class="s4">, </span><span class="s1">scanline</span><span class="s4">, </span><span class="s1">recon)</span>
                <span class="s4">yield </span><span class="s1">recon</span>
        <span class="s4">if </span><span class="s1">len(a) != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0"># :file:format We get here with a file format error:</span>
            <span class="s0"># when the available bytes (after decompressing) do not</span>
            <span class="s0"># pack into exact rows.</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;Wrong size for decompressed IDAT chunk.&quot;</span><span class="s1">)</span>
        <span class="s4">assert </span><span class="s1">len(a) == </span><span class="s5">0</span>

    <span class="s4">def </span><span class="s1">validate_signature(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        If signature (header) has not been read then read and 
        validate it; otherwise do nothing. 
        &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">self.signature:</span>
            <span class="s4">return</span>
        <span class="s1">self.signature = self.file.read(</span><span class="s5">8</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">self.signature != signature:</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;PNG file has invalid signature.&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">preamble(self</span><span class="s4">, </span><span class="s1">lenient=</span><span class="s4">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Extract the image metadata by reading 
        the initial part of the PNG file up to 
        the start of the ``IDAT`` chunk. 
        All the chunks that precede the ``IDAT`` chunk are 
        read and either processed for metadata or discarded. 
 
        If the optional `lenient` argument evaluates to `True`, 
        checksum failures will raise warnings rather than exceptions. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.validate_signature()</span>

        <span class="s4">while True</span><span class="s1">:</span>
            <span class="s4">if not </span><span class="s1">self.atchunk:</span>
                <span class="s1">self.atchunk = self._chunk_len_type()</span>
                <span class="s4">if </span><span class="s1">self.atchunk </span><span class="s4">is None</span><span class="s1">:</span>
                    <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;This PNG file has no IDAT chunks.&quot;</span><span class="s1">)</span>
            <span class="s4">if </span><span class="s1">self.atchunk[</span><span class="s5">1</span><span class="s1">] == </span><span class="s6">b&quot;IDAT&quot;</span><span class="s1">:</span>
                <span class="s4">return</span>
            <span class="s1">self.process_chunk(lenient=lenient)</span>

    <span class="s4">def </span><span class="s1">_chunk_len_type(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Reads just enough of the input to 
        determine the next chunk's length and type; 
        return a (*length*, *type*) pair where *type* is a byte sequence. 
        If there are no more chunks, ``None`` is returned. 
        &quot;&quot;&quot;</span>

        <span class="s1">x = self.file.read(</span><span class="s5">8</span><span class="s1">)</span>
        <span class="s4">if not </span><span class="s1">x:</span>
            <span class="s4">return None</span>
        <span class="s4">if </span><span class="s1">len(x) != </span><span class="s5">8</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;End of file whilst reading chunk length and type.&quot;</span><span class="s1">)</span>
        <span class="s1">length</span><span class="s4">, </span><span class="s1">type = struct.unpack(</span><span class="s3">&quot;!I4s&quot;</span><span class="s4">, </span><span class="s1">x)</span>
        <span class="s4">if </span><span class="s1">length &gt; </span><span class="s5">2 </span><span class="s1">** </span><span class="s5">31 </span><span class="s1">- </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;Chunk %s is too large: %d.&quot; </span><span class="s1">% (type</span><span class="s4">, </span><span class="s1">length))</span>
        <span class="s0"># Check that all bytes are in valid ASCII range.</span>
        <span class="s0"># https://www.w3.org/TR/2003/REC-PNG-20031110/#5Chunk-layout</span>
        <span class="s1">type_bytes = set(bytearray(type))</span>
        <span class="s4">if not </span><span class="s1">(type_bytes &lt;= set(range(</span><span class="s5">65</span><span class="s4">, </span><span class="s5">91</span><span class="s1">)) | set(range(</span><span class="s5">97</span><span class="s4">, </span><span class="s5">123</span><span class="s1">))):</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;Chunk %r has invalid Chunk Type.&quot; </span><span class="s1">% list(type))</span>
        <span class="s4">return </span><span class="s1">length</span><span class="s4">, </span><span class="s1">type</span>

    <span class="s4">def </span><span class="s1">process_chunk(self</span><span class="s4">, </span><span class="s1">lenient=</span><span class="s4">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Process the next chunk and its data. 
        This only processes the following chunk types: 
        ``IHDR``, ``PLTE``, ``bKGD``, ``tRNS``, ``gAMA``, ``sBIT``, ``pHYs``. 
        All other chunk types are ignored. 
 
        If the optional `lenient` argument evaluates to `True`, 
        checksum failures will raise warnings rather than exceptions. 
        &quot;&quot;&quot;</span>

        <span class="s1">type</span><span class="s4">, </span><span class="s1">data = self.chunk(lenient=lenient)</span>
        <span class="s1">method = </span><span class="s3">&quot;_process_&quot; </span><span class="s1">+ type.decode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span>
        <span class="s1">m = getattr(self</span><span class="s4">, </span><span class="s1">method</span><span class="s4">, None</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">m:</span>
            <span class="s1">m(data)</span>

    <span class="s4">def </span><span class="s1">_process_IHDR(self</span><span class="s4">, </span><span class="s1">data):</span>
        <span class="s0"># http://www.w3.org/TR/PNG/#11IHDR</span>
        <span class="s4">if </span><span class="s1">len(data) != </span><span class="s5">13</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;IHDR chunk has incorrect length.&quot;</span><span class="s1">)</span>
        <span class="s1">(</span>
            <span class="s1">self.width</span><span class="s4">,</span>
            <span class="s1">self.height</span><span class="s4">,</span>
            <span class="s1">self.bitdepth</span><span class="s4">,</span>
            <span class="s1">self.color_type</span><span class="s4">,</span>
            <span class="s1">self.compression</span><span class="s4">,</span>
            <span class="s1">self.filter</span><span class="s4">,</span>
            <span class="s1">self.interlace</span><span class="s4">,</span>
        <span class="s1">) = struct.unpack(</span><span class="s3">&quot;!2I5B&quot;</span><span class="s4">, </span><span class="s1">data)</span>

        <span class="s1">check_bitdepth_colortype(self.bitdepth</span><span class="s4">, </span><span class="s1">self.color_type)</span>

        <span class="s4">if </span><span class="s1">self.compression != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;Unknown compression method %d&quot; </span><span class="s1">% self.compression)</span>
        <span class="s4">if </span><span class="s1">self.filter != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span>
                <span class="s3">&quot;Unknown filter method %d,&quot;</span>
                <span class="s3">&quot; see http://www.w3.org/TR/2003/REC-PNG-20031110/#9Filters .&quot;</span>
                <span class="s1">% self.filter</span>
            <span class="s1">)</span>
        <span class="s4">if </span><span class="s1">self.interlace </span><span class="s4">not in </span><span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span>
                <span class="s3">&quot;Unknown interlace method %d, see &quot;</span>
                <span class="s3">&quot;http://www.w3.org/TR/2003/REC-PNG-20031110/#8InterlaceMethods&quot;</span>
                <span class="s3">&quot; .&quot; </span><span class="s1">% self.interlace</span>
            <span class="s1">)</span>

        <span class="s0"># Derived values</span>
        <span class="s0"># http://www.w3.org/TR/PNG/#6Colour-values</span>
        <span class="s1">colormap = bool(self.color_type &amp; </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">greyscale = </span><span class="s4">not </span><span class="s1">(self.color_type &amp; </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">alpha = bool(self.color_type &amp; </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">color_planes = (</span><span class="s5">3</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)[greyscale </span><span class="s4">or </span><span class="s1">colormap]</span>
        <span class="s1">planes = color_planes + alpha</span>

        <span class="s1">self.colormap = colormap</span>
        <span class="s1">self.greyscale = greyscale</span>
        <span class="s1">self.alpha = alpha</span>
        <span class="s1">self.color_planes = color_planes</span>
        <span class="s1">self.planes = planes</span>
        <span class="s1">self.psize = float(self.bitdepth) / float(</span><span class="s5">8</span><span class="s1">) * planes</span>
        <span class="s4">if </span><span class="s1">int(self.psize) == self.psize:</span>
            <span class="s1">self.psize = int(self.psize)</span>
        <span class="s1">self.row_bytes = int(math.ceil(self.width * self.psize))</span>
        <span class="s0"># Stores PLTE chunk if present, and is used to check</span>
        <span class="s0"># chunk ordering constraints.</span>
        <span class="s1">self.plte = </span><span class="s4">None</span>
        <span class="s0"># Stores tRNS chunk if present, and is used to check chunk</span>
        <span class="s0"># ordering constraints.</span>
        <span class="s1">self.trns = </span><span class="s4">None</span>
        <span class="s0"># Stores sBIT chunk if present.</span>
        <span class="s1">self.sbit = </span><span class="s4">None</span>

    <span class="s4">def </span><span class="s1">_process_PLTE(self</span><span class="s4">, </span><span class="s1">data):</span>
        <span class="s0"># http://www.w3.org/TR/PNG/#11PLTE</span>
        <span class="s4">if </span><span class="s1">self.plte:</span>
            <span class="s1">warnings.warn(</span><span class="s3">&quot;Multiple PLTE chunks present.&quot;</span><span class="s1">)</span>
        <span class="s1">self.plte = data</span>
        <span class="s4">if </span><span class="s1">len(data) % </span><span class="s5">3 </span><span class="s1">!= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;PLTE chunk's length should be a multiple of 3.&quot;</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">len(data) &gt; (</span><span class="s5">2 </span><span class="s1">** self.bitdepth) * </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;PLTE chunk is too long.&quot;</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">len(data) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;Empty PLTE is not allowed.&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">_process_bKGD(self</span><span class="s4">, </span><span class="s1">data):</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">self.colormap:</span>
                <span class="s4">if not </span><span class="s1">self.plte:</span>
                    <span class="s1">warnings.warn(</span><span class="s3">&quot;PLTE chunk is required before bKGD chunk.&quot;</span><span class="s1">)</span>
                <span class="s1">self.background = struct.unpack(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">data)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">self.background = struct.unpack(</span><span class="s3">&quot;!%dH&quot; </span><span class="s1">% self.color_planes</span><span class="s4">, </span><span class="s1">data)</span>
        <span class="s4">except </span><span class="s1">struct.error:</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;bKGD chunk has incorrect length.&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">_process_tRNS(self</span><span class="s4">, </span><span class="s1">data):</span>
        <span class="s0"># http://www.w3.org/TR/PNG/#11tRNS</span>
        <span class="s1">self.trns = data</span>
        <span class="s4">if </span><span class="s1">self.colormap:</span>
            <span class="s4">if not </span><span class="s1">self.plte:</span>
                <span class="s1">warnings.warn(</span><span class="s3">&quot;PLTE chunk is required before tRNS chunk.&quot;</span><span class="s1">)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s4">if </span><span class="s1">len(data) &gt; len(self.plte) / </span><span class="s5">3</span><span class="s1">:</span>
                    <span class="s0"># Was warning, but promoted to Error as it</span>
                    <span class="s0"># would otherwise cause pain later on.</span>
                    <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;tRNS chunk is too long.&quot;</span><span class="s1">)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">self.alpha:</span>
                <span class="s4">raise </span><span class="s1">FormatError(</span>
                    <span class="s3">&quot;tRNS chunk is not valid with colour type %d.&quot; </span><span class="s1">% self.color_type</span>
                <span class="s1">)</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s1">self.transparent = struct.unpack(</span><span class="s3">&quot;!%dH&quot; </span><span class="s1">% self.color_planes</span><span class="s4">, </span><span class="s1">data)</span>
            <span class="s4">except </span><span class="s1">struct.error:</span>
                <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;tRNS chunk has incorrect length.&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">_process_gAMA(self</span><span class="s4">, </span><span class="s1">data):</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">self.gamma = struct.unpack(</span><span class="s3">&quot;!L&quot;</span><span class="s4">, </span><span class="s1">data)[</span><span class="s5">0</span><span class="s1">] / </span><span class="s5">100000.0</span>
        <span class="s4">except </span><span class="s1">struct.error:</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;gAMA chunk has incorrect length.&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">_process_sBIT(self</span><span class="s4">, </span><span class="s1">data):</span>
        <span class="s1">self.sbit = data</span>
        <span class="s4">if </span><span class="s1">(</span>
            <span class="s1">self.colormap</span>
            <span class="s4">and </span><span class="s1">len(data) != </span><span class="s5">3</span>
            <span class="s4">or not </span><span class="s1">self.colormap</span>
            <span class="s4">and </span><span class="s1">len(data) != self.planes</span>
        <span class="s1">):</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;sBIT chunk has incorrect length.&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">_process_pHYs(self</span><span class="s4">, </span><span class="s1">data):</span>
        <span class="s0"># http://www.w3.org/TR/PNG/#11pHYs</span>
        <span class="s1">self.phys = data</span>
        <span class="s1">fmt = </span><span class="s3">&quot;!LLB&quot;</span>
        <span class="s4">if </span><span class="s1">len(data) != struct.calcsize(fmt):</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;pHYs chunk has incorrect length.&quot;</span><span class="s1">)</span>
        <span class="s1">self.x_pixels_per_unit</span><span class="s4">, </span><span class="s1">self.y_pixels_per_unit</span><span class="s4">, </span><span class="s1">unit = struct.unpack(fmt</span><span class="s4">, </span><span class="s1">data)</span>
        <span class="s1">self.unit_is_meter = bool(unit)</span>

    <span class="s4">def </span><span class="s1">read(self</span><span class="s4">, </span><span class="s1">lenient=</span><span class="s4">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Read the PNG file and decode it. 
        Returns (`width`, `height`, `rows`, `info`). 
 
        May use excessive memory. 
 
        `rows` is a sequence of rows; 
        each row is a sequence of values. 
 
        If the optional `lenient` argument evaluates to True, 
        checksum failures will raise warnings rather than exceptions. 
        &quot;&quot;&quot;</span>

        <span class="s4">def </span><span class="s1">iteridat():</span>
            <span class="s2">&quot;&quot;&quot;Iterator that yields all the ``IDAT`` chunks as strings.&quot;&quot;&quot;</span>
            <span class="s4">while True</span><span class="s1">:</span>
                <span class="s1">type</span><span class="s4">, </span><span class="s1">data = self.chunk(lenient=lenient)</span>
                <span class="s4">if </span><span class="s1">type == </span><span class="s6">b&quot;IEND&quot;</span><span class="s1">:</span>
                    <span class="s0"># http://www.w3.org/TR/PNG/#11IEND</span>
                    <span class="s4">break</span>
                <span class="s4">if </span><span class="s1">type != </span><span class="s6">b&quot;IDAT&quot;</span><span class="s1">:</span>
                    <span class="s4">continue</span>
                <span class="s0"># type == b'IDAT'</span>
                <span class="s0"># http://www.w3.org/TR/PNG/#11IDAT</span>
                <span class="s4">if </span><span class="s1">self.colormap </span><span class="s4">and not </span><span class="s1">self.plte:</span>
                    <span class="s1">warnings.warn(</span><span class="s3">&quot;PLTE chunk is required before IDAT chunk&quot;</span><span class="s1">)</span>
                <span class="s4">yield </span><span class="s1">data</span>

        <span class="s1">self.preamble(lenient=lenient)</span>
        <span class="s1">raw = decompress(iteridat())</span>

        <span class="s4">if </span><span class="s1">self.interlace:</span>

            <span class="s4">def </span><span class="s1">rows_from_interlace():</span>
                <span class="s2">&quot;&quot;&quot;Yield each row from an interlaced PNG.&quot;&quot;&quot;</span>
                <span class="s0"># It's important that this iterator doesn't read</span>
                <span class="s0"># IDAT chunks until it yields the first row.</span>
                <span class="s1">bs = bytearray(itertools.chain(*raw))</span>
                <span class="s1">arraycode = </span><span class="s3">&quot;BH&quot;</span><span class="s1">[self.bitdepth &gt; </span><span class="s5">8</span><span class="s1">]</span>
                <span class="s0"># Like :meth:`group` but</span>
                <span class="s0"># producing an array.array object for each row.</span>
                <span class="s1">values = self._deinterlace(bs)</span>
                <span class="s1">vpr = self.width * self.planes</span>
                <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">len(values)</span><span class="s4">, </span><span class="s1">vpr):</span>
                    <span class="s1">row = array(arraycode</span><span class="s4">, </span><span class="s1">values[i : i + vpr])</span>
                    <span class="s4">yield </span><span class="s1">row</span>

            <span class="s1">rows = rows_from_interlace()</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">rows = self._iter_bytes_to_values(self._iter_straight_packed(raw))</span>
        <span class="s1">info = dict()</span>
        <span class="s4">for </span><span class="s1">attr </span><span class="s4">in </span><span class="s3">&quot;greyscale alpha planes bitdepth interlace&quot;</span><span class="s1">.split():</span>
            <span class="s1">info[attr] = getattr(self</span><span class="s4">, </span><span class="s1">attr)</span>
        <span class="s1">info[</span><span class="s3">&quot;size&quot;</span><span class="s1">] = (self.width</span><span class="s4">, </span><span class="s1">self.height)</span>
        <span class="s4">for </span><span class="s1">attr </span><span class="s4">in </span><span class="s3">&quot;gamma transparent background&quot;</span><span class="s1">.split():</span>
            <span class="s1">a = getattr(self</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">, None</span><span class="s1">)</span>
            <span class="s4">if </span><span class="s1">a </span><span class="s4">is not None</span><span class="s1">:</span>
                <span class="s1">info[attr] = a</span>
        <span class="s4">if </span><span class="s1">getattr(self</span><span class="s4">, </span><span class="s3">&quot;x_pixels_per_unit&quot;</span><span class="s4">, None</span><span class="s1">):</span>
            <span class="s1">info[</span><span class="s3">&quot;physical&quot;</span><span class="s1">] = Resolution(</span>
                <span class="s1">self.x_pixels_per_unit</span><span class="s4">, </span><span class="s1">self.y_pixels_per_unit</span><span class="s4">, </span><span class="s1">self.unit_is_meter</span>
            <span class="s1">)</span>
        <span class="s4">if </span><span class="s1">self.plte:</span>
            <span class="s1">info[</span><span class="s3">&quot;palette&quot;</span><span class="s1">] = self.palette()</span>
        <span class="s4">return </span><span class="s1">self.width</span><span class="s4">, </span><span class="s1">self.height</span><span class="s4">, </span><span class="s1">rows</span><span class="s4">, </span><span class="s1">info</span>

    <span class="s4">def </span><span class="s1">read_flat(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Read a PNG file and decode it into a single array of values. 
        Returns (*width*, *height*, *values*, *info*). 
 
        May use excessive memory. 
 
        `values` is a single array. 
 
        The :meth:`read` method is more stream-friendly than this, 
        because it returns a sequence of rows. 
        &quot;&quot;&quot;</span>

        <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixel</span><span class="s4">, </span><span class="s1">info = self.read()</span>
        <span class="s1">arraycode = </span><span class="s3">&quot;BH&quot;</span><span class="s1">[info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] &gt; </span><span class="s5">8</span><span class="s1">]</span>
        <span class="s1">pixel = array(arraycode</span><span class="s4">, </span><span class="s1">itertools.chain(*pixel))</span>
        <span class="s4">return </span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixel</span><span class="s4">, </span><span class="s1">info</span>

    <span class="s4">def </span><span class="s1">palette(self</span><span class="s4">, </span><span class="s1">alpha=</span><span class="s3">&quot;natural&quot;</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns a palette that is a sequence of 3-tuples or 4-tuples, 
        synthesizing it from the ``PLTE`` and ``tRNS`` chunks. 
        These chunks should have already been processed (for example, 
        by calling the :meth:`preamble` method). 
        All the tuples are the same size: 
        3-tuples if there is no ``tRNS`` chunk, 
        4-tuples when there is a ``tRNS`` chunk. 
 
        Assumes that the image is colour type 
        3 and therefore a ``PLTE`` chunk is required. 
 
        If the `alpha` argument is ``'force'`` then an alpha channel is 
        always added, forcing the result to be a sequence of 4-tuples. 
        &quot;&quot;&quot;</span>

        <span class="s4">if not </span><span class="s1">self.plte:</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;Required PLTE chunk is missing in colour type 3 image.&quot;</span><span class="s1">)</span>
        <span class="s1">plte = group(array(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">self.plte)</span><span class="s4">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">self.trns </span><span class="s4">or </span><span class="s1">alpha == </span><span class="s3">&quot;force&quot;</span><span class="s1">:</span>
            <span class="s1">trns = array(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">self.trns </span><span class="s4">or </span><span class="s1">[])</span>
            <span class="s1">trns.extend([</span><span class="s5">255</span><span class="s1">] * (len(plte) - len(trns)))</span>
            <span class="s1">plte = list(map(operator.add</span><span class="s4">, </span><span class="s1">plte</span><span class="s4">, </span><span class="s1">group(trns</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)))</span>
        <span class="s4">return </span><span class="s1">plte</span>

    <span class="s4">def </span><span class="s1">asDirect(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns the image data as a direct representation of 
        an ``x * y * planes`` array. 
        This removes the need for callers to deal with 
        palettes and transparency themselves. 
        Images with a palette (colour type 3) are converted to RGB or RGBA; 
        images with transparency (a ``tRNS`` chunk) are converted to 
        LA or RGBA as appropriate. 
        When returned in this format the pixel values represent 
        the colour value directly without needing to refer 
        to palettes or transparency information. 
 
        Like the :meth:`read` method this method returns a 4-tuple: 
 
        (*width*, *height*, *rows*, *info*) 
 
        This method normally returns pixel values with 
        the bit depth they have in the source image, but 
        when the source PNG has an ``sBIT`` chunk it is inspected and 
        can reduce the bit depth of the result pixels; 
        pixel values will be reduced according to the bit depth 
        specified in the ``sBIT`` chunk. 
        PNG nerds should note a single result bit depth is 
        used for all channels: 
        the maximum of the ones specified in the ``sBIT`` chunk. 
        An RGB565 image will be rescaled to 6-bit RGB666. 
 
        The *info* dictionary that is returned reflects 
        the `direct` format and not the original source image. 
        For example, an RGB source image with a ``tRNS`` chunk 
        to represent a transparent colour, 
        will start with ``planes=3`` and ``alpha=False`` for the 
        source image, 
        but the *info* dictionary returned by this method 
        will have ``planes=4`` and ``alpha=True`` because 
        an alpha channel is synthesized and added. 
 
        *rows* is a sequence of rows; 
        each row being a sequence of values 
        (like the :meth:`read` method). 
 
        All the other aspects of the image data are not changed. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.preamble()</span>

        <span class="s0"># Simple case, no conversion necessary.</span>
        <span class="s4">if not </span><span class="s1">self.colormap </span><span class="s4">and not </span><span class="s1">self.trns </span><span class="s4">and not </span><span class="s1">self.sbit:</span>
            <span class="s4">return </span><span class="s1">self.read()</span>

        <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">info = self.read()</span>

        <span class="s4">if </span><span class="s1">self.colormap:</span>
            <span class="s1">info[</span><span class="s3">&quot;colormap&quot;</span><span class="s1">] = </span><span class="s4">False</span>
            <span class="s1">info[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">] = bool(self.trns)</span>
            <span class="s1">info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] = </span><span class="s5">8</span>
            <span class="s1">info[</span><span class="s3">&quot;planes&quot;</span><span class="s1">] = </span><span class="s5">3 </span><span class="s1">+ bool(self.trns)</span>
            <span class="s1">plte = self.palette()</span>

            <span class="s4">def </span><span class="s1">iterpal(pixels):</span>
                <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">pixels:</span>
                    <span class="s1">row = [plte[x] </span><span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">row]</span>
                    <span class="s4">yield </span><span class="s1">array(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">itertools.chain(*row))</span>

            <span class="s1">pixels = iterpal(pixels)</span>
        <span class="s4">elif </span><span class="s1">self.trns:</span>
            <span class="s0"># It would be nice if there was some reasonable way</span>
            <span class="s0"># of doing this without generating a whole load of</span>
            <span class="s0"># intermediate tuples.  But tuples does seem like the</span>
            <span class="s0"># easiest way, with no other way clearly much simpler or</span>
            <span class="s0"># much faster.  (Actually, the L to LA conversion could</span>
            <span class="s0"># perhaps go faster (all those 1-tuples!), but I still</span>
            <span class="s0"># wonder whether the code proliferation is worth it)</span>
            <span class="s1">it = self.transparent</span>
            <span class="s1">maxval = </span><span class="s5">2 </span><span class="s1">** info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] - </span><span class="s5">1</span>
            <span class="s1">planes = info[</span><span class="s3">&quot;planes&quot;</span><span class="s1">]</span>
            <span class="s1">info[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">] = </span><span class="s4">True</span>
            <span class="s1">info[</span><span class="s3">&quot;planes&quot;</span><span class="s1">] += </span><span class="s5">1</span>
            <span class="s1">typecode = </span><span class="s3">&quot;BH&quot;</span><span class="s1">[info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] &gt; </span><span class="s5">8</span><span class="s1">]</span>

            <span class="s4">def </span><span class="s1">itertrns(pixels):</span>
                <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">pixels:</span>
                    <span class="s0"># For each row we group it into pixels, then form a</span>
                    <span class="s0"># characterisation vector that says whether each</span>
                    <span class="s0"># pixel is opaque or not.  Then we convert</span>
                    <span class="s0"># True/False to 0/maxval (by multiplication),</span>
                    <span class="s0"># and add it as the extra channel.</span>
                    <span class="s1">row = group(row</span><span class="s4">, </span><span class="s1">planes)</span>
                    <span class="s1">opa = map(it.__ne__</span><span class="s4">, </span><span class="s1">row)</span>
                    <span class="s1">opa = map(maxval.__mul__</span><span class="s4">, </span><span class="s1">opa)</span>
                    <span class="s1">opa = list(zip(opa))  </span><span class="s0"># convert to 1-tuples</span>
                    <span class="s4">yield </span><span class="s1">array(typecode</span><span class="s4">, </span><span class="s1">itertools.chain(*map(operator.add</span><span class="s4">, </span><span class="s1">row</span><span class="s4">, </span><span class="s1">opa)))</span>

            <span class="s1">pixels = itertrns(pixels)</span>
        <span class="s1">targetbitdepth = </span><span class="s4">None</span>
        <span class="s4">if </span><span class="s1">self.sbit:</span>
            <span class="s1">sbit = struct.unpack(</span><span class="s3">&quot;%dB&quot; </span><span class="s1">% len(self.sbit)</span><span class="s4">, </span><span class="s1">self.sbit)</span>
            <span class="s1">targetbitdepth = max(sbit)</span>
            <span class="s4">if </span><span class="s1">targetbitdepth &gt; info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">]:</span>
                <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">&quot;sBIT chunk %r exceeds bitdepth %d&quot; </span><span class="s1">% (sbit</span><span class="s4">, </span><span class="s1">self.bitdepth))</span>
            <span class="s4">if </span><span class="s1">min(sbit) &lt;= </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">&quot;sBIT chunk %r has a 0-entry&quot; </span><span class="s1">% sbit)</span>
        <span class="s4">if </span><span class="s1">targetbitdepth:</span>
            <span class="s1">shift = info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] - targetbitdepth</span>
            <span class="s1">info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] = targetbitdepth</span>

            <span class="s4">def </span><span class="s1">itershift(pixels):</span>
                <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">pixels:</span>
                    <span class="s4">yield </span><span class="s1">[p &gt;&gt; shift </span><span class="s4">for </span><span class="s1">p </span><span class="s4">in </span><span class="s1">row]</span>

            <span class="s1">pixels = itershift(pixels)</span>
        <span class="s4">return </span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">info</span>

    <span class="s4">def </span><span class="s1">_as_rescale(self</span><span class="s4">, </span><span class="s1">get</span><span class="s4">, </span><span class="s1">targetbitdepth):</span>
        <span class="s2">&quot;&quot;&quot;Helper used by :meth:`asRGB8` and :meth:`asRGBA8`.&quot;&quot;&quot;</span>

        <span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">info = get()</span>
        <span class="s1">maxval = </span><span class="s5">2 </span><span class="s1">** info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] - </span><span class="s5">1</span>
        <span class="s1">targetmaxval = </span><span class="s5">2 </span><span class="s1">** targetbitdepth - </span><span class="s5">1</span>
        <span class="s1">factor = float(targetmaxval) / float(maxval)</span>
        <span class="s1">info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] = targetbitdepth</span>

        <span class="s4">def </span><span class="s1">iterscale():</span>
            <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">pixels:</span>
                <span class="s4">yield </span><span class="s1">[int(round(x * factor)) </span><span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">row]</span>

        <span class="s4">if </span><span class="s1">maxval == targetmaxval:</span>
            <span class="s4">return </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">info</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">iterscale()</span><span class="s4">, </span><span class="s1">info</span>

    <span class="s4">def </span><span class="s1">asRGB8(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the image data as an RGB pixels with 8-bits per sample. 
        This is like the :meth:`asRGB` method except that 
        this method additionally rescales the values so that 
        they are all between 0 and 255 (8-bit). 
        In the case where the source image has a bit depth &lt; 8 
        the transformation preserves all the information; 
        where the source image has bit depth &gt; 8, then 
        rescaling to 8-bit values loses precision. 
        No dithering is performed. 
        Like :meth:`asRGB`, 
        an alpha channel in the source image will raise an exception. 
 
        This function returns a 4-tuple: 
        (*width*, *height*, *rows*, *info*). 
        *width*, *height*, *info* are as per the :meth:`read` method. 
 
        *rows* is the pixel data as a sequence of rows. 
        &quot;&quot;&quot;</span>

        <span class="s4">return </span><span class="s1">self._as_rescale(self.asRGB</span><span class="s4">, </span><span class="s5">8</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">asRGBA8(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the image data as RGBA pixels with 8-bits per sample. 
        This method is similar to :meth:`asRGB8` and :meth:`asRGBA`: 
        The result pixels have an alpha channel, *and* 
        values are rescaled to the range 0 to 255. 
        The alpha channel is synthesized if necessary 
        (with a small speed penalty). 
        &quot;&quot;&quot;</span>

        <span class="s4">return </span><span class="s1">self._as_rescale(self.asRGBA</span><span class="s4">, </span><span class="s5">8</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">asRGB(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return image as RGB pixels. 
        RGB colour images are passed through unchanged; 
        greyscales are expanded into RGB triplets 
        (there is a small speed overhead for doing this). 
 
        An alpha channel in the source image will raise an exception. 
 
        The return values are as for the :meth:`read` method except that 
        the *info* reflect the returned pixels, not the source image. 
        In particular, 
        for this method ``info['greyscale']`` will be ``False``. 
        &quot;&quot;&quot;</span>

        <span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">info = self.asDirect()</span>
        <span class="s4">if </span><span class="s1">info[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">]:</span>
            <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">&quot;will not convert image with alpha channel to RGB&quot;</span><span class="s1">)</span>
        <span class="s4">if not </span><span class="s1">info[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">]:</span>
            <span class="s4">return </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">info</span>
        <span class="s1">info[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">] = </span><span class="s4">False</span>
        <span class="s1">info[</span><span class="s3">&quot;planes&quot;</span><span class="s1">] = </span><span class="s5">3</span>

        <span class="s4">if </span><span class="s1">info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] &gt; </span><span class="s5">8</span><span class="s1">:</span>

            <span class="s4">def </span><span class="s1">newarray():</span>
                <span class="s4">return </span><span class="s1">array(</span><span class="s3">&quot;H&quot;</span><span class="s4">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s4">else</span><span class="s1">:</span>

            <span class="s4">def </span><span class="s1">newarray():</span>
                <span class="s4">return </span><span class="s1">bytearray([</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s4">def </span><span class="s1">iterrgb():</span>
            <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">pixels:</span>
                <span class="s1">a = newarray() * </span><span class="s5">3 </span><span class="s1">* width</span>
                <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s1">):</span>
                    <span class="s1">a[i::</span><span class="s5">3</span><span class="s1">] = row</span>
                <span class="s4">yield </span><span class="s1">a</span>

        <span class="s4">return </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">iterrgb()</span><span class="s4">, </span><span class="s1">info</span>

    <span class="s4">def </span><span class="s1">asRGBA(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return image as RGBA pixels. 
        Greyscales are expanded into RGB triplets; 
        an alpha channel is synthesized if necessary. 
        The return values are as for the :meth:`read` method except that 
        the *info* reflect the returned pixels, not the source image. 
        In particular, for this method 
        ``info['greyscale']`` will be ``False``, and 
        ``info['alpha']`` will be ``True``. 
        &quot;&quot;&quot;</span>

        <span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">info = self.asDirect()</span>
        <span class="s4">if </span><span class="s1">info[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">] </span><span class="s4">and not </span><span class="s1">info[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">]:</span>
            <span class="s4">return </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">info</span>
        <span class="s1">typecode = </span><span class="s3">&quot;BH&quot;</span><span class="s1">[info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] &gt; </span><span class="s5">8</span><span class="s1">]</span>
        <span class="s1">maxval = </span><span class="s5">2 </span><span class="s1">** info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] - </span><span class="s5">1</span>
        <span class="s1">maxbuffer = struct.pack(</span><span class="s3">&quot;=&quot; </span><span class="s1">+ typecode</span><span class="s4">, </span><span class="s1">maxval) * </span><span class="s5">4 </span><span class="s1">* width</span>

        <span class="s4">if </span><span class="s1">info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] &gt; </span><span class="s5">8</span><span class="s1">:</span>

            <span class="s4">def </span><span class="s1">newarray():</span>
                <span class="s4">return </span><span class="s1">array(</span><span class="s3">&quot;H&quot;</span><span class="s4">, </span><span class="s1">maxbuffer)</span>

        <span class="s4">else</span><span class="s1">:</span>

            <span class="s4">def </span><span class="s1">newarray():</span>
                <span class="s4">return </span><span class="s1">bytearray(maxbuffer)</span>

        <span class="s4">if </span><span class="s1">info[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">] </span><span class="s4">and </span><span class="s1">info[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">]:</span>
            <span class="s0"># LA to RGBA</span>
            <span class="s4">def </span><span class="s1">convert():</span>
                <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">pixels:</span>
                    <span class="s0"># Create a fresh target row, then copy L channel</span>
                    <span class="s0"># into first three target channels, and A channel</span>
                    <span class="s0"># into fourth channel.</span>
                    <span class="s1">a = newarray()</span>
                    <span class="s1">convert_la_to_rgba(row</span><span class="s4">, </span><span class="s1">a)</span>
                    <span class="s4">yield </span><span class="s1">a</span>

        <span class="s4">elif </span><span class="s1">info[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">]:</span>
            <span class="s0"># L to RGBA</span>
            <span class="s4">def </span><span class="s1">convert():</span>
                <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">pixels:</span>
                    <span class="s1">a = newarray()</span>
                    <span class="s1">convert_l_to_rgba(row</span><span class="s4">, </span><span class="s1">a)</span>
                    <span class="s4">yield </span><span class="s1">a</span>

        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">assert not </span><span class="s1">info[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">] </span><span class="s4">and not </span><span class="s1">info[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">]</span>
            <span class="s0"># RGB to RGBA</span>

            <span class="s4">def </span><span class="s1">convert():</span>
                <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">pixels:</span>
                    <span class="s1">a = newarray()</span>
                    <span class="s1">convert_rgb_to_rgba(row</span><span class="s4">, </span><span class="s1">a)</span>
                    <span class="s4">yield </span><span class="s1">a</span>

        <span class="s1">info[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">] = </span><span class="s4">True</span>
        <span class="s1">info[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">] = </span><span class="s4">False</span>
        <span class="s1">info[</span><span class="s3">&quot;planes&quot;</span><span class="s1">] = </span><span class="s5">4</span>
        <span class="s4">return </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">convert()</span><span class="s4">, </span><span class="s1">info</span>


<span class="s4">def </span><span class="s1">decompress(data_blocks):</span>
    <span class="s2">&quot;&quot;&quot; 
    `data_blocks` should be an iterable that 
    yields the compressed data (from the ``IDAT`` chunks). 
    This yields decompressed byte strings. 
    &quot;&quot;&quot;</span>

    <span class="s0"># Currently, with no max_length parameter to decompress,</span>
    <span class="s0"># this routine will do one yield per IDAT chunk: Not very</span>
    <span class="s0"># incremental.</span>
    <span class="s1">d = zlib.decompressobj()</span>
    <span class="s0"># Each IDAT chunk is passed to the decompressor, then any</span>
    <span class="s0"># remaining state is decompressed out.</span>
    <span class="s4">for </span><span class="s1">data </span><span class="s4">in </span><span class="s1">data_blocks:</span>
        <span class="s0"># :todo: add a max_length argument here to limit output size.</span>
        <span class="s4">yield </span><span class="s1">bytearray(d.decompress(data))</span>
    <span class="s4">yield </span><span class="s1">bytearray(d.flush())</span>


<span class="s4">def </span><span class="s1">check_bitdepth_colortype(bitdepth</span><span class="s4">, </span><span class="s1">colortype):</span>
    <span class="s2">&quot;&quot;&quot; 
    Check that `bitdepth` and `colortype` are both valid, 
    and specified in a valid combination. 
    Returns (None) if valid, raise an Exception if not valid. 
    &quot;&quot;&quot;</span>

    <span class="s4">if </span><span class="s1">bitdepth </span><span class="s4">not in </span><span class="s1">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s5">8</span><span class="s4">, </span><span class="s5">16</span><span class="s1">):</span>
        <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;invalid bit depth %d&quot; </span><span class="s1">% bitdepth)</span>
    <span class="s4">if </span><span class="s1">colortype </span><span class="s4">not in </span><span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s5">6</span><span class="s1">):</span>
        <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;invalid colour type %d&quot; </span><span class="s1">% colortype)</span>
    <span class="s0"># Check indexed (palettized) images have 8 or fewer bits</span>
    <span class="s0"># per pixel; check only indexed or greyscale images have</span>
    <span class="s0"># fewer than 8 bits per pixel.</span>
    <span class="s4">if </span><span class="s1">colortype &amp; </span><span class="s5">1 </span><span class="s4">and </span><span class="s1">bitdepth &gt; </span><span class="s5">8</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">FormatError(</span>
            <span class="s3">&quot;Indexed images (colour type %d) cannot&quot;</span>
            <span class="s3">&quot; have bitdepth &gt; 8 (bit depth %d).&quot;</span>
            <span class="s3">&quot; See http://www.w3.org/TR/2003/REC-PNG-20031110/#table111 .&quot;</span>
            <span class="s1">% (bitdepth</span><span class="s4">, </span><span class="s1">colortype)</span>
        <span class="s1">)</span>
    <span class="s4">if </span><span class="s1">bitdepth &lt; </span><span class="s5">8 </span><span class="s4">and </span><span class="s1">colortype </span><span class="s4">not in </span><span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">3</span><span class="s1">):</span>
        <span class="s4">raise </span><span class="s1">FormatError(</span>
            <span class="s3">&quot;Illegal combination of bit depth (%d)&quot;</span>
            <span class="s3">&quot; and colour type (%d).&quot;</span>
            <span class="s3">&quot; See http://www.w3.org/TR/2003/REC-PNG-20031110/#table111 .&quot;</span>
            <span class="s1">% (bitdepth</span><span class="s4">, </span><span class="s1">colortype)</span>
        <span class="s1">)</span>


<span class="s4">def </span><span class="s1">is_natural(x):</span>
    <span class="s2">&quot;&quot;&quot;A non-negative integer.&quot;&quot;&quot;</span>
    <span class="s4">try</span><span class="s1">:</span>
        <span class="s1">is_integer = int(x) == x</span>
    <span class="s4">except </span><span class="s1">(TypeError</span><span class="s4">, </span><span class="s1">ValueError):</span>
        <span class="s4">return False</span>
    <span class="s4">return </span><span class="s1">is_integer </span><span class="s4">and </span><span class="s1">x &gt;= </span><span class="s5">0</span>


<span class="s4">def </span><span class="s1">undo_filter_sub(filter_unit</span><span class="s4">, </span><span class="s1">scanline</span><span class="s4">, </span><span class="s1">previous</span><span class="s4">, </span><span class="s1">result):</span>
    <span class="s2">&quot;&quot;&quot;Undo sub filter.&quot;&quot;&quot;</span>

    <span class="s1">ai = </span><span class="s5">0</span>
    <span class="s0"># Loops starts at index fu.  Observe that the initial part</span>
    <span class="s0"># of the result is already filled in correctly with</span>
    <span class="s0"># scanline.</span>
    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(filter_unit</span><span class="s4">, </span><span class="s1">len(result)):</span>
        <span class="s1">x = scanline[i]</span>
        <span class="s1">a = result[ai]</span>
        <span class="s1">result[i] = (x + a) &amp; </span><span class="s5">0xFF</span>
        <span class="s1">ai += </span><span class="s5">1</span>


<span class="s4">def </span><span class="s1">undo_filter_up(filter_unit</span><span class="s4">, </span><span class="s1">scanline</span><span class="s4">, </span><span class="s1">previous</span><span class="s4">, </span><span class="s1">result):</span>
    <span class="s2">&quot;&quot;&quot;Undo up filter.&quot;&quot;&quot;</span>

    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(len(result)):</span>
        <span class="s1">x = scanline[i]</span>
        <span class="s1">b = previous[i]</span>
        <span class="s1">result[i] = (x + b) &amp; </span><span class="s5">0xFF</span>


<span class="s4">def </span><span class="s1">undo_filter_average(filter_unit</span><span class="s4">, </span><span class="s1">scanline</span><span class="s4">, </span><span class="s1">previous</span><span class="s4">, </span><span class="s1">result):</span>
    <span class="s2">&quot;&quot;&quot;Undo up filter.&quot;&quot;&quot;</span>

    <span class="s1">ai = -filter_unit</span>
    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(len(result)):</span>
        <span class="s1">x = scanline[i]</span>
        <span class="s4">if </span><span class="s1">ai &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">a = </span><span class="s5">0</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">a = result[ai]</span>
        <span class="s1">b = previous[i]</span>
        <span class="s1">result[i] = (x + ((a + b) &gt;&gt; </span><span class="s5">1</span><span class="s1">)) &amp; </span><span class="s5">0xFF</span>
        <span class="s1">ai += </span><span class="s5">1</span>


<span class="s4">def </span><span class="s1">undo_filter_paeth(filter_unit</span><span class="s4">, </span><span class="s1">scanline</span><span class="s4">, </span><span class="s1">previous</span><span class="s4">, </span><span class="s1">result):</span>
    <span class="s2">&quot;&quot;&quot;Undo Paeth filter.&quot;&quot;&quot;</span>

    <span class="s0"># Also used for ci.</span>
    <span class="s1">ai = -filter_unit</span>
    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(len(result)):</span>
        <span class="s1">x = scanline[i]</span>
        <span class="s4">if </span><span class="s1">ai &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">a = c = </span><span class="s5">0</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">a = result[ai]</span>
            <span class="s1">c = previous[ai]</span>
        <span class="s1">b = previous[i]</span>
        <span class="s1">p = a + b - c</span>
        <span class="s1">pa = abs(p - a)</span>
        <span class="s1">pb = abs(p - b)</span>
        <span class="s1">pc = abs(p - c)</span>
        <span class="s4">if </span><span class="s1">pa &lt;= pb </span><span class="s4">and </span><span class="s1">pa &lt;= pc:</span>
            <span class="s1">pr = a</span>
        <span class="s4">elif </span><span class="s1">pb &lt;= pc:</span>
            <span class="s1">pr = b</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">pr = c</span>
        <span class="s1">result[i] = (x + pr) &amp; </span><span class="s5">0xFF</span>
        <span class="s1">ai += </span><span class="s5">1</span>


<span class="s4">def </span><span class="s1">convert_la_to_rgba(row</span><span class="s4">, </span><span class="s1">result):</span>
    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s1">):</span>
        <span class="s1">result[i::</span><span class="s5">4</span><span class="s1">] = row[</span><span class="s5">0</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s1">result[</span><span class="s5">3</span><span class="s1">::</span><span class="s5">4</span><span class="s1">] = row[</span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>


<span class="s4">def </span><span class="s1">convert_l_to_rgba(row</span><span class="s4">, </span><span class="s1">result):</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert a grayscale image to RGBA. 
    This method assumes the alpha channel in result is 
    already correctly initialized. 
    &quot;&quot;&quot;</span>
    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s1">):</span>
        <span class="s1">result[i::</span><span class="s5">4</span><span class="s1">] = row</span>


<span class="s4">def </span><span class="s1">convert_rgb_to_rgba(row</span><span class="s4">, </span><span class="s1">result):</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert an RGB image to RGBA. 
    This method assumes the alpha channel in result is 
    already correctly initialized. 
    &quot;&quot;&quot;</span>
    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s1">):</span>
        <span class="s1">result[i::</span><span class="s5">4</span><span class="s1">] = row[i::</span><span class="s5">3</span><span class="s1">]</span>


<span class="s0"># Only reason to include this in this module is that</span>
<span class="s0"># several utilities need it, and it is small.</span>
<span class="s4">def </span><span class="s1">binary_stdin():</span>
    <span class="s2">&quot;&quot;&quot; 
    A sys.stdin that returns bytes. 
    &quot;&quot;&quot;</span>

    <span class="s4">return </span><span class="s1">sys.stdin.buffer</span>


<span class="s4">def </span><span class="s1">binary_stdout():</span>
    <span class="s2">&quot;&quot;&quot; 
    A sys.stdout that accepts bytes. 
    &quot;&quot;&quot;</span>

    <span class="s1">stdout = sys.stdout.buffer</span>

    <span class="s0"># On Windows the C runtime file orientation needs changing.</span>
    <span class="s4">if </span><span class="s1">sys.platform == </span><span class="s3">&quot;win32&quot;</span><span class="s1">:</span>
        <span class="s4">import </span><span class="s1">msvcrt</span>
        <span class="s4">import </span><span class="s1">os</span>

        <span class="s1">msvcrt.setmode(sys.stdout.fileno()</span><span class="s4">, </span><span class="s1">os.O_BINARY)</span>

    <span class="s4">return </span><span class="s1">stdout</span>


<span class="s4">def </span><span class="s1">cli_open(path):</span>
    <span class="s4">if </span><span class="s1">path == </span><span class="s3">&quot;-&quot;</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">binary_stdin()</span>
    <span class="s4">return </span><span class="s1">open(path</span><span class="s4">, </span><span class="s3">&quot;rb&quot;</span><span class="s1">)</span>
</pre>
</body>
</html>