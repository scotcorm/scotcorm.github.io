<html>
<head>
<title>test_linalg.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_linalg.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; Test functions for linalg module 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">traceback</span>
<span class="s2">import </span><span class="s1">textwrap</span>
<span class="s2">import </span><span class="s1">subprocess</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">array</span><span class="s2">, </span><span class="s1">single</span><span class="s2">, </span><span class="s1">double</span><span class="s2">, </span><span class="s1">csingle</span><span class="s2">, </span><span class="s1">cdouble</span><span class="s2">, </span><span class="s1">dot</span><span class="s2">, </span><span class="s1">identity</span><span class="s2">, </span><span class="s1">matmul</span>
<span class="s2">from </span><span class="s1">numpy.core </span><span class="s2">import </span><span class="s1">swapaxes</span>
<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">multiply</span><span class="s2">, </span><span class="s1">atleast_2d</span><span class="s2">, </span><span class="s1">inf</span><span class="s2">, </span><span class="s1">asarray</span>
<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">linalg</span>
<span class="s2">from </span><span class="s1">numpy.linalg </span><span class="s2">import </span><span class="s1">matrix_power</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">matrix_rank</span><span class="s2">, </span><span class="s1">multi_dot</span><span class="s2">, </span><span class="s1">LinAlgError</span>
<span class="s2">from </span><span class="s1">numpy.linalg.linalg </span><span class="s2">import </span><span class="s1">_multi_dot_matrix_chain_order</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">assert_</span><span class="s2">, </span><span class="s1">assert_equal</span><span class="s2">, </span><span class="s1">assert_raises</span><span class="s2">, </span><span class="s1">assert_array_equal</span><span class="s2">,</span>
    <span class="s1">assert_almost_equal</span><span class="s2">, </span><span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">suppress_warnings</span><span class="s2">,</span>
    <span class="s1">assert_raises_regex</span><span class="s2">, </span><span class="s1">HAS_LAPACK64</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">consistent_subclass(out</span><span class="s2">, </span><span class="s1">in_):</span>
    <span class="s3"># For ndarray subclass input, our output should have the same subclass</span>
    <span class="s3"># (non-ndarray input gets converted to ndarray).</span>
    <span class="s2">return </span><span class="s1">type(out) </span><span class="s2">is </span><span class="s1">(type(in_) </span><span class="s2">if </span><span class="s1">isinstance(in_</span><span class="s2">, </span><span class="s1">np.ndarray)</span>
                         <span class="s2">else </span><span class="s1">np.ndarray)</span>


<span class="s1">old_assert_almost_equal = assert_almost_equal</span>


<span class="s2">def </span><span class="s1">assert_almost_equal(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">single_decimal=</span><span class="s4">6</span><span class="s2">, </span><span class="s1">double_decimal=</span><span class="s4">12</span><span class="s2">, </span><span class="s1">**kw):</span>
    <span class="s2">if </span><span class="s1">asarray(a).dtype.type </span><span class="s2">in </span><span class="s1">(single</span><span class="s2">, </span><span class="s1">csingle):</span>
        <span class="s1">decimal = single_decimal</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">decimal = double_decimal</span>
    <span class="s1">old_assert_almost_equal(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">decimal=decimal</span><span class="s2">, </span><span class="s1">**kw)</span>


<span class="s2">def </span><span class="s1">get_real_dtype(dtype):</span>
    <span class="s2">return </span><span class="s1">{single: single</span><span class="s2">, </span><span class="s1">double: double</span><span class="s2">,</span>
            <span class="s1">csingle: single</span><span class="s2">, </span><span class="s1">cdouble: double}[dtype]</span>


<span class="s2">def </span><span class="s1">get_complex_dtype(dtype):</span>
    <span class="s2">return </span><span class="s1">{single: csingle</span><span class="s2">, </span><span class="s1">double: cdouble</span><span class="s2">,</span>
            <span class="s1">csingle: csingle</span><span class="s2">, </span><span class="s1">cdouble: cdouble}[dtype]</span>


<span class="s2">def </span><span class="s1">get_rtol(dtype):</span>
    <span class="s3"># Choose a safe rtol</span>
    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">(single</span><span class="s2">, </span><span class="s1">csingle):</span>
        <span class="s2">return </span><span class="s4">1e-5</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s4">1e-11</span>


<span class="s3"># used to categorize tests</span>
<span class="s1">all_tags = {</span>
  <span class="s5">'square'</span><span class="s2">, </span><span class="s5">'nonsquare'</span><span class="s2">, </span><span class="s5">'hermitian'</span><span class="s2">,  </span><span class="s3"># mutually exclusive</span>
  <span class="s5">'generalized'</span><span class="s2">, </span><span class="s5">'size-0'</span><span class="s2">, </span><span class="s5">'strided' </span><span class="s3"># optional additions</span>
<span class="s1">}</span>


<span class="s2">class </span><span class="s1">LinalgCase:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tags=set()):</span>
        <span class="s0">&quot;&quot;&quot; 
        A bundle of arguments to be passed to a test case, with an identifying 
        name, the operands a and b, and a set of tags to filter the tests 
        &quot;&quot;&quot;</span>
        <span class="s1">assert_(isinstance(name</span><span class="s2">, </span><span class="s1">str))</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.a = a</span>
        <span class="s1">self.b = b</span>
        <span class="s1">self.tags = frozenset(tags)  </span><span class="s3"># prevent shared tags</span>

    <span class="s2">def </span><span class="s1">check(self</span><span class="s2">, </span><span class="s1">do):</span>
        <span class="s0">&quot;&quot;&quot; 
        Run the function `do` on this test case, expanding arguments 
        &quot;&quot;&quot;</span>
        <span class="s1">do(self.a</span><span class="s2">, </span><span class="s1">self.b</span><span class="s2">, </span><span class="s1">tags=self.tags)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s5">f'&lt;LinalgCase: </span><span class="s2">{</span><span class="s1">self.name</span><span class="s2">}</span><span class="s5">&gt;'</span>


<span class="s2">def </span><span class="s1">apply_tag(tag</span><span class="s2">, </span><span class="s1">cases):</span>
    <span class="s0">&quot;&quot;&quot; 
    Add the given tag (a string) to each of the cases (a list of LinalgCase 
    objects) 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">tag </span><span class="s2">in </span><span class="s1">all_tags</span><span class="s2">, </span><span class="s5">&quot;Invalid tag&quot;</span>
    <span class="s2">for </span><span class="s1">case </span><span class="s2">in </span><span class="s1">cases:</span>
        <span class="s1">case.tags = case.tags | {tag}</span>
    <span class="s2">return </span><span class="s1">cases</span>


<span class="s3">#</span>
<span class="s3"># Base test cases</span>
<span class="s3">#</span>

<span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

<span class="s1">CASES = []</span>

<span class="s3"># square test cases</span>
<span class="s1">CASES += apply_tag(</span><span class="s5">'square'</span><span class="s2">, </span><span class="s1">[</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;single&quot;</span><span class="s2">,</span>
               <span class="s1">array([[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3.</span><span class="s2">, </span><span class="s4">4.</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=single)</span><span class="s2">,</span>
               <span class="s1">array([</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=single))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;double&quot;</span><span class="s2">,</span>
               <span class="s1">array([[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3.</span><span class="s2">, </span><span class="s4">4.</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=double)</span><span class="s2">,</span>
               <span class="s1">array([</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=double))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;double_2&quot;</span><span class="s2">,</span>
               <span class="s1">array([[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3.</span><span class="s2">, </span><span class="s4">4.</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=double)</span><span class="s2">,</span>
               <span class="s1">array([[</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">4.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3.</span><span class="s2">, </span><span class="s4">4.</span><span class="s2">, </span><span class="s4">6.</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=double))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;csingle&quot;</span><span class="s2">,</span>
               <span class="s1">array([[</span><span class="s4">1. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">3j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3 </span><span class="s1">+ </span><span class="s4">4j</span><span class="s2">, </span><span class="s4">4 </span><span class="s1">+ </span><span class="s4">5j</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=csingle)</span><span class="s2">,</span>
               <span class="s1">array([</span><span class="s4">2. </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">1. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=csingle))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;cdouble&quot;</span><span class="s2">,</span>
               <span class="s1">array([[</span><span class="s4">1. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">3j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3 </span><span class="s1">+ </span><span class="s4">4j</span><span class="s2">, </span><span class="s4">4 </span><span class="s1">+ </span><span class="s4">5j</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=cdouble)</span><span class="s2">,</span>
               <span class="s1">array([</span><span class="s4">2. </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">1. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=cdouble))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;cdouble_2&quot;</span><span class="s2">,</span>
               <span class="s1">array([[</span><span class="s4">1. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">3j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3 </span><span class="s1">+ </span><span class="s4">4j</span><span class="s2">, </span><span class="s4">4 </span><span class="s1">+ </span><span class="s4">5j</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=cdouble)</span><span class="s2">,</span>
               <span class="s1">array([[</span><span class="s4">2. </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">1. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">3j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1 </span><span class="s1">- </span><span class="s4">2j</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- </span><span class="s4">3j</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- </span><span class="s4">6j</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=cdouble))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;0x0&quot;</span><span class="s2">,</span>
               <span class="s1">np.empty((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=double)</span><span class="s2">,</span>
               <span class="s1">np.empty((</span><span class="s4">0</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=double)</span><span class="s2">,</span>
               <span class="s1">tags={</span><span class="s5">'size-0'</span><span class="s1">})</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;8x8&quot;</span><span class="s2">,</span>
               <span class="s1">np.random.rand(</span><span class="s4">8</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">,</span>
               <span class="s1">np.random.rand(</span><span class="s4">8</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;1x1&quot;</span><span class="s2">,</span>
               <span class="s1">np.random.rand(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
               <span class="s1">np.random.rand(</span><span class="s4">1</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;nonarray&quot;</span><span class="s2">,</span>
               <span class="s1">[[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]]</span><span class="s2">,</span>
               <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
<span class="s1">])</span>

<span class="s3"># non-square test-cases</span>
<span class="s1">CASES += apply_tag(</span><span class="s5">'nonsquare'</span><span class="s2">, </span><span class="s1">[</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;single_nsq_1&quot;</span><span class="s2">,</span>
               <span class="s1">array([[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">3.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3.</span><span class="s2">, </span><span class="s4">4.</span><span class="s2">, </span><span class="s4">6.</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=single)</span><span class="s2">,</span>
               <span class="s1">array([</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=single))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;single_nsq_2&quot;</span><span class="s2">,</span>
               <span class="s1">array([[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3.</span><span class="s2">, </span><span class="s4">4.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5.</span><span class="s2">, </span><span class="s4">6.</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=single)</span><span class="s2">,</span>
               <span class="s1">array([</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">3.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=single))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;double_nsq_1&quot;</span><span class="s2">,</span>
               <span class="s1">array([[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">3.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3.</span><span class="s2">, </span><span class="s4">4.</span><span class="s2">, </span><span class="s4">6.</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=double)</span><span class="s2">,</span>
               <span class="s1">array([</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=double))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;double_nsq_2&quot;</span><span class="s2">,</span>
               <span class="s1">array([[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3.</span><span class="s2">, </span><span class="s4">4.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5.</span><span class="s2">, </span><span class="s4">6.</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=double)</span><span class="s2">,</span>
               <span class="s1">array([</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">3.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=double))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;csingle_nsq_1&quot;</span><span class="s2">,</span>
               <span class="s1">array(</span>
                   <span class="s1">[[</span><span class="s4">1. </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s2">, </span><span class="s4">3. </span><span class="s1">- </span><span class="s4">3j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3. </span><span class="s1">- </span><span class="s4">5j</span><span class="s2">, </span><span class="s4">4. </span><span class="s1">+ </span><span class="s4">9j</span><span class="s2">, </span><span class="s4">6. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=csingle)</span><span class="s2">,</span>
               <span class="s1">array([</span><span class="s4">2. </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">1. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=csingle))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;csingle_nsq_2&quot;</span><span class="s2">,</span>
               <span class="s1">array(</span>
                   <span class="s1">[[</span><span class="s4">1. </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3. </span><span class="s1">- </span><span class="s4">3j</span><span class="s2">, </span><span class="s4">4. </span><span class="s1">- </span><span class="s4">9j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5. </span><span class="s1">- </span><span class="s4">4j</span><span class="s2">, </span><span class="s4">6. </span><span class="s1">+ </span><span class="s4">8j</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=csingle)</span><span class="s2">,</span>
               <span class="s1">array([</span><span class="s4">2. </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">1. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s2">, </span><span class="s4">3. </span><span class="s1">- </span><span class="s4">3j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=csingle))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;cdouble_nsq_1&quot;</span><span class="s2">,</span>
               <span class="s1">array(</span>
                   <span class="s1">[[</span><span class="s4">1. </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s2">, </span><span class="s4">3. </span><span class="s1">- </span><span class="s4">3j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3. </span><span class="s1">- </span><span class="s4">5j</span><span class="s2">, </span><span class="s4">4. </span><span class="s1">+ </span><span class="s4">9j</span><span class="s2">, </span><span class="s4">6. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=cdouble)</span><span class="s2">,</span>
               <span class="s1">array([</span><span class="s4">2. </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">1. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=cdouble))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;cdouble_nsq_2&quot;</span><span class="s2">,</span>
               <span class="s1">array(</span>
                   <span class="s1">[[</span><span class="s4">1. </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3. </span><span class="s1">- </span><span class="s4">3j</span><span class="s2">, </span><span class="s4">4. </span><span class="s1">- </span><span class="s4">9j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5. </span><span class="s1">- </span><span class="s4">4j</span><span class="s2">, </span><span class="s4">6. </span><span class="s1">+ </span><span class="s4">8j</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=cdouble)</span><span class="s2">,</span>
               <span class="s1">array([</span><span class="s4">2. </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">1. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s2">, </span><span class="s4">3. </span><span class="s1">- </span><span class="s4">3j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=cdouble))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;cdouble_nsq_1_2&quot;</span><span class="s2">,</span>
               <span class="s1">array(</span>
                   <span class="s1">[[</span><span class="s4">1. </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s2">, </span><span class="s4">3. </span><span class="s1">- </span><span class="s4">3j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3. </span><span class="s1">- </span><span class="s4">5j</span><span class="s2">, </span><span class="s4">4. </span><span class="s1">+ </span><span class="s4">9j</span><span class="s2">, </span><span class="s4">6. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=cdouble)</span><span class="s2">,</span>
               <span class="s1">array([[</span><span class="s4">2. </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">1. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1 </span><span class="s1">- </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">2j</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=cdouble))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;cdouble_nsq_2_2&quot;</span><span class="s2">,</span>
               <span class="s1">array(</span>
                   <span class="s1">[[</span><span class="s4">1. </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3. </span><span class="s1">- </span><span class="s4">3j</span><span class="s2">, </span><span class="s4">4. </span><span class="s1">- </span><span class="s4">9j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5. </span><span class="s1">- </span><span class="s4">4j</span><span class="s2">, </span><span class="s4">6. </span><span class="s1">+ </span><span class="s4">8j</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=cdouble)</span><span class="s2">,</span>
               <span class="s1">array([[</span><span class="s4">2. </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">1. </span><span class="s1">+ </span><span class="s4">2j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1 </span><span class="s1">- </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">2j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1 </span><span class="s1">- </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">2j</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=cdouble))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;8x11&quot;</span><span class="s2">,</span>
               <span class="s1">np.random.rand(</span><span class="s4">8</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span><span class="s2">,</span>
               <span class="s1">np.random.rand(</span><span class="s4">8</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;1x5&quot;</span><span class="s2">,</span>
               <span class="s1">np.random.rand(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span><span class="s2">,</span>
               <span class="s1">np.random.rand(</span><span class="s4">1</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;5x1&quot;</span><span class="s2">,</span>
               <span class="s1">np.random.rand(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
               <span class="s1">np.random.rand(</span><span class="s4">5</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;0x4&quot;</span><span class="s2">,</span>
               <span class="s1">np.random.rand(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">,</span>
               <span class="s1">np.random.rand(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
               <span class="s1">tags={</span><span class="s5">'size-0'</span><span class="s1">})</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;4x0&quot;</span><span class="s2">,</span>
               <span class="s1">np.random.rand(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
               <span class="s1">np.random.rand(</span><span class="s4">4</span><span class="s1">)</span><span class="s2">,</span>
               <span class="s1">tags={</span><span class="s5">'size-0'</span><span class="s1">})</span><span class="s2">,</span>
<span class="s1">])</span>

<span class="s3"># hermitian test-cases</span>
<span class="s1">CASES += apply_tag(</span><span class="s5">'hermitian'</span><span class="s2">, </span><span class="s1">[</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;hsingle&quot;</span><span class="s2">,</span>
               <span class="s1">array([[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=single)</span><span class="s2">,</span>
               <span class="s2">None</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;hdouble&quot;</span><span class="s2">,</span>
               <span class="s1">array([[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=double)</span><span class="s2">,</span>
               <span class="s2">None</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;hcsingle&quot;</span><span class="s2">,</span>
               <span class="s1">array([[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">3j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">3j</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=csingle)</span><span class="s2">,</span>
               <span class="s2">None</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;hcdouble&quot;</span><span class="s2">,</span>
               <span class="s1">array([[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">3j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">3j</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=cdouble)</span><span class="s2">,</span>
               <span class="s2">None</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;hempty&quot;</span><span class="s2">,</span>
               <span class="s1">np.empty((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=double)</span><span class="s2">,</span>
               <span class="s2">None,</span>
               <span class="s1">tags={</span><span class="s5">'size-0'</span><span class="s1">})</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;hnonarray&quot;</span><span class="s2">,</span>
               <span class="s1">[[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">,</span>
               <span class="s2">None</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;matrix_b_only&quot;</span><span class="s2">,</span>
               <span class="s1">array([[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]])</span><span class="s2">,</span>
               <span class="s2">None</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">LinalgCase(</span><span class="s5">&quot;hmatrix_1x1&quot;</span><span class="s2">,</span>
               <span class="s1">np.random.rand(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
               <span class="s2">None</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">])</span>


<span class="s3">#</span>
<span class="s3"># Gufunc test cases</span>
<span class="s3">#</span>
<span class="s2">def </span><span class="s1">_make_generalized_cases():</span>
    <span class="s1">new_cases = []</span>

    <span class="s2">for </span><span class="s1">case </span><span class="s2">in </span><span class="s1">CASES:</span>
        <span class="s2">if not </span><span class="s1">isinstance(case.a</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s2">continue</span>

        <span class="s1">a = np.array([case.a</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">* case.a</span><span class="s2">, </span><span class="s4">3 </span><span class="s1">* case.a])</span>
        <span class="s2">if </span><span class="s1">case.b </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">b = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">b = np.array([case.b</span><span class="s2">, </span><span class="s4">7 </span><span class="s1">* case.b</span><span class="s2">, </span><span class="s4">6 </span><span class="s1">* case.b])</span>
        <span class="s1">new_case = LinalgCase(case.name + </span><span class="s5">&quot;_tile3&quot;</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">,</span>
                              <span class="s1">tags=case.tags | {</span><span class="s5">'generalized'</span><span class="s1">})</span>
        <span class="s1">new_cases.append(new_case)</span>

        <span class="s1">a = np.array([case.a] * </span><span class="s4">2 </span><span class="s1">* </span><span class="s4">3</span><span class="s1">).reshape((</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">) + case.a.shape)</span>
        <span class="s2">if </span><span class="s1">case.b </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">b = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">b = np.array([case.b] * </span><span class="s4">2 </span><span class="s1">* </span><span class="s4">3</span><span class="s1">).reshape((</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">) + case.b.shape)</span>
        <span class="s1">new_case = LinalgCase(case.name + </span><span class="s5">&quot;_tile213&quot;</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">,</span>
                              <span class="s1">tags=case.tags | {</span><span class="s5">'generalized'</span><span class="s1">})</span>
        <span class="s1">new_cases.append(new_case)</span>

    <span class="s2">return </span><span class="s1">new_cases</span>


<span class="s1">CASES += _make_generalized_cases()</span>


<span class="s3">#</span>
<span class="s3"># Generate stride combination variations of the above</span>
<span class="s3">#</span>
<span class="s2">def </span><span class="s1">_stride_comb_iter(x):</span>
    <span class="s0">&quot;&quot;&quot; 
    Generate cartesian product of strides for all axes 
    &quot;&quot;&quot;</span>

    <span class="s2">if not </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
        <span class="s2">yield </span><span class="s1">x</span><span class="s2">, </span><span class="s5">&quot;nop&quot;</span>
        <span class="s2">return</span>

    <span class="s1">stride_set = [(</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)] * x.ndim</span>
    <span class="s1">stride_set[-</span><span class="s4">1</span><span class="s1">] = (</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">x.ndim &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">stride_set[-</span><span class="s4">2</span><span class="s1">] = (</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">x.ndim &gt; </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s1">stride_set[-</span><span class="s4">3</span><span class="s1">] = (</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">repeats </span><span class="s2">in </span><span class="s1">itertools.product(*tuple(stride_set)):</span>
        <span class="s1">new_shape = [abs(a * b) </span><span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">zip(x.shape</span><span class="s2">, </span><span class="s1">repeats)]</span>
        <span class="s1">slices = tuple([slice(</span><span class="s2">None, None, </span><span class="s1">repeat) </span><span class="s2">for </span><span class="s1">repeat </span><span class="s2">in </span><span class="s1">repeats])</span>

        <span class="s3"># new array with different strides, but same data</span>
        <span class="s1">xi = np.empty(new_shape</span><span class="s2">, </span><span class="s1">dtype=x.dtype)</span>
        <span class="s1">xi.view(np.uint32).fill(</span><span class="s4">0xdeadbeef</span><span class="s1">)</span>
        <span class="s1">xi = xi[slices]</span>
        <span class="s1">xi[...] = x</span>
        <span class="s1">xi = xi.view(x.__class__)</span>
        <span class="s1">assert_(np.all(xi == x))</span>
        <span class="s2">yield </span><span class="s1">xi</span><span class="s2">, </span><span class="s5">&quot;stride_&quot; </span><span class="s1">+ </span><span class="s5">&quot;_&quot;</span><span class="s1">.join([</span><span class="s5">&quot;%+d&quot; </span><span class="s1">% j </span><span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">repeats])</span>

        <span class="s3"># generate also zero strides if possible</span>
        <span class="s2">if </span><span class="s1">x.ndim &gt;= </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">x.shape[-</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">s = list(x.strides)</span>
            <span class="s1">s[-</span><span class="s4">1</span><span class="s1">] = </span><span class="s4">0</span>
            <span class="s1">xi = np.lib.stride_tricks.as_strided(x</span><span class="s2">, </span><span class="s1">strides=s)</span>
            <span class="s2">yield </span><span class="s1">xi</span><span class="s2">, </span><span class="s5">&quot;stride_xxx_0&quot;</span>
        <span class="s2">if </span><span class="s1">x.ndim &gt;= </span><span class="s4">2 </span><span class="s2">and </span><span class="s1">x.shape[-</span><span class="s4">2</span><span class="s1">] == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">s = list(x.strides)</span>
            <span class="s1">s[-</span><span class="s4">2</span><span class="s1">] = </span><span class="s4">0</span>
            <span class="s1">xi = np.lib.stride_tricks.as_strided(x</span><span class="s2">, </span><span class="s1">strides=s)</span>
            <span class="s2">yield </span><span class="s1">xi</span><span class="s2">, </span><span class="s5">&quot;stride_xxx_0_x&quot;</span>
        <span class="s2">if </span><span class="s1">x.ndim &gt;= </span><span class="s4">2 </span><span class="s2">and </span><span class="s1">x.shape[:-</span><span class="s4">2</span><span class="s1">] == (</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">s = list(x.strides)</span>
            <span class="s1">s[-</span><span class="s4">1</span><span class="s1">] = </span><span class="s4">0</span>
            <span class="s1">s[-</span><span class="s4">2</span><span class="s1">] = </span><span class="s4">0</span>
            <span class="s1">xi = np.lib.stride_tricks.as_strided(x</span><span class="s2">, </span><span class="s1">strides=s)</span>
            <span class="s2">yield </span><span class="s1">xi</span><span class="s2">, </span><span class="s5">&quot;stride_xxx_0_0&quot;</span>


<span class="s2">def </span><span class="s1">_make_strided_cases():</span>
    <span class="s1">new_cases = []</span>
    <span class="s2">for </span><span class="s1">case </span><span class="s2">in </span><span class="s1">CASES:</span>
        <span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">a_label </span><span class="s2">in </span><span class="s1">_stride_comb_iter(case.a):</span>
            <span class="s2">for </span><span class="s1">b</span><span class="s2">, </span><span class="s1">b_label </span><span class="s2">in </span><span class="s1">_stride_comb_iter(case.b):</span>
                <span class="s1">new_case = LinalgCase(case.name + </span><span class="s5">&quot;_&quot; </span><span class="s1">+ a_label + </span><span class="s5">&quot;_&quot; </span><span class="s1">+ b_label</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">,</span>
                                      <span class="s1">tags=case.tags | {</span><span class="s5">'strided'</span><span class="s1">})</span>
                <span class="s1">new_cases.append(new_case)</span>
    <span class="s2">return </span><span class="s1">new_cases</span>


<span class="s1">CASES += _make_strided_cases()</span>


<span class="s3">#</span>
<span class="s3"># Test different routines against the above cases</span>
<span class="s3">#</span>
<span class="s2">class </span><span class="s1">LinalgTestCase:</span>
    <span class="s1">TEST_CASES = CASES</span>

    <span class="s2">def </span><span class="s1">check_cases(self</span><span class="s2">, </span><span class="s1">require=set()</span><span class="s2">, </span><span class="s1">exclude=set()):</span>
        <span class="s0">&quot;&quot;&quot; 
        Run func on each of the cases with all of the tags in require, and none 
        of the tags in exclude 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">case </span><span class="s2">in </span><span class="s1">self.TEST_CASES:</span>
            <span class="s3"># filter by require and exclude</span>
            <span class="s2">if </span><span class="s1">case.tags &amp; require != require:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">case.tags &amp; exclude:</span>
                <span class="s2">continue</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">case.check(self.do)</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s1">msg = </span><span class="s5">f'In test case: </span><span class="s2">{</span><span class="s1">case</span><span class="s2">!r}\n\n</span><span class="s5">'</span>
                <span class="s1">msg += traceback.format_exc()</span>
                <span class="s2">raise </span><span class="s1">AssertionError(msg) </span><span class="s2">from </span><span class="s1">e</span>


<span class="s2">class </span><span class="s1">LinalgSquareTestCase(LinalgTestCase):</span>

    <span class="s2">def </span><span class="s1">test_sq_cases(self):</span>
        <span class="s1">self.check_cases(require={</span><span class="s5">'square'</span><span class="s1">}</span><span class="s2">,</span>
                         <span class="s1">exclude={</span><span class="s5">'generalized'</span><span class="s2">, </span><span class="s5">'size-0'</span><span class="s1">})</span>

    <span class="s2">def </span><span class="s1">test_empty_sq_cases(self):</span>
        <span class="s1">self.check_cases(require={</span><span class="s5">'square'</span><span class="s2">, </span><span class="s5">'size-0'</span><span class="s1">}</span><span class="s2">,</span>
                         <span class="s1">exclude={</span><span class="s5">'generalized'</span><span class="s1">})</span>


<span class="s2">class </span><span class="s1">LinalgNonsquareTestCase(LinalgTestCase):</span>

    <span class="s2">def </span><span class="s1">test_nonsq_cases(self):</span>
        <span class="s1">self.check_cases(require={</span><span class="s5">'nonsquare'</span><span class="s1">}</span><span class="s2">,</span>
                         <span class="s1">exclude={</span><span class="s5">'generalized'</span><span class="s2">, </span><span class="s5">'size-0'</span><span class="s1">})</span>

    <span class="s2">def </span><span class="s1">test_empty_nonsq_cases(self):</span>
        <span class="s1">self.check_cases(require={</span><span class="s5">'nonsquare'</span><span class="s2">, </span><span class="s5">'size-0'</span><span class="s1">}</span><span class="s2">,</span>
                         <span class="s1">exclude={</span><span class="s5">'generalized'</span><span class="s1">})</span>


<span class="s2">class </span><span class="s1">HermitianTestCase(LinalgTestCase):</span>

    <span class="s2">def </span><span class="s1">test_herm_cases(self):</span>
        <span class="s1">self.check_cases(require={</span><span class="s5">'hermitian'</span><span class="s1">}</span><span class="s2">,</span>
                         <span class="s1">exclude={</span><span class="s5">'generalized'</span><span class="s2">, </span><span class="s5">'size-0'</span><span class="s1">})</span>

    <span class="s2">def </span><span class="s1">test_empty_herm_cases(self):</span>
        <span class="s1">self.check_cases(require={</span><span class="s5">'hermitian'</span><span class="s2">, </span><span class="s5">'size-0'</span><span class="s1">}</span><span class="s2">,</span>
                         <span class="s1">exclude={</span><span class="s5">'generalized'</span><span class="s1">})</span>


<span class="s2">class </span><span class="s1">LinalgGeneralizedSquareTestCase(LinalgTestCase):</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_generalized_sq_cases(self):</span>
        <span class="s1">self.check_cases(require={</span><span class="s5">'generalized'</span><span class="s2">, </span><span class="s5">'square'</span><span class="s1">}</span><span class="s2">,</span>
                         <span class="s1">exclude={</span><span class="s5">'size-0'</span><span class="s1">})</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_generalized_empty_sq_cases(self):</span>
        <span class="s1">self.check_cases(require={</span><span class="s5">'generalized'</span><span class="s2">, </span><span class="s5">'square'</span><span class="s2">, </span><span class="s5">'size-0'</span><span class="s1">})</span>


<span class="s2">class </span><span class="s1">LinalgGeneralizedNonsquareTestCase(LinalgTestCase):</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_generalized_nonsq_cases(self):</span>
        <span class="s1">self.check_cases(require={</span><span class="s5">'generalized'</span><span class="s2">, </span><span class="s5">'nonsquare'</span><span class="s1">}</span><span class="s2">,</span>
                         <span class="s1">exclude={</span><span class="s5">'size-0'</span><span class="s1">})</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_generalized_empty_nonsq_cases(self):</span>
        <span class="s1">self.check_cases(require={</span><span class="s5">'generalized'</span><span class="s2">, </span><span class="s5">'nonsquare'</span><span class="s2">, </span><span class="s5">'size-0'</span><span class="s1">})</span>


<span class="s2">class </span><span class="s1">HermitianGeneralizedTestCase(LinalgTestCase):</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_generalized_herm_cases(self):</span>
        <span class="s1">self.check_cases(require={</span><span class="s5">'generalized'</span><span class="s2">, </span><span class="s5">'hermitian'</span><span class="s1">}</span><span class="s2">,</span>
                         <span class="s1">exclude={</span><span class="s5">'size-0'</span><span class="s1">})</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_generalized_empty_herm_cases(self):</span>
        <span class="s1">self.check_cases(require={</span><span class="s5">'generalized'</span><span class="s2">, </span><span class="s5">'hermitian'</span><span class="s2">, </span><span class="s5">'size-0'</span><span class="s1">}</span><span class="s2">,</span>
                         <span class="s1">exclude={</span><span class="s5">'none'</span><span class="s1">})</span>


<span class="s2">def </span><span class="s1">dot_generalized(a</span><span class="s2">, </span><span class="s1">b):</span>
    <span class="s1">a = asarray(a)</span>
    <span class="s2">if </span><span class="s1">a.ndim &gt;= </span><span class="s4">3</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">a.ndim == b.ndim:</span>
            <span class="s3"># matrix x matrix</span>
            <span class="s1">new_shape = a.shape[:-</span><span class="s4">1</span><span class="s1">] + b.shape[-</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s2">elif </span><span class="s1">a.ndim == b.ndim + </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3"># matrix x vector</span>
            <span class="s1">new_shape = a.shape[:-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Not implemented...&quot;</span><span class="s1">)</span>
        <span class="s1">r = np.empty(new_shape</span><span class="s2">, </span><span class="s1">dtype=np.common_type(a</span><span class="s2">, </span><span class="s1">b))</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">itertools.product(*map(range</span><span class="s2">, </span><span class="s1">a.shape[:-</span><span class="s4">2</span><span class="s1">])):</span>
            <span class="s1">r[c] = dot(a[c]</span><span class="s2">, </span><span class="s1">b[c])</span>
        <span class="s2">return </span><span class="s1">r</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">dot(a</span><span class="s2">, </span><span class="s1">b)</span>


<span class="s2">def </span><span class="s1">identity_like_generalized(a):</span>
    <span class="s1">a = asarray(a)</span>
    <span class="s2">if </span><span class="s1">a.ndim &gt;= </span><span class="s4">3</span><span class="s1">:</span>
        <span class="s1">r = np.empty(a.shape</span><span class="s2">, </span><span class="s1">dtype=a.dtype)</span>
        <span class="s1">r[...] = identity(a.shape[-</span><span class="s4">2</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s1">r</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">identity(a.shape[</span><span class="s4">0</span><span class="s1">])</span>


<span class="s2">class </span><span class="s1">SolveCases(LinalgSquareTestCase</span><span class="s2">, </span><span class="s1">LinalgGeneralizedSquareTestCase):</span>
    <span class="s3"># kept apart from TestSolve for use for testing with matrices.</span>
    <span class="s2">def </span><span class="s1">do(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tags):</span>
        <span class="s1">x = linalg.solve(a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_almost_equal(b</span><span class="s2">, </span><span class="s1">dot_generalized(a</span><span class="s2">, </span><span class="s1">x))</span>
        <span class="s1">assert_(consistent_subclass(x</span><span class="s2">, </span><span class="s1">b))</span>


<span class="s2">class </span><span class="s1">TestSolve(SolveCases):</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'dtype'</span><span class="s2">, </span><span class="s1">[single</span><span class="s2">, </span><span class="s1">double</span><span class="s2">, </span><span class="s1">csingle</span><span class="s2">, </span><span class="s1">cdouble])</span>
    <span class="s2">def </span><span class="s1">test_types(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">x = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">assert_equal(linalg.solve(x</span><span class="s2">, </span><span class="s1">x).dtype</span><span class="s2">, </span><span class="s1">dtype)</span>

    <span class="s2">def </span><span class="s1">test_0_size(self):</span>
        <span class="s2">class </span><span class="s1">ArraySubclass(np.ndarray):</span>
            <span class="s2">pass</span>
        <span class="s3"># Test system of 0x0 matrices</span>
        <span class="s1">a = np.arange(</span><span class="s4">8</span><span class="s1">).reshape(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">b = np.arange(</span><span class="s4">6</span><span class="s1">).reshape(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">).view(ArraySubclass)</span>

        <span class="s1">expected = linalg.solve(a</span><span class="s2">, </span><span class="s1">b)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s1">result = linalg.solve(a[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">b[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s2">, </span><span class="s1">:])</span>
        <span class="s1">assert_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">assert_(isinstance(result</span><span class="s2">, </span><span class="s1">ArraySubclass))</span>

        <span class="s3"># Test errors for non-square and only b's dimension being 0</span>
        <span class="s1">assert_raises(linalg.LinAlgError</span><span class="s2">, </span><span class="s1">linalg.solve</span><span class="s2">, </span><span class="s1">a[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">linalg.solve</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s2">, </span><span class="s1">:])</span>

        <span class="s3"># Test broadcasting error</span>
        <span class="s1">b = np.arange(</span><span class="s4">6</span><span class="s1">).reshape(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)  </span><span class="s3"># broadcasting error</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">linalg.solve</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">linalg.solve</span><span class="s2">, </span><span class="s1">a[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">b[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s1">])</span>

        <span class="s3"># Test zero &quot;single equations&quot; with 0x0 matrices.</span>
        <span class="s1">b = np.arange(</span><span class="s4">2</span><span class="s1">).reshape(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">).view(ArraySubclass)</span>
        <span class="s1">expected = linalg.solve(a</span><span class="s2">, </span><span class="s1">b)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">result = linalg.solve(a[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">b[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">assert_(isinstance(result</span><span class="s2">, </span><span class="s1">ArraySubclass))</span>

        <span class="s1">b = np.arange(</span><span class="s4">3</span><span class="s1">).reshape(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">linalg.solve</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">linalg.solve</span><span class="s2">, </span><span class="s1">a[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">b[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">linalg.solve</span><span class="s2">, </span><span class="s1">a[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">b)</span>

    <span class="s2">def </span><span class="s1">test_0_size_k(self):</span>
        <span class="s3"># test zero multiple equation (K=0) case.</span>
        <span class="s2">class </span><span class="s1">ArraySubclass(np.ndarray):</span>
            <span class="s2">pass</span>
        <span class="s1">a = np.arange(</span><span class="s4">4</span><span class="s1">).reshape(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">b = np.arange(</span><span class="s4">6</span><span class="s1">).reshape(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">).view(ArraySubclass)</span>

        <span class="s1">expected = linalg.solve(a</span><span class="s2">, </span><span class="s1">b)[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">result = linalg.solve(a</span><span class="s2">, </span><span class="s1">b[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">assert_(isinstance(result</span><span class="s2">, </span><span class="s1">ArraySubclass))</span>

        <span class="s3"># test both zero.</span>
        <span class="s1">expected = linalg.solve(a</span><span class="s2">, </span><span class="s1">b)[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">result = linalg.solve(a[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">b[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">:</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">assert_(isinstance(result</span><span class="s2">, </span><span class="s1">ArraySubclass))</span>


<span class="s2">class </span><span class="s1">InvCases(LinalgSquareTestCase</span><span class="s2">, </span><span class="s1">LinalgGeneralizedSquareTestCase):</span>

    <span class="s2">def </span><span class="s1">do(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tags):</span>
        <span class="s1">a_inv = linalg.inv(a)</span>
        <span class="s1">assert_almost_equal(dot_generalized(a</span><span class="s2">, </span><span class="s1">a_inv)</span><span class="s2">,</span>
                            <span class="s1">identity_like_generalized(a))</span>
        <span class="s1">assert_(consistent_subclass(a_inv</span><span class="s2">, </span><span class="s1">a))</span>


<span class="s2">class </span><span class="s1">TestInv(InvCases):</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'dtype'</span><span class="s2">, </span><span class="s1">[single</span><span class="s2">, </span><span class="s1">double</span><span class="s2">, </span><span class="s1">csingle</span><span class="s2">, </span><span class="s1">cdouble])</span>
    <span class="s2">def </span><span class="s1">test_types(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">x = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">assert_equal(linalg.inv(x).dtype</span><span class="s2">, </span><span class="s1">dtype)</span>

    <span class="s2">def </span><span class="s1">test_0_size(self):</span>
        <span class="s3"># Check that all kinds of 0-sized arrays work</span>
        <span class="s2">class </span><span class="s1">ArraySubclass(np.ndarray):</span>
            <span class="s2">pass</span>
        <span class="s1">a = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.int_).view(ArraySubclass)</span>
        <span class="s1">res = linalg.inv(a)</span>
        <span class="s1">assert_(res.dtype.type </span><span class="s2">is </span><span class="s1">np.float64)</span>
        <span class="s1">assert_equal(a.shape</span><span class="s2">, </span><span class="s1">res.shape)</span>
        <span class="s1">assert_(isinstance(res</span><span class="s2">, </span><span class="s1">ArraySubclass))</span>

        <span class="s1">a = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.complex64).view(ArraySubclass)</span>
        <span class="s1">res = linalg.inv(a)</span>
        <span class="s1">assert_(res.dtype.type </span><span class="s2">is </span><span class="s1">np.complex64)</span>
        <span class="s1">assert_equal(a.shape</span><span class="s2">, </span><span class="s1">res.shape)</span>
        <span class="s1">assert_(isinstance(res</span><span class="s2">, </span><span class="s1">ArraySubclass))</span>


<span class="s2">class </span><span class="s1">EigvalsCases(LinalgSquareTestCase</span><span class="s2">, </span><span class="s1">LinalgGeneralizedSquareTestCase):</span>

    <span class="s2">def </span><span class="s1">do(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tags):</span>
        <span class="s1">ev = linalg.eigvals(a)</span>
        <span class="s1">evalues</span><span class="s2">, </span><span class="s1">evectors = linalg.eig(a)</span>
        <span class="s1">assert_almost_equal(ev</span><span class="s2">, </span><span class="s1">evalues)</span>


<span class="s2">class </span><span class="s1">TestEigvals(EigvalsCases):</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'dtype'</span><span class="s2">, </span><span class="s1">[single</span><span class="s2">, </span><span class="s1">double</span><span class="s2">, </span><span class="s1">csingle</span><span class="s2">, </span><span class="s1">cdouble])</span>
    <span class="s2">def </span><span class="s1">test_types(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">x = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">assert_equal(linalg.eigvals(x).dtype</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s1">x = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">assert_equal(linalg.eigvals(x).dtype</span><span class="s2">, </span><span class="s1">get_complex_dtype(dtype))</span>

    <span class="s2">def </span><span class="s1">test_0_size(self):</span>
        <span class="s3"># Check that all kinds of 0-sized arrays work</span>
        <span class="s2">class </span><span class="s1">ArraySubclass(np.ndarray):</span>
            <span class="s2">pass</span>
        <span class="s1">a = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.int_).view(ArraySubclass)</span>
        <span class="s1">res = linalg.eigvals(a)</span>
        <span class="s1">assert_(res.dtype.type </span><span class="s2">is </span><span class="s1">np.float64)</span>
        <span class="s1">assert_equal((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">res.shape)</span>
        <span class="s3"># This is just for documentation, it might make sense to change:</span>
        <span class="s1">assert_(isinstance(res</span><span class="s2">, </span><span class="s1">np.ndarray))</span>

        <span class="s1">a = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.complex64).view(ArraySubclass)</span>
        <span class="s1">res = linalg.eigvals(a)</span>
        <span class="s1">assert_(res.dtype.type </span><span class="s2">is </span><span class="s1">np.complex64)</span>
        <span class="s1">assert_equal((</span><span class="s4">0</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">res.shape)</span>
        <span class="s3"># This is just for documentation, it might make sense to change:</span>
        <span class="s1">assert_(isinstance(res</span><span class="s2">, </span><span class="s1">np.ndarray))</span>


<span class="s2">class </span><span class="s1">EigCases(LinalgSquareTestCase</span><span class="s2">, </span><span class="s1">LinalgGeneralizedSquareTestCase):</span>

    <span class="s2">def </span><span class="s1">do(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tags):</span>
        <span class="s1">evalues</span><span class="s2">, </span><span class="s1">evectors = linalg.eig(a)</span>
        <span class="s1">assert_allclose(dot_generalized(a</span><span class="s2">, </span><span class="s1">evectors)</span><span class="s2">,</span>
                        <span class="s1">np.asarray(evectors) * np.asarray(evalues)[...</span><span class="s2">, None, </span><span class="s1">:]</span><span class="s2">,</span>
                        <span class="s1">rtol=get_rtol(evalues.dtype))</span>
        <span class="s1">assert_(consistent_subclass(evectors</span><span class="s2">, </span><span class="s1">a))</span>


<span class="s2">class </span><span class="s1">TestEig(EigCases):</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'dtype'</span><span class="s2">, </span><span class="s1">[single</span><span class="s2">, </span><span class="s1">double</span><span class="s2">, </span><span class="s1">csingle</span><span class="s2">, </span><span class="s1">cdouble])</span>
    <span class="s2">def </span><span class="s1">test_types(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">x = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">v = np.linalg.eig(x)</span>
        <span class="s1">assert_equal(w.dtype</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s1">assert_equal(v.dtype</span><span class="s2">, </span><span class="s1">dtype)</span>

        <span class="s1">x = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">v = np.linalg.eig(x)</span>
        <span class="s1">assert_equal(w.dtype</span><span class="s2">, </span><span class="s1">get_complex_dtype(dtype))</span>
        <span class="s1">assert_equal(v.dtype</span><span class="s2">, </span><span class="s1">get_complex_dtype(dtype))</span>

    <span class="s2">def </span><span class="s1">test_0_size(self):</span>
        <span class="s3"># Check that all kinds of 0-sized arrays work</span>
        <span class="s2">class </span><span class="s1">ArraySubclass(np.ndarray):</span>
            <span class="s2">pass</span>
        <span class="s1">a = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.int_).view(ArraySubclass)</span>
        <span class="s1">res</span><span class="s2">, </span><span class="s1">res_v = linalg.eig(a)</span>
        <span class="s1">assert_(res_v.dtype.type </span><span class="s2">is </span><span class="s1">np.float64)</span>
        <span class="s1">assert_(res.dtype.type </span><span class="s2">is </span><span class="s1">np.float64)</span>
        <span class="s1">assert_equal(a.shape</span><span class="s2">, </span><span class="s1">res_v.shape)</span>
        <span class="s1">assert_equal((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">res.shape)</span>
        <span class="s3"># This is just for documentation, it might make sense to change:</span>
        <span class="s1">assert_(isinstance(a</span><span class="s2">, </span><span class="s1">np.ndarray))</span>

        <span class="s1">a = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.complex64).view(ArraySubclass)</span>
        <span class="s1">res</span><span class="s2">, </span><span class="s1">res_v = linalg.eig(a)</span>
        <span class="s1">assert_(res_v.dtype.type </span><span class="s2">is </span><span class="s1">np.complex64)</span>
        <span class="s1">assert_(res.dtype.type </span><span class="s2">is </span><span class="s1">np.complex64)</span>
        <span class="s1">assert_equal(a.shape</span><span class="s2">, </span><span class="s1">res_v.shape)</span>
        <span class="s1">assert_equal((</span><span class="s4">0</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">res.shape)</span>
        <span class="s3"># This is just for documentation, it might make sense to change:</span>
        <span class="s1">assert_(isinstance(a</span><span class="s2">, </span><span class="s1">np.ndarray))</span>


<span class="s2">class </span><span class="s1">SVDBaseTests:</span>
    <span class="s1">hermitian = </span><span class="s2">False</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'dtype'</span><span class="s2">, </span><span class="s1">[single</span><span class="s2">, </span><span class="s1">double</span><span class="s2">, </span><span class="s1">csingle</span><span class="s2">, </span><span class="s1">cdouble])</span>
    <span class="s2">def </span><span class="s1">test_types(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">x = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">u</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">vh = linalg.svd(x)</span>
        <span class="s1">assert_equal(u.dtype</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s1">assert_equal(s.dtype</span><span class="s2">, </span><span class="s1">get_real_dtype(dtype))</span>
        <span class="s1">assert_equal(vh.dtype</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s1">s = linalg.svd(x</span><span class="s2">, </span><span class="s1">compute_uv=</span><span class="s2">False, </span><span class="s1">hermitian=self.hermitian)</span>
        <span class="s1">assert_equal(s.dtype</span><span class="s2">, </span><span class="s1">get_real_dtype(dtype))</span>


<span class="s2">class </span><span class="s1">SVDCases(LinalgSquareTestCase</span><span class="s2">, </span><span class="s1">LinalgGeneralizedSquareTestCase):</span>

    <span class="s2">def </span><span class="s1">do(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tags):</span>
        <span class="s1">u</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">vt = linalg.svd(a</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">assert_allclose(a</span><span class="s2">, </span><span class="s1">dot_generalized(np.asarray(u) * np.asarray(s)[...</span><span class="s2">, None, </span><span class="s1">:]</span><span class="s2">,</span>
                                           <span class="s1">np.asarray(vt))</span><span class="s2">,</span>
                        <span class="s1">rtol=get_rtol(u.dtype))</span>
        <span class="s1">assert_(consistent_subclass(u</span><span class="s2">, </span><span class="s1">a))</span>
        <span class="s1">assert_(consistent_subclass(vt</span><span class="s2">, </span><span class="s1">a))</span>


<span class="s2">class </span><span class="s1">TestSVD(SVDCases</span><span class="s2">, </span><span class="s1">SVDBaseTests):</span>
    <span class="s2">def </span><span class="s1">test_empty_identity(self):</span>
        <span class="s0">&quot;&quot;&quot; Empty input should put an identity matrix in u or vh &quot;&quot;&quot;</span>
        <span class="s1">x = np.empty((</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">u</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">vh = linalg.svd(x</span><span class="s2">, </span><span class="s1">compute_uv=</span><span class="s2">True, </span><span class="s1">hermitian=self.hermitian)</span>
        <span class="s1">assert_equal(u.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">assert_equal(vh.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">assert_equal(u</span><span class="s2">, </span><span class="s1">np.eye(</span><span class="s4">4</span><span class="s1">))</span>

        <span class="s1">x = np.empty((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">u</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">vh = linalg.svd(x</span><span class="s2">, </span><span class="s1">compute_uv=</span><span class="s2">True, </span><span class="s1">hermitian=self.hermitian)</span>
        <span class="s1">assert_equal(u.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">assert_equal(vh.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">assert_equal(vh</span><span class="s2">, </span><span class="s1">np.eye(</span><span class="s4">4</span><span class="s1">))</span>


<span class="s2">class </span><span class="s1">SVDHermitianCases(HermitianTestCase</span><span class="s2">, </span><span class="s1">HermitianGeneralizedTestCase):</span>

    <span class="s2">def </span><span class="s1">do(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tags):</span>
        <span class="s1">u</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">vt = linalg.svd(a</span><span class="s2">, False, </span><span class="s1">hermitian=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">assert_allclose(a</span><span class="s2">, </span><span class="s1">dot_generalized(np.asarray(u) * np.asarray(s)[...</span><span class="s2">, None, </span><span class="s1">:]</span><span class="s2">,</span>
                                           <span class="s1">np.asarray(vt))</span><span class="s2">,</span>
                        <span class="s1">rtol=get_rtol(u.dtype))</span>
        <span class="s2">def </span><span class="s1">hermitian(mat):</span>
            <span class="s1">axes = list(range(mat.ndim))</span>
            <span class="s1">axes[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">axes[-</span><span class="s4">2</span><span class="s1">] = axes[-</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">axes[-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s2">return </span><span class="s1">np.conj(np.transpose(mat</span><span class="s2">, </span><span class="s1">axes=axes))</span>

        <span class="s1">assert_almost_equal(np.matmul(u</span><span class="s2">, </span><span class="s1">hermitian(u))</span><span class="s2">, </span><span class="s1">np.broadcast_to(np.eye(u.shape[-</span><span class="s4">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">u.shape))</span>
        <span class="s1">assert_almost_equal(np.matmul(vt</span><span class="s2">, </span><span class="s1">hermitian(vt))</span><span class="s2">, </span><span class="s1">np.broadcast_to(np.eye(vt.shape[-</span><span class="s4">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">vt.shape))</span>
        <span class="s1">assert_equal(np.sort(s)[...</span><span class="s2">, </span><span class="s1">::-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">s)</span>
        <span class="s1">assert_(consistent_subclass(u</span><span class="s2">, </span><span class="s1">a))</span>
        <span class="s1">assert_(consistent_subclass(vt</span><span class="s2">, </span><span class="s1">a))</span>


<span class="s2">class </span><span class="s1">TestSVDHermitian(SVDHermitianCases</span><span class="s2">, </span><span class="s1">SVDBaseTests):</span>
    <span class="s1">hermitian = </span><span class="s2">True</span>


<span class="s2">class </span><span class="s1">CondCases(LinalgSquareTestCase</span><span class="s2">, </span><span class="s1">LinalgGeneralizedSquareTestCase):</span>
    <span class="s3"># cond(x, p) for p in (None, 2, -2)</span>

    <span class="s2">def </span><span class="s1">do(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tags):</span>
        <span class="s1">c = asarray(a)  </span><span class="s3"># a might be a matrix</span>
        <span class="s2">if </span><span class="s5">'size-0' </span><span class="s2">in </span><span class="s1">tags:</span>
            <span class="s1">assert_raises(LinAlgError</span><span class="s2">, </span><span class="s1">linalg.cond</span><span class="s2">, </span><span class="s1">c)</span>
            <span class="s2">return</span>

        <span class="s3"># +-2 norms</span>
        <span class="s1">s = linalg.svd(c</span><span class="s2">, </span><span class="s1">compute_uv=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">linalg.cond(a)</span><span class="s2">, </span><span class="s1">s[...</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] / s[...</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">single_decimal=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">double_decimal=</span><span class="s4">11</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">linalg.cond(a</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">s[...</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] / s[...</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">single_decimal=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">double_decimal=</span><span class="s4">11</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">linalg.cond(a</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">s[...</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">] / s[...</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">single_decimal=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">double_decimal=</span><span class="s4">11</span><span class="s1">)</span>

        <span class="s3"># Other norms</span>
        <span class="s1">cinv = np.linalg.inv(c)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">linalg.cond(a</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">abs(c).sum(-</span><span class="s4">2</span><span class="s1">).max(-</span><span class="s4">1</span><span class="s1">) * abs(cinv).sum(-</span><span class="s4">2</span><span class="s1">).max(-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">single_decimal=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">double_decimal=</span><span class="s4">11</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">linalg.cond(a</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">abs(c).sum(-</span><span class="s4">2</span><span class="s1">).min(-</span><span class="s4">1</span><span class="s1">) * abs(cinv).sum(-</span><span class="s4">2</span><span class="s1">).min(-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">single_decimal=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">double_decimal=</span><span class="s4">11</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">linalg.cond(a</span><span class="s2">, </span><span class="s1">np.inf)</span><span class="s2">,</span>
            <span class="s1">abs(c).sum(-</span><span class="s4">1</span><span class="s1">).max(-</span><span class="s4">1</span><span class="s1">) * abs(cinv).sum(-</span><span class="s4">1</span><span class="s1">).max(-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">single_decimal=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">double_decimal=</span><span class="s4">11</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">linalg.cond(a</span><span class="s2">, </span><span class="s1">-np.inf)</span><span class="s2">,</span>
            <span class="s1">abs(c).sum(-</span><span class="s4">1</span><span class="s1">).min(-</span><span class="s4">1</span><span class="s1">) * abs(cinv).sum(-</span><span class="s4">1</span><span class="s1">).min(-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">single_decimal=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">double_decimal=</span><span class="s4">11</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">linalg.cond(a</span><span class="s2">, </span><span class="s5">'fro'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">np.sqrt((abs(c)**</span><span class="s4">2</span><span class="s1">).sum(-</span><span class="s4">1</span><span class="s1">).sum(-</span><span class="s4">1</span><span class="s1">)</span>
                    <span class="s1">* (abs(cinv)**</span><span class="s4">2</span><span class="s1">).sum(-</span><span class="s4">1</span><span class="s1">).sum(-</span><span class="s4">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">single_decimal=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">double_decimal=</span><span class="s4">11</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestCond(CondCases):</span>
    <span class="s2">def </span><span class="s1">test_basic_nonsvd(self):</span>
        <span class="s3"># Smoketest the non-svd norms</span>
        <span class="s1">A = array([[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3.</span><span class="s1">]])</span>
        <span class="s1">assert_almost_equal(linalg.cond(A</span><span class="s2">, </span><span class="s1">inf)</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(linalg.cond(A</span><span class="s2">, </span><span class="s1">-inf)</span><span class="s2">, </span><span class="s4">2</span><span class="s1">/</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(linalg.cond(A</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(linalg.cond(A</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(linalg.cond(A</span><span class="s2">, </span><span class="s5">'fro'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.sqrt(</span><span class="s4">265 </span><span class="s1">/ </span><span class="s4">12</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_singular(self):</span>
        <span class="s3"># Singular matrices have infinite condition number for</span>
        <span class="s3"># positive norms, and negative norms shouldn't raise</span>
        <span class="s3"># exceptions</span>
        <span class="s1">As = [np.zeros((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">np.ones((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))]</span>
        <span class="s1">p_pos = [</span><span class="s2">None, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s5">'fro'</span><span class="s1">]</span>
        <span class="s1">p_neg = [-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">A</span><span class="s2">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">itertools.product(As</span><span class="s2">, </span><span class="s1">p_pos):</span>
            <span class="s3"># Inversion may not hit exact infinity, so just check the</span>
            <span class="s3"># number is large</span>
            <span class="s1">assert_(linalg.cond(A</span><span class="s2">, </span><span class="s1">p) &gt; </span><span class="s4">1e15</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">A</span><span class="s2">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">itertools.product(As</span><span class="s2">, </span><span class="s1">p_neg):</span>
            <span class="s1">linalg.cond(A</span><span class="s2">, </span><span class="s1">p)</span>

    <span class="s1">@pytest.mark.xfail(</span><span class="s2">True, </span><span class="s1">run=</span><span class="s2">False,</span>
                       <span class="s1">reason=</span><span class="s5">&quot;Platform/LAPACK-dependent failure, &quot;</span>
                              <span class="s5">&quot;see gh-18914&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_nan(self):</span>
        <span class="s3"># nans should be passed through, not converted to infs</span>
        <span class="s1">ps = [</span><span class="s2">None, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s2">, </span><span class="s5">'fro'</span><span class="s1">]</span>
        <span class="s1">p_pos = [</span><span class="s2">None, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s5">'fro'</span><span class="s1">]</span>

        <span class="s1">A = np.ones((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">A[</span><span class="s4">0</span><span class="s2">,</span><span class="s4">1</span><span class="s1">] = np.nan</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">ps:</span>
            <span class="s1">c = linalg.cond(A</span><span class="s2">, </span><span class="s1">p)</span>
            <span class="s1">assert_(isinstance(c</span><span class="s2">, </span><span class="s1">np.float_))</span>
            <span class="s1">assert_(np.isnan(c))</span>

        <span class="s1">A = np.ones((</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">A[</span><span class="s4">1</span><span class="s2">,</span><span class="s4">0</span><span class="s2">,</span><span class="s4">1</span><span class="s1">] = np.nan</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">ps:</span>
            <span class="s1">c = linalg.cond(A</span><span class="s2">, </span><span class="s1">p)</span>
            <span class="s1">assert_(np.isnan(c[</span><span class="s4">1</span><span class="s1">]))</span>
            <span class="s2">if </span><span class="s1">p </span><span class="s2">in </span><span class="s1">p_pos:</span>
                <span class="s1">assert_(c[</span><span class="s4">0</span><span class="s1">] &gt; </span><span class="s4">1e15</span><span class="s1">)</span>
                <span class="s1">assert_(c[</span><span class="s4">2</span><span class="s1">] &gt; </span><span class="s4">1e15</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">assert_(</span><span class="s2">not </span><span class="s1">np.isnan(c[</span><span class="s4">0</span><span class="s1">]))</span>
                <span class="s1">assert_(</span><span class="s2">not </span><span class="s1">np.isnan(c[</span><span class="s4">2</span><span class="s1">]))</span>

    <span class="s2">def </span><span class="s1">test_stacked_singular(self):</span>
        <span class="s3"># Check behavior when only some of the stacked matrices are</span>
        <span class="s3"># singular</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>
        <span class="s1">A = np.random.rand(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">A[</span><span class="s4">0</span><span class="s2">,</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">0</span>
        <span class="s1">A[</span><span class="s4">1</span><span class="s2">,</span><span class="s4">1</span><span class="s1">] = </span><span class="s4">0</span>

        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">(</span><span class="s2">None, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s5">'fro'</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">):</span>
            <span class="s1">c = linalg.cond(A</span><span class="s2">, </span><span class="s1">p)</span>
            <span class="s1">assert_equal(c[</span><span class="s4">0</span><span class="s2">,</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.inf)</span>
            <span class="s1">assert_equal(c[</span><span class="s4">1</span><span class="s2">,</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.inf)</span>
            <span class="s1">assert_(np.isfinite(c[</span><span class="s4">0</span><span class="s2">,</span><span class="s4">1</span><span class="s1">]))</span>
            <span class="s1">assert_(np.isfinite(c[</span><span class="s4">1</span><span class="s2">,</span><span class="s4">0</span><span class="s1">]))</span>


<span class="s2">class </span><span class="s1">PinvCases(LinalgSquareTestCase</span><span class="s2">,</span>
                <span class="s1">LinalgNonsquareTestCase</span><span class="s2">,</span>
                <span class="s1">LinalgGeneralizedSquareTestCase</span><span class="s2">,</span>
                <span class="s1">LinalgGeneralizedNonsquareTestCase):</span>

    <span class="s2">def </span><span class="s1">do(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tags):</span>
        <span class="s1">a_ginv = linalg.pinv(a)</span>
        <span class="s3"># `a @ a_ginv == I` does not hold if a is singular</span>
        <span class="s1">dot = dot_generalized</span>
        <span class="s1">assert_almost_equal(dot(dot(a</span><span class="s2">, </span><span class="s1">a_ginv)</span><span class="s2">, </span><span class="s1">a)</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">single_decimal=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">double_decimal=</span><span class="s4">11</span><span class="s1">)</span>
        <span class="s1">assert_(consistent_subclass(a_ginv</span><span class="s2">, </span><span class="s1">a))</span>


<span class="s2">class </span><span class="s1">TestPinv(PinvCases):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">PinvHermitianCases(HermitianTestCase</span><span class="s2">, </span><span class="s1">HermitianGeneralizedTestCase):</span>

    <span class="s2">def </span><span class="s1">do(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tags):</span>
        <span class="s1">a_ginv = linalg.pinv(a</span><span class="s2">, </span><span class="s1">hermitian=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s3"># `a @ a_ginv == I` does not hold if a is singular</span>
        <span class="s1">dot = dot_generalized</span>
        <span class="s1">assert_almost_equal(dot(dot(a</span><span class="s2">, </span><span class="s1">a_ginv)</span><span class="s2">, </span><span class="s1">a)</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">single_decimal=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">double_decimal=</span><span class="s4">11</span><span class="s1">)</span>
        <span class="s1">assert_(consistent_subclass(a_ginv</span><span class="s2">, </span><span class="s1">a))</span>


<span class="s2">class </span><span class="s1">TestPinvHermitian(PinvHermitianCases):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">DetCases(LinalgSquareTestCase</span><span class="s2">, </span><span class="s1">LinalgGeneralizedSquareTestCase):</span>

    <span class="s2">def </span><span class="s1">do(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tags):</span>
        <span class="s1">d = linalg.det(a)</span>
        <span class="s1">(s</span><span class="s2">, </span><span class="s1">ld) = linalg.slogdet(a)</span>
        <span class="s2">if </span><span class="s1">asarray(a).dtype.type </span><span class="s2">in </span><span class="s1">(single</span><span class="s2">, </span><span class="s1">double):</span>
            <span class="s1">ad = asarray(a).astype(double)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ad = asarray(a).astype(cdouble)</span>
        <span class="s1">ev = linalg.eigvals(ad)</span>
        <span class="s1">assert_almost_equal(d</span><span class="s2">, </span><span class="s1">multiply.reduce(ev</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">assert_almost_equal(s * np.exp(ld)</span><span class="s2">, </span><span class="s1">multiply.reduce(ev</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s1">))</span>

        <span class="s1">s = np.atleast_1d(s)</span>
        <span class="s1">ld = np.atleast_1d(ld)</span>
        <span class="s1">m = (s != </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(np.abs(s[m])</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(ld[~m]</span><span class="s2">, </span><span class="s1">-inf)</span>


<span class="s2">class </span><span class="s1">TestDet(DetCases):</span>
    <span class="s2">def </span><span class="s1">test_zero(self):</span>
        <span class="s1">assert_equal(linalg.det([[</span><span class="s4">0.0</span><span class="s1">]])</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(type(linalg.det([[</span><span class="s4">0.0</span><span class="s1">]]))</span><span class="s2">, </span><span class="s1">double)</span>
        <span class="s1">assert_equal(linalg.det([[</span><span class="s4">0.0j</span><span class="s1">]])</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(type(linalg.det([[</span><span class="s4">0.0j</span><span class="s1">]]))</span><span class="s2">, </span><span class="s1">cdouble)</span>

        <span class="s1">assert_equal(linalg.slogdet([[</span><span class="s4">0.0</span><span class="s1">]])</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">-inf))</span>
        <span class="s1">assert_equal(type(linalg.slogdet([[</span><span class="s4">0.0</span><span class="s1">]])[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">double)</span>
        <span class="s1">assert_equal(type(linalg.slogdet([[</span><span class="s4">0.0</span><span class="s1">]])[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">double)</span>
        <span class="s1">assert_equal(linalg.slogdet([[</span><span class="s4">0.0j</span><span class="s1">]])</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.0j</span><span class="s2">, </span><span class="s1">-inf))</span>
        <span class="s1">assert_equal(type(linalg.slogdet([[</span><span class="s4">0.0j</span><span class="s1">]])[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">cdouble)</span>
        <span class="s1">assert_equal(type(linalg.slogdet([[</span><span class="s4">0.0j</span><span class="s1">]])[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">double)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'dtype'</span><span class="s2">, </span><span class="s1">[single</span><span class="s2">, </span><span class="s1">double</span><span class="s2">, </span><span class="s1">csingle</span><span class="s2">, </span><span class="s1">cdouble])</span>
    <span class="s2">def </span><span class="s1">test_types(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">x = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">assert_equal(np.linalg.det(x).dtype</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s1">ph</span><span class="s2">, </span><span class="s1">s = np.linalg.slogdet(x)</span>
        <span class="s1">assert_equal(s.dtype</span><span class="s2">, </span><span class="s1">get_real_dtype(dtype))</span>
        <span class="s1">assert_equal(ph.dtype</span><span class="s2">, </span><span class="s1">dtype)</span>

    <span class="s2">def </span><span class="s1">test_0_size(self):</span>
        <span class="s1">a = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.complex64)</span>
        <span class="s1">res = linalg.det(a)</span>
        <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">)</span>
        <span class="s1">assert_(res.dtype.type </span><span class="s2">is </span><span class="s1">np.complex64)</span>
        <span class="s1">res = linalg.slogdet(a)</span>
        <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">assert_(res[</span><span class="s4">0</span><span class="s1">].dtype.type </span><span class="s2">is </span><span class="s1">np.complex64)</span>
        <span class="s1">assert_(res[</span><span class="s4">1</span><span class="s1">].dtype.type </span><span class="s2">is </span><span class="s1">np.float32)</span>

        <span class="s1">a = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">res = linalg.det(a)</span>
        <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">)</span>
        <span class="s1">assert_(res.dtype.type </span><span class="s2">is </span><span class="s1">np.float64)</span>
        <span class="s1">res = linalg.slogdet(a)</span>
        <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">assert_(res[</span><span class="s4">0</span><span class="s1">].dtype.type </span><span class="s2">is </span><span class="s1">np.float64)</span>
        <span class="s1">assert_(res[</span><span class="s4">1</span><span class="s1">].dtype.type </span><span class="s2">is </span><span class="s1">np.float64)</span>


<span class="s2">class </span><span class="s1">LstsqCases(LinalgSquareTestCase</span><span class="s2">, </span><span class="s1">LinalgNonsquareTestCase):</span>

    <span class="s2">def </span><span class="s1">do(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tags):</span>
        <span class="s1">arr = np.asarray(a)</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">n = arr.shape</span>
        <span class="s1">u</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">vt = linalg.svd(a</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">residuals</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">, </span><span class="s1">sv = linalg.lstsq(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">rcond=-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">m == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">assert_((x == </span><span class="s4">0</span><span class="s1">).all())</span>
        <span class="s2">if </span><span class="s1">m &lt;= n:</span>
            <span class="s1">assert_almost_equal(b</span><span class="s2">, </span><span class="s1">dot(a</span><span class="s2">, </span><span class="s1">x))</span>
            <span class="s1">assert_equal(rank</span><span class="s2">, </span><span class="s1">m)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assert_equal(rank</span><span class="s2">, </span><span class="s1">n)</span>
        <span class="s1">assert_almost_equal(sv</span><span class="s2">, </span><span class="s1">sv.__array_wrap__(s))</span>
        <span class="s2">if </span><span class="s1">rank == n </span><span class="s2">and </span><span class="s1">m &gt; n:</span>
            <span class="s1">expect_resids = (</span>
                <span class="s1">np.asarray(abs(np.dot(a</span><span class="s2">, </span><span class="s1">x) - b)) ** </span><span class="s4">2</span><span class="s1">).sum(axis=</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">expect_resids = np.asarray(expect_resids)</span>
            <span class="s2">if </span><span class="s1">np.asarray(b).ndim == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">expect_resids.shape = (</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span>
                <span class="s1">assert_equal(residuals.shape</span><span class="s2">, </span><span class="s1">expect_resids.shape)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">expect_resids = np.array([]).view(type(x))</span>
        <span class="s1">assert_almost_equal(residuals</span><span class="s2">, </span><span class="s1">expect_resids)</span>
        <span class="s1">assert_(np.issubdtype(residuals.dtype</span><span class="s2">, </span><span class="s1">np.floating))</span>
        <span class="s1">assert_(consistent_subclass(x</span><span class="s2">, </span><span class="s1">b))</span>
        <span class="s1">assert_(consistent_subclass(residuals</span><span class="s2">, </span><span class="s1">b))</span>


<span class="s2">class </span><span class="s1">TestLstsq(LstsqCases):</span>
    <span class="s2">def </span><span class="s1">test_future_rcond(self):</span>
        <span class="s1">a = np.array([[</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">1.</span><span class="s2">,  </span><span class="s4">2.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">1.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">1.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">4.</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">2.</span><span class="s2">,  </span><span class="s4">3.</span><span class="s2">,  </span><span class="s4">0.</span><span class="s1">]]).T</span>

        <span class="s1">b = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">w = sup.record(FutureWarning</span><span class="s2">, </span><span class="s5">&quot;`rcond` parameter will change&quot;</span><span class="s1">)</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">residuals</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">, </span><span class="s1">s = linalg.lstsq(a</span><span class="s2">, </span><span class="s1">b)</span>
            <span class="s1">assert_(rank == </span><span class="s4">4</span><span class="s1">)</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">residuals</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">, </span><span class="s1">s = linalg.lstsq(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">rcond=-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">assert_(rank == </span><span class="s4">4</span><span class="s1">)</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">residuals</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">, </span><span class="s1">s = linalg.lstsq(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">rcond=</span><span class="s2">None</span><span class="s1">)</span>
            <span class="s1">assert_(rank == </span><span class="s4">3</span><span class="s1">)</span>
            <span class="s3"># Warning should be raised exactly once (first command)</span>
            <span class="s1">assert_(len(w) == </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize([</span><span class="s5">&quot;m&quot;</span><span class="s2">, </span><span class="s5">&quot;n&quot;</span><span class="s2">, </span><span class="s5">&quot;n_rhs&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span>
        <span class="s1">(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_empty_a_b(self</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">n_rhs):</span>
        <span class="s1">a = np.arange(m * n).reshape(m</span><span class="s2">, </span><span class="s1">n)</span>
        <span class="s1">b = np.ones((m</span><span class="s2">, </span><span class="s1">n_rhs))</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">residuals</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">, </span><span class="s1">s = linalg.lstsq(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">rcond=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">m == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">assert_((x == </span><span class="s4">0</span><span class="s1">).all())</span>
        <span class="s1">assert_equal(x.shape</span><span class="s2">, </span><span class="s1">(n</span><span class="s2">, </span><span class="s1">n_rhs))</span>
        <span class="s1">assert_equal(residuals.shape</span><span class="s2">, </span><span class="s1">((n_rhs</span><span class="s2">,</span><span class="s1">) </span><span class="s2">if </span><span class="s1">m &gt; n </span><span class="s2">else </span><span class="s1">(</span><span class="s4">0</span><span class="s2">,</span><span class="s1">)))</span>
        <span class="s2">if </span><span class="s1">m &gt; n </span><span class="s2">and </span><span class="s1">n_rhs &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3"># residuals are exactly the squared norms of b's columns</span>
            <span class="s1">r = b - np.dot(a</span><span class="s2">, </span><span class="s1">x)</span>
            <span class="s1">assert_almost_equal(residuals</span><span class="s2">, </span><span class="s1">(r * r).sum(axis=-</span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">assert_equal(rank</span><span class="s2">, </span><span class="s1">min(m</span><span class="s2">, </span><span class="s1">n))</span>
        <span class="s1">assert_equal(s.shape</span><span class="s2">, </span><span class="s1">(min(m</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_incompatible_dims(self):</span>
        <span class="s3"># use modified version of docstring example</span>
        <span class="s1">x = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">y = np.array([-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">2.1</span><span class="s2">, </span><span class="s4">3.3</span><span class="s1">])</span>
        <span class="s1">A = np.vstack([x</span><span class="s2">, </span><span class="s1">np.ones(len(x))]).T</span>
        <span class="s2">with </span><span class="s1">assert_raises_regex(LinAlgError</span><span class="s2">, </span><span class="s5">&quot;Incompatible dimensions&quot;</span><span class="s1">):</span>
            <span class="s1">linalg.lstsq(A</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">rcond=</span><span class="s2">None</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">'dt'</span><span class="s2">, </span><span class="s1">[np.dtype(c) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s5">'?bBhHiIqQefdgFDGO'</span><span class="s1">])</span>
<span class="s2">class </span><span class="s1">TestMatrixPower:</span>

    <span class="s1">rshft_0 = np.eye(</span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">rshft_1 = rshft_0[[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]]</span>
    <span class="s1">rshft_2 = rshft_0[[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span>
    <span class="s1">rshft_3 = rshft_0[[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span>
    <span class="s1">rshft_all = [rshft_0</span><span class="s2">, </span><span class="s1">rshft_1</span><span class="s2">, </span><span class="s1">rshft_2</span><span class="s2">, </span><span class="s1">rshft_3]</span>
    <span class="s1">noninv = array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]])</span>
    <span class="s1">stacked = np.block([[[rshft_0]]]*</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s3">#FIXME the 'e' dtype might work in future</span>
    <span class="s1">dtnoinv = [object</span><span class="s2">, </span><span class="s1">np.dtype(</span><span class="s5">'e'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.dtype(</span><span class="s5">'g'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.dtype(</span><span class="s5">'G'</span><span class="s1">)]</span>

    <span class="s2">def </span><span class="s1">test_large_power(self</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s1">rshft = self.rshft_1.astype(dt)</span>
        <span class="s1">assert_equal(</span>
            <span class="s1">matrix_power(rshft</span><span class="s2">, </span><span class="s4">2</span><span class="s1">**</span><span class="s4">100 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">**</span><span class="s4">10 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">**</span><span class="s4">5 </span><span class="s1">+ </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">self.rshft_0)</span>
        <span class="s1">assert_equal(</span>
            <span class="s1">matrix_power(rshft</span><span class="s2">, </span><span class="s4">2</span><span class="s1">**</span><span class="s4">100 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">**</span><span class="s4">10 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">**</span><span class="s4">5 </span><span class="s1">+ </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">self.rshft_1)</span>
        <span class="s1">assert_equal(</span>
            <span class="s1">matrix_power(rshft</span><span class="s2">, </span><span class="s4">2</span><span class="s1">**</span><span class="s4">100 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">**</span><span class="s4">10 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">**</span><span class="s4">5 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">self.rshft_2)</span>
        <span class="s1">assert_equal(</span>
            <span class="s1">matrix_power(rshft</span><span class="s2">, </span><span class="s4">2</span><span class="s1">**</span><span class="s4">100 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">**</span><span class="s4">10 </span><span class="s1">+ </span><span class="s4">2</span><span class="s1">**</span><span class="s4">5 </span><span class="s1">+ </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">self.rshft_3)</span>

    <span class="s2">def </span><span class="s1">test_power_is_zero(self</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s2">def </span><span class="s1">tz(M):</span>
            <span class="s1">mz = matrix_power(M</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">assert_equal(mz</span><span class="s2">, </span><span class="s1">identity_like_generalized(M))</span>
            <span class="s1">assert_equal(mz.dtype</span><span class="s2">, </span><span class="s1">M.dtype)</span>

        <span class="s2">for </span><span class="s1">mat </span><span class="s2">in </span><span class="s1">self.rshft_all:</span>
            <span class="s1">tz(mat.astype(dt))</span>
            <span class="s2">if </span><span class="s1">dt != object:</span>
                <span class="s1">tz(self.stacked.astype(dt))</span>

    <span class="s2">def </span><span class="s1">test_power_is_one(self</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s2">def </span><span class="s1">tz(mat):</span>
            <span class="s1">mz = matrix_power(mat</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">assert_equal(mz</span><span class="s2">, </span><span class="s1">mat)</span>
            <span class="s1">assert_equal(mz.dtype</span><span class="s2">, </span><span class="s1">mat.dtype)</span>

        <span class="s2">for </span><span class="s1">mat </span><span class="s2">in </span><span class="s1">self.rshft_all:</span>
            <span class="s1">tz(mat.astype(dt))</span>
            <span class="s2">if </span><span class="s1">dt != object:</span>
                <span class="s1">tz(self.stacked.astype(dt))</span>

    <span class="s2">def </span><span class="s1">test_power_is_two(self</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s2">def </span><span class="s1">tz(mat):</span>
            <span class="s1">mz = matrix_power(mat</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">mmul = matmul </span><span class="s2">if </span><span class="s1">mat.dtype != object </span><span class="s2">else </span><span class="s1">dot</span>
            <span class="s1">assert_equal(mz</span><span class="s2">, </span><span class="s1">mmul(mat</span><span class="s2">, </span><span class="s1">mat))</span>
            <span class="s1">assert_equal(mz.dtype</span><span class="s2">, </span><span class="s1">mat.dtype)</span>

        <span class="s2">for </span><span class="s1">mat </span><span class="s2">in </span><span class="s1">self.rshft_all:</span>
            <span class="s1">tz(mat.astype(dt))</span>
            <span class="s2">if </span><span class="s1">dt != object:</span>
                <span class="s1">tz(self.stacked.astype(dt))</span>

    <span class="s2">def </span><span class="s1">test_power_is_minus_one(self</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s2">def </span><span class="s1">tz(mat):</span>
            <span class="s1">invmat = matrix_power(mat</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">mmul = matmul </span><span class="s2">if </span><span class="s1">mat.dtype != object </span><span class="s2">else </span><span class="s1">dot</span>
            <span class="s1">assert_almost_equal(</span>
                <span class="s1">mmul(invmat</span><span class="s2">, </span><span class="s1">mat)</span><span class="s2">, </span><span class="s1">identity_like_generalized(mat))</span>

        <span class="s2">for </span><span class="s1">mat </span><span class="s2">in </span><span class="s1">self.rshft_all:</span>
            <span class="s2">if </span><span class="s1">dt </span><span class="s2">not in </span><span class="s1">self.dtnoinv:</span>
                <span class="s1">tz(mat.astype(dt))</span>

    <span class="s2">def </span><span class="s1">test_exceptions_bad_power(self</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s1">mat = self.rshft_0.astype(dt)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">matrix_power</span><span class="s2">, </span><span class="s1">mat</span><span class="s2">, </span><span class="s4">1.5</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">matrix_power</span><span class="s2">, </span><span class="s1">mat</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_exceptions_non_square(self</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s1">assert_raises(LinAlgError</span><span class="s2">, </span><span class="s1">matrix_power</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dt)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_raises(LinAlgError</span><span class="s2">, </span><span class="s1">matrix_power</span><span class="s2">, </span><span class="s1">np.array([[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dt)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_raises(LinAlgError</span><span class="s2">, </span><span class="s1">matrix_power</span><span class="s2">, </span><span class="s1">np.ones((</span><span class="s4">4</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dt)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_exceptions_not_invertible(self</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s2">if </span><span class="s1">dt </span><span class="s2">in </span><span class="s1">self.dtnoinv:</span>
            <span class="s2">return</span>
        <span class="s1">mat = self.noninv.astype(dt)</span>
        <span class="s1">assert_raises(LinAlgError</span><span class="s2">, </span><span class="s1">matrix_power</span><span class="s2">, </span><span class="s1">mat</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestEigvalshCases(HermitianTestCase</span><span class="s2">, </span><span class="s1">HermitianGeneralizedTestCase):</span>

    <span class="s2">def </span><span class="s1">do(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tags):</span>
        <span class="s3"># note that eigenvalue arrays returned by eig must be sorted since</span>
        <span class="s3"># their order isn't guaranteed.</span>
        <span class="s1">ev = linalg.eigvalsh(a</span><span class="s2">, </span><span class="s5">'L'</span><span class="s1">)</span>
        <span class="s1">evalues</span><span class="s2">, </span><span class="s1">evectors = linalg.eig(a)</span>
        <span class="s1">evalues.sort(axis=-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(ev</span><span class="s2">, </span><span class="s1">evalues</span><span class="s2">, </span><span class="s1">rtol=get_rtol(ev.dtype))</span>

        <span class="s1">ev2 = linalg.eigvalsh(a</span><span class="s2">, </span><span class="s5">'U'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(ev2</span><span class="s2">, </span><span class="s1">evalues</span><span class="s2">, </span><span class="s1">rtol=get_rtol(ev.dtype))</span>


<span class="s2">class </span><span class="s1">TestEigvalsh:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'dtype'</span><span class="s2">, </span><span class="s1">[single</span><span class="s2">, </span><span class="s1">double</span><span class="s2">, </span><span class="s1">csingle</span><span class="s2">, </span><span class="s1">cdouble])</span>
    <span class="s2">def </span><span class="s1">test_types(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">x = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">w = np.linalg.eigvalsh(x)</span>
        <span class="s1">assert_equal(w.dtype</span><span class="s2">, </span><span class="s1">get_real_dtype(dtype))</span>

    <span class="s2">def </span><span class="s1">test_invalid(self):</span>
        <span class="s1">x = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.float32)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">np.linalg.eigvalsh</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">UPLO=</span><span class="s5">&quot;lrong&quot;</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">np.linalg.eigvalsh</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s5">&quot;lower&quot;</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">np.linalg.eigvalsh</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s5">&quot;upper&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_UPLO(self):</span>
        <span class="s1">Klo = np.array([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">Kup = np.array([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">tgt = np.array([-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">rtol = get_rtol(np.double)</span>

        <span class="s3"># Check default is 'L'</span>
        <span class="s1">w = np.linalg.eigvalsh(Klo)</span>
        <span class="s1">assert_allclose(w</span><span class="s2">, </span><span class="s1">tgt</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s3"># Check 'L'</span>
        <span class="s1">w = np.linalg.eigvalsh(Klo</span><span class="s2">, </span><span class="s1">UPLO=</span><span class="s5">'L'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(w</span><span class="s2">, </span><span class="s1">tgt</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s3"># Check 'l'</span>
        <span class="s1">w = np.linalg.eigvalsh(Klo</span><span class="s2">, </span><span class="s1">UPLO=</span><span class="s5">'l'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(w</span><span class="s2">, </span><span class="s1">tgt</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s3"># Check 'U'</span>
        <span class="s1">w = np.linalg.eigvalsh(Kup</span><span class="s2">, </span><span class="s1">UPLO=</span><span class="s5">'U'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(w</span><span class="s2">, </span><span class="s1">tgt</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s3"># Check 'u'</span>
        <span class="s1">w = np.linalg.eigvalsh(Kup</span><span class="s2">, </span><span class="s1">UPLO=</span><span class="s5">'u'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(w</span><span class="s2">, </span><span class="s1">tgt</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>

    <span class="s2">def </span><span class="s1">test_0_size(self):</span>
        <span class="s3"># Check that all kinds of 0-sized arrays work</span>
        <span class="s2">class </span><span class="s1">ArraySubclass(np.ndarray):</span>
            <span class="s2">pass</span>
        <span class="s1">a = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.int_).view(ArraySubclass)</span>
        <span class="s1">res = linalg.eigvalsh(a)</span>
        <span class="s1">assert_(res.dtype.type </span><span class="s2">is </span><span class="s1">np.float64)</span>
        <span class="s1">assert_equal((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">res.shape)</span>
        <span class="s3"># This is just for documentation, it might make sense to change:</span>
        <span class="s1">assert_(isinstance(res</span><span class="s2">, </span><span class="s1">np.ndarray))</span>

        <span class="s1">a = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.complex64).view(ArraySubclass)</span>
        <span class="s1">res = linalg.eigvalsh(a)</span>
        <span class="s1">assert_(res.dtype.type </span><span class="s2">is </span><span class="s1">np.float32)</span>
        <span class="s1">assert_equal((</span><span class="s4">0</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">res.shape)</span>
        <span class="s3"># This is just for documentation, it might make sense to change:</span>
        <span class="s1">assert_(isinstance(res</span><span class="s2">, </span><span class="s1">np.ndarray))</span>


<span class="s2">class </span><span class="s1">TestEighCases(HermitianTestCase</span><span class="s2">, </span><span class="s1">HermitianGeneralizedTestCase):</span>

    <span class="s2">def </span><span class="s1">do(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tags):</span>
        <span class="s3"># note that eigenvalue arrays returned by eig must be sorted since</span>
        <span class="s3"># their order isn't guaranteed.</span>
        <span class="s1">ev</span><span class="s2">, </span><span class="s1">evc = linalg.eigh(a)</span>
        <span class="s1">evalues</span><span class="s2">, </span><span class="s1">evectors = linalg.eig(a)</span>
        <span class="s1">evalues.sort(axis=-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(ev</span><span class="s2">, </span><span class="s1">evalues)</span>

        <span class="s1">assert_allclose(dot_generalized(a</span><span class="s2">, </span><span class="s1">evc)</span><span class="s2">,</span>
                        <span class="s1">np.asarray(ev)[...</span><span class="s2">, None, </span><span class="s1">:] * np.asarray(evc)</span><span class="s2">,</span>
                        <span class="s1">rtol=get_rtol(ev.dtype))</span>

        <span class="s1">ev2</span><span class="s2">, </span><span class="s1">evc2 = linalg.eigh(a</span><span class="s2">, </span><span class="s5">'U'</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(ev2</span><span class="s2">, </span><span class="s1">evalues)</span>

        <span class="s1">assert_allclose(dot_generalized(a</span><span class="s2">, </span><span class="s1">evc2)</span><span class="s2">,</span>
                        <span class="s1">np.asarray(ev2)[...</span><span class="s2">, None, </span><span class="s1">:] * np.asarray(evc2)</span><span class="s2">,</span>
                        <span class="s1">rtol=get_rtol(ev.dtype)</span><span class="s2">, </span><span class="s1">err_msg=repr(a))</span>


<span class="s2">class </span><span class="s1">TestEigh:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'dtype'</span><span class="s2">, </span><span class="s1">[single</span><span class="s2">, </span><span class="s1">double</span><span class="s2">, </span><span class="s1">csingle</span><span class="s2">, </span><span class="s1">cdouble])</span>
    <span class="s2">def </span><span class="s1">test_types(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">x = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">v = np.linalg.eigh(x)</span>
        <span class="s1">assert_equal(w.dtype</span><span class="s2">, </span><span class="s1">get_real_dtype(dtype))</span>
        <span class="s1">assert_equal(v.dtype</span><span class="s2">, </span><span class="s1">dtype)</span>

    <span class="s2">def </span><span class="s1">test_invalid(self):</span>
        <span class="s1">x = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.float32)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">np.linalg.eigh</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">UPLO=</span><span class="s5">&quot;lrong&quot;</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">np.linalg.eigh</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s5">&quot;lower&quot;</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">np.linalg.eigh</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s5">&quot;upper&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_UPLO(self):</span>
        <span class="s1">Klo = np.array([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">Kup = np.array([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">tgt = np.array([-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">rtol = get_rtol(np.double)</span>

        <span class="s3"># Check default is 'L'</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">v = np.linalg.eigh(Klo)</span>
        <span class="s1">assert_allclose(w</span><span class="s2">, </span><span class="s1">tgt</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s3"># Check 'L'</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">v = np.linalg.eigh(Klo</span><span class="s2">, </span><span class="s1">UPLO=</span><span class="s5">'L'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(w</span><span class="s2">, </span><span class="s1">tgt</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s3"># Check 'l'</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">v = np.linalg.eigh(Klo</span><span class="s2">, </span><span class="s1">UPLO=</span><span class="s5">'l'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(w</span><span class="s2">, </span><span class="s1">tgt</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s3"># Check 'U'</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">v = np.linalg.eigh(Kup</span><span class="s2">, </span><span class="s1">UPLO=</span><span class="s5">'U'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(w</span><span class="s2">, </span><span class="s1">tgt</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s3"># Check 'u'</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">v = np.linalg.eigh(Kup</span><span class="s2">, </span><span class="s1">UPLO=</span><span class="s5">'u'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(w</span><span class="s2">, </span><span class="s1">tgt</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>

    <span class="s2">def </span><span class="s1">test_0_size(self):</span>
        <span class="s3"># Check that all kinds of 0-sized arrays work</span>
        <span class="s2">class </span><span class="s1">ArraySubclass(np.ndarray):</span>
            <span class="s2">pass</span>
        <span class="s1">a = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.int_).view(ArraySubclass)</span>
        <span class="s1">res</span><span class="s2">, </span><span class="s1">res_v = linalg.eigh(a)</span>
        <span class="s1">assert_(res_v.dtype.type </span><span class="s2">is </span><span class="s1">np.float64)</span>
        <span class="s1">assert_(res.dtype.type </span><span class="s2">is </span><span class="s1">np.float64)</span>
        <span class="s1">assert_equal(a.shape</span><span class="s2">, </span><span class="s1">res_v.shape)</span>
        <span class="s1">assert_equal((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">res.shape)</span>
        <span class="s3"># This is just for documentation, it might make sense to change:</span>
        <span class="s1">assert_(isinstance(a</span><span class="s2">, </span><span class="s1">np.ndarray))</span>

        <span class="s1">a = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.complex64).view(ArraySubclass)</span>
        <span class="s1">res</span><span class="s2">, </span><span class="s1">res_v = linalg.eigh(a)</span>
        <span class="s1">assert_(res_v.dtype.type </span><span class="s2">is </span><span class="s1">np.complex64)</span>
        <span class="s1">assert_(res.dtype.type </span><span class="s2">is </span><span class="s1">np.float32)</span>
        <span class="s1">assert_equal(a.shape</span><span class="s2">, </span><span class="s1">res_v.shape)</span>
        <span class="s1">assert_equal((</span><span class="s4">0</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">res.shape)</span>
        <span class="s3"># This is just for documentation, it might make sense to change:</span>
        <span class="s1">assert_(isinstance(a</span><span class="s2">, </span><span class="s1">np.ndarray))</span>


<span class="s2">class </span><span class="s1">_TestNormBase:</span>
    <span class="s1">dt = </span><span class="s2">None</span>
    <span class="s1">dec = </span><span class="s2">None</span>


<span class="s2">class </span><span class="s1">_TestNormGeneral(_TestNormBase):</span>

    <span class="s2">def </span><span class="s1">test_empty(self):</span>
        <span class="s1">assert_equal(norm([])</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(norm(array([]</span><span class="s2">, </span><span class="s1">dtype=self.dt))</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(norm(atleast_2d(array([]</span><span class="s2">, </span><span class="s1">dtype=self.dt)))</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_vector_return_type(self):</span>
        <span class="s1">a = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>

        <span class="s1">exact_types = np.typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">]</span>
        <span class="s1">inexact_types = np.typecodes[</span><span class="s5">'AllFloat'</span><span class="s1">]</span>

        <span class="s1">all_types = exact_types + inexact_types</span>

        <span class="s2">for </span><span class="s1">each_inexact_types </span><span class="s2">in </span><span class="s1">all_types:</span>
            <span class="s1">at = a.astype(each_inexact_types)</span>

            <span class="s1">an = norm(at</span><span class="s2">, </span><span class="s1">-np.inf)</span>
            <span class="s1">assert_(issubclass(an.dtype.type</span><span class="s2">, </span><span class="s1">np.floating))</span>
            <span class="s1">assert_almost_equal(an</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>

            <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
                <span class="s1">sup.filter(RuntimeWarning</span><span class="s2">, </span><span class="s5">&quot;divide by zero encountered&quot;</span><span class="s1">)</span>
                <span class="s1">an = norm(at</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">assert_(issubclass(an.dtype.type</span><span class="s2">, </span><span class="s1">np.floating))</span>
                <span class="s1">assert_almost_equal(an</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>

            <span class="s1">an = norm(at</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">assert_(issubclass(an.dtype.type</span><span class="s2">, </span><span class="s1">np.floating))</span>
            <span class="s1">assert_almost_equal(an</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>

            <span class="s1">an = norm(at</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">assert_(issubclass(an.dtype.type</span><span class="s2">, </span><span class="s1">np.floating))</span>
            <span class="s1">assert_almost_equal(an</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)</span>

            <span class="s1">an = norm(at</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">assert_(issubclass(an.dtype.type</span><span class="s2">, </span><span class="s1">np.floating))</span>
            <span class="s1">assert_almost_equal(an</span><span class="s2">, </span><span class="s1">an.dtype.type(</span><span class="s4">2.0</span><span class="s1">)**an.dtype.type(</span><span class="s4">1.0</span><span class="s1">/</span><span class="s4">2.0</span><span class="s1">))</span>

            <span class="s1">an = norm(at</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
            <span class="s1">assert_(issubclass(an.dtype.type</span><span class="s2">, </span><span class="s1">np.floating))</span>
            <span class="s1">assert_almost_equal(an</span><span class="s2">, </span><span class="s1">an.dtype.type(</span><span class="s4">2.0</span><span class="s1">)**an.dtype.type(</span><span class="s4">1.0</span><span class="s1">/</span><span class="s4">4.0</span><span class="s1">))</span>

            <span class="s1">an = norm(at</span><span class="s2">, </span><span class="s1">np.inf)</span>
            <span class="s1">assert_(issubclass(an.dtype.type</span><span class="s2">, </span><span class="s1">np.floating))</span>
            <span class="s1">assert_almost_equal(an</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_vector(self):</span>
        <span class="s1">a = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">b = [-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">c = [-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span>

        <span class="s2">def </span><span class="s1">_test(v):</span>
            <span class="s1">np.testing.assert_almost_equal(norm(v)</span><span class="s2">, </span><span class="s4">30 </span><span class="s1">** </span><span class="s4">0.5</span><span class="s2">,</span>
                                           <span class="s1">decimal=self.dec)</span>
            <span class="s1">np.testing.assert_almost_equal(norm(v</span><span class="s2">, </span><span class="s1">inf)</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">,</span>
                                           <span class="s1">decimal=self.dec)</span>
            <span class="s1">np.testing.assert_almost_equal(norm(v</span><span class="s2">, </span><span class="s1">-inf)</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">,</span>
                                           <span class="s1">decimal=self.dec)</span>
            <span class="s1">np.testing.assert_almost_equal(norm(v</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">10.0</span><span class="s2">,</span>
                                           <span class="s1">decimal=self.dec)</span>
            <span class="s1">np.testing.assert_almost_equal(norm(v</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">12.0 </span><span class="s1">/ </span><span class="s4">25</span><span class="s2">,</span>
                                           <span class="s1">decimal=self.dec)</span>
            <span class="s1">np.testing.assert_almost_equal(norm(v</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">30 </span><span class="s1">** </span><span class="s4">0.5</span><span class="s2">,</span>
                                           <span class="s1">decimal=self.dec)</span>
            <span class="s1">np.testing.assert_almost_equal(norm(v</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">((</span><span class="s4">205. </span><span class="s1">/ </span><span class="s4">144</span><span class="s1">) ** -</span><span class="s4">0.5</span><span class="s1">)</span><span class="s2">,</span>
                                           <span class="s1">decimal=self.dec)</span>
            <span class="s1">np.testing.assert_almost_equal(norm(v</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">4</span><span class="s2">,</span>
                                           <span class="s1">decimal=self.dec)</span>

        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">,</span><span class="s1">):</span>
            <span class="s1">_test(v)</span>

        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">(array(a</span><span class="s2">, </span><span class="s1">dtype=self.dt)</span><span class="s2">, </span><span class="s1">array(b</span><span class="s2">, </span><span class="s1">dtype=self.dt)</span><span class="s2">,</span>
                  <span class="s1">array(c</span><span class="s2">, </span><span class="s1">dtype=self.dt)):</span>
            <span class="s1">_test(v)</span>

    <span class="s2">def </span><span class="s1">test_axis(self):</span>
        <span class="s3"># Vector norms.</span>
        <span class="s3"># Compare the use of `axis` with computing the norm of each row</span>
        <span class="s3"># or column separately.</span>
        <span class="s1">A = array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=self.dt)</span>
        <span class="s2">for </span><span class="s1">order </span><span class="s2">in </span><span class="s1">[</span><span class="s2">None, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">np.Inf</span><span class="s2">, </span><span class="s1">-np.Inf]:</span>
            <span class="s1">expected0 = [norm(A[:</span><span class="s2">, </span><span class="s1">k]</span><span class="s2">, </span><span class="s1">ord=order) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(A.shape[</span><span class="s4">1</span><span class="s1">])]</span>
            <span class="s1">assert_almost_equal(norm(A</span><span class="s2">, </span><span class="s1">ord=order</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">expected0)</span>
            <span class="s1">expected1 = [norm(A[k</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">ord=order) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(A.shape[</span><span class="s4">0</span><span class="s1">])]</span>
            <span class="s1">assert_almost_equal(norm(A</span><span class="s2">, </span><span class="s1">ord=order</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">expected1)</span>

        <span class="s3"># Matrix norms.</span>
        <span class="s1">B = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">25</span><span class="s2">, </span><span class="s1">dtype=self.dt).reshape(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">nd = B.ndim</span>
        <span class="s2">for </span><span class="s1">order </span><span class="s2">in </span><span class="s1">[</span><span class="s2">None, </span><span class="s1">-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.Inf</span><span class="s2">, </span><span class="s1">-np.Inf</span><span class="s2">, </span><span class="s5">'fro'</span><span class="s1">]:</span>
            <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">itertools.combinations(range(-nd</span><span class="s2">, </span><span class="s1">nd)</span><span class="s2">, </span><span class="s4">2</span><span class="s1">):</span>
                <span class="s1">row_axis</span><span class="s2">, </span><span class="s1">col_axis = axis</span>
                <span class="s2">if </span><span class="s1">row_axis &lt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">row_axis += nd</span>
                <span class="s2">if </span><span class="s1">col_axis &lt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">col_axis += nd</span>
                <span class="s2">if </span><span class="s1">row_axis == col_axis:</span>
                    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">ord=order</span><span class="s2">, </span><span class="s1">axis=axis)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">n = norm(B</span><span class="s2">, </span><span class="s1">ord=order</span><span class="s2">, </span><span class="s1">axis=axis)</span>

                    <span class="s3"># The logic using k_index only works for nd = 3.</span>
                    <span class="s3"># This has to be changed if nd is increased.</span>
                    <span class="s1">k_index = nd - (row_axis + col_axis)</span>
                    <span class="s2">if </span><span class="s1">row_axis &lt; col_axis:</span>
                        <span class="s1">expected = [norm(B[:].take(k</span><span class="s2">, </span><span class="s1">axis=k_index)</span><span class="s2">, </span><span class="s1">ord=order)</span>
                                    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(B.shape[k_index])]</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">expected = [norm(B[:].take(k</span><span class="s2">, </span><span class="s1">axis=k_index).T</span><span class="s2">, </span><span class="s1">ord=order)</span>
                                    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(B.shape[k_index])]</span>
                    <span class="s1">assert_almost_equal(n</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_keepdims(self):</span>
        <span class="s1">A = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">25</span><span class="s2">, </span><span class="s1">dtype=self.dt).reshape(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>

        <span class="s1">allclose_err = </span><span class="s5">'order {0}, axis = {1}'</span>
        <span class="s1">shape_err = </span><span class="s5">'Shape mismatch found {0}, expected {1}, order={2}, axis={3}'</span>

        <span class="s3"># check the order=None, axis=None case</span>
        <span class="s1">expected = norm(A</span><span class="s2">, </span><span class="s1">ord=</span><span class="s2">None, </span><span class="s1">axis=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">found = norm(A</span><span class="s2">, </span><span class="s1">ord=</span><span class="s2">None, </span><span class="s1">axis=</span><span class="s2">None, </span><span class="s1">keepdims=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.squeeze(found)</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">,</span>
                        <span class="s1">err_msg=allclose_err.format(</span><span class="s2">None, None</span><span class="s1">))</span>
        <span class="s1">expected_shape = (</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_(found.shape == expected_shape</span><span class="s2">,</span>
                <span class="s1">shape_err.format(found.shape</span><span class="s2">, </span><span class="s1">expected_shape</span><span class="s2">, None, None</span><span class="s1">))</span>

        <span class="s3"># Vector norms.</span>
        <span class="s2">for </span><span class="s1">order </span><span class="s2">in </span><span class="s1">[</span><span class="s2">None, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">np.Inf</span><span class="s2">, </span><span class="s1">-np.Inf]:</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(A.ndim):</span>
                <span class="s1">expected = norm(A</span><span class="s2">, </span><span class="s1">ord=order</span><span class="s2">, </span><span class="s1">axis=k)</span>
                <span class="s1">found = norm(A</span><span class="s2">, </span><span class="s1">ord=order</span><span class="s2">, </span><span class="s1">axis=k</span><span class="s2">, </span><span class="s1">keepdims=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s1">assert_allclose(np.squeeze(found)</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">,</span>
                                <span class="s1">err_msg=allclose_err.format(order</span><span class="s2">, </span><span class="s1">k))</span>
                <span class="s1">expected_shape = list(A.shape)</span>
                <span class="s1">expected_shape[k] = </span><span class="s4">1</span>
                <span class="s1">expected_shape = tuple(expected_shape)</span>
                <span class="s1">assert_(found.shape == expected_shape</span><span class="s2">,</span>
                        <span class="s1">shape_err.format(found.shape</span><span class="s2">, </span><span class="s1">expected_shape</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">k))</span>

        <span class="s3"># Matrix norms.</span>
        <span class="s2">for </span><span class="s1">order </span><span class="s2">in </span><span class="s1">[</span><span class="s2">None, </span><span class="s1">-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.Inf</span><span class="s2">, </span><span class="s1">-np.Inf</span><span class="s2">, </span><span class="s5">'fro'</span><span class="s2">, </span><span class="s5">'nuc'</span><span class="s1">]:</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">itertools.permutations(range(A.ndim)</span><span class="s2">, </span><span class="s4">2</span><span class="s1">):</span>
                <span class="s1">expected = norm(A</span><span class="s2">, </span><span class="s1">ord=order</span><span class="s2">, </span><span class="s1">axis=k)</span>
                <span class="s1">found = norm(A</span><span class="s2">, </span><span class="s1">ord=order</span><span class="s2">, </span><span class="s1">axis=k</span><span class="s2">, </span><span class="s1">keepdims=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s1">assert_allclose(np.squeeze(found)</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">,</span>
                                <span class="s1">err_msg=allclose_err.format(order</span><span class="s2">, </span><span class="s1">k))</span>
                <span class="s1">expected_shape = list(A.shape)</span>
                <span class="s1">expected_shape[k[</span><span class="s4">0</span><span class="s1">]] = </span><span class="s4">1</span>
                <span class="s1">expected_shape[k[</span><span class="s4">1</span><span class="s1">]] = </span><span class="s4">1</span>
                <span class="s1">expected_shape = tuple(expected_shape)</span>
                <span class="s1">assert_(found.shape == expected_shape</span><span class="s2">,</span>
                        <span class="s1">shape_err.format(found.shape</span><span class="s2">, </span><span class="s1">expected_shape</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">k))</span>


<span class="s2">class </span><span class="s1">_TestNorm2D(_TestNormBase):</span>
    <span class="s3"># Define the part for 2d arrays separately, so we can subclass this</span>
    <span class="s3"># and run the tests using np.matrix in matrixlib.tests.test_matrix_linalg.</span>
    <span class="s1">array = np.array</span>

    <span class="s2">def </span><span class="s1">test_matrix_empty(self):</span>
        <span class="s1">assert_equal(norm(self.array([[]]</span><span class="s2">, </span><span class="s1">dtype=self.dt))</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_matrix_return_type(self):</span>
        <span class="s1">a = self.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]])</span>

        <span class="s1">exact_types = np.typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">]</span>

        <span class="s3"># float32, complex64, float64, complex128 types are the only types</span>
        <span class="s3"># allowed by `linalg`, which performs the matrix operations used</span>
        <span class="s3"># within `norm`.</span>
        <span class="s1">inexact_types = </span><span class="s5">'fdFD'</span>

        <span class="s1">all_types = exact_types + inexact_types</span>

        <span class="s2">for </span><span class="s1">each_inexact_types </span><span class="s2">in </span><span class="s1">all_types:</span>
            <span class="s1">at = a.astype(each_inexact_types)</span>

            <span class="s1">an = norm(at</span><span class="s2">, </span><span class="s1">-np.inf)</span>
            <span class="s1">assert_(issubclass(an.dtype.type</span><span class="s2">, </span><span class="s1">np.floating))</span>
            <span class="s1">assert_almost_equal(an</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)</span>

            <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
                <span class="s1">sup.filter(RuntimeWarning</span><span class="s2">, </span><span class="s5">&quot;divide by zero encountered&quot;</span><span class="s1">)</span>
                <span class="s1">an = norm(at</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">assert_(issubclass(an.dtype.type</span><span class="s2">, </span><span class="s1">np.floating))</span>
                <span class="s1">assert_almost_equal(an</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>

            <span class="s1">an = norm(at</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">assert_(issubclass(an.dtype.type</span><span class="s2">, </span><span class="s1">np.floating))</span>
            <span class="s1">assert_almost_equal(an</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)</span>

            <span class="s1">an = norm(at</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">assert_(issubclass(an.dtype.type</span><span class="s2">, </span><span class="s1">np.floating))</span>
            <span class="s1">assert_almost_equal(an</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">**(</span><span class="s4">1.0</span><span class="s1">/</span><span class="s4">2.0</span><span class="s1">))</span>

            <span class="s1">an = norm(at</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">assert_(issubclass(an.dtype.type</span><span class="s2">, </span><span class="s1">np.floating))</span>
            <span class="s1">assert_almost_equal(an</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>

            <span class="s1">an = norm(at</span><span class="s2">, </span><span class="s1">np.inf)</span>
            <span class="s1">assert_(issubclass(an.dtype.type</span><span class="s2">, </span><span class="s1">np.floating))</span>
            <span class="s1">assert_almost_equal(an</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)</span>

            <span class="s1">an = norm(at</span><span class="s2">, </span><span class="s5">'fro'</span><span class="s1">)</span>
            <span class="s1">assert_(issubclass(an.dtype.type</span><span class="s2">, </span><span class="s1">np.floating))</span>
            <span class="s1">assert_almost_equal(an</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)</span>

            <span class="s1">an = norm(at</span><span class="s2">, </span><span class="s5">'nuc'</span><span class="s1">)</span>
            <span class="s1">assert_(issubclass(an.dtype.type</span><span class="s2">, </span><span class="s1">np.floating))</span>
            <span class="s3"># Lower bar needed to support low precision floats.</span>
            <span class="s3"># They end up being off by 1 in the 7th place.</span>
            <span class="s1">np.testing.assert_almost_equal(an</span><span class="s2">, </span><span class="s4">2.7320508075688772</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_matrix_2x2(self):</span>
        <span class="s1">A = self.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">7</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=self.dt)</span>
        <span class="s1">assert_almost_equal(norm(A)</span><span class="s2">, </span><span class="s4">84 </span><span class="s1">** </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(norm(A</span><span class="s2">, </span><span class="s5">'fro'</span><span class="s1">)</span><span class="s2">, </span><span class="s4">84 </span><span class="s1">** </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(norm(A</span><span class="s2">, </span><span class="s5">'nuc'</span><span class="s1">)</span><span class="s2">, </span><span class="s4">10.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(norm(A</span><span class="s2">, </span><span class="s1">inf)</span><span class="s2">, </span><span class="s4">12.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(norm(A</span><span class="s2">, </span><span class="s1">-inf)</span><span class="s2">, </span><span class="s4">4.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(norm(A</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">10.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(norm(A</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">6.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(norm(A</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">9.1231056256176615</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(norm(A</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.87689437438234041</span><span class="s1">)</span>

        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s5">'nofro'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_matrix_3x3(self):</span>
        <span class="s3"># This test has been added because the 2x2 example</span>
        <span class="s3"># happened to have equal nuclear norm and induced 1-norm.</span>
        <span class="s3"># The 1/10 scaling factor accommodates the absolute tolerance</span>
        <span class="s3"># used in assert_almost_equal.</span>
        <span class="s1">A = (</span><span class="s4">1 </span><span class="s1">/ </span><span class="s4">10</span><span class="s1">) * \</span>
            <span class="s1">self.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">6</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=self.dt)</span>
        <span class="s1">assert_almost_equal(norm(A)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1 </span><span class="s1">/ </span><span class="s4">10</span><span class="s1">) * </span><span class="s4">89 </span><span class="s1">** </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(norm(A</span><span class="s2">, </span><span class="s5">'fro'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1 </span><span class="s1">/ </span><span class="s4">10</span><span class="s1">) * </span><span class="s4">89 </span><span class="s1">** </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(norm(A</span><span class="s2">, </span><span class="s5">'nuc'</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.3366836911774836</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(norm(A</span><span class="s2">, </span><span class="s1">inf)</span><span class="s2">, </span><span class="s4">1.1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(norm(A</span><span class="s2">, </span><span class="s1">-inf)</span><span class="s2">, </span><span class="s4">0.6</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(norm(A</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(norm(A</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.4</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(norm(A</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.88722940323461277</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(norm(A</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.19456584790481812</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bad_args(self):</span>
        <span class="s3"># Check that bad arguments raise the appropriate exceptions.</span>

        <span class="s1">A = self.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=self.dt)</span>
        <span class="s1">B = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">25</span><span class="s2">, </span><span class="s1">dtype=self.dt).reshape(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>

        <span class="s3"># Using `axis=&lt;integer&gt;` or passing in a 1-D array implies vector</span>
        <span class="s3"># norms are being computed, so also using `ord='fro'`</span>
        <span class="s3"># or `ord='nuc'` or any other string raises a ValueError.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s5">'fro'</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s5">'nuc'</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'fro'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'nuc'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s5">'test'</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s3"># Similarly, norm should raise an exception when ord is any finite</span>
        <span class="s3"># number other than 1, 2, -1 or -2 when computing matrix norms.</span>
        <span class="s2">for </span><span class="s1">order </span><span class="s2">in </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]:</span>
            <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
            <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>

        <span class="s3"># Invalid axis</span>
        <span class="s1">assert_raises(np.AxisError</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, None, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_raises(np.AxisError</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, None, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, None, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>


<span class="s2">class </span><span class="s1">_TestNorm(_TestNorm2D</span><span class="s2">, </span><span class="s1">_TestNormGeneral):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestNorm_NonSystematic:</span>

    <span class="s2">def </span><span class="s1">test_longdouble_norm(self):</span>
        <span class="s3"># Non-regression test: p-norm of longdouble would previously raise</span>
        <span class="s3"># UnboundLocalError.</span>
        <span class="s1">x = np.arange(</span><span class="s4">10</span><span class="s2">, </span><span class="s1">dtype=np.longdouble)</span>
        <span class="s1">old_assert_almost_equal(norm(x</span><span class="s2">, </span><span class="s1">ord=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s4">12.65</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_intmin(self):</span>
        <span class="s3"># Non-regression test: p-norm of signed integer would previously do</span>
        <span class="s3"># float cast and abs in the wrong order.</span>
        <span class="s1">x = np.array([-</span><span class="s4">2 </span><span class="s1">** </span><span class="s4">31</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.int32)</span>
        <span class="s1">old_assert_almost_equal(norm(x</span><span class="s2">, </span><span class="s1">ord=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">** </span><span class="s4">31</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_complex_high_ord(self):</span>
        <span class="s3"># gh-4156</span>
        <span class="s1">d = np.empty((</span><span class="s4">2</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.clongdouble)</span>
        <span class="s1">d[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">6 </span><span class="s1">+ </span><span class="s4">7j</span>
        <span class="s1">d[</span><span class="s4">1</span><span class="s1">] = -</span><span class="s4">6 </span><span class="s1">+ </span><span class="s4">7j</span>
        <span class="s1">res = </span><span class="s4">11.615898132184</span>
        <span class="s1">old_assert_almost_equal(np.linalg.norm(d</span><span class="s2">, </span><span class="s1">ord=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">res</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">d = d.astype(np.complex128)</span>
        <span class="s1">old_assert_almost_equal(np.linalg.norm(d</span><span class="s2">, </span><span class="s1">ord=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">res</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">9</span><span class="s1">)</span>
        <span class="s1">d = d.astype(np.complex64)</span>
        <span class="s1">old_assert_almost_equal(np.linalg.norm(d</span><span class="s2">, </span><span class="s1">ord=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">res</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">5</span><span class="s1">)</span>


<span class="s3"># Separate definitions so we can use them for matrix tests.</span>
<span class="s2">class </span><span class="s1">_TestNormDoubleBase(_TestNormBase):</span>
    <span class="s1">dt = np.double</span>
    <span class="s1">dec = </span><span class="s4">12</span>


<span class="s2">class </span><span class="s1">_TestNormSingleBase(_TestNormBase):</span>
    <span class="s1">dt = np.float32</span>
    <span class="s1">dec = </span><span class="s4">6</span>


<span class="s2">class </span><span class="s1">_TestNormInt64Base(_TestNormBase):</span>
    <span class="s1">dt = np.int64</span>
    <span class="s1">dec = </span><span class="s4">12</span>


<span class="s2">class </span><span class="s1">TestNormDouble(_TestNorm</span><span class="s2">, </span><span class="s1">_TestNormDoubleBase):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestNormSingle(_TestNorm</span><span class="s2">, </span><span class="s1">_TestNormSingleBase):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestNormInt64(_TestNorm</span><span class="s2">, </span><span class="s1">_TestNormInt64Base):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestMatrixRank:</span>

    <span class="s2">def </span><span class="s1">test_matrix_rank(self):</span>
        <span class="s3"># Full rank matrix</span>
        <span class="s1">assert_equal(</span><span class="s4">4</span><span class="s2">, </span><span class="s1">matrix_rank(np.eye(</span><span class="s4">4</span><span class="s1">)))</span>
        <span class="s3"># rank deficient matrix</span>
        <span class="s1">I = np.eye(</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">I[-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">] = </span><span class="s4">0.</span>
        <span class="s1">assert_equal(matrix_rank(I)</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s3"># All zeros - zero rank</span>
        <span class="s1">assert_equal(matrix_rank(np.zeros((</span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)))</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s3"># 1 dimension - rank 1 unless all 0</span>
        <span class="s1">assert_equal(matrix_rank([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(matrix_rank(np.zeros((</span><span class="s4">4</span><span class="s2">,</span><span class="s1">)))</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s3"># accepts array-like</span>
        <span class="s1">assert_equal(matrix_rank([</span><span class="s4">1</span><span class="s1">])</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s3"># greater than 2 dimensions treated as stacked matrices</span>
        <span class="s1">ms = np.array([I</span><span class="s2">, </span><span class="s1">np.eye(</span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.zeros((</span><span class="s4">4</span><span class="s2">,</span><span class="s4">4</span><span class="s1">))])</span>
        <span class="s1">assert_equal(matrix_rank(ms)</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s3"># works on scalar</span>
        <span class="s1">assert_equal(matrix_rank(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_symmetric_rank(self):</span>
        <span class="s1">assert_equal(</span><span class="s4">4</span><span class="s2">, </span><span class="s1">matrix_rank(np.eye(</span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">hermitian=</span><span class="s2">True</span><span class="s1">))</span>
        <span class="s1">assert_equal(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">matrix_rank(np.ones((</span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span><span class="s2">, </span><span class="s1">hermitian=</span><span class="s2">True</span><span class="s1">))</span>
        <span class="s1">assert_equal(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">matrix_rank(np.zeros((</span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span><span class="s2">, </span><span class="s1">hermitian=</span><span class="s2">True</span><span class="s1">))</span>
        <span class="s3"># rank deficient matrix</span>
        <span class="s1">I = np.eye(</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">I[-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">] = </span><span class="s4">0.</span>
        <span class="s1">assert_equal(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">matrix_rank(I</span><span class="s2">, </span><span class="s1">hermitian=</span><span class="s2">True</span><span class="s1">))</span>
        <span class="s3"># manually supplied tolerance</span>
        <span class="s1">I[-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">] = </span><span class="s4">1e-8</span>
        <span class="s1">assert_equal(</span><span class="s4">4</span><span class="s2">, </span><span class="s1">matrix_rank(I</span><span class="s2">, </span><span class="s1">hermitian=</span><span class="s2">True, </span><span class="s1">tol=</span><span class="s4">0.99e-8</span><span class="s1">))</span>
        <span class="s1">assert_equal(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">matrix_rank(I</span><span class="s2">, </span><span class="s1">hermitian=</span><span class="s2">True, </span><span class="s1">tol=</span><span class="s4">1.01e-8</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">test_reduced_rank():</span>
    <span class="s3"># Test matrices with reduced rank</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s4">20120714</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">100</span><span class="s1">):</span>
        <span class="s3"># Make a rank deficient matrix</span>
        <span class="s1">X = rng.normal(size=(</span><span class="s4">40</span><span class="s2">, </span><span class="s4">10</span><span class="s1">))</span>
        <span class="s1">X[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = X[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] + X[:</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s3"># Assert that matrix_rank detected deficiency</span>
        <span class="s1">assert_equal(matrix_rank(X)</span><span class="s2">, </span><span class="s4">9</span><span class="s1">)</span>
        <span class="s1">X[:</span><span class="s2">, </span><span class="s4">3</span><span class="s1">] = X[:</span><span class="s2">, </span><span class="s4">4</span><span class="s1">] + X[:</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span>
        <span class="s1">assert_equal(matrix_rank(X)</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestQR:</span>
    <span class="s3"># Define the array class here, so run this on matrices elsewhere.</span>
    <span class="s1">array = np.array</span>

    <span class="s2">def </span><span class="s1">check_qr(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s3"># This test expects the argument `a` to be an ndarray or</span>
        <span class="s3"># a subclass of an ndarray of inexact type.</span>
        <span class="s1">a_type = type(a)</span>
        <span class="s1">a_dtype = a.dtype</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">n = a.shape</span>
        <span class="s1">k = min(m</span><span class="s2">, </span><span class="s1">n)</span>

        <span class="s3"># mode == 'complete'</span>
        <span class="s1">q</span><span class="s2">, </span><span class="s1">r = linalg.qr(a</span><span class="s2">, </span><span class="s1">mode=</span><span class="s5">'complete'</span><span class="s1">)</span>
        <span class="s1">assert_(q.dtype == a_dtype)</span>
        <span class="s1">assert_(r.dtype == a_dtype)</span>
        <span class="s1">assert_(isinstance(q</span><span class="s2">, </span><span class="s1">a_type))</span>
        <span class="s1">assert_(isinstance(r</span><span class="s2">, </span><span class="s1">a_type))</span>
        <span class="s1">assert_(q.shape == (m</span><span class="s2">, </span><span class="s1">m))</span>
        <span class="s1">assert_(r.shape == (m</span><span class="s2">, </span><span class="s1">n))</span>
        <span class="s1">assert_almost_equal(dot(q</span><span class="s2">, </span><span class="s1">r)</span><span class="s2">, </span><span class="s1">a)</span>
        <span class="s1">assert_almost_equal(dot(q.T.conj()</span><span class="s2">, </span><span class="s1">q)</span><span class="s2">, </span><span class="s1">np.eye(m))</span>
        <span class="s1">assert_almost_equal(np.triu(r)</span><span class="s2">, </span><span class="s1">r)</span>

        <span class="s3"># mode == 'reduced'</span>
        <span class="s1">q1</span><span class="s2">, </span><span class="s1">r1 = linalg.qr(a</span><span class="s2">, </span><span class="s1">mode=</span><span class="s5">'reduced'</span><span class="s1">)</span>
        <span class="s1">assert_(q1.dtype == a_dtype)</span>
        <span class="s1">assert_(r1.dtype == a_dtype)</span>
        <span class="s1">assert_(isinstance(q1</span><span class="s2">, </span><span class="s1">a_type))</span>
        <span class="s1">assert_(isinstance(r1</span><span class="s2">, </span><span class="s1">a_type))</span>
        <span class="s1">assert_(q1.shape == (m</span><span class="s2">, </span><span class="s1">k))</span>
        <span class="s1">assert_(r1.shape == (k</span><span class="s2">, </span><span class="s1">n))</span>
        <span class="s1">assert_almost_equal(dot(q1</span><span class="s2">, </span><span class="s1">r1)</span><span class="s2">, </span><span class="s1">a)</span>
        <span class="s1">assert_almost_equal(dot(q1.T.conj()</span><span class="s2">, </span><span class="s1">q1)</span><span class="s2">, </span><span class="s1">np.eye(k))</span>
        <span class="s1">assert_almost_equal(np.triu(r1)</span><span class="s2">, </span><span class="s1">r1)</span>

        <span class="s3"># mode == 'r'</span>
        <span class="s1">r2 = linalg.qr(a</span><span class="s2">, </span><span class="s1">mode=</span><span class="s5">'r'</span><span class="s1">)</span>
        <span class="s1">assert_(r2.dtype == a_dtype)</span>
        <span class="s1">assert_(isinstance(r2</span><span class="s2">, </span><span class="s1">a_type))</span>
        <span class="s1">assert_almost_equal(r2</span><span class="s2">, </span><span class="s1">r1)</span>


    <span class="s1">@pytest.mark.parametrize([</span><span class="s5">&quot;m&quot;</span><span class="s2">, </span><span class="s5">&quot;n&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span>
        <span class="s1">(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_qr_empty(self</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s1">k = min(m</span><span class="s2">, </span><span class="s1">n)</span>
        <span class="s1">a = np.empty((m</span><span class="s2">, </span><span class="s1">n))</span>

        <span class="s1">self.check_qr(a)</span>

        <span class="s1">h</span><span class="s2">, </span><span class="s1">tau = np.linalg.qr(a</span><span class="s2">, </span><span class="s1">mode=</span><span class="s5">'raw'</span><span class="s1">)</span>
        <span class="s1">assert_equal(h.dtype</span><span class="s2">, </span><span class="s1">np.double)</span>
        <span class="s1">assert_equal(tau.dtype</span><span class="s2">, </span><span class="s1">np.double)</span>
        <span class="s1">assert_equal(h.shape</span><span class="s2">, </span><span class="s1">(n</span><span class="s2">, </span><span class="s1">m))</span>
        <span class="s1">assert_equal(tau.shape</span><span class="s2">, </span><span class="s1">(k</span><span class="s2">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_mode_raw(self):</span>
        <span class="s3"># The factorization is not unique and varies between libraries,</span>
        <span class="s3"># so it is not possible to check against known values. Functional</span>
        <span class="s3"># testing is a possibility, but awaits the exposure of more</span>
        <span class="s3"># of the functions in lapack_lite. Consequently, this test is</span>
        <span class="s3"># very limited in scope. Note that the results are in FORTRAN</span>
        <span class="s3"># order, hence the h arrays are transposed.</span>
        <span class="s1">a = self.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.double)</span>

        <span class="s3"># Test double</span>
        <span class="s1">h</span><span class="s2">, </span><span class="s1">tau = linalg.qr(a</span><span class="s2">, </span><span class="s1">mode=</span><span class="s5">'raw'</span><span class="s1">)</span>
        <span class="s1">assert_(h.dtype == np.double)</span>
        <span class="s1">assert_(tau.dtype == np.double)</span>
        <span class="s1">assert_(h.shape == (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
        <span class="s1">assert_(tau.shape == (</span><span class="s4">2</span><span class="s2">,</span><span class="s1">))</span>

        <span class="s1">h</span><span class="s2">, </span><span class="s1">tau = linalg.qr(a.T</span><span class="s2">, </span><span class="s1">mode=</span><span class="s5">'raw'</span><span class="s1">)</span>
        <span class="s1">assert_(h.dtype == np.double)</span>
        <span class="s1">assert_(tau.dtype == np.double)</span>
        <span class="s1">assert_(h.shape == (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">assert_(tau.shape == (</span><span class="s4">2</span><span class="s2">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_mode_all_but_economic(self):</span>
        <span class="s1">a = self.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]])</span>
        <span class="s1">b = self.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]])</span>
        <span class="s2">for </span><span class="s1">dt </span><span class="s2">in </span><span class="s5">&quot;fd&quot;</span><span class="s1">:</span>
            <span class="s1">m1 = a.astype(dt)</span>
            <span class="s1">m2 = b.astype(dt)</span>
            <span class="s1">self.check_qr(m1)</span>
            <span class="s1">self.check_qr(m2)</span>
            <span class="s1">self.check_qr(m2.T)</span>

        <span class="s2">for </span><span class="s1">dt </span><span class="s2">in </span><span class="s5">&quot;fd&quot;</span><span class="s1">:</span>
            <span class="s1">m1 = </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1j </span><span class="s1">* a.astype(dt)</span>
            <span class="s1">m2 = </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1j </span><span class="s1">* b.astype(dt)</span>
            <span class="s1">self.check_qr(m1)</span>
            <span class="s1">self.check_qr(m2)</span>
            <span class="s1">self.check_qr(m2.T)</span>

    <span class="s2">def </span><span class="s1">check_qr_stacked(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s3"># This test expects the argument `a` to be an ndarray or</span>
        <span class="s3"># a subclass of an ndarray of inexact type.</span>
        <span class="s1">a_type = type(a)</span>
        <span class="s1">a_dtype = a.dtype</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">n = a.shape[-</span><span class="s4">2</span><span class="s1">:]</span>
        <span class="s1">k = min(m</span><span class="s2">, </span><span class="s1">n)</span>

        <span class="s3"># mode == 'complete'</span>
        <span class="s1">q</span><span class="s2">, </span><span class="s1">r = linalg.qr(a</span><span class="s2">, </span><span class="s1">mode=</span><span class="s5">'complete'</span><span class="s1">)</span>
        <span class="s1">assert_(q.dtype == a_dtype)</span>
        <span class="s1">assert_(r.dtype == a_dtype)</span>
        <span class="s1">assert_(isinstance(q</span><span class="s2">, </span><span class="s1">a_type))</span>
        <span class="s1">assert_(isinstance(r</span><span class="s2">, </span><span class="s1">a_type))</span>
        <span class="s1">assert_(q.shape[-</span><span class="s4">2</span><span class="s1">:] == (m</span><span class="s2">, </span><span class="s1">m))</span>
        <span class="s1">assert_(r.shape[-</span><span class="s4">2</span><span class="s1">:] == (m</span><span class="s2">, </span><span class="s1">n))</span>
        <span class="s1">assert_almost_equal(matmul(q</span><span class="s2">, </span><span class="s1">r)</span><span class="s2">, </span><span class="s1">a)</span>
        <span class="s1">I_mat = np.identity(q.shape[-</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">stack_I_mat = np.broadcast_to(I_mat</span><span class="s2">, </span>
                        <span class="s1">q.shape[:-</span><span class="s4">2</span><span class="s1">] + (q.shape[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span><span class="s1">)*</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(matmul(swapaxes(q</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">).conj()</span><span class="s2">, </span><span class="s1">q)</span><span class="s2">, </span><span class="s1">stack_I_mat)</span>
        <span class="s1">assert_almost_equal(np.triu(r[...</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:])</span><span class="s2">, </span><span class="s1">r)</span>

        <span class="s3"># mode == 'reduced'</span>
        <span class="s1">q1</span><span class="s2">, </span><span class="s1">r1 = linalg.qr(a</span><span class="s2">, </span><span class="s1">mode=</span><span class="s5">'reduced'</span><span class="s1">)</span>
        <span class="s1">assert_(q1.dtype == a_dtype)</span>
        <span class="s1">assert_(r1.dtype == a_dtype)</span>
        <span class="s1">assert_(isinstance(q1</span><span class="s2">, </span><span class="s1">a_type))</span>
        <span class="s1">assert_(isinstance(r1</span><span class="s2">, </span><span class="s1">a_type))</span>
        <span class="s1">assert_(q1.shape[-</span><span class="s4">2</span><span class="s1">:] == (m</span><span class="s2">, </span><span class="s1">k))</span>
        <span class="s1">assert_(r1.shape[-</span><span class="s4">2</span><span class="s1">:] == (k</span><span class="s2">, </span><span class="s1">n))</span>
        <span class="s1">assert_almost_equal(matmul(q1</span><span class="s2">, </span><span class="s1">r1)</span><span class="s2">, </span><span class="s1">a)</span>
        <span class="s1">I_mat = np.identity(q1.shape[-</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">stack_I_mat = np.broadcast_to(I_mat</span><span class="s2">, </span>
                        <span class="s1">q1.shape[:-</span><span class="s4">2</span><span class="s1">] + (q1.shape[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span><span class="s1">)*</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(matmul(swapaxes(q1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">).conj()</span><span class="s2">, </span><span class="s1">q1)</span><span class="s2">, </span>
                            <span class="s1">stack_I_mat)</span>
        <span class="s1">assert_almost_equal(np.triu(r1[...</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:])</span><span class="s2">, </span><span class="s1">r1)</span>

        <span class="s3"># mode == 'r'</span>
        <span class="s1">r2 = linalg.qr(a</span><span class="s2">, </span><span class="s1">mode=</span><span class="s5">'r'</span><span class="s1">)</span>
        <span class="s1">assert_(r2.dtype == a_dtype)</span>
        <span class="s1">assert_(isinstance(r2</span><span class="s2">, </span><span class="s1">a_type))</span>
        <span class="s1">assert_almost_equal(r2</span><span class="s2">, </span><span class="s1">r1)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;size&quot;</span><span class="s2">, </span><span class="s1">[</span>
        <span class="s1">(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span>
        <span class="s1">(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;outer_size&quot;</span><span class="s2">, </span><span class="s1">[</span>
        <span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;dt&quot;</span><span class="s2">, </span><span class="s1">[</span>
        <span class="s1">np.single</span><span class="s2">, </span><span class="s1">np.double</span><span class="s2">, </span>
        <span class="s1">np.csingle</span><span class="s2">, </span><span class="s1">np.cdouble])</span>
    <span class="s2">def </span><span class="s1">test_stacked_inputs(self</span><span class="s2">, </span><span class="s1">outer_size</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dt):</span>

        <span class="s1">A = np.random.normal(size=outer_size + size).astype(dt)</span>
        <span class="s1">B = np.random.normal(size=outer_size + size).astype(dt)</span>
        <span class="s1">self.check_qr_stacked(A)</span>
        <span class="s1">self.check_qr_stacked(A + </span><span class="s4">1.j</span><span class="s1">*B)</span>


<span class="s2">class </span><span class="s1">TestCholesky:</span>
    <span class="s3"># TODO: are there no other tests for cholesky?</span>

    <span class="s2">def </span><span class="s1">test_basic_property(self):</span>
        <span class="s3"># Check A = L L^H</span>
        <span class="s1">shapes = [(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">50</span><span class="s2">, </span><span class="s4">50</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)]</span>
        <span class="s1">dtypes = (np.float32</span><span class="s2">, </span><span class="s1">np.float64</span><span class="s2">, </span><span class="s1">np.complex64</span><span class="s2">, </span><span class="s1">np.complex128)</span>

        <span class="s2">for </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">itertools.product(shapes</span><span class="s2">, </span><span class="s1">dtypes):</span>
            <span class="s1">np.random.seed(</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">a = np.random.randn(*shape)</span>
            <span class="s2">if </span><span class="s1">np.issubdtype(dtype</span><span class="s2">, </span><span class="s1">np.complexfloating):</span>
                <span class="s1">a = a + </span><span class="s4">1j</span><span class="s1">*np.random.randn(*shape)</span>

            <span class="s1">t = list(range(len(shape)))</span>
            <span class="s1">t[-</span><span class="s4">2</span><span class="s1">:] = -</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span>

            <span class="s1">a = np.matmul(a.transpose(t).conj()</span><span class="s2">, </span><span class="s1">a)</span>
            <span class="s1">a = np.asarray(a</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

            <span class="s1">c = np.linalg.cholesky(a)</span>

            <span class="s1">b = np.matmul(c</span><span class="s2">, </span><span class="s1">c.transpose(t).conj())</span>
            <span class="s1">assert_allclose(b</span><span class="s2">, </span><span class="s1">a</span><span class="s2">,</span>
                            <span class="s1">err_msg=</span><span class="s5">f'</span><span class="s2">{</span><span class="s1">shape</span><span class="s2">} {</span><span class="s1">dtype</span><span class="s2">}\n{</span><span class="s1">a</span><span class="s2">}\n{</span><span class="s1">c</span><span class="s2">}</span><span class="s5">'</span><span class="s2">,</span>
                            <span class="s1">atol=</span><span class="s4">500 </span><span class="s1">* a.shape[</span><span class="s4">0</span><span class="s1">] * np.finfo(dtype).eps)</span>

    <span class="s2">def </span><span class="s1">test_0_size(self):</span>
        <span class="s2">class </span><span class="s1">ArraySubclass(np.ndarray):</span>
            <span class="s2">pass</span>
        <span class="s1">a = np.zeros((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.int_).view(ArraySubclass)</span>
        <span class="s1">res = linalg.cholesky(a)</span>
        <span class="s1">assert_equal(a.shape</span><span class="s2">, </span><span class="s1">res.shape)</span>
        <span class="s1">assert_(res.dtype.type </span><span class="s2">is </span><span class="s1">np.float64)</span>
        <span class="s3"># for documentation purpose:</span>
        <span class="s1">assert_(isinstance(res</span><span class="s2">, </span><span class="s1">np.ndarray))</span>

        <span class="s1">a = np.zeros((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.complex64).view(ArraySubclass)</span>
        <span class="s1">res = linalg.cholesky(a)</span>
        <span class="s1">assert_equal(a.shape</span><span class="s2">, </span><span class="s1">res.shape)</span>
        <span class="s1">assert_(res.dtype.type </span><span class="s2">is </span><span class="s1">np.complex64)</span>
        <span class="s1">assert_(isinstance(res</span><span class="s2">, </span><span class="s1">np.ndarray))</span>


<span class="s2">def </span><span class="s1">test_byteorder_check():</span>
    <span class="s3"># Byte order check should pass for native order</span>
    <span class="s2">if </span><span class="s1">sys.byteorder == </span><span class="s5">'little'</span><span class="s1">:</span>
        <span class="s1">native = </span><span class="s5">'&lt;'</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">native = </span><span class="s5">'&gt;'</span>

    <span class="s2">for </span><span class="s1">dtt </span><span class="s2">in </span><span class="s1">(np.float32</span><span class="s2">, </span><span class="s1">np.float64):</span>
        <span class="s1">arr = np.eye(</span><span class="s4">4</span><span class="s2">, </span><span class="s1">dtype=dtt)</span>
        <span class="s1">n_arr = arr.newbyteorder(native)</span>
        <span class="s1">sw_arr = arr.newbyteorder(</span><span class="s5">'S'</span><span class="s1">).byteswap()</span>
        <span class="s1">assert_equal(arr.dtype.byteorder</span><span class="s2">, </span><span class="s5">'='</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">routine </span><span class="s2">in </span><span class="s1">(linalg.inv</span><span class="s2">, </span><span class="s1">linalg.det</span><span class="s2">, </span><span class="s1">linalg.pinv):</span>
            <span class="s3"># Normal call</span>
            <span class="s1">res = routine(arr)</span>
            <span class="s3"># Native but not '='</span>
            <span class="s1">assert_array_equal(res</span><span class="s2">, </span><span class="s1">routine(n_arr))</span>
            <span class="s3"># Swapped</span>
            <span class="s1">assert_array_equal(res</span><span class="s2">, </span><span class="s1">routine(sw_arr))</span>


<span class="s2">def </span><span class="s1">test_generalized_raise_multiloop():</span>
    <span class="s3"># It should raise an error even if the error doesn't occur in the</span>
    <span class="s3"># last iteration of the ufunc inner loop</span>

    <span class="s1">invertible = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]])</span>
    <span class="s1">non_invertible = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]])</span>

    <span class="s1">x = np.zeros([</span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])[</span><span class="s4">1</span><span class="s1">::</span><span class="s4">2</span><span class="s1">]</span>
    <span class="s1">x[...] = invertible</span>
    <span class="s1">x[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = non_invertible</span>

    <span class="s1">assert_raises(np.linalg.LinAlgError</span><span class="s2">, </span><span class="s1">np.linalg.inv</span><span class="s2">, </span><span class="s1">x)</span>


<span class="s2">def </span><span class="s1">test_xerbla_override():</span>
    <span class="s3"># Check that our xerbla has been successfully linked in. If it is not,</span>
    <span class="s3"># the default xerbla routine is called, which prints a message to stdout</span>
    <span class="s3"># and may, or may not, abort the process depending on the LAPACK package.</span>

    <span class="s1">XERBLA_OK = </span><span class="s4">255</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">pid = os.fork()</span>
    <span class="s2">except </span><span class="s1">(OSError</span><span class="s2">, </span><span class="s1">AttributeError):</span>
        <span class="s3"># fork failed, or not running on POSIX</span>
        <span class="s1">pytest.skip(</span><span class="s5">&quot;Not POSIX or fork failed.&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">pid == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s3"># child; close i/o file handles</span>
        <span class="s1">os.close(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">os.close(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s3"># Avoid producing core files.</span>
        <span class="s2">import </span><span class="s1">resource</span>
        <span class="s1">resource.setrlimit(resource.RLIMIT_CORE</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s3"># These calls may abort.</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">np.linalg.lapack_lite.xerbla()</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">pass</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s1">os._exit(os.EX_CONFIG)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">a = np.array([[</span><span class="s4">1.</span><span class="s1">]])</span>
            <span class="s1">np.linalg.lapack_lite.dorgqr(</span>
                <span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">a</span><span class="s2">,</span>
                <span class="s4">0</span><span class="s2">,  </span><span class="s3"># &lt;- invalid value</span>
                <span class="s1">a</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">if </span><span class="s5">&quot;DORGQR parameter number 5&quot; </span><span class="s2">in </span><span class="s1">str(e):</span>
                <span class="s3"># success, reuse error code to mark success as</span>
                <span class="s3"># FORTRAN STOP returns as success.</span>
                <span class="s1">os._exit(XERBLA_OK)</span>

        <span class="s3"># Did not abort, but our xerbla was not linked in.</span>
        <span class="s1">os._exit(os.EX_CONFIG)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># parent</span>
        <span class="s1">pid</span><span class="s2">, </span><span class="s1">status = os.wait()</span>
        <span class="s2">if </span><span class="s1">os.WEXITSTATUS(status) != XERBLA_OK:</span>
            <span class="s1">pytest.skip(</span><span class="s5">'Numpy xerbla not linked in.'</span><span class="s1">)</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s2">def </span><span class="s1">test_sdot_bug_8577():</span>
    <span class="s3"># Regression test that loading certain other libraries does not</span>
    <span class="s3"># result to wrong results in float32 linear algebra.</span>
    <span class="s3">#</span>
    <span class="s3"># There's a bug gh-8577 on OSX that can trigger this, and perhaps</span>
    <span class="s3"># there are also other situations in which it occurs.</span>
    <span class="s3">#</span>
    <span class="s3"># Do the check in a separate process.</span>

    <span class="s1">bad_libs = [</span><span class="s5">'PyQt5.QtWidgets'</span><span class="s2">, </span><span class="s5">'IPython'</span><span class="s1">]</span>

    <span class="s1">template = textwrap.dedent(</span><span class="s5">&quot;&quot;&quot; 
    import sys 
    {before} 
    try: 
        import {bad_lib} 
    except ImportError: 
        sys.exit(0) 
    {after} 
    x = np.ones(2, dtype=np.float32) 
    sys.exit(0 if np.allclose(x.dot(x), 2.0) else 1) 
    &quot;&quot;&quot;</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">bad_lib </span><span class="s2">in </span><span class="s1">bad_libs:</span>
        <span class="s1">code = template.format(before=</span><span class="s5">&quot;import numpy as np&quot;</span><span class="s2">, </span><span class="s1">after=</span><span class="s5">&quot;&quot;</span><span class="s2">,</span>
                               <span class="s1">bad_lib=bad_lib)</span>
        <span class="s1">subprocess.check_call([sys.executable</span><span class="s2">, </span><span class="s5">&quot;-c&quot;</span><span class="s2">, </span><span class="s1">code])</span>

        <span class="s3"># Swapped import order</span>
        <span class="s1">code = template.format(after=</span><span class="s5">&quot;import numpy as np&quot;</span><span class="s2">, </span><span class="s1">before=</span><span class="s5">&quot;&quot;</span><span class="s2">,</span>
                               <span class="s1">bad_lib=bad_lib)</span>
        <span class="s1">subprocess.check_call([sys.executable</span><span class="s2">, </span><span class="s5">&quot;-c&quot;</span><span class="s2">, </span><span class="s1">code])</span>


<span class="s2">class </span><span class="s1">TestMultiDot:</span>

    <span class="s2">def </span><span class="s1">test_basic_function_with_three_arguments(self):</span>
        <span class="s3"># multi_dot with three arguments uses a fast hand coded algorithm to</span>
        <span class="s3"># determine the optimal order. Therefore test it separately.</span>
        <span class="s1">A = np.random.random((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">B = np.random.random((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">C = np.random.random((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>

        <span class="s1">assert_almost_equal(multi_dot([A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">C])</span><span class="s2">, </span><span class="s1">A.dot(B).dot(C))</span>
        <span class="s1">assert_almost_equal(multi_dot([A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">C])</span><span class="s2">, </span><span class="s1">np.dot(A</span><span class="s2">, </span><span class="s1">np.dot(B</span><span class="s2">, </span><span class="s1">C)))</span>

    <span class="s2">def </span><span class="s1">test_basic_function_with_two_arguments(self):</span>
        <span class="s3"># separate code path with two arguments</span>
        <span class="s1">A = np.random.random((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">B = np.random.random((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s1">))</span>

        <span class="s1">assert_almost_equal(multi_dot([A</span><span class="s2">, </span><span class="s1">B])</span><span class="s2">, </span><span class="s1">A.dot(B))</span>
        <span class="s1">assert_almost_equal(multi_dot([A</span><span class="s2">, </span><span class="s1">B])</span><span class="s2">, </span><span class="s1">np.dot(A</span><span class="s2">, </span><span class="s1">B))</span>

    <span class="s2">def </span><span class="s1">test_basic_function_with_dynamic_programming_optimization(self):</span>
        <span class="s3"># multi_dot with four or more arguments uses the dynamic programming</span>
        <span class="s3"># optimization and therefore deserve a separate</span>
        <span class="s1">A = np.random.random((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">B = np.random.random((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">C = np.random.random((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">D = np.random.random((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">assert_almost_equal(multi_dot([A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">D])</span><span class="s2">, </span><span class="s1">A.dot(B).dot(C).dot(D))</span>

    <span class="s2">def </span><span class="s1">test_vector_as_first_argument(self):</span>
        <span class="s3"># The first argument can be 1-D</span>
        <span class="s1">A1d = np.random.random(</span><span class="s4">2</span><span class="s1">)  </span><span class="s3"># 1-D</span>
        <span class="s1">B = np.random.random((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">C = np.random.random((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">D = np.random.random((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>

        <span class="s3"># the result should be 1-D</span>
        <span class="s1">assert_equal(multi_dot([A1d</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">D]).shape</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_vector_as_last_argument(self):</span>
        <span class="s3"># The last argument can be 1-D</span>
        <span class="s1">A = np.random.random((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">B = np.random.random((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">C = np.random.random((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">D1d = np.random.random(</span><span class="s4">2</span><span class="s1">)  </span><span class="s3"># 1-D</span>

        <span class="s3"># the result should be 1-D</span>
        <span class="s1">assert_equal(multi_dot([A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">D1d]).shape</span><span class="s2">, </span><span class="s1">(</span><span class="s4">6</span><span class="s2">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_vector_as_first_and_last_argument(self):</span>
        <span class="s3"># The first and last arguments can be 1-D</span>
        <span class="s1">A1d = np.random.random(</span><span class="s4">2</span><span class="s1">)  </span><span class="s3"># 1-D</span>
        <span class="s1">B = np.random.random((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">C = np.random.random((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">D1d = np.random.random(</span><span class="s4">2</span><span class="s1">)  </span><span class="s3"># 1-D</span>

        <span class="s3"># the result should be a scalar</span>
        <span class="s1">assert_equal(multi_dot([A1d</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">D1d]).shape</span><span class="s2">, </span><span class="s1">())</span>

    <span class="s2">def </span><span class="s1">test_three_arguments_and_out(self):</span>
        <span class="s3"># multi_dot with three arguments uses a fast hand coded algorithm to</span>
        <span class="s3"># determine the optimal order. Therefore test it separately.</span>
        <span class="s1">A = np.random.random((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">B = np.random.random((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">C = np.random.random((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>

        <span class="s1">out = np.zeros((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">ret = multi_dot([A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">C]</span><span class="s2">, </span><span class="s1">out=out)</span>
        <span class="s2">assert </span><span class="s1">out </span><span class="s2">is </span><span class="s1">ret</span>
        <span class="s1">assert_almost_equal(out</span><span class="s2">, </span><span class="s1">A.dot(B).dot(C))</span>
        <span class="s1">assert_almost_equal(out</span><span class="s2">, </span><span class="s1">np.dot(A</span><span class="s2">, </span><span class="s1">np.dot(B</span><span class="s2">, </span><span class="s1">C)))</span>

    <span class="s2">def </span><span class="s1">test_two_arguments_and_out(self):</span>
        <span class="s3"># separate code path with two arguments</span>
        <span class="s1">A = np.random.random((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">B = np.random.random((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">out = np.zeros((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">ret = multi_dot([A</span><span class="s2">, </span><span class="s1">B]</span><span class="s2">, </span><span class="s1">out=out)</span>
        <span class="s2">assert </span><span class="s1">out </span><span class="s2">is </span><span class="s1">ret</span>
        <span class="s1">assert_almost_equal(out</span><span class="s2">, </span><span class="s1">A.dot(B))</span>
        <span class="s1">assert_almost_equal(out</span><span class="s2">, </span><span class="s1">np.dot(A</span><span class="s2">, </span><span class="s1">B))</span>

    <span class="s2">def </span><span class="s1">test_dynamic_programming_optimization_and_out(self):</span>
        <span class="s3"># multi_dot with four or more arguments uses the dynamic programming</span>
        <span class="s3"># optimization and therefore deserve a separate test</span>
        <span class="s1">A = np.random.random((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">B = np.random.random((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">C = np.random.random((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">D = np.random.random((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">out = np.zeros((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">ret = multi_dot([A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">D]</span><span class="s2">, </span><span class="s1">out=out)</span>
        <span class="s2">assert </span><span class="s1">out </span><span class="s2">is </span><span class="s1">ret</span>
        <span class="s1">assert_almost_equal(out</span><span class="s2">, </span><span class="s1">A.dot(B).dot(C).dot(D))</span>

    <span class="s2">def </span><span class="s1">test_dynamic_programming_logic(self):</span>
        <span class="s3"># Test for the dynamic programming part</span>
        <span class="s3"># This test is directly taken from Cormen page 376.</span>
        <span class="s1">arrays = [np.random.random((</span><span class="s4">30</span><span class="s2">, </span><span class="s4">35</span><span class="s1">))</span><span class="s2">,</span>
                  <span class="s1">np.random.random((</span><span class="s4">35</span><span class="s2">, </span><span class="s4">15</span><span class="s1">))</span><span class="s2">,</span>
                  <span class="s1">np.random.random((</span><span class="s4">15</span><span class="s2">, </span><span class="s4">5</span><span class="s1">))</span><span class="s2">,</span>
                  <span class="s1">np.random.random((</span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s1">))</span><span class="s2">,</span>
                  <span class="s1">np.random.random((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">20</span><span class="s1">))</span><span class="s2">,</span>
                  <span class="s1">np.random.random((</span><span class="s4">20</span><span class="s2">, </span><span class="s4">25</span><span class="s1">))]</span>
        <span class="s1">m_expected = np.array([[</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">15750.</span><span class="s2">, </span><span class="s4">7875.</span><span class="s2">, </span><span class="s4">9375.</span><span class="s2">, </span><span class="s4">11875.</span><span class="s2">, </span><span class="s4">15125.</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0.</span><span class="s2">,     </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">2625.</span><span class="s2">, </span><span class="s4">4375.</span><span class="s2">,  </span><span class="s4">7125.</span><span class="s2">, </span><span class="s4">10500.</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0.</span><span class="s2">,     </span><span class="s4">0.</span><span class="s2">,    </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">750.</span><span class="s2">,  </span><span class="s4">2500.</span><span class="s2">,  </span><span class="s4">5375.</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0.</span><span class="s2">,     </span><span class="s4">0.</span><span class="s2">,    </span><span class="s4">0.</span><span class="s2">,    </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">1000.</span><span class="s2">,  </span><span class="s4">3500.</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0.</span><span class="s2">,     </span><span class="s4">0.</span><span class="s2">,    </span><span class="s4">0.</span><span class="s2">,    </span><span class="s4">0.</span><span class="s2">,     </span><span class="s4">0.</span><span class="s2">,  </span><span class="s4">5000.</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0.</span><span class="s2">,     </span><span class="s4">0.</span><span class="s2">,    </span><span class="s4">0.</span><span class="s2">,    </span><span class="s4">0.</span><span class="s2">,     </span><span class="s4">0.</span><span class="s2">,     </span><span class="s4">0.</span><span class="s1">]])</span>
        <span class="s1">s_expected = np.array([[</span><span class="s4">0</span><span class="s2">,  </span><span class="s4">1</span><span class="s2">,  </span><span class="s4">1</span><span class="s2">,  </span><span class="s4">3</span><span class="s2">,  </span><span class="s4">3</span><span class="s2">,  </span><span class="s4">3</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0</span><span class="s2">,  </span><span class="s4">0</span><span class="s2">,  </span><span class="s4">2</span><span class="s2">,  </span><span class="s4">3</span><span class="s2">,  </span><span class="s4">3</span><span class="s2">,  </span><span class="s4">3</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0</span><span class="s2">,  </span><span class="s4">0</span><span class="s2">,  </span><span class="s4">0</span><span class="s2">,  </span><span class="s4">3</span><span class="s2">,  </span><span class="s4">3</span><span class="s2">,  </span><span class="s4">3</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0</span><span class="s2">,  </span><span class="s4">0</span><span class="s2">,  </span><span class="s4">0</span><span class="s2">,  </span><span class="s4">0</span><span class="s2">,  </span><span class="s4">4</span><span class="s2">,  </span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0</span><span class="s2">,  </span><span class="s4">0</span><span class="s2">,  </span><span class="s4">0</span><span class="s2">,  </span><span class="s4">0</span><span class="s2">,  </span><span class="s4">0</span><span class="s2">,  </span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s1">[</span><span class="s4">0</span><span class="s2">,  </span><span class="s4">0</span><span class="s2">,  </span><span class="s4">0</span><span class="s2">,  </span><span class="s4">0</span><span class="s2">,  </span><span class="s4">0</span><span class="s2">,  </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=int)</span>
        <span class="s1">s_expected -= </span><span class="s4">1  </span><span class="s3"># Cormen uses 1-based index, python does not.</span>

        <span class="s1">s</span><span class="s2">, </span><span class="s1">m = _multi_dot_matrix_chain_order(arrays</span><span class="s2">, </span><span class="s1">return_costs=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s3"># Only the upper triangular part (without the diagonal) is interesting.</span>
        <span class="s1">assert_almost_equal(np.triu(s[:-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">:])</span><span class="s2">,</span>
                            <span class="s1">np.triu(s_expected[:-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">:]))</span>
        <span class="s1">assert_almost_equal(np.triu(m)</span><span class="s2">, </span><span class="s1">np.triu(m_expected))</span>

    <span class="s2">def </span><span class="s1">test_too_few_input_arrays(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">multi_dot</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">multi_dot</span><span class="s2">, </span><span class="s1">[np.random.random((</span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))])</span>


<span class="s2">class </span><span class="s1">TestTensorinv:</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;arr, ind&quot;</span><span class="s2">, </span><span class="s1">[</span>
        <span class="s1">(np.ones((</span><span class="s4">4</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(np.ones((</span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_non_square_handling(self</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">, </span><span class="s1">ind):</span>
        <span class="s2">with </span><span class="s1">assert_raises(LinAlgError):</span>
            <span class="s1">linalg.tensorinv(arr</span><span class="s2">, </span><span class="s1">ind=ind)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;shape, ind&quot;</span><span class="s2">, </span><span class="s1">[</span>
        <span class="s3"># examples from docstring</span>
        <span class="s1">((</span><span class="s4">4</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">((</span><span class="s4">24</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_tensorinv_shape(self</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">ind):</span>
        <span class="s1">a = np.eye(</span><span class="s4">24</span><span class="s1">)</span>
        <span class="s1">a.shape = shape</span>
        <span class="s1">ainv = linalg.tensorinv(a=a</span><span class="s2">, </span><span class="s1">ind=ind)</span>
        <span class="s1">expected = a.shape[ind:] + a.shape[:ind]</span>
        <span class="s1">actual = ainv.shape</span>
        <span class="s1">assert_equal(actual</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;ind&quot;</span><span class="s2">, </span><span class="s1">[</span>
        <span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s2">,</span>
        <span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_tensorinv_ind_limit(self</span><span class="s2">, </span><span class="s1">ind):</span>
        <span class="s1">a = np.eye(</span><span class="s4">24</span><span class="s1">)</span>
        <span class="s1">a.shape = (</span><span class="s4">4</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">linalg.tensorinv(a=a</span><span class="s2">, </span><span class="s1">ind=ind)</span>

    <span class="s2">def </span><span class="s1">test_tensorinv_result(self):</span>
        <span class="s3"># mimic a docstring example</span>
        <span class="s1">a = np.eye(</span><span class="s4">24</span><span class="s1">)</span>
        <span class="s1">a.shape = (</span><span class="s4">24</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">ainv = linalg.tensorinv(a</span><span class="s2">, </span><span class="s1">ind=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">b = np.ones(</span><span class="s4">24</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.tensordot(ainv</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.linalg.tensorsolve(a</span><span class="s2">, </span><span class="s1">b))</span>


<span class="s2">def </span><span class="s1">test_unsupported_commontype():</span>
    <span class="s3"># linalg gracefully handles unsupported type</span>
    <span class="s1">arr = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">'float16'</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">assert_raises_regex(TypeError</span><span class="s2">, </span><span class="s5">&quot;unsupported in linalg&quot;</span><span class="s1">):</span>
        <span class="s1">linalg.cholesky(arr)</span>


<span class="s3">#@pytest.mark.slow</span>
<span class="s3">#@pytest.mark.xfail(not HAS_LAPACK64, run=False,</span>
<span class="s3">#                   reason=&quot;Numpy not compiled with 64-bit BLAS/LAPACK&quot;)</span>
<span class="s3">#@requires_memory(free_bytes=16e9)</span>
<span class="s1">@pytest.mark.skip(reason=</span><span class="s5">&quot;Bad memory reports lead to OOM in ci testing&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_blas64_dot():</span>
    <span class="s1">n = </span><span class="s4">2</span><span class="s1">**</span><span class="s4">32</span>
    <span class="s1">a = np.zeros([</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n]</span><span class="s2">, </span><span class="s1">dtype=np.float32)</span>
    <span class="s1">b = np.ones([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.float32)</span>
    <span class="s1">a[</span><span class="s4">0</span><span class="s2">,</span><span class="s1">-</span><span class="s4">1</span><span class="s1">] = </span><span class="s4">1</span>
    <span class="s1">c = np.dot(b</span><span class="s2">, </span><span class="s1">a)</span>
    <span class="s1">assert_equal(c[</span><span class="s4">0</span><span class="s2">,</span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>


<span class="s1">@pytest.mark.xfail(</span><span class="s2">not </span><span class="s1">HAS_LAPACK64</span><span class="s2">,</span>
                   <span class="s1">reason=</span><span class="s5">&quot;Numpy not compiled with 64-bit BLAS/LAPACK&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_blas64_geqrf_lwork_smoketest():</span>
    <span class="s3"># Smoke test LAPACK geqrf lwork call with 64-bit integers</span>
    <span class="s1">dtype = np.float64</span>
    <span class="s1">lapack_routine = np.linalg.lapack_lite.dgeqrf</span>

    <span class="s1">m = </span><span class="s4">2</span><span class="s1">**</span><span class="s4">32 </span><span class="s1">+ </span><span class="s4">1</span>
    <span class="s1">n = </span><span class="s4">2</span><span class="s1">**</span><span class="s4">32 </span><span class="s1">+ </span><span class="s4">1</span>
    <span class="s1">lda = m</span>

    <span class="s3"># Dummy arrays, not referenced by the lapack routine, so don't</span>
    <span class="s3"># need to be of the right size</span>
    <span class="s1">a = np.zeros([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">work = np.zeros([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">tau = np.zeros([</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s3"># Size query</span>
    <span class="s1">results = lapack_routine(m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">lda</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">work</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(results[</span><span class="s5">'info'</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(results[</span><span class="s5">'m'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">m)</span>
    <span class="s1">assert_equal(results[</span><span class="s5">'n'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">m)</span>

    <span class="s3"># Should result to an integer of a reasonable size</span>
    <span class="s1">lwork = int(work.item())</span>
    <span class="s1">assert_(</span><span class="s4">2</span><span class="s1">**</span><span class="s4">32 </span><span class="s1">&lt; lwork &lt; </span><span class="s4">2</span><span class="s1">**</span><span class="s4">42</span><span class="s1">)</span>
</pre>
</body>
</html>