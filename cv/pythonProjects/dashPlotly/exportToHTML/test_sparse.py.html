<html>
<head>
<title>test_sparse.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_sparse.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
This file contains a minimal set of tests for compliance with the extension 
array interface test suite, and should contain no other tests. 
The test suite for the full functionality of the array is located in 
`pandas/tests/arrays/`. 
 
The tests in this file are inherited from the BaseExtensionTests, and only 
minimal tweaks should be applied to get the tests passing (by overwriting a 
parent method). 
 
Additional tests should either be added to one of the BaseExtensionTests 
classes (if they are relevant for the extension interface for all dtypes), or 
be added to the array-specific tests in `pandas/tests/arrays/`. 
 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">pandas.compat </span><span class="s2">import </span><span class="s1">np_version_under1p20</span>
<span class="s2">from </span><span class="s1">pandas.errors </span><span class="s2">import </span><span class="s1">PerformanceWarning</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">is_object_dtype</span>

<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">SparseDtype</span>
<span class="s2">import </span><span class="s1">pandas._testing </span><span class="s2">as </span><span class="s1">tm</span>
<span class="s2">from </span><span class="s1">pandas.arrays </span><span class="s2">import </span><span class="s1">SparseArray</span>
<span class="s2">from </span><span class="s1">pandas.tests.extension </span><span class="s2">import </span><span class="s1">base</span>


<span class="s2">def </span><span class="s1">make_data(fill_value):</span>
    <span class="s2">if </span><span class="s1">np.isnan(fill_value):</span>
        <span class="s1">data = np.random.uniform(size=</span><span class="s3">100</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">data = np.random.randint(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">100</span><span class="s2">, </span><span class="s1">size=</span><span class="s3">100</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">data[</span><span class="s3">0</span><span class="s1">] == data[</span><span class="s3">1</span><span class="s1">]:</span>
            <span class="s1">data[</span><span class="s3">0</span><span class="s1">] += </span><span class="s3">1</span>

    <span class="s1">data[</span><span class="s3">2</span><span class="s1">::</span><span class="s3">3</span><span class="s1">] = fill_value</span>
    <span class="s2">return </span><span class="s1">data</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">dtype():</span>
    <span class="s2">return </span><span class="s1">SparseDtype()</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s3">0</span><span class="s2">, </span><span class="s1">np.nan])</span>
<span class="s2">def </span><span class="s1">data(request):</span>
    <span class="s0">&quot;&quot;&quot;Length-100 PeriodArray for semantics test.&quot;&quot;&quot;</span>
    <span class="s1">res = SparseArray(make_data(request.param)</span><span class="s2">, </span><span class="s1">fill_value=request.param)</span>
    <span class="s2">return </span><span class="s1">res</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">data_for_twos(request):</span>
    <span class="s2">return </span><span class="s1">SparseArray(np.ones(</span><span class="s3">100</span><span class="s1">) * </span><span class="s3">2</span><span class="s1">)</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s3">0</span><span class="s2">, </span><span class="s1">np.nan])</span>
<span class="s2">def </span><span class="s1">data_missing(request):</span>
    <span class="s0">&quot;&quot;&quot;Length 2 array with [NA, Valid]&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">SparseArray([np.nan</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fill_value=request.param)</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s3">0</span><span class="s2">, </span><span class="s1">np.nan])</span>
<span class="s2">def </span><span class="s1">data_repeated(request):</span>
    <span class="s0">&quot;&quot;&quot;Return different versions of data for count times&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">gen(count):</span>
        <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(count):</span>
            <span class="s2">yield </span><span class="s1">SparseArray(make_data(request.param)</span><span class="s2">, </span><span class="s1">fill_value=request.param)</span>

    <span class="s2">yield </span><span class="s1">gen</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s3">0</span><span class="s2">, </span><span class="s1">np.nan])</span>
<span class="s2">def </span><span class="s1">data_for_sorting(request):</span>
    <span class="s2">return </span><span class="s1">SparseArray([</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fill_value=request.param)</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s3">0</span><span class="s2">, </span><span class="s1">np.nan])</span>
<span class="s2">def </span><span class="s1">data_missing_for_sorting(request):</span>
    <span class="s2">return </span><span class="s1">SparseArray([</span><span class="s3">2</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fill_value=request.param)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">na_value():</span>
    <span class="s2">return </span><span class="s1">np.nan</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">na_cmp():</span>
    <span class="s2">return lambda </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right: pd.isna(left) </span><span class="s2">and </span><span class="s1">pd.isna(right)</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s3">0</span><span class="s2">, </span><span class="s1">np.nan])</span>
<span class="s2">def </span><span class="s1">data_for_grouping(request):</span>
    <span class="s2">return </span><span class="s1">SparseArray([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fill_value=request.param)</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s3">0</span><span class="s2">, </span><span class="s1">np.nan])</span>
<span class="s2">def </span><span class="s1">data_for_compare(request):</span>
    <span class="s2">return </span><span class="s1">SparseArray([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">-</span><span class="s3">2</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fill_value=request.param)</span>


<span class="s2">class </span><span class="s1">BaseSparseTests:</span>
    <span class="s2">def </span><span class="s1">_check_unsupported(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s2">if </span><span class="s1">data.dtype == SparseDtype(int</span><span class="s2">, </span><span class="s3">0</span><span class="s1">):</span>
            <span class="s1">pytest.skip(</span><span class="s4">&quot;Can't store nan in int array.&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s4">&quot;SparseArray does not support setitem&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_ravel(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">super().test_ravel(data)</span>


<span class="s2">class </span><span class="s1">TestDtype(BaseSparseTests</span><span class="s2">, </span><span class="s1">base.BaseDtypeTests):</span>
    <span class="s2">def </span><span class="s1">test_array_type_with_arg(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s2">assert </span><span class="s1">dtype.construct_array_type() </span><span class="s2">is </span><span class="s1">SparseArray</span>


<span class="s2">class </span><span class="s1">TestInterface(BaseSparseTests</span><span class="s2">, </span><span class="s1">base.BaseInterfaceTests):</span>
    <span class="s2">def </span><span class="s1">test_copy(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s5"># __setitem__ does not work, so we only have a smoke-test</span>
        <span class="s1">data.copy()</span>

    <span class="s2">def </span><span class="s1">test_view(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s5"># __setitem__ does not work, so we only have a smoke-test</span>
        <span class="s1">data.view()</span>


<span class="s2">class </span><span class="s1">TestConstructors(BaseSparseTests</span><span class="s2">, </span><span class="s1">base.BaseConstructorsTests):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestReshaping(BaseSparseTests</span><span class="s2">, </span><span class="s1">base.BaseReshapingTests):</span>
    <span class="s2">def </span><span class="s1">test_concat_mixed_dtypes(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s5"># https://github.com/pandas-dev/pandas/issues/20762</span>
        <span class="s5"># This should be the same, aside from concat([sparse, float])</span>
        <span class="s1">df1 = pd.DataFrame({</span><span class="s4">&quot;A&quot;</span><span class="s1">: data[:</span><span class="s3">3</span><span class="s1">]})</span>
        <span class="s1">df2 = pd.DataFrame({</span><span class="s4">&quot;A&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]})</span>
        <span class="s1">df3 = pd.DataFrame({</span><span class="s4">&quot;A&quot;</span><span class="s1">: [</span><span class="s4">&quot;a&quot;</span><span class="s2">, </span><span class="s4">&quot;b&quot;</span><span class="s2">, </span><span class="s4">&quot;c&quot;</span><span class="s1">]}).astype(</span><span class="s4">&quot;category&quot;</span><span class="s1">)</span>
        <span class="s1">dfs = [df1</span><span class="s2">, </span><span class="s1">df2</span><span class="s2">, </span><span class="s1">df3]</span>

        <span class="s5"># dataframes</span>
        <span class="s1">result = pd.concat(dfs)</span>
        <span class="s1">expected = pd.concat(</span>
            <span class="s1">[x.apply(</span><span class="s2">lambda </span><span class="s1">s: np.asarray(s).astype(object)) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dfs]</span>
        <span class="s1">)</span>
        <span class="s1">self.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_concat_columns(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value):</span>
        <span class="s1">self._check_unsupported(data)</span>
        <span class="s1">super().test_concat_columns(data</span><span class="s2">, </span><span class="s1">na_value)</span>

    <span class="s2">def </span><span class="s1">test_concat_extension_arrays_copy_false(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value):</span>
        <span class="s1">self._check_unsupported(data)</span>
        <span class="s1">super().test_concat_extension_arrays_copy_false(data</span><span class="s2">, </span><span class="s1">na_value)</span>

    <span class="s2">def </span><span class="s1">test_align(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value):</span>
        <span class="s1">self._check_unsupported(data)</span>
        <span class="s1">super().test_align(data</span><span class="s2">, </span><span class="s1">na_value)</span>

    <span class="s2">def </span><span class="s1">test_align_frame(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value):</span>
        <span class="s1">self._check_unsupported(data)</span>
        <span class="s1">super().test_align_frame(data</span><span class="s2">, </span><span class="s1">na_value)</span>

    <span class="s2">def </span><span class="s1">test_align_series_frame(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value):</span>
        <span class="s1">self._check_unsupported(data)</span>
        <span class="s1">super().test_align_series_frame(data</span><span class="s2">, </span><span class="s1">na_value)</span>

    <span class="s2">def </span><span class="s1">test_merge(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value):</span>
        <span class="s1">self._check_unsupported(data)</span>
        <span class="s1">super().test_merge(data</span><span class="s2">, </span><span class="s1">na_value)</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s4">&quot;SparseArray does not support setitem&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_transpose(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">super().test_transpose(data)</span>


<span class="s2">class </span><span class="s1">TestGetitem(BaseSparseTests</span><span class="s2">, </span><span class="s1">base.BaseGetitemTests):</span>
    <span class="s2">def </span><span class="s1">test_get(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">ser = pd.Series(data</span><span class="s2">, </span><span class="s1">index=[</span><span class="s3">2 </span><span class="s1">* i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(data))])</span>
        <span class="s2">if </span><span class="s1">np.isnan(ser.values.fill_value):</span>
            <span class="s2">assert </span><span class="s1">np.isnan(ser.get(</span><span class="s3">4</span><span class="s1">)) </span><span class="s2">and </span><span class="s1">np.isnan(ser.iloc[</span><span class="s3">2</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">ser.get(</span><span class="s3">4</span><span class="s1">) == ser.iloc[</span><span class="s3">2</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">ser.get(</span><span class="s3">2</span><span class="s1">) == ser.iloc[</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">test_reindex(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value):</span>
        <span class="s1">self._check_unsupported(data)</span>
        <span class="s1">super().test_reindex(data</span><span class="s2">, </span><span class="s1">na_value)</span>


<span class="s5"># Skipping TestSetitem, since we don't implement it.</span>


<span class="s2">class </span><span class="s1">TestIndex(base.BaseIndexTests):</span>
    <span class="s2">def </span><span class="s1">test_index_from_array(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">msg = </span><span class="s4">&quot;will store that array directly&quot;</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">idx = pd.Index(data)</span>

        <span class="s2">if </span><span class="s1">data.dtype.subtype == </span><span class="s4">&quot;f&quot;</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">idx.dtype == np.float64</span>
        <span class="s2">elif </span><span class="s1">data.dtype.subtype == </span><span class="s4">&quot;i&quot;</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">idx.dtype == np.int64</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">idx.dtype == data.dtype.subtype</span>

    <span class="s5"># TODO(2.0): should pass once SparseArray is stored directly in Index.</span>
    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s4">&quot;Index cannot yet store sparse dtype&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_index_from_listlike_with_dtype(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">msg = </span><span class="s4">&quot;passing a SparseArray to pd.Index&quot;</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">super().test_index_from_listlike_with_dtype(data)</span>


<span class="s2">class </span><span class="s1">TestMissing(BaseSparseTests</span><span class="s2">, </span><span class="s1">base.BaseMissingTests):</span>
    <span class="s2">def </span><span class="s1">test_isna(self</span><span class="s2">, </span><span class="s1">data_missing):</span>
        <span class="s1">sarr = SparseArray(data_missing)</span>
        <span class="s1">expected_dtype = SparseDtype(bool</span><span class="s2">, </span><span class="s1">pd.isna(data_missing.dtype.fill_value))</span>
        <span class="s1">expected = SparseArray([</span><span class="s2">True, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=expected_dtype)</span>
        <span class="s1">result = sarr.isna()</span>
        <span class="s1">tm.assert_sp_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s5"># test isna for arr without na</span>
        <span class="s1">sarr = sarr.fillna(</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">expected_dtype = SparseDtype(bool</span><span class="s2">, </span><span class="s1">pd.isna(data_missing.dtype.fill_value))</span>
        <span class="s1">expected = SparseArray([</span><span class="s2">False, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fill_value=</span><span class="s2">False, </span><span class="s1">dtype=expected_dtype)</span>
        <span class="s1">self.assert_equal(sarr.isna()</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_fillna_limit_pad(self</span><span class="s2">, </span><span class="s1">data_missing):</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">super().test_fillna_limit_pad(data_missing)</span>

    <span class="s2">def </span><span class="s1">test_fillna_limit_backfill(self</span><span class="s2">, </span><span class="s1">data_missing):</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">super().test_fillna_limit_backfill(data_missing)</span>

    <span class="s2">def </span><span class="s1">test_fillna_no_op_returns_copy(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s2">if </span><span class="s1">np.isnan(data.fill_value):</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(reason=</span><span class="s4">&quot;returns array with different fill value&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">super().test_fillna_no_op_returns_copy(data)</span>

    <span class="s2">def </span><span class="s1">test_fillna_series_method(self</span><span class="s2">, </span><span class="s1">data_missing):</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">super().test_fillna_limit_backfill(data_missing)</span>

    <span class="s1">@pytest.mark.skip(reason=</span><span class="s4">&quot;Unsupported&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_fillna_series(self):</span>
        <span class="s5"># this one looks doable.</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_fillna_frame(self</span><span class="s2">, </span><span class="s1">data_missing):</span>
        <span class="s5"># Have to override to specify that fill_value will change.</span>
        <span class="s1">fill_value = data_missing[</span><span class="s3">1</span><span class="s1">]</span>

        <span class="s1">result = pd.DataFrame({</span><span class="s4">&quot;A&quot;</span><span class="s1">: data_missing</span><span class="s2">, </span><span class="s4">&quot;B&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]}).fillna(fill_value)</span>

        <span class="s2">if </span><span class="s1">pd.isna(data_missing.fill_value):</span>
            <span class="s1">dtype = SparseDtype(data_missing.dtype</span><span class="s2">, </span><span class="s1">fill_value)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dtype = data_missing.dtype</span>

        <span class="s1">expected = pd.DataFrame(</span>
            <span class="s1">{</span>
                <span class="s4">&quot;A&quot;</span><span class="s1">: data_missing._from_sequence([fill_value</span><span class="s2">, </span><span class="s1">fill_value]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span><span class="s2">,</span>
                <span class="s4">&quot;B&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

        <span class="s1">self.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestMethods(BaseSparseTests</span><span class="s2">, </span><span class="s1">base.BaseMethodsTests):</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;ascending&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_sort_values_frame(self</span><span class="s2">, </span><span class="s1">data_for_sorting</span><span class="s2">, </span><span class="s1">ascending):</span>
        <span class="s1">msg = </span><span class="s4">&quot;will store that array directly&quot;</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(</span>
            <span class="s1">FutureWarning</span><span class="s2">, </span><span class="s1">match=msg</span><span class="s2">, </span><span class="s1">check_stacklevel=</span><span class="s2">False</span>
        <span class="s1">):</span>
            <span class="s1">super().test_sort_values_frame(data_for_sorting</span><span class="s2">, </span><span class="s1">ascending)</span>

    <span class="s2">def </span><span class="s1">test_combine_le(self</span><span class="s2">, </span><span class="s1">data_repeated):</span>
        <span class="s5"># We return a Series[SparseArray].__le__ returns a</span>
        <span class="s5"># Series[Sparse[bool]]</span>
        <span class="s5"># rather than Series[bool]</span>
        <span class="s1">orig_data1</span><span class="s2">, </span><span class="s1">orig_data2 = data_repeated(</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">s1 = pd.Series(orig_data1)</span>
        <span class="s1">s2 = pd.Series(orig_data2)</span>
        <span class="s1">result = s1.combine(s2</span><span class="s2">, lambda </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2: x1 &lt;= x2)</span>
        <span class="s1">expected = pd.Series(</span>
            <span class="s1">SparseArray(</span>
                <span class="s1">[a &lt;= b </span><span class="s2">for </span><span class="s1">(a</span><span class="s2">, </span><span class="s1">b) </span><span class="s2">in </span><span class="s1">zip(list(orig_data1)</span><span class="s2">, </span><span class="s1">list(orig_data2))]</span><span class="s2">,</span>
                <span class="s1">fill_value=</span><span class="s2">False,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">self.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">val = s1.iloc[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">result = s1.combine(val</span><span class="s2">, lambda </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2: x1 &lt;= x2)</span>
        <span class="s1">expected = pd.Series(</span>
            <span class="s1">SparseArray([a &lt;= val </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">list(orig_data1)]</span><span class="s2">, </span><span class="s1">fill_value=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">self.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_fillna_copy_frame(self</span><span class="s2">, </span><span class="s1">data_missing):</span>
        <span class="s1">arr = data_missing.take([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s4">&quot;A&quot;</span><span class="s1">: arr}</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">filled_val = df.iloc[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">result = df.fillna(filled_val)</span>

        <span class="s2">if </span><span class="s1">hasattr(df._mgr</span><span class="s2">, </span><span class="s4">&quot;blocks&quot;</span><span class="s1">):</span>
            <span class="s2">assert </span><span class="s1">df.values.base </span><span class="s2">is not </span><span class="s1">result.values.base</span>
        <span class="s2">assert </span><span class="s1">df.A._values.to_dense() </span><span class="s2">is </span><span class="s1">arr.to_dense()</span>

    <span class="s2">def </span><span class="s1">test_fillna_copy_series(self</span><span class="s2">, </span><span class="s1">data_missing):</span>
        <span class="s1">arr = data_missing.take([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">ser = pd.Series(arr)</span>

        <span class="s1">filled_val = ser[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">result = ser.fillna(filled_val)</span>

        <span class="s2">assert </span><span class="s1">ser._values </span><span class="s2">is not </span><span class="s1">result._values</span>
        <span class="s2">assert </span><span class="s1">ser._values.to_dense() </span><span class="s2">is </span><span class="s1">arr.to_dense()</span>

    <span class="s1">@pytest.mark.skip(reason=</span><span class="s4">&quot;Not Applicable&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_fillna_length_mismatch(self</span><span class="s2">, </span><span class="s1">data_missing):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_where_series(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value):</span>
        <span class="s2">assert </span><span class="s1">data[</span><span class="s3">0</span><span class="s1">] != data[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">cls = type(data)</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b = data[:</span><span class="s3">2</span><span class="s1">]</span>

        <span class="s1">ser = pd.Series(cls._from_sequence([a</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">b]</span><span class="s2">, </span><span class="s1">dtype=data.dtype))</span>

        <span class="s1">cond = np.array([</span><span class="s2">True, True, False, False</span><span class="s1">])</span>
        <span class="s1">result = ser.where(cond)</span>

        <span class="s1">new_dtype = SparseDtype(</span><span class="s4">&quot;float&quot;</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">)</span>
        <span class="s1">expected = pd.Series(</span>
            <span class="s1">cls._from_sequence([a</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">, </span><span class="s1">na_value]</span><span class="s2">, </span><span class="s1">dtype=new_dtype)</span>
        <span class="s1">)</span>
        <span class="s1">self.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">other = cls._from_sequence([a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b]</span><span class="s2">, </span><span class="s1">dtype=data.dtype)</span>
        <span class="s1">cond = np.array([</span><span class="s2">True, False, True, True</span><span class="s1">])</span>
        <span class="s1">result = ser.where(cond</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">expected = pd.Series(cls._from_sequence([a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">b]</span><span class="s2">, </span><span class="s1">dtype=data.dtype))</span>
        <span class="s1">self.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_combine_first(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s2">if </span><span class="s1">data.dtype.subtype == </span><span class="s4">&quot;int&quot;</span><span class="s1">:</span>
            <span class="s5"># Right now this is upcasted to float, just like combine_first</span>
            <span class="s5"># for Series[int]</span>
            <span class="s1">mark = pytest.mark.xfail(</span>
                <span class="s1">reason=</span><span class="s4">&quot;TODO(SparseArray.__setitem__) will preserve dtype.&quot;</span>
            <span class="s1">)</span>
            <span class="s1">request.node.add_marker(mark)</span>
        <span class="s1">super().test_combine_first(data)</span>

    <span class="s2">def </span><span class="s1">test_searchsorted(self</span><span class="s2">, </span><span class="s1">data_for_sorting</span><span class="s2">, </span><span class="s1">as_series):</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
            <span class="s1">super().test_searchsorted(data_for_sorting</span><span class="s2">, </span><span class="s1">as_series)</span>

    <span class="s2">def </span><span class="s1">test_shift_0_periods(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s5"># GH#33856 shifting with periods=0 should return a copy, not same obj</span>
        <span class="s1">result = data.shift(</span><span class="s3">0</span><span class="s1">)</span>

        <span class="s1">data._sparse_values[</span><span class="s3">0</span><span class="s1">] = data._sparse_values[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">result._sparse_values[</span><span class="s3">0</span><span class="s1">] != result._sparse_values[</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;method&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">&quot;argmax&quot;</span><span class="s2">, </span><span class="s4">&quot;argmin&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_argmin_argmax_all_na(self</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value):</span>
        <span class="s5"># overriding because Sparse[int64, 0] cannot handle na_value</span>
        <span class="s1">self._check_unsupported(data)</span>
        <span class="s1">super().test_argmin_argmax_all_na(method</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;box&quot;</span><span class="s2">, </span><span class="s1">[pd.array</span><span class="s2">, </span><span class="s1">pd.Series</span><span class="s2">, </span><span class="s1">pd.DataFrame])</span>
    <span class="s2">def </span><span class="s1">test_equals(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">, </span><span class="s1">as_series</span><span class="s2">, </span><span class="s1">box):</span>
        <span class="s1">self._check_unsupported(data)</span>
        <span class="s1">super().test_equals(data</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">, </span><span class="s1">as_series</span><span class="s2">, </span><span class="s1">box)</span>


<span class="s2">class </span><span class="s1">TestCasting(BaseSparseTests</span><span class="s2">, </span><span class="s1">base.BaseCastingTests):</span>
    <span class="s2">def </span><span class="s1">test_astype_object_series(self</span><span class="s2">, </span><span class="s1">all_data):</span>
        <span class="s5"># Unlike the base class, we do not expect the resulting Block</span>
        <span class="s5">#  to be ObjectBlock / resulting array to be np.dtype(&quot;object&quot;)</span>
        <span class="s1">ser = pd.Series(all_data</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">result = ser.astype(object)</span>
        <span class="s2">assert </span><span class="s1">is_object_dtype(result.dtype)</span>
        <span class="s2">assert </span><span class="s1">is_object_dtype(result._mgr.array.dtype)</span>

    <span class="s2">def </span><span class="s1">test_astype_object_frame(self</span><span class="s2">, </span><span class="s1">all_data):</span>
        <span class="s5"># Unlike the base class, we do not expect the resulting Block</span>
        <span class="s5">#  to be ObjectBlock / resulting array to be np.dtype(&quot;object&quot;)</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s4">&quot;A&quot;</span><span class="s1">: all_data})</span>

        <span class="s1">result = df.astype(object)</span>
        <span class="s2">assert </span><span class="s1">is_object_dtype(result._mgr.arrays[</span><span class="s3">0</span><span class="s1">].dtype)</span>

        <span class="s5"># earlier numpy raises TypeError on e.g. np.dtype(np.int64) == &quot;Int64&quot;</span>
        <span class="s5">#  instead of returning False</span>
        <span class="s2">if not </span><span class="s1">np_version_under1p20:</span>
            <span class="s5"># check that we can compare the dtypes</span>
            <span class="s1">comp = result.dtypes == df.dtypes</span>
            <span class="s2">assert not </span><span class="s1">comp.any()</span>

    <span class="s2">def </span><span class="s1">test_astype_str(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">result = pd.Series(data[:</span><span class="s3">5</span><span class="s1">]).astype(str)</span>
        <span class="s1">expected_dtype = SparseDtype(str</span><span class="s2">, </span><span class="s1">str(data.fill_value))</span>
        <span class="s1">expected = pd.Series([str(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">data[:</span><span class="s3">5</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=expected_dtype)</span>
        <span class="s1">self.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.xfail(raises=TypeError</span><span class="s2">, </span><span class="s1">reason=</span><span class="s4">&quot;no sparse StringDtype&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_astype_string(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">super().test_astype_string(data)</span>


<span class="s2">class </span><span class="s1">TestArithmeticOps(BaseSparseTests</span><span class="s2">, </span><span class="s1">base.BaseArithmeticOpsTests):</span>
    <span class="s1">series_scalar_exc = </span><span class="s2">None</span>
    <span class="s1">frame_scalar_exc = </span><span class="s2">None</span>
    <span class="s1">divmod_exc = </span><span class="s2">None</span>
    <span class="s1">series_array_exc = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_skip_if_different_combine(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s2">if </span><span class="s1">data.fill_value == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s5"># arith ops call on dtype.fill_value so that the sparsity</span>
            <span class="s5"># is maintained. Combine can't be called on a dtype in</span>
            <span class="s5"># general, so we can't make the expected. This is tested elsewhere</span>
            <span class="s2">raise </span><span class="s1">pytest.skip(</span><span class="s4">&quot;Incorrected expected from Series.combine&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_arith_series_with_scalar(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators):</span>
        <span class="s1">self._skip_if_different_combine(data)</span>
        <span class="s1">super().test_arith_series_with_scalar(data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators)</span>

    <span class="s2">def </span><span class="s1">test_arith_series_with_array(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators):</span>
        <span class="s1">self._skip_if_different_combine(data)</span>
        <span class="s1">super().test_arith_series_with_array(data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators)</span>

    <span class="s2">def </span><span class="s1">test_arith_frame_with_scalar(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s2">if </span><span class="s1">data.dtype.fill_value != </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">pass</span>
        <span class="s2">elif </span><span class="s1">all_arithmetic_operators.strip(</span><span class="s4">&quot;_&quot;</span><span class="s1">) </span><span class="s2">not in </span><span class="s1">[</span>
            <span class="s4">&quot;mul&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;rmul&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;floordiv&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;rfloordiv&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;pow&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;mod&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;rmod&quot;</span><span class="s2">,</span>
        <span class="s1">]:</span>
            <span class="s1">mark = pytest.mark.xfail(reason=</span><span class="s4">&quot;result dtype.fill_value mismatch&quot;</span><span class="s1">)</span>
            <span class="s1">request.node.add_marker(mark)</span>
        <span class="s1">super().test_arith_frame_with_scalar(data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators)</span>

    <span class="s2">def </span><span class="s1">_check_divmod_op(self</span><span class="s2">, </span><span class="s1">ser</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">exc=NotImplementedError):</span>
        <span class="s5"># We implement divmod</span>
        <span class="s1">super()._check_divmod_op(ser</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">exc=</span><span class="s2">None</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestComparisonOps(BaseSparseTests):</span>
    <span class="s2">def </span><span class="s1">_compare_other(self</span><span class="s2">, </span><span class="s1">data_for_compare: SparseArray</span><span class="s2">, </span><span class="s1">comparison_op</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s1">op = comparison_op</span>

        <span class="s1">result = op(data_for_compare</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">SparseArray)</span>
        <span class="s2">assert </span><span class="s1">result.dtype.subtype == np.bool_</span>

        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">SparseArray):</span>
            <span class="s1">fill_value = op(data_for_compare.fill_value</span><span class="s2">, </span><span class="s1">other.fill_value)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">fill_value = np.all(</span>
                <span class="s1">op(np.asarray(data_for_compare.fill_value)</span><span class="s2">, </span><span class="s1">np.asarray(other))</span>
            <span class="s1">)</span>

            <span class="s1">expected = SparseArray(</span>
                <span class="s1">op(data_for_compare.to_dense()</span><span class="s2">, </span><span class="s1">np.asarray(other))</span><span class="s2">,</span>
                <span class="s1">fill_value=fill_value</span><span class="s2">,</span>
                <span class="s1">dtype=np.bool_</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">tm.assert_sp_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_scalar(self</span><span class="s2">, </span><span class="s1">data_for_compare: SparseArray</span><span class="s2">, </span><span class="s1">comparison_op):</span>
        <span class="s1">self._compare_other(data_for_compare</span><span class="s2">, </span><span class="s1">comparison_op</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">self._compare_other(data_for_compare</span><span class="s2">, </span><span class="s1">comparison_op</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">self._compare_other(data_for_compare</span><span class="s2">, </span><span class="s1">comparison_op</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">self._compare_other(data_for_compare</span><span class="s2">, </span><span class="s1">comparison_op</span><span class="s2">, </span><span class="s1">np.nan)</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s4">&quot;Wrong indices&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_array(self</span><span class="s2">, </span><span class="s1">data_for_compare: SparseArray</span><span class="s2">, </span><span class="s1">comparison_op):</span>
        <span class="s1">arr = np.linspace(-</span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">self._compare_other(data_for_compare</span><span class="s2">, </span><span class="s1">comparison_op</span><span class="s2">, </span><span class="s1">arr)</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s4">&quot;Wrong indices&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_sparse_array(self</span><span class="s2">, </span><span class="s1">data_for_compare: SparseArray</span><span class="s2">, </span><span class="s1">comparison_op):</span>
        <span class="s1">arr = data_for_compare + </span><span class="s3">1</span>
        <span class="s1">self._compare_other(data_for_compare</span><span class="s2">, </span><span class="s1">comparison_op</span><span class="s2">, </span><span class="s1">arr)</span>
        <span class="s1">arr = data_for_compare * </span><span class="s3">2</span>
        <span class="s1">self._compare_other(data_for_compare</span><span class="s2">, </span><span class="s1">comparison_op</span><span class="s2">, </span><span class="s1">arr)</span>


<span class="s2">class </span><span class="s1">TestPrinting(BaseSparseTests</span><span class="s2">, </span><span class="s1">base.BasePrintingTests):</span>
    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s4">&quot;Different repr&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_array_repr(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">size):</span>
        <span class="s1">super().test_array_repr(data</span><span class="s2">, </span><span class="s1">size)</span>


<span class="s2">class </span><span class="s1">TestParsing(BaseSparseTests</span><span class="s2">, </span><span class="s1">base.BaseParsingTests):</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;engine&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">&quot;c&quot;</span><span class="s2">, </span><span class="s4">&quot;python&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_EA_types(self</span><span class="s2">, </span><span class="s1">engine</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">expected_msg = </span><span class="s4">r&quot;.*must implement _from_sequence_of_strings.*&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s2">, </span><span class="s1">match=expected_msg):</span>
            <span class="s1">super().test_EA_types(engine</span><span class="s2">, </span><span class="s1">data)</span>
</pre>
</body>
</html>