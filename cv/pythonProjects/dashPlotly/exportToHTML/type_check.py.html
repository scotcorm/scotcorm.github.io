<html>
<head>
<title>type_check.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
type_check.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Automatically adapted for numpy Sep 19, 2005 by convertcode.py 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s1">__all__ = [</span><span class="s3">'iscomplexobj'</span><span class="s2">, </span><span class="s3">'isrealobj'</span><span class="s2">, </span><span class="s3">'imag'</span><span class="s2">, </span><span class="s3">'iscomplex'</span><span class="s2">,</span>
           <span class="s3">'isreal'</span><span class="s2">, </span><span class="s3">'nan_to_num'</span><span class="s2">, </span><span class="s3">'real'</span><span class="s2">, </span><span class="s3">'real_if_close'</span><span class="s2">,</span>
           <span class="s3">'typename'</span><span class="s2">, </span><span class="s3">'asfarray'</span><span class="s2">, </span><span class="s3">'mintypecode'</span><span class="s2">, </span><span class="s3">'asscalar'</span><span class="s2">,</span>
           <span class="s3">'common_type'</span><span class="s1">]</span>

<span class="s2">import </span><span class="s1">numpy.core.numeric </span><span class="s2">as </span><span class="s1">_nx</span>
<span class="s2">from </span><span class="s1">numpy.core.numeric </span><span class="s2">import </span><span class="s1">asarray</span><span class="s2">, </span><span class="s1">asanyarray</span><span class="s2">, </span><span class="s1">isnan</span><span class="s2">, </span><span class="s1">zeros</span>
<span class="s2">from </span><span class="s1">numpy.core.overrides </span><span class="s2">import </span><span class="s1">set_module</span>
<span class="s2">from </span><span class="s1">numpy.core </span><span class="s2">import </span><span class="s1">overrides</span>
<span class="s2">from </span><span class="s1">.ufunclike </span><span class="s2">import </span><span class="s1">isneginf</span><span class="s2">, </span><span class="s1">isposinf</span>


<span class="s1">array_function_dispatch = functools.partial(</span>
    <span class="s1">overrides.array_function_dispatch</span><span class="s2">, </span><span class="s1">module=</span><span class="s3">'numpy'</span><span class="s1">)</span>


<span class="s1">_typecodes_by_elsize = </span><span class="s3">'GDFgdfQqLlIiHhBb?'</span>


<span class="s1">@set_module(</span><span class="s3">'numpy'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">mintypecode(typechars</span><span class="s2">, </span><span class="s1">typeset=</span><span class="s3">'GDFgdf'</span><span class="s2">, </span><span class="s1">default=</span><span class="s3">'d'</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the character for the minimum-size type to which given types can 
    be safely cast. 
 
    The returned type character must represent the smallest size dtype such 
    that an array of the returned type can handle the data from an array of 
    all types in `typechars` (or if `typechars` is an array, then its 
    dtype.char). 
 
    Parameters 
    ---------- 
    typechars : list of str or array_like 
        If a list of strings, each string should represent a dtype. 
        If array_like, the character representation of the array dtype is used. 
    typeset : str or list of str, optional 
        The set of characters that the returned character is chosen from. 
        The default set is 'GDFgdf'. 
    default : str, optional 
        The default character, this is returned if none of the characters in 
        `typechars` matches a character in `typeset`. 
 
    Returns 
    ------- 
    typechar : str 
        The character representing the minimum-size type that was found. 
 
    See Also 
    -------- 
    dtype, sctype2char, maximum_sctype 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.mintypecode(['d', 'f', 'S']) 
    'd' 
    &gt;&gt;&gt; x = np.array([1.1, 2-3.j]) 
    &gt;&gt;&gt; np.mintypecode(x) 
    'D' 
 
    &gt;&gt;&gt; np.mintypecode('abceh', default='G') 
    'G' 
 
    &quot;&quot;&quot;</span>
    <span class="s1">typecodes = ((isinstance(t</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">t) </span><span class="s2">or </span><span class="s1">asarray(t).dtype.char</span>
                 <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">typechars)</span>
    <span class="s1">intersection = set(t </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">typecodes </span><span class="s2">if </span><span class="s1">t </span><span class="s2">in </span><span class="s1">typeset)</span>
    <span class="s2">if not </span><span class="s1">intersection:</span>
        <span class="s2">return </span><span class="s1">default</span>
    <span class="s2">if </span><span class="s3">'F' </span><span class="s2">in </span><span class="s1">intersection </span><span class="s2">and </span><span class="s3">'d' </span><span class="s2">in </span><span class="s1">intersection:</span>
        <span class="s2">return </span><span class="s3">'D'</span>
    <span class="s2">return </span><span class="s1">min(intersection</span><span class="s2">, </span><span class="s1">key=_typecodes_by_elsize.index)</span>


<span class="s2">def </span><span class="s1">_asfarray_dispatcher(a</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_asfarray_dispatcher)</span>
<span class="s2">def </span><span class="s1">asfarray(a</span><span class="s2">, </span><span class="s1">dtype=_nx.float_):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return an array converted to a float type. 
 
    Parameters 
    ---------- 
    a : array_like 
        The input array. 
    dtype : str or dtype object, optional 
        Float type code to coerce input array `a`.  If `dtype` is one of the 
        'int' dtypes, it is replaced with float64. 
 
    Returns 
    ------- 
    out : ndarray 
        The input `a` as a float ndarray. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.asfarray([2, 3]) 
    array([2.,  3.]) 
    &gt;&gt;&gt; np.asfarray([2, 3], dtype='float') 
    array([2.,  3.]) 
    &gt;&gt;&gt; np.asfarray([2, 3], dtype='int8') 
    array([2.,  3.]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">_nx.issubdtype(dtype</span><span class="s2">, </span><span class="s1">_nx.inexact):</span>
        <span class="s1">dtype = _nx.float_</span>
    <span class="s2">return </span><span class="s1">asarray(a</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>


<span class="s2">def </span><span class="s1">_real_dispatcher(val):</span>
    <span class="s2">return </span><span class="s1">(val</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_real_dispatcher)</span>
<span class="s2">def </span><span class="s1">real(val):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the real part of the complex argument. 
 
    Parameters 
    ---------- 
    val : array_like 
        Input array. 
 
    Returns 
    ------- 
    out : ndarray or scalar 
        The real component of the complex argument. If `val` is real, the type 
        of `val` is used for the output.  If `val` has complex elements, the 
        returned type is float. 
 
    See Also 
    -------- 
    real_if_close, imag, angle 
 
    Examples 
    -------- 
    &gt;&gt;&gt; a = np.array([1+2j, 3+4j, 5+6j]) 
    &gt;&gt;&gt; a.real 
    array([1.,  3.,  5.]) 
    &gt;&gt;&gt; a.real = 9 
    &gt;&gt;&gt; a 
    array([9.+2.j,  9.+4.j,  9.+6.j]) 
    &gt;&gt;&gt; a.real = np.array([9, 8, 7]) 
    &gt;&gt;&gt; a 
    array([9.+2.j,  8.+4.j,  7.+6.j]) 
    &gt;&gt;&gt; np.real(1 + 1j) 
    1.0 
 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">val.real</span>
    <span class="s2">except </span><span class="s1">AttributeError:</span>
        <span class="s2">return </span><span class="s1">asanyarray(val).real</span>


<span class="s2">def </span><span class="s1">_imag_dispatcher(val):</span>
    <span class="s2">return </span><span class="s1">(val</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_imag_dispatcher)</span>
<span class="s2">def </span><span class="s1">imag(val):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the imaginary part of the complex argument. 
 
    Parameters 
    ---------- 
    val : array_like 
        Input array. 
 
    Returns 
    ------- 
    out : ndarray or scalar 
        The imaginary component of the complex argument. If `val` is real, 
        the type of `val` is used for the output.  If `val` has complex 
        elements, the returned type is float. 
 
    See Also 
    -------- 
    real, angle, real_if_close 
 
    Examples 
    -------- 
    &gt;&gt;&gt; a = np.array([1+2j, 3+4j, 5+6j]) 
    &gt;&gt;&gt; a.imag 
    array([2.,  4.,  6.]) 
    &gt;&gt;&gt; a.imag = np.array([8, 10, 12]) 
    &gt;&gt;&gt; a 
    array([1. +8.j,  3.+10.j,  5.+12.j]) 
    &gt;&gt;&gt; np.imag(1 + 1j) 
    1.0 
 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">val.imag</span>
    <span class="s2">except </span><span class="s1">AttributeError:</span>
        <span class="s2">return </span><span class="s1">asanyarray(val).imag</span>


<span class="s2">def </span><span class="s1">_is_type_dispatcher(x):</span>
    <span class="s2">return </span><span class="s1">(x</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_is_type_dispatcher)</span>
<span class="s2">def </span><span class="s1">iscomplex(x):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a bool array, where True if input element is complex. 
 
    What is tested is whether the input has a non-zero imaginary part, not if 
    the input type is complex. 
 
    Parameters 
    ---------- 
    x : array_like 
        Input array. 
 
    Returns 
    ------- 
    out : ndarray of bools 
        Output array. 
 
    See Also 
    -------- 
    isreal 
    iscomplexobj : Return True if x is a complex type or an array of complex 
                   numbers. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j]) 
    array([ True, False, False, False, False,  True]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">ax = asanyarray(x)</span>
    <span class="s2">if </span><span class="s1">issubclass(ax.dtype.type</span><span class="s2">, </span><span class="s1">_nx.complexfloating):</span>
        <span class="s2">return </span><span class="s1">ax.imag != </span><span class="s4">0</span>
    <span class="s1">res = zeros(ax.shape</span><span class="s2">, </span><span class="s1">bool)</span>
    <span class="s2">return </span><span class="s1">res[()]   </span><span class="s5"># convert to scalar if needed</span>


<span class="s1">@array_function_dispatch(_is_type_dispatcher)</span>
<span class="s2">def </span><span class="s1">isreal(x):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a bool array, where True if input element is real. 
 
    If element has complex type with zero complex part, the return value 
    for that element is True. 
 
    Parameters 
    ---------- 
    x : array_like 
        Input array. 
 
    Returns 
    ------- 
    out : ndarray, bool 
        Boolean array of same shape as `x`. 
 
    Notes 
    ----- 
    `isreal` may behave unexpectedly for string or object arrays (see examples) 
 
    See Also 
    -------- 
    iscomplex 
    isrealobj : Return True if x is not a complex type. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; a = np.array([1+1j, 1+0j, 4.5, 3, 2, 2j], dtype=complex) 
    &gt;&gt;&gt; np.isreal(a) 
    array([False,  True,  True,  True,  True, False]) 
     
    The function does not work on string arrays. 
 
    &gt;&gt;&gt; a = np.array([2j, &quot;a&quot;], dtype=&quot;U&quot;) 
    &gt;&gt;&gt; np.isreal(a)  # Warns about non-elementwise comparison 
    False 
     
    Returns True for all elements in input array of ``dtype=object`` even if 
    any of the elements is complex. 
 
    &gt;&gt;&gt; a = np.array([1, &quot;2&quot;, 3+4j], dtype=object) 
    &gt;&gt;&gt; np.isreal(a) 
    array([ True,  True,  True]) 
     
    isreal should not be used with object arrays 
     
    &gt;&gt;&gt; a = np.array([1+2j, 2+1j], dtype=object) 
    &gt;&gt;&gt; np.isreal(a) 
    array([ True,  True]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">imag(x) == </span><span class="s4">0</span>


<span class="s1">@array_function_dispatch(_is_type_dispatcher)</span>
<span class="s2">def </span><span class="s1">iscomplexobj(x):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check for a complex type or an array of complex numbers. 
 
    The type of the input is checked, not the value. Even if the input 
    has an imaginary part equal to zero, `iscomplexobj` evaluates to True. 
 
    Parameters 
    ---------- 
    x : any 
        The input can be of any type and shape. 
 
    Returns 
    ------- 
    iscomplexobj : bool 
        The return value, True if `x` is of a complex type or has at least 
        one complex element. 
 
    See Also 
    -------- 
    isrealobj, iscomplex 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.iscomplexobj(1) 
    False 
    &gt;&gt;&gt; np.iscomplexobj(1+0j) 
    True 
    &gt;&gt;&gt; np.iscomplexobj([3, 1+0j, True]) 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">dtype = x.dtype</span>
        <span class="s1">type_ = dtype.type</span>
    <span class="s2">except </span><span class="s1">AttributeError:</span>
        <span class="s1">type_ = asarray(x).dtype.type</span>
    <span class="s2">return </span><span class="s1">issubclass(type_</span><span class="s2">, </span><span class="s1">_nx.complexfloating)</span>


<span class="s1">@array_function_dispatch(_is_type_dispatcher)</span>
<span class="s2">def </span><span class="s1">isrealobj(x):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return True if x is a not complex type or an array of complex numbers. 
 
    The type of the input is checked, not the value. So even if the input 
    has an imaginary part equal to zero, `isrealobj` evaluates to False 
    if the data type is complex. 
 
    Parameters 
    ---------- 
    x : any 
        The input can be of any type and shape. 
 
    Returns 
    ------- 
    y : bool 
        The return value, False if `x` is of a complex type. 
 
    See Also 
    -------- 
    iscomplexobj, isreal 
 
    Notes 
    ----- 
    The function is only meant for arrays with numerical values but it 
    accepts all other objects. Since it assumes array input, the return 
    value of other objects may be True. 
 
    &gt;&gt;&gt; np.isrealobj('A string') 
    True 
    &gt;&gt;&gt; np.isrealobj(False) 
    True 
    &gt;&gt;&gt; np.isrealobj(None) 
    True 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.isrealobj(1) 
    True 
    &gt;&gt;&gt; np.isrealobj(1+0j) 
    False 
    &gt;&gt;&gt; np.isrealobj([3, 1+0j, True]) 
    False 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return not </span><span class="s1">iscomplexobj(x)</span>

<span class="s5">#-----------------------------------------------------------------------------</span>

<span class="s2">def </span><span class="s1">_getmaxmin(t):</span>
    <span class="s2">from </span><span class="s1">numpy.core </span><span class="s2">import </span><span class="s1">getlimits</span>
    <span class="s1">f = getlimits.finfo(t)</span>
    <span class="s2">return </span><span class="s1">f.max</span><span class="s2">, </span><span class="s1">f.min</span>


<span class="s2">def </span><span class="s1">_nan_to_num_dispatcher(x</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">None, </span><span class="s1">nan=</span><span class="s2">None, </span><span class="s1">posinf=</span><span class="s2">None, </span><span class="s1">neginf=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(x</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_nan_to_num_dispatcher)</span>
<span class="s2">def </span><span class="s1">nan_to_num(x</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True, </span><span class="s1">nan=</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">posinf=</span><span class="s2">None, </span><span class="s1">neginf=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Replace NaN with zero and infinity with large finite numbers (default 
    behaviour) or with the numbers defined by the user using the `nan`,  
    `posinf` and/or `neginf` keywords. 
 
    If `x` is inexact, NaN is replaced by zero or by the user defined value in 
    `nan` keyword, infinity is replaced by the largest finite floating point  
    values representable by ``x.dtype`` or by the user defined value in  
    `posinf` keyword and -infinity is replaced by the most negative finite  
    floating point values representable by ``x.dtype`` or by the user defined  
    value in `neginf` keyword. 
 
    For complex dtypes, the above is applied to each of the real and 
    imaginary components of `x` separately. 
 
    If `x` is not inexact, then no replacements are made. 
 
    Parameters 
    ---------- 
    x : scalar or array_like 
        Input data. 
    copy : bool, optional 
        Whether to create a copy of `x` (True) or to replace values 
        in-place (False). The in-place operation only occurs if 
        casting to an array does not require a copy. 
        Default is True. 
         
        .. versionadded:: 1.13 
    nan : int, float, optional 
        Value to be used to fill NaN values. If no value is passed  
        then NaN values will be replaced with 0.0. 
         
        .. versionadded:: 1.17 
    posinf : int, float, optional 
        Value to be used to fill positive infinity values. If no value is  
        passed then positive infinity values will be replaced with a very 
        large number. 
         
        .. versionadded:: 1.17 
    neginf : int, float, optional 
        Value to be used to fill negative infinity values. If no value is  
        passed then negative infinity values will be replaced with a very 
        small (or negative) number. 
         
        .. versionadded:: 1.17 
 
         
 
    Returns 
    ------- 
    out : ndarray 
        `x`, with the non-finite values replaced. If `copy` is False, this may 
        be `x` itself. 
 
    See Also 
    -------- 
    isinf : Shows which elements are positive or negative infinity. 
    isneginf : Shows which elements are negative infinity. 
    isposinf : Shows which elements are positive infinity. 
    isnan : Shows which elements are Not a Number (NaN). 
    isfinite : Shows which elements are finite (not NaN, not infinity) 
 
    Notes 
    ----- 
    NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic 
    (IEEE 754). This means that Not a Number is not equivalent to infinity. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.nan_to_num(np.inf) 
    1.7976931348623157e+308 
    &gt;&gt;&gt; np.nan_to_num(-np.inf) 
    -1.7976931348623157e+308 
    &gt;&gt;&gt; np.nan_to_num(np.nan) 
    0.0 
    &gt;&gt;&gt; x = np.array([np.inf, -np.inf, np.nan, -128, 128]) 
    &gt;&gt;&gt; np.nan_to_num(x) 
    array([ 1.79769313e+308, -1.79769313e+308,  0.00000000e+000, # may vary 
           -1.28000000e+002,  1.28000000e+002]) 
    &gt;&gt;&gt; np.nan_to_num(x, nan=-9999, posinf=33333333, neginf=33333333) 
    array([ 3.3333333e+07,  3.3333333e+07, -9.9990000e+03,  
           -1.2800000e+02,  1.2800000e+02]) 
    &gt;&gt;&gt; y = np.array([complex(np.inf, np.nan), np.nan, complex(np.nan, np.inf)]) 
    array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000, # may vary 
         -1.28000000e+002,   1.28000000e+002]) 
    &gt;&gt;&gt; np.nan_to_num(y) 
    array([  1.79769313e+308 +0.00000000e+000j, # may vary 
             0.00000000e+000 +0.00000000e+000j, 
             0.00000000e+000 +1.79769313e+308j]) 
    &gt;&gt;&gt; np.nan_to_num(y, nan=111111, posinf=222222) 
    array([222222.+111111.j, 111111.     +0.j, 111111.+222222.j]) 
    &quot;&quot;&quot;</span>
    <span class="s1">x = _nx.array(x</span><span class="s2">, </span><span class="s1">subok=</span><span class="s2">True, </span><span class="s1">copy=copy)</span>
    <span class="s1">xtype = x.dtype.type</span>

    <span class="s1">isscalar = (x.ndim == </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">if not </span><span class="s1">issubclass(xtype</span><span class="s2">, </span><span class="s1">_nx.inexact):</span>
        <span class="s2">return </span><span class="s1">x[()] </span><span class="s2">if </span><span class="s1">isscalar </span><span class="s2">else </span><span class="s1">x</span>

    <span class="s1">iscomplex = issubclass(xtype</span><span class="s2">, </span><span class="s1">_nx.complexfloating)</span>

    <span class="s1">dest = (x.real</span><span class="s2">, </span><span class="s1">x.imag) </span><span class="s2">if </span><span class="s1">iscomplex </span><span class="s2">else </span><span class="s1">(x</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">maxf</span><span class="s2">, </span><span class="s1">minf = _getmaxmin(x.real.dtype)</span>
    <span class="s2">if </span><span class="s1">posinf </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">maxf = posinf</span>
    <span class="s2">if </span><span class="s1">neginf </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">minf = neginf</span>
    <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">dest:</span>
        <span class="s1">idx_nan = isnan(d)</span>
        <span class="s1">idx_posinf = isposinf(d)</span>
        <span class="s1">idx_neginf = isneginf(d)</span>
        <span class="s1">_nx.copyto(d</span><span class="s2">, </span><span class="s1">nan</span><span class="s2">, </span><span class="s1">where=idx_nan)</span>
        <span class="s1">_nx.copyto(d</span><span class="s2">, </span><span class="s1">maxf</span><span class="s2">, </span><span class="s1">where=idx_posinf)</span>
        <span class="s1">_nx.copyto(d</span><span class="s2">, </span><span class="s1">minf</span><span class="s2">, </span><span class="s1">where=idx_neginf)</span>
    <span class="s2">return </span><span class="s1">x[()] </span><span class="s2">if </span><span class="s1">isscalar </span><span class="s2">else </span><span class="s1">x</span>

<span class="s5">#-----------------------------------------------------------------------------</span>

<span class="s2">def </span><span class="s1">_real_if_close_dispatcher(a</span><span class="s2">, </span><span class="s1">tol=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_real_if_close_dispatcher)</span>
<span class="s2">def </span><span class="s1">real_if_close(a</span><span class="s2">, </span><span class="s1">tol=</span><span class="s4">100</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    If input is complex with all imaginary parts close to zero, return  
    real parts. 
 
    &quot;Close to zero&quot; is defined as `tol` * (machine epsilon of the type for 
    `a`). 
 
    Parameters 
    ---------- 
    a : array_like 
        Input array. 
    tol : float 
        Tolerance in machine epsilons for the complex part of the elements 
        in the array. 
 
    Returns 
    ------- 
    out : ndarray 
        If `a` is real, the type of `a` is used for the output.  If `a` 
        has complex elements, the returned type is float. 
 
    See Also 
    -------- 
    real, imag, angle 
 
    Notes 
    ----- 
    Machine epsilon varies from machine to machine and between data types 
    but Python floats on most platforms have a machine epsilon equal to 
    2.2204460492503131e-16.  You can use 'np.finfo(float).eps' to print 
    out the machine epsilon for floats. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.finfo(float).eps 
    2.2204460492503131e-16 # may vary 
 
    &gt;&gt;&gt; np.real_if_close([2.1 + 4e-14j, 5.2 + 3e-15j], tol=1000) 
    array([2.1, 5.2]) 
    &gt;&gt;&gt; np.real_if_close([2.1 + 4e-13j, 5.2 + 3e-15j], tol=1000) 
    array([2.1+4.e-13j, 5.2 + 3e-15j]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = asanyarray(a)</span>
    <span class="s2">if not </span><span class="s1">issubclass(a.dtype.type</span><span class="s2">, </span><span class="s1">_nx.complexfloating):</span>
        <span class="s2">return </span><span class="s1">a</span>
    <span class="s2">if </span><span class="s1">tol &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">numpy.core </span><span class="s2">import </span><span class="s1">getlimits</span>
        <span class="s1">f = getlimits.finfo(a.dtype.type)</span>
        <span class="s1">tol = f.eps * tol</span>
    <span class="s2">if </span><span class="s1">_nx.all(_nx.absolute(a.imag) &lt; tol):</span>
        <span class="s1">a = a.real</span>
    <span class="s2">return </span><span class="s1">a</span>


<span class="s2">def </span><span class="s1">_asscalar_dispatcher(a):</span>
    <span class="s5"># 2018-10-10, 1.16</span>
    <span class="s1">warnings.warn(</span><span class="s3">'np.asscalar(a) is deprecated since NumPy v1.16, use '</span>
                  <span class="s3">'a.item() instead'</span><span class="s2">, </span><span class="s1">DeprecationWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">(a</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_asscalar_dispatcher)</span>
<span class="s2">def </span><span class="s1">asscalar(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert an array of size 1 to its scalar equivalent. 
 
    .. deprecated:: 1.16 
 
        Deprecated, use `numpy.ndarray.item()` instead. 
 
    Parameters 
    ---------- 
    a : ndarray 
        Input array of size 1. 
 
    Returns 
    ------- 
    out : scalar 
        Scalar representation of `a`. The output data type is the same type 
        returned by the input's `item` method. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.asscalar(np.array([24])) 
    24 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">a.item()</span>

<span class="s5">#-----------------------------------------------------------------------------</span>

<span class="s1">_namefromtype = {</span><span class="s3">'S1'</span><span class="s1">: </span><span class="s3">'character'</span><span class="s2">,</span>
                 <span class="s3">'?'</span><span class="s1">: </span><span class="s3">'bool'</span><span class="s2">,</span>
                 <span class="s3">'b'</span><span class="s1">: </span><span class="s3">'signed char'</span><span class="s2">,</span>
                 <span class="s3">'B'</span><span class="s1">: </span><span class="s3">'unsigned char'</span><span class="s2">,</span>
                 <span class="s3">'h'</span><span class="s1">: </span><span class="s3">'short'</span><span class="s2">,</span>
                 <span class="s3">'H'</span><span class="s1">: </span><span class="s3">'unsigned short'</span><span class="s2">,</span>
                 <span class="s3">'i'</span><span class="s1">: </span><span class="s3">'integer'</span><span class="s2">,</span>
                 <span class="s3">'I'</span><span class="s1">: </span><span class="s3">'unsigned integer'</span><span class="s2">,</span>
                 <span class="s3">'l'</span><span class="s1">: </span><span class="s3">'long integer'</span><span class="s2">,</span>
                 <span class="s3">'L'</span><span class="s1">: </span><span class="s3">'unsigned long integer'</span><span class="s2">,</span>
                 <span class="s3">'q'</span><span class="s1">: </span><span class="s3">'long long integer'</span><span class="s2">,</span>
                 <span class="s3">'Q'</span><span class="s1">: </span><span class="s3">'unsigned long long integer'</span><span class="s2">,</span>
                 <span class="s3">'f'</span><span class="s1">: </span><span class="s3">'single precision'</span><span class="s2">,</span>
                 <span class="s3">'d'</span><span class="s1">: </span><span class="s3">'double precision'</span><span class="s2">,</span>
                 <span class="s3">'g'</span><span class="s1">: </span><span class="s3">'long precision'</span><span class="s2">,</span>
                 <span class="s3">'F'</span><span class="s1">: </span><span class="s3">'complex single precision'</span><span class="s2">,</span>
                 <span class="s3">'D'</span><span class="s1">: </span><span class="s3">'complex double precision'</span><span class="s2">,</span>
                 <span class="s3">'G'</span><span class="s1">: </span><span class="s3">'complex long double precision'</span><span class="s2">,</span>
                 <span class="s3">'S'</span><span class="s1">: </span><span class="s3">'string'</span><span class="s2">,</span>
                 <span class="s3">'U'</span><span class="s1">: </span><span class="s3">'unicode'</span><span class="s2">,</span>
                 <span class="s3">'V'</span><span class="s1">: </span><span class="s3">'void'</span><span class="s2">,</span>
                 <span class="s3">'O'</span><span class="s1">: </span><span class="s3">'object'</span>
                 <span class="s1">}</span>

<span class="s1">@set_module(</span><span class="s3">'numpy'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">typename(char):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a description for the given data type code. 
 
    Parameters 
    ---------- 
    char : str 
        Data type code. 
 
    Returns 
    ------- 
    out : str 
        Description of the input data type code. 
 
    See Also 
    -------- 
    dtype, typecodes 
 
    Examples 
    -------- 
    &gt;&gt;&gt; typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q', 
    ...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q'] 
    &gt;&gt;&gt; for typechar in typechars: 
    ...     print(typechar, ' : ', np.typename(typechar)) 
    ... 
    S1  :  character 
    ?  :  bool 
    B  :  unsigned char 
    D  :  complex double precision 
    G  :  complex long double precision 
    F  :  complex single precision 
    I  :  unsigned integer 
    H  :  unsigned short 
    L  :  unsigned long integer 
    O  :  object 
    Q  :  unsigned long long integer 
    S  :  string 
    U  :  unicode 
    V  :  void 
    b  :  signed char 
    d  :  double precision 
    g  :  long precision 
    f  :  single precision 
    i  :  integer 
    h  :  short 
    l  :  long integer 
    q  :  long long integer 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_namefromtype[char]</span>

<span class="s5">#-----------------------------------------------------------------------------</span>

<span class="s5">#determine the &quot;minimum common type&quot; for a group of arrays.</span>
<span class="s1">array_type = [[_nx.half</span><span class="s2">, </span><span class="s1">_nx.single</span><span class="s2">, </span><span class="s1">_nx.double</span><span class="s2">, </span><span class="s1">_nx.longdouble]</span><span class="s2">,</span>
              <span class="s1">[</span><span class="s2">None, </span><span class="s1">_nx.csingle</span><span class="s2">, </span><span class="s1">_nx.cdouble</span><span class="s2">, </span><span class="s1">_nx.clongdouble]]</span>
<span class="s1">array_precision = {_nx.half: </span><span class="s4">0</span><span class="s2">,</span>
                   <span class="s1">_nx.single: </span><span class="s4">1</span><span class="s2">,</span>
                   <span class="s1">_nx.double: </span><span class="s4">2</span><span class="s2">,</span>
                   <span class="s1">_nx.longdouble: </span><span class="s4">3</span><span class="s2">,</span>
                   <span class="s1">_nx.csingle: </span><span class="s4">1</span><span class="s2">,</span>
                   <span class="s1">_nx.cdouble: </span><span class="s4">2</span><span class="s2">,</span>
                   <span class="s1">_nx.clongdouble: </span><span class="s4">3</span><span class="s1">}</span>


<span class="s2">def </span><span class="s1">_common_type_dispatcher(*arrays):</span>
    <span class="s2">return </span><span class="s1">arrays</span>


<span class="s1">@array_function_dispatch(_common_type_dispatcher)</span>
<span class="s2">def </span><span class="s1">common_type(*arrays):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a scalar type which is common to the input arrays. 
 
    The return type will always be an inexact (i.e. floating point) scalar 
    type, even if all the arrays are integer arrays. If one of the inputs is 
    an integer array, the minimum precision type that is returned is a 
    64-bit floating point dtype. 
 
    All input arrays except int64 and uint64 can be safely cast to the 
    returned dtype without loss of information. 
 
    Parameters 
    ---------- 
    array1, array2, ... : ndarrays 
        Input arrays. 
 
    Returns 
    ------- 
    out : data type code 
        Data type code. 
 
    See Also 
    -------- 
    dtype, mintypecode 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.common_type(np.arange(2, dtype=np.float32)) 
    &lt;class 'numpy.float32'&gt; 
    &gt;&gt;&gt; np.common_type(np.arange(2, dtype=np.float32), np.arange(2)) 
    &lt;class 'numpy.float64'&gt; 
    &gt;&gt;&gt; np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0])) 
    &lt;class 'numpy.complex128'&gt; 
 
    &quot;&quot;&quot;</span>
    <span class="s1">is_complex = </span><span class="s2">False</span>
    <span class="s1">precision = </span><span class="s4">0</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays:</span>
        <span class="s1">t = a.dtype.type</span>
        <span class="s2">if </span><span class="s1">iscomplexobj(a):</span>
            <span class="s1">is_complex = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">issubclass(t</span><span class="s2">, </span><span class="s1">_nx.integer):</span>
            <span class="s1">p = </span><span class="s4">2  </span><span class="s5"># array_precision[_nx.double]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">p = array_precision.get(t</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">p </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;can't get common type for non-numeric array&quot;</span><span class="s1">)</span>
        <span class="s1">precision = max(precision</span><span class="s2">, </span><span class="s1">p)</span>
    <span class="s2">if </span><span class="s1">is_complex:</span>
        <span class="s2">return </span><span class="s1">array_type[</span><span class="s4">1</span><span class="s1">][precision]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">array_type[</span><span class="s4">0</span><span class="s1">][precision]</span>
</pre>
</body>
</html>