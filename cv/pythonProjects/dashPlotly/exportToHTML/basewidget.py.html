<html>
<head>
<title>basewidget.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
basewidget.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">uuid</span>
<span class="s0">from </span><span class="s1">importlib </span><span class="s0">import </span><span class="s1">import_module</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">numbers</span>

<span class="s0">try</span><span class="s1">:</span>
    <span class="s0">from </span><span class="s1">urllib </span><span class="s0">import </span><span class="s1">parse</span>
<span class="s0">except </span><span class="s1">ImportError:</span>
    <span class="s0">from </span><span class="s1">urlparse </span><span class="s0">import </span><span class="s1">urlparse </span><span class="s0">as </span><span class="s1">parse</span>

<span class="s0">import </span><span class="s1">ipywidgets </span><span class="s0">as </span><span class="s1">widgets</span>
<span class="s0">from </span><span class="s1">traitlets </span><span class="s0">import </span><span class="s1">List</span><span class="s0">, </span><span class="s1">Unicode</span><span class="s0">, </span><span class="s1">Dict</span><span class="s0">, </span><span class="s1">observe</span><span class="s0">, </span><span class="s1">Integer</span>
<span class="s0">from </span><span class="s1">.basedatatypes </span><span class="s0">import </span><span class="s1">BaseFigure</span><span class="s0">, </span><span class="s1">BasePlotlyType</span>
<span class="s0">from </span><span class="s1">.callbacks </span><span class="s0">import </span><span class="s1">BoxSelector</span><span class="s0">, </span><span class="s1">LassoSelector</span><span class="s0">, </span><span class="s1">InputDeviceState</span><span class="s0">, </span><span class="s1">Points</span>
<span class="s0">from </span><span class="s1">.serializers </span><span class="s0">import </span><span class="s1">custom_serializers</span>
<span class="s0">from </span><span class="s1">.version </span><span class="s0">import </span><span class="s1">__frontend_version__</span>


<span class="s1">@widgets.register</span>
<span class="s0">class </span><span class="s1">BaseFigureWidget(BaseFigure</span><span class="s0">, </span><span class="s1">widgets.DOMWidget):</span>
    <span class="s2">&quot;&quot;&quot; 
    Base class for FigureWidget. The FigureWidget class is code-generated as a 
    subclass 
    &quot;&quot;&quot;</span>

    <span class="s3"># Widget Traits</span>
    <span class="s3"># -------------</span>
    <span class="s3"># Widget traitlets are automatically synchronized with the FigureModel</span>
    <span class="s3"># JavaScript object</span>
    <span class="s1">_view_name = Unicode(</span><span class="s4">&quot;FigureView&quot;</span><span class="s1">).tag(sync=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">_view_module = Unicode(</span><span class="s4">&quot;jupyterlab-plotly&quot;</span><span class="s1">).tag(sync=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">_view_module_version = Unicode(__frontend_version__).tag(sync=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">_model_name = Unicode(</span><span class="s4">&quot;FigureModel&quot;</span><span class="s1">).tag(sync=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">_model_module = Unicode(</span><span class="s4">&quot;jupyterlab-plotly&quot;</span><span class="s1">).tag(sync=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">_model_module_version = Unicode(__frontend_version__).tag(sync=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s3"># ### _data and _layout ###</span>
    <span class="s3"># These properties store the current state of the traces and</span>
    <span class="s3"># layout as JSON-style dicts. These dicts do not store any subclasses of</span>
    <span class="s3"># `BasePlotlyType`</span>
    <span class="s3">#</span>
    <span class="s3"># Note: These are only automatically synced with the frontend on full</span>
    <span class="s3"># assignment, not on mutation. We use this fact to only directly sync</span>
    <span class="s3"># them to the front-end on FigureWidget construction. All other updates</span>
    <span class="s3"># are made using mutation, and they are manually synced to the frontend</span>
    <span class="s3"># using the relayout/restyle/update/etc. messages.</span>
    <span class="s1">_layout = Dict().tag(sync=</span><span class="s0">True, </span><span class="s1">**custom_serializers)</span>
    <span class="s1">_data = List().tag(sync=</span><span class="s0">True, </span><span class="s1">**custom_serializers)</span>
    <span class="s1">_config = Dict().tag(sync=</span><span class="s0">True, </span><span class="s1">**custom_serializers)</span>

    <span class="s3"># ### Python -&gt; JS message properties ###</span>
    <span class="s3"># These properties are used to send messages from Python to the</span>
    <span class="s3"># frontend. Messages are sent by assigning the message contents to the</span>
    <span class="s3"># appropriate _py2js_* property and then immediatly assigning None to the</span>
    <span class="s3"># property.</span>
    <span class="s3">#</span>
    <span class="s3"># See JSDoc comments in the FigureModel class in js/src/Figure.js for</span>
    <span class="s3"># detailed descriptions of the messages.</span>
    <span class="s1">_py2js_addTraces = Dict(allow_none=</span><span class="s0">True</span><span class="s1">).tag(sync=</span><span class="s0">True, </span><span class="s1">**custom_serializers)</span>
    <span class="s1">_py2js_restyle = Dict(allow_none=</span><span class="s0">True</span><span class="s1">).tag(sync=</span><span class="s0">True, </span><span class="s1">**custom_serializers)</span>
    <span class="s1">_py2js_relayout = Dict(allow_none=</span><span class="s0">True</span><span class="s1">).tag(sync=</span><span class="s0">True, </span><span class="s1">**custom_serializers)</span>
    <span class="s1">_py2js_update = Dict(allow_none=</span><span class="s0">True</span><span class="s1">).tag(sync=</span><span class="s0">True, </span><span class="s1">**custom_serializers)</span>
    <span class="s1">_py2js_animate = Dict(allow_none=</span><span class="s0">True</span><span class="s1">).tag(sync=</span><span class="s0">True, </span><span class="s1">**custom_serializers)</span>

    <span class="s1">_py2js_deleteTraces = Dict(allow_none=</span><span class="s0">True</span><span class="s1">).tag(sync=</span><span class="s0">True, </span><span class="s1">**custom_serializers)</span>
    <span class="s1">_py2js_moveTraces = Dict(allow_none=</span><span class="s0">True</span><span class="s1">).tag(sync=</span><span class="s0">True, </span><span class="s1">**custom_serializers)</span>

    <span class="s1">_py2js_removeLayoutProps = Dict(allow_none=</span><span class="s0">True</span><span class="s1">).tag(</span>
        <span class="s1">sync=</span><span class="s0">True, </span><span class="s1">**custom_serializers</span>
    <span class="s1">)</span>
    <span class="s1">_py2js_removeTraceProps = Dict(allow_none=</span><span class="s0">True</span><span class="s1">).tag(sync=</span><span class="s0">True, </span><span class="s1">**custom_serializers)</span>

    <span class="s3"># ### JS -&gt; Python message properties ###</span>
    <span class="s3"># These properties are used to receive messages from the frontend.</span>
    <span class="s3"># Messages are received by defining methods that observe changes to these</span>
    <span class="s3"># properties. Receive methods are named `_handler_js2py_*` where '*' is</span>
    <span class="s3"># the name of the corresponding message property.  Receive methods are</span>
    <span class="s3"># responsible for setting the message property to None after retreiving</span>
    <span class="s3"># the message data.</span>
    <span class="s3">#</span>
    <span class="s3"># See JSDoc comments in the FigureModel class in js/src/Figure.js for</span>
    <span class="s3"># detailed descriptions of the messages.</span>
    <span class="s1">_js2py_traceDeltas = Dict(allow_none=</span><span class="s0">True</span><span class="s1">).tag(sync=</span><span class="s0">True, </span><span class="s1">**custom_serializers)</span>
    <span class="s1">_js2py_layoutDelta = Dict(allow_none=</span><span class="s0">True</span><span class="s1">).tag(sync=</span><span class="s0">True, </span><span class="s1">**custom_serializers)</span>
    <span class="s1">_js2py_restyle = Dict(allow_none=</span><span class="s0">True</span><span class="s1">).tag(sync=</span><span class="s0">True, </span><span class="s1">**custom_serializers)</span>
    <span class="s1">_js2py_relayout = Dict(allow_none=</span><span class="s0">True</span><span class="s1">).tag(sync=</span><span class="s0">True, </span><span class="s1">**custom_serializers)</span>
    <span class="s1">_js2py_update = Dict(allow_none=</span><span class="s0">True</span><span class="s1">).tag(sync=</span><span class="s0">True, </span><span class="s1">**custom_serializers)</span>
    <span class="s1">_js2py_pointsCallback = Dict(allow_none=</span><span class="s0">True</span><span class="s1">).tag(sync=</span><span class="s0">True, </span><span class="s1">**custom_serializers)</span>

    <span class="s3"># ### Message tracking properties ###</span>
    <span class="s3"># The _last_layout_edit_id and _last_trace_edit_id properties are used</span>
    <span class="s3"># to keep track of the edit id of the message that most recently</span>
    <span class="s3"># requested an update to the Figures layout or traces respectively.</span>
    <span class="s3">#</span>
    <span class="s3"># We track this information because we don't want to update the Figure's</span>
    <span class="s3"># default layout/trace properties (_layout_defaults, _data_defaults)</span>
    <span class="s3"># while edits are in process. This can lead to inconsistent property</span>
    <span class="s3"># states.</span>
    <span class="s1">_last_layout_edit_id = Integer(</span><span class="s5">0</span><span class="s1">).tag(sync=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">_last_trace_edit_id = Integer(</span><span class="s5">0</span><span class="s1">).tag(sync=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">_set_trace_uid = </span><span class="s0">True</span>
    <span class="s1">_allow_disable_validation = </span><span class="s0">False</span>

    <span class="s3"># Constructor</span>
    <span class="s3"># -----------</span>
    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">data=</span><span class="s0">None, </span><span class="s1">layout=</span><span class="s0">None, </span><span class="s1">frames=</span><span class="s0">None, </span><span class="s1">skip_invalid=</span><span class="s0">False, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>

        <span class="s3"># Call superclass constructors</span>
        <span class="s3"># ----------------------------</span>
        <span class="s3"># Note: We rename layout to layout_plotly because to deconflict it</span>
        <span class="s3"># with the `layout` constructor parameter of the `widgets.DOMWidget`</span>
        <span class="s3"># ipywidgets class</span>
        <span class="s1">super(BaseFigureWidget</span><span class="s0">, </span><span class="s1">self).__init__(</span>
            <span class="s1">data=data</span><span class="s0">,</span>
            <span class="s1">layout_plotly=layout</span><span class="s0">,</span>
            <span class="s1">frames=frames</span><span class="s0">,</span>
            <span class="s1">skip_invalid=skip_invalid</span><span class="s0">,</span>
            <span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s3"># Validate Frames</span>
        <span class="s3"># ---------------</span>
        <span class="s3"># Frames are not supported by figure widget</span>
        <span class="s0">if </span><span class="s1">self._frame_objs:</span>
            <span class="s1">BaseFigureWidget._display_frames_error()</span>

        <span class="s3"># Message States</span>
        <span class="s3"># --------------</span>
        <span class="s3"># ### Layout ###</span>

        <span class="s3"># _last_layout_edit_id is described above</span>
        <span class="s1">self._last_layout_edit_id = </span><span class="s5">0</span>

        <span class="s3"># _layout_edit_in_process is set to True if there are layout edit</span>
        <span class="s3"># operations that have been sent to the frontend that haven't</span>
        <span class="s3"># completed yet.</span>
        <span class="s1">self._layout_edit_in_process = </span><span class="s0">False</span>

        <span class="s3"># _waiting_edit_callbacks is a list of callback functions that</span>
        <span class="s3"># should be executed as soon as all pending edit operations are</span>
        <span class="s3"># completed</span>
        <span class="s1">self._waiting_edit_callbacks = []</span>

        <span class="s3"># ### Trace ###</span>
        <span class="s3"># _last_trace_edit_id: described above</span>
        <span class="s1">self._last_trace_edit_id = </span><span class="s5">0</span>

        <span class="s3"># _trace_edit_in_process is set to True if there are trace edit</span>
        <span class="s3"># operations that have been sent to the frontend that haven't</span>
        <span class="s3"># completed yet.</span>
        <span class="s1">self._trace_edit_in_process = </span><span class="s0">False</span>

        <span class="s3"># View count</span>
        <span class="s3"># ----------</span>
        <span class="s3"># ipywidget property that stores the number of active frontend</span>
        <span class="s3"># views of this widget</span>
        <span class="s1">self._view_count = </span><span class="s5">0</span>

    <span class="s3"># Python -&gt; JavaScript Messages</span>
    <span class="s3"># -----------------------------</span>
    <span class="s0">def </span><span class="s1">_send_relayout_msg(self</span><span class="s0">, </span><span class="s1">layout_data</span><span class="s0">, </span><span class="s1">source_view_id=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Send Plotly.relayout message to the frontend 
 
        Parameters 
        ---------- 
        layout_data : dict 
            Plotly.relayout layout data 
        source_view_id : str 
            UID of view that triggered this relayout operation 
            (e.g. By the user clicking 'zoom' in the toolbar). None if the 
            operation was not triggered by a frontend view 
        &quot;&quot;&quot;</span>
        <span class="s3"># Increment layout edit messages IDs</span>
        <span class="s3"># ----------------------------------</span>
        <span class="s1">layout_edit_id = self._last_layout_edit_id + </span><span class="s5">1</span>
        <span class="s1">self._last_layout_edit_id = layout_edit_id</span>
        <span class="s1">self._layout_edit_in_process = </span><span class="s0">True</span>

        <span class="s3"># Build message</span>
        <span class="s3"># -------------</span>
        <span class="s1">msg_data = {</span>
            <span class="s4">&quot;relayout_data&quot;</span><span class="s1">: layout_data</span><span class="s0">,</span>
            <span class="s4">&quot;layout_edit_id&quot;</span><span class="s1">: layout_edit_id</span><span class="s0">,</span>
            <span class="s4">&quot;source_view_id&quot;</span><span class="s1">: source_view_id</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s3"># Send message</span>
        <span class="s3"># ------------</span>
        <span class="s1">self._py2js_relayout = msg_data</span>
        <span class="s1">self._py2js_relayout = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_send_restyle_msg(self</span><span class="s0">, </span><span class="s1">restyle_data</span><span class="s0">, </span><span class="s1">trace_indexes=</span><span class="s0">None, </span><span class="s1">source_view_id=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Send Plotly.restyle message to the frontend 
 
        Parameters 
        ---------- 
        restyle_data : dict 
            Plotly.restyle restyle data 
        trace_indexes : list[int] 
            List of trace indexes that the restyle operation 
            applies to 
        source_view_id : str 
            UID of view that triggered this restyle operation 
            (e.g. By the user clicking the legend to hide a trace). 
            None if the operation was not triggered by a frontend view 
        &quot;&quot;&quot;</span>

        <span class="s3"># Validate / normalize inputs</span>
        <span class="s3"># ---------------------------</span>
        <span class="s1">trace_indexes = self._normalize_trace_indexes(trace_indexes)</span>

        <span class="s3"># Increment layout/trace edit message IDs</span>
        <span class="s3"># ---------------------------------------</span>
        <span class="s1">layout_edit_id = self._last_layout_edit_id + </span><span class="s5">1</span>
        <span class="s1">self._last_layout_edit_id = layout_edit_id</span>
        <span class="s1">self._layout_edit_in_process = </span><span class="s0">True</span>

        <span class="s1">trace_edit_id = self._last_trace_edit_id + </span><span class="s5">1</span>
        <span class="s1">self._last_trace_edit_id = trace_edit_id</span>
        <span class="s1">self._trace_edit_in_process = </span><span class="s0">True</span>

        <span class="s3"># Build message</span>
        <span class="s3"># -------------</span>
        <span class="s1">restyle_msg = {</span>
            <span class="s4">&quot;restyle_data&quot;</span><span class="s1">: restyle_data</span><span class="s0">,</span>
            <span class="s4">&quot;restyle_traces&quot;</span><span class="s1">: trace_indexes</span><span class="s0">,</span>
            <span class="s4">&quot;trace_edit_id&quot;</span><span class="s1">: trace_edit_id</span><span class="s0">,</span>
            <span class="s4">&quot;layout_edit_id&quot;</span><span class="s1">: layout_edit_id</span><span class="s0">,</span>
            <span class="s4">&quot;source_view_id&quot;</span><span class="s1">: source_view_id</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s3"># Send message</span>
        <span class="s3"># ------------</span>
        <span class="s1">self._py2js_restyle = restyle_msg</span>
        <span class="s1">self._py2js_restyle = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_send_addTraces_msg(self</span><span class="s0">, </span><span class="s1">new_traces_data):</span>
        <span class="s2">&quot;&quot;&quot; 
        Send Plotly.addTraces message to the frontend 
 
        Parameters 
        ---------- 
        new_traces_data : list[dict] 
            List of trace data for new traces as accepted by Plotly.addTraces 
        &quot;&quot;&quot;</span>

        <span class="s3"># Increment layout/trace edit message IDs</span>
        <span class="s3"># ---------------------------------------</span>
        <span class="s1">layout_edit_id = self._last_layout_edit_id + </span><span class="s5">1</span>
        <span class="s1">self._last_layout_edit_id = layout_edit_id</span>
        <span class="s1">self._layout_edit_in_process = </span><span class="s0">True</span>

        <span class="s1">trace_edit_id = self._last_trace_edit_id + </span><span class="s5">1</span>
        <span class="s1">self._last_trace_edit_id = trace_edit_id</span>
        <span class="s1">self._trace_edit_in_process = </span><span class="s0">True</span>

        <span class="s3"># Build message</span>
        <span class="s3"># -------------</span>
        <span class="s1">add_traces_msg = {</span>
            <span class="s4">&quot;trace_data&quot;</span><span class="s1">: new_traces_data</span><span class="s0">,</span>
            <span class="s4">&quot;trace_edit_id&quot;</span><span class="s1">: trace_edit_id</span><span class="s0">,</span>
            <span class="s4">&quot;layout_edit_id&quot;</span><span class="s1">: layout_edit_id</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s3"># Send message</span>
        <span class="s3"># ------------</span>
        <span class="s1">self._py2js_addTraces = add_traces_msg</span>
        <span class="s1">self._py2js_addTraces = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_send_moveTraces_msg(self</span><span class="s0">, </span><span class="s1">current_inds</span><span class="s0">, </span><span class="s1">new_inds):</span>
        <span class="s2">&quot;&quot;&quot; 
        Send Plotly.moveTraces message to the frontend 
 
        Parameters 
        ---------- 
        current_inds : list[int] 
            List of current trace indexes 
        new_inds : list[int] 
            List of new trace indexes 
        &quot;&quot;&quot;</span>

        <span class="s3"># Build message</span>
        <span class="s3"># -------------</span>
        <span class="s1">move_msg = {</span><span class="s4">&quot;current_trace_inds&quot;</span><span class="s1">: current_inds</span><span class="s0">, </span><span class="s4">&quot;new_trace_inds&quot;</span><span class="s1">: new_inds}</span>

        <span class="s3"># Send message</span>
        <span class="s3"># ------------</span>
        <span class="s1">self._py2js_moveTraces = move_msg</span>
        <span class="s1">self._py2js_moveTraces = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_send_update_msg(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">restyle_data</span><span class="s0">, </span><span class="s1">relayout_data</span><span class="s0">, </span><span class="s1">trace_indexes=</span><span class="s0">None, </span><span class="s1">source_view_id=</span><span class="s0">None</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Send Plotly.update message to the frontend 
 
        Parameters 
        ---------- 
        restyle_data : dict 
            Plotly.update restyle data 
        relayout_data : dict 
            Plotly.update relayout data 
        trace_indexes : list[int] 
            List of trace indexes that the update operation applies to 
        source_view_id : str 
            UID of view that triggered this update operation 
            (e.g. By the user clicking a button). 
            None if the operation was not triggered by a frontend view 
        &quot;&quot;&quot;</span>

        <span class="s3"># Validate / normalize inputs</span>
        <span class="s3"># ---------------------------</span>
        <span class="s1">trace_indexes = self._normalize_trace_indexes(trace_indexes)</span>

        <span class="s3"># Increment layout/trace edit message IDs</span>
        <span class="s3"># ---------------------------------------</span>
        <span class="s1">trace_edit_id = self._last_trace_edit_id + </span><span class="s5">1</span>
        <span class="s1">self._last_trace_edit_id = trace_edit_id</span>
        <span class="s1">self._trace_edit_in_process = </span><span class="s0">True</span>

        <span class="s1">layout_edit_id = self._last_layout_edit_id + </span><span class="s5">1</span>
        <span class="s1">self._last_layout_edit_id = layout_edit_id</span>
        <span class="s1">self._layout_edit_in_process = </span><span class="s0">True</span>

        <span class="s3"># Build message</span>
        <span class="s3"># -------------</span>
        <span class="s1">update_msg = {</span>
            <span class="s4">&quot;style_data&quot;</span><span class="s1">: restyle_data</span><span class="s0">,</span>
            <span class="s4">&quot;layout_data&quot;</span><span class="s1">: relayout_data</span><span class="s0">,</span>
            <span class="s4">&quot;style_traces&quot;</span><span class="s1">: trace_indexes</span><span class="s0">,</span>
            <span class="s4">&quot;trace_edit_id&quot;</span><span class="s1">: trace_edit_id</span><span class="s0">,</span>
            <span class="s4">&quot;layout_edit_id&quot;</span><span class="s1">: layout_edit_id</span><span class="s0">,</span>
            <span class="s4">&quot;source_view_id&quot;</span><span class="s1">: source_view_id</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s3"># Send message</span>
        <span class="s3"># ------------</span>
        <span class="s1">self._py2js_update = update_msg</span>
        <span class="s1">self._py2js_update = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_send_animate_msg(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">styles_data</span><span class="s0">, </span><span class="s1">relayout_data</span><span class="s0">, </span><span class="s1">trace_indexes</span><span class="s0">, </span><span class="s1">animation_opts</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Send Plotly.update message to the frontend 
 
        Note: there is no source_view_id parameter because animations 
        triggered by the fontend are not currently supported 
 
        Parameters 
        ---------- 
        styles_data : list[dict] 
            Plotly.animate styles data 
        relayout_data : dict 
            Plotly.animate relayout data 
        trace_indexes : list[int] 
            List of trace indexes that the animate operation applies to 
        &quot;&quot;&quot;</span>

        <span class="s3"># Validate / normalize inputs</span>
        <span class="s3"># ---------------------------</span>
        <span class="s1">trace_indexes = self._normalize_trace_indexes(trace_indexes)</span>

        <span class="s3"># Increment layout/trace edit message IDs</span>
        <span class="s3"># ---------------------------------------</span>
        <span class="s1">trace_edit_id = self._last_trace_edit_id + </span><span class="s5">1</span>
        <span class="s1">self._last_trace_edit_id = trace_edit_id</span>
        <span class="s1">self._trace_edit_in_process = </span><span class="s0">True</span>

        <span class="s1">layout_edit_id = self._last_layout_edit_id + </span><span class="s5">1</span>
        <span class="s1">self._last_layout_edit_id = layout_edit_id</span>
        <span class="s1">self._layout_edit_in_process = </span><span class="s0">True</span>

        <span class="s3"># Build message</span>
        <span class="s3"># -------------</span>
        <span class="s1">animate_msg = {</span>
            <span class="s4">&quot;style_data&quot;</span><span class="s1">: styles_data</span><span class="s0">,</span>
            <span class="s4">&quot;layout_data&quot;</span><span class="s1">: relayout_data</span><span class="s0">,</span>
            <span class="s4">&quot;style_traces&quot;</span><span class="s1">: trace_indexes</span><span class="s0">,</span>
            <span class="s4">&quot;animation_opts&quot;</span><span class="s1">: animation_opts</span><span class="s0">,</span>
            <span class="s4">&quot;trace_edit_id&quot;</span><span class="s1">: trace_edit_id</span><span class="s0">,</span>
            <span class="s4">&quot;layout_edit_id&quot;</span><span class="s1">: layout_edit_id</span><span class="s0">,</span>
            <span class="s4">&quot;source_view_id&quot;</span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s1">}</span>

        <span class="s3"># Send message</span>
        <span class="s3"># ------------</span>
        <span class="s1">self._py2js_animate = animate_msg</span>
        <span class="s1">self._py2js_animate = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_send_deleteTraces_msg(self</span><span class="s0">, </span><span class="s1">delete_inds):</span>
        <span class="s2">&quot;&quot;&quot; 
        Send Plotly.deleteTraces message to the frontend 
 
        Parameters 
        ---------- 
        delete_inds : list[int] 
            List of trace indexes of traces to delete 
        &quot;&quot;&quot;</span>

        <span class="s3"># Increment layout/trace edit message IDs</span>
        <span class="s3"># ---------------------------------------</span>
        <span class="s1">trace_edit_id = self._last_trace_edit_id + </span><span class="s5">1</span>
        <span class="s1">self._last_trace_edit_id = trace_edit_id</span>
        <span class="s1">self._trace_edit_in_process = </span><span class="s0">True</span>

        <span class="s1">layout_edit_id = self._last_layout_edit_id + </span><span class="s5">1</span>
        <span class="s1">self._last_layout_edit_id = layout_edit_id</span>
        <span class="s1">self._layout_edit_in_process = </span><span class="s0">True</span>

        <span class="s3"># Build message</span>
        <span class="s3"># -------------</span>
        <span class="s1">delete_msg = {</span>
            <span class="s4">&quot;delete_inds&quot;</span><span class="s1">: delete_inds</span><span class="s0">,</span>
            <span class="s4">&quot;layout_edit_id&quot;</span><span class="s1">: layout_edit_id</span><span class="s0">,</span>
            <span class="s4">&quot;trace_edit_id&quot;</span><span class="s1">: trace_edit_id</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s3"># Send message</span>
        <span class="s3"># ------------</span>
        <span class="s1">self._py2js_deleteTraces = delete_msg</span>
        <span class="s1">self._py2js_deleteTraces = </span><span class="s0">None</span>

    <span class="s3"># JavaScript -&gt; Python Messages</span>
    <span class="s3"># -----------------------------</span>
    <span class="s1">@observe(</span><span class="s4">&quot;_js2py_traceDeltas&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">_handler_js2py_traceDeltas(self</span><span class="s0">, </span><span class="s1">change):</span>
        <span class="s2">&quot;&quot;&quot; 
        Process trace deltas message from the frontend 
        &quot;&quot;&quot;</span>

        <span class="s3"># Receive message</span>
        <span class="s3"># ---------------</span>
        <span class="s1">msg_data = change[</span><span class="s4">&quot;new&quot;</span><span class="s1">]</span>
        <span class="s0">if not </span><span class="s1">msg_data:</span>
            <span class="s1">self._js2py_traceDeltas = </span><span class="s0">None</span>
            <span class="s0">return</span>

        <span class="s1">trace_deltas = msg_data[</span><span class="s4">&quot;trace_deltas&quot;</span><span class="s1">]</span>
        <span class="s1">trace_edit_id = msg_data[</span><span class="s4">&quot;trace_edit_id&quot;</span><span class="s1">]</span>

        <span class="s3"># Apply deltas</span>
        <span class="s3"># ------------</span>
        <span class="s3"># We only apply the deltas if this message corresponds to the most</span>
        <span class="s3"># recent trace edit operation</span>
        <span class="s0">if </span><span class="s1">trace_edit_id == self._last_trace_edit_id:</span>

            <span class="s3"># ### Loop over deltas ###</span>
            <span class="s0">for </span><span class="s1">delta </span><span class="s0">in </span><span class="s1">trace_deltas:</span>

                <span class="s3"># #### Find existing trace for uid ###</span>
                <span class="s1">trace_uid = delta[</span><span class="s4">&quot;uid&quot;</span><span class="s1">]</span>
                <span class="s1">trace_uids = [trace.uid </span><span class="s0">for </span><span class="s1">trace </span><span class="s0">in </span><span class="s1">self.data]</span>
                <span class="s1">trace_index = trace_uids.index(trace_uid)</span>
                <span class="s1">uid_trace = self.data[trace_index]</span>

                <span class="s3"># #### Transform defaults to delta ####</span>
                <span class="s1">delta_transform = BaseFigureWidget._transform_data(</span>
                    <span class="s1">uid_trace._prop_defaults</span><span class="s0">, </span><span class="s1">delta</span>
                <span class="s1">)</span>

                <span class="s3"># #### Remove overlapping properties ####</span>
                <span class="s3"># If a property is present in both _props and _prop_defaults</span>
                <span class="s3"># then we remove the copy from _props</span>
                <span class="s1">remove_props = self._remove_overlapping_props(</span>
                    <span class="s1">uid_trace._props</span><span class="s0">, </span><span class="s1">uid_trace._prop_defaults</span>
                <span class="s1">)</span>

                <span class="s3"># #### Notify frontend model of property removal ####</span>
                <span class="s0">if </span><span class="s1">remove_props:</span>
                    <span class="s1">remove_trace_props_msg = {</span>
                        <span class="s4">&quot;remove_trace&quot;</span><span class="s1">: trace_index</span><span class="s0">,</span>
                        <span class="s4">&quot;remove_props&quot;</span><span class="s1">: remove_props</span><span class="s0">,</span>
                    <span class="s1">}</span>
                    <span class="s1">self._py2js_removeTraceProps = remove_trace_props_msg</span>
                    <span class="s1">self._py2js_removeTraceProps = </span><span class="s0">None</span>

                <span class="s3"># #### Dispatch change callbacks ####</span>
                <span class="s1">self._dispatch_trace_change_callbacks(delta_transform</span><span class="s0">, </span><span class="s1">[trace_index])</span>

            <span class="s3"># ### Trace edits no longer in process ###</span>
            <span class="s1">self._trace_edit_in_process = </span><span class="s0">False</span>

            <span class="s3"># ### Call any waiting trace edit callbacks ###</span>
            <span class="s0">if not </span><span class="s1">self._layout_edit_in_process:</span>
                <span class="s0">while </span><span class="s1">self._waiting_edit_callbacks:</span>
                    <span class="s1">self._waiting_edit_callbacks.pop()()</span>

        <span class="s1">self._js2py_traceDeltas = </span><span class="s0">None</span>

    <span class="s1">@observe(</span><span class="s4">&quot;_js2py_layoutDelta&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">_handler_js2py_layoutDelta(self</span><span class="s0">, </span><span class="s1">change):</span>
        <span class="s2">&quot;&quot;&quot; 
        Process layout delta message from the frontend 
        &quot;&quot;&quot;</span>

        <span class="s3"># Receive message</span>
        <span class="s3"># ---------------</span>
        <span class="s1">msg_data = change[</span><span class="s4">&quot;new&quot;</span><span class="s1">]</span>
        <span class="s0">if not </span><span class="s1">msg_data:</span>
            <span class="s1">self._js2py_layoutDelta = </span><span class="s0">None</span>
            <span class="s0">return</span>

        <span class="s1">layout_delta = msg_data[</span><span class="s4">&quot;layout_delta&quot;</span><span class="s1">]</span>
        <span class="s1">layout_edit_id = msg_data[</span><span class="s4">&quot;layout_edit_id&quot;</span><span class="s1">]</span>

        <span class="s3"># Apply delta</span>
        <span class="s3"># -----------</span>
        <span class="s3"># We only apply the delta if this message corresponds to the most</span>
        <span class="s3"># recent layout edit operation</span>
        <span class="s0">if </span><span class="s1">layout_edit_id == self._last_layout_edit_id:</span>

            <span class="s3"># ### Transform defaults to delta ###</span>
            <span class="s1">delta_transform = BaseFigureWidget._transform_data(</span>
                <span class="s1">self._layout_defaults</span><span class="s0">, </span><span class="s1">layout_delta</span>
            <span class="s1">)</span>

            <span class="s3"># ### Remove overlapping properties ###</span>
            <span class="s3"># If a property is present in both _layout and _layout_defaults</span>
            <span class="s3"># then we remove the copy from _layout</span>
            <span class="s1">removed_props = self._remove_overlapping_props(</span>
                <span class="s1">self._layout</span><span class="s0">, </span><span class="s1">self._layout_defaults</span>
            <span class="s1">)</span>

            <span class="s3"># ### Notify frontend model of property removal ###</span>
            <span class="s0">if </span><span class="s1">removed_props:</span>
                <span class="s1">remove_props_msg = {</span><span class="s4">&quot;remove_props&quot;</span><span class="s1">: removed_props}</span>

                <span class="s1">self._py2js_removeLayoutProps = remove_props_msg</span>
                <span class="s1">self._py2js_removeLayoutProps = </span><span class="s0">None</span>

            <span class="s3"># ### Create axis objects ###</span>
            <span class="s3"># For example, when a SPLOM trace is created the layout defaults</span>
            <span class="s3"># may include axes that weren't explicitly defined by the user.</span>
            <span class="s0">for </span><span class="s1">proppath </span><span class="s0">in </span><span class="s1">delta_transform:</span>
                <span class="s1">prop = proppath[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s1">match = self.layout._subplot_re_match(prop)</span>
                <span class="s0">if </span><span class="s1">match </span><span class="s0">and </span><span class="s1">prop </span><span class="s0">not in </span><span class="s1">self.layout:</span>
                    <span class="s3"># We need to create a subplotid object</span>
                    <span class="s1">self.layout[prop] = {}</span>

            <span class="s3"># ### Dispatch change callbacks ###</span>
            <span class="s1">self._dispatch_layout_change_callbacks(delta_transform)</span>

            <span class="s3"># ### Layout edits no longer in process ###</span>
            <span class="s1">self._layout_edit_in_process = </span><span class="s0">False</span>

            <span class="s3"># ### Call any waiting layout edit callbacks ###</span>
            <span class="s0">if not </span><span class="s1">self._trace_edit_in_process:</span>
                <span class="s0">while </span><span class="s1">self._waiting_edit_callbacks:</span>
                    <span class="s1">self._waiting_edit_callbacks.pop()()</span>

        <span class="s1">self._js2py_layoutDelta = </span><span class="s0">None</span>

    <span class="s1">@observe(</span><span class="s4">&quot;_js2py_restyle&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">_handler_js2py_restyle(self</span><span class="s0">, </span><span class="s1">change):</span>
        <span class="s2">&quot;&quot;&quot; 
        Process Plotly.restyle message from the frontend 
        &quot;&quot;&quot;</span>

        <span class="s3"># Receive message</span>
        <span class="s3"># ---------------</span>
        <span class="s1">restyle_msg = change[</span><span class="s4">&quot;new&quot;</span><span class="s1">]</span>

        <span class="s0">if not </span><span class="s1">restyle_msg:</span>
            <span class="s1">self._js2py_restyle = </span><span class="s0">None</span>
            <span class="s0">return</span>

        <span class="s1">style_data = restyle_msg[</span><span class="s4">&quot;style_data&quot;</span><span class="s1">]</span>
        <span class="s1">style_traces = restyle_msg[</span><span class="s4">&quot;style_traces&quot;</span><span class="s1">]</span>
        <span class="s1">source_view_id = restyle_msg[</span><span class="s4">&quot;source_view_id&quot;</span><span class="s1">]</span>

        <span class="s3"># Perform restyle</span>
        <span class="s3"># ---------------</span>
        <span class="s1">self.plotly_restyle(</span>
            <span class="s1">restyle_data=style_data</span><span class="s0">,</span>
            <span class="s1">trace_indexes=style_traces</span><span class="s0">,</span>
            <span class="s1">source_view_id=source_view_id</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">self._js2py_restyle = </span><span class="s0">None</span>

    <span class="s1">@observe(</span><span class="s4">&quot;_js2py_update&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">_handler_js2py_update(self</span><span class="s0">, </span><span class="s1">change):</span>
        <span class="s2">&quot;&quot;&quot; 
        Process Plotly.update message from the frontend 
        &quot;&quot;&quot;</span>

        <span class="s3"># Receive message</span>
        <span class="s3"># ---------------</span>
        <span class="s1">update_msg = change[</span><span class="s4">&quot;new&quot;</span><span class="s1">]</span>

        <span class="s0">if not </span><span class="s1">update_msg:</span>
            <span class="s1">self._js2py_update = </span><span class="s0">None</span>
            <span class="s0">return</span>

        <span class="s1">style = update_msg[</span><span class="s4">&quot;style_data&quot;</span><span class="s1">]</span>
        <span class="s1">trace_indexes = update_msg[</span><span class="s4">&quot;style_traces&quot;</span><span class="s1">]</span>
        <span class="s1">layout = update_msg[</span><span class="s4">&quot;layout_data&quot;</span><span class="s1">]</span>
        <span class="s1">source_view_id = update_msg[</span><span class="s4">&quot;source_view_id&quot;</span><span class="s1">]</span>

        <span class="s3"># Perform update</span>
        <span class="s3"># --------------</span>
        <span class="s1">self.plotly_update(</span>
            <span class="s1">restyle_data=style</span><span class="s0">,</span>
            <span class="s1">relayout_data=layout</span><span class="s0">,</span>
            <span class="s1">trace_indexes=trace_indexes</span><span class="s0">,</span>
            <span class="s1">source_view_id=source_view_id</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">self._js2py_update = </span><span class="s0">None</span>

    <span class="s1">@observe(</span><span class="s4">&quot;_js2py_relayout&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">_handler_js2py_relayout(self</span><span class="s0">, </span><span class="s1">change):</span>
        <span class="s2">&quot;&quot;&quot; 
        Process Plotly.relayout message from the frontend 
        &quot;&quot;&quot;</span>

        <span class="s3"># Receive message</span>
        <span class="s3"># ---------------</span>
        <span class="s1">relayout_msg = change[</span><span class="s4">&quot;new&quot;</span><span class="s1">]</span>

        <span class="s0">if not </span><span class="s1">relayout_msg:</span>
            <span class="s1">self._js2py_relayout = </span><span class="s0">None</span>
            <span class="s0">return</span>

        <span class="s1">relayout_data = relayout_msg[</span><span class="s4">&quot;relayout_data&quot;</span><span class="s1">]</span>
        <span class="s1">source_view_id = relayout_msg[</span><span class="s4">&quot;source_view_id&quot;</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s4">&quot;lastInputTime&quot; </span><span class="s0">in </span><span class="s1">relayout_data:</span>
            <span class="s3"># Remove 'lastInputTime'. Seems to be an internal plotly</span>
            <span class="s3"># property that is introduced for some plot types, but it is not</span>
            <span class="s3"># actually a property in the schema</span>
            <span class="s1">relayout_data.pop(</span><span class="s4">&quot;lastInputTime&quot;</span><span class="s1">)</span>

        <span class="s3"># Perform relayout</span>
        <span class="s3"># ----------------</span>
        <span class="s1">self.plotly_relayout(relayout_data=relayout_data</span><span class="s0">, </span><span class="s1">source_view_id=source_view_id)</span>

        <span class="s1">self._js2py_relayout = </span><span class="s0">None</span>

    <span class="s1">@observe(</span><span class="s4">&quot;_js2py_pointsCallback&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">_handler_js2py_pointsCallback(self</span><span class="s0">, </span><span class="s1">change):</span>
        <span class="s2">&quot;&quot;&quot; 
        Process points callback message from the frontend 
        &quot;&quot;&quot;</span>

        <span class="s3"># Receive message</span>
        <span class="s3"># ---------------</span>
        <span class="s1">callback_data = change[</span><span class="s4">&quot;new&quot;</span><span class="s1">]</span>

        <span class="s0">if not </span><span class="s1">callback_data:</span>
            <span class="s1">self._js2py_pointsCallback = </span><span class="s0">None</span>
            <span class="s0">return</span>

        <span class="s3"># Get event type</span>
        <span class="s3"># --------------</span>
        <span class="s1">event_type = callback_data[</span><span class="s4">&quot;event_type&quot;</span><span class="s1">]</span>

        <span class="s3"># Build Selector Object</span>
        <span class="s3"># ---------------------</span>
        <span class="s0">if </span><span class="s1">callback_data.get(</span><span class="s4">&quot;selector&quot;</span><span class="s0">, None</span><span class="s1">):</span>
            <span class="s1">selector_data = callback_data[</span><span class="s4">&quot;selector&quot;</span><span class="s1">]</span>
            <span class="s1">selector_type = selector_data[</span><span class="s4">&quot;type&quot;</span><span class="s1">]</span>
            <span class="s1">selector_state = selector_data[</span><span class="s4">&quot;selector_state&quot;</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">selector_type == </span><span class="s4">&quot;box&quot;</span><span class="s1">:</span>
                <span class="s1">selector = BoxSelector(**selector_state)</span>
            <span class="s0">elif </span><span class="s1">selector_type == </span><span class="s4">&quot;lasso&quot;</span><span class="s1">:</span>
                <span class="s1">selector = LassoSelector(**selector_state)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unsupported selector type: %s&quot; </span><span class="s1">% selector_type)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">selector = </span><span class="s0">None</span>

        <span class="s3"># Build Input Device State Object</span>
        <span class="s3"># -------------------------------</span>
        <span class="s0">if </span><span class="s1">callback_data.get(</span><span class="s4">&quot;device_state&quot;</span><span class="s0">, None</span><span class="s1">):</span>
            <span class="s1">device_state_data = callback_data[</span><span class="s4">&quot;device_state&quot;</span><span class="s1">]</span>
            <span class="s1">state = InputDeviceState(**device_state_data)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">state = </span><span class="s0">None</span>

        <span class="s3"># Build Trace Points Dictionary</span>
        <span class="s3"># -----------------------------</span>
        <span class="s1">points_data = callback_data[</span><span class="s4">&quot;points&quot;</span><span class="s1">]</span>
        <span class="s1">trace_points = {</span>
            <span class="s1">trace_ind: {</span>
                <span class="s4">&quot;point_inds&quot;</span><span class="s1">: []</span><span class="s0">,</span>
                <span class="s4">&quot;xs&quot;</span><span class="s1">: []</span><span class="s0">,</span>
                <span class="s4">&quot;ys&quot;</span><span class="s1">: []</span><span class="s0">,</span>
                <span class="s4">&quot;trace_name&quot;</span><span class="s1">: self._data_objs[trace_ind].name</span><span class="s0">,</span>
                <span class="s4">&quot;trace_index&quot;</span><span class="s1">: trace_ind</span><span class="s0">,</span>
            <span class="s1">}</span>
            <span class="s0">for </span><span class="s1">trace_ind </span><span class="s0">in </span><span class="s1">range(len(self._data_objs))</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">point_ind</span><span class="s0">, </span><span class="s1">trace_ind </span><span class="s0">in </span><span class="s1">zip(</span>
            <span class="s1">points_data[</span><span class="s4">&quot;xs&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">points_data[</span><span class="s4">&quot;ys&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">points_data[</span><span class="s4">&quot;point_indexes&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">points_data[</span><span class="s4">&quot;trace_indexes&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">):</span>

            <span class="s1">trace_dict = trace_points[trace_ind]</span>
            <span class="s1">trace_dict[</span><span class="s4">&quot;xs&quot;</span><span class="s1">].append(x)</span>
            <span class="s1">trace_dict[</span><span class="s4">&quot;ys&quot;</span><span class="s1">].append(y)</span>
            <span class="s1">trace_dict[</span><span class="s4">&quot;point_inds&quot;</span><span class="s1">].append(point_ind)</span>

        <span class="s3"># Dispatch callbacks</span>
        <span class="s3"># ------------------</span>
        <span class="s0">for </span><span class="s1">trace_ind</span><span class="s0">, </span><span class="s1">trace_points_data </span><span class="s0">in </span><span class="s1">trace_points.items():</span>
            <span class="s1">points = Points(**trace_points_data)</span>
            <span class="s1">trace = self.data[trace_ind]</span>

            <span class="s0">if </span><span class="s1">event_type == </span><span class="s4">&quot;plotly_click&quot;</span><span class="s1">:</span>
                <span class="s1">trace._dispatch_on_click(points</span><span class="s0">, </span><span class="s1">state)</span>
            <span class="s0">elif </span><span class="s1">event_type == </span><span class="s4">&quot;plotly_hover&quot;</span><span class="s1">:</span>
                <span class="s1">trace._dispatch_on_hover(points</span><span class="s0">, </span><span class="s1">state)</span>
            <span class="s0">elif </span><span class="s1">event_type == </span><span class="s4">&quot;plotly_unhover&quot;</span><span class="s1">:</span>
                <span class="s1">trace._dispatch_on_unhover(points</span><span class="s0">, </span><span class="s1">state)</span>
            <span class="s0">elif </span><span class="s1">event_type == </span><span class="s4">&quot;plotly_selected&quot;</span><span class="s1">:</span>
                <span class="s1">trace._dispatch_on_selection(points</span><span class="s0">, </span><span class="s1">selector)</span>
            <span class="s0">elif </span><span class="s1">event_type == </span><span class="s4">&quot;plotly_deselect&quot;</span><span class="s1">:</span>
                <span class="s1">trace._dispatch_on_deselect(points)</span>

        <span class="s1">self._js2py_pointsCallback = </span><span class="s0">None</span>

    <span class="s3"># Display</span>
    <span class="s3"># -------</span>
    <span class="s0">def </span><span class="s1">_ipython_display_(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Handle rich display of figures in ipython contexts 
        &quot;&quot;&quot;</span>
        <span class="s3"># Override BaseFigure's display to make sure we display the widget version</span>
        <span class="s1">widgets.DOMWidget._ipython_display_(self)</span>

    <span class="s3"># Callbacks</span>
    <span class="s3"># ---------</span>
    <span class="s0">def </span><span class="s1">on_edits_completed(self</span><span class="s0">, </span><span class="s1">fn):</span>
        <span class="s2">&quot;&quot;&quot; 
        Register a function to be called after all pending trace and layout 
        edit operations have completed 
 
        If there are no pending edit operations then function is called 
        immediately 
 
        Parameters 
        ---------- 
        fn : callable 
            Function of zero arguments to be called when all pending edit 
            operations have completed 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._layout_edit_in_process </span><span class="s0">or </span><span class="s1">self._trace_edit_in_process:</span>
            <span class="s1">self._waiting_edit_callbacks.append(fn)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">fn()</span>

    <span class="s3"># Validate No Frames</span>
    <span class="s3"># ------------------</span>
    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">frames(self):</span>
        <span class="s3"># Note: This property getter is identical to that of the superclass,</span>
        <span class="s3"># but it must be included here because we're overriding the setter</span>
        <span class="s3"># below.</span>
        <span class="s0">return </span><span class="s1">self._frame_objs</span>

    <span class="s1">@frames.setter</span>
    <span class="s0">def </span><span class="s1">frames(self</span><span class="s0">, </span><span class="s1">new_frames):</span>
        <span class="s0">if </span><span class="s1">new_frames:</span>
            <span class="s1">BaseFigureWidget._display_frames_error()</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_display_frames_error():</span>
        <span class="s2">&quot;&quot;&quot; 
        Display an informative error when user attempts to set frames on a 
        FigureWidget 
 
        Raises 
        ------ 
        ValueError 
            always 
        &quot;&quot;&quot;</span>
        <span class="s1">msg = </span><span class="s4">&quot;&quot;&quot; 
Frames are not supported by the plotly.graph_objs.FigureWidget class. 
Note: Frames are supported by the plotly.graph_objs.Figure class&quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s3"># Static Helpers</span>
    <span class="s3"># --------------</span>
    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_remove_overlapping_props(input_data</span><span class="s0">, </span><span class="s1">delta_data</span><span class="s0">, </span><span class="s1">prop_path=()):</span>
        <span class="s2">&quot;&quot;&quot; 
        Remove properties in input_data that are also in delta_data, and do so 
        recursively. 
 
        Exception: Never remove 'uid' from input_data, this property is used 
        to align traces 
 
        Parameters 
        ---------- 
        input_data : dict|list 
        delta_data : dict|list 
 
        Returns 
        ------- 
        list[tuple[str|int]] 
            List of removed property path tuples 
        &quot;&quot;&quot;</span>

        <span class="s3"># Initialize removed</span>
        <span class="s3"># ------------------</span>
        <span class="s3"># This is the list of path tuples to the properties that were</span>
        <span class="s3"># removed from input_data</span>
        <span class="s1">removed = []</span>

        <span class="s3"># Handle dict</span>
        <span class="s3"># -----------</span>
        <span class="s0">if </span><span class="s1">isinstance(input_data</span><span class="s0">, </span><span class="s1">dict):</span>
            <span class="s0">assert </span><span class="s1">isinstance(delta_data</span><span class="s0">, </span><span class="s1">dict)</span>

            <span class="s0">for </span><span class="s1">p</span><span class="s0">, </span><span class="s1">delta_val </span><span class="s0">in </span><span class="s1">delta_data.items():</span>
                <span class="s0">if </span><span class="s1">isinstance(delta_val</span><span class="s0">, </span><span class="s1">dict) </span><span class="s0">or </span><span class="s1">BaseFigure._is_dict_list(delta_val):</span>
                    <span class="s0">if </span><span class="s1">p </span><span class="s0">in </span><span class="s1">input_data:</span>
                        <span class="s3"># ### Recurse ###</span>
                        <span class="s1">input_val = input_data[p]</span>
                        <span class="s1">recur_prop_path = prop_path + (p</span><span class="s0">,</span><span class="s1">)</span>
                        <span class="s1">recur_removed = BaseFigureWidget._remove_overlapping_props(</span>
                            <span class="s1">input_val</span><span class="s0">, </span><span class="s1">delta_val</span><span class="s0">, </span><span class="s1">recur_prop_path</span>
                        <span class="s1">)</span>
                        <span class="s1">removed.extend(recur_removed)</span>

                        <span class="s3"># Check whether the last property in input_val</span>
                        <span class="s3"># has been removed. If so, remove it entirely</span>
                        <span class="s0">if not </span><span class="s1">input_val:</span>
                            <span class="s1">input_data.pop(p)</span>
                            <span class="s1">removed.append(recur_prop_path)</span>

                <span class="s0">elif </span><span class="s1">p </span><span class="s0">in </span><span class="s1">input_data </span><span class="s0">and </span><span class="s1">p != </span><span class="s4">&quot;uid&quot;</span><span class="s1">:</span>
                    <span class="s3"># ### Remove property ###</span>
                    <span class="s1">input_data.pop(p)</span>
                    <span class="s1">removed.append(prop_path + (p</span><span class="s0">,</span><span class="s1">))</span>

        <span class="s3"># Handle list</span>
        <span class="s3"># -----------</span>
        <span class="s0">elif </span><span class="s1">isinstance(input_data</span><span class="s0">, </span><span class="s1">list):</span>
            <span class="s0">assert </span><span class="s1">isinstance(delta_data</span><span class="s0">, </span><span class="s1">list)</span>

            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">delta_val </span><span class="s0">in </span><span class="s1">enumerate(delta_data):</span>
                <span class="s0">if </span><span class="s1">i &gt;= len(input_data):</span>
                    <span class="s0">break</span>

                <span class="s1">input_val = input_data[i]</span>
                <span class="s0">if </span><span class="s1">(</span>
                    <span class="s1">input_val </span><span class="s0">is not None</span>
                    <span class="s0">and </span><span class="s1">isinstance(delta_val</span><span class="s0">, </span><span class="s1">dict)</span>
                    <span class="s0">or </span><span class="s1">BaseFigure._is_dict_list(delta_val)</span>
                <span class="s1">):</span>

                    <span class="s3"># ### Recurse ###</span>
                    <span class="s1">recur_prop_path = prop_path + (i</span><span class="s0">,</span><span class="s1">)</span>
                    <span class="s1">recur_removed = BaseFigureWidget._remove_overlapping_props(</span>
                        <span class="s1">input_val</span><span class="s0">, </span><span class="s1">delta_val</span><span class="s0">, </span><span class="s1">recur_prop_path</span>
                    <span class="s1">)</span>

                    <span class="s1">removed.extend(recur_removed)</span>

        <span class="s0">return </span><span class="s1">removed</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_transform_data(to_data</span><span class="s0">, </span><span class="s1">from_data</span><span class="s0">, </span><span class="s1">should_remove=</span><span class="s0">True, </span><span class="s1">relayout_path=()):</span>
        <span class="s2">&quot;&quot;&quot; 
        Transform to_data into from_data and return relayout-style 
        description of the transformation 
 
        Parameters 
        ---------- 
        to_data : dict|list 
        from_data : dict|list 
 
        Returns 
        ------- 
        dict 
            relayout-style description of the transformation 
        &quot;&quot;&quot;</span>

        <span class="s3"># Initialize relayout data</span>
        <span class="s3"># ------------------------</span>
        <span class="s1">relayout_data = {}</span>

        <span class="s3"># Handle dict</span>
        <span class="s3"># -----------</span>
        <span class="s0">if </span><span class="s1">isinstance(to_data</span><span class="s0">, </span><span class="s1">dict):</span>

            <span class="s3"># ### Validate from_data ###</span>
            <span class="s0">if not </span><span class="s1">isinstance(from_data</span><span class="s0">, </span><span class="s1">dict):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Mismatched data types: {to_dict} {from_data}&quot;</span><span class="s1">.format(</span>
                        <span class="s1">to_dict=to_data</span><span class="s0">, </span><span class="s1">from_data=from_data</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

            <span class="s3"># ### Add/modify properties ###</span>
            <span class="s3"># Loop over props/vals</span>
            <span class="s0">for </span><span class="s1">from_prop</span><span class="s0">, </span><span class="s1">from_val </span><span class="s0">in </span><span class="s1">from_data.items():</span>

                <span class="s3"># #### Handle compound vals recursively ####</span>
                <span class="s0">if </span><span class="s1">isinstance(from_val</span><span class="s0">, </span><span class="s1">dict) </span><span class="s0">or </span><span class="s1">BaseFigure._is_dict_list(from_val):</span>

                    <span class="s3"># ##### Init property value if needed #####</span>
                    <span class="s0">if </span><span class="s1">from_prop </span><span class="s0">not in </span><span class="s1">to_data:</span>
                        <span class="s1">to_data[from_prop] = {} </span><span class="s0">if </span><span class="s1">isinstance(from_val</span><span class="s0">, </span><span class="s1">dict) </span><span class="s0">else </span><span class="s1">[]</span>

                    <span class="s3"># ##### Transform property val recursively #####</span>
                    <span class="s1">input_val = to_data[from_prop]</span>
                    <span class="s1">relayout_data.update(</span>
                        <span class="s1">BaseFigureWidget._transform_data(</span>
                            <span class="s1">input_val</span><span class="s0">,</span>
                            <span class="s1">from_val</span><span class="s0">,</span>
                            <span class="s1">should_remove=should_remove</span><span class="s0">,</span>
                            <span class="s1">relayout_path=relayout_path + (from_prop</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>

                <span class="s3"># #### Handle simple vals directly ####</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">from_prop </span><span class="s0">not in </span><span class="s1">to_data </span><span class="s0">or not </span><span class="s1">BasePlotlyType._vals_equal(</span>
                        <span class="s1">to_data[from_prop]</span><span class="s0">, </span><span class="s1">from_val</span>
                    <span class="s1">):</span>

                        <span class="s1">to_data[from_prop] = from_val</span>
                        <span class="s1">relayout_path_prop = relayout_path + (from_prop</span><span class="s0">,</span><span class="s1">)</span>
                        <span class="s1">relayout_data[relayout_path_prop] = from_val</span>

            <span class="s3"># ### Remove properties ###</span>
            <span class="s0">if </span><span class="s1">should_remove:</span>
                <span class="s0">for </span><span class="s1">remove_prop </span><span class="s0">in </span><span class="s1">set(to_data.keys()).difference(</span>
                    <span class="s1">set(from_data.keys())</span>
                <span class="s1">):</span>
                    <span class="s1">to_data.pop(remove_prop)</span>

        <span class="s3"># Handle list</span>
        <span class="s3"># -----------</span>
        <span class="s0">elif </span><span class="s1">isinstance(to_data</span><span class="s0">, </span><span class="s1">list):</span>

            <span class="s3"># ### Validate from_data ###</span>
            <span class="s0">if not </span><span class="s1">isinstance(from_data</span><span class="s0">, </span><span class="s1">list):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Mismatched data types: to_data: {to_data} {from_data}&quot;</span><span class="s1">.format(</span>
                        <span class="s1">to_data=to_data</span><span class="s0">, </span><span class="s1">from_data=from_data</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

            <span class="s3"># ### Add/modify properties ###</span>
            <span class="s3"># Loop over indexes / elements</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">from_val </span><span class="s0">in </span><span class="s1">enumerate(from_data):</span>

                <span class="s3"># #### Initialize element if needed ####</span>
                <span class="s0">if </span><span class="s1">i &gt;= len(to_data):</span>
                    <span class="s1">to_data.append(</span><span class="s0">None</span><span class="s1">)</span>
                <span class="s1">input_val = to_data[i]</span>

                <span class="s3"># #### Handle compound element recursively ####</span>
                <span class="s0">if </span><span class="s1">input_val </span><span class="s0">is not None and </span><span class="s1">(</span>
                    <span class="s1">isinstance(from_val</span><span class="s0">, </span><span class="s1">dict) </span><span class="s0">or </span><span class="s1">BaseFigure._is_dict_list(from_val)</span>
                <span class="s1">):</span>

                    <span class="s1">relayout_data.update(</span>
                        <span class="s1">BaseFigureWidget._transform_data(</span>
                            <span class="s1">input_val</span><span class="s0">,</span>
                            <span class="s1">from_val</span><span class="s0">,</span>
                            <span class="s1">should_remove=should_remove</span><span class="s0">,</span>
                            <span class="s1">relayout_path=relayout_path + (i</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>

                <span class="s3"># #### Handle simple elements directly ####</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">if not </span><span class="s1">BasePlotlyType._vals_equal(to_data[i]</span><span class="s0">, </span><span class="s1">from_val):</span>
                        <span class="s1">to_data[i] = from_val</span>
                        <span class="s1">relayout_data[relayout_path + (i</span><span class="s0">,</span><span class="s1">)] = from_val</span>

        <span class="s0">return </span><span class="s1">relayout_data</span>
</pre>
</body>
</html>