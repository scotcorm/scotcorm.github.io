<html>
<head>
<title>test_logical_ops.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_logical_ops.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">datetime</span>
<span class="s0">import </span><span class="s1">operator</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s0">,</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">bdate_range</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>
<span class="s0">from </span><span class="s1">pandas.core </span><span class="s0">import </span><span class="s1">ops</span>


<span class="s0">class </span><span class="s1">TestSeriesLogicalOps:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;bool_op&quot;</span><span class="s0">, </span><span class="s1">[operator.and_</span><span class="s0">, </span><span class="s1">operator.or_</span><span class="s0">, </span><span class="s1">operator.xor])</span>
    <span class="s0">def </span><span class="s1">test_bool_operators_with_nas(self</span><span class="s0">, </span><span class="s1">bool_op):</span>
        <span class="s3"># boolean &amp;, |, ^ should work with object arrays and propagate NAs</span>
        <span class="s1">ser = Series(bdate_range(</span><span class="s2">&quot;1/1/2000&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">ser[::</span><span class="s4">2</span><span class="s1">] = np.nan</span>

        <span class="s1">mask = ser.isna()</span>
        <span class="s1">filled = ser.fillna(ser[</span><span class="s4">0</span><span class="s1">])</span>

        <span class="s1">result = bool_op(ser &lt; ser[</span><span class="s4">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ser &gt; ser[</span><span class="s4">3</span><span class="s1">])</span>

        <span class="s1">expected = bool_op(filled &lt; filled[</span><span class="s4">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">filled &gt; filled[</span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">expected[mask] = </span><span class="s0">False</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_logical_operators_bool_dtype_with_empty(self):</span>
        <span class="s3"># GH#9016: support bitwise op for integer types</span>
        <span class="s1">index = list(</span><span class="s2">&quot;bca&quot;</span><span class="s1">)</span>

        <span class="s1">s_tft = Series([</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index)</span>
        <span class="s1">s_fff = Series([</span><span class="s0">False, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index)</span>
        <span class="s1">s_empty = Series([]</span><span class="s0">, </span><span class="s1">dtype=object)</span>

        <span class="s1">res = s_tft &amp; s_empty</span>
        <span class="s1">expected = s_fff</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">res = s_tft | s_empty</span>
        <span class="s1">expected = s_tft</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_logical_operators_int_dtype_with_int_dtype(self):</span>
        <span class="s3"># GH#9016: support bitwise op for integer types</span>

        <span class="s1">s_0123 = Series(range(</span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span>
        <span class="s1">s_3333 = Series([</span><span class="s4">3</span><span class="s1">] * </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">s_4444 = Series([</span><span class="s4">4</span><span class="s1">] * </span><span class="s4">4</span><span class="s1">)</span>

        <span class="s1">res = s_0123 &amp; s_3333</span>
        <span class="s1">expected = Series(range(</span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">res = s_0123 | s_4444</span>
        <span class="s1">expected = Series(range(</span><span class="s4">4</span><span class="s0">, </span><span class="s4">8</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">s_1111 = Series([</span><span class="s4">1</span><span class="s1">] * </span><span class="s4">4</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int8&quot;</span><span class="s1">)</span>
        <span class="s1">res = s_0123 &amp; s_1111</span>
        <span class="s1">expected = Series([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">res = s_0123.astype(np.int16) | s_1111.astype(np.int32)</span>
        <span class="s1">expected = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int32&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_logical_operators_int_dtype_with_int_scalar(self):</span>
        <span class="s3"># GH#9016: support bitwise op for integer types</span>
        <span class="s1">s_0123 = Series(range(</span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span>

        <span class="s1">res = s_0123 &amp; </span><span class="s4">0</span>
        <span class="s1">expected = Series([</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">res = s_0123 &amp; </span><span class="s4">1</span>
        <span class="s1">expected = Series([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_logical_operators_int_dtype_with_float(self):</span>
        <span class="s3"># GH#9016: support bitwise op for integer types</span>
        <span class="s1">s_0123 = Series(range(</span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span>

        <span class="s1">msg = </span><span class="s2">&quot;Cannot perform.+with a dtyped.+array and scalar of type&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s_0123 &amp; np.NaN</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s_0123 &amp; </span><span class="s4">3.14</span>
        <span class="s1">msg = </span><span class="s2">&quot;unsupported operand type.+for &amp;:&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s_0123 &amp; [</span><span class="s4">0.1</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">3.14</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s_0123 &amp; np.array([</span><span class="s4">0.1</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">3.14</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s_0123 &amp; Series([</span><span class="s4">0.1</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s1">-</span><span class="s4">3.14</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_logical_operators_int_dtype_with_str(self):</span>
        <span class="s1">s_1111 = Series([</span><span class="s4">1</span><span class="s1">] * </span><span class="s4">4</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int8&quot;</span><span class="s1">)</span>
        <span class="s1">msg = </span><span class="s2">&quot;Cannot perform 'and_' with a dtyped.+array and scalar of type&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s_1111 &amp; </span><span class="s2">&quot;a&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;unsupported operand.+for &amp;&quot;</span><span class="s1">):</span>
            <span class="s1">s_1111 &amp; [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_logical_operators_int_dtype_with_bool(self):</span>
        <span class="s3"># GH#9016: support bitwise op for integer types</span>
        <span class="s1">s_0123 = Series(range(</span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span>

        <span class="s1">expected = Series([</span><span class="s0">False</span><span class="s1">] * </span><span class="s4">4</span><span class="s1">)</span>

        <span class="s1">result = s_0123 &amp; </span><span class="s0">False</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">result = s_0123 &amp; [</span><span class="s0">False</span><span class="s1">]</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">result = s_0123 &amp; (</span><span class="s0">False,</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">result = s_0123 ^ </span><span class="s0">False</span>
        <span class="s1">expected = Series([</span><span class="s0">False, True, True, True</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_logical_operators_int_dtype_with_object(self):</span>
        <span class="s3"># GH#9016: support bitwise op for integer types</span>
        <span class="s1">s_0123 = Series(range(</span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span>

        <span class="s1">result = s_0123 &amp; Series([</span><span class="s0">False, </span><span class="s1">np.NaN</span><span class="s0">, False, False</span><span class="s1">])</span>
        <span class="s1">expected = Series([</span><span class="s0">False</span><span class="s1">] * </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">s_abNd = Series([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">np.NaN</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;unsupported.* 'int' and 'str'&quot;</span><span class="s1">):</span>
            <span class="s1">s_0123 &amp; s_abNd</span>

    <span class="s0">def </span><span class="s1">test_logical_operators_bool_dtype_with_int(self):</span>
        <span class="s1">index = list(</span><span class="s2">&quot;bca&quot;</span><span class="s1">)</span>

        <span class="s1">s_tft = Series([</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index)</span>
        <span class="s1">s_fff = Series([</span><span class="s0">False, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index)</span>

        <span class="s1">res = s_tft &amp; </span><span class="s4">0</span>
        <span class="s1">expected = s_fff</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">res = s_tft &amp; </span><span class="s4">1</span>
        <span class="s1">expected = s_tft</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_logical_ops_bool_dtype_with_ndarray(self):</span>
        <span class="s3"># make sure we operate on ndarray the same as Series</span>
        <span class="s1">left = Series([</span><span class="s0">True, True, True, False, True</span><span class="s1">])</span>
        <span class="s1">right = [</span><span class="s0">True, False, None, True, </span><span class="s1">np.nan]</span>

        <span class="s1">expected = Series([</span><span class="s0">True, False, False, False, False</span><span class="s1">])</span>
        <span class="s1">result = left &amp; right</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s1">result = left &amp; np.array(right)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s1">result = left &amp; Index(right)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s1">result = left &amp; Series(right)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series([</span><span class="s0">True, True, True, True, True</span><span class="s1">])</span>
        <span class="s1">result = left | right</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s1">result = left | np.array(right)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s1">result = left | Index(right)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s1">result = left | Series(right)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series([</span><span class="s0">False, True, True, True, True</span><span class="s1">])</span>
        <span class="s1">result = left ^ right</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s1">result = left ^ np.array(right)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s1">result = left ^ Index(right)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s1">result = left ^ Series(right)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_logical_operators_int_dtype_with_bool_dtype_and_reindex(self):</span>
        <span class="s3"># GH#9016: support bitwise op for integer types</span>

        <span class="s3"># with non-matching indexes, logical operators will cast to object</span>
        <span class="s3">#  before operating</span>
        <span class="s1">index = list(</span><span class="s2">&quot;bca&quot;</span><span class="s1">)</span>

        <span class="s1">s_tft = Series([</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index)</span>
        <span class="s1">s_tft = Series([</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index)</span>
        <span class="s1">s_tff = Series([</span><span class="s0">True, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index)</span>

        <span class="s1">s_0123 = Series(range(</span><span class="s4">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span>

        <span class="s3"># s_0123 will be all false now because of reindexing like s_tft</span>
        <span class="s1">expected = Series([</span><span class="s0">False</span><span class="s1">] * </span><span class="s4">7</span><span class="s0">, </span><span class="s1">index=[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>
        <span class="s1">result = s_tft &amp; s_0123</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series([</span><span class="s0">False</span><span class="s1">] * </span><span class="s4">7</span><span class="s0">, </span><span class="s1">index=[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>
        <span class="s1">result = s_0123 &amp; s_tft</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">s_a0b1c0 = Series([</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list(</span><span class="s2">&quot;b&quot;</span><span class="s1">))</span>

        <span class="s1">res = s_tft &amp; s_a0b1c0</span>
        <span class="s1">expected = s_tff.reindex(list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">))</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">res = s_tft | s_a0b1c0</span>
        <span class="s1">expected = s_tft.reindex(list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">))</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_scalar_na_logical_ops_corners(self):</span>
        <span class="s1">s = Series([</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">9</span><span class="s0">, </span><span class="s4">10</span><span class="s1">])</span>

        <span class="s1">msg = </span><span class="s2">&quot;Cannot perform.+with a dtyped.+array and scalar of type&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s &amp; datetime(</span><span class="s4">2005</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">s = Series([</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">9</span><span class="s0">, </span><span class="s1">datetime(</span><span class="s4">2005</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)])</span>
        <span class="s1">s[::</span><span class="s4">2</span><span class="s1">] = np.nan</span>

        <span class="s1">expected = Series(</span><span class="s0">True, </span><span class="s1">index=s.index)</span>
        <span class="s1">expected[::</span><span class="s4">2</span><span class="s1">] = </span><span class="s0">False</span>
        <span class="s1">result = s &amp; list(s)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_scalar_na_logical_ops_corners_aligns(self):</span>
        <span class="s1">s = Series([</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">9</span><span class="s0">, </span><span class="s1">datetime(</span><span class="s4">2005</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)])</span>
        <span class="s1">s[::</span><span class="s4">2</span><span class="s1">] = np.nan</span>
        <span class="s1">d = DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: s})</span>

        <span class="s1">expected = DataFrame(</span><span class="s0">False, </span><span class="s1">index=range(</span><span class="s4">9</span><span class="s1">)</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;A&quot;</span><span class="s1">] + list(range(</span><span class="s4">9</span><span class="s1">)))</span>

        <span class="s1">result = s &amp; d</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">result = d &amp; s</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;op&quot;</span><span class="s0">, </span><span class="s1">[operator.and_</span><span class="s0">, </span><span class="s1">operator.or_</span><span class="s0">, </span><span class="s1">operator.xor])</span>
    <span class="s0">def </span><span class="s1">test_logical_ops_with_index(self</span><span class="s0">, </span><span class="s1">op):</span>
        <span class="s3"># GH#22092, GH#19792</span>
        <span class="s1">ser = Series([</span><span class="s0">True, True, False, False</span><span class="s1">])</span>
        <span class="s1">idx1 = Index([</span><span class="s0">True, False, True, False</span><span class="s1">])</span>
        <span class="s1">idx2 = Index([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span>

        <span class="s1">expected = Series([op(ser[n]</span><span class="s0">, </span><span class="s1">idx1[n]) </span><span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">range(len(ser))])</span>

        <span class="s1">result = op(ser</span><span class="s0">, </span><span class="s1">idx1)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series([op(ser[n]</span><span class="s0">, </span><span class="s1">idx2[n]) </span><span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">range(len(ser))]</span><span class="s0">, </span><span class="s1">dtype=bool)</span>

        <span class="s1">result = op(ser</span><span class="s0">, </span><span class="s1">idx2)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s2">&quot;ignore:passing object-dtype arraylike:FutureWarning&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_reversed_xor_with_index_returns_index(self):</span>
        <span class="s3"># GH#22092, GH#19792</span>
        <span class="s1">ser = Series([</span><span class="s0">True, True, False, False</span><span class="s1">])</span>
        <span class="s1">idx1 = Index([</span><span class="s0">True, False, True, False</span><span class="s1">])</span>
        <span class="s1">idx2 = Index([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span>

        <span class="s1">msg = </span><span class="s2">&quot;operating as a set operation&quot;</span>

        <span class="s1">expected = Index.symmetric_difference(idx1</span><span class="s0">, </span><span class="s1">ser)</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">result = idx1 ^ ser</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Index.symmetric_difference(idx2</span><span class="s0">, </span><span class="s1">ser)</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">result = idx2 ^ ser</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;op&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">pytest.param(</span>
                <span class="s1">ops.rand_</span><span class="s0">,</span>
                <span class="s1">marks=pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;GH#22092 Index __and__ returns Index intersection&quot;</span><span class="s0">,</span>
                    <span class="s1">raises=AssertionError</span><span class="s0">,</span>
                <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">pytest.param(</span>
                <span class="s1">ops.ror_</span><span class="s0">,</span>
                <span class="s1">marks=pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;GH#22092 Index __or__ returns Index union&quot;</span><span class="s0">,</span>
                    <span class="s1">raises=AssertionError</span><span class="s0">,</span>
                <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_reversed_logical_op_with_index_returns_series(self</span><span class="s0">, </span><span class="s1">op):</span>
        <span class="s3"># GH#22092, GH#19792</span>
        <span class="s1">ser = Series([</span><span class="s0">True, True, False, False</span><span class="s1">])</span>
        <span class="s1">idx1 = Index([</span><span class="s0">True, False, True, False</span><span class="s1">])</span>
        <span class="s1">idx2 = Index([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span>

        <span class="s1">msg = </span><span class="s2">&quot;operating as a set operation&quot;</span>

        <span class="s1">expected = Series(op(idx1.values</span><span class="s0">, </span><span class="s1">ser.values))</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">result = op(ser</span><span class="s0">, </span><span class="s1">idx1)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series(op(idx2.values</span><span class="s0">, </span><span class="s1">ser.values))</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">result = op(ser</span><span class="s0">, </span><span class="s1">idx2)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;op, expected&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(ops.rand_</span><span class="s0">, </span><span class="s1">Index([</span><span class="s0">False, True</span><span class="s1">]))</span><span class="s0">,</span>
            <span class="s1">(ops.ror_</span><span class="s0">, </span><span class="s1">Index([</span><span class="s0">False, True</span><span class="s1">]))</span><span class="s0">,</span>
            <span class="s1">(ops.rxor</span><span class="s0">, </span><span class="s1">Index([]))</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_reverse_ops_with_index(self</span><span class="s0">, </span><span class="s1">op</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s3"># https://github.com/pandas-dev/pandas/pull/23628</span>
        <span class="s3"># multi-set Index ops are buggy, so let's avoid duplicates...</span>
        <span class="s1">ser = Series([</span><span class="s0">True, False</span><span class="s1">])</span>
        <span class="s1">idx = Index([</span><span class="s0">False, True</span><span class="s1">])</span>

        <span class="s1">msg = </span><span class="s2">&quot;operating as a set operation&quot;</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s3"># behaving as set ops is deprecated, will become logical ops</span>
            <span class="s1">result = op(ser</span><span class="s0">, </span><span class="s1">idx)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_logical_ops_label_based(self):</span>
        <span class="s3"># GH#4947</span>
        <span class="s3"># logical ops should be label based</span>

        <span class="s1">a = Series([</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list(</span><span class="s2">&quot;bca&quot;</span><span class="s1">))</span>
        <span class="s1">b = Series([</span><span class="s0">False, True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">))</span>

        <span class="s1">expected = Series([</span><span class="s0">False, True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">))</span>
        <span class="s1">result = a &amp; b</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series([</span><span class="s0">True, True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">))</span>
        <span class="s1">result = a | b</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series([</span><span class="s0">True, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">))</span>
        <span class="s1">result = a ^ b</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s3"># rhs is bigger</span>
        <span class="s1">a = Series([</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list(</span><span class="s2">&quot;bca&quot;</span><span class="s1">))</span>
        <span class="s1">b = Series([</span><span class="s0">False, True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list(</span><span class="s2">&quot;abcd&quot;</span><span class="s1">))</span>

        <span class="s1">expected = Series([</span><span class="s0">False, True, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list(</span><span class="s2">&quot;abcd&quot;</span><span class="s1">))</span>
        <span class="s1">result = a &amp; b</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series([</span><span class="s0">True, True, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list(</span><span class="s2">&quot;abcd&quot;</span><span class="s1">))</span>
        <span class="s1">result = a | b</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s3"># filling</span>

        <span class="s3"># vs empty</span>
        <span class="s1">empty = Series([]</span><span class="s0">, </span><span class="s1">dtype=object)</span>

        <span class="s1">result = a &amp; empty.copy()</span>
        <span class="s1">expected = Series([</span><span class="s0">False, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list(</span><span class="s2">&quot;bca&quot;</span><span class="s1">))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">result = a | empty.copy()</span>
        <span class="s1">expected = Series([</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list(</span><span class="s2">&quot;bca&quot;</span><span class="s1">))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s3"># vs non-matching</span>
        <span class="s1">result = a &amp; Series([</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;z&quot;</span><span class="s1">])</span>
        <span class="s1">expected = Series([</span><span class="s0">False, False, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list(</span><span class="s2">&quot;abcz&quot;</span><span class="s1">))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">result = a | Series([</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;z&quot;</span><span class="s1">])</span>
        <span class="s1">expected = Series([</span><span class="s0">True, True, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list(</span><span class="s2">&quot;abcz&quot;</span><span class="s1">))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s3"># identity</span>
        <span class="s3"># we would like s[s|e] == s to hold for any e, whether empty or not</span>
        <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">[</span>
            <span class="s1">empty.copy()</span><span class="s0">,</span>
            <span class="s1">Series([</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;z&quot;</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">Series(np.nan</span><span class="s0">, </span><span class="s1">b.index)</span><span class="s0">,</span>
            <span class="s1">Series(np.nan</span><span class="s0">, </span><span class="s1">a.index)</span><span class="s0">,</span>
        <span class="s1">]:</span>
            <span class="s1">result = a[a | e]</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">a[a])</span>

        <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">[Series([</span><span class="s2">&quot;z&quot;</span><span class="s1">])]:</span>
            <span class="s1">result = a[a | e]</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">a[a])</span>

        <span class="s3"># vs scalars</span>
        <span class="s1">index = list(</span><span class="s2">&quot;bca&quot;</span><span class="s1">)</span>
        <span class="s1">t = Series([</span><span class="s0">True, False, True</span><span class="s1">])</span>

        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">[</span><span class="s0">True, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]:</span>
            <span class="s1">result = Series([</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index) | v</span>
            <span class="s1">expected = Series([</span><span class="s0">True, True, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index)</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">msg = </span><span class="s2">&quot;Cannot perform.+with a dtyped.+array and scalar of type&quot;</span>
        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s2">&quot;foo&quot;</span><span class="s1">]:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">t | v</span>

        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">[</span><span class="s0">False, </span><span class="s4">0</span><span class="s1">]:</span>
            <span class="s1">result = Series([</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index) | v</span>
            <span class="s1">expected = Series([</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index)</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">[</span><span class="s0">True, </span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s1">result = Series([</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index) &amp; v</span>
            <span class="s1">expected = Series([</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index)</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">[</span><span class="s0">False, </span><span class="s4">0</span><span class="s1">]:</span>
            <span class="s1">result = Series([</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index) &amp; v</span>
            <span class="s1">expected = Series([</span><span class="s0">False, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index)</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s1">msg = </span><span class="s2">&quot;Cannot perform.+with a dtyped.+array and scalar of type&quot;</span>
        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">[np.nan]:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">t &amp; v</span>

    <span class="s0">def </span><span class="s1">test_logical_ops_df_compat(self):</span>
        <span class="s3"># GH#1134</span>
        <span class="s1">s1 = Series([</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;ABC&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">s2 = Series([</span><span class="s0">True, True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;ABD&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>

        <span class="s1">exp = Series([</span><span class="s0">True, False, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;ABCD&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(s1 &amp; s2</span><span class="s0">, </span><span class="s1">exp)</span>
        <span class="s1">tm.assert_series_equal(s2 &amp; s1</span><span class="s0">, </span><span class="s1">exp)</span>

        <span class="s3"># True | np.nan =&gt; True</span>
        <span class="s1">exp_or1 = Series([</span><span class="s0">True, True, True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;ABCD&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(s1 | s2</span><span class="s0">, </span><span class="s1">exp_or1)</span>
        <span class="s3"># np.nan | True =&gt; np.nan, filled with False</span>
        <span class="s1">exp_or = Series([</span><span class="s0">True, True, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;ABCD&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(s2 | s1</span><span class="s0">, </span><span class="s1">exp_or)</span>

        <span class="s3"># DataFrame doesn't fill nan with False</span>
        <span class="s1">tm.assert_frame_equal(s1.to_frame() &amp; s2.to_frame()</span><span class="s0">, </span><span class="s1">exp.to_frame())</span>
        <span class="s1">tm.assert_frame_equal(s2.to_frame() &amp; s1.to_frame()</span><span class="s0">, </span><span class="s1">exp.to_frame())</span>

        <span class="s1">exp = DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s0">True, True, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]}</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;ABCD&quot;</span><span class="s1">))</span>
        <span class="s1">tm.assert_frame_equal(s1.to_frame() | s2.to_frame()</span><span class="s0">, </span><span class="s1">exp_or1.to_frame())</span>
        <span class="s1">tm.assert_frame_equal(s2.to_frame() | s1.to_frame()</span><span class="s0">, </span><span class="s1">exp_or.to_frame())</span>

        <span class="s3"># different length</span>
        <span class="s1">s3 = Series([</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;ABC&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">s4 = Series([</span><span class="s0">True, True, True, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;ABCD&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>

        <span class="s1">exp = Series([</span><span class="s0">True, False, True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;ABCD&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(s3 &amp; s4</span><span class="s0">, </span><span class="s1">exp)</span>
        <span class="s1">tm.assert_series_equal(s4 &amp; s3</span><span class="s0">, </span><span class="s1">exp)</span>

        <span class="s3"># np.nan | True =&gt; np.nan, filled with False</span>
        <span class="s1">exp_or1 = Series([</span><span class="s0">True, True, True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;ABCD&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(s3 | s4</span><span class="s0">, </span><span class="s1">exp_or1)</span>
        <span class="s3"># True | np.nan =&gt; True</span>
        <span class="s1">exp_or = Series([</span><span class="s0">True, True, True, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;ABCD&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(s4 | s3</span><span class="s0">, </span><span class="s1">exp_or)</span>

        <span class="s1">tm.assert_frame_equal(s3.to_frame() &amp; s4.to_frame()</span><span class="s0">, </span><span class="s1">exp.to_frame())</span>
        <span class="s1">tm.assert_frame_equal(s4.to_frame() &amp; s3.to_frame()</span><span class="s0">, </span><span class="s1">exp.to_frame())</span>

        <span class="s1">tm.assert_frame_equal(s3.to_frame() | s4.to_frame()</span><span class="s0">, </span><span class="s1">exp_or1.to_frame())</span>
        <span class="s1">tm.assert_frame_equal(s4.to_frame() | s3.to_frame()</span><span class="s0">, </span><span class="s1">exp_or.to_frame())</span>
</pre>
</body>
</html>