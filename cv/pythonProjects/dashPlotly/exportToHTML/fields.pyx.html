<html>
<head>
<title>fields.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fields.pyx</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;</span>
<span class="s0">Functions for accessing attributes of Timestamp/datetime64/datetime-like</span>
<span class="s0">objects and arrays</span>
<span class="s0">&quot;&quot;&quot;</span>
<span class="s0">from locale import LC_TIME</span>

<span class="s0">import cython</span>
<span class="s0">from cython import Py_ssize_t</span>
<span class="s0">import numpy as np</span>

<span class="s0">cimport numpy as cnp</span>
<span class="s0">from numpy cimport (</span>
    <span class="s0">int8_t,</span>
    <span class="s0">int32_t,</span>
    <span class="s0">int64_t,</span>
    <span class="s0">ndarray,</span>
    <span class="s0">uint32_t,</span>
<span class="s0">)</span>

<span class="s0">cnp.import_array()</span>

<span class="s0">from pandas._config.localization import set_locale</span>

<span class="s0">from pandas._libs.tslibs.ccalendar import (</span>
    <span class="s0">DAYS_FULL,</span>
    <span class="s0">MONTHS_FULL,</span>
<span class="s0">)</span>

<span class="s0">from pandas._libs.tslibs.ccalendar cimport (</span>
    <span class="s0">dayofweek,</span>
    <span class="s0">get_day_of_year,</span>
    <span class="s0">get_days_in_month,</span>
    <span class="s0">get_firstbday,</span>
    <span class="s0">get_iso_calendar,</span>
    <span class="s0">get_lastbday,</span>
    <span class="s0">get_week_of_year,</span>
    <span class="s0">is_leapyear,</span>
    <span class="s0">iso_calendar_t,</span>
    <span class="s0">month_offset,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.nattype cimport NPY_NAT</span>
<span class="s0">from pandas._libs.tslibs.np_datetime cimport (</span>
    <span class="s0">dt64_to_dtstruct,</span>
    <span class="s0">npy_datetimestruct,</span>
    <span class="s0">pandas_timedeltastruct,</span>
    <span class="s0">td64_to_tdstruct,</span>
<span class="s0">)</span>

<span class="s0">from pandas._libs.tslibs.strptime import LocaleTime</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def build_field_sarray(const int64_t[:] dtindex):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Datetime as int64 representation to a structured array of fields</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, count = len(dtindex)</span>
        <span class="s0">npy_datetimestruct dts</span>
        <span class="s0">ndarray[int32_t] years, months, days, hours, minutes, seconds, mus</span>

    <span class="s0">sa_dtype = [</span>
        <span class="s0">(&quot;Y&quot;, &quot;i4&quot;),  # year</span>
        <span class="s0">(&quot;M&quot;, &quot;i4&quot;),  # month</span>
        <span class="s0">(&quot;D&quot;, &quot;i4&quot;),  # day</span>
        <span class="s0">(&quot;h&quot;, &quot;i4&quot;),  # hour</span>
        <span class="s0">(&quot;m&quot;, &quot;i4&quot;),  # min</span>
        <span class="s0">(&quot;s&quot;, &quot;i4&quot;),  # second</span>
        <span class="s0">(&quot;u&quot;, &quot;i4&quot;),  # microsecond</span>
    <span class="s0">]</span>

    <span class="s0">out = np.empty(count, dtype=sa_dtype)</span>

    <span class="s0">years = out['Y']</span>
    <span class="s0">months = out['M']</span>
    <span class="s0">days = out['D']</span>
    <span class="s0">hours = out['h']</span>
    <span class="s0">minutes = out['m']</span>
    <span class="s0">seconds = out['s']</span>
    <span class="s0">mus = out['u']</span>

    <span class="s0">for i in range(count):</span>
        <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
        <span class="s0">years[i] = dts.year</span>
        <span class="s0">months[i] = dts.month</span>
        <span class="s0">days[i] = dts.day</span>
        <span class="s0">hours[i] = dts.hour</span>
        <span class="s0">minutes[i] = dts.min</span>
        <span class="s0">seconds[i] = dts.sec</span>
        <span class="s0">mus[i] = dts.us</span>

    <span class="s0">return out</span>


<span class="s0">def month_position_check(fields, weekdays) -&gt; str | None:</span>
    <span class="s0">cdef:</span>
        <span class="s0">int32_t daysinmonth, y, m, d</span>
        <span class="s0">bint calendar_end = True</span>
        <span class="s0">bint business_end = True</span>
        <span class="s0">bint calendar_start = True</span>
        <span class="s0">bint business_start = True</span>
        <span class="s0">bint cal</span>
        <span class="s0">int32_t[:] years = fields[&quot;Y&quot;]</span>
        <span class="s0">int32_t[:] months = fields[&quot;M&quot;]</span>
        <span class="s0">int32_t[:] days = fields[&quot;D&quot;]</span>

    <span class="s0">for y, m, d, wd in zip(years, months, days, weekdays):</span>
        <span class="s0">if calendar_start:</span>
            <span class="s0">calendar_start &amp;= d == 1</span>
        <span class="s0">if business_start:</span>
            <span class="s0">business_start &amp;= d == 1 or (d &lt;= 3 and wd == 0)</span>

        <span class="s0">if calendar_end or business_end:</span>
            <span class="s0">daysinmonth = get_days_in_month(y, m)</span>
            <span class="s0">cal = d == daysinmonth</span>
            <span class="s0">if calendar_end:</span>
                <span class="s0">calendar_end &amp;= cal</span>
            <span class="s0">if business_end:</span>
                <span class="s0">business_end &amp;= cal or (daysinmonth - d &lt; 3 and wd == 4)</span>
        <span class="s0">elif not calendar_start and not business_start:</span>
            <span class="s0">break</span>

    <span class="s0">if calendar_end:</span>
        <span class="s0">return &quot;ce&quot;</span>
    <span class="s0">elif business_end:</span>
        <span class="s0">return &quot;be&quot;</span>
    <span class="s0">elif calendar_start:</span>
        <span class="s0">return &quot;cs&quot;</span>
    <span class="s0">elif business_start:</span>
        <span class="s0">return &quot;bs&quot;</span>
    <span class="s0">else:</span>
        <span class="s0">return None</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def get_date_name_field(const int64_t[:] dtindex, str field, object locale=None):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Given a int64-based datetime index, return array of strings of date</span>
    <span class="s0">name based on requested field (e.g. day_name)</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, count = len(dtindex)</span>
        <span class="s0">ndarray[object] out, names</span>
        <span class="s0">npy_datetimestruct dts</span>
        <span class="s0">int dow</span>

    <span class="s0">out = np.empty(count, dtype=object)</span>

    <span class="s0">if field == 'day_name':</span>
        <span class="s0">if locale is None:</span>
            <span class="s0">names = np.array(DAYS_FULL, dtype=np.object_)</span>
        <span class="s0">else:</span>
            <span class="s0">names = np.array(get_locale_names('f_weekday', locale),</span>
                             <span class="s0">dtype=np.object_)</span>
        <span class="s0">for i in range(count):</span>
            <span class="s0">if dtindex[i] == NPY_NAT:</span>
                <span class="s0">out[i] = np.nan</span>
                <span class="s0">continue</span>

            <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
            <span class="s0">dow = dayofweek(dts.year, dts.month, dts.day)</span>
            <span class="s0">out[i] = names[dow].capitalize()</span>

    <span class="s0">elif field == 'month_name':</span>
        <span class="s0">if locale is None:</span>
            <span class="s0">names = np.array(MONTHS_FULL, dtype=np.object_)</span>
        <span class="s0">else:</span>
            <span class="s0">names = np.array(get_locale_names('f_month', locale),</span>
                             <span class="s0">dtype=np.object_)</span>
        <span class="s0">for i in range(count):</span>
            <span class="s0">if dtindex[i] == NPY_NAT:</span>
                <span class="s0">out[i] = np.nan</span>
                <span class="s0">continue</span>

            <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
            <span class="s0">out[i] = names[dts.month].capitalize()</span>

    <span class="s0">else:</span>
        <span class="s0">raise ValueError(f&quot;Field {field} not supported&quot;)</span>

    <span class="s0">return out</span>


<span class="s0">cdef inline bint _is_on_month(int month, int compare_month, int modby) nogil:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Analogous to DateOffset.is_on_offset checking for the month part of a date.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if modby == 1:</span>
        <span class="s0">return True</span>
    <span class="s0">elif modby == 3:</span>
        <span class="s0">return (month - compare_month) % 3 == 0</span>
    <span class="s0">else:</span>
        <span class="s0">return month == compare_month</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def get_start_end_field(const int64_t[:] dtindex, str field,</span>
                        <span class="s0">str freqstr=None, int month_kw=12):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Given an int64-based datetime index return array of indicators</span>
    <span class="s0">of whether timestamps are at the start/end of the month/quarter/year</span>
    <span class="s0">(defined by frequency).</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i</span>
        <span class="s0">int count = len(dtindex)</span>
        <span class="s0">bint is_business = 0</span>
        <span class="s0">int end_month = 12</span>
        <span class="s0">int start_month = 1</span>
        <span class="s0">ndarray[int8_t] out</span>
        <span class="s0">npy_datetimestruct dts</span>
        <span class="s0">int compare_month, modby</span>

    <span class="s0">out = np.zeros(count, dtype='int8')</span>

    <span class="s0">if freqstr:</span>
        <span class="s0">if freqstr == 'C':</span>
            <span class="s0">raise ValueError(f&quot;Custom business days is not supported by {field}&quot;)</span>
        <span class="s0">is_business = freqstr[0] == 'B'</span>

        <span class="s0"># YearBegin(), BYearBegin() use month = starting month of year.</span>
        <span class="s0"># QuarterBegin(), BQuarterBegin() use startingMonth = starting</span>
        <span class="s0"># month of year. Other offsets use month, startingMonth as ending</span>
        <span class="s0"># month of year.</span>

        <span class="s0">if (freqstr[0:2] in ['MS', 'QS', 'AS']) or (</span>
                <span class="s0">freqstr[1:3] in ['MS', 'QS', 'AS']):</span>
            <span class="s0">end_month = 12 if month_kw == 1 else month_kw - 1</span>
            <span class="s0">start_month = month_kw</span>
        <span class="s0">else:</span>
            <span class="s0">end_month = month_kw</span>
            <span class="s0">start_month = (end_month % 12) + 1</span>
    <span class="s0">else:</span>
        <span class="s0">end_month = 12</span>
        <span class="s0">start_month = 1</span>

    <span class="s0">compare_month = start_month if &quot;start&quot; in field else end_month</span>
    <span class="s0">if &quot;month&quot; in field:</span>
        <span class="s0">modby = 1</span>
    <span class="s0">elif &quot;quarter&quot; in field:</span>
        <span class="s0">modby = 3</span>
    <span class="s0">else:</span>
        <span class="s0">modby = 12</span>

    <span class="s0">if field in [&quot;is_month_start&quot;, &quot;is_quarter_start&quot;, &quot;is_year_start&quot;]:</span>
        <span class="s0">if is_business:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if dtindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = 0</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>

                <span class="s0">if _is_on_month(dts.month, compare_month, modby) and (</span>
                        <span class="s0">dts.day == get_firstbday(dts.year, dts.month)):</span>
                    <span class="s0">out[i] = 1</span>

        <span class="s0">else:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if dtindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = 0</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>

                <span class="s0">if _is_on_month(dts.month, compare_month, modby) and dts.day == 1:</span>
                    <span class="s0">out[i] = 1</span>

    <span class="s0">elif field in [&quot;is_month_end&quot;, &quot;is_quarter_end&quot;, &quot;is_year_end&quot;]:</span>
        <span class="s0">if is_business:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if dtindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = 0</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>

                <span class="s0">if _is_on_month(dts.month, compare_month, modby) and (</span>
                        <span class="s0">dts.day == get_lastbday(dts.year, dts.month)):</span>
                    <span class="s0">out[i] = 1</span>

        <span class="s0">else:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if dtindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = 0</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>

                <span class="s0">if _is_on_month(dts.month, compare_month, modby) and (</span>
                        <span class="s0">dts.day == get_days_in_month(dts.year, dts.month)):</span>
                    <span class="s0">out[i] = 1</span>

    <span class="s0">else:</span>
        <span class="s0">raise ValueError(f&quot;Field {field} not supported&quot;)</span>

    <span class="s0">return out.view(bool)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def get_date_field(const int64_t[:] dtindex, str field):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Given a int64-based datetime index, extract the year, month, etc.,</span>
    <span class="s0">field and return an array of these values.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, count = len(dtindex)</span>
        <span class="s0">ndarray[int32_t] out</span>
        <span class="s0">npy_datetimestruct dts</span>

    <span class="s0">out = np.empty(count, dtype='i4')</span>

    <span class="s0">if field == 'Y':</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if dtindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
                <span class="s0">out[i] = dts.year</span>
        <span class="s0">return out</span>

    <span class="s0">elif field == 'M':</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if dtindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
                <span class="s0">out[i] = dts.month</span>
        <span class="s0">return out</span>

    <span class="s0">elif field == 'D':</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if dtindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
                <span class="s0">out[i] = dts.day</span>
        <span class="s0">return out</span>

    <span class="s0">elif field == 'h':</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if dtindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
                <span class="s0">out[i] = dts.hour</span>
        <span class="s0">return out</span>

    <span class="s0">elif field == 'm':</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if dtindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
                <span class="s0">out[i] = dts.min</span>
        <span class="s0">return out</span>

    <span class="s0">elif field == 's':</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if dtindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
                <span class="s0">out[i] = dts.sec</span>
        <span class="s0">return out</span>

    <span class="s0">elif field == 'us':</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if dtindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
                <span class="s0">out[i] = dts.us</span>
        <span class="s0">return out</span>

    <span class="s0">elif field == 'ns':</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if dtindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
                <span class="s0">out[i] = dts.ps // 1000</span>
        <span class="s0">return out</span>
    <span class="s0">elif field == 'doy':</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if dtindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
                <span class="s0">out[i] = get_day_of_year(dts.year, dts.month, dts.day)</span>
        <span class="s0">return out</span>

    <span class="s0">elif field == 'dow':</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if dtindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
                <span class="s0">out[i] = dayofweek(dts.year, dts.month, dts.day)</span>
        <span class="s0">return out</span>

    <span class="s0">elif field == 'woy':</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if dtindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
                <span class="s0">out[i] = get_week_of_year(dts.year, dts.month, dts.day)</span>
        <span class="s0">return out</span>

    <span class="s0">elif field == 'q':</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if dtindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
                <span class="s0">out[i] = dts.month</span>
                <span class="s0">out[i] = ((out[i] - 1) // 3) + 1</span>
        <span class="s0">return out</span>

    <span class="s0">elif field == 'dim':</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if dtindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
                <span class="s0">out[i] = get_days_in_month(dts.year, dts.month)</span>
        <span class="s0">return out</span>
    <span class="s0">elif field == 'is_leap_year':</span>
        <span class="s0">return isleapyear_arr(get_date_field(dtindex, 'Y'))</span>

    <span class="s0">raise ValueError(f&quot;Field {field} not supported&quot;)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def get_timedelta_field(const int64_t[:] tdindex, str field):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Given a int64-based timedelta index, extract the days, hrs, sec.,</span>
    <span class="s0">field and return an array of these values.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, count = len(tdindex)</span>
        <span class="s0">ndarray[int32_t] out</span>
        <span class="s0">pandas_timedeltastruct tds</span>

    <span class="s0">out = np.empty(count, dtype='i4')</span>

    <span class="s0">if field == 'days':</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if tdindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">td64_to_tdstruct(tdindex[i], &amp;tds)</span>
                <span class="s0">out[i] = tds.days</span>
        <span class="s0">return out</span>

    <span class="s0">elif field == 'seconds':</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if tdindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">td64_to_tdstruct(tdindex[i], &amp;tds)</span>
                <span class="s0">out[i] = tds.seconds</span>
        <span class="s0">return out</span>

    <span class="s0">elif field == 'microseconds':</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if tdindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">td64_to_tdstruct(tdindex[i], &amp;tds)</span>
                <span class="s0">out[i] = tds.microseconds</span>
        <span class="s0">return out</span>

    <span class="s0">elif field == 'nanoseconds':</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if tdindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = -1</span>
                    <span class="s0">continue</span>

                <span class="s0">td64_to_tdstruct(tdindex[i], &amp;tds)</span>
                <span class="s0">out[i] = tds.nanoseconds</span>
        <span class="s0">return out</span>

    <span class="s0">raise ValueError(f&quot;Field {field} not supported&quot;)</span>


<span class="s0">cpdef isleapyear_arr(ndarray years):</span>
    <span class="s0">&quot;&quot;&quot;vectorized version of isleapyear; NaT evaluates as False&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">ndarray[int8_t] out</span>

    <span class="s0">out = np.zeros(len(years), dtype='int8')</span>
    <span class="s0">out[np.logical_or(years % 400 == 0,</span>
                      <span class="s0">np.logical_and(years % 4 == 0,</span>
                                     <span class="s0">years % 100 &gt; 0))] = 1</span>
    <span class="s0">return out.view(bool)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def build_isocalendar_sarray(const int64_t[:] dtindex):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Given a int64-based datetime array, return the ISO 8601 year, week, and day</span>
    <span class="s0">as a structured array.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, count = len(dtindex)</span>
        <span class="s0">npy_datetimestruct dts</span>
        <span class="s0">ndarray[uint32_t] iso_years, iso_weeks, days</span>
        <span class="s0">iso_calendar_t ret_val</span>

    <span class="s0">sa_dtype = [</span>
        <span class="s0">(&quot;year&quot;, &quot;u4&quot;),</span>
        <span class="s0">(&quot;week&quot;, &quot;u4&quot;),</span>
        <span class="s0">(&quot;day&quot;, &quot;u4&quot;),</span>
    <span class="s0">]</span>

    <span class="s0">out = np.empty(count, dtype=sa_dtype)</span>

    <span class="s0">iso_years = out[&quot;year&quot;]</span>
    <span class="s0">iso_weeks = out[&quot;week&quot;]</span>
    <span class="s0">days = out[&quot;day&quot;]</span>

    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(count):</span>
            <span class="s0">if dtindex[i] == NPY_NAT:</span>
                <span class="s0">ret_val = 0, 0, 0</span>
            <span class="s0">else:</span>
                <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
                <span class="s0">ret_val = get_iso_calendar(dts.year, dts.month, dts.day)</span>

            <span class="s0">iso_years[i] = ret_val[0]</span>
            <span class="s0">iso_weeks[i] = ret_val[1]</span>
            <span class="s0">days[i] = ret_val[2]</span>
    <span class="s0">return out</span>


<span class="s0">def get_locale_names(name_type: str, locale: object = None):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Returns an array of localized day or month names.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">name_type : str</span>
        <span class="s0">Attribute of LocaleTime() in which to return localized names.</span>
    <span class="s0">locale : str</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">list of locale names</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">with set_locale(locale, LC_TIME):</span>
        <span class="s0">return getattr(LocaleTime(), name_type)</span>


<span class="s0"># ---------------------------------------------------------------------</span>
<span class="s0"># Rounding</span>


<span class="s0">class RoundTo:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">enumeration defining the available rounding modes</span>

    <span class="s0">Attributes</span>
    <span class="s0">----------</span>
    <span class="s0">MINUS_INFTY</span>
        <span class="s0">round towards -∞, or floor [2]_</span>
    <span class="s0">PLUS_INFTY</span>
        <span class="s0">round towards +∞, or ceil [3]_</span>
    <span class="s0">NEAREST_HALF_EVEN</span>
        <span class="s0">round to nearest, tie-break half to even [6]_</span>
    <span class="s0">NEAREST_HALF_MINUS_INFTY</span>
        <span class="s0">round to nearest, tie-break half to -∞ [5]_</span>
    <span class="s0">NEAREST_HALF_PLUS_INFTY</span>
        <span class="s0">round to nearest, tie-break half to +∞ [4]_</span>


    <span class="s0">References</span>
    <span class="s0">----------</span>
    <span class="s0">.. [1] &quot;Rounding - Wikipedia&quot;</span>
           <span class="s0">https://en.wikipedia.org/wiki/Rounding</span>
    <span class="s0">.. [2] &quot;Rounding down&quot;</span>
           <span class="s0">https://en.wikipedia.org/wiki/Rounding#Rounding_down</span>
    <span class="s0">.. [3] &quot;Rounding up&quot;</span>
           <span class="s0">https://en.wikipedia.org/wiki/Rounding#Rounding_up</span>
    <span class="s0">.. [4] &quot;Round half up&quot;</span>
           <span class="s0">https://en.wikipedia.org/wiki/Rounding#Round_half_up</span>
    <span class="s0">.. [5] &quot;Round half down&quot;</span>
           <span class="s0">https://en.wikipedia.org/wiki/Rounding#Round_half_down</span>
    <span class="s0">.. [6] &quot;Round half to even&quot;</span>
           <span class="s0">https://en.wikipedia.org/wiki/Rounding#Round_half_to_even</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">@property</span>
    <span class="s0">def MINUS_INFTY(self) -&gt; int:</span>
        <span class="s0">return 0</span>

    <span class="s0">@property</span>
    <span class="s0">def PLUS_INFTY(self) -&gt; int:</span>
        <span class="s0">return 1</span>

    <span class="s0">@property</span>
    <span class="s0">def NEAREST_HALF_EVEN(self) -&gt; int:</span>
        <span class="s0">return 2</span>

    <span class="s0">@property</span>
    <span class="s0">def NEAREST_HALF_PLUS_INFTY(self) -&gt; int:</span>
        <span class="s0">return 3</span>

    <span class="s0">@property</span>
    <span class="s0">def NEAREST_HALF_MINUS_INFTY(self) -&gt; int:</span>
        <span class="s0">return 4</span>


<span class="s0">cdef inline ndarray[int64_t] _floor_int64(int64_t[:] values, int64_t unit):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(values)</span>
        <span class="s0">ndarray[int64_t] result = np.empty(n, dtype=&quot;i8&quot;)</span>
        <span class="s0">int64_t res, value</span>

    <span class="s0">with cython.overflowcheck(True):</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">value = values[i]</span>
            <span class="s0">if value == NPY_NAT:</span>
                <span class="s0">res = NPY_NAT</span>
            <span class="s0">else:</span>
                <span class="s0">res = value - value % unit</span>
            <span class="s0">result[i] = res</span>

    <span class="s0">return result</span>


<span class="s0">cdef inline ndarray[int64_t] _ceil_int64(int64_t[:] values, int64_t unit):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(values)</span>
        <span class="s0">ndarray[int64_t] result = np.empty(n, dtype=&quot;i8&quot;)</span>
        <span class="s0">int64_t res, value</span>

    <span class="s0">with cython.overflowcheck(True):</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">value = values[i]</span>

            <span class="s0">if value == NPY_NAT:</span>
                <span class="s0">res = NPY_NAT</span>
            <span class="s0">else:</span>
                <span class="s0">remainder = value % unit</span>
                <span class="s0">if remainder == 0:</span>
                    <span class="s0">res = value</span>
                <span class="s0">else:</span>
                    <span class="s0">res = value + (unit - remainder)</span>

            <span class="s0">result[i] = res</span>

    <span class="s0">return result</span>


<span class="s0">cdef inline ndarray[int64_t] _rounddown_int64(values, int64_t unit):</span>
    <span class="s0">return _ceil_int64(values - unit // 2, unit)</span>


<span class="s0">cdef inline ndarray[int64_t] _roundup_int64(values, int64_t unit):</span>
    <span class="s0">return _floor_int64(values + unit // 2, unit)</span>


<span class="s0">def round_nsint64(values: np.ndarray, mode: RoundTo, nanos: int) -&gt; np.ndarray:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Applies rounding mode at given frequency</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">values : np.ndarray[int64_t]`</span>
    <span class="s0">mode : instance of `RoundTo` enumeration</span>
    <span class="s0">nanos : np.int64</span>
        <span class="s0">Freq to round to, expressed in nanoseconds</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">np.ndarray[int64_t]</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">int64_t unit = nanos</span>

    <span class="s0">if mode == RoundTo.MINUS_INFTY:</span>
        <span class="s0">return _floor_int64(values, unit)</span>
    <span class="s0">elif mode == RoundTo.PLUS_INFTY:</span>
        <span class="s0">return _ceil_int64(values, unit)</span>
    <span class="s0">elif mode == RoundTo.NEAREST_HALF_MINUS_INFTY:</span>
        <span class="s0">return _rounddown_int64(values, unit)</span>
    <span class="s0">elif mode == RoundTo.NEAREST_HALF_PLUS_INFTY:</span>
        <span class="s0">return _roundup_int64(values, unit)</span>
    <span class="s0">elif mode == RoundTo.NEAREST_HALF_EVEN:</span>
        <span class="s0"># for odd unit there is no need of a tie break</span>
        <span class="s0">if unit % 2:</span>
            <span class="s0">return _rounddown_int64(values, unit)</span>
        <span class="s0">quotient, remainder = np.divmod(values, unit)</span>
        <span class="s0">mask = np.logical_or(</span>
            <span class="s0">remainder &gt; (unit // 2),</span>
            <span class="s0">np.logical_and(remainder == (unit // 2), quotient % 2)</span>
        <span class="s0">)</span>
        <span class="s0">quotient[mask] += 1</span>
        <span class="s0">return quotient * unit</span>

    <span class="s0"># if/elif above should catch all rounding modes defined in enum 'RoundTo':</span>
    <span class="s0"># if flow of control arrives here, it is a bug</span>
    <span class="s0">raise ValueError(&quot;round_nsint64 called with an unrecognized rounding mode&quot;)</span>
</pre>
</body>
</html>