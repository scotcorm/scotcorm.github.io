<html>
<head>
<title>subplots.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
subplots.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">absolute_import</span><span class="s2">, </span><span class="s1">unicode_literals</span>

<span class="s0"># Constants</span>
<span class="s0"># ---------</span>
<span class="s0"># Subplot types that are each individually positioned with a domain</span>
<span class="s0">#</span>
<span class="s0"># Each of these subplot types has a `domain` property with `x`/`y`</span>
<span class="s0"># properties.</span>
<span class="s0"># Note that this set does not contain `xaxis`/`yaxis` because these behave a</span>
<span class="s0"># little differently.</span>
<span class="s2">import </span><span class="s1">collections</span>

<span class="s1">_single_subplot_types = {</span><span class="s3">&quot;scene&quot;</span><span class="s2">, </span><span class="s3">&quot;geo&quot;</span><span class="s2">, </span><span class="s3">&quot;polar&quot;</span><span class="s2">, </span><span class="s3">&quot;ternary&quot;</span><span class="s2">, </span><span class="s3">&quot;mapbox&quot;</span><span class="s1">}</span>
<span class="s1">_subplot_types = set.union(_single_subplot_types</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;xy&quot;</span><span class="s2">, </span><span class="s3">&quot;domain&quot;</span><span class="s1">})</span>

<span class="s0"># For most subplot types, a trace is associated with a particular subplot</span>
<span class="s0"># using a trace property with a name that matches the subplot type. For</span>
<span class="s0"># example, a `scatter3d.scene` property set to `'scene2'` associates a</span>
<span class="s0"># scatter3d trace with the second `scene` subplot in the figure.</span>
<span class="s0">#</span>
<span class="s0"># There are a few subplot types that don't follow this pattern, and instead</span>
<span class="s0"># the trace property is just named `subplot`.  For example setting</span>
<span class="s0"># the `scatterpolar.subplot` property to `polar3` associates the scatterpolar</span>
<span class="s0"># trace with the third polar subplot in the figure</span>
<span class="s1">_subplot_prop_named_subplot = {</span><span class="s3">&quot;polar&quot;</span><span class="s2">, </span><span class="s3">&quot;ternary&quot;</span><span class="s2">, </span><span class="s3">&quot;mapbox&quot;</span><span class="s1">}</span>


<span class="s0"># Named tuple to hold an xaxis/yaxis pair that represent a single subplot</span>
<span class="s1">SubplotXY = collections.namedtuple(</span><span class="s3">&quot;SubplotXY&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;xaxis&quot;</span><span class="s2">, </span><span class="s3">&quot;yaxis&quot;</span><span class="s1">))</span>
<span class="s1">SubplotDomain = collections.namedtuple(</span><span class="s3">&quot;SubplotDomain&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s3">&quot;y&quot;</span><span class="s1">))</span>

<span class="s1">SubplotRef = collections.namedtuple(</span>
    <span class="s3">&quot;SubplotRef&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;subplot_type&quot;</span><span class="s2">, </span><span class="s3">&quot;layout_keys&quot;</span><span class="s2">, </span><span class="s3">&quot;trace_kwargs&quot;</span><span class="s1">)</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">_get_initial_max_subplot_ids():</span>
    <span class="s1">max_subplot_ids = {subplot_type: </span><span class="s4">0 </span><span class="s2">for </span><span class="s1">subplot_type </span><span class="s2">in </span><span class="s1">_single_subplot_types}</span>
    <span class="s1">max_subplot_ids[</span><span class="s3">&quot;xaxis&quot;</span><span class="s1">] = </span><span class="s4">0</span>
    <span class="s1">max_subplot_ids[</span><span class="s3">&quot;yaxis&quot;</span><span class="s1">] = </span><span class="s4">0</span>
    <span class="s2">return </span><span class="s1">max_subplot_ids</span>


<span class="s2">def </span><span class="s1">make_subplots(</span>
    <span class="s1">rows=</span><span class="s4">1</span><span class="s2">,</span>
    <span class="s1">cols=</span><span class="s4">1</span><span class="s2">,</span>
    <span class="s1">shared_xaxes=</span><span class="s2">False,</span>
    <span class="s1">shared_yaxes=</span><span class="s2">False,</span>
    <span class="s1">start_cell=</span><span class="s3">&quot;top-left&quot;</span><span class="s2">,</span>
    <span class="s1">print_grid=</span><span class="s2">False,</span>
    <span class="s1">horizontal_spacing=</span><span class="s2">None,</span>
    <span class="s1">vertical_spacing=</span><span class="s2">None,</span>
    <span class="s1">subplot_titles=</span><span class="s2">None,</span>
    <span class="s1">column_widths=</span><span class="s2">None,</span>
    <span class="s1">row_heights=</span><span class="s2">None,</span>
    <span class="s1">specs=</span><span class="s2">None,</span>
    <span class="s1">insets=</span><span class="s2">None,</span>
    <span class="s1">column_titles=</span><span class="s2">None,</span>
    <span class="s1">row_titles=</span><span class="s2">None,</span>
    <span class="s1">x_title=</span><span class="s2">None,</span>
    <span class="s1">y_title=</span><span class="s2">None,</span>
    <span class="s1">figure=</span><span class="s2">None,</span>
    <span class="s1">**kwargs</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Return an instance of plotly.graph_objs.Figure with predefined subplots 
    configured in 'layout'. 
 
    Parameters 
    ---------- 
    rows: int (default 1) 
        Number of rows in the subplot grid. Must be greater than zero. 
 
    cols: int (default 1) 
        Number of columns in the subplot grid. Must be greater than zero. 
 
    shared_xaxes: boolean or str (default False) 
        Assign shared (linked) x-axes for 2D cartesian subplots 
 
          - True or 'columns': Share axes among subplots in the same column 
          - 'rows': Share axes among subplots in the same row 
          - 'all': Share axes across all subplots in the grid. 
 
    shared_yaxes: boolean or str (default False) 
        Assign shared (linked) y-axes for 2D cartesian subplots 
 
          - 'columns': Share axes among subplots in the same column 
          - True or 'rows': Share axes among subplots in the same row 
          - 'all': Share axes across all subplots in the grid. 
 
    start_cell: 'bottom-left' or 'top-left' (default 'top-left') 
        Choose the starting cell in the subplot grid used to set the 
        domains_grid of the subplots. 
 
          - 'top-left': Subplots are numbered with (1, 1) in the top 
                        left corner 
          - 'bottom-left': Subplots are numbererd with (1, 1) in the bottom 
                           left corner 
 
    print_grid: boolean (default True): 
        If True, prints a string representation of the plot grid.  Grid may 
        also be printed using the `Figure.print_grid()` method on the 
        resulting figure. 
 
    horizontal_spacing: float (default 0.2 / cols) 
        Space between subplot columns in normalized plot coordinates. Must be 
        a float between 0 and 1. 
 
        Applies to all columns (use 'specs' subplot-dependents spacing) 
 
    vertical_spacing: float (default 0.3 / rows) 
        Space between subplot rows in normalized plot coordinates. Must be 
        a float between 0 and 1. 
 
        Applies to all rows (use 'specs' subplot-dependents spacing) 
 
    subplot_titles: list of str or None (default None) 
        Title of each subplot as a list in row-major ordering. 
 
        Empty strings (&quot;&quot;) can be included in the list if no subplot title 
        is desired in that space so that the titles are properly indexed. 
 
    specs: list of lists of dict or None (default None) 
        Per subplot specifications of subplot type, row/column spanning, and 
        spacing. 
 
        ex1: specs=[[{}, {}], [{'colspan': 2}, None]] 
 
        ex2: specs=[[{'rowspan': 2}, {}], [None, {}]] 
 
        - Indices of the outer list correspond to subplot grid rows 
          starting from the top, if start_cell='top-left', 
          or bottom, if start_cell='bottom-left'. 
          The number of rows in 'specs' must be equal to 'rows'. 
 
        - Indices of the inner lists correspond to subplot grid columns 
          starting from the left. The number of columns in 'specs' 
          must be equal to 'cols'. 
 
        - Each item in the 'specs' list corresponds to one subplot 
          in a subplot grid. (N.B. The subplot grid has exactly 'rows' 
          times 'cols' cells.) 
 
        - Use None for a blank a subplot cell (or to move past a col/row span). 
 
        - Note that specs[0][0] has the specs of the 'start_cell' subplot. 
 
        - Each item in 'specs' is a dictionary. 
            The available keys are: 
            * type (string, default 'xy'): Subplot type. One of 
                - 'xy': 2D Cartesian subplot type for scatter, bar, etc. 
                - 'scene': 3D Cartesian subplot for scatter3d, cone, etc. 
                - 'polar': Polar subplot for scatterpolar, barpolar, etc. 
                - 'ternary': Ternary subplot for scatterternary 
                - 'mapbox': Mapbox subplot for scattermapbox 
                - 'domain': Subplot type for traces that are individually 
                            positioned. pie, parcoords, parcats, etc. 
                - trace type: A trace type which will be used to determine 
                              the appropriate subplot type for that trace 
 
            * secondary_y (bool, default False): If True, create a secondary 
                y-axis positioned on the right side of the subplot. Only valid 
                if type='xy'. 
            * colspan (int, default 1): number of subplot columns 
                for this subplot to span. 
            * rowspan (int, default 1): number of subplot rows 
                for this subplot to span. 
            * l (float, default 0.0): padding left of cell 
            * r (float, default 0.0): padding right of cell 
            * t (float, default 0.0): padding right of cell 
            * b (float, default 0.0): padding bottom of cell 
 
        - Note: Use 'horizontal_spacing' and 'vertical_spacing' to adjust 
          the spacing in between the subplots. 
 
    insets: list of dict or None (default None): 
        Inset specifications.  Insets are subplots that overlay grid subplots 
 
        - Each item in 'insets' is a dictionary. 
            The available keys are: 
 
            * cell (tuple, default=(1,1)): (row, col) index of the 
                subplot cell to overlay inset axes onto. 
            * type (string, default 'xy'): Subplot type 
            * l (float, default=0.0): padding left of inset 
                  in fraction of cell width 
            * w (float or 'to_end', default='to_end') inset width 
                  in fraction of cell width ('to_end': to cell right edge) 
            * b (float, default=0.0): padding bottom of inset 
                  in fraction of cell height 
            * h (float or 'to_end', default='to_end') inset height 
                  in fraction of cell height ('to_end': to cell top edge) 
 
    column_widths: list of numbers or None (default None) 
        list of length `cols` of the relative widths of each column of suplots. 
        Values are normalized internally and used to distribute overall width 
        of the figure (excluding padding) among the columns. 
 
        For backward compatibility, may also be specified using the 
        `column_width` keyword argument. 
 
    row_heights: list of numbers or None (default None) 
        list of length `rows` of the relative heights of each row of subplots. 
        If start_cell='top-left' then row heights are applied top to bottom. 
        Otherwise, if start_cell='bottom-left' then row heights are applied 
        bottom to top. 
 
        For backward compatibility, may also be specified using the 
        `row_width` kwarg. If specified as `row_width`, then the width values 
        are applied from bottom to top regardless of the value of start_cell. 
        This matches the legacy behavior of the `row_width` argument. 
 
    column_titles: list of str or None (default None) 
        list of length `cols` of titles to place above the top subplot in 
        each column. 
 
    row_titles: list of str or None (default None) 
        list of length `rows` of titles to place on the right side of each 
        row of subplots. If start_cell='top-left' then row titles are 
        applied top to bottom. Otherwise, if start_cell='bottom-left' then 
        row titles are applied bottom to top. 
 
    x_title: str or None (default None) 
        Title to place below the bottom row of subplots, 
        centered horizontally 
 
    y_title: str or None (default None) 
        Title to place to the left of the left column of subplots, 
        centered vertically 
 
    figure: go.Figure or None (default None) 
        If None, a new go.Figure instance will be created and its axes will be 
        populated with those corresponding to the requested subplot geometry and 
        this new figure will be returned. 
        If a go.Figure instance, the axes will be added to the 
        layout of this figure and this figure will be returned. If the figure 
        already contains axes, they will be overwritten. 
 
    Examples 
    -------- 
 
    Example 1: 
 
    &gt;&gt;&gt; # Stack two subplots vertically, and add a scatter trace to each 
    &gt;&gt;&gt; from plotly.subplots import make_subplots 
    &gt;&gt;&gt; import plotly.graph_objects as go 
    &gt;&gt;&gt; fig = make_subplots(rows=2) 
 
    This is the format of your plot grid: 
    [ (1,1) xaxis1,yaxis1 ] 
    [ (2,1) xaxis2,yaxis2 ] 
 
    &gt;&gt;&gt; fig.add_scatter(y=[2, 1, 3], row=1, col=1) # doctest: +ELLIPSIS 
    Figure(...) 
    &gt;&gt;&gt; fig.add_scatter(y=[1, 3, 2], row=2, col=1) # doctest: +ELLIPSIS 
    Figure(...) 
 
    or see Figure.append_trace 
 
    Example 2: 
 
    &gt;&gt;&gt; # Stack a scatter plot 
    &gt;&gt;&gt; fig = make_subplots(rows=2, shared_xaxes=True) 
 
    This is the format of your plot grid: 
    [ (1,1) xaxis1,yaxis1 ] 
    [ (2,1) xaxis2,yaxis2 ] 
 
    &gt;&gt;&gt; fig.add_scatter(y=[2, 1, 3], row=1, col=1) # doctest: +ELLIPSIS 
    Figure(...) 
    &gt;&gt;&gt; fig.add_scatter(y=[1, 3, 2], row=2, col=1) # doctest: +ELLIPSIS 
    Figure(...) 
 
    Example 3: 
 
    &gt;&gt;&gt; # irregular subplot layout (more examples below under 'specs') 
    &gt;&gt;&gt; fig = make_subplots(rows=2, cols=2, 
    ...                     specs=[[{}, {}], 
    ...                     [{'colspan': 2}, None]]) 
 
    This is the format of your plot grid: 
    [ (1,1) xaxis1,yaxis1 ]  [ (1,2) xaxis2,yaxis2 ] 
    [ (2,1) xaxis3,yaxis3           -              ] 
 
    &gt;&gt;&gt; fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=1, col=1) # doctest: +ELLIPSIS 
    Figure(...) 
    &gt;&gt;&gt; fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=1, col=2) # doctest: +ELLIPSIS 
    Figure(...) 
    &gt;&gt;&gt; fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=2, col=1) # doctest: +ELLIPSIS 
    Figure(...) 
 
    Example 4: 
 
    &gt;&gt;&gt; # insets 
    &gt;&gt;&gt; fig = make_subplots(insets=[{'cell': (1,1), 'l': 0.7, 'b': 0.3}]) 
 
    This is the format of your plot grid: 
    [ (1,1) xaxis1,yaxis1 ] 
 
    With insets: 
    [ xaxis2,yaxis2 ] over [ (1,1) xaxis1,yaxis1 ] 
 
    &gt;&gt;&gt; fig.add_scatter(x=[1,2,3], y=[2,1,1]) # doctest: +ELLIPSIS 
    Figure(...) 
    &gt;&gt;&gt; fig.add_scatter(x=[1,2,3], y=[2,1,2], xaxis='x2', yaxis='y2') # doctest: +ELLIPSIS 
    Figure(...) 
 
    Example 5: 
 
    &gt;&gt;&gt; # include subplot titles 
    &gt;&gt;&gt; fig = make_subplots(rows=2, subplot_titles=('Plot 1','Plot 2')) 
 
    This is the format of your plot grid: 
    [ (1,1) x1,y1 ] 
    [ (2,1) x2,y2 ] 
 
    &gt;&gt;&gt; fig.add_scatter(x=[1,2,3], y=[2,1,2], row=1, col=1) # doctest: +ELLIPSIS 
    Figure(...) 
    &gt;&gt;&gt; fig.add_bar(x=[1,2,3], y=[2,1,2], row=2, col=1) # doctest: +ELLIPSIS 
    Figure(...) 
 
    Example 6: 
 
    Subplot with mixed subplot types 
 
    &gt;&gt;&gt; fig = make_subplots(rows=2, cols=2, 
    ...                     specs=[[{'type': 'xy'},    {'type': 'polar'}], 
    ...                            [{'type': 'scene'}, {'type': 'ternary'}]]) 
 
    &gt;&gt;&gt; fig.add_traces( 
    ...     [go.Scatter(y=[2, 3, 1]), 
    ...      go.Scatterpolar(r=[1, 3, 2], theta=[0, 45, 90]), 
    ...      go.Scatter3d(x=[1, 2, 1], y=[2, 3, 1], z=[0, 3, 5]), 
    ...      go.Scatterternary(a=[0.1, 0.2, 0.1], 
    ...                        b=[0.2, 0.3, 0.1], 
    ...                        c=[0.7, 0.5, 0.8])], 
    ...     rows=[1, 1, 2, 2], 
    ...     cols=[1, 2, 1, 2]) # doctest: +ELLIPSIS 
    Figure(...) 
    &quot;&quot;&quot;</span>

    <span class="s2">import </span><span class="s1">plotly.graph_objs </span><span class="s2">as </span><span class="s1">go</span>

    <span class="s0"># Handle backward compatibility</span>
    <span class="s0"># -----------------------------</span>
    <span class="s1">use_legacy_row_heights_order = </span><span class="s3">&quot;row_width&quot; </span><span class="s2">in </span><span class="s1">kwargs</span>
    <span class="s1">row_heights = kwargs.pop(</span><span class="s3">&quot;row_width&quot;</span><span class="s2">, </span><span class="s1">row_heights)</span>
    <span class="s1">column_widths = kwargs.pop(</span><span class="s3">&quot;column_width&quot;</span><span class="s2">, </span><span class="s1">column_widths)</span>

    <span class="s2">if </span><span class="s1">kwargs:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span>
            <span class="s3">&quot;make_subplots() got unexpected keyword argument(s): {}&quot;</span><span class="s1">.format(</span>
                <span class="s1">list(kwargs)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s0"># Validate coerce inputs</span>
    <span class="s0"># ----------------------</span>
    <span class="s0">#  ### rows ###</span>
    <span class="s2">if not </span><span class="s1">isinstance(rows</span><span class="s2">, </span><span class="s1">int) </span><span class="s2">or </span><span class="s1">rows &lt;= </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;&quot;&quot; 
The 'rows' argument to make_suplots must be an int greater than 0. 
    Received value of type {typ}: {val}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                <span class="s1">typ=type(rows)</span><span class="s2">, </span><span class="s1">val=repr(rows)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s0">#  ### cols ###</span>
    <span class="s2">if not </span><span class="s1">isinstance(cols</span><span class="s2">, </span><span class="s1">int) </span><span class="s2">or </span><span class="s1">cols &lt;= </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;&quot;&quot; 
The 'cols' argument to make_suplots must be an int greater than 0. 
    Received value of type {typ}: {val}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                <span class="s1">typ=type(cols)</span><span class="s2">, </span><span class="s1">val=repr(cols)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s0"># ### start_cell ###</span>
    <span class="s2">if </span><span class="s1">start_cell == </span><span class="s3">&quot;bottom-left&quot;</span><span class="s1">:</span>
        <span class="s1">col_dir = </span><span class="s4">1</span>
        <span class="s1">row_dir = </span><span class="s4">1</span>
    <span class="s2">elif </span><span class="s1">start_cell == </span><span class="s3">&quot;top-left&quot;</span><span class="s1">:</span>
        <span class="s1">col_dir = </span><span class="s4">1</span>
        <span class="s1">row_dir = -</span><span class="s4">1</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;&quot;&quot; 
The 'start_cell` argument to make_subplots must be one of </span><span class="s2">\ 
</span><span class="s3">['bottom-left', 'top-left'] 
    Received value of type {typ}: {val}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                <span class="s1">typ=type(start_cell)</span><span class="s2">, </span><span class="s1">val=repr(start_cell)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s0"># ### Helper to validate coerce elements of lists of dictionaries ###</span>
    <span class="s2">def </span><span class="s1">_check_keys_and_fill(name</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">defaults):</span>
        <span class="s2">def </span><span class="s1">_checks(item</span><span class="s2">, </span><span class="s1">defaults):</span>
            <span class="s2">if </span><span class="s1">item </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return</span>
            <span class="s2">if not </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">dict):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;&quot;&quot; 
Elements of the '{name}' argument to make_suplots must be dictionaries </span><span class="s2">\ 
</span><span class="s3">or None. 
    Received value of type {typ}: {val}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                        <span class="s1">name=name</span><span class="s2">, </span><span class="s1">typ=type(item)</span><span class="s2">, </span><span class="s1">val=repr(item)</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">item:</span>
                <span class="s2">if </span><span class="s1">k </span><span class="s2">not in </span><span class="s1">defaults:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">&quot;&quot;&quot; 
Invalid key specified in an element of the '{name}' argument to </span><span class="s2">\ 
</span><span class="s3">make_subplots: {k} 
    Valid keys include: {valid_keys}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                            <span class="s1">k=repr(k)</span><span class="s2">, </span><span class="s1">name=name</span><span class="s2">, </span><span class="s1">valid_keys=repr(list(defaults))</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
            <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">defaults.items():</span>
                <span class="s1">item.setdefault(k</span><span class="s2">, </span><span class="s1">v)</span>

        <span class="s2">for </span><span class="s1">arg_i </span><span class="s2">in </span><span class="s1">arg:</span>
            <span class="s2">if </span><span class="s1">isinstance(arg_i</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
                <span class="s0"># 2D list</span>
                <span class="s2">for </span><span class="s1">arg_ii </span><span class="s2">in </span><span class="s1">arg_i:</span>
                    <span class="s1">_checks(arg_ii</span><span class="s2">, </span><span class="s1">defaults)</span>
            <span class="s2">elif </span><span class="s1">isinstance(arg_i</span><span class="s2">, </span><span class="s1">dict):</span>
                <span class="s0"># 1D list</span>
                <span class="s1">_checks(arg_i</span><span class="s2">, </span><span class="s1">defaults)</span>

    <span class="s0"># ### specs ###</span>
    <span class="s2">if </span><span class="s1">specs </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">specs = [[{} </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range(cols)] </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">range(rows)]</span>
    <span class="s2">elif not </span><span class="s1">(</span>
        <span class="s1">isinstance(specs</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple))</span>
        <span class="s2">and </span><span class="s1">specs</span>
        <span class="s2">and </span><span class="s1">all(isinstance(row</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)) </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">specs)</span>
        <span class="s2">and </span><span class="s1">len(specs) == rows</span>
        <span class="s2">and </span><span class="s1">all(len(row) == cols </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">specs)</span>
        <span class="s2">and </span><span class="s1">all(all(v </span><span class="s2">is None or </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">dict) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">row) </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">specs)</span>
    <span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;&quot;&quot; 
The 'specs' argument to make_subplots must be a 2D list of dictionaries with </span><span class="s2">\ 
</span><span class="s3">dimensions ({rows} x {cols}). 
    Received value of type {typ}: {val}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                <span class="s1">rows=rows</span><span class="s2">, </span><span class="s1">cols=cols</span><span class="s2">, </span><span class="s1">typ=type(specs)</span><span class="s2">, </span><span class="s1">val=repr(specs)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">specs:</span>
        <span class="s2">for </span><span class="s1">spec </span><span class="s2">in </span><span class="s1">row:</span>
            <span class="s0"># For backward compatibility,</span>
            <span class="s0"># convert is_3d flag to type='scene' kwarg</span>
            <span class="s2">if </span><span class="s1">spec </span><span class="s2">and </span><span class="s1">spec.pop(</span><span class="s3">&quot;is_3d&quot;</span><span class="s2">, None</span><span class="s1">):</span>
                <span class="s1">spec[</span><span class="s3">&quot;type&quot;</span><span class="s1">] = </span><span class="s3">&quot;scene&quot;</span>

    <span class="s1">spec_defaults = dict(</span>
        <span class="s1">type=</span><span class="s3">&quot;xy&quot;</span><span class="s2">, </span><span class="s1">secondary_y=</span><span class="s2">False, </span><span class="s1">colspan=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">rowspan=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">l=</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">r=</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">b=</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">t=</span><span class="s4">0.0</span>
    <span class="s1">)</span>
    <span class="s1">_check_keys_and_fill(</span><span class="s3">&quot;specs&quot;</span><span class="s2">, </span><span class="s1">specs</span><span class="s2">, </span><span class="s1">spec_defaults)</span>

    <span class="s0"># Validate secondary_y</span>
    <span class="s1">has_secondary_y = </span><span class="s2">False</span>
    <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">specs:</span>
        <span class="s2">for </span><span class="s1">spec </span><span class="s2">in </span><span class="s1">row:</span>
            <span class="s2">if </span><span class="s1">spec </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">has_secondary_y = has_secondary_y </span><span class="s2">or </span><span class="s1">spec[</span><span class="s3">&quot;secondary_y&quot;</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">spec </span><span class="s2">and </span><span class="s1">spec[</span><span class="s3">&quot;type&quot;</span><span class="s1">] != </span><span class="s3">&quot;xy&quot; </span><span class="s2">and </span><span class="s1">spec[</span><span class="s3">&quot;secondary_y&quot;</span><span class="s1">]:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;&quot;&quot; 
The 'secondary_y' spec property is not supported for subplot of type '{s_typ}' 
     'secondary_y' is only supported for subplots of type 'xy' 
&quot;&quot;&quot;</span><span class="s1">.format(</span>
                        <span class="s1">s_typ=spec[</span><span class="s3">&quot;type&quot;</span><span class="s1">]</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

    <span class="s0"># ### insets ###</span>
    <span class="s2">if </span><span class="s1">insets </span><span class="s2">is None or </span><span class="s1">insets </span><span class="s2">is False</span><span class="s1">:</span>
        <span class="s1">insets = []</span>
    <span class="s2">elif not </span><span class="s1">(</span>
        <span class="s1">isinstance(insets</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)) </span><span class="s2">and </span><span class="s1">all(isinstance(v</span><span class="s2">, </span><span class="s1">dict) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">insets)</span>
    <span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;&quot;&quot; 
The 'insets' argument to make_suplots must be a list of dictionaries. 
    Received value of type {typ}: {val}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                <span class="s1">typ=type(insets)</span><span class="s2">, </span><span class="s1">val=repr(insets)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">insets:</span>
        <span class="s2">for </span><span class="s1">inset </span><span class="s2">in </span><span class="s1">insets:</span>
            <span class="s2">if </span><span class="s1">inset </span><span class="s2">and </span><span class="s1">inset.pop(</span><span class="s3">&quot;is_3d&quot;</span><span class="s2">, None</span><span class="s1">):</span>
                <span class="s1">inset[</span><span class="s3">&quot;type&quot;</span><span class="s1">] = </span><span class="s3">&quot;scene&quot;</span>

        <span class="s1">inset_defaults = dict(</span>
            <span class="s1">cell=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">type=</span><span class="s3">&quot;xy&quot;</span><span class="s2">, </span><span class="s1">l=</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">w=</span><span class="s3">&quot;to_end&quot;</span><span class="s2">, </span><span class="s1">b=</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">h=</span><span class="s3">&quot;to_end&quot;</span>
        <span class="s1">)</span>
        <span class="s1">_check_keys_and_fill(</span><span class="s3">&quot;insets&quot;</span><span class="s2">, </span><span class="s1">insets</span><span class="s2">, </span><span class="s1">inset_defaults)</span>

    <span class="s0"># ### shared_xaxes / shared_yaxes</span>
    <span class="s1">valid_shared_vals = [</span><span class="s2">None, True, False, </span><span class="s3">&quot;rows&quot;</span><span class="s2">, </span><span class="s3">&quot;columns&quot;</span><span class="s2">, </span><span class="s3">&quot;all&quot;</span><span class="s1">]</span>
    <span class="s1">shared_err_msg = </span><span class="s3">&quot;&quot;&quot; 
The {arg} argument to make_subplots must be one of: {valid_vals} 
    Received value of type {typ}: {val}&quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">shared_xaxes </span><span class="s2">not in </span><span class="s1">valid_shared_vals:</span>
        <span class="s1">val = shared_xaxes</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s1">shared_err_msg.format(</span>
                <span class="s1">arg=</span><span class="s3">&quot;shared_xaxes&quot;</span><span class="s2">,</span>
                <span class="s1">valid_vals=valid_shared_vals</span><span class="s2">,</span>
                <span class="s1">typ=type(val)</span><span class="s2">,</span>
                <span class="s1">val=repr(val)</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s2">if </span><span class="s1">shared_yaxes </span><span class="s2">not in </span><span class="s1">valid_shared_vals:</span>
        <span class="s1">val = shared_yaxes</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s1">shared_err_msg.format(</span>
                <span class="s1">arg=</span><span class="s3">&quot;shared_yaxes&quot;</span><span class="s2">,</span>
                <span class="s1">valid_vals=valid_shared_vals</span><span class="s2">,</span>
                <span class="s1">typ=type(val)</span><span class="s2">,</span>
                <span class="s1">val=repr(val)</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_check_hv_spacing(dimsize</span><span class="s2">, </span><span class="s1">spacing</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">dimvarname</span><span class="s2">, </span><span class="s1">dimname):</span>
        <span class="s2">if </span><span class="s1">spacing &lt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">spacing &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;%s spacing must be between 0 and 1.&quot; </span><span class="s1">% (name</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">dimsize &lt;= </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">return</span>
        <span class="s1">max_spacing = </span><span class="s4">1.0 </span><span class="s1">/ float(dimsize - </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">spacing &gt; max_spacing:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;&quot;&quot;{name} spacing cannot be greater than (1 / ({dimvarname} - 1)) = {max_spacing:f}. 
The resulting plot would have {dimsize} {dimname} ({dimvarname}={dimsize}).&quot;&quot;&quot;</span><span class="s1">.format(</span>
                    <span class="s1">dimvarname=dimvarname</span><span class="s2">,</span>
                    <span class="s1">name=name</span><span class="s2">,</span>
                    <span class="s1">dimname=dimname</span><span class="s2">,</span>
                    <span class="s1">max_spacing=max_spacing</span><span class="s2">,</span>
                    <span class="s1">dimsize=dimsize</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

    <span class="s0"># ### horizontal_spacing ###</span>
    <span class="s2">if </span><span class="s1">horizontal_spacing </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">has_secondary_y:</span>
            <span class="s1">horizontal_spacing = </span><span class="s4">0.4 </span><span class="s1">/ cols</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">horizontal_spacing = </span><span class="s4">0.2 </span><span class="s1">/ cols</span>
    <span class="s0"># check horizontal_spacing can be satisfied:</span>
    <span class="s1">_check_hv_spacing(cols</span><span class="s2">, </span><span class="s1">horizontal_spacing</span><span class="s2">, </span><span class="s3">&quot;Horizontal&quot;</span><span class="s2">, </span><span class="s3">&quot;cols&quot;</span><span class="s2">, </span><span class="s3">&quot;columns&quot;</span><span class="s1">)</span>

    <span class="s0"># ### vertical_spacing ###</span>
    <span class="s2">if </span><span class="s1">vertical_spacing </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">subplot_titles </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">vertical_spacing = </span><span class="s4">0.5 </span><span class="s1">/ rows</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">vertical_spacing = </span><span class="s4">0.3 </span><span class="s1">/ rows</span>
    <span class="s0"># check vertical_spacing can be satisfied:</span>
    <span class="s1">_check_hv_spacing(rows</span><span class="s2">, </span><span class="s1">vertical_spacing</span><span class="s2">, </span><span class="s3">&quot;Vertical&quot;</span><span class="s2">, </span><span class="s3">&quot;rows&quot;</span><span class="s2">, </span><span class="s3">&quot;rows&quot;</span><span class="s1">)</span>

    <span class="s0"># ### subplot titles ###</span>
    <span class="s2">if </span><span class="s1">subplot_titles </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">subplot_titles = [</span><span class="s3">&quot;&quot;</span><span class="s1">] * rows * cols</span>

    <span class="s0"># ### column_widths ###</span>
    <span class="s2">if </span><span class="s1">has_secondary_y:</span>
        <span class="s0"># Add room for secondary y-axis title</span>
        <span class="s1">max_width = </span><span class="s4">0.94</span>
    <span class="s2">elif </span><span class="s1">row_titles:</span>
        <span class="s0"># Add a little breathing room between row labels and legend</span>
        <span class="s1">max_width = </span><span class="s4">0.98</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">max_width = </span><span class="s4">1.0</span>

    <span class="s2">if </span><span class="s1">column_widths </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">widths = [(max_width - horizontal_spacing * (cols - </span><span class="s4">1</span><span class="s1">)) / cols] * cols</span>
    <span class="s2">elif </span><span class="s1">isinstance(column_widths</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)) </span><span class="s2">and </span><span class="s1">len(column_widths) == cols:</span>
        <span class="s1">cum_sum = float(sum(column_widths))</span>
        <span class="s1">widths = []</span>
        <span class="s2">for </span><span class="s1">w </span><span class="s2">in </span><span class="s1">column_widths:</span>
            <span class="s1">widths.append((max_width - horizontal_spacing * (cols - </span><span class="s4">1</span><span class="s1">)) * (w / cum_sum))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;&quot;&quot; 
The 'column_widths' argument to make_suplots must be a list of numbers of </span><span class="s2">\ 
</span><span class="s3">length {cols}. 
    Received value of type {typ}: {val}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                <span class="s1">cols=cols</span><span class="s2">, </span><span class="s1">typ=type(column_widths)</span><span class="s2">, </span><span class="s1">val=repr(column_widths)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s0"># ### row_heights ###</span>
    <span class="s2">if </span><span class="s1">row_heights </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">heights = [(</span><span class="s4">1.0 </span><span class="s1">- vertical_spacing * (rows - </span><span class="s4">1</span><span class="s1">)) / rows] * rows</span>
    <span class="s2">elif </span><span class="s1">isinstance(row_heights</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)) </span><span class="s2">and </span><span class="s1">len(row_heights) == rows:</span>
        <span class="s1">cum_sum = float(sum(row_heights))</span>
        <span class="s1">heights = []</span>
        <span class="s2">for </span><span class="s1">h </span><span class="s2">in </span><span class="s1">row_heights:</span>
            <span class="s1">heights.append((</span><span class="s4">1.0 </span><span class="s1">- vertical_spacing * (rows - </span><span class="s4">1</span><span class="s1">)) * (h / cum_sum))</span>
        <span class="s2">if </span><span class="s1">row_dir &lt; </span><span class="s4">0 </span><span class="s2">and not </span><span class="s1">use_legacy_row_heights_order:</span>
            <span class="s1">heights = list(reversed(heights))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;&quot;&quot; 
The 'row_heights' argument to make_suplots must be a list of numbers of </span><span class="s2">\ 
</span><span class="s3">length {rows}. 
    Received value of type {typ}: {val}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                <span class="s1">rows=rows</span><span class="s2">, </span><span class="s1">typ=type(row_heights)</span><span class="s2">, </span><span class="s1">val=repr(row_heights)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s0"># ### column_titles / row_titles ###</span>
    <span class="s2">if </span><span class="s1">column_titles </span><span class="s2">and not </span><span class="s1">isinstance(column_titles</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;&quot;&quot; 
The column_titles argument to make_subplots must be a list or tuple 
    Received value of type {typ}: {val}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                <span class="s1">typ=type(column_titles)</span><span class="s2">, </span><span class="s1">val=repr(column_titles)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">row_titles </span><span class="s2">and not </span><span class="s1">isinstance(row_titles</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;&quot;&quot; 
The row_titles argument to make_subplots must be a list or tuple 
    Received value of type {typ}: {val}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                <span class="s1">typ=type(row_titles)</span><span class="s2">, </span><span class="s1">val=repr(row_titles)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s0"># Init layout</span>
    <span class="s0"># -----------</span>
    <span class="s1">layout = go.Layout()</span>

    <span class="s0"># Build grid reference</span>
    <span class="s0"># --------------------</span>
    <span class="s0"># Built row/col sequence using 'row_dir' and 'col_dir'</span>
    <span class="s1">col_seq = range(cols)[::col_dir]</span>
    <span class="s1">row_seq = range(rows)[::row_dir]</span>

    <span class="s0"># Build 2D array of tuples of the start x and start y coordinate of each</span>
    <span class="s0"># subplot</span>
    <span class="s1">grid = [</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s1">(sum(widths[:c]) + c * horizontal_spacing)</span><span class="s2">,</span>
                <span class="s1">(sum(heights[:r]) + r * vertical_spacing)</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">col_seq</span>
        <span class="s1">]</span>
        <span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">row_seq</span>
    <span class="s1">]</span>

    <span class="s1">domains_grid = [[</span><span class="s2">None for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(cols)] </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(rows)]</span>

    <span class="s0"># Initialize subplot reference lists for the grid and insets</span>
    <span class="s1">grid_ref = [[</span><span class="s2">None for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range(cols)] </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">range(rows)]</span>

    <span class="s1">list_of_domains = []  </span><span class="s0"># added for subplot titles</span>

    <span class="s1">max_subplot_ids = _get_initial_max_subplot_ids()</span>

    <span class="s0"># Loop through specs -- (r, c) &lt;-&gt; (row, col)</span>
    <span class="s2">for </span><span class="s1">r</span><span class="s2">, </span><span class="s1">spec_row </span><span class="s2">in </span><span class="s1">enumerate(specs):</span>
        <span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">spec </span><span class="s2">in </span><span class="s1">enumerate(spec_row):</span>

            <span class="s2">if </span><span class="s1">spec </span><span class="s2">is None</span><span class="s1">:  </span><span class="s0"># skip over None cells</span>
                <span class="s2">continue</span>

            <span class="s0"># ### Compute x and y domain for subplot ###</span>
            <span class="s1">c_spanned = c + spec[</span><span class="s3">&quot;colspan&quot;</span><span class="s1">] - </span><span class="s4">1  </span><span class="s0"># get spanned c</span>
            <span class="s1">r_spanned = r + spec[</span><span class="s3">&quot;rowspan&quot;</span><span class="s1">] - </span><span class="s4">1  </span><span class="s0"># get spanned r</span>

            <span class="s0"># Throw exception if 'colspan' | 'rowspan' is too large for grid</span>
            <span class="s2">if </span><span class="s1">c_spanned &gt;= cols:</span>
                <span class="s2">raise </span><span class="s1">Exception(</span>
                    <span class="s3">&quot;Some 'colspan' value is too large for &quot; &quot;this subplot grid.&quot;</span>
                <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">r_spanned &gt;= rows:</span>
                <span class="s2">raise </span><span class="s1">Exception(</span>
                    <span class="s3">&quot;Some 'rowspan' value is too large for &quot; &quot;this subplot grid.&quot;</span>
                <span class="s1">)</span>

            <span class="s0"># Get x domain using grid and colspan</span>
            <span class="s1">x_s = grid[r][c][</span><span class="s4">0</span><span class="s1">] + spec[</span><span class="s3">&quot;l&quot;</span><span class="s1">]</span>

            <span class="s1">x_e = grid[r][c_spanned][</span><span class="s4">0</span><span class="s1">] + widths[c_spanned] - spec[</span><span class="s3">&quot;r&quot;</span><span class="s1">]</span>
            <span class="s1">x_domain = [x_s</span><span class="s2">, </span><span class="s1">x_e]</span>

            <span class="s0"># Get y domain (dep. on row_dir) using grid &amp; r_spanned</span>
            <span class="s2">if </span><span class="s1">row_dir &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">y_s = grid[r][c][</span><span class="s4">1</span><span class="s1">] + spec[</span><span class="s3">&quot;b&quot;</span><span class="s1">]</span>
                <span class="s1">y_e = grid[r_spanned][c][</span><span class="s4">1</span><span class="s1">] + heights[r_spanned] - spec[</span><span class="s3">&quot;t&quot;</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">y_s = grid[r_spanned][c][</span><span class="s4">1</span><span class="s1">] + spec[</span><span class="s3">&quot;b&quot;</span><span class="s1">]</span>
                <span class="s1">y_e = grid[r][c][</span><span class="s4">1</span><span class="s1">] + heights[-</span><span class="s4">1 </span><span class="s1">- r] - spec[</span><span class="s3">&quot;t&quot;</span><span class="s1">]</span>
            <span class="s1">y_domain = [y_s</span><span class="s2">, </span><span class="s1">y_e]</span>

            <span class="s1">list_of_domains.append(x_domain)</span>
            <span class="s1">list_of_domains.append(y_domain)</span>

            <span class="s1">domains_grid[r][c] = [x_domain</span><span class="s2">, </span><span class="s1">y_domain]</span>

            <span class="s0"># ### construct subplot container ###</span>
            <span class="s1">subplot_type = spec[</span><span class="s3">&quot;type&quot;</span><span class="s1">]</span>
            <span class="s1">secondary_y = spec[</span><span class="s3">&quot;secondary_y&quot;</span><span class="s1">]</span>
            <span class="s1">subplot_refs = _init_subplot(</span>
                <span class="s1">layout</span><span class="s2">, </span><span class="s1">subplot_type</span><span class="s2">, </span><span class="s1">secondary_y</span><span class="s2">, </span><span class="s1">x_domain</span><span class="s2">, </span><span class="s1">y_domain</span><span class="s2">, </span><span class="s1">max_subplot_ids</span>
            <span class="s1">)</span>
            <span class="s1">grid_ref[r][c] = subplot_refs</span>

    <span class="s1">_configure_shared_axes(layout</span><span class="s2">, </span><span class="s1">grid_ref</span><span class="s2">, </span><span class="s1">specs</span><span class="s2">, </span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s1">shared_xaxes</span><span class="s2">, </span><span class="s1">row_dir)</span>
    <span class="s1">_configure_shared_axes(layout</span><span class="s2">, </span><span class="s1">grid_ref</span><span class="s2">, </span><span class="s1">specs</span><span class="s2">, </span><span class="s3">&quot;y&quot;</span><span class="s2">, </span><span class="s1">shared_yaxes</span><span class="s2">, </span><span class="s1">row_dir)</span>

    <span class="s0"># Build inset reference</span>
    <span class="s0"># ---------------------</span>
    <span class="s0"># Loop through insets</span>
    <span class="s1">insets_ref = [</span><span class="s2">None for </span><span class="s1">inset </span><span class="s2">in </span><span class="s1">range(len(insets))] </span><span class="s2">if </span><span class="s1">insets </span><span class="s2">else None</span>
    <span class="s2">if </span><span class="s1">insets:</span>
        <span class="s2">for </span><span class="s1">i_inset</span><span class="s2">, </span><span class="s1">inset </span><span class="s2">in </span><span class="s1">enumerate(insets):</span>

            <span class="s1">r = inset[</span><span class="s3">&quot;cell&quot;</span><span class="s1">][</span><span class="s4">0</span><span class="s1">] - </span><span class="s4">1</span>
            <span class="s1">c = inset[</span><span class="s3">&quot;cell&quot;</span><span class="s1">][</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">1</span>

            <span class="s0"># Throw exception if r | c is out of range</span>
            <span class="s2">if not </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">&lt;= r &lt; rows):</span>
                <span class="s2">raise </span><span class="s1">Exception(</span>
                    <span class="s3">&quot;Some 'cell' row value is out of range. &quot;</span>
                    <span class="s3">&quot;Note: the starting cell is (1, 1)&quot;</span>
                <span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">&lt;= c &lt; cols):</span>
                <span class="s2">raise </span><span class="s1">Exception(</span>
                    <span class="s3">&quot;Some 'cell' col value is out of range. &quot;</span>
                    <span class="s3">&quot;Note: the starting cell is (1, 1)&quot;</span>
                <span class="s1">)</span>

            <span class="s0"># Get inset x domain using grid</span>
            <span class="s1">x_s = grid[r][c][</span><span class="s4">0</span><span class="s1">] + inset[</span><span class="s3">&quot;l&quot;</span><span class="s1">] * widths[c]</span>
            <span class="s2">if </span><span class="s1">inset[</span><span class="s3">&quot;w&quot;</span><span class="s1">] == </span><span class="s3">&quot;to_end&quot;</span><span class="s1">:</span>
                <span class="s1">x_e = grid[r][c][</span><span class="s4">0</span><span class="s1">] + widths[c]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">x_e = x_s + inset[</span><span class="s3">&quot;w&quot;</span><span class="s1">] * widths[c]</span>
            <span class="s1">x_domain = [x_s</span><span class="s2">, </span><span class="s1">x_e]</span>

            <span class="s0"># Get inset y domain using grid</span>
            <span class="s1">y_s = grid[r][c][</span><span class="s4">1</span><span class="s1">] + inset[</span><span class="s3">&quot;b&quot;</span><span class="s1">] * heights[-</span><span class="s4">1 </span><span class="s1">- r]</span>
            <span class="s2">if </span><span class="s1">inset[</span><span class="s3">&quot;h&quot;</span><span class="s1">] == </span><span class="s3">&quot;to_end&quot;</span><span class="s1">:</span>
                <span class="s1">y_e = grid[r][c][</span><span class="s4">1</span><span class="s1">] + heights[-</span><span class="s4">1 </span><span class="s1">- r]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">y_e = y_s + inset[</span><span class="s3">&quot;h&quot;</span><span class="s1">] * heights[-</span><span class="s4">1 </span><span class="s1">- r]</span>
            <span class="s1">y_domain = [y_s</span><span class="s2">, </span><span class="s1">y_e]</span>

            <span class="s1">list_of_domains.append(x_domain)</span>
            <span class="s1">list_of_domains.append(y_domain)</span>

            <span class="s1">subplot_type = inset[</span><span class="s3">&quot;type&quot;</span><span class="s1">]</span>

            <span class="s1">subplot_refs = _init_subplot(</span>
                <span class="s1">layout</span><span class="s2">, </span><span class="s1">subplot_type</span><span class="s2">, False, </span><span class="s1">x_domain</span><span class="s2">, </span><span class="s1">y_domain</span><span class="s2">, </span><span class="s1">max_subplot_ids</span>
            <span class="s1">)</span>

            <span class="s1">insets_ref[i_inset] = subplot_refs</span>

    <span class="s0"># Build grid_str</span>
    <span class="s0"># This is the message printed when print_grid=True</span>
    <span class="s1">grid_str = _build_grid_str(specs</span><span class="s2">, </span><span class="s1">grid_ref</span><span class="s2">, </span><span class="s1">insets</span><span class="s2">, </span><span class="s1">insets_ref</span><span class="s2">, </span><span class="s1">row_seq)</span>

    <span class="s0"># Add subplot titles</span>
    <span class="s1">plot_title_annotations = _build_subplot_title_annotations(</span>
        <span class="s1">subplot_titles</span><span class="s2">, </span><span class="s1">list_of_domains</span>
    <span class="s1">)</span>

    <span class="s1">layout[</span><span class="s3">&quot;annotations&quot;</span><span class="s1">] = plot_title_annotations</span>

    <span class="s0"># Add column titles</span>
    <span class="s2">if </span><span class="s1">column_titles:</span>
        <span class="s1">domains_list = []</span>
        <span class="s2">if </span><span class="s1">row_dir &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range(cols):</span>
                <span class="s1">domain_pair = domains_grid[-</span><span class="s4">1</span><span class="s1">][c]</span>
                <span class="s2">if </span><span class="s1">domain_pair:</span>
                    <span class="s1">domains_list.extend(domain_pair)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range(cols):</span>
                <span class="s1">domain_pair = domains_grid[</span><span class="s4">0</span><span class="s1">][c]</span>
                <span class="s2">if </span><span class="s1">domain_pair:</span>
                    <span class="s1">domains_list.extend(domain_pair)</span>

        <span class="s0"># Add subplot titles</span>
        <span class="s1">column_title_annotations = _build_subplot_title_annotations(</span>
            <span class="s1">column_titles</span><span class="s2">, </span><span class="s1">domains_list</span>
        <span class="s1">)</span>

        <span class="s1">layout[</span><span class="s3">&quot;annotations&quot;</span><span class="s1">] += tuple(column_title_annotations)</span>

    <span class="s2">if </span><span class="s1">row_titles:</span>
        <span class="s1">domains_list = []</span>
        <span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">range(rows):</span>
            <span class="s1">domain_pair = domains_grid[r][-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">domain_pair:</span>
                <span class="s1">domains_list.extend(domain_pair)</span>

        <span class="s0"># Add subplot titles</span>
        <span class="s1">column_title_annotations = _build_subplot_title_annotations(</span>
            <span class="s1">row_titles</span><span class="s2">, </span><span class="s1">domains_list</span><span class="s2">, </span><span class="s1">title_edge=</span><span class="s3">&quot;right&quot;</span>
        <span class="s1">)</span>

        <span class="s1">layout[</span><span class="s3">&quot;annotations&quot;</span><span class="s1">] += tuple(column_title_annotations)</span>

    <span class="s2">if </span><span class="s1">x_title:</span>
        <span class="s1">domains_list = [(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">max_width)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)]</span>

        <span class="s0"># Add subplot titles</span>
        <span class="s1">column_title_annotations = _build_subplot_title_annotations(</span>
            <span class="s1">[x_title]</span><span class="s2">, </span><span class="s1">domains_list</span><span class="s2">, </span><span class="s1">title_edge=</span><span class="s3">&quot;bottom&quot;</span><span class="s2">, </span><span class="s1">offset=</span><span class="s4">30</span>
        <span class="s1">)</span>

        <span class="s1">layout[</span><span class="s3">&quot;annotations&quot;</span><span class="s1">] += tuple(column_title_annotations)</span>

    <span class="s2">if </span><span class="s1">y_title:</span>
        <span class="s1">domains_list = [(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)]</span>

        <span class="s0"># Add subplot titles</span>
        <span class="s1">column_title_annotations = _build_subplot_title_annotations(</span>
            <span class="s1">[y_title]</span><span class="s2">, </span><span class="s1">domains_list</span><span class="s2">, </span><span class="s1">title_edge=</span><span class="s3">&quot;left&quot;</span><span class="s2">, </span><span class="s1">offset=</span><span class="s4">40</span>
        <span class="s1">)</span>

        <span class="s1">layout[</span><span class="s3">&quot;annotations&quot;</span><span class="s1">] += tuple(column_title_annotations)</span>

    <span class="s0"># Handle displaying grid information</span>
    <span class="s2">if </span><span class="s1">print_grid:</span>
        <span class="s1">print(grid_str)</span>

    <span class="s0"># Build resulting figure</span>
    <span class="s2">if </span><span class="s1">figure </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">figure = go.Figure()</span>
    <span class="s1">figure.update_layout(layout)</span>

    <span class="s0"># Attach subplot grid info to the figure</span>
    <span class="s1">figure.__dict__[</span><span class="s3">&quot;_grid_ref&quot;</span><span class="s1">] = grid_ref</span>
    <span class="s1">figure.__dict__[</span><span class="s3">&quot;_grid_str&quot;</span><span class="s1">] = grid_str</span>

    <span class="s2">return </span><span class="s1">figure</span>


<span class="s2">def </span><span class="s1">_configure_shared_axes(layout</span><span class="s2">, </span><span class="s1">grid_ref</span><span class="s2">, </span><span class="s1">specs</span><span class="s2">, </span><span class="s1">x_or_y</span><span class="s2">, </span><span class="s1">shared</span><span class="s2">, </span><span class="s1">row_dir):</span>
    <span class="s1">rows = len(grid_ref)</span>
    <span class="s1">cols = len(grid_ref[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s1">layout_key_ind = [</span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s3">&quot;y&quot;</span><span class="s1">].index(x_or_y)</span>

    <span class="s2">if </span><span class="s1">row_dir &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">rows_iter = range(rows - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">rows_iter = range(rows)</span>

    <span class="s2">def </span><span class="s1">update_axis_matches(first_axis_id</span><span class="s2">, </span><span class="s1">subplot_ref</span><span class="s2">, </span><span class="s1">spec</span><span class="s2">, </span><span class="s1">remove_label):</span>
        <span class="s2">if </span><span class="s1">subplot_ref </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">first_axis_id</span>

        <span class="s2">if </span><span class="s1">x_or_y == </span><span class="s3">&quot;x&quot;</span><span class="s1">:</span>
            <span class="s1">span = spec[</span><span class="s3">&quot;colspan&quot;</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">span = spec[</span><span class="s3">&quot;rowspan&quot;</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">subplot_ref.subplot_type == </span><span class="s3">&quot;xy&quot; </span><span class="s2">and </span><span class="s1">span == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">first_axis_id </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">first_axis_name = subplot_ref.layout_keys[layout_key_ind]</span>
                <span class="s1">first_axis_id = first_axis_name.replace(</span><span class="s3">&quot;axis&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">axis_name = subplot_ref.layout_keys[layout_key_ind]</span>
                <span class="s1">axis_to_match = layout[axis_name]</span>
                <span class="s1">axis_to_match.matches = first_axis_id</span>
                <span class="s2">if </span><span class="s1">remove_label:</span>
                    <span class="s1">axis_to_match.showticklabels = </span><span class="s2">False</span>

        <span class="s2">return </span><span class="s1">first_axis_id</span>

    <span class="s2">if </span><span class="s1">shared == </span><span class="s3">&quot;columns&quot; </span><span class="s2">or </span><span class="s1">(x_or_y == </span><span class="s3">&quot;x&quot; </span><span class="s2">and </span><span class="s1">shared </span><span class="s2">is True</span><span class="s1">):</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range(cols):</span>
            <span class="s1">first_axis_id = </span><span class="s2">None</span>
            <span class="s1">ok_to_remove_label = x_or_y == </span><span class="s3">&quot;x&quot;</span>
            <span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">rows_iter:</span>
                <span class="s2">if not </span><span class="s1">grid_ref[r][c]:</span>
                    <span class="s2">continue</span>
                <span class="s1">subplot_ref = grid_ref[r][c][</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">spec = specs[r][c]</span>
                <span class="s1">first_axis_id = update_axis_matches(</span>
                    <span class="s1">first_axis_id</span><span class="s2">, </span><span class="s1">subplot_ref</span><span class="s2">, </span><span class="s1">spec</span><span class="s2">, </span><span class="s1">ok_to_remove_label</span>
                <span class="s1">)</span>

    <span class="s2">elif </span><span class="s1">shared == </span><span class="s3">&quot;rows&quot; </span><span class="s2">or </span><span class="s1">(x_or_y == </span><span class="s3">&quot;y&quot; </span><span class="s2">and </span><span class="s1">shared </span><span class="s2">is True</span><span class="s1">):</span>
        <span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">rows_iter:</span>
            <span class="s1">first_axis_id = </span><span class="s2">None</span>
            <span class="s1">ok_to_remove_label = x_or_y == </span><span class="s3">&quot;y&quot;</span>
            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range(cols):</span>
                <span class="s2">if not </span><span class="s1">grid_ref[r][c]:</span>
                    <span class="s2">continue</span>
                <span class="s1">subplot_ref = grid_ref[r][c][</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">spec = specs[r][c]</span>
                <span class="s1">first_axis_id = update_axis_matches(</span>
                    <span class="s1">first_axis_id</span><span class="s2">, </span><span class="s1">subplot_ref</span><span class="s2">, </span><span class="s1">spec</span><span class="s2">, </span><span class="s1">ok_to_remove_label</span>
                <span class="s1">)</span>

    <span class="s2">elif </span><span class="s1">shared == </span><span class="s3">&quot;all&quot;</span><span class="s1">:</span>
        <span class="s1">first_axis_id = </span><span class="s2">None</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range(cols):</span>
            <span class="s2">for </span><span class="s1">ri</span><span class="s2">, </span><span class="s1">r </span><span class="s2">in </span><span class="s1">enumerate(rows_iter):</span>
                <span class="s2">if not </span><span class="s1">grid_ref[r][c]:</span>
                    <span class="s2">continue</span>
                <span class="s1">subplot_ref = grid_ref[r][c][</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">spec = specs[r][c]</span>

                <span class="s2">if </span><span class="s1">x_or_y == </span><span class="s3">&quot;y&quot;</span><span class="s1">:</span>
                    <span class="s1">ok_to_remove_label = c &gt; </span><span class="s4">0</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">ok_to_remove_label = ri &gt; </span><span class="s4">0 </span><span class="s2">if </span><span class="s1">row_dir &gt; </span><span class="s4">0 </span><span class="s2">else </span><span class="s1">r &lt; rows - </span><span class="s4">1</span>

                <span class="s1">first_axis_id = update_axis_matches(</span>
                    <span class="s1">first_axis_id</span><span class="s2">, </span><span class="s1">subplot_ref</span><span class="s2">, </span><span class="s1">spec</span><span class="s2">, </span><span class="s1">ok_to_remove_label</span>
                <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_init_subplot_xy(layout</span><span class="s2">, </span><span class="s1">secondary_y</span><span class="s2">, </span><span class="s1">x_domain</span><span class="s2">, </span><span class="s1">y_domain</span><span class="s2">, </span><span class="s1">max_subplot_ids=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">max_subplot_ids </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">max_subplot_ids = _get_initial_max_subplot_ids()</span>

    <span class="s0"># Get axis label and anchor</span>
    <span class="s1">x_cnt = max_subplot_ids[</span><span class="s3">&quot;xaxis&quot;</span><span class="s1">] + </span><span class="s4">1</span>
    <span class="s1">y_cnt = max_subplot_ids[</span><span class="s3">&quot;yaxis&quot;</span><span class="s1">] + </span><span class="s4">1</span>

    <span class="s0"># Compute x/y labels (the values of trace.xaxis/trace.yaxis</span>
    <span class="s1">x_label = </span><span class="s3">&quot;x{cnt}&quot;</span><span class="s1">.format(cnt=x_cnt </span><span class="s2">if </span><span class="s1">x_cnt &gt; </span><span class="s4">1 </span><span class="s2">else </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
    <span class="s1">y_label = </span><span class="s3">&quot;y{cnt}&quot;</span><span class="s1">.format(cnt=y_cnt </span><span class="s2">if </span><span class="s1">y_cnt &gt; </span><span class="s4">1 </span><span class="s2">else </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>

    <span class="s0"># Anchor x and y axes to each other</span>
    <span class="s1">x_anchor</span><span class="s2">, </span><span class="s1">y_anchor = y_label</span><span class="s2">, </span><span class="s1">x_label</span>

    <span class="s0"># Build layout.xaxis/layout.yaxis containers</span>
    <span class="s1">xaxis_name = </span><span class="s3">&quot;xaxis{cnt}&quot;</span><span class="s1">.format(cnt=x_cnt </span><span class="s2">if </span><span class="s1">x_cnt &gt; </span><span class="s4">1 </span><span class="s2">else </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
    <span class="s1">yaxis_name = </span><span class="s3">&quot;yaxis{cnt}&quot;</span><span class="s1">.format(cnt=y_cnt </span><span class="s2">if </span><span class="s1">y_cnt &gt; </span><span class="s4">1 </span><span class="s2">else </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
    <span class="s1">x_axis = {</span><span class="s3">&quot;domain&quot;</span><span class="s1">: x_domain</span><span class="s2">, </span><span class="s3">&quot;anchor&quot;</span><span class="s1">: x_anchor}</span>
    <span class="s1">y_axis = {</span><span class="s3">&quot;domain&quot;</span><span class="s1">: y_domain</span><span class="s2">, </span><span class="s3">&quot;anchor&quot;</span><span class="s1">: y_anchor}</span>

    <span class="s1">layout[xaxis_name] = x_axis</span>
    <span class="s1">layout[yaxis_name] = y_axis</span>

    <span class="s1">subplot_refs = [</span>
        <span class="s1">SubplotRef(</span>
            <span class="s1">subplot_type=</span><span class="s3">&quot;xy&quot;</span><span class="s2">,</span>
            <span class="s1">layout_keys=(xaxis_name</span><span class="s2">, </span><span class="s1">yaxis_name)</span><span class="s2">,</span>
            <span class="s1">trace_kwargs={</span><span class="s3">&quot;xaxis&quot;</span><span class="s1">: x_label</span><span class="s2">, </span><span class="s3">&quot;yaxis&quot;</span><span class="s1">: y_label}</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s1">]</span>

    <span class="s2">if </span><span class="s1">secondary_y:</span>
        <span class="s1">y_cnt += </span><span class="s4">1</span>
        <span class="s1">secondary_yaxis_name = </span><span class="s3">&quot;yaxis{cnt}&quot;</span><span class="s1">.format(cnt=y_cnt </span><span class="s2">if </span><span class="s1">y_cnt &gt; </span><span class="s4">1 </span><span class="s2">else </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">secondary_y_label = </span><span class="s3">&quot;y{cnt}&quot;</span><span class="s1">.format(cnt=y_cnt)</span>

        <span class="s0"># Add secondary y-axis to subplot reference</span>
        <span class="s1">subplot_refs.append(</span>
            <span class="s1">SubplotRef(</span>
                <span class="s1">subplot_type=</span><span class="s3">&quot;xy&quot;</span><span class="s2">,</span>
                <span class="s1">layout_keys=(xaxis_name</span><span class="s2">, </span><span class="s1">secondary_yaxis_name)</span><span class="s2">,</span>
                <span class="s1">trace_kwargs={</span><span class="s3">&quot;xaxis&quot;</span><span class="s1">: x_label</span><span class="s2">, </span><span class="s3">&quot;yaxis&quot;</span><span class="s1">: secondary_y_label}</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s0"># Add secondary y axis to layout</span>
        <span class="s1">secondary_y_axis = {</span><span class="s3">&quot;anchor&quot;</span><span class="s1">: y_anchor</span><span class="s2">, </span><span class="s3">&quot;overlaying&quot;</span><span class="s1">: y_label</span><span class="s2">, </span><span class="s3">&quot;side&quot;</span><span class="s1">: </span><span class="s3">&quot;right&quot;</span><span class="s1">}</span>
        <span class="s1">layout[secondary_yaxis_name] = secondary_y_axis</span>

    <span class="s0"># increment max_subplot_ids</span>
    <span class="s1">max_subplot_ids[</span><span class="s3">&quot;xaxis&quot;</span><span class="s1">] = x_cnt</span>
    <span class="s1">max_subplot_ids[</span><span class="s3">&quot;yaxis&quot;</span><span class="s1">] = y_cnt</span>

    <span class="s2">return </span><span class="s1">tuple(subplot_refs)</span>


<span class="s2">def </span><span class="s1">_init_subplot_single(</span>
    <span class="s1">layout</span><span class="s2">, </span><span class="s1">subplot_type</span><span class="s2">, </span><span class="s1">x_domain</span><span class="s2">, </span><span class="s1">y_domain</span><span class="s2">, </span><span class="s1">max_subplot_ids=</span><span class="s2">None</span>
<span class="s1">):</span>
    <span class="s2">if </span><span class="s1">max_subplot_ids </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">max_subplot_ids = _get_initial_max_subplot_ids()</span>

    <span class="s0"># Add scene to layout</span>
    <span class="s1">cnt = max_subplot_ids[subplot_type] + </span><span class="s4">1</span>
    <span class="s1">label = </span><span class="s3">&quot;{subplot_type}{cnt}&quot;</span><span class="s1">.format(</span>
        <span class="s1">subplot_type=subplot_type</span><span class="s2">, </span><span class="s1">cnt=cnt </span><span class="s2">if </span><span class="s1">cnt &gt; </span><span class="s4">1 </span><span class="s2">else </span><span class="s3">&quot;&quot;</span>
    <span class="s1">)</span>
    <span class="s1">scene = dict(domain={</span><span class="s3">&quot;x&quot;</span><span class="s1">: x_domain</span><span class="s2">, </span><span class="s3">&quot;y&quot;</span><span class="s1">: y_domain})</span>
    <span class="s1">layout[label] = scene</span>

    <span class="s1">trace_key = (</span>
        <span class="s3">&quot;subplot&quot; </span><span class="s2">if </span><span class="s1">subplot_type </span><span class="s2">in </span><span class="s1">_subplot_prop_named_subplot </span><span class="s2">else </span><span class="s1">subplot_type</span>
    <span class="s1">)</span>

    <span class="s1">subplot_ref = SubplotRef(</span>
        <span class="s1">subplot_type=subplot_type</span><span class="s2">, </span><span class="s1">layout_keys=(label</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trace_kwargs={trace_key: label}</span>
    <span class="s1">)</span>

    <span class="s0"># increment max_subplot_id</span>
    <span class="s1">max_subplot_ids[subplot_type] = cnt</span>

    <span class="s2">return </span><span class="s1">(subplot_ref</span><span class="s2">,</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_init_subplot_domain(x_domain</span><span class="s2">, </span><span class="s1">y_domain):</span>
    <span class="s0"># No change to layout since domain traces are labeled individually</span>
    <span class="s1">subplot_ref = SubplotRef(</span>
        <span class="s1">subplot_type=</span><span class="s3">&quot;domain&quot;</span><span class="s2">,</span>
        <span class="s1">layout_keys=()</span><span class="s2">,</span>
        <span class="s1">trace_kwargs={</span><span class="s3">&quot;domain&quot;</span><span class="s1">: {</span><span class="s3">&quot;x&quot;</span><span class="s1">: tuple(x_domain)</span><span class="s2">, </span><span class="s3">&quot;y&quot;</span><span class="s1">: tuple(y_domain)}}</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">(subplot_ref</span><span class="s2">,</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_subplot_type_for_trace_type(trace_type):</span>
    <span class="s2">from </span><span class="s1">plotly.validators </span><span class="s2">import </span><span class="s1">DataValidator</span>

    <span class="s1">trace_validator = DataValidator()</span>
    <span class="s2">if </span><span class="s1">trace_type </span><span class="s2">in </span><span class="s1">trace_validator.class_strs_map:</span>
        <span class="s0"># subplot_type is a trace name, find the subplot type for trace</span>
        <span class="s1">trace = trace_validator.validate_coerce([{</span><span class="s3">&quot;type&quot;</span><span class="s1">: trace_type}])[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s3">&quot;domain&quot; </span><span class="s2">in </span><span class="s1">trace:</span>
            <span class="s2">return </span><span class="s3">&quot;domain&quot;</span>
        <span class="s2">elif </span><span class="s3">&quot;xaxis&quot; </span><span class="s2">in </span><span class="s1">trace </span><span class="s2">and </span><span class="s3">&quot;yaxis&quot; </span><span class="s2">in </span><span class="s1">trace:</span>
            <span class="s2">return </span><span class="s3">&quot;xy&quot;</span>
        <span class="s2">elif </span><span class="s3">&quot;geo&quot; </span><span class="s2">in </span><span class="s1">trace:</span>
            <span class="s2">return </span><span class="s3">&quot;geo&quot;</span>
        <span class="s2">elif </span><span class="s3">&quot;scene&quot; </span><span class="s2">in </span><span class="s1">trace:</span>
            <span class="s2">return </span><span class="s3">&quot;scene&quot;</span>
        <span class="s2">elif </span><span class="s3">&quot;subplot&quot; </span><span class="s2">in </span><span class="s1">trace:</span>
            <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">_subplot_prop_named_subplot:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">trace.subplot = t</span>
                    <span class="s2">return </span><span class="s1">t</span>
                <span class="s2">except </span><span class="s1">ValueError:</span>
                    <span class="s2">pass</span>

    <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">_validate_coerce_subplot_type(subplot_type):</span>

    <span class="s0"># Lowercase subplot_type</span>
    <span class="s1">orig_subplot_type = subplot_type</span>
    <span class="s1">subplot_type = subplot_type.lower()</span>

    <span class="s0"># Check if it's a named subplot type</span>
    <span class="s2">if </span><span class="s1">subplot_type </span><span class="s2">in </span><span class="s1">_subplot_types:</span>
        <span class="s2">return </span><span class="s1">subplot_type</span>

    <span class="s0"># Try to determine subplot type for trace</span>
    <span class="s1">subplot_type = _subplot_type_for_trace_type(subplot_type)</span>

    <span class="s2">if </span><span class="s1">subplot_type </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unsupported subplot type: {}&quot;</span><span class="s1">.format(repr(orig_subplot_type)))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">subplot_type</span>


<span class="s2">def </span><span class="s1">_init_subplot(</span>
    <span class="s1">layout</span><span class="s2">, </span><span class="s1">subplot_type</span><span class="s2">, </span><span class="s1">secondary_y</span><span class="s2">, </span><span class="s1">x_domain</span><span class="s2">, </span><span class="s1">y_domain</span><span class="s2">, </span><span class="s1">max_subplot_ids=</span><span class="s2">None</span>
<span class="s1">):</span>
    <span class="s0"># Normalize subplot type</span>
    <span class="s1">subplot_type = _validate_coerce_subplot_type(subplot_type)</span>

    <span class="s2">if </span><span class="s1">max_subplot_ids </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">max_subplot_ids = _get_initial_max_subplot_ids()</span>

    <span class="s0"># Clamp domain elements between [0, 1].</span>
    <span class="s0"># This is only needed to combat numerical precision errors</span>
    <span class="s0"># See GH1031</span>
    <span class="s1">x_domain = [max(</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">x_domain[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">min(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">x_domain[</span><span class="s4">1</span><span class="s1">])]</span>
    <span class="s1">y_domain = [max(</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">y_domain[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">min(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">y_domain[</span><span class="s4">1</span><span class="s1">])]</span>

    <span class="s2">if </span><span class="s1">subplot_type == </span><span class="s3">&quot;xy&quot;</span><span class="s1">:</span>
        <span class="s1">subplot_refs = _init_subplot_xy(</span>
            <span class="s1">layout</span><span class="s2">, </span><span class="s1">secondary_y</span><span class="s2">, </span><span class="s1">x_domain</span><span class="s2">, </span><span class="s1">y_domain</span><span class="s2">, </span><span class="s1">max_subplot_ids</span>
        <span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">subplot_type </span><span class="s2">in </span><span class="s1">_single_subplot_types:</span>
        <span class="s1">subplot_refs = _init_subplot_single(</span>
            <span class="s1">layout</span><span class="s2">, </span><span class="s1">subplot_type</span><span class="s2">, </span><span class="s1">x_domain</span><span class="s2">, </span><span class="s1">y_domain</span><span class="s2">, </span><span class="s1">max_subplot_ids</span>
        <span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">subplot_type == </span><span class="s3">&quot;domain&quot;</span><span class="s1">:</span>
        <span class="s1">subplot_refs = _init_subplot_domain(x_domain</span><span class="s2">, </span><span class="s1">y_domain)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unsupported subplot type: {}&quot;</span><span class="s1">.format(repr(subplot_type)))</span>

    <span class="s2">return </span><span class="s1">subplot_refs</span>


<span class="s2">def </span><span class="s1">_get_cartesian_label(x_or_y</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">cnt):</span>
    <span class="s0"># Default label (given strictly by cnt)</span>
    <span class="s1">label = </span><span class="s3">&quot;{x_or_y}{cnt}&quot;</span><span class="s1">.format(x_or_y=x_or_y</span><span class="s2">, </span><span class="s1">cnt=cnt)</span>
    <span class="s2">return </span><span class="s1">label</span>


<span class="s2">def </span><span class="s1">_build_subplot_title_annotations(</span>
    <span class="s1">subplot_titles</span><span class="s2">, </span><span class="s1">list_of_domains</span><span class="s2">, </span><span class="s1">title_edge=</span><span class="s3">&quot;top&quot;</span><span class="s2">, </span><span class="s1">offset=</span><span class="s4">0</span>
<span class="s1">):</span>
    <span class="s0"># If shared_axes is False (default) use list_of_domains</span>
    <span class="s0"># This is used for insets and irregular layouts</span>
    <span class="s0"># if not shared_xaxes and not shared_yaxes:</span>
    <span class="s1">x_dom = list_of_domains[::</span><span class="s4">2</span><span class="s1">]</span>
    <span class="s1">y_dom = list_of_domains[</span><span class="s4">1</span><span class="s1">::</span><span class="s4">2</span><span class="s1">]</span>
    <span class="s1">subtitle_pos_x = []</span>
    <span class="s1">subtitle_pos_y = []</span>

    <span class="s2">if </span><span class="s1">title_edge == </span><span class="s3">&quot;top&quot;</span><span class="s1">:</span>
        <span class="s1">text_angle = </span><span class="s4">0</span>
        <span class="s1">xanchor = </span><span class="s3">&quot;center&quot;</span>
        <span class="s1">yanchor = </span><span class="s3">&quot;bottom&quot;</span>

        <span class="s2">for </span><span class="s1">x_domains </span><span class="s2">in </span><span class="s1">x_dom:</span>
            <span class="s1">subtitle_pos_x.append(sum(x_domains) / </span><span class="s4">2.0</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">y_domains </span><span class="s2">in </span><span class="s1">y_dom:</span>
            <span class="s1">subtitle_pos_y.append(y_domains[</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s1">yshift = offset</span>
        <span class="s1">xshift = </span><span class="s4">0</span>
    <span class="s2">elif </span><span class="s1">title_edge == </span><span class="s3">&quot;bottom&quot;</span><span class="s1">:</span>
        <span class="s1">text_angle = </span><span class="s4">0</span>
        <span class="s1">xanchor = </span><span class="s3">&quot;center&quot;</span>
        <span class="s1">yanchor = </span><span class="s3">&quot;top&quot;</span>

        <span class="s2">for </span><span class="s1">x_domains </span><span class="s2">in </span><span class="s1">x_dom:</span>
            <span class="s1">subtitle_pos_x.append(sum(x_domains) / </span><span class="s4">2.0</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">y_domains </span><span class="s2">in </span><span class="s1">y_dom:</span>
            <span class="s1">subtitle_pos_y.append(y_domains[</span><span class="s4">0</span><span class="s1">])</span>

        <span class="s1">yshift = -offset</span>
        <span class="s1">xshift = </span><span class="s4">0</span>
    <span class="s2">elif </span><span class="s1">title_edge == </span><span class="s3">&quot;right&quot;</span><span class="s1">:</span>
        <span class="s1">text_angle = </span><span class="s4">90</span>
        <span class="s1">xanchor = </span><span class="s3">&quot;left&quot;</span>
        <span class="s1">yanchor = </span><span class="s3">&quot;middle&quot;</span>

        <span class="s2">for </span><span class="s1">x_domains </span><span class="s2">in </span><span class="s1">x_dom:</span>
            <span class="s1">subtitle_pos_x.append(x_domains[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s2">for </span><span class="s1">y_domains </span><span class="s2">in </span><span class="s1">y_dom:</span>
            <span class="s1">subtitle_pos_y.append(sum(y_domains) / </span><span class="s4">2.0</span><span class="s1">)</span>

        <span class="s1">yshift = </span><span class="s4">0</span>
        <span class="s1">xshift = offset</span>
    <span class="s2">elif </span><span class="s1">title_edge == </span><span class="s3">&quot;left&quot;</span><span class="s1">:</span>
        <span class="s1">text_angle = -</span><span class="s4">90</span>
        <span class="s1">xanchor = </span><span class="s3">&quot;right&quot;</span>
        <span class="s1">yanchor = </span><span class="s3">&quot;middle&quot;</span>

        <span class="s2">for </span><span class="s1">x_domains </span><span class="s2">in </span><span class="s1">x_dom:</span>
            <span class="s1">subtitle_pos_x.append(x_domains[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s2">for </span><span class="s1">y_domains </span><span class="s2">in </span><span class="s1">y_dom:</span>
            <span class="s1">subtitle_pos_y.append(sum(y_domains) / </span><span class="s4">2.0</span><span class="s1">)</span>

        <span class="s1">yshift = </span><span class="s4">0</span>
        <span class="s1">xshift = -offset</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Invalid annotation edge '{edge}'&quot;</span><span class="s1">.format(edge=title_edge))</span>

    <span class="s1">plot_titles = []</span>
    <span class="s2">for </span><span class="s1">index </span><span class="s2">in </span><span class="s1">range(len(subplot_titles)):</span>
        <span class="s2">if not </span><span class="s1">subplot_titles[index] </span><span class="s2">or </span><span class="s1">index &gt;= len(subtitle_pos_y):</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">annot = {</span>
                <span class="s3">&quot;y&quot;</span><span class="s1">: subtitle_pos_y[index]</span><span class="s2">,</span>
                <span class="s3">&quot;xref&quot;</span><span class="s1">: </span><span class="s3">&quot;paper&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;x&quot;</span><span class="s1">: subtitle_pos_x[index]</span><span class="s2">,</span>
                <span class="s3">&quot;yref&quot;</span><span class="s1">: </span><span class="s3">&quot;paper&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;text&quot;</span><span class="s1">: subplot_titles[index]</span><span class="s2">,</span>
                <span class="s3">&quot;showarrow&quot;</span><span class="s1">: </span><span class="s2">False,</span>
                <span class="s3">&quot;font&quot;</span><span class="s1">: dict(size=</span><span class="s4">16</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;xanchor&quot;</span><span class="s1">: xanchor</span><span class="s2">,</span>
                <span class="s3">&quot;yanchor&quot;</span><span class="s1">: yanchor</span><span class="s2">,</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">xshift != </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">annot[</span><span class="s3">&quot;xshift&quot;</span><span class="s1">] = xshift</span>

            <span class="s2">if </span><span class="s1">yshift != </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">annot[</span><span class="s3">&quot;yshift&quot;</span><span class="s1">] = yshift</span>

            <span class="s2">if </span><span class="s1">text_angle != </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">annot[</span><span class="s3">&quot;textangle&quot;</span><span class="s1">] = text_angle</span>

            <span class="s1">plot_titles.append(annot)</span>
    <span class="s2">return </span><span class="s1">plot_titles</span>


<span class="s2">def </span><span class="s1">_build_grid_str(specs</span><span class="s2">, </span><span class="s1">grid_ref</span><span class="s2">, </span><span class="s1">insets</span><span class="s2">, </span><span class="s1">insets_ref</span><span class="s2">, </span><span class="s1">row_seq):</span>

    <span class="s0"># Compute rows and columns</span>
    <span class="s1">rows = len(specs)</span>
    <span class="s1">cols = len(specs[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s0"># Initialize constants</span>
    <span class="s1">sp = </span><span class="s3">&quot;  &quot;  </span><span class="s0"># space between cell</span>
    <span class="s1">s_str = </span><span class="s3">&quot;[ &quot;  </span><span class="s0"># cell start string</span>
    <span class="s1">e_str = </span><span class="s3">&quot; ]&quot;  </span><span class="s0"># cell end string</span>

    <span class="s1">s_top = </span><span class="s3">&quot; &quot;  </span><span class="s0"># U+23A1</span>
    <span class="s1">s_mid = </span><span class="s3">&quot; &quot;  </span><span class="s0"># U+23A2</span>
    <span class="s1">s_bot = </span><span class="s3">&quot; &quot;  </span><span class="s0"># U+23A3</span>

    <span class="s1">e_top = </span><span class="s3">&quot; &quot;  </span><span class="s0"># U+23A4</span>
    <span class="s1">e_mid = </span><span class="s3">&quot; &quot;  </span><span class="s0"># U+239F</span>
    <span class="s1">e_bot = </span><span class="s3">&quot; &quot;  </span><span class="s0"># U+23A6</span>

    <span class="s1">colspan_str = </span><span class="s3">&quot;       -&quot;  </span><span class="s0"># colspan string</span>
    <span class="s1">rowspan_str = </span><span class="s3">&quot;       :&quot;  </span><span class="s0"># rowspan string</span>
    <span class="s1">empty_str = </span><span class="s3">&quot;    (empty) &quot;  </span><span class="s0"># empty cell string</span>
    <span class="s0"># Init grid_str with intro message</span>
    <span class="s1">grid_str = </span><span class="s3">&quot;This is the format of your plot grid:</span><span class="s2">\n</span><span class="s3">&quot;</span>

    <span class="s0"># Init tmp list of lists of strings (sorta like 'grid_ref' but w/ strings)</span>
    <span class="s1">_tmp = [[</span><span class="s3">&quot;&quot; </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range(cols)] </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">range(rows)]</span>

    <span class="s0"># Define cell string as function of (r, c) and grid_ref</span>
    <span class="s2">def </span><span class="s1">_get_cell_str(r</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">subplot_refs):</span>
        <span class="s1">layout_keys = sorted({k </span><span class="s2">for </span><span class="s1">ref </span><span class="s2">in </span><span class="s1">subplot_refs </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">ref.layout_keys})</span>

        <span class="s1">ref_str = </span><span class="s3">&quot;,&quot;</span><span class="s1">.join(layout_keys)</span>

        <span class="s0"># Replace yaxis2 -&gt; y2</span>
        <span class="s1">ref_str = ref_str.replace(</span><span class="s3">&quot;axis&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s3">&quot;({r},{c}) {ref}&quot;</span><span class="s1">.format(r=r + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">c=c + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">ref=ref_str)</span>

    <span class="s0"># Find max len of _cell_str, add define a padding function</span>
    <span class="s1">cell_len = (</span>
        <span class="s1">max(</span>
            <span class="s1">[</span>
                <span class="s1">len(_get_cell_str(r</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">ref))</span>
                <span class="s2">for </span><span class="s1">r</span><span class="s2">, </span><span class="s1">row_ref </span><span class="s2">in </span><span class="s1">enumerate(grid_ref)</span>
                <span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">ref </span><span class="s2">in </span><span class="s1">enumerate(row_ref)</span>
                <span class="s2">if </span><span class="s1">ref</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">+ len(s_str)</span>
        <span class="s1">+ len(e_str)</span>
    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_pad(s</span><span class="s2">, </span><span class="s1">cell_len=cell_len):</span>
        <span class="s2">return </span><span class="s3">&quot; &quot; </span><span class="s1">* (cell_len - len(s))</span>

    <span class="s0"># Loop through specs, fill in _tmp</span>
    <span class="s2">for </span><span class="s1">r</span><span class="s2">, </span><span class="s1">spec_row </span><span class="s2">in </span><span class="s1">enumerate(specs):</span>
        <span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">spec </span><span class="s2">in </span><span class="s1">enumerate(spec_row):</span>

            <span class="s1">ref = grid_ref[r][c]</span>
            <span class="s2">if </span><span class="s1">ref </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">_tmp[r][c] == </span><span class="s3">&quot;&quot;</span><span class="s1">:</span>
                    <span class="s1">_tmp[r][c] = empty_str + _pad(empty_str)</span>
                <span class="s2">continue</span>

            <span class="s2">if </span><span class="s1">spec[</span><span class="s3">&quot;rowspan&quot;</span><span class="s1">] &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">cell_str = s_top + _get_cell_str(r</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">ref)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">cell_str = s_str + _get_cell_str(r</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">ref)</span>

            <span class="s2">if </span><span class="s1">spec[</span><span class="s3">&quot;colspan&quot;</span><span class="s1">] &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">cc </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">spec[</span><span class="s3">&quot;colspan&quot;</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">):</span>
                    <span class="s1">_tmp[r][c + cc] = colspan_str + _pad(colspan_str)</span>

                <span class="s2">if </span><span class="s1">spec[</span><span class="s3">&quot;rowspan&quot;</span><span class="s1">] &gt; </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s1">_tmp[r][c + spec[</span><span class="s3">&quot;colspan&quot;</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">] = (</span>
                        <span class="s1">colspan_str + _pad(colspan_str + e_str)</span>
                    <span class="s1">) + e_top</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">_tmp[r][c + spec[</span><span class="s3">&quot;colspan&quot;</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">] = (</span>
                        <span class="s1">colspan_str + _pad(colspan_str + e_str)</span>
                    <span class="s1">) + e_str</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">padding = </span><span class="s3">&quot; &quot; </span><span class="s1">* (cell_len - len(cell_str) - </span><span class="s4">2</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">spec[</span><span class="s3">&quot;rowspan&quot;</span><span class="s1">] &gt; </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s1">cell_str += padding + e_top</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">cell_str += padding + e_str</span>

            <span class="s2">if </span><span class="s1">spec[</span><span class="s3">&quot;rowspan&quot;</span><span class="s1">] &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">cc </span><span class="s2">in </span><span class="s1">range(spec[</span><span class="s3">&quot;colspan&quot;</span><span class="s1">]):</span>
                    <span class="s2">for </span><span class="s1">rr </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">spec[</span><span class="s3">&quot;rowspan&quot;</span><span class="s1">]):</span>
                        <span class="s1">row_str = rowspan_str + _pad(rowspan_str)</span>
                        <span class="s2">if </span><span class="s1">cc == </span><span class="s4">0</span><span class="s1">:</span>
                            <span class="s2">if </span><span class="s1">rr &lt; spec[</span><span class="s3">&quot;rowspan&quot;</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">:</span>
                                <span class="s1">row_str = s_mid + row_str[</span><span class="s4">2</span><span class="s1">:]</span>
                            <span class="s2">else</span><span class="s1">:</span>
                                <span class="s1">row_str = s_bot + row_str[</span><span class="s4">2</span><span class="s1">:]</span>

                        <span class="s2">if </span><span class="s1">cc == spec[</span><span class="s3">&quot;colspan&quot;</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">:</span>
                            <span class="s2">if </span><span class="s1">rr &lt; spec[</span><span class="s3">&quot;rowspan&quot;</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">:</span>
                                <span class="s1">row_str = row_str[:-</span><span class="s4">2</span><span class="s1">] + e_mid</span>
                            <span class="s2">else</span><span class="s1">:</span>
                                <span class="s1">row_str = row_str[:-</span><span class="s4">2</span><span class="s1">] + e_bot</span>

                        <span class="s1">_tmp[r + rr][c + cc] = row_str</span>

            <span class="s1">_tmp[r][c] = cell_str + _pad(cell_str)</span>

    <span class="s0"># Append grid_str using data from _tmp in the correct order</span>
    <span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">row_seq[::-</span><span class="s4">1</span><span class="s1">]:</span>
        <span class="s1">grid_str += sp.join(_tmp[r]) + </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>

    <span class="s0"># Append grid_str to include insets info</span>
    <span class="s2">if </span><span class="s1">insets:</span>
        <span class="s1">grid_str += </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">With insets:</span><span class="s2">\n</span><span class="s3">&quot;</span>
        <span class="s2">for </span><span class="s1">i_inset</span><span class="s2">, </span><span class="s1">inset </span><span class="s2">in </span><span class="s1">enumerate(insets):</span>
            <span class="s1">r = inset[</span><span class="s3">&quot;cell&quot;</span><span class="s1">][</span><span class="s4">0</span><span class="s1">] - </span><span class="s4">1</span>
            <span class="s1">c = inset[</span><span class="s3">&quot;cell&quot;</span><span class="s1">][</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">1</span>
            <span class="s1">ref = grid_ref[r][c]</span>

            <span class="s1">subplot_labels_str = </span><span class="s3">&quot;,&quot;</span><span class="s1">.join(insets_ref[i_inset][</span><span class="s4">0</span><span class="s1">].layout_keys)</span>

            <span class="s0"># Replace, e.g., yaxis2 -&gt; y2</span>
            <span class="s1">subplot_labels_str = subplot_labels_str.replace(</span><span class="s3">&quot;axis&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>

            <span class="s1">grid_str += (</span>
                <span class="s1">s_str</span>
                <span class="s1">+ subplot_labels_str</span>
                <span class="s1">+ e_str</span>
                <span class="s1">+ </span><span class="s3">&quot; over &quot;</span>
                <span class="s1">+ s_str</span>
                <span class="s1">+ _get_cell_str(r</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">ref)</span>
                <span class="s1">+ e_str</span>
                <span class="s1">+ </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
            <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">grid_str</span>


<span class="s2">def </span><span class="s1">_set_trace_grid_reference(trace</span><span class="s2">, </span><span class="s1">layout</span><span class="s2">, </span><span class="s1">grid_ref</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">secondary_y=</span><span class="s2">False</span><span class="s1">):</span>

    <span class="s2">if </span><span class="s1">row &lt;= </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">Exception(</span>
            <span class="s3">&quot;Row value is out of range. &quot; &quot;Note: the starting cell is (1, 1)&quot;</span>
        <span class="s1">)</span>
    <span class="s2">if </span><span class="s1">col &lt;= </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">Exception(</span>
            <span class="s3">&quot;Col value is out of range. &quot; &quot;Note: the starting cell is (1, 1)&quot;</span>
        <span class="s1">)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">subplot_refs = grid_ref[row - </span><span class="s4">1</span><span class="s1">][col - </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s2">except </span><span class="s1">IndexError:</span>
        <span class="s2">raise </span><span class="s1">Exception(</span>
            <span class="s3">&quot;The (row, col) pair sent is out of &quot;</span>
            <span class="s3">&quot;range. Use Figure.print_grid to view the &quot;</span>
            <span class="s3">&quot;subplot grid. &quot;</span>
        <span class="s1">)</span>

    <span class="s2">if not </span><span class="s1">subplot_refs:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;&quot;&quot; 
No subplot specified at grid position ({row}, {col})&quot;&quot;&quot;</span><span class="s1">.format(</span>
                <span class="s1">row=row</span><span class="s2">, </span><span class="s1">col=col</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">secondary_y:</span>
        <span class="s2">if </span><span class="s1">len(subplot_refs) &lt; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;&quot;&quot; 
Subplot with type '{subplot_type}' at grid position ({row}, {col}) was not 
created with the secondary_y spec property set to True. See the docstring 
for the specs argument to plotly.subplots.make_subplots for more information. 
&quot;&quot;&quot;</span>
            <span class="s1">)</span>
        <span class="s1">trace_kwargs = subplot_refs[</span><span class="s4">1</span><span class="s1">].trace_kwargs</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">trace_kwargs = subplot_refs[</span><span class="s4">0</span><span class="s1">].trace_kwargs</span>

    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">trace_kwargs:</span>
        <span class="s2">if </span><span class="s1">k </span><span class="s2">not in </span><span class="s1">trace:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">Trace type '{typ}' is not compatible with subplot type '{subplot_type}' 
at grid position ({row}, {col})  
 
See the docstring for the specs argument to plotly.subplots.make_subplots  
for more information on subplot types&quot;&quot;&quot;</span><span class="s1">.format(</span>
                    <span class="s1">typ=trace.type</span><span class="s2">,</span>
                    <span class="s1">subplot_type=subplot_refs[</span><span class="s4">0</span><span class="s1">].subplot_type</span><span class="s2">,</span>
                    <span class="s1">row=row</span><span class="s2">,</span>
                    <span class="s1">col=col</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

    <span class="s0"># Update trace reference</span>
    <span class="s1">trace.update(trace_kwargs)</span>


<span class="s2">def </span><span class="s1">_get_grid_subplot(fig</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">secondary_y=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">grid_ref = fig._grid_ref</span>
    <span class="s2">except </span><span class="s1">AttributeError:</span>
        <span class="s2">raise </span><span class="s1">Exception(</span>
            <span class="s3">&quot;In order to reference traces by row and column, &quot;</span>
            <span class="s3">&quot;you must first use &quot;</span>
            <span class="s3">&quot;plotly.tools.make_subplots &quot;</span>
            <span class="s3">&quot;to create the figure with a subplot grid.&quot;</span>
        <span class="s1">)</span>

    <span class="s1">rows = len(grid_ref)</span>
    <span class="s1">cols = len(grid_ref[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s0"># Validate row</span>
    <span class="s2">if not </span><span class="s1">isinstance(row</span><span class="s2">, </span><span class="s1">int) </span><span class="s2">or </span><span class="s1">row &lt; </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">rows &lt; row:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;&quot;&quot; 
The row argument to get_subplot must be an integer where 1 &lt;= row &lt;= {rows} 
    Received value of type {typ}: {val}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                <span class="s1">rows=rows</span><span class="s2">, </span><span class="s1">typ=type(row)</span><span class="s2">, </span><span class="s1">val=repr(row)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">if not </span><span class="s1">isinstance(col</span><span class="s2">, </span><span class="s1">int) </span><span class="s2">or </span><span class="s1">col &lt; </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">cols &lt; col:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;&quot;&quot; 
The col argument to get_subplot must be an integer where 1 &lt;= row &lt;= {cols} 
    Received value of type {typ}: {val}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                <span class="s1">cols=cols</span><span class="s2">, </span><span class="s1">typ=type(col)</span><span class="s2">, </span><span class="s1">val=repr(col)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">subplot_refs = fig._grid_ref[row - </span><span class="s4">1</span><span class="s1">][col - </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s2">if not </span><span class="s1">subplot_refs:</span>
        <span class="s2">return None</span>

    <span class="s2">if </span><span class="s1">secondary_y:</span>
        <span class="s2">if </span><span class="s1">len(subplot_refs) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">layout_keys = subplot_refs[</span><span class="s4">1</span><span class="s1">].layout_keys</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return None</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">layout_keys = subplot_refs[</span><span class="s4">0</span><span class="s1">].layout_keys</span>

    <span class="s2">if </span><span class="s1">len(layout_keys) == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">SubplotDomain(**subplot_refs[</span><span class="s4">0</span><span class="s1">].trace_kwargs[</span><span class="s3">&quot;domain&quot;</span><span class="s1">])</span>
    <span class="s2">elif </span><span class="s1">len(layout_keys) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">fig.layout[layout_keys[</span><span class="s4">0</span><span class="s1">]]</span>
    <span class="s2">elif </span><span class="s1">len(layout_keys) == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">SubplotXY(</span>
            <span class="s1">xaxis=fig.layout[layout_keys[</span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">yaxis=fig.layout[layout_keys[</span><span class="s4">1</span><span class="s1">]]</span>
        <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;&quot;&quot; 
Unexpected subplot type with layout_keys of {}&quot;&quot;&quot;</span><span class="s1">.format(</span>
                <span class="s1">layout_keys</span>
            <span class="s1">)</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_get_subplot_ref_for_trace(trace):</span>

    <span class="s2">if </span><span class="s3">&quot;domain&quot; </span><span class="s2">in </span><span class="s1">trace:</span>
        <span class="s2">return </span><span class="s1">SubplotRef(</span>
            <span class="s1">subplot_type=</span><span class="s3">&quot;domain&quot;</span><span class="s2">,</span>
            <span class="s1">layout_keys=()</span><span class="s2">,</span>
            <span class="s1">trace_kwargs={</span><span class="s3">&quot;domain&quot;</span><span class="s1">: {</span><span class="s3">&quot;x&quot;</span><span class="s1">: trace.domain.x</span><span class="s2">, </span><span class="s3">&quot;y&quot;</span><span class="s1">: trace.domain.y}}</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">elif </span><span class="s3">&quot;xaxis&quot; </span><span class="s2">in </span><span class="s1">trace </span><span class="s2">and </span><span class="s3">&quot;yaxis&quot; </span><span class="s2">in </span><span class="s1">trace:</span>
        <span class="s1">xaxis_name = </span><span class="s3">&quot;xaxis&quot; </span><span class="s1">+ trace.xaxis[</span><span class="s4">1</span><span class="s1">:] </span><span class="s2">if </span><span class="s1">trace.xaxis </span><span class="s2">else </span><span class="s3">&quot;xaxis&quot;</span>
        <span class="s1">yaxis_name = </span><span class="s3">&quot;yaxis&quot; </span><span class="s1">+ trace.yaxis[</span><span class="s4">1</span><span class="s1">:] </span><span class="s2">if </span><span class="s1">trace.yaxis </span><span class="s2">else </span><span class="s3">&quot;yaxis&quot;</span>

        <span class="s2">return </span><span class="s1">SubplotRef(</span>
            <span class="s1">subplot_type=</span><span class="s3">&quot;xy&quot;</span><span class="s2">,</span>
            <span class="s1">layout_keys=(xaxis_name</span><span class="s2">, </span><span class="s1">yaxis_name)</span><span class="s2">,</span>
            <span class="s1">trace_kwargs={</span><span class="s3">&quot;xaxis&quot;</span><span class="s1">: trace.xaxis</span><span class="s2">, </span><span class="s3">&quot;yaxis&quot;</span><span class="s1">: trace.yaxis}</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s2">elif </span><span class="s3">&quot;geo&quot; </span><span class="s2">in </span><span class="s1">trace:</span>
        <span class="s2">return </span><span class="s1">SubplotRef(</span>
            <span class="s1">subplot_type=</span><span class="s3">&quot;geo&quot;</span><span class="s2">,</span>
            <span class="s1">layout_keys=(trace.geo</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">trace_kwargs={</span><span class="s3">&quot;geo&quot;</span><span class="s1">: trace.geo}</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s2">elif </span><span class="s3">&quot;scene&quot; </span><span class="s2">in </span><span class="s1">trace:</span>
        <span class="s2">return </span><span class="s1">SubplotRef(</span>
            <span class="s1">subplot_type=</span><span class="s3">&quot;scene&quot;</span><span class="s2">,</span>
            <span class="s1">layout_keys=(trace.scene</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">trace_kwargs={</span><span class="s3">&quot;scene&quot;</span><span class="s1">: trace.scene}</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s2">elif </span><span class="s3">&quot;subplot&quot; </span><span class="s2">in </span><span class="s1">trace:</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">_subplot_prop_named_subplot:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">validator = trace._get_prop_validator(</span><span class="s3">&quot;subplot&quot;</span><span class="s1">)</span>
                <span class="s1">validator.validate_coerce(t)</span>
                <span class="s2">return </span><span class="s1">SubplotRef(</span>
                    <span class="s1">subplot_type=t</span><span class="s2">,</span>
                    <span class="s1">layout_keys=(trace.subplot</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">trace_kwargs={</span><span class="s3">&quot;subplot&quot;</span><span class="s1">: trace.subplot}</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s2">pass</span>

    <span class="s2">return None</span>
</pre>
</body>
</html>