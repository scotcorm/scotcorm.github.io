<html>
<head>
<title>cmdline.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
cmdline.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
    pygments.cmdline 
    ~~~~~~~~~~~~~~~~ 
 
    Command line interface. 
 
    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS. 
    :license: BSD, see LICENSE for details. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">shutil</span>
<span class="s2">import </span><span class="s1">argparse</span>
<span class="s2">from </span><span class="s1">textwrap </span><span class="s2">import </span><span class="s1">dedent</span>

<span class="s2">from </span><span class="s1">pip._vendor.pygments </span><span class="s2">import </span><span class="s1">__version__</span><span class="s2">, </span><span class="s1">highlight</span>
<span class="s2">from </span><span class="s1">pip._vendor.pygments.util </span><span class="s2">import </span><span class="s1">ClassNotFound</span><span class="s2">, </span><span class="s1">OptionError</span><span class="s2">, </span><span class="s1">docstring_headline</span><span class="s2">, </span><span class="s1">\</span>
    <span class="s1">guess_decode</span><span class="s2">, </span><span class="s1">guess_decode_from_terminal</span><span class="s2">, </span><span class="s1">terminal_encoding</span><span class="s2">, </span><span class="s1">\</span>
    <span class="s1">UnclosingTextIOWrapper</span>
<span class="s2">from </span><span class="s1">pip._vendor.pygments.lexers </span><span class="s2">import </span><span class="s1">get_all_lexers</span><span class="s2">, </span><span class="s1">get_lexer_by_name</span><span class="s2">, </span><span class="s1">guess_lexer</span><span class="s2">, </span><span class="s1">\</span>
    <span class="s1">load_lexer_from_file</span><span class="s2">, </span><span class="s1">get_lexer_for_filename</span><span class="s2">, </span><span class="s1">find_lexer_class_for_filename</span>
<span class="s2">from </span><span class="s1">pip._vendor.pygments.lexers.special </span><span class="s2">import </span><span class="s1">TextLexer</span>
<span class="s2">from </span><span class="s1">pip._vendor.pygments.formatters.latex </span><span class="s2">import </span><span class="s1">LatexEmbeddedLexer</span><span class="s2">, </span><span class="s1">LatexFormatter</span>
<span class="s2">from </span><span class="s1">pip._vendor.pygments.formatters </span><span class="s2">import </span><span class="s1">get_all_formatters</span><span class="s2">, </span><span class="s1">get_formatter_by_name</span><span class="s2">, </span><span class="s1">\</span>
    <span class="s1">load_formatter_from_file</span><span class="s2">, </span><span class="s1">get_formatter_for_filename</span><span class="s2">, </span><span class="s1">find_formatter_class</span>
<span class="s2">from </span><span class="s1">pip._vendor.pygments.formatters.terminal </span><span class="s2">import </span><span class="s1">TerminalFormatter</span>
<span class="s2">from </span><span class="s1">pip._vendor.pygments.formatters.terminal256 </span><span class="s2">import </span><span class="s1">Terminal256Formatter</span>
<span class="s2">from </span><span class="s1">pip._vendor.pygments.filters </span><span class="s2">import </span><span class="s1">get_all_filters</span><span class="s2">, </span><span class="s1">find_filter_class</span>
<span class="s2">from </span><span class="s1">pip._vendor.pygments.styles </span><span class="s2">import </span><span class="s1">get_all_styles</span><span class="s2">, </span><span class="s1">get_style_by_name</span>


<span class="s2">def </span><span class="s1">_parse_options(o_strs):</span>
    <span class="s1">opts = {}</span>
    <span class="s2">if not </span><span class="s1">o_strs:</span>
        <span class="s2">return </span><span class="s1">opts</span>
    <span class="s2">for </span><span class="s1">o_str </span><span class="s2">in </span><span class="s1">o_strs:</span>
        <span class="s2">if not </span><span class="s1">o_str.strip():</span>
            <span class="s2">continue</span>
        <span class="s1">o_args = o_str.split(</span><span class="s3">','</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">o_arg </span><span class="s2">in </span><span class="s1">o_args:</span>
            <span class="s1">o_arg = o_arg.strip()</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">o_key</span><span class="s2">, </span><span class="s1">o_val = o_arg.split(</span><span class="s3">'='</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">o_key = o_key.strip()</span>
                <span class="s1">o_val = o_val.strip()</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s1">opts[o_arg] = </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">opts[o_key] = o_val</span>
    <span class="s2">return </span><span class="s1">opts</span>


<span class="s2">def </span><span class="s1">_parse_filters(f_strs):</span>
    <span class="s1">filters = []</span>
    <span class="s2">if not </span><span class="s1">f_strs:</span>
        <span class="s2">return </span><span class="s1">filters</span>
    <span class="s2">for </span><span class="s1">f_str </span><span class="s2">in </span><span class="s1">f_strs:</span>
        <span class="s2">if </span><span class="s3">':' </span><span class="s2">in </span><span class="s1">f_str:</span>
            <span class="s1">fname</span><span class="s2">, </span><span class="s1">fopts = f_str.split(</span><span class="s3">':'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">filters.append((fname</span><span class="s2">, </span><span class="s1">_parse_options([fopts])))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">filters.append((f_str</span><span class="s2">, </span><span class="s1">{}))</span>
    <span class="s2">return </span><span class="s1">filters</span>


<span class="s2">def </span><span class="s1">_print_help(what</span><span class="s2">, </span><span class="s1">name):</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">what == </span><span class="s3">'lexer'</span><span class="s1">:</span>
            <span class="s1">cls = get_lexer_by_name(name)</span>
            <span class="s1">print(</span><span class="s3">&quot;Help on the %s lexer:&quot; </span><span class="s1">% cls.name)</span>
            <span class="s1">print(dedent(cls.__doc__))</span>
        <span class="s2">elif </span><span class="s1">what == </span><span class="s3">'formatter'</span><span class="s1">:</span>
            <span class="s1">cls = find_formatter_class(name)</span>
            <span class="s1">print(</span><span class="s3">&quot;Help on the %s formatter:&quot; </span><span class="s1">% cls.name)</span>
            <span class="s1">print(dedent(cls.__doc__))</span>
        <span class="s2">elif </span><span class="s1">what == </span><span class="s3">'filter'</span><span class="s1">:</span>
            <span class="s1">cls = find_filter_class(name)</span>
            <span class="s1">print(</span><span class="s3">&quot;Help on the %s filter:&quot; </span><span class="s1">% name)</span>
            <span class="s1">print(dedent(cls.__doc__))</span>
        <span class="s2">return </span><span class="s4">0</span>
    <span class="s2">except </span><span class="s1">(AttributeError</span><span class="s2">, </span><span class="s1">ValueError):</span>
        <span class="s1">print(</span><span class="s3">&quot;%s not found!&quot; </span><span class="s1">% what</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>
        <span class="s2">return </span><span class="s4">1</span>


<span class="s2">def </span><span class="s1">_print_list(what):</span>
    <span class="s2">if </span><span class="s1">what == </span><span class="s3">'lexer'</span><span class="s1">:</span>
        <span class="s1">print()</span>
        <span class="s1">print(</span><span class="s3">&quot;Lexers:&quot;</span><span class="s1">)</span>
        <span class="s1">print(</span><span class="s3">&quot;~~~~~~~&quot;</span><span class="s1">)</span>

        <span class="s1">info = []</span>
        <span class="s2">for </span><span class="s1">fullname</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">exts</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">get_all_lexers():</span>
            <span class="s1">tup = (</span><span class="s3">', '</span><span class="s1">.join(names)+</span><span class="s3">':'</span><span class="s2">, </span><span class="s1">fullname</span><span class="s2">,</span>
                   <span class="s1">exts </span><span class="s2">and </span><span class="s3">'(filenames ' </span><span class="s1">+ </span><span class="s3">', '</span><span class="s1">.join(exts) + </span><span class="s3">')' </span><span class="s2">or </span><span class="s3">''</span><span class="s1">)</span>
            <span class="s1">info.append(tup)</span>
        <span class="s1">info.sort()</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">info:</span>
            <span class="s1">print((</span><span class="s3">'* %s</span><span class="s2">\n    </span><span class="s3">%s %s'</span><span class="s1">) % i)</span>

    <span class="s2">elif </span><span class="s1">what == </span><span class="s3">'formatter'</span><span class="s1">:</span>
        <span class="s1">print()</span>
        <span class="s1">print(</span><span class="s3">&quot;Formatters:&quot;</span><span class="s1">)</span>
        <span class="s1">print(</span><span class="s3">&quot;~~~~~~~~~~~&quot;</span><span class="s1">)</span>

        <span class="s1">info = []</span>
        <span class="s2">for </span><span class="s1">cls </span><span class="s2">in </span><span class="s1">get_all_formatters():</span>
            <span class="s1">doc = docstring_headline(cls)</span>
            <span class="s1">tup = (</span><span class="s3">', '</span><span class="s1">.join(cls.aliases) + </span><span class="s3">':'</span><span class="s2">, </span><span class="s1">doc</span><span class="s2">, </span><span class="s1">cls.filenames </span><span class="s2">and</span>
                   <span class="s3">'(filenames ' </span><span class="s1">+ </span><span class="s3">', '</span><span class="s1">.join(cls.filenames) + </span><span class="s3">')' </span><span class="s2">or </span><span class="s3">''</span><span class="s1">)</span>
            <span class="s1">info.append(tup)</span>
        <span class="s1">info.sort()</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">info:</span>
            <span class="s1">print((</span><span class="s3">'* %s</span><span class="s2">\n    </span><span class="s3">%s %s'</span><span class="s1">) % i)</span>

    <span class="s2">elif </span><span class="s1">what == </span><span class="s3">'filter'</span><span class="s1">:</span>
        <span class="s1">print()</span>
        <span class="s1">print(</span><span class="s3">&quot;Filters:&quot;</span><span class="s1">)</span>
        <span class="s1">print(</span><span class="s3">&quot;~~~~~~~~&quot;</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">get_all_filters():</span>
            <span class="s1">cls = find_filter_class(name)</span>
            <span class="s1">print(</span><span class="s3">&quot;* &quot; </span><span class="s1">+ name + </span><span class="s3">':'</span><span class="s1">)</span>
            <span class="s1">print(</span><span class="s3">&quot;    %s&quot; </span><span class="s1">% docstring_headline(cls))</span>

    <span class="s2">elif </span><span class="s1">what == </span><span class="s3">'style'</span><span class="s1">:</span>
        <span class="s1">print()</span>
        <span class="s1">print(</span><span class="s3">&quot;Styles:&quot;</span><span class="s1">)</span>
        <span class="s1">print(</span><span class="s3">&quot;~~~~~~~&quot;</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">get_all_styles():</span>
            <span class="s1">cls = get_style_by_name(name)</span>
            <span class="s1">print(</span><span class="s3">&quot;* &quot; </span><span class="s1">+ name + </span><span class="s3">':'</span><span class="s1">)</span>
            <span class="s1">print(</span><span class="s3">&quot;    %s&quot; </span><span class="s1">% docstring_headline(cls))</span>


<span class="s2">def </span><span class="s1">_print_list_as_json(requested_items):</span>
    <span class="s2">import </span><span class="s1">json</span>
    <span class="s1">result = {}</span>
    <span class="s2">if </span><span class="s3">'lexer' </span><span class="s2">in </span><span class="s1">requested_items:</span>
        <span class="s1">info = {}</span>
        <span class="s2">for </span><span class="s1">fullname</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">filenames</span><span class="s2">, </span><span class="s1">mimetypes </span><span class="s2">in </span><span class="s1">get_all_lexers():</span>
            <span class="s1">info[fullname] = {</span>
                <span class="s3">'aliases'</span><span class="s1">: names</span><span class="s2">,</span>
                <span class="s3">'filenames'</span><span class="s1">: filenames</span><span class="s2">,</span>
                <span class="s3">'mimetypes'</span><span class="s1">: mimetypes</span>
            <span class="s1">}</span>
        <span class="s1">result[</span><span class="s3">'lexers'</span><span class="s1">] = info</span>

    <span class="s2">if </span><span class="s3">'formatter' </span><span class="s2">in </span><span class="s1">requested_items:</span>
        <span class="s1">info = {}</span>
        <span class="s2">for </span><span class="s1">cls </span><span class="s2">in </span><span class="s1">get_all_formatters():</span>
            <span class="s1">doc = docstring_headline(cls)</span>
            <span class="s1">info[cls.name] = {</span>
                <span class="s3">'aliases'</span><span class="s1">: cls.aliases</span><span class="s2">,</span>
                <span class="s3">'filenames'</span><span class="s1">: cls.filenames</span><span class="s2">,</span>
                <span class="s3">'doc'</span><span class="s1">: doc</span>
            <span class="s1">}</span>
        <span class="s1">result[</span><span class="s3">'formatters'</span><span class="s1">] = info</span>

    <span class="s2">if </span><span class="s3">'filter' </span><span class="s2">in </span><span class="s1">requested_items:</span>
        <span class="s1">info = {}</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">get_all_filters():</span>
            <span class="s1">cls = find_filter_class(name)</span>
            <span class="s1">info[name] = {</span>
                <span class="s3">'doc'</span><span class="s1">: docstring_headline(cls)</span>
            <span class="s1">}</span>
        <span class="s1">result[</span><span class="s3">'filters'</span><span class="s1">] = info</span>

    <span class="s2">if </span><span class="s3">'style' </span><span class="s2">in </span><span class="s1">requested_items:</span>
        <span class="s1">info = {}</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">get_all_styles():</span>
            <span class="s1">cls = get_style_by_name(name)</span>
            <span class="s1">info[name] = {</span>
                <span class="s3">'doc'</span><span class="s1">: docstring_headline(cls)</span>
            <span class="s1">}</span>
        <span class="s1">result[</span><span class="s3">'styles'</span><span class="s1">] = info</span>

    <span class="s1">json.dump(result</span><span class="s2">, </span><span class="s1">sys.stdout)</span>

<span class="s2">def </span><span class="s1">main_inner(parser</span><span class="s2">, </span><span class="s1">argns):</span>
    <span class="s2">if </span><span class="s1">argns.help:</span>
        <span class="s1">parser.print_help()</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s2">if </span><span class="s1">argns.V:</span>
        <span class="s1">print(</span><span class="s3">'Pygments version %s, (c) 2006-2021 by Georg Brandl, Matth√§us '</span>
              <span class="s3">'Chajdas and contributors.' </span><span class="s1">% __version__)</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s2">def </span><span class="s1">is_only_option(opt):</span>
        <span class="s2">return not </span><span class="s1">any(v </span><span class="s2">for </span><span class="s1">(k</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">in </span><span class="s1">vars(argns).items() </span><span class="s2">if </span><span class="s1">k != opt)</span>

    <span class="s5"># handle ``pygmentize -L``</span>
    <span class="s2">if </span><span class="s1">argns.L </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">arg_set = set()</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vars(argns).items():</span>
            <span class="s2">if </span><span class="s1">v:</span>
                <span class="s1">arg_set.add(k)</span>

        <span class="s1">arg_set.discard(</span><span class="s3">'L'</span><span class="s1">)</span>
        <span class="s1">arg_set.discard(</span><span class="s3">'json'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">arg_set:</span>
            <span class="s1">parser.print_help(sys.stderr)</span>
            <span class="s2">return </span><span class="s4">2</span>

        <span class="s5"># print version</span>
        <span class="s2">if not </span><span class="s1">argns.json:</span>
            <span class="s1">main([</span><span class="s3">''</span><span class="s2">, </span><span class="s3">'-V'</span><span class="s1">])</span>
        <span class="s1">allowed_types = {</span><span class="s3">'lexer'</span><span class="s2">, </span><span class="s3">'formatter'</span><span class="s2">, </span><span class="s3">'filter'</span><span class="s2">, </span><span class="s3">'style'</span><span class="s1">}</span>
        <span class="s1">largs = [arg.rstrip(</span><span class="s3">'s'</span><span class="s1">) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">argns.L]</span>
        <span class="s2">if </span><span class="s1">any(arg </span><span class="s2">not in </span><span class="s1">allowed_types </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">largs):</span>
            <span class="s1">parser.print_help(sys.stderr)</span>
            <span class="s2">return </span><span class="s4">0</span>
        <span class="s2">if not </span><span class="s1">largs:</span>
            <span class="s1">largs = allowed_types</span>
        <span class="s2">if not </span><span class="s1">argns.json:</span>
            <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">largs:</span>
                <span class="s1">_print_list(arg)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">_print_list_as_json(largs)</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s5"># handle ``pygmentize -H``</span>
    <span class="s2">if </span><span class="s1">argns.H:</span>
        <span class="s2">if not </span><span class="s1">is_only_option(</span><span class="s3">'H'</span><span class="s1">):</span>
            <span class="s1">parser.print_help(sys.stderr)</span>
            <span class="s2">return </span><span class="s4">2</span>
        <span class="s1">what</span><span class="s2">, </span><span class="s1">name = argns.H</span>
        <span class="s2">if </span><span class="s1">what </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">'lexer'</span><span class="s2">, </span><span class="s3">'formatter'</span><span class="s2">, </span><span class="s3">'filter'</span><span class="s1">):</span>
            <span class="s1">parser.print_help(sys.stderr)</span>
            <span class="s2">return </span><span class="s4">2</span>
        <span class="s2">return </span><span class="s1">_print_help(what</span><span class="s2">, </span><span class="s1">name)</span>

    <span class="s5"># parse -O options</span>
    <span class="s1">parsed_opts = _parse_options(argns.O </span><span class="s2">or </span><span class="s1">[])</span>

    <span class="s5"># parse -P options</span>
    <span class="s2">for </span><span class="s1">p_opt </span><span class="s2">in </span><span class="s1">argns.P </span><span class="s2">or </span><span class="s1">[]:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">value = p_opt.split(</span><span class="s3">'='</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s1">parsed_opts[p_opt] = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">parsed_opts[name] = value</span>

    <span class="s5"># encodings</span>
    <span class="s1">inencoding = parsed_opts.get(</span><span class="s3">'inencoding'</span><span class="s2">, </span><span class="s1">parsed_opts.get(</span><span class="s3">'encoding'</span><span class="s1">))</span>
    <span class="s1">outencoding = parsed_opts.get(</span><span class="s3">'outencoding'</span><span class="s2">, </span><span class="s1">parsed_opts.get(</span><span class="s3">'encoding'</span><span class="s1">))</span>

    <span class="s5"># handle ``pygmentize -N``</span>
    <span class="s2">if </span><span class="s1">argns.N:</span>
        <span class="s1">lexer = find_lexer_class_for_filename(argns.N)</span>
        <span class="s2">if </span><span class="s1">lexer </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">lexer = TextLexer</span>

        <span class="s1">print(lexer.aliases[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s5"># handle ``pygmentize -C``</span>
    <span class="s2">if </span><span class="s1">argns.C:</span>
        <span class="s1">inp = sys.stdin.buffer.read()</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">lexer = guess_lexer(inp</span><span class="s2">, </span><span class="s1">inencoding=inencoding)</span>
        <span class="s2">except </span><span class="s1">ClassNotFound:</span>
            <span class="s1">lexer = TextLexer</span>

        <span class="s1">print(lexer.aliases[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s5"># handle ``pygmentize -S``</span>
    <span class="s1">S_opt = argns.S</span>
    <span class="s1">a_opt = argns.a</span>
    <span class="s2">if </span><span class="s1">S_opt </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">f_opt = argns.f</span>
        <span class="s2">if not </span><span class="s1">f_opt:</span>
            <span class="s1">parser.print_help(sys.stderr)</span>
            <span class="s2">return </span><span class="s4">2</span>
        <span class="s2">if </span><span class="s1">argns.l </span><span class="s2">or </span><span class="s1">argns.INPUTFILE:</span>
            <span class="s1">parser.print_help(sys.stderr)</span>
            <span class="s2">return </span><span class="s4">2</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">parsed_opts[</span><span class="s3">'style'</span><span class="s1">] = S_opt</span>
            <span class="s1">fmter = get_formatter_by_name(f_opt</span><span class="s2">, </span><span class="s1">**parsed_opts)</span>
        <span class="s2">except </span><span class="s1">ClassNotFound </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s1">print(err</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>
            <span class="s2">return </span><span class="s4">1</span>

        <span class="s1">print(fmter.get_style_defs(a_opt </span><span class="s2">or </span><span class="s3">''</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s5"># if no -S is given, -a is not allowed</span>
    <span class="s2">if </span><span class="s1">argns.a </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">parser.print_help(sys.stderr)</span>
        <span class="s2">return </span><span class="s4">2</span>

    <span class="s5"># parse -F options</span>
    <span class="s1">F_opts = _parse_filters(argns.F </span><span class="s2">or </span><span class="s1">[])</span>

    <span class="s5"># -x: allow custom (eXternal) lexers and formatters</span>
    <span class="s1">allow_custom_lexer_formatter = bool(argns.x)</span>

    <span class="s5"># select lexer</span>
    <span class="s1">lexer = </span><span class="s2">None</span>

    <span class="s5"># given by name?</span>
    <span class="s1">lexername = argns.l</span>
    <span class="s2">if </span><span class="s1">lexername:</span>
        <span class="s5"># custom lexer, located relative to user's cwd</span>
        <span class="s2">if </span><span class="s1">allow_custom_lexer_formatter </span><span class="s2">and </span><span class="s3">'.py' </span><span class="s2">in </span><span class="s1">lexername:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">filename = </span><span class="s2">None</span>
                <span class="s1">name = </span><span class="s2">None</span>
                <span class="s2">if </span><span class="s3">':' </span><span class="s2">in </span><span class="s1">lexername:</span>
                    <span class="s1">filename</span><span class="s2">, </span><span class="s1">name = lexername.rsplit(</span><span class="s3">':'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

                    <span class="s2">if </span><span class="s3">'.py' </span><span class="s2">in </span><span class="s1">name:</span>
                        <span class="s5"># This can happen on Windows: If the lexername is</span>
                        <span class="s5"># C:\lexer.py -- return to normal load path in that case</span>
                        <span class="s1">name = </span><span class="s2">None</span>

                <span class="s2">if </span><span class="s1">filename </span><span class="s2">and </span><span class="s1">name:</span>
                    <span class="s1">lexer = load_lexer_from_file(filename</span><span class="s2">, </span><span class="s1">name</span><span class="s2">,</span>
                                                 <span class="s1">**parsed_opts)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">lexer = load_lexer_from_file(lexername</span><span class="s2">, </span><span class="s1">**parsed_opts)</span>
            <span class="s2">except </span><span class="s1">ClassNotFound </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s1">print(</span><span class="s3">'Error:'</span><span class="s2">, </span><span class="s1">err</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>
                <span class="s2">return </span><span class="s4">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">lexer = get_lexer_by_name(lexername</span><span class="s2">, </span><span class="s1">**parsed_opts)</span>
            <span class="s2">except </span><span class="s1">(OptionError</span><span class="s2">, </span><span class="s1">ClassNotFound) </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s1">print(</span><span class="s3">'Error:'</span><span class="s2">, </span><span class="s1">err</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>
                <span class="s2">return </span><span class="s4">1</span>

    <span class="s5"># read input code</span>
    <span class="s1">code = </span><span class="s2">None</span>

    <span class="s2">if </span><span class="s1">argns.INPUTFILE:</span>
        <span class="s2">if </span><span class="s1">argns.s:</span>
            <span class="s1">print(</span><span class="s3">'Error: -s option not usable when input file specified'</span><span class="s2">,</span>
                  <span class="s1">file=sys.stderr)</span>
            <span class="s2">return </span><span class="s4">2</span>

        <span class="s1">infn = argns.INPUTFILE</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">with </span><span class="s1">open(infn</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">infp:</span>
                <span class="s1">code = infp.read()</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s1">print(</span><span class="s3">'Error: cannot read infile:'</span><span class="s2">, </span><span class="s1">err</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>
            <span class="s2">return </span><span class="s4">1</span>
        <span class="s2">if not </span><span class="s1">inencoding:</span>
            <span class="s1">code</span><span class="s2">, </span><span class="s1">inencoding = guess_decode(code)</span>

        <span class="s5"># do we have to guess the lexer?</span>
        <span class="s2">if not </span><span class="s1">lexer:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">lexer = get_lexer_for_filename(infn</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">**parsed_opts)</span>
            <span class="s2">except </span><span class="s1">ClassNotFound </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s2">if </span><span class="s1">argns.g:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">lexer = guess_lexer(code</span><span class="s2">, </span><span class="s1">**parsed_opts)</span>
                    <span class="s2">except </span><span class="s1">ClassNotFound:</span>
                        <span class="s1">lexer = TextLexer(**parsed_opts)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">print(</span><span class="s3">'Error:'</span><span class="s2">, </span><span class="s1">err</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>
                    <span class="s2">return </span><span class="s4">1</span>
            <span class="s2">except </span><span class="s1">OptionError </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s1">print(</span><span class="s3">'Error:'</span><span class="s2">, </span><span class="s1">err</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>
                <span class="s2">return </span><span class="s4">1</span>

    <span class="s2">elif not </span><span class="s1">argns.s:  </span><span class="s5"># treat stdin as full file (-s support is later)</span>
        <span class="s5"># read code from terminal, always in binary mode since we want to</span>
        <span class="s5"># decode ourselves and be tolerant with it</span>
        <span class="s1">code = sys.stdin.buffer.read()  </span><span class="s5"># use .buffer to get a binary stream</span>
        <span class="s2">if not </span><span class="s1">inencoding:</span>
            <span class="s1">code</span><span class="s2">, </span><span class="s1">inencoding = guess_decode_from_terminal(code</span><span class="s2">, </span><span class="s1">sys.stdin)</span>
            <span class="s5"># else the lexer will do the decoding</span>
        <span class="s2">if not </span><span class="s1">lexer:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">lexer = guess_lexer(code</span><span class="s2">, </span><span class="s1">**parsed_opts)</span>
            <span class="s2">except </span><span class="s1">ClassNotFound:</span>
                <span class="s1">lexer = TextLexer(**parsed_opts)</span>

    <span class="s2">else</span><span class="s1">:  </span><span class="s5"># -s option needs a lexer with -l</span>
        <span class="s2">if not </span><span class="s1">lexer:</span>
            <span class="s1">print(</span><span class="s3">'Error: when using -s a lexer has to be selected with -l'</span><span class="s2">,</span>
                  <span class="s1">file=sys.stderr)</span>
            <span class="s2">return </span><span class="s4">2</span>

    <span class="s5"># process filters</span>
    <span class="s2">for </span><span class="s1">fname</span><span class="s2">, </span><span class="s1">fopts </span><span class="s2">in </span><span class="s1">F_opts:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">lexer.add_filter(fname</span><span class="s2">, </span><span class="s1">**fopts)</span>
        <span class="s2">except </span><span class="s1">ClassNotFound </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s1">print(</span><span class="s3">'Error:'</span><span class="s2">, </span><span class="s1">err</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>
            <span class="s2">return </span><span class="s4">1</span>

    <span class="s5"># select formatter</span>
    <span class="s1">outfn = argns.o</span>
    <span class="s1">fmter = argns.f</span>
    <span class="s2">if </span><span class="s1">fmter:</span>
        <span class="s5"># custom formatter, located relative to user's cwd</span>
        <span class="s2">if </span><span class="s1">allow_custom_lexer_formatter </span><span class="s2">and </span><span class="s3">'.py' </span><span class="s2">in </span><span class="s1">fmter:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">filename = </span><span class="s2">None</span>
                <span class="s1">name = </span><span class="s2">None</span>
                <span class="s2">if </span><span class="s3">':' </span><span class="s2">in </span><span class="s1">fmter:</span>
                    <span class="s5"># Same logic as above for custom lexer</span>
                    <span class="s1">filename</span><span class="s2">, </span><span class="s1">name = fmter.rsplit(</span><span class="s3">':'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

                    <span class="s2">if </span><span class="s3">'.py' </span><span class="s2">in </span><span class="s1">name:</span>
                        <span class="s1">name = </span><span class="s2">None</span>

                <span class="s2">if </span><span class="s1">filename </span><span class="s2">and </span><span class="s1">name:</span>
                    <span class="s1">fmter = load_formatter_from_file(filename</span><span class="s2">, </span><span class="s1">name</span><span class="s2">,</span>
                                                     <span class="s1">**parsed_opts)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">fmter = load_formatter_from_file(fmter</span><span class="s2">, </span><span class="s1">**parsed_opts)</span>
            <span class="s2">except </span><span class="s1">ClassNotFound </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s1">print(</span><span class="s3">'Error:'</span><span class="s2">, </span><span class="s1">err</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>
                <span class="s2">return </span><span class="s4">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">fmter = get_formatter_by_name(fmter</span><span class="s2">, </span><span class="s1">**parsed_opts)</span>
            <span class="s2">except </span><span class="s1">(OptionError</span><span class="s2">, </span><span class="s1">ClassNotFound) </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s1">print(</span><span class="s3">'Error:'</span><span class="s2">, </span><span class="s1">err</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>
                <span class="s2">return </span><span class="s4">1</span>

    <span class="s2">if </span><span class="s1">outfn:</span>
        <span class="s2">if not </span><span class="s1">fmter:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">fmter = get_formatter_for_filename(outfn</span><span class="s2">, </span><span class="s1">**parsed_opts)</span>
            <span class="s2">except </span><span class="s1">(OptionError</span><span class="s2">, </span><span class="s1">ClassNotFound) </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s1">print(</span><span class="s3">'Error:'</span><span class="s2">, </span><span class="s1">err</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>
                <span class="s2">return </span><span class="s4">1</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">outfile = open(outfn</span><span class="s2">, </span><span class="s3">'wb'</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s1">print(</span><span class="s3">'Error: cannot open outfile:'</span><span class="s2">, </span><span class="s1">err</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>
            <span class="s2">return </span><span class="s4">1</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">fmter:</span>
            <span class="s2">if </span><span class="s3">'256' </span><span class="s2">in </span><span class="s1">os.environ.get(</span><span class="s3">'TERM'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">):</span>
                <span class="s1">fmter = Terminal256Formatter(**parsed_opts)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">fmter = TerminalFormatter(**parsed_opts)</span>
        <span class="s1">outfile = sys.stdout.buffer</span>

    <span class="s5"># determine output encoding if not explicitly selected</span>
    <span class="s2">if not </span><span class="s1">outencoding:</span>
        <span class="s2">if </span><span class="s1">outfn:</span>
            <span class="s5"># output file? use lexer encoding for now (can still be None)</span>
            <span class="s1">fmter.encoding = inencoding</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># else use terminal encoding</span>
            <span class="s1">fmter.encoding = terminal_encoding(sys.stdout)</span>

    <span class="s5"># provide coloring under Windows, if possible</span>
    <span class="s2">if not </span><span class="s1">outfn </span><span class="s2">and </span><span class="s1">sys.platform </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'win32'</span><span class="s2">, </span><span class="s3">'cygwin'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">\</span>
       <span class="s1">fmter.name </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'Terminal'</span><span class="s2">, </span><span class="s3">'Terminal256'</span><span class="s1">):  </span><span class="s5"># pragma: no cover</span>
        <span class="s5"># unfortunately colorama doesn't support binary streams on Py3</span>
        <span class="s1">outfile = UnclosingTextIOWrapper(outfile</span><span class="s2">, </span><span class="s1">encoding=fmter.encoding)</span>
        <span class="s1">fmter.encoding = </span><span class="s2">None</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">import </span><span class="s1">pip._vendor.colorama.initialise </span><span class="s2">as </span><span class="s1">colorama_initialise</span>
        <span class="s2">except </span><span class="s1">ImportError:</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">outfile = colorama_initialise.wrap_stream(</span>
                <span class="s1">outfile</span><span class="s2">, </span><span class="s1">convert=</span><span class="s2">None, </span><span class="s1">strip=</span><span class="s2">None, </span><span class="s1">autoreset=</span><span class="s2">False, </span><span class="s1">wrap=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s5"># When using the LaTeX formatter and the option `escapeinside` is</span>
    <span class="s5"># specified, we need a special lexer which collects escaped text</span>
    <span class="s5"># before running the chosen language lexer.</span>
    <span class="s1">escapeinside = parsed_opts.get(</span><span class="s3">'escapeinside'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">len(escapeinside) == </span><span class="s4">2 </span><span class="s2">and </span><span class="s1">isinstance(fmter</span><span class="s2">, </span><span class="s1">LatexFormatter):</span>
        <span class="s1">left = escapeinside[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">right = escapeinside[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">lexer = LatexEmbeddedLexer(left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">lexer)</span>

    <span class="s5"># ... and do it!</span>
    <span class="s2">if not </span><span class="s1">argns.s:</span>
        <span class="s5"># process whole input as per normal...</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">highlight(code</span><span class="s2">, </span><span class="s1">lexer</span><span class="s2">, </span><span class="s1">fmter</span><span class="s2">, </span><span class="s1">outfile)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">outfn:</span>
                <span class="s1">outfile.close()</span>
        <span class="s2">return </span><span class="s4">0</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s5"># line by line processing of stdin (eg: for 'tail -f')...</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">while </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">line = sys.stdin.buffer.readline()</span>
                <span class="s2">if not </span><span class="s1">line:</span>
                    <span class="s2">break</span>
                <span class="s2">if not </span><span class="s1">inencoding:</span>
                    <span class="s1">line = guess_decode_from_terminal(line</span><span class="s2">, </span><span class="s1">sys.stdin)[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">highlight(line</span><span class="s2">, </span><span class="s1">lexer</span><span class="s2">, </span><span class="s1">fmter</span><span class="s2">, </span><span class="s1">outfile)</span>
                <span class="s2">if </span><span class="s1">hasattr(outfile</span><span class="s2">, </span><span class="s3">'flush'</span><span class="s1">):</span>
                    <span class="s1">outfile.flush()</span>
            <span class="s2">return </span><span class="s4">0</span>
        <span class="s2">except </span><span class="s1">KeyboardInterrupt:  </span><span class="s5"># pragma: no cover</span>
            <span class="s2">return </span><span class="s4">0</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">outfn:</span>
                <span class="s1">outfile.close()</span>


<span class="s2">class </span><span class="s1">HelpFormatter(argparse.HelpFormatter):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">prog</span><span class="s2">, </span><span class="s1">indent_increment=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">max_help_position=</span><span class="s4">16</span><span class="s2">, </span><span class="s1">width=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">width </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">width = shutil.get_terminal_size().columns - </span><span class="s4">2</span>
            <span class="s2">except </span><span class="s1">Exception:</span>
                <span class="s2">pass</span>
        <span class="s1">argparse.HelpFormatter.__init__(self</span><span class="s2">, </span><span class="s1">prog</span><span class="s2">, </span><span class="s1">indent_increment</span><span class="s2">,</span>
                                        <span class="s1">max_help_position</span><span class="s2">, </span><span class="s1">width)</span>


<span class="s2">def </span><span class="s1">main(args=sys.argv):</span>
    <span class="s0">&quot;&quot;&quot; 
    Main command line entry point. 
    &quot;&quot;&quot;</span>
    <span class="s1">desc = </span><span class="s3">&quot;Highlight an input file and write the result to an output file.&quot;</span>
    <span class="s1">parser = argparse.ArgumentParser(description=desc</span><span class="s2">, </span><span class="s1">add_help=</span><span class="s2">False,</span>
                                     <span class="s1">formatter_class=HelpFormatter)</span>

    <span class="s1">operation = parser.add_argument_group(</span><span class="s3">'Main operation'</span><span class="s1">)</span>
    <span class="s1">lexersel = operation.add_mutually_exclusive_group()</span>
    <span class="s1">lexersel.add_argument(</span>
        <span class="s3">'-l'</span><span class="s2">, </span><span class="s1">metavar=</span><span class="s3">'LEXER'</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">'Specify the lexer to use.  (Query names with -L.)  If not '</span>
        <span class="s3">'given and -g is not present, the lexer is guessed from the filename.'</span><span class="s1">)</span>
    <span class="s1">lexersel.add_argument(</span>
        <span class="s3">'-g'</span><span class="s2">, </span><span class="s1">action=</span><span class="s3">'store_true'</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">'Guess the lexer from the file contents, or pass through '</span>
        <span class="s3">'as plain text if nothing can be guessed.'</span><span class="s1">)</span>
    <span class="s1">operation.add_argument(</span>
        <span class="s3">'-F'</span><span class="s2">, </span><span class="s1">metavar=</span><span class="s3">'FILTER[:options]'</span><span class="s2">, </span><span class="s1">action=</span><span class="s3">'append'</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">'Add a filter to the token stream.  (Query names with -L.) '</span>
        <span class="s3">'Filter options are given after a colon if necessary.'</span><span class="s1">)</span>
    <span class="s1">operation.add_argument(</span>
        <span class="s3">'-f'</span><span class="s2">, </span><span class="s1">metavar=</span><span class="s3">'FORMATTER'</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">'Specify the formatter to use.  (Query names with -L.) '</span>
        <span class="s3">'If not given, the formatter is guessed from the output filename, '</span>
        <span class="s3">'and defaults to the terminal formatter if the output is to the '</span>
        <span class="s3">'terminal or an unknown file extension.'</span><span class="s1">)</span>
    <span class="s1">operation.add_argument(</span>
        <span class="s3">'-O'</span><span class="s2">, </span><span class="s1">metavar=</span><span class="s3">'OPTION=value[,OPTION=value,...]'</span><span class="s2">, </span><span class="s1">action=</span><span class="s3">'append'</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">'Give options to the lexer and formatter as a comma-separated '</span>
        <span class="s3">'list of key-value pairs. '</span>
        <span class="s3">'Example: `-O bg=light,python=cool`.'</span><span class="s1">)</span>
    <span class="s1">operation.add_argument(</span>
        <span class="s3">'-P'</span><span class="s2">, </span><span class="s1">metavar=</span><span class="s3">'OPTION=value'</span><span class="s2">, </span><span class="s1">action=</span><span class="s3">'append'</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">'Give a single option to the lexer and formatter - with this '</span>
        <span class="s3">'you can pass options whose value contains commas and equal signs. '</span>
        <span class="s3">'Example: `-P &quot;heading=Pygments, the Python highlighter&quot;`.'</span><span class="s1">)</span>
    <span class="s1">operation.add_argument(</span>
        <span class="s3">'-o'</span><span class="s2">, </span><span class="s1">metavar=</span><span class="s3">'OUTPUTFILE'</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">'Where to write the output.  Defaults to standard output.'</span><span class="s1">)</span>

    <span class="s1">operation.add_argument(</span>
        <span class="s3">'INPUTFILE'</span><span class="s2">, </span><span class="s1">nargs=</span><span class="s3">'?'</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">'Where to read the input.  Defaults to standard input.'</span><span class="s1">)</span>

    <span class="s1">flags = parser.add_argument_group(</span><span class="s3">'Operation flags'</span><span class="s1">)</span>
    <span class="s1">flags.add_argument(</span>
        <span class="s3">'-v'</span><span class="s2">, </span><span class="s1">action=</span><span class="s3">'store_true'</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">'Print a detailed traceback on unhandled exceptions, which '</span>
        <span class="s3">'is useful for debugging and bug reports.'</span><span class="s1">)</span>
    <span class="s1">flags.add_argument(</span>
        <span class="s3">'-s'</span><span class="s2">, </span><span class="s1">action=</span><span class="s3">'store_true'</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">'Process lines one at a time until EOF, rather than waiting to '</span>
        <span class="s3">'process the entire file.  This only works for stdin, only for lexers '</span>
        <span class="s3">'with no line-spanning constructs, and is intended for streaming '</span>
        <span class="s3">'input such as you get from `tail -f`. '</span>
        <span class="s3">'Example usage: `tail -f sql.log | pygmentize -s -l sql`.'</span><span class="s1">)</span>
    <span class="s1">flags.add_argument(</span>
        <span class="s3">'-x'</span><span class="s2">, </span><span class="s1">action=</span><span class="s3">'store_true'</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">'Allow custom lexers and formatters to be loaded from a .py file '</span>
        <span class="s3">'relative to the current working directory. For example, '</span>
        <span class="s3">'`-l ./customlexer.py -x`. By default, this option expects a file '</span>
        <span class="s3">'with a class named CustomLexer or CustomFormatter; you can also '</span>
        <span class="s3">'specify your own class name with a colon (`-l ./lexer.py:MyLexer`). '</span>
        <span class="s3">'Users should be very careful not to use this option with untrusted '</span>
        <span class="s3">'files, because it will import and run them.'</span><span class="s1">)</span>
    <span class="s1">flags.add_argument(</span><span class="s3">'--json'</span><span class="s2">, </span><span class="s1">help=</span><span class="s3">'Output as JSON. This can '</span>
        <span class="s3">'be only used in conjunction with -L.'</span><span class="s2">,</span>
        <span class="s1">default=</span><span class="s2">False,</span>
        <span class="s1">action=</span><span class="s3">'store_true'</span><span class="s1">)</span>

    <span class="s1">special_modes_group = parser.add_argument_group(</span>
        <span class="s3">'Special modes - do not do any highlighting'</span><span class="s1">)</span>
    <span class="s1">special_modes = special_modes_group.add_mutually_exclusive_group()</span>
    <span class="s1">special_modes.add_argument(</span>
        <span class="s3">'-S'</span><span class="s2">, </span><span class="s1">metavar=</span><span class="s3">'STYLE -f formatter'</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">'Print style definitions for STYLE for a formatter '</span>
        <span class="s3">'given with -f. The argument given by -a is formatter '</span>
        <span class="s3">'dependent.'</span><span class="s1">)</span>
    <span class="s1">special_modes.add_argument(</span>
        <span class="s3">'-L'</span><span class="s2">, </span><span class="s1">nargs=</span><span class="s3">'*'</span><span class="s2">, </span><span class="s1">metavar=</span><span class="s3">'WHAT'</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">'List lexers, formatters, styles or filters -- '</span>
        <span class="s3">'give additional arguments for the thing(s) you want to list '</span>
        <span class="s3">'(e.g. &quot;styles&quot;), or omit them to list everything.'</span><span class="s1">)</span>
    <span class="s1">special_modes.add_argument(</span>
        <span class="s3">'-N'</span><span class="s2">, </span><span class="s1">metavar=</span><span class="s3">'FILENAME'</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">'Guess and print out a lexer name based solely on the given '</span>
        <span class="s3">'filename. Does not take input or highlight anything. If no specific '</span>
        <span class="s3">'lexer can be determined, &quot;text&quot; is printed.'</span><span class="s1">)</span>
    <span class="s1">special_modes.add_argument(</span>
        <span class="s3">'-C'</span><span class="s2">, </span><span class="s1">action=</span><span class="s3">'store_true'</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">'Like -N, but print out a lexer name based solely on '</span>
        <span class="s3">'a given content from standard input.'</span><span class="s1">)</span>
    <span class="s1">special_modes.add_argument(</span>
        <span class="s3">'-H'</span><span class="s2">, </span><span class="s1">action=</span><span class="s3">'store'</span><span class="s2">, </span><span class="s1">nargs=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">metavar=(</span><span class="s3">'NAME'</span><span class="s2">, </span><span class="s3">'TYPE'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">'Print detailed help for the object &lt;name&gt; of type &lt;type&gt;, '</span>
        <span class="s3">'where &lt;type&gt; is one of &quot;lexer&quot;, &quot;formatter&quot; or &quot;filter&quot;.'</span><span class="s1">)</span>
    <span class="s1">special_modes.add_argument(</span>
        <span class="s3">'-V'</span><span class="s2">, </span><span class="s1">action=</span><span class="s3">'store_true'</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">'Print the package version.'</span><span class="s1">)</span>
    <span class="s1">special_modes.add_argument(</span>
        <span class="s3">'-h'</span><span class="s2">, </span><span class="s3">'--help'</span><span class="s2">, </span><span class="s1">action=</span><span class="s3">'store_true'</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">'Print this help.'</span><span class="s1">)</span>
    <span class="s1">special_modes_group.add_argument(</span>
        <span class="s3">'-a'</span><span class="s2">, </span><span class="s1">metavar=</span><span class="s3">'ARG'</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">'Formatter-specific additional argument for the -S (print '</span>
        <span class="s3">'style sheet) mode.'</span><span class="s1">)</span>

    <span class="s1">argns = parser.parse_args(args[</span><span class="s4">1</span><span class="s1">:])</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">main_inner(parser</span><span class="s2">, </span><span class="s1">argns)</span>
    <span class="s2">except </span><span class="s1">Exception:</span>
        <span class="s2">if </span><span class="s1">argns.v:</span>
            <span class="s1">print(file=sys.stderr)</span>
            <span class="s1">print(</span><span class="s3">'*' </span><span class="s1">* </span><span class="s4">65</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>
            <span class="s1">print(</span><span class="s3">'An unhandled exception occurred while highlighting.'</span><span class="s2">,</span>
                  <span class="s1">file=sys.stderr)</span>
            <span class="s1">print(</span><span class="s3">'Please report the whole traceback to the issue tracker at'</span><span class="s2">,</span>
                  <span class="s1">file=sys.stderr)</span>
            <span class="s1">print(</span><span class="s3">'&lt;https://github.com/pygments/pygments/issues&gt;.'</span><span class="s2">,</span>
                  <span class="s1">file=sys.stderr)</span>
            <span class="s1">print(</span><span class="s3">'*' </span><span class="s1">* </span><span class="s4">65</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>
            <span class="s1">print(file=sys.stderr)</span>
            <span class="s2">raise</span>
        <span class="s2">import </span><span class="s1">traceback</span>
        <span class="s1">info = traceback.format_exception(*sys.exc_info())</span>
        <span class="s1">msg = info[-</span><span class="s4">1</span><span class="s1">].strip()</span>
        <span class="s2">if </span><span class="s1">len(info) &gt;= </span><span class="s4">3</span><span class="s1">:</span>
            <span class="s5"># extract relevant file and position info</span>
            <span class="s1">msg += </span><span class="s3">'</span><span class="s2">\n   </span><span class="s3">(f%s)' </span><span class="s1">% info[-</span><span class="s4">2</span><span class="s1">].split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">].strip()[</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s1">print(file=sys.stderr)</span>
        <span class="s1">print(</span><span class="s3">'*** Error while highlighting:'</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>
        <span class="s1">print(msg</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>
        <span class="s1">print(</span><span class="s3">'*** If this is a bug you want to report, please rerun with -v.'</span><span class="s2">,</span>
              <span class="s1">file=sys.stderr)</span>
        <span class="s2">return </span><span class="s4">1</span>
</pre>
</body>
</html>