<html>
<head>
<title>_pyxlsb.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_pyxlsb.py</font>
</center></td></tr></table>
<pre><span class="s0"># pyright: reportMissingImports=false</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">pandas._typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">FilePath</span><span class="s2">,</span>
    <span class="s1">ReadBuffer</span><span class="s2">,</span>
    <span class="s1">Scalar</span><span class="s2">,</span>
    <span class="s1">StorageOptions</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.compat._optional </span><span class="s2">import </span><span class="s1">import_optional_dependency</span>

<span class="s2">from </span><span class="s1">pandas.io.excel._base </span><span class="s2">import </span><span class="s1">BaseExcelReader</span>


<span class="s2">class </span><span class="s1">PyxlsbReader(BaseExcelReader):</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">filepath_or_buffer: FilePath | ReadBuffer[bytes]</span><span class="s2">,</span>
        <span class="s1">storage_options: StorageOptions = </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Reader using pyxlsb engine. 
 
        Parameters 
        ---------- 
        filepath_or_buffer : str, path object, or Workbook 
            Object to be parsed. 
        storage_options : dict, optional 
            passed to fsspec for appropriate URLs (see ``_get_filepath_or_buffer``) 
        &quot;&quot;&quot;</span>
        <span class="s1">import_optional_dependency(</span><span class="s4">&quot;pyxlsb&quot;</span><span class="s1">)</span>
        <span class="s0"># This will call load_workbook on the filepath or buffer</span>
        <span class="s0"># And set the result to the book-attribute</span>
        <span class="s1">super().__init__(filepath_or_buffer</span><span class="s2">, </span><span class="s1">storage_options=storage_options)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_workbook_class(self):</span>
        <span class="s2">from </span><span class="s1">pyxlsb </span><span class="s2">import </span><span class="s1">Workbook</span>

        <span class="s2">return </span><span class="s1">Workbook</span>

    <span class="s2">def </span><span class="s1">load_workbook(self</span><span class="s2">, </span><span class="s1">filepath_or_buffer: FilePath | ReadBuffer[bytes]):</span>
        <span class="s2">from </span><span class="s1">pyxlsb </span><span class="s2">import </span><span class="s1">open_workbook</span>

        <span class="s0"># TODO: hack in buffer capability</span>
        <span class="s0"># This might need some modifications to the Pyxlsb library</span>
        <span class="s0"># Actual work for opening it is in xlsbpackage.py, line 20-ish</span>

        <span class="s2">return </span><span class="s1">open_workbook(filepath_or_buffer)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">sheet_names(self) -&gt; list[str]:</span>
        <span class="s2">return </span><span class="s1">self.book.sheets</span>

    <span class="s2">def </span><span class="s1">get_sheet_by_name(self</span><span class="s2">, </span><span class="s1">name: str):</span>
        <span class="s1">self.raise_if_bad_sheet_by_name(name)</span>
        <span class="s2">return </span><span class="s1">self.book.get_sheet(name)</span>

    <span class="s2">def </span><span class="s1">get_sheet_by_index(self</span><span class="s2">, </span><span class="s1">index: int):</span>
        <span class="s1">self.raise_if_bad_sheet_by_index(index)</span>
        <span class="s0"># pyxlsb sheets are indexed from 1 onwards</span>
        <span class="s0"># There's a fix for this in the source, but the pypi package doesn't have it</span>
        <span class="s2">return </span><span class="s1">self.book.get_sheet(index + </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_convert_cell(self</span><span class="s2">, </span><span class="s1">cell</span><span class="s2">, </span><span class="s1">convert_float: bool) -&gt; Scalar:</span>
        <span class="s0"># TODO: there is no way to distinguish between floats and datetimes in pyxlsb</span>
        <span class="s0"># This means that there is no way to read datetime types from an xlsb file yet</span>
        <span class="s2">if </span><span class="s1">cell.v </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">&quot;&quot;  </span><span class="s0"># Prevents non-named columns from not showing up as Unnamed: i</span>
        <span class="s2">if </span><span class="s1">isinstance(cell.v</span><span class="s2">, </span><span class="s1">float) </span><span class="s2">and </span><span class="s1">convert_float:</span>
            <span class="s1">val = int(cell.v)</span>
            <span class="s2">if </span><span class="s1">val == cell.v:</span>
                <span class="s2">return </span><span class="s1">val</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">float(cell.v)</span>

        <span class="s2">return </span><span class="s1">cell.v</span>

    <span class="s2">def </span><span class="s1">get_sheet_data(self</span><span class="s2">, </span><span class="s1">sheet</span><span class="s2">, </span><span class="s1">convert_float: bool) -&gt; list[list[Scalar]]:</span>
        <span class="s1">data: list[list[Scalar]] = []</span>
        <span class="s1">prevous_row_number = -</span><span class="s5">1</span>
        <span class="s0"># When sparse=True the rows can have different lengths and empty rows are</span>
        <span class="s0"># not returned. The cells are namedtuples of row, col, value (r, c, v).</span>
        <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">sheet.rows(sparse=</span><span class="s2">True</span><span class="s1">):</span>
            <span class="s1">row_number = row[</span><span class="s5">0</span><span class="s1">].r</span>
            <span class="s1">converted_row = [self._convert_cell(cell</span><span class="s2">, </span><span class="s1">convert_float) </span><span class="s2">for </span><span class="s1">cell </span><span class="s2">in </span><span class="s1">row]</span>
            <span class="s2">while </span><span class="s1">converted_row </span><span class="s2">and </span><span class="s1">converted_row[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s4">&quot;&quot;</span><span class="s1">:</span>
                <span class="s0"># trim trailing empty elements</span>
                <span class="s1">converted_row.pop()</span>
            <span class="s2">if </span><span class="s1">converted_row:</span>
                <span class="s1">data.extend([[]] * (row_number - prevous_row_number - </span><span class="s5">1</span><span class="s1">))</span>
                <span class="s1">data.append(converted_row)</span>
                <span class="s1">prevous_row_number = row_number</span>
        <span class="s2">if </span><span class="s1">data:</span>
            <span class="s0"># extend rows to max_width</span>
            <span class="s1">max_width = max(len(data_row) </span><span class="s2">for </span><span class="s1">data_row </span><span class="s2">in </span><span class="s1">data)</span>
            <span class="s2">if </span><span class="s1">min(len(data_row) </span><span class="s2">for </span><span class="s1">data_row </span><span class="s2">in </span><span class="s1">data) &lt; max_width:</span>
                <span class="s1">empty_cell: list[Scalar] = [</span><span class="s4">&quot;&quot;</span><span class="s1">]</span>
                <span class="s1">data = [</span>
                    <span class="s1">data_row + (max_width - len(data_row)) * empty_cell</span>
                    <span class="s2">for </span><span class="s1">data_row </span><span class="s2">in </span><span class="s1">data</span>
                <span class="s1">]</span>
        <span class="s2">return </span><span class="s1">data</span>
</pre>
</body>
</html>