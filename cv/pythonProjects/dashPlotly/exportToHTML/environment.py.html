<html>
<head>
<title>environment.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
environment.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Classes for managing templates and their runtime and compile time 
options. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">typing</span>
<span class="s2">import </span><span class="s1">typing </span><span class="s2">as </span><span class="s1">t</span>
<span class="s2">import </span><span class="s1">weakref</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">ChainMap</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">lru_cache</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">reduce</span>
<span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">CodeType</span>

<span class="s2">from </span><span class="s1">markupsafe </span><span class="s2">import </span><span class="s1">Markup</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">nodes</span>
<span class="s2">from </span><span class="s1">.compiler </span><span class="s2">import </span><span class="s1">CodeGenerator</span>
<span class="s2">from </span><span class="s1">.compiler </span><span class="s2">import </span><span class="s1">generate</span>
<span class="s2">from </span><span class="s1">.defaults </span><span class="s2">import </span><span class="s1">BLOCK_END_STRING</span>
<span class="s2">from </span><span class="s1">.defaults </span><span class="s2">import </span><span class="s1">BLOCK_START_STRING</span>
<span class="s2">from </span><span class="s1">.defaults </span><span class="s2">import </span><span class="s1">COMMENT_END_STRING</span>
<span class="s2">from </span><span class="s1">.defaults </span><span class="s2">import </span><span class="s1">COMMENT_START_STRING</span>
<span class="s2">from </span><span class="s1">.defaults </span><span class="s2">import </span><span class="s1">DEFAULT_FILTERS</span>
<span class="s2">from </span><span class="s1">.defaults </span><span class="s2">import </span><span class="s1">DEFAULT_NAMESPACE</span>
<span class="s2">from </span><span class="s1">.defaults </span><span class="s2">import </span><span class="s1">DEFAULT_POLICIES</span>
<span class="s2">from </span><span class="s1">.defaults </span><span class="s2">import </span><span class="s1">DEFAULT_TESTS</span>
<span class="s2">from </span><span class="s1">.defaults </span><span class="s2">import </span><span class="s1">KEEP_TRAILING_NEWLINE</span>
<span class="s2">from </span><span class="s1">.defaults </span><span class="s2">import </span><span class="s1">LINE_COMMENT_PREFIX</span>
<span class="s2">from </span><span class="s1">.defaults </span><span class="s2">import </span><span class="s1">LINE_STATEMENT_PREFIX</span>
<span class="s2">from </span><span class="s1">.defaults </span><span class="s2">import </span><span class="s1">LSTRIP_BLOCKS</span>
<span class="s2">from </span><span class="s1">.defaults </span><span class="s2">import </span><span class="s1">NEWLINE_SEQUENCE</span>
<span class="s2">from </span><span class="s1">.defaults </span><span class="s2">import </span><span class="s1">TRIM_BLOCKS</span>
<span class="s2">from </span><span class="s1">.defaults </span><span class="s2">import </span><span class="s1">VARIABLE_END_STRING</span>
<span class="s2">from </span><span class="s1">.defaults </span><span class="s2">import </span><span class="s1">VARIABLE_START_STRING</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">TemplateNotFound</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">TemplateRuntimeError</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">TemplatesNotFound</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">TemplateSyntaxError</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">UndefinedError</span>
<span class="s2">from </span><span class="s1">.lexer </span><span class="s2">import </span><span class="s1">get_lexer</span>
<span class="s2">from </span><span class="s1">.lexer </span><span class="s2">import </span><span class="s1">Lexer</span>
<span class="s2">from </span><span class="s1">.lexer </span><span class="s2">import </span><span class="s1">TokenStream</span>
<span class="s2">from </span><span class="s1">.nodes </span><span class="s2">import </span><span class="s1">EvalContext</span>
<span class="s2">from </span><span class="s1">.parser </span><span class="s2">import </span><span class="s1">Parser</span>
<span class="s2">from </span><span class="s1">.runtime </span><span class="s2">import </span><span class="s1">Context</span>
<span class="s2">from </span><span class="s1">.runtime </span><span class="s2">import </span><span class="s1">new_context</span>
<span class="s2">from </span><span class="s1">.runtime </span><span class="s2">import </span><span class="s1">Undefined</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">_PassArg</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">concat</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">consume</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">import_string</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">internalcode</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">LRUCache</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">missing</span>

<span class="s2">if </span><span class="s1">t.TYPE_CHECKING:</span>
    <span class="s2">import </span><span class="s1">typing_extensions </span><span class="s2">as </span><span class="s1">te</span>
    <span class="s2">from </span><span class="s1">.bccache </span><span class="s2">import </span><span class="s1">BytecodeCache</span>
    <span class="s2">from </span><span class="s1">.ext </span><span class="s2">import </span><span class="s1">Extension</span>
    <span class="s2">from </span><span class="s1">.loaders </span><span class="s2">import </span><span class="s1">BaseLoader</span>

<span class="s1">_env_bound = t.TypeVar(</span><span class="s3">&quot;_env_bound&quot;</span><span class="s2">, </span><span class="s1">bound=</span><span class="s3">&quot;Environment&quot;</span><span class="s1">)</span>


<span class="s4"># for direct template usage we have up to ten living environments</span>
<span class="s1">@lru_cache(maxsize=</span><span class="s5">10</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">get_spontaneous_environment(cls: t.Type[_env_bound]</span><span class="s2">, </span><span class="s1">*args: t.Any) -&gt; _env_bound:</span>
    <span class="s0">&quot;&quot;&quot;Return a new spontaneous environment. A spontaneous environment 
    is used for templates created directly rather than through an 
    existing environment. 
 
    :param cls: Environment class to create. 
    :param args: Positional arguments passed to environment. 
    &quot;&quot;&quot;</span>
    <span class="s1">env = cls(*args)</span>
    <span class="s1">env.shared = </span><span class="s2">True</span>
    <span class="s2">return </span><span class="s1">env</span>


<span class="s2">def </span><span class="s1">create_cache(</span>
    <span class="s1">size: int</span><span class="s2">,</span>
<span class="s1">) -&gt; t.Optional[t.MutableMapping[t.Tuple[weakref.ref</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s3">&quot;Template&quot;</span><span class="s1">]]:</span>
    <span class="s0">&quot;&quot;&quot;Return the cache class for the given size.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">size == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">return None</span>

    <span class="s2">if </span><span class="s1">size &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">{}</span>

    <span class="s2">return </span><span class="s1">LRUCache(size)  </span><span class="s4"># type: ignore</span>


<span class="s2">def </span><span class="s1">copy_cache(</span>
    <span class="s1">cache: t.Optional[t.MutableMapping]</span><span class="s2">,</span>
<span class="s1">) -&gt; t.Optional[t.MutableMapping[t.Tuple[weakref.ref</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s3">&quot;Template&quot;</span><span class="s1">]]:</span>
    <span class="s0">&quot;&quot;&quot;Create an empty copy of the given cache.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">cache </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return None</span>

    <span class="s2">if </span><span class="s1">type(cache) </span><span class="s2">is </span><span class="s1">dict:</span>
        <span class="s2">return </span><span class="s1">{}</span>

    <span class="s2">return </span><span class="s1">LRUCache(cache.capacity)  </span><span class="s4"># type: ignore</span>


<span class="s2">def </span><span class="s1">load_extensions(</span>
    <span class="s1">environment: </span><span class="s3">&quot;Environment&quot;</span><span class="s2">,</span>
    <span class="s1">extensions: t.Sequence[t.Union[str</span><span class="s2">, </span><span class="s1">t.Type[</span><span class="s3">&quot;Extension&quot;</span><span class="s1">]]]</span><span class="s2">,</span>
<span class="s1">) -&gt; t.Dict[str</span><span class="s2">, </span><span class="s3">&quot;Extension&quot;</span><span class="s1">]:</span>
    <span class="s0">&quot;&quot;&quot;Load the extensions from the list and bind it to the environment. 
    Returns a dict of instantiated extensions. 
    &quot;&quot;&quot;</span>
    <span class="s1">result = {}</span>

    <span class="s2">for </span><span class="s1">extension </span><span class="s2">in </span><span class="s1">extensions:</span>
        <span class="s2">if </span><span class="s1">isinstance(extension</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">extension = t.cast(t.Type[</span><span class="s3">&quot;Extension&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">import_string(extension))</span>

        <span class="s1">result[extension.identifier] = extension(environment)</span>

    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">_environment_config_check(environment: </span><span class="s3">&quot;Environment&quot;</span><span class="s1">) -&gt; </span><span class="s3">&quot;Environment&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Perform a sanity check on the environment.&quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">issubclass(</span>
        <span class="s1">environment.undefined</span><span class="s2">, </span><span class="s1">Undefined</span>
    <span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;'undefined' must be a subclass of 'jinja2.Undefined'.&quot;</span>
    <span class="s2">assert </span><span class="s1">(</span>
        <span class="s1">environment.block_start_string</span>
        <span class="s1">!= environment.variable_start_string</span>
        <span class="s1">!= environment.comment_start_string</span>
    <span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;block, variable and comment start strings must be different.&quot;</span>
    <span class="s2">assert </span><span class="s1">environment.newline_sequence </span><span class="s2">in </span><span class="s1">{</span>
        <span class="s3">&quot;</span><span class="s2">\r</span><span class="s3">&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;</span><span class="s2">\r\n</span><span class="s3">&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">,</span>
    <span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;'newline_sequence' must be one of '</span><span class="s2">\\</span><span class="s3">n', '</span><span class="s2">\\</span><span class="s3">r</span><span class="s2">\\</span><span class="s3">n', or '</span><span class="s2">\\</span><span class="s3">r'.&quot;</span>
    <span class="s2">return </span><span class="s1">environment</span>


<span class="s2">class </span><span class="s1">Environment:</span>
    <span class="s0">r&quot;&quot;&quot;The core component of Jinja is the `Environment`.  It contains 
    important shared variables like configuration, filters, tests, 
    globals and others.  Instances of this class may be modified if 
    they are not shared and if no template was loaded so far. 
    Modifications on environments after the first template was loaded 
    will lead to surprising effects and undefined behavior. 
 
    Here are the possible initialization parameters: 
 
        `block_start_string` 
            The string marking the beginning of a block.  Defaults to ``'{%'``. 
 
        `block_end_string` 
            The string marking the end of a block.  Defaults to ``'%}'``. 
 
        `variable_start_string` 
            The string marking the beginning of a print statement. 
            Defaults to ``'{{'``. 
 
        `variable_end_string` 
            The string marking the end of a print statement.  Defaults to 
            ``'}}'``. 
 
        `comment_start_string` 
            The string marking the beginning of a comment.  Defaults to ``'{#'``. 
 
        `comment_end_string` 
            The string marking the end of a comment.  Defaults to ``'#}'``. 
 
        `line_statement_prefix` 
            If given and a string, this will be used as prefix for line based 
            statements.  See also :ref:`line-statements`. 
 
        `line_comment_prefix` 
            If given and a string, this will be used as prefix for line based 
            comments.  See also :ref:`line-statements`. 
 
            .. versionadded:: 2.2 
 
        `trim_blocks` 
            If this is set to ``True`` the first newline after a block is 
            removed (block, not variable tag!).  Defaults to `False`. 
 
        `lstrip_blocks` 
            If this is set to ``True`` leading spaces and tabs are stripped 
            from the start of a line to a block.  Defaults to `False`. 
 
        `newline_sequence` 
            The sequence that starts a newline.  Must be one of ``'\r'``, 
            ``'\n'`` or ``'\r\n'``.  The default is ``'\n'`` which is a 
            useful default for Linux and OS X systems as well as web 
            applications. 
 
        `keep_trailing_newline` 
            Preserve the trailing newline when rendering templates. 
            The default is ``False``, which causes a single newline, 
            if present, to be stripped from the end of the template. 
 
            .. versionadded:: 2.7 
 
        `extensions` 
            List of Jinja extensions to use.  This can either be import paths 
            as strings or extension classes.  For more information have a 
            look at :ref:`the extensions documentation &lt;jinja-extensions&gt;`. 
 
        `optimized` 
            should the optimizer be enabled?  Default is ``True``. 
 
        `undefined` 
            :class:`Undefined` or a subclass of it that is used to represent 
            undefined values in the template. 
 
        `finalize` 
            A callable that can be used to process the result of a variable 
            expression before it is output.  For example one can convert 
            ``None`` implicitly into an empty string here. 
 
        `autoescape` 
            If set to ``True`` the XML/HTML autoescaping feature is enabled by 
            default.  For more details about autoescaping see 
            :class:`~markupsafe.Markup`.  As of Jinja 2.4 this can also 
            be a callable that is passed the template name and has to 
            return ``True`` or ``False`` depending on autoescape should be 
            enabled by default. 
 
            .. versionchanged:: 2.4 
               `autoescape` can now be a function 
 
        `loader` 
            The template loader for this environment. 
 
        `cache_size` 
            The size of the cache.  Per default this is ``400`` which means 
            that if more than 400 templates are loaded the loader will clean 
            out the least recently used template.  If the cache size is set to 
            ``0`` templates are recompiled all the time, if the cache size is 
            ``-1`` the cache will not be cleaned. 
 
            .. versionchanged:: 2.8 
               The cache size was increased to 400 from a low 50. 
 
        `auto_reload` 
            Some loaders load templates from locations where the template 
            sources may change (ie: file system or database).  If 
            ``auto_reload`` is set to ``True`` (default) every time a template is 
            requested the loader checks if the source changed and if yes, it 
            will reload the template.  For higher performance it's possible to 
            disable that. 
 
        `bytecode_cache` 
            If set to a bytecode cache object, this object will provide a 
            cache for the internal Jinja bytecode so that templates don't 
            have to be parsed if they were not changed. 
 
            See :ref:`bytecode-cache` for more information. 
 
        `enable_async` 
            If set to true this enables async template execution which 
            allows using async functions and generators. 
    &quot;&quot;&quot;</span>

    <span class="s4">#: if this environment is sandboxed.  Modifying this variable won't make</span>
    <span class="s4">#: the environment sandboxed though.  For a real sandboxed environment</span>
    <span class="s4">#: have a look at jinja2.sandbox.  This flag alone controls the code</span>
    <span class="s4">#: generation by the compiler.</span>
    <span class="s1">sandboxed = </span><span class="s2">False</span>

    <span class="s4">#: True if the environment is just an overlay</span>
    <span class="s1">overlayed = </span><span class="s2">False</span>

    <span class="s4">#: the environment this environment is linked to if it is an overlay</span>
    <span class="s1">linked_to: t.Optional[</span><span class="s3">&quot;Environment&quot;</span><span class="s1">] = </span><span class="s2">None</span>

    <span class="s4">#: shared environments have this set to `True`.  A shared environment</span>
    <span class="s4">#: must not be modified</span>
    <span class="s1">shared = </span><span class="s2">False</span>

    <span class="s4">#: the class that is used for code generation.  See</span>
    <span class="s4">#: :class:`~jinja2.compiler.CodeGenerator` for more information.</span>
    <span class="s1">code_generator_class: t.Type[</span><span class="s3">&quot;CodeGenerator&quot;</span><span class="s1">] = CodeGenerator</span>

    <span class="s4">#: the context class that is used for templates.  See</span>
    <span class="s4">#: :class:`~jinja2.runtime.Context` for more information.</span>
    <span class="s1">context_class: t.Type[Context] = Context</span>

    <span class="s1">template_class: t.Type[</span><span class="s3">&quot;Template&quot;</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">block_start_string: str = BLOCK_START_STRING</span><span class="s2">,</span>
        <span class="s1">block_end_string: str = BLOCK_END_STRING</span><span class="s2">,</span>
        <span class="s1">variable_start_string: str = VARIABLE_START_STRING</span><span class="s2">,</span>
        <span class="s1">variable_end_string: str = VARIABLE_END_STRING</span><span class="s2">,</span>
        <span class="s1">comment_start_string: str = COMMENT_START_STRING</span><span class="s2">,</span>
        <span class="s1">comment_end_string: str = COMMENT_END_STRING</span><span class="s2">,</span>
        <span class="s1">line_statement_prefix: t.Optional[str] = LINE_STATEMENT_PREFIX</span><span class="s2">,</span>
        <span class="s1">line_comment_prefix: t.Optional[str] = LINE_COMMENT_PREFIX</span><span class="s2">,</span>
        <span class="s1">trim_blocks: bool = TRIM_BLOCKS</span><span class="s2">,</span>
        <span class="s1">lstrip_blocks: bool = LSTRIP_BLOCKS</span><span class="s2">,</span>
        <span class="s1">newline_sequence: </span><span class="s3">&quot;te.Literal['</span><span class="s2">\\</span><span class="s3">n', '</span><span class="s2">\\</span><span class="s3">r</span><span class="s2">\\</span><span class="s3">n', '</span><span class="s2">\\</span><span class="s3">r']&quot; </span><span class="s1">= NEWLINE_SEQUENCE</span><span class="s2">,</span>
        <span class="s1">keep_trailing_newline: bool = KEEP_TRAILING_NEWLINE</span><span class="s2">,</span>
        <span class="s1">extensions: t.Sequence[t.Union[str</span><span class="s2">, </span><span class="s1">t.Type[</span><span class="s3">&quot;Extension&quot;</span><span class="s1">]]] = ()</span><span class="s2">,</span>
        <span class="s1">optimized: bool = </span><span class="s2">True,</span>
        <span class="s1">undefined: t.Type[Undefined] = Undefined</span><span class="s2">,</span>
        <span class="s1">finalize: t.Optional[t.Callable[...</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
        <span class="s1">autoescape: t.Union[bool</span><span class="s2">, </span><span class="s1">t.Callable[[t.Optional[str]]</span><span class="s2">, </span><span class="s1">bool]] = </span><span class="s2">False,</span>
        <span class="s1">loader: t.Optional[</span><span class="s3">&quot;BaseLoader&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
        <span class="s1">cache_size: int = </span><span class="s5">400</span><span class="s2">,</span>
        <span class="s1">auto_reload: bool = </span><span class="s2">True,</span>
        <span class="s1">bytecode_cache: t.Optional[</span><span class="s3">&quot;BytecodeCache&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
        <span class="s1">enable_async: bool = </span><span class="s2">False,</span>
    <span class="s1">):</span>
        <span class="s4"># !!Important notice!!</span>
        <span class="s4">#   The constructor accepts quite a few arguments that should be</span>
        <span class="s4">#   passed by keyword rather than position.  However it's important to</span>
        <span class="s4">#   not change the order of arguments because it's used at least</span>
        <span class="s4">#   internally in those cases:</span>
        <span class="s4">#       -   spontaneous environments (i18n extension and Template)</span>
        <span class="s4">#       -   unittests</span>
        <span class="s4">#   If parameter changes are required only add parameters at the end</span>
        <span class="s4">#   and don't change the arguments (or the defaults!) of the arguments</span>
        <span class="s4">#   existing already.</span>

        <span class="s4"># lexer / parser information</span>
        <span class="s1">self.block_start_string = block_start_string</span>
        <span class="s1">self.block_end_string = block_end_string</span>
        <span class="s1">self.variable_start_string = variable_start_string</span>
        <span class="s1">self.variable_end_string = variable_end_string</span>
        <span class="s1">self.comment_start_string = comment_start_string</span>
        <span class="s1">self.comment_end_string = comment_end_string</span>
        <span class="s1">self.line_statement_prefix = line_statement_prefix</span>
        <span class="s1">self.line_comment_prefix = line_comment_prefix</span>
        <span class="s1">self.trim_blocks = trim_blocks</span>
        <span class="s1">self.lstrip_blocks = lstrip_blocks</span>
        <span class="s1">self.newline_sequence = newline_sequence</span>
        <span class="s1">self.keep_trailing_newline = keep_trailing_newline</span>

        <span class="s4"># runtime information</span>
        <span class="s1">self.undefined: t.Type[Undefined] = undefined</span>
        <span class="s1">self.optimized = optimized</span>
        <span class="s1">self.finalize = finalize</span>
        <span class="s1">self.autoescape = autoescape</span>

        <span class="s4"># defaults</span>
        <span class="s1">self.filters = DEFAULT_FILTERS.copy()</span>
        <span class="s1">self.tests = DEFAULT_TESTS.copy()</span>
        <span class="s1">self.globals = DEFAULT_NAMESPACE.copy()</span>

        <span class="s4"># set the loader provided</span>
        <span class="s1">self.loader = loader</span>
        <span class="s1">self.cache = create_cache(cache_size)</span>
        <span class="s1">self.bytecode_cache = bytecode_cache</span>
        <span class="s1">self.auto_reload = auto_reload</span>

        <span class="s4"># configurable policies</span>
        <span class="s1">self.policies = DEFAULT_POLICIES.copy()</span>

        <span class="s4"># load extensions</span>
        <span class="s1">self.extensions = load_extensions(self</span><span class="s2">, </span><span class="s1">extensions)</span>

        <span class="s1">self.is_async = enable_async</span>
        <span class="s1">_environment_config_check(self)</span>

    <span class="s2">def </span><span class="s1">add_extension(self</span><span class="s2">, </span><span class="s1">extension: t.Union[str</span><span class="s2">, </span><span class="s1">t.Type[</span><span class="s3">&quot;Extension&quot;</span><span class="s1">]]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Adds an extension after the environment was created. 
 
        .. versionadded:: 2.5 
        &quot;&quot;&quot;</span>
        <span class="s1">self.extensions.update(load_extensions(self</span><span class="s2">, </span><span class="s1">[extension]))</span>

    <span class="s2">def </span><span class="s1">extend(self</span><span class="s2">, </span><span class="s1">**attributes: t.Any) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Add the items to the instance of the environment if they do not exist 
        yet.  This is used by :ref:`extensions &lt;writing-extensions&gt;` to register 
        callbacks and configuration values without breaking inheritance. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">attributes.items():</span>
            <span class="s2">if not </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s1">key):</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value)</span>

    <span class="s2">def </span><span class="s1">overlay(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">block_start_string: str = missing</span><span class="s2">,</span>
        <span class="s1">block_end_string: str = missing</span><span class="s2">,</span>
        <span class="s1">variable_start_string: str = missing</span><span class="s2">,</span>
        <span class="s1">variable_end_string: str = missing</span><span class="s2">,</span>
        <span class="s1">comment_start_string: str = missing</span><span class="s2">,</span>
        <span class="s1">comment_end_string: str = missing</span><span class="s2">,</span>
        <span class="s1">line_statement_prefix: t.Optional[str] = missing</span><span class="s2">,</span>
        <span class="s1">line_comment_prefix: t.Optional[str] = missing</span><span class="s2">,</span>
        <span class="s1">trim_blocks: bool = missing</span><span class="s2">,</span>
        <span class="s1">lstrip_blocks: bool = missing</span><span class="s2">,</span>
        <span class="s1">extensions: t.Sequence[t.Union[str</span><span class="s2">, </span><span class="s1">t.Type[</span><span class="s3">&quot;Extension&quot;</span><span class="s1">]]] = missing</span><span class="s2">,</span>
        <span class="s1">optimized: bool = missing</span><span class="s2">,</span>
        <span class="s1">undefined: t.Type[Undefined] = missing</span><span class="s2">,</span>
        <span class="s1">finalize: t.Optional[t.Callable[...</span><span class="s2">, </span><span class="s1">t.Any]] = missing</span><span class="s2">,</span>
        <span class="s1">autoescape: t.Union[bool</span><span class="s2">, </span><span class="s1">t.Callable[[t.Optional[str]]</span><span class="s2">, </span><span class="s1">bool]] = missing</span><span class="s2">,</span>
        <span class="s1">loader: t.Optional[</span><span class="s3">&quot;BaseLoader&quot;</span><span class="s1">] = missing</span><span class="s2">,</span>
        <span class="s1">cache_size: int = missing</span><span class="s2">,</span>
        <span class="s1">auto_reload: bool = missing</span><span class="s2">,</span>
        <span class="s1">bytecode_cache: t.Optional[</span><span class="s3">&quot;BytecodeCache&quot;</span><span class="s1">] = missing</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Environment&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Create a new overlay environment that shares all the data with the 
        current environment except for cache and the overridden attributes. 
        Extensions cannot be removed for an overlayed environment.  An overlayed 
        environment automatically gets all the extensions of the environment it 
        is linked to plus optional extra extensions. 
 
        Creating overlays should happen after the initial environment was set 
        up completely.  Not all attributes are truly linked, some are just 
        copied over so modifications on the original environment may not shine 
        through. 
        &quot;&quot;&quot;</span>
        <span class="s1">args = dict(locals())</span>
        <span class="s2">del </span><span class="s1">args[</span><span class="s3">&quot;self&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">args[</span><span class="s3">&quot;cache_size&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">args[</span><span class="s3">&quot;extensions&quot;</span><span class="s1">]</span>

        <span class="s1">rv = object.__new__(self.__class__)</span>
        <span class="s1">rv.__dict__.update(self.__dict__)</span>
        <span class="s1">rv.overlayed = </span><span class="s2">True</span>
        <span class="s1">rv.linked_to = self</span>

        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">args.items():</span>
            <span class="s2">if </span><span class="s1">value </span><span class="s2">is not </span><span class="s1">missing:</span>
                <span class="s1">setattr(rv</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value)</span>

        <span class="s2">if </span><span class="s1">cache_size </span><span class="s2">is not </span><span class="s1">missing:</span>
            <span class="s1">rv.cache = create_cache(cache_size)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rv.cache = copy_cache(self.cache)</span>

        <span class="s1">rv.extensions = {}</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">self.extensions.items():</span>
            <span class="s1">rv.extensions[key] = value.bind(rv)</span>
        <span class="s2">if </span><span class="s1">extensions </span><span class="s2">is not </span><span class="s1">missing:</span>
            <span class="s1">rv.extensions.update(load_extensions(rv</span><span class="s2">, </span><span class="s1">extensions))</span>

        <span class="s2">return </span><span class="s1">_environment_config_check(rv)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">lexer(self) -&gt; Lexer:</span>
        <span class="s0">&quot;&quot;&quot;The lexer for this environment.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">get_lexer(self)</span>

    <span class="s2">def </span><span class="s1">iter_extensions(self) -&gt; t.Iterator[</span><span class="s3">&quot;Extension&quot;</span><span class="s1">]:</span>
        <span class="s0">&quot;&quot;&quot;Iterates over the extensions by priority.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">iter(sorted(self.extensions.values()</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">x: x.priority))</span>

    <span class="s2">def </span><span class="s1">getitem(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">obj: t.Any</span><span class="s2">, </span><span class="s1">argument: t.Union[str</span><span class="s2">, </span><span class="s1">t.Any]</span>
    <span class="s1">) -&gt; t.Union[t.Any</span><span class="s2">, </span><span class="s1">Undefined]:</span>
        <span class="s0">&quot;&quot;&quot;Get an item or attribute of an object but prefer the item.&quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">obj[argument]</span>
        <span class="s2">except </span><span class="s1">(AttributeError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">LookupError):</span>
            <span class="s2">if </span><span class="s1">isinstance(argument</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">attr = str(argument)</span>
                <span class="s2">except </span><span class="s1">Exception:</span>
                    <span class="s2">pass</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s2">return </span><span class="s1">getattr(obj</span><span class="s2">, </span><span class="s1">attr)</span>
                    <span class="s2">except </span><span class="s1">AttributeError:</span>
                        <span class="s2">pass</span>
            <span class="s2">return </span><span class="s1">self.undefined(obj=obj</span><span class="s2">, </span><span class="s1">name=argument)</span>

    <span class="s2">def </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">obj: t.Any</span><span class="s2">, </span><span class="s1">attribute: str) -&gt; t.Any:</span>
        <span class="s0">&quot;&quot;&quot;Get an item or attribute of an object but prefer the attribute. 
        Unlike :meth:`getitem` the attribute *must* be a string. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">getattr(obj</span><span class="s2">, </span><span class="s1">attribute)</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">pass</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">obj[attribute]</span>
        <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">LookupError</span><span class="s2">, </span><span class="s1">AttributeError):</span>
            <span class="s2">return </span><span class="s1">self.undefined(obj=obj</span><span class="s2">, </span><span class="s1">name=attribute)</span>

    <span class="s2">def </span><span class="s1">_filter_test_common(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">name: t.Union[str</span><span class="s2">, </span><span class="s1">Undefined]</span><span class="s2">,</span>
        <span class="s1">value: t.Any</span><span class="s2">,</span>
        <span class="s1">args: t.Optional[t.Sequence[t.Any]]</span><span class="s2">,</span>
        <span class="s1">kwargs: t.Optional[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]]</span><span class="s2">,</span>
        <span class="s1">context: t.Optional[Context]</span><span class="s2">,</span>
        <span class="s1">eval_ctx: t.Optional[EvalContext]</span><span class="s2">,</span>
        <span class="s1">is_filter: bool</span><span class="s2">,</span>
    <span class="s1">) -&gt; t.Any:</span>
        <span class="s2">if </span><span class="s1">is_filter:</span>
            <span class="s1">env_map = self.filters</span>
            <span class="s1">type_name = </span><span class="s3">&quot;filter&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">env_map = self.tests</span>
            <span class="s1">type_name = </span><span class="s3">&quot;test&quot;</span>

        <span class="s1">func = env_map.get(name)  </span><span class="s4"># type: ignore</span>

        <span class="s2">if </span><span class="s1">func </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">f&quot;No </span><span class="s2">{</span><span class="s1">type_name</span><span class="s2">} </span><span class="s3">named </span><span class="s2">{</span><span class="s1">name</span><span class="s2">!r}</span><span class="s3">.&quot;</span>

            <span class="s2">if </span><span class="s1">isinstance(name</span><span class="s2">, </span><span class="s1">Undefined):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">name._fail_with_undefined_error()</span>
                <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
                    <span class="s1">msg = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">msg</span><span class="s2">} </span><span class="s3">(</span><span class="s2">{</span><span class="s1">e</span><span class="s2">}</span><span class="s3">; did you forget to quote the callable name?)&quot;</span>

            <span class="s2">raise </span><span class="s1">TemplateRuntimeError(msg)</span>

        <span class="s1">args = [value</span><span class="s2">, </span><span class="s1">*(args </span><span class="s2">if </span><span class="s1">args </span><span class="s2">is not None else </span><span class="s1">())]</span>
        <span class="s1">kwargs = kwargs </span><span class="s2">if </span><span class="s1">kwargs </span><span class="s2">is not None else </span><span class="s1">{}</span>
        <span class="s1">pass_arg = _PassArg.from_obj(func)</span>

        <span class="s2">if </span><span class="s1">pass_arg </span><span class="s2">is </span><span class="s1">_PassArg.context:</span>
            <span class="s2">if </span><span class="s1">context </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TemplateRuntimeError(</span>
                    <span class="s3">f&quot;Attempted to invoke a context </span><span class="s2">{</span><span class="s1">type_name</span><span class="s2">} </span><span class="s3">without context.&quot;</span>
                <span class="s1">)</span>

            <span class="s1">args.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">context)</span>
        <span class="s2">elif </span><span class="s1">pass_arg </span><span class="s2">is </span><span class="s1">_PassArg.eval_context:</span>
            <span class="s2">if </span><span class="s1">eval_ctx </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">context </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">eval_ctx = context.eval_ctx</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">eval_ctx = EvalContext(self)</span>

            <span class="s1">args.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">eval_ctx)</span>
        <span class="s2">elif </span><span class="s1">pass_arg </span><span class="s2">is </span><span class="s1">_PassArg.environment:</span>
            <span class="s1">args.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">self)</span>

        <span class="s2">return </span><span class="s1">func(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">call_filter(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">name: str</span><span class="s2">,</span>
        <span class="s1">value: t.Any</span><span class="s2">,</span>
        <span class="s1">args: t.Optional[t.Sequence[t.Any]] = </span><span class="s2">None,</span>
        <span class="s1">kwargs: t.Optional[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
        <span class="s1">context: t.Optional[Context] = </span><span class="s2">None,</span>
        <span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; t.Any:</span>
        <span class="s0">&quot;&quot;&quot;Invoke a filter on a value the same way the compiler does. 
 
        This might return a coroutine if the filter is running from an 
        environment in async mode and the filter supports async 
        execution. It's your responsibility to await this if needed. 
 
        .. versionadded:: 2.7 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._filter_test_common(</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">eval_ctx</span><span class="s2">, True</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">call_test(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">name: str</span><span class="s2">,</span>
        <span class="s1">value: t.Any</span><span class="s2">,</span>
        <span class="s1">args: t.Optional[t.Sequence[t.Any]] = </span><span class="s2">None,</span>
        <span class="s1">kwargs: t.Optional[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
        <span class="s1">context: t.Optional[Context] = </span><span class="s2">None,</span>
        <span class="s1">eval_ctx: t.Optional[EvalContext] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; t.Any:</span>
        <span class="s0">&quot;&quot;&quot;Invoke a test on a value the same way the compiler does. 
 
        This might return a coroutine if the test is running from an 
        environment in async mode and the test supports async execution. 
        It's your responsibility to await this if needed. 
 
        .. versionchanged:: 3.0 
            Tests support ``@pass_context``, etc. decorators. Added 
            the ``context`` and ``eval_ctx`` parameters. 
 
        .. versionadded:: 2.7 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._filter_test_common(</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">eval_ctx</span><span class="s2">, False</span>
        <span class="s1">)</span>

    <span class="s1">@internalcode</span>
    <span class="s2">def </span><span class="s1">parse(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">source: str</span><span class="s2">,</span>
        <span class="s1">name: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">filename: t.Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; nodes.Template:</span>
        <span class="s0">&quot;&quot;&quot;Parse the sourcecode and return the abstract syntax tree.  This 
        tree of nodes is used by the compiler to convert the template into 
        executable source- or bytecode.  This is useful for debugging or to 
        extract information from templates. 
 
        If you are :ref:`developing Jinja extensions &lt;writing-extensions&gt;` 
        this gives you a good overview of the node tree generated. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._parse(source</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">filename)</span>
        <span class="s2">except </span><span class="s1">TemplateSyntaxError:</span>
            <span class="s1">self.handle_exception(source=source)</span>

    <span class="s2">def </span><span class="s1">_parse(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">source: str</span><span class="s2">, </span><span class="s1">name: t.Optional[str]</span><span class="s2">, </span><span class="s1">filename: t.Optional[str]</span>
    <span class="s1">) -&gt; nodes.Template:</span>
        <span class="s0">&quot;&quot;&quot;Internal parsing function used by `parse` and `compile`.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">Parser(self</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">filename).parse()</span>

    <span class="s2">def </span><span class="s1">lex(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">source: str</span><span class="s2">,</span>
        <span class="s1">name: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">filename: t.Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; t.Iterator[t.Tuple[int</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s0">&quot;&quot;&quot;Lex the given sourcecode and return a generator that yields 
        tokens as tuples in the form ``(lineno, token_type, value)``. 
        This can be useful for :ref:`extension development &lt;writing-extensions&gt;` 
        and debugging templates. 
 
        This does not perform preprocessing.  If you want the preprocessing 
        of the extensions to be applied you have to filter source through 
        the :meth:`preprocess` method. 
        &quot;&quot;&quot;</span>
        <span class="s1">source = str(source)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.lexer.tokeniter(source</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">filename)</span>
        <span class="s2">except </span><span class="s1">TemplateSyntaxError:</span>
            <span class="s1">self.handle_exception(source=source)</span>

    <span class="s2">def </span><span class="s1">preprocess(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">source: str</span><span class="s2">,</span>
        <span class="s1">name: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">filename: t.Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Preprocesses the source with all extensions.  This is automatically 
        called for all parsing and compiling methods but *not* for :meth:`lex` 
        because there you usually only want the actual source tokenized. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">reduce(</span>
            <span class="s2">lambda </span><span class="s1">s</span><span class="s2">, </span><span class="s1">e: e.preprocess(s</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">filename)</span><span class="s2">,</span>
            <span class="s1">self.iter_extensions()</span><span class="s2">,</span>
            <span class="s1">str(source)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_tokenize(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">source: str</span><span class="s2">,</span>
        <span class="s1">name: t.Optional[str]</span><span class="s2">,</span>
        <span class="s1">filename: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">state: t.Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; TokenStream:</span>
        <span class="s0">&quot;&quot;&quot;Called by the parser to do the preprocessing and filtering 
        for all the extensions.  Returns a :class:`~jinja2.lexer.TokenStream`. 
        &quot;&quot;&quot;</span>
        <span class="s1">source = self.preprocess(source</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">filename)</span>
        <span class="s1">stream = self.lexer.tokenize(source</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">state)</span>

        <span class="s2">for </span><span class="s1">ext </span><span class="s2">in </span><span class="s1">self.iter_extensions():</span>
            <span class="s1">stream = ext.filter_stream(stream)  </span><span class="s4"># type: ignore</span>

            <span class="s2">if not </span><span class="s1">isinstance(stream</span><span class="s2">, </span><span class="s1">TokenStream):</span>
                <span class="s1">stream = TokenStream(stream</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">filename)  </span><span class="s4"># type: ignore</span>

        <span class="s2">return </span><span class="s1">stream</span>

    <span class="s2">def </span><span class="s1">_generate(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">source: nodes.Template</span><span class="s2">,</span>
        <span class="s1">name: t.Optional[str]</span><span class="s2">,</span>
        <span class="s1">filename: t.Optional[str]</span><span class="s2">,</span>
        <span class="s1">defer_init: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Internal hook that can be overridden to hook a different generate 
        method in. 
 
        .. versionadded:: 2.5 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">generate(  </span><span class="s4"># type: ignore</span>
            <span class="s1">source</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">,</span>
            <span class="s1">filename</span><span class="s2">,</span>
            <span class="s1">defer_init=defer_init</span><span class="s2">,</span>
            <span class="s1">optimized=self.optimized</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_compile(self</span><span class="s2">, </span><span class="s1">source: str</span><span class="s2">, </span><span class="s1">filename: str) -&gt; CodeType:</span>
        <span class="s0">&quot;&quot;&quot;Internal hook that can be overridden to hook a different compile 
        method in. 
 
        .. versionadded:: 2.5 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">compile(source</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s3">&quot;exec&quot;</span><span class="s1">)  </span><span class="s4"># type: ignore</span>

    <span class="s1">@typing.overload</span>
    <span class="s2">def </span><span class="s1">compile(  </span><span class="s4"># type: ignore</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">source: t.Union[str</span><span class="s2">, </span><span class="s1">nodes.Template]</span><span class="s2">,</span>
        <span class="s1">name: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">filename: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">raw: </span><span class="s3">&quot;te.Literal[False]&quot; </span><span class="s1">= </span><span class="s2">False,</span>
        <span class="s1">defer_init: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; CodeType:</span>
        <span class="s1">...</span>

    <span class="s1">@typing.overload</span>
    <span class="s2">def </span><span class="s1">compile(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">source: t.Union[str</span><span class="s2">, </span><span class="s1">nodes.Template]</span><span class="s2">,</span>
        <span class="s1">name: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">filename: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">raw: </span><span class="s3">&quot;te.Literal[True]&quot; </span><span class="s1">= ...</span><span class="s2">,</span>
        <span class="s1">defer_init: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s1">...</span>

    <span class="s1">@internalcode</span>
    <span class="s2">def </span><span class="s1">compile(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">source: t.Union[str</span><span class="s2">, </span><span class="s1">nodes.Template]</span><span class="s2">,</span>
        <span class="s1">name: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">filename: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">raw: bool = </span><span class="s2">False,</span>
        <span class="s1">defer_init: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; t.Union[str</span><span class="s2">, </span><span class="s1">CodeType]:</span>
        <span class="s0">&quot;&quot;&quot;Compile a node or template source code.  The `name` parameter is 
        the load name of the template after it was joined using 
        :meth:`join_path` if necessary, not the filename on the file system. 
        the `filename` parameter is the estimated filename of the template on 
        the file system.  If the template came from a database or memory this 
        can be omitted. 
 
        The return value of this method is a python code object.  If the `raw` 
        parameter is `True` the return value will be a string with python 
        code equivalent to the bytecode returned otherwise.  This method is 
        mainly used internally. 
 
        `defer_init` is use internally to aid the module code generator.  This 
        causes the generated code to be able to import without the global 
        environment variable to be set. 
 
        .. versionadded:: 2.4 
           `defer_init` parameter added. 
        &quot;&quot;&quot;</span>
        <span class="s1">source_hint = </span><span class="s2">None</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(source</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">source_hint = source</span>
                <span class="s1">source = self._parse(source</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">filename)</span>
            <span class="s1">source = self._generate(source</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">defer_init=defer_init)</span>
            <span class="s2">if </span><span class="s1">raw:</span>
                <span class="s2">return </span><span class="s1">source</span>
            <span class="s2">if </span><span class="s1">filename </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">filename = </span><span class="s3">&quot;&lt;template&gt;&quot;</span>
            <span class="s2">return </span><span class="s1">self._compile(source</span><span class="s2">, </span><span class="s1">filename)</span>
        <span class="s2">except </span><span class="s1">TemplateSyntaxError:</span>
            <span class="s1">self.handle_exception(source=source_hint)</span>

    <span class="s2">def </span><span class="s1">compile_expression(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">source: str</span><span class="s2">, </span><span class="s1">undefined_to_none: bool = </span><span class="s2">True</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;TemplateExpression&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;A handy helper method that returns a callable that accepts keyword 
        arguments that appear as variables in the expression.  If called it 
        returns the result of the expression. 
 
        This is useful if applications want to use the same rules as Jinja 
        in template &quot;configuration files&quot; or similar situations. 
 
        Example usage: 
 
        &gt;&gt;&gt; env = Environment() 
        &gt;&gt;&gt; expr = env.compile_expression('foo == 42') 
        &gt;&gt;&gt; expr(foo=23) 
        False 
        &gt;&gt;&gt; expr(foo=42) 
        True 
 
        Per default the return value is converted to `None` if the 
        expression returns an undefined value.  This can be changed 
        by setting `undefined_to_none` to `False`. 
 
        &gt;&gt;&gt; env.compile_expression('var')() is None 
        True 
        &gt;&gt;&gt; env.compile_expression('var', undefined_to_none=False)() 
        Undefined 
 
        .. versionadded:: 2.1 
        &quot;&quot;&quot;</span>
        <span class="s1">parser = Parser(self</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">state=</span><span class="s3">&quot;variable&quot;</span><span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">expr = parser.parse_expression()</span>
            <span class="s2">if not </span><span class="s1">parser.stream.eos:</span>
                <span class="s2">raise </span><span class="s1">TemplateSyntaxError(</span>
                    <span class="s3">&quot;chunk after expression&quot;</span><span class="s2">, </span><span class="s1">parser.stream.current.lineno</span><span class="s2">, None, None</span>
                <span class="s1">)</span>
            <span class="s1">expr.set_environment(self)</span>
        <span class="s2">except </span><span class="s1">TemplateSyntaxError:</span>
            <span class="s1">self.handle_exception(source=source)</span>

        <span class="s1">body = [nodes.Assign(nodes.Name(</span><span class="s3">&quot;result&quot;</span><span class="s2">, </span><span class="s3">&quot;store&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">, </span><span class="s1">lineno=</span><span class="s5">1</span><span class="s1">)]</span>
        <span class="s1">template = self.from_string(nodes.Template(body</span><span class="s2">, </span><span class="s1">lineno=</span><span class="s5">1</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">TemplateExpression(template</span><span class="s2">, </span><span class="s1">undefined_to_none)</span>

    <span class="s2">def </span><span class="s1">compile_templates(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">target: t.Union[str</span><span class="s2">, </span><span class="s1">os.PathLike]</span><span class="s2">,</span>
        <span class="s1">extensions: t.Optional[t.Collection[str]] = </span><span class="s2">None,</span>
        <span class="s1">filter_func: t.Optional[t.Callable[[str]</span><span class="s2">, </span><span class="s1">bool]] = </span><span class="s2">None,</span>
        <span class="s1">zip: t.Optional[str] = </span><span class="s3">&quot;deflated&quot;</span><span class="s2">,</span>
        <span class="s1">log_function: t.Optional[t.Callable[[str]</span><span class="s2">, None</span><span class="s1">]] = </span><span class="s2">None,</span>
        <span class="s1">ignore_errors: bool = </span><span class="s2">True,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Finds all the templates the loader can find, compiles them 
        and stores them in `target`.  If `zip` is `None`, instead of in a 
        zipfile, the templates will be stored in a directory. 
        By default a deflate zip algorithm is used. To switch to 
        the stored algorithm, `zip` can be set to ``'stored'``. 
 
        `extensions` and `filter_func` are passed to :meth:`list_templates`. 
        Each template returned will be compiled to the target folder or 
        zipfile. 
 
        By default template compilation errors are ignored.  In case a 
        log function is provided, errors are logged.  If you want template 
        syntax errors to abort the compilation you can set `ignore_errors` 
        to `False` and you will get an exception on syntax errors. 
 
        .. versionadded:: 2.4 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">.loaders </span><span class="s2">import </span><span class="s1">ModuleLoader</span>

        <span class="s2">if </span><span class="s1">log_function </span><span class="s2">is None</span><span class="s1">:</span>

            <span class="s2">def </span><span class="s1">log_function(x: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
                <span class="s2">pass</span>

        <span class="s2">assert </span><span class="s1">log_function </span><span class="s2">is not None</span>
        <span class="s2">assert </span><span class="s1">self.loader </span><span class="s2">is not None, </span><span class="s3">&quot;No loader configured.&quot;</span>

        <span class="s2">def </span><span class="s1">write_file(filename: str</span><span class="s2">, </span><span class="s1">data: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">zip:</span>
                <span class="s1">info = ZipInfo(filename)</span>
                <span class="s1">info.external_attr = </span><span class="s5">0o755 </span><span class="s1">&lt;&lt; </span><span class="s5">16</span>
                <span class="s1">zip_file.writestr(info</span><span class="s2">, </span><span class="s1">data)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">with </span><span class="s1">open(os.path.join(target</span><span class="s2">, </span><span class="s1">filename)</span><span class="s2">, </span><span class="s3">&quot;wb&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
                    <span class="s1">f.write(data.encode(</span><span class="s3">&quot;utf8&quot;</span><span class="s1">))</span>

        <span class="s2">if </span><span class="s1">zip </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">zipfile </span><span class="s2">import </span><span class="s1">ZipFile</span><span class="s2">, </span><span class="s1">ZipInfo</span><span class="s2">, </span><span class="s1">ZIP_DEFLATED</span><span class="s2">, </span><span class="s1">ZIP_STORED</span>

            <span class="s1">zip_file = ZipFile(</span>
                <span class="s1">target</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s2">, </span><span class="s1">dict(deflated=ZIP_DEFLATED</span><span class="s2">, </span><span class="s1">stored=ZIP_STORED)[zip]</span>
            <span class="s1">)</span>
            <span class="s1">log_function(</span><span class="s3">f&quot;Compiling into Zip archive </span><span class="s2">{</span><span class="s1">target</span><span class="s2">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">os.path.isdir(target):</span>
                <span class="s1">os.makedirs(target)</span>
            <span class="s1">log_function(</span><span class="s3">f&quot;Compiling into folder </span><span class="s2">{</span><span class="s1">target</span><span class="s2">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.list_templates(extensions</span><span class="s2">, </span><span class="s1">filter_func):</span>
                <span class="s1">source</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">_ = self.loader.get_source(self</span><span class="s2">, </span><span class="s1">name)</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">code = self.compile(source</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, True, True</span><span class="s1">)</span>
                <span class="s2">except </span><span class="s1">TemplateSyntaxError </span><span class="s2">as </span><span class="s1">e:</span>
                    <span class="s2">if not </span><span class="s1">ignore_errors:</span>
                        <span class="s2">raise</span>
                    <span class="s1">log_function(</span><span class="s3">f'Could not compile &quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">&quot;: </span><span class="s2">{</span><span class="s1">e</span><span class="s2">}</span><span class="s3">'</span><span class="s1">)</span>
                    <span class="s2">continue</span>

                <span class="s1">filename = ModuleLoader.get_module_filename(name)</span>

                <span class="s1">write_file(filename</span><span class="s2">, </span><span class="s1">code)</span>
                <span class="s1">log_function(</span><span class="s3">f'Compiled &quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">&quot; as </span><span class="s2">{</span><span class="s1">filename</span><span class="s2">}</span><span class="s3">'</span><span class="s1">)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">zip:</span>
                <span class="s1">zip_file.close()</span>

        <span class="s1">log_function(</span><span class="s3">&quot;Finished compiling templates&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">list_templates(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">extensions: t.Optional[t.Collection[str]] = </span><span class="s2">None,</span>
        <span class="s1">filter_func: t.Optional[t.Callable[[str]</span><span class="s2">, </span><span class="s1">bool]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; t.List[str]:</span>
        <span class="s0">&quot;&quot;&quot;Returns a list of templates for this environment.  This requires 
        that the loader supports the loader's 
        :meth:`~BaseLoader.list_templates` method. 
 
        If there are other files in the template folder besides the 
        actual templates, the returned list can be filtered.  There are two 
        ways: either `extensions` is set to a list of file extensions for 
        templates, or a `filter_func` can be provided which is a callable that 
        is passed a template name and should return `True` if it should end up 
        in the result list. 
 
        If the loader does not support that, a :exc:`TypeError` is raised. 
 
        .. versionadded:: 2.4 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">self.loader </span><span class="s2">is not None, </span><span class="s3">&quot;No loader configured.&quot;</span>
        <span class="s1">names = self.loader.list_templates()</span>

        <span class="s2">if </span><span class="s1">extensions </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">filter_func </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">&quot;either extensions or filter_func can be passed, but not both&quot;</span>
                <span class="s1">)</span>

            <span class="s2">def </span><span class="s1">filter_func(x: str) -&gt; bool:</span>
                <span class="s2">return </span><span class="s3">&quot;.&quot; </span><span class="s2">in </span><span class="s1">x </span><span class="s2">and </span><span class="s1">x.rsplit(</span><span class="s3">&quot;.&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">1</span><span class="s1">] </span><span class="s2">in </span><span class="s1">extensions  </span><span class="s4"># type: ignore</span>

        <span class="s2">if </span><span class="s1">filter_func </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">names = [name </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names </span><span class="s2">if </span><span class="s1">filter_func(name)]</span>

        <span class="s2">return </span><span class="s1">names</span>

    <span class="s2">def </span><span class="s1">handle_exception(self</span><span class="s2">, </span><span class="s1">source: t.Optional[str] = </span><span class="s2">None</span><span class="s1">) -&gt; </span><span class="s3">&quot;te.NoReturn&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Exception handling helper.  This is used internally to either raise 
        rewritten exceptions or return a rendered traceback for the template. 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">.debug </span><span class="s2">import </span><span class="s1">rewrite_traceback_stack</span>

        <span class="s2">raise </span><span class="s1">rewrite_traceback_stack(source=source)</span>

    <span class="s2">def </span><span class="s1">join_path(self</span><span class="s2">, </span><span class="s1">template: str</span><span class="s2">, </span><span class="s1">parent: str) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Join a template with the parent.  By default all the lookups are 
        relative to the loader root so this method returns the `template` 
        parameter unchanged, but if the paths should be relative to the 
        parent template, this function can be used to calculate the real 
        template name. 
 
        Subclasses may override this method and implement template path 
        joining here. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">template</span>

    <span class="s1">@internalcode</span>
    <span class="s2">def </span><span class="s1">_load_template(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">globals: t.Optional[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]]</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Template&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self.loader </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;no loader for this environment specified&quot;</span><span class="s1">)</span>
        <span class="s1">cache_key = (weakref.ref(self.loader)</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s2">if </span><span class="s1">self.cache </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">template = self.cache.get(cache_key)</span>
            <span class="s2">if </span><span class="s1">template </span><span class="s2">is not None and </span><span class="s1">(</span>
                <span class="s2">not </span><span class="s1">self.auto_reload </span><span class="s2">or </span><span class="s1">template.is_up_to_date</span>
            <span class="s1">):</span>
                <span class="s4"># template.globals is a ChainMap, modifying it will only</span>
                <span class="s4"># affect the template, not the environment globals.</span>
                <span class="s2">if </span><span class="s1">globals:</span>
                    <span class="s1">template.globals.update(globals)</span>

                <span class="s2">return </span><span class="s1">template</span>

        <span class="s1">template = self.loader.load(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">self.make_globals(globals))</span>

        <span class="s2">if </span><span class="s1">self.cache </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.cache[cache_key] = template</span>
        <span class="s2">return </span><span class="s1">template</span>

    <span class="s1">@internalcode</span>
    <span class="s2">def </span><span class="s1">get_template(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">name: t.Union[str</span><span class="s2">, </span><span class="s3">&quot;Template&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">parent: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">globals: t.Optional[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Template&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Load a template by name with :attr:`loader` and return a 
        :class:`Template`. If the template does not exist a 
        :exc:`TemplateNotFound` exception is raised. 
 
        :param name: Name of the template to load. 
        :param parent: The name of the parent template importing this 
            template. :meth:`join_path` can be used to implement name 
            transformations with this. 
        :param globals: Extend the environment :attr:`globals` with 
            these extra variables available for all renders of this 
            template. If the template has already been loaded and 
            cached, its globals are updated with any new items. 
 
        .. versionchanged:: 3.0 
            If a template is loaded from cache, ``globals`` will update 
            the template's globals instead of ignoring the new values. 
 
        .. versionchanged:: 2.4 
            If ``name`` is a :class:`Template` object it is returned 
            unchanged. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(name</span><span class="s2">, </span><span class="s1">Template):</span>
            <span class="s2">return </span><span class="s1">name</span>
        <span class="s2">if </span><span class="s1">parent </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">name = self.join_path(name</span><span class="s2">, </span><span class="s1">parent)</span>

        <span class="s2">return </span><span class="s1">self._load_template(name</span><span class="s2">, </span><span class="s1">globals)</span>

    <span class="s1">@internalcode</span>
    <span class="s2">def </span><span class="s1">select_template(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">names: t.Iterable[t.Union[str</span><span class="s2">, </span><span class="s3">&quot;Template&quot;</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">parent: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">globals: t.Optional[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Template&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Like :meth:`get_template`, but tries loading multiple names. 
        If none of the names can be loaded a :exc:`TemplatesNotFound` 
        exception is raised. 
 
        :param names: List of template names to try loading in order. 
        :param parent: The name of the parent template importing this 
            template. :meth:`join_path` can be used to implement name 
            transformations with this. 
        :param globals: Extend the environment :attr:`globals` with 
            these extra variables available for all renders of this 
            template. If the template has already been loaded and 
            cached, its globals are updated with any new items. 
 
        .. versionchanged:: 3.0 
            If a template is loaded from cache, ``globals`` will update 
            the template's globals instead of ignoring the new values. 
 
        .. versionchanged:: 2.11 
            If ``names`` is :class:`Undefined`, an :exc:`UndefinedError` 
            is raised instead. If no templates were found and ``names`` 
            contains :class:`Undefined`, the message is more helpful. 
 
        .. versionchanged:: 2.4 
            If ``names`` contains a :class:`Template` object it is 
            returned unchanged. 
 
        .. versionadded:: 2.3 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(names</span><span class="s2">, </span><span class="s1">Undefined):</span>
            <span class="s1">names._fail_with_undefined_error()</span>

        <span class="s2">if not </span><span class="s1">names:</span>
            <span class="s2">raise </span><span class="s1">TemplatesNotFound(</span>
                <span class="s1">message=</span><span class="s3">&quot;Tried to select from an empty list of templates.&quot;</span>
            <span class="s1">)</span>

        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names:</span>
            <span class="s2">if </span><span class="s1">isinstance(name</span><span class="s2">, </span><span class="s1">Template):</span>
                <span class="s2">return </span><span class="s1">name</span>
            <span class="s2">if </span><span class="s1">parent </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">name = self.join_path(name</span><span class="s2">, </span><span class="s1">parent)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self._load_template(name</span><span class="s2">, </span><span class="s1">globals)</span>
            <span class="s2">except </span><span class="s1">(TemplateNotFound</span><span class="s2">, </span><span class="s1">UndefinedError):</span>
                <span class="s2">pass</span>
        <span class="s2">raise </span><span class="s1">TemplatesNotFound(names)  </span><span class="s4"># type: ignore</span>

    <span class="s1">@internalcode</span>
    <span class="s2">def </span><span class="s1">get_or_select_template(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">template_name_or_list: t.Union[</span>
            <span class="s1">str</span><span class="s2">, </span><span class="s3">&quot;Template&quot;</span><span class="s2">, </span><span class="s1">t.List[t.Union[str</span><span class="s2">, </span><span class="s3">&quot;Template&quot;</span><span class="s1">]]</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">parent: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">globals: t.Optional[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Template&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Use :meth:`select_template` if an iterable of template names 
        is given, or :meth:`get_template` if one name is given. 
 
        .. versionadded:: 2.3 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(template_name_or_list</span><span class="s2">, </span><span class="s1">(str</span><span class="s2">, </span><span class="s1">Undefined)):</span>
            <span class="s2">return </span><span class="s1">self.get_template(template_name_or_list</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">globals)</span>
        <span class="s2">elif </span><span class="s1">isinstance(template_name_or_list</span><span class="s2">, </span><span class="s1">Template):</span>
            <span class="s2">return </span><span class="s1">template_name_or_list</span>
        <span class="s2">return </span><span class="s1">self.select_template(template_name_or_list</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">globals)</span>

    <span class="s2">def </span><span class="s1">from_string(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">source: t.Union[str</span><span class="s2">, </span><span class="s1">nodes.Template]</span><span class="s2">,</span>
        <span class="s1">globals: t.Optional[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
        <span class="s1">template_class: t.Optional[t.Type[</span><span class="s3">&quot;Template&quot;</span><span class="s1">]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Template&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Load a template from a source string without using 
        :attr:`loader`. 
 
        :param source: Jinja source to compile into a template. 
        :param globals: Extend the environment :attr:`globals` with 
            these extra variables available for all renders of this 
            template. If the template has already been loaded and 
            cached, its globals are updated with any new items. 
        :param template_class: Return an instance of this 
            :class:`Template` class. 
        &quot;&quot;&quot;</span>
        <span class="s1">gs = self.make_globals(globals)</span>
        <span class="s1">cls = template_class </span><span class="s2">or </span><span class="s1">self.template_class</span>
        <span class="s2">return </span><span class="s1">cls.from_code(self</span><span class="s2">, </span><span class="s1">self.compile(source)</span><span class="s2">, </span><span class="s1">gs</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">make_globals(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">d: t.Optional[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]]</span>
    <span class="s1">) -&gt; t.MutableMapping[str</span><span class="s2">, </span><span class="s1">t.Any]:</span>
        <span class="s0">&quot;&quot;&quot;Make the globals map for a template. Any given template 
        globals overlay the environment :attr:`globals`. 
 
        Returns a :class:`collections.ChainMap`. This allows any changes 
        to a template's globals to only affect that template, while 
        changes to the environment's globals are still reflected. 
        However, avoid modifying any globals after a template is loaded. 
 
        :param d: Dict of template-specific globals. 
 
        .. versionchanged:: 3.0 
            Use :class:`collections.ChainMap` to always prevent mutating 
            environment globals. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">d </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">d = {}</span>

        <span class="s2">return </span><span class="s1">ChainMap(d</span><span class="s2">, </span><span class="s1">self.globals)</span>


<span class="s2">class </span><span class="s1">Template:</span>
    <span class="s0">&quot;&quot;&quot;A compiled template that can be rendered. 
 
    Use the methods on :class:`Environment` to create or load templates. 
    The environment is used to configure how templates are compiled and 
    behave. 
 
    It is also possible to create a template object directly. This is 
    not usually recommended. The constructor takes most of the same 
    arguments as :class:`Environment`. All templates created with the 
    same environment arguments share the same ephemeral ``Environment`` 
    instance behind the scenes. 
 
    A template object should be considered immutable. Modifications on 
    the object are not supported. 
    &quot;&quot;&quot;</span>

    <span class="s4">#: Type of environment to create when creating a template directly</span>
    <span class="s4">#: rather than through an existing environment.</span>
    <span class="s1">environment_class: t.Type[Environment] = Environment</span>

    <span class="s1">environment: Environment</span>
    <span class="s1">globals: t.MutableMapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span>
    <span class="s1">name: t.Optional[str]</span>
    <span class="s1">filename: t.Optional[str]</span>
    <span class="s1">blocks: t.Dict[str</span><span class="s2">, </span><span class="s1">t.Callable[[Context]</span><span class="s2">, </span><span class="s1">t.Iterator[str]]]</span>
    <span class="s1">root_render_func: t.Callable[[Context]</span><span class="s2">, </span><span class="s1">t.Iterator[str]]</span>
    <span class="s1">_module: t.Optional[</span><span class="s3">&quot;TemplateModule&quot;</span><span class="s1">]</span>
    <span class="s1">_debug_info: str</span>
    <span class="s1">_uptodate: t.Optional[t.Callable[[]</span><span class="s2">, </span><span class="s1">bool]]</span>

    <span class="s2">def </span><span class="s1">__new__(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">source: t.Union[str</span><span class="s2">, </span><span class="s1">nodes.Template]</span><span class="s2">,</span>
        <span class="s1">block_start_string: str = BLOCK_START_STRING</span><span class="s2">,</span>
        <span class="s1">block_end_string: str = BLOCK_END_STRING</span><span class="s2">,</span>
        <span class="s1">variable_start_string: str = VARIABLE_START_STRING</span><span class="s2">,</span>
        <span class="s1">variable_end_string: str = VARIABLE_END_STRING</span><span class="s2">,</span>
        <span class="s1">comment_start_string: str = COMMENT_START_STRING</span><span class="s2">,</span>
        <span class="s1">comment_end_string: str = COMMENT_END_STRING</span><span class="s2">,</span>
        <span class="s1">line_statement_prefix: t.Optional[str] = LINE_STATEMENT_PREFIX</span><span class="s2">,</span>
        <span class="s1">line_comment_prefix: t.Optional[str] = LINE_COMMENT_PREFIX</span><span class="s2">,</span>
        <span class="s1">trim_blocks: bool = TRIM_BLOCKS</span><span class="s2">,</span>
        <span class="s1">lstrip_blocks: bool = LSTRIP_BLOCKS</span><span class="s2">,</span>
        <span class="s1">newline_sequence: </span><span class="s3">&quot;te.Literal['</span><span class="s2">\\</span><span class="s3">n', '</span><span class="s2">\\</span><span class="s3">r</span><span class="s2">\\</span><span class="s3">n', '</span><span class="s2">\\</span><span class="s3">r']&quot; </span><span class="s1">= NEWLINE_SEQUENCE</span><span class="s2">,</span>
        <span class="s1">keep_trailing_newline: bool = KEEP_TRAILING_NEWLINE</span><span class="s2">,</span>
        <span class="s1">extensions: t.Sequence[t.Union[str</span><span class="s2">, </span><span class="s1">t.Type[</span><span class="s3">&quot;Extension&quot;</span><span class="s1">]]] = ()</span><span class="s2">,</span>
        <span class="s1">optimized: bool = </span><span class="s2">True,</span>
        <span class="s1">undefined: t.Type[Undefined] = Undefined</span><span class="s2">,</span>
        <span class="s1">finalize: t.Optional[t.Callable[...</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
        <span class="s1">autoescape: t.Union[bool</span><span class="s2">, </span><span class="s1">t.Callable[[t.Optional[str]]</span><span class="s2">, </span><span class="s1">bool]] = </span><span class="s2">False,</span>
        <span class="s1">enable_async: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; t.Any:  </span><span class="s4"># it returns a `Template`, but this breaks the sphinx build...</span>
        <span class="s1">env = get_spontaneous_environment(</span>
            <span class="s1">cls.environment_class</span><span class="s2">,  </span><span class="s4"># type: ignore</span>
            <span class="s1">block_start_string</span><span class="s2">,</span>
            <span class="s1">block_end_string</span><span class="s2">,</span>
            <span class="s1">variable_start_string</span><span class="s2">,</span>
            <span class="s1">variable_end_string</span><span class="s2">,</span>
            <span class="s1">comment_start_string</span><span class="s2">,</span>
            <span class="s1">comment_end_string</span><span class="s2">,</span>
            <span class="s1">line_statement_prefix</span><span class="s2">,</span>
            <span class="s1">line_comment_prefix</span><span class="s2">,</span>
            <span class="s1">trim_blocks</span><span class="s2">,</span>
            <span class="s1">lstrip_blocks</span><span class="s2">,</span>
            <span class="s1">newline_sequence</span><span class="s2">,</span>
            <span class="s1">keep_trailing_newline</span><span class="s2">,</span>
            <span class="s1">frozenset(extensions)</span><span class="s2">,</span>
            <span class="s1">optimized</span><span class="s2">,</span>
            <span class="s1">undefined</span><span class="s2">,  </span><span class="s4"># type: ignore</span>
            <span class="s1">finalize</span><span class="s2">,</span>
            <span class="s1">autoescape</span><span class="s2">,</span>
            <span class="s2">None,</span>
            <span class="s5">0</span><span class="s2">,</span>
            <span class="s2">False,</span>
            <span class="s2">None,</span>
            <span class="s1">enable_async</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">env.from_string(source</span><span class="s2">, </span><span class="s1">template_class=cls)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_code(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">environment: Environment</span><span class="s2">,</span>
        <span class="s1">code: CodeType</span><span class="s2">,</span>
        <span class="s1">globals: t.MutableMapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">,</span>
        <span class="s1">uptodate: t.Optional[t.Callable[[]</span><span class="s2">, </span><span class="s1">bool]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Template&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Creates a template object from compiled code and the globals.  This 
        is used by the loaders and environment to create a template object. 
        &quot;&quot;&quot;</span>
        <span class="s1">namespace = {</span><span class="s3">&quot;environment&quot;</span><span class="s1">: environment</span><span class="s2">, </span><span class="s3">&quot;__file__&quot;</span><span class="s1">: code.co_filename}</span>
        <span class="s1">exec(code</span><span class="s2">, </span><span class="s1">namespace)</span>
        <span class="s1">rv = cls._from_namespace(environment</span><span class="s2">, </span><span class="s1">namespace</span><span class="s2">, </span><span class="s1">globals)</span>
        <span class="s1">rv._uptodate = uptodate</span>
        <span class="s2">return </span><span class="s1">rv</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_module_dict(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">environment: Environment</span><span class="s2">,</span>
        <span class="s1">module_dict: t.MutableMapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">,</span>
        <span class="s1">globals: t.MutableMapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Template&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Creates a template object from a module.  This is used by the 
        module loader to create a template object. 
 
        .. versionadded:: 2.4 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">cls._from_namespace(environment</span><span class="s2">, </span><span class="s1">module_dict</span><span class="s2">, </span><span class="s1">globals)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_from_namespace(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">environment: Environment</span><span class="s2">,</span>
        <span class="s1">namespace: t.MutableMapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">,</span>
        <span class="s1">globals: t.MutableMapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Template&quot;</span><span class="s1">:</span>
        <span class="s1">t: </span><span class="s3">&quot;Template&quot; </span><span class="s1">= object.__new__(cls)</span>
        <span class="s1">t.environment = environment</span>
        <span class="s1">t.globals = globals</span>
        <span class="s1">t.name = namespace[</span><span class="s3">&quot;name&quot;</span><span class="s1">]</span>
        <span class="s1">t.filename = namespace[</span><span class="s3">&quot;__file__&quot;</span><span class="s1">]</span>
        <span class="s1">t.blocks = namespace[</span><span class="s3">&quot;blocks&quot;</span><span class="s1">]</span>

        <span class="s4"># render function and module</span>
        <span class="s1">t.root_render_func = namespace[</span><span class="s3">&quot;root&quot;</span><span class="s1">]  </span><span class="s4"># type: ignore</span>
        <span class="s1">t._module = </span><span class="s2">None</span>

        <span class="s4"># debug and loader helpers</span>
        <span class="s1">t._debug_info = namespace[</span><span class="s3">&quot;debug_info&quot;</span><span class="s1">]</span>
        <span class="s1">t._uptodate = </span><span class="s2">None</span>

        <span class="s4"># store the reference</span>
        <span class="s1">namespace[</span><span class="s3">&quot;environment&quot;</span><span class="s1">] = environment</span>
        <span class="s1">namespace[</span><span class="s3">&quot;__jinja_template__&quot;</span><span class="s1">] = t</span>

        <span class="s2">return </span><span class="s1">t</span>

    <span class="s2">def </span><span class="s1">render(self</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;This method accepts the same arguments as the `dict` constructor: 
        A dict, a dict subclass or some keyword arguments.  If no arguments 
        are given the context will be empty.  These two calls do the same:: 
 
            template.render(knights='that say nih') 
            template.render({'knights': 'that say nih'}) 
 
        This will return the rendered template as a string. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.environment.is_async:</span>
            <span class="s2">import </span><span class="s1">asyncio</span>

            <span class="s1">close = </span><span class="s2">False</span>

            <span class="s2">if </span><span class="s1">sys.version_info &lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">7</span><span class="s1">):</span>
                <span class="s1">loop = asyncio.get_event_loop()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">loop = asyncio.get_running_loop()</span>
                <span class="s2">except </span><span class="s1">RuntimeError:</span>
                    <span class="s1">loop = asyncio.new_event_loop()</span>
                    <span class="s1">close = </span><span class="s2">True</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">loop.run_until_complete(self.render_async(*args</span><span class="s2">, </span><span class="s1">**kwargs))</span>
            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">close:</span>
                    <span class="s1">loop.close()</span>

        <span class="s1">ctx = self.new_context(dict(*args</span><span class="s2">, </span><span class="s1">**kwargs))</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">concat(self.root_render_func(ctx))  </span><span class="s4"># type: ignore</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s1">self.environment.handle_exception()</span>

    <span class="s2">async def </span><span class="s1">render_async(self</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;This works similar to :meth:`render` but returns a coroutine 
        that when awaited returns the entire rendered template string.  This 
        requires the async feature to be enabled. 
 
        Example usage:: 
 
            await template.render_async(knights='that say nih; asynchronously') 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self.environment.is_async:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span>
                <span class="s3">&quot;The environment was not created with async mode enabled.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">ctx = self.new_context(dict(*args</span><span class="s2">, </span><span class="s1">**kwargs))</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">concat([n </span><span class="s2">async for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self.root_render_func(ctx)])  </span><span class="s4"># type: ignore</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">return </span><span class="s1">self.environment.handle_exception()</span>

    <span class="s2">def </span><span class="s1">stream(self</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any) -&gt; </span><span class="s3">&quot;TemplateStream&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Works exactly like :meth:`generate` but returns a 
        :class:`TemplateStream`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">TemplateStream(self.generate(*args</span><span class="s2">, </span><span class="s1">**kwargs))</span>

    <span class="s2">def </span><span class="s1">generate(self</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any) -&gt; t.Iterator[str]:</span>
        <span class="s0">&quot;&quot;&quot;For very large templates it can be useful to not render the whole 
        template at once but evaluate each statement after another and yield 
        piece for piece.  This method basically does exactly that and returns 
        a generator that yields one item after another as strings. 
 
        It accepts the same arguments as :meth:`render`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.environment.is_async:</span>
            <span class="s2">import </span><span class="s1">asyncio</span>

            <span class="s2">async def </span><span class="s1">to_list() -&gt; t.List[str]:</span>
                <span class="s2">return </span><span class="s1">[x </span><span class="s2">async for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self.generate_async(*args</span><span class="s2">, </span><span class="s1">**kwargs)]</span>

            <span class="s2">if </span><span class="s1">sys.version_info &lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">7</span><span class="s1">):</span>
                <span class="s1">loop = asyncio.get_event_loop()</span>
                <span class="s1">out = loop.run_until_complete(to_list())</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">out = asyncio.run(to_list())</span>

            <span class="s2">yield from </span><span class="s1">out</span>
            <span class="s2">return</span>

        <span class="s1">ctx = self.new_context(dict(*args</span><span class="s2">, </span><span class="s1">**kwargs))</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">yield from </span><span class="s1">self.root_render_func(ctx)  </span><span class="s4"># type: ignore</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">yield </span><span class="s1">self.environment.handle_exception()</span>

    <span class="s2">async def </span><span class="s1">generate_async(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any</span>
    <span class="s1">) -&gt; t.AsyncIterator[str]:</span>
        <span class="s0">&quot;&quot;&quot;An async version of :meth:`generate`.  Works very similarly but 
        returns an async iterator instead. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self.environment.is_async:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span>
                <span class="s3">&quot;The environment was not created with async mode enabled.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">ctx = self.new_context(dict(*args</span><span class="s2">, </span><span class="s1">**kwargs))</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">async for </span><span class="s1">event </span><span class="s2">in </span><span class="s1">self.root_render_func(ctx):  </span><span class="s4"># type: ignore</span>
                <span class="s2">yield </span><span class="s1">event</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">yield </span><span class="s1">self.environment.handle_exception()</span>

    <span class="s2">def </span><span class="s1">new_context(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">vars: t.Optional[t.Dict[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
        <span class="s1">shared: bool = </span><span class="s2">False,</span>
        <span class="s1">locals: t.Optional[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; Context:</span>
        <span class="s0">&quot;&quot;&quot;Create a new :class:`Context` for this template.  The vars 
        provided will be passed to the template.  Per default the globals 
        are added to the context.  If shared is set to `True` the data 
        is passed as is to the context without adding the globals. 
 
        `locals` can be a dict of local variables for internal usage. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">new_context(</span>
            <span class="s1">self.environment</span><span class="s2">, </span><span class="s1">self.name</span><span class="s2">, </span><span class="s1">self.blocks</span><span class="s2">, </span><span class="s1">vars</span><span class="s2">, </span><span class="s1">shared</span><span class="s2">, </span><span class="s1">self.globals</span><span class="s2">, </span><span class="s1">locals</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">make_module(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">vars: t.Optional[t.Dict[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
        <span class="s1">shared: bool = </span><span class="s2">False,</span>
        <span class="s1">locals: t.Optional[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;TemplateModule&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;This method works like the :attr:`module` attribute when called 
        without arguments but it will evaluate the template on every call 
        rather than caching it.  It's also possible to provide 
        a dict which is then used as context.  The arguments are the same 
        as for the :meth:`new_context` method. 
        &quot;&quot;&quot;</span>
        <span class="s1">ctx = self.new_context(vars</span><span class="s2">, </span><span class="s1">shared</span><span class="s2">, </span><span class="s1">locals)</span>
        <span class="s2">return </span><span class="s1">TemplateModule(self</span><span class="s2">, </span><span class="s1">ctx)</span>

    <span class="s2">async def </span><span class="s1">make_module_async(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">vars: t.Optional[t.Dict[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
        <span class="s1">shared: bool = </span><span class="s2">False,</span>
        <span class="s1">locals: t.Optional[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;TemplateModule&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;As template module creation can invoke template code for 
        asynchronous executions this method must be used instead of the 
        normal :meth:`make_module` one.  Likewise the module attribute 
        becomes unavailable in async mode. 
        &quot;&quot;&quot;</span>
        <span class="s1">ctx = self.new_context(vars</span><span class="s2">, </span><span class="s1">shared</span><span class="s2">, </span><span class="s1">locals)</span>
        <span class="s2">return </span><span class="s1">TemplateModule(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">[x </span><span class="s2">async for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self.root_render_func(ctx)]  </span><span class="s4"># type: ignore</span>
        <span class="s1">)</span>

    <span class="s1">@internalcode</span>
    <span class="s2">def </span><span class="s1">_get_default_module(self</span><span class="s2">, </span><span class="s1">ctx: t.Optional[Context] = </span><span class="s2">None</span><span class="s1">) -&gt; </span><span class="s3">&quot;TemplateModule&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;If a context is passed in, this means that the template was 
        imported. Imported templates have access to the current 
        template's globals by default, but they can only be accessed via 
        the context during runtime. 
 
        If there are new globals, we need to create a new module because 
        the cached module is already rendered and will not have access 
        to globals from the current context. This new module is not 
        cached because the template can be imported elsewhere, and it 
        should have access to only the current template's globals. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.environment.is_async:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;Module is not available in async mode.&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">ctx </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">keys = ctx.globals_keys - self.globals.keys()</span>

            <span class="s2">if </span><span class="s1">keys:</span>
                <span class="s2">return </span><span class="s1">self.make_module({k: ctx.parent[k] </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">keys})</span>

        <span class="s2">if </span><span class="s1">self._module </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._module = self.make_module()</span>

        <span class="s2">return </span><span class="s1">self._module</span>

    <span class="s2">async def </span><span class="s1">_get_default_module_async(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">ctx: t.Optional[Context] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;TemplateModule&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">ctx </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">keys = ctx.globals_keys - self.globals.keys()</span>

            <span class="s2">if </span><span class="s1">keys:</span>
                <span class="s2">return await </span><span class="s1">self.make_module_async({k: ctx.parent[k] </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">keys})</span>

        <span class="s2">if </span><span class="s1">self._module </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._module = </span><span class="s2">await </span><span class="s1">self.make_module_async()</span>

        <span class="s2">return </span><span class="s1">self._module</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">module(self) -&gt; </span><span class="s3">&quot;TemplateModule&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;The template as module.  This is used for imports in the 
        template runtime but is also useful if one wants to access 
        exported template variables from the Python layer: 
 
        &gt;&gt;&gt; t = Template('{% macro foo() %}42{% endmacro %}23') 
        &gt;&gt;&gt; str(t.module) 
        '23' 
        &gt;&gt;&gt; t.module.foo() == u'42' 
        True 
 
        This attribute is not available if async mode is enabled. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._get_default_module()</span>

    <span class="s2">def </span><span class="s1">get_corresponding_lineno(self</span><span class="s2">, </span><span class="s1">lineno: int) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;Return the source line number of a line number in the 
        generated bytecode as they are not in sync. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">template_line</span><span class="s2">, </span><span class="s1">code_line </span><span class="s2">in </span><span class="s1">reversed(self.debug_info):</span>
            <span class="s2">if </span><span class="s1">code_line &lt;= lineno:</span>
                <span class="s2">return </span><span class="s1">template_line</span>
        <span class="s2">return </span><span class="s5">1</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_up_to_date(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;If this variable is `False` there is a newer version available.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._uptodate </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return True</span>
        <span class="s2">return </span><span class="s1">self._uptodate()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">debug_info(self) -&gt; t.List[t.Tuple[int</span><span class="s2">, </span><span class="s1">int]]:</span>
        <span class="s0">&quot;&quot;&quot;The debug info mapping.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._debug_info:</span>
            <span class="s2">return </span><span class="s1">[</span>
                <span class="s1">tuple(map(int</span><span class="s2">, </span><span class="s1">x.split(</span><span class="s3">&quot;=&quot;</span><span class="s1">)))  </span><span class="s4"># type: ignore</span>
                <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self._debug_info.split(</span><span class="s3">&quot;&amp;&quot;</span><span class="s1">)</span>
            <span class="s1">]</span>

        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">if </span><span class="s1">self.name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">name = </span><span class="s3">f&quot;memory:</span><span class="s2">{</span><span class="s1">id(self)</span><span class="s2">:</span><span class="s3">x</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">name = repr(self.name)</span>
        <span class="s2">return </span><span class="s3">f&quot;&lt;</span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">} {</span><span class="s1">name</span><span class="s2">}</span><span class="s3">&gt;&quot;</span>


<span class="s2">class </span><span class="s1">TemplateModule:</span>
    <span class="s0">&quot;&quot;&quot;Represents an imported template.  All the exported names of the 
    template are available as attributes on this object.  Additionally 
    converting it into a string renders the contents. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">template: Template</span><span class="s2">,</span>
        <span class="s1">context: Context</span><span class="s2">,</span>
        <span class="s1">body_stream: t.Optional[t.Iterable[str]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">body_stream </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">context.environment.is_async:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError(</span>
                    <span class="s3">&quot;Async mode requires a body stream to be passed to&quot;</span>
                    <span class="s3">&quot; a template module. Use the async methods of the&quot;</span>
                    <span class="s3">&quot; API you are using.&quot;</span>
                <span class="s1">)</span>

            <span class="s1">body_stream = list(template.root_render_func(context))  </span><span class="s4"># type: ignore</span>

        <span class="s1">self._body_stream = body_stream</span>
        <span class="s1">self.__dict__.update(context.get_exported())</span>
        <span class="s1">self.__name__ = template.name</span>

    <span class="s2">def </span><span class="s1">__html__(self) -&gt; Markup:</span>
        <span class="s2">return </span><span class="s1">Markup(concat(self._body_stream))</span>

    <span class="s2">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">concat(self._body_stream)</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">if </span><span class="s1">self.__name__ </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">name = </span><span class="s3">f&quot;memory:</span><span class="s2">{</span><span class="s1">id(self)</span><span class="s2">:</span><span class="s3">x</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">name = repr(self.__name__)</span>
        <span class="s2">return </span><span class="s3">f&quot;&lt;</span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">} {</span><span class="s1">name</span><span class="s2">}</span><span class="s3">&gt;&quot;</span>


<span class="s2">class </span><span class="s1">TemplateExpression:</span>
    <span class="s0">&quot;&quot;&quot;The :meth:`jinja2.Environment.compile_expression` method returns an 
    instance of this object.  It encapsulates the expression-like access 
    to the template with an expression it wraps. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">template: Template</span><span class="s2">, </span><span class="s1">undefined_to_none: bool) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._template = template</span>
        <span class="s1">self._undefined_to_none = undefined_to_none</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any) -&gt; t.Optional[t.Any]:</span>
        <span class="s1">context = self._template.new_context(dict(*args</span><span class="s2">, </span><span class="s1">**kwargs))</span>
        <span class="s1">consume(self._template.root_render_func(context))  </span><span class="s4"># type: ignore</span>
        <span class="s1">rv = context.vars[</span><span class="s3">&quot;result&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self._undefined_to_none </span><span class="s2">and </span><span class="s1">isinstance(rv</span><span class="s2">, </span><span class="s1">Undefined):</span>
            <span class="s1">rv = </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">rv</span>


<span class="s2">class </span><span class="s1">TemplateStream:</span>
    <span class="s0">&quot;&quot;&quot;A template stream works pretty much like an ordinary python generator 
    but it can buffer multiple items to reduce the number of total iterations. 
    Per default the output is unbuffered which means that for every unbuffered 
    instruction in the template one string is yielded. 
 
    If buffering is enabled with a buffer size of 5, five items are combined 
    into a new string.  This is mainly useful if you are streaming 
    big templates to a client via WSGI which flushes after each iteration. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">gen: t.Iterator[str]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._gen = gen</span>
        <span class="s1">self.disable_buffering()</span>

    <span class="s2">def </span><span class="s1">dump(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">fp: t.Union[str</span><span class="s2">, </span><span class="s1">t.IO]</span><span class="s2">,</span>
        <span class="s1">encoding: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">errors: t.Optional[str] = </span><span class="s3">&quot;strict&quot;</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Dump the complete stream into a file or file-like object. 
        Per default strings are written, if you want to encode 
        before writing specify an `encoding`. 
 
        Example usage:: 
 
            Template('Hello {{ name }}!').stream(name='foo').dump('hello.html') 
        &quot;&quot;&quot;</span>
        <span class="s1">close = </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">isinstance(fp</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">encoding = </span><span class="s3">&quot;utf-8&quot;</span>

            <span class="s1">fp = open(fp</span><span class="s2">, </span><span class="s3">&quot;wb&quot;</span><span class="s1">)</span>
            <span class="s1">close = </span><span class="s2">True</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">iterable = (x.encode(encoding</span><span class="s2">, </span><span class="s1">errors) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self)  </span><span class="s4"># type: ignore</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">iterable = self  </span><span class="s4"># type: ignore</span>

            <span class="s2">if </span><span class="s1">hasattr(fp</span><span class="s2">, </span><span class="s3">&quot;writelines&quot;</span><span class="s1">):</span>
                <span class="s1">fp.writelines(iterable)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">iterable:</span>
                    <span class="s1">fp.write(item)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">close:</span>
                <span class="s1">fp.close()</span>

    <span class="s2">def </span><span class="s1">disable_buffering(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Disable the output buffering.&quot;&quot;&quot;</span>
        <span class="s1">self._next = partial(next</span><span class="s2">, </span><span class="s1">self._gen)</span>
        <span class="s1">self.buffered = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">_buffered_generator(self</span><span class="s2">, </span><span class="s1">size: int) -&gt; t.Iterator[str]:</span>
        <span class="s1">buf: t.List[str] = []</span>
        <span class="s1">c_size = </span><span class="s5">0</span>
        <span class="s1">push = buf.append</span>

        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">while </span><span class="s1">c_size &lt; size:</span>
                    <span class="s1">c = next(self._gen)</span>
                    <span class="s1">push(c)</span>
                    <span class="s2">if </span><span class="s1">c:</span>
                        <span class="s1">c_size += </span><span class="s5">1</span>
            <span class="s2">except </span><span class="s1">StopIteration:</span>
                <span class="s2">if not </span><span class="s1">c_size:</span>
                    <span class="s2">return</span>
            <span class="s2">yield </span><span class="s1">concat(buf)</span>
            <span class="s2">del </span><span class="s1">buf[:]</span>
            <span class="s1">c_size = </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">enable_buffering(self</span><span class="s2">, </span><span class="s1">size: int = </span><span class="s5">5</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Enable buffering.  Buffer `size` items before yielding them.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">size &lt;= </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;buffer size too small&quot;</span><span class="s1">)</span>

        <span class="s1">self.buffered = </span><span class="s2">True</span>
        <span class="s1">self._next = partial(next</span><span class="s2">, </span><span class="s1">self._buffered_generator(size))</span>

    <span class="s2">def </span><span class="s1">__iter__(self) -&gt; </span><span class="s3">&quot;TemplateStream&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__next__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self._next()  </span><span class="s4"># type: ignore</span>


<span class="s4"># hook in default template class.  if anyone reads this comment: ignore that</span>
<span class="s4"># it's possible to use custom templates ;-)</span>
<span class="s1">Environment.template_class = Template</span>
</pre>
</body>
</html>