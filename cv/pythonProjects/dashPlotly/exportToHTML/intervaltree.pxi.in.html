<html>
<head>
<title>intervaltree.pxi.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
intervaltree.pxi.in</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;</span>
<span class="s0">Template for intervaltree</span>

<span class="s0">WARNING: DO NOT edit .pxi FILE directly, .pxi is generated from .pxi.in</span>
<span class="s0">&quot;&quot;&quot;</span>

<span class="s0">from pandas._libs.algos import is_monotonic</span>

<span class="s0">ctypedef fused int_scalar_t:</span>
    <span class="s0">int64_t</span>
    <span class="s0">float64_t</span>

<span class="s0">ctypedef fused uint_scalar_t:</span>
    <span class="s0">uint64_t</span>
    <span class="s0">float64_t</span>

<span class="s0">ctypedef fused scalar_t:</span>
    <span class="s0">int_scalar_t</span>
    <span class="s0">uint_scalar_t</span>

<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># IntervalTree</span>
<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0">cdef class IntervalTree(IntervalMixin):</span>
    <span class="s0">&quot;&quot;&quot;A centered interval tree</span>

    <span class="s0">Based off the algorithm described on Wikipedia:</span>
    <span class="s0">https://en.wikipedia.org/wiki/Interval_tree</span>

    <span class="s0">we are emulating the IndexEngine interface</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef readonly:</span>
        <span class="s0">ndarray left, right</span>
        <span class="s0">IntervalNode root</span>
        <span class="s0">object dtype</span>
        <span class="s0">str closed</span>
        <span class="s0">object _is_overlapping, _left_sorter, _right_sorter</span>
        <span class="s0">Py_ssize_t _na_count</span>

    <span class="s0">def __init__(self, left, right, closed='right', leaf_size=100):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">left, right : np.ndarray[ndim=1]</span>
            <span class="s0">Left and right bounds for each interval. Assumed to contain no</span>
            <span class="s0">NaNs.</span>
        <span class="s0">closed : {'left', 'right', 'both', 'neither'}, optional</span>
            <span class="s0">Whether the intervals are closed on the left-side, right-side, both</span>
            <span class="s0">or neither. Defaults to 'right'.</span>
        <span class="s0">leaf_size : int, optional</span>
            <span class="s0">Parameter that controls when the tree switches from creating nodes</span>
            <span class="s0">to brute-force search. Tune this parameter to optimize query</span>
            <span class="s0">performance.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if closed not in ['left', 'right', 'both', 'neither']:</span>
            <span class="s0">raise ValueError(&quot;invalid option for 'closed': %s&quot; % closed)</span>

        <span class="s0">left = np.asarray(left)</span>
        <span class="s0">right = np.asarray(right)</span>
        <span class="s0">self.dtype = np.result_type(left, right)</span>
        <span class="s0">self.left = np.asarray(left, dtype=self.dtype)</span>
        <span class="s0">self.right = np.asarray(right, dtype=self.dtype)</span>

        <span class="s0">indices = np.arange(len(left), dtype='int64')</span>

        <span class="s0">self.closed = closed</span>

        <span class="s0"># GH 23352: ensure no nan in nodes</span>
        <span class="s0">mask = ~np.isnan(self.left)</span>
        <span class="s0">self._na_count = len(mask) - mask.sum()</span>
        <span class="s0">self.left = self.left[mask]</span>
        <span class="s0">self.right = self.right[mask]</span>
        <span class="s0">indices = indices[mask]</span>

        <span class="s0">node_cls = NODE_CLASSES[str(self.dtype), closed]</span>
        <span class="s0">self.root = node_cls(self.left, self.right, indices, leaf_size)</span>

    <span class="s0">@property</span>
    <span class="s0">def left_sorter(self) -&gt; np.ndarray:</span>
        <span class="s0">&quot;&quot;&quot;How to sort the left labels; this is used for binary search</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self._left_sorter is None:</span>
            <span class="s0">self._left_sorter = np.argsort(self.left)</span>
        <span class="s0">return self._left_sorter</span>

    <span class="s0">@property</span>
    <span class="s0">def right_sorter(self) -&gt; np.ndarray:</span>
        <span class="s0">&quot;&quot;&quot;How to sort the right labels</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self._right_sorter is None:</span>
            <span class="s0">self._right_sorter = np.argsort(self.right)</span>
        <span class="s0">return self._right_sorter</span>

    <span class="s0">@property</span>
    <span class="s0">def is_overlapping(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Determine if the IntervalTree contains overlapping intervals.</span>
        <span class="s0">Cached as self._is_overlapping.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self._is_overlapping is not None:</span>
            <span class="s0">return self._is_overlapping</span>

        <span class="s0"># &lt;= when both sides closed since endpoints can overlap</span>
        <span class="s0">op = le if self.closed == 'both' else lt</span>

        <span class="s0"># overlap if start of current interval &lt; end of previous interval</span>
        <span class="s0"># (current and previous in terms of sorted order by left/start side)</span>
        <span class="s0">current = self.left[self.left_sorter[1:]]</span>
        <span class="s0">previous = self.right[self.left_sorter[:-1]]</span>
        <span class="s0">self._is_overlapping = bool(op(current, previous).any())</span>

        <span class="s0">return self._is_overlapping</span>

    <span class="s0">@property</span>
    <span class="s0">def is_monotonic_increasing(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return True if the IntervalTree is monotonic increasing (only equal or</span>
        <span class="s0">increasing values), else False</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self._na_count &gt; 0:</span>
            <span class="s0">return False</span>
        <span class="s0">values = [self.right, self.left]</span>

        <span class="s0">sort_order = np.lexsort(values)</span>
        <span class="s0">return is_monotonic(sort_order, False)[0]</span>

    <span class="s0">def get_indexer(self, scalar_t[:] target) -&gt; np.ndarray:</span>
        <span class="s0">&quot;&quot;&quot;Return the positions corresponding to unique intervals that overlap</span>
        <span class="s0">with the given array of scalar targets.</span>
        <span class="s0">&quot;&quot;&quot;</span>

        <span class="s0"># TODO: write get_indexer_intervals</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t old_len</span>
            <span class="s0">Py_ssize_t i</span>
            <span class="s0">Int64Vector result</span>

        <span class="s0">result = Int64Vector()</span>
        <span class="s0">old_len = 0</span>
        <span class="s0">for i in range(len(target)):</span>
            <span class="s0">try:</span>
                <span class="s0">self.root.query(result, target[i])</span>
            <span class="s0">except OverflowError:</span>
                <span class="s0"># overflow -&gt; no match, which is already handled below</span>
                <span class="s0">pass</span>

            <span class="s0">if result.data.n == old_len:</span>
                <span class="s0">result.append(-1)</span>
            <span class="s0">elif result.data.n &gt; old_len + 1:</span>
                <span class="s0">raise KeyError(</span>
                    <span class="s0">'indexer does not intersect a unique set of intervals')</span>
            <span class="s0">old_len = result.data.n</span>
        <span class="s0">return result.to_array().astype('intp')</span>

    <span class="s0">def get_indexer_non_unique(self, scalar_t[:] target):</span>
        <span class="s0">&quot;&quot;&quot;Return the positions corresponding to intervals that overlap with</span>
        <span class="s0">the given array of scalar targets. Non-unique positions are repeated.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t old_len</span>
            <span class="s0">Py_ssize_t i</span>
            <span class="s0">Int64Vector result, missing</span>

        <span class="s0">result = Int64Vector()</span>
        <span class="s0">missing = Int64Vector()</span>
        <span class="s0">old_len = 0</span>
        <span class="s0">for i in range(len(target)):</span>
            <span class="s0">try:</span>
                <span class="s0">self.root.query(result, target[i])</span>
            <span class="s0">except OverflowError:</span>
                <span class="s0"># overflow -&gt; no match, which is already handled below</span>
                <span class="s0">pass</span>

            <span class="s0">if result.data.n == old_len:</span>
                <span class="s0">result.append(-1)</span>
                <span class="s0">missing.append(i)</span>
            <span class="s0">old_len = result.data.n</span>
        <span class="s0">return (result.to_array().astype('intp'),</span>
                <span class="s0">missing.to_array().astype('intp'))</span>

    <span class="s0">def __repr__(self) -&gt; str:</span>
        <span class="s0">return ('&lt;IntervalTree[{dtype},{closed}]: '</span>
                <span class="s0">'{n_elements} elements&gt;'.format(</span>
                    <span class="s0">dtype=self.dtype, closed=self.closed,</span>
                    <span class="s0">n_elements=self.root.n_elements))</span>

    <span class="s0"># compat with IndexEngine interface</span>
    <span class="s0">def clear_mapping(self) -&gt; None:</span>
        <span class="s0">pass</span>


<span class="s0">cdef take(ndarray source, ndarray indices):</span>
    <span class="s0">&quot;&quot;&quot;Take the given positions from a 1D ndarray</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">return PyArray_Take(source, indices, 0)</span>


<span class="s0">cdef sort_values_and_indices(all_values, all_indices, subset):</span>
    <span class="s0">indices = take(all_indices, subset)</span>
    <span class="s0">values = take(all_values, subset)</span>
    <span class="s0">sorter = PyArray_ArgSort(values, 0, NPY_QUICKSORT)</span>
    <span class="s0">sorted_values = take(values, sorter)</span>
    <span class="s0">sorted_indices = take(indices, sorter)</span>
    <span class="s0">return sorted_values, sorted_indices</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Nodes</span>
<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0">@cython.internal</span>
<span class="s0">cdef class IntervalNode:</span>
    <span class="s0">cdef readonly:</span>
        <span class="s0">int64_t n_elements, n_center, leaf_size</span>
        <span class="s0">bint is_leaf_node</span>

    <span class="s0">def __repr__(self) -&gt; str:</span>
        <span class="s0">if self.is_leaf_node:</span>
            <span class="s0">return (</span>
                <span class="s0">f&quot;&lt;{type(self).__name__}: {self.n_elements} elements (terminal)&gt;&quot;</span>
            <span class="s0">)</span>
        <span class="s0">else:</span>
            <span class="s0">n_left = self.left_node.n_elements</span>
            <span class="s0">n_right = self.right_node.n_elements</span>
            <span class="s0">n_center = self.n_elements - n_left - n_right</span>
            <span class="s0">return (</span>
                <span class="s0">f&quot;&lt;{type(self).__name__}: &quot;</span>
                <span class="s0">f&quot;pivot {self.pivot}, {self.n_elements} elements &quot;</span>
                <span class="s0">f&quot;({n_left} left, {n_right} right, {n_center} overlapping)&gt;&quot;</span>
            <span class="s0">)</span>

    <span class="s0">def counts(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Inspect counts on this node</span>
        <span class="s0">useful for debugging purposes</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self.is_leaf_node:</span>
            <span class="s0">return self.n_elements</span>
        <span class="s0">else:</span>
            <span class="s0">m = len(self.center_left_values)</span>
            <span class="s0">l = self.left_node.counts()</span>
            <span class="s0">r = self.right_node.counts()</span>
            <span class="s0">return (m, (l, r))</span>


<span class="s0"># we need specialized nodes and leaves to optimize for different dtype and</span>
<span class="s0"># closed values</span>

<span class="s0">{{py:</span>

<span class="s0">nodes = []</span>
<span class="s0">for dtype in ['float64', 'int64', 'uint64']:</span>
    <span class="s0">for closed, cmp_left, cmp_right in [</span>
        <span class="s0">('left', '&lt;=', '&lt;'),</span>
        <span class="s0">('right', '&lt;', '&lt;='),</span>
        <span class="s0">('both', '&lt;=', '&lt;='),</span>
        <span class="s0">('neither', '&lt;', '&lt;')]:</span>
        <span class="s0">cmp_left_converse = '&lt;' if cmp_left == '&lt;=' else '&lt;='</span>
        <span class="s0">cmp_right_converse = '&lt;' if cmp_right == '&lt;=' else '&lt;='</span>
        <span class="s0">if dtype.startswith('int'):</span>
            <span class="s0">fused_prefix = 'int_'</span>
        <span class="s0">elif dtype.startswith('uint'):</span>
            <span class="s0">fused_prefix = 'uint_'</span>
        <span class="s0">elif dtype.startswith('float'):</span>
            <span class="s0">fused_prefix = ''</span>
        <span class="s0">nodes.append((dtype, dtype.title(),</span>
                      <span class="s0">closed, closed.title(),</span>
                      <span class="s0">cmp_left,</span>
                      <span class="s0">cmp_right,</span>
                      <span class="s0">cmp_left_converse,</span>
                      <span class="s0">cmp_right_converse,</span>
                      <span class="s0">fused_prefix))</span>

<span class="s0">}}</span>

<span class="s0">NODE_CLASSES = {}</span>

<span class="s0">{{for dtype, dtype_title, closed, closed_title, cmp_left, cmp_right,</span>
      <span class="s0">cmp_left_converse, cmp_right_converse, fused_prefix in nodes}}</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class {{dtype_title}}Closed{{closed_title}}IntervalNode(IntervalNode):</span>
    <span class="s0">&quot;&quot;&quot;Non-terminal node for an IntervalTree</span>

    <span class="s0">Categorizes intervals by those that fall to the left, those that fall to</span>
    <span class="s0">the right, and those that overlap with the pivot.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef readonly:</span>
        <span class="s0">{{dtype_title}}Closed{{closed_title}}IntervalNode left_node, right_node</span>
        <span class="s0">{{dtype}}_t[:] center_left_values, center_right_values, left, right</span>
        <span class="s0">int64_t[:] center_left_indices, center_right_indices, indices</span>
        <span class="s0">{{dtype}}_t min_left, max_right</span>
        <span class="s0">{{dtype}}_t pivot</span>

    <span class="s0">def __init__(self,</span>
                 <span class="s0">ndarray[{{dtype}}_t, ndim=1] left,</span>
                 <span class="s0">ndarray[{{dtype}}_t, ndim=1] right,</span>
                 <span class="s0">ndarray[int64_t, ndim=1] indices,</span>
                 <span class="s0">int64_t leaf_size):</span>

        <span class="s0">self.n_elements = len(left)</span>
        <span class="s0">self.leaf_size = leaf_size</span>

        <span class="s0"># min_left and min_right are used to speed-up query by skipping</span>
        <span class="s0"># query on sub-nodes. If this node has size 0, query is cheap,</span>
        <span class="s0"># so these values don't matter.</span>
        <span class="s0">if left.size &gt; 0:</span>
            <span class="s0">self.min_left = left.min()</span>
            <span class="s0">self.max_right = right.max()</span>
        <span class="s0">else:</span>
            <span class="s0">self.min_left = 0</span>
            <span class="s0">self.max_right = 0</span>

        <span class="s0">if self.n_elements &lt;= leaf_size:</span>
            <span class="s0"># make this a terminal (leaf) node</span>
            <span class="s0">self.is_leaf_node = True</span>
            <span class="s0">self.left = left</span>
            <span class="s0">self.right = right</span>
            <span class="s0">self.indices = indices</span>
            <span class="s0">self.n_center = 0</span>
        <span class="s0">else:</span>
            <span class="s0"># calculate a pivot so we can create child nodes</span>
            <span class="s0">self.is_leaf_node = False</span>
            <span class="s0">self.pivot = np.median(left / 2 + right / 2)</span>
            <span class="s0">left_set, right_set, center_set = self.classify_intervals(</span>
                <span class="s0">left, right)</span>

            <span class="s0">self.left_node = self.new_child_node(left, right,</span>
                                                 <span class="s0">indices, left_set)</span>
            <span class="s0">self.right_node = self.new_child_node(left, right,</span>
                                                  <span class="s0">indices, right_set)</span>

            <span class="s0">self.center_left_values, self.center_left_indices = \</span>
                <span class="s0">sort_values_and_indices(left, indices, center_set)</span>
            <span class="s0">self.center_right_values, self.center_right_indices = \</span>
                <span class="s0">sort_values_and_indices(right, indices, center_set)</span>
            <span class="s0">self.n_center = len(self.center_left_indices)</span>

    <span class="s0">@cython.wraparound(False)</span>
    <span class="s0">@cython.boundscheck(False)</span>
    <span class="s0">cdef classify_intervals(self, {{dtype}}_t[:] left, {{dtype}}_t[:] right):</span>
        <span class="s0">&quot;&quot;&quot;Classify the given intervals based upon whether they fall to the</span>
        <span class="s0">left, right, or overlap with this node's pivot.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">Int64Vector left_ind, right_ind, overlapping_ind</span>
            <span class="s0">Py_ssize_t i</span>

        <span class="s0">left_ind = Int64Vector()</span>
        <span class="s0">right_ind = Int64Vector()</span>
        <span class="s0">overlapping_ind = Int64Vector()</span>

        <span class="s0">for i in range(self.n_elements):</span>
            <span class="s0">if right[i] {{cmp_right_converse}} self.pivot:</span>
                <span class="s0">left_ind.append(i)</span>
            <span class="s0">elif self.pivot {{cmp_left_converse}} left[i]:</span>
                <span class="s0">right_ind.append(i)</span>
            <span class="s0">else:</span>
                <span class="s0">overlapping_ind.append(i)</span>

        <span class="s0">return (left_ind.to_array(),</span>
                <span class="s0">right_ind.to_array(),</span>
                <span class="s0">overlapping_ind.to_array())</span>

    <span class="s0">cdef new_child_node(self,</span>
                        <span class="s0">ndarray[{{dtype}}_t, ndim=1] left,</span>
                        <span class="s0">ndarray[{{dtype}}_t, ndim=1] right,</span>
                        <span class="s0">ndarray[int64_t, ndim=1] indices,</span>
                        <span class="s0">ndarray[int64_t, ndim=1] subset):</span>
        <span class="s0">&quot;&quot;&quot;Create a new child node.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">left = take(left, subset)</span>
        <span class="s0">right = take(right, subset)</span>
        <span class="s0">indices = take(indices, subset)</span>
        <span class="s0">return {{dtype_title}}Closed{{closed_title}}IntervalNode(</span>
            <span class="s0">left, right, indices, self.leaf_size)</span>

    <span class="s0">@cython.wraparound(False)</span>
    <span class="s0">@cython.boundscheck(False)</span>
    <span class="s0">@cython.initializedcheck(False)</span>
    <span class="s0">cpdef query(self, Int64Vector result, {{fused_prefix}}scalar_t point):</span>
        <span class="s0">&quot;&quot;&quot;Recursively query this node and its sub-nodes for intervals that</span>
        <span class="s0">overlap with the query point.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">int64_t[:] indices</span>
            <span class="s0">{{dtype}}_t[:] values</span>
            <span class="s0">Py_ssize_t i</span>

        <span class="s0">if self.is_leaf_node:</span>
            <span class="s0"># Once we get down to a certain size, it doesn't make sense to</span>
            <span class="s0"># continue the binary tree structure. Instead, we use linear</span>
            <span class="s0"># search.</span>
            <span class="s0">for i in range(self.n_elements):</span>
                <span class="s0">if self.left[i] {{cmp_left}} point {{cmp_right}} self.right[i]:</span>
                    <span class="s0">result.append(self.indices[i])</span>
        <span class="s0">else:</span>
            <span class="s0"># There are child nodes. Based on comparing our query to the pivot,</span>
            <span class="s0"># look at the center values, then go to the relevant child.</span>
            <span class="s0">if point &lt; self.pivot:</span>
                <span class="s0">values = self.center_left_values</span>
                <span class="s0">indices = self.center_left_indices</span>
                <span class="s0">for i in range(self.n_center):</span>
                    <span class="s0">if not values[i] {{cmp_left}} point:</span>
                        <span class="s0">break</span>
                    <span class="s0">result.append(indices[i])</span>
                <span class="s0">if point {{cmp_right}} self.left_node.max_right:</span>
                    <span class="s0">self.left_node.query(result, point)</span>
            <span class="s0">elif point &gt; self.pivot:</span>
                <span class="s0">values = self.center_right_values</span>
                <span class="s0">indices = self.center_right_indices</span>
                <span class="s0">for i in range(self.n_center - 1, -1, -1):</span>
                    <span class="s0">if not point {{cmp_right}} values[i]:</span>
                        <span class="s0">break</span>
                    <span class="s0">result.append(indices[i])</span>
                <span class="s0">if self.right_node.min_left {{cmp_left}} point:</span>
                    <span class="s0">self.right_node.query(result, point)</span>
            <span class="s0">else:</span>
                <span class="s0">result.extend(self.center_left_indices)</span>


<span class="s0">NODE_CLASSES['{{dtype}}',</span>
             <span class="s0">'{{closed}}'] = {{dtype_title}}Closed{{closed_title}}IntervalNode</span>

<span class="s0">{{endfor}}</span>
</pre>
</body>
</html>