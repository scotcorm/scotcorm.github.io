<html>
<head>
<title>test_subclassing.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_subclassing.py</font>
</center></td></tr></table>
<pre><span class="s0"># pylint: disable-msg=W0611, W0612, W0511,R0201</span>
<span class="s2">&quot;&quot;&quot;Tests suite for MaskedArray &amp; subclassing. 
 
:author: Pierre Gerard-Marchant 
:contact: pierregm_at_uga_dot_edu 
:version: $Id: test_subclassing.py 3473 2007-10-29 15:18:13Z jarrod.millman $ 
 
&quot;&quot;&quot;</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">numpy.testing </span><span class="s3">import </span><span class="s1">assert_</span><span class="s3">, </span><span class="s1">assert_raises</span>
<span class="s3">from </span><span class="s1">numpy.ma.testutils </span><span class="s3">import </span><span class="s1">assert_equal</span>
<span class="s3">from </span><span class="s1">numpy.ma.core </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">array</span><span class="s3">, </span><span class="s1">arange</span><span class="s3">, </span><span class="s1">masked</span><span class="s3">, </span><span class="s1">MaskedArray</span><span class="s3">, </span><span class="s1">masked_array</span><span class="s3">, </span><span class="s1">log</span><span class="s3">, </span><span class="s1">add</span><span class="s3">, </span><span class="s1">hypot</span><span class="s3">,</span>
    <span class="s1">divide</span><span class="s3">, </span><span class="s1">asarray</span><span class="s3">, </span><span class="s1">asanyarray</span><span class="s3">, </span><span class="s1">nomask</span>
    <span class="s1">)</span>
<span class="s0"># from numpy.ma.core import (</span>

<span class="s3">def </span><span class="s1">assert_startswith(a</span><span class="s3">, </span><span class="s1">b):</span>
    <span class="s0"># produces a better error message than assert_(a.startswith(b))</span>
    <span class="s1">assert_equal(a[:len(b)]</span><span class="s3">, </span><span class="s1">b)</span>

<span class="s3">class </span><span class="s1">SubArray(np.ndarray):</span>
    <span class="s0"># Defines a generic np.ndarray subclass, that stores some metadata</span>
    <span class="s0"># in the  dictionary `info`.</span>
    <span class="s3">def </span><span class="s1">__new__(cls</span><span class="s3">,</span><span class="s1">arr</span><span class="s3">,</span><span class="s1">info={}):</span>
        <span class="s1">x = np.asanyarray(arr).view(cls)</span>
        <span class="s1">x.info = info.copy()</span>
        <span class="s3">return </span><span class="s1">x</span>

    <span class="s3">def </span><span class="s1">__array_finalize__(self</span><span class="s3">, </span><span class="s1">obj):</span>
        <span class="s3">if </span><span class="s1">callable(getattr(super()</span><span class="s3">, </span><span class="s4">'__array_finalize__'</span><span class="s3">, None</span><span class="s1">)):</span>
            <span class="s1">super().__array_finalize__(obj)</span>
        <span class="s1">self.info = getattr(obj</span><span class="s3">, </span><span class="s4">'info'</span><span class="s3">, </span><span class="s1">{}).copy()</span>
        <span class="s3">return</span>

    <span class="s3">def </span><span class="s1">__add__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">result = super().__add__(other)</span>
        <span class="s1">result.info[</span><span class="s4">'added'</span><span class="s1">] = result.info.get(</span><span class="s4">'added'</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) + </span><span class="s5">1</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">__iadd__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">result = super().__iadd__(other)</span>
        <span class="s1">result.info[</span><span class="s4">'iadded'</span><span class="s1">] = result.info.get(</span><span class="s4">'iadded'</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) + </span><span class="s5">1</span>
        <span class="s3">return </span><span class="s1">result</span>


<span class="s1">subarray = SubArray</span>


<span class="s3">class </span><span class="s1">SubMaskedArray(MaskedArray):</span>
    <span class="s2">&quot;&quot;&quot;Pure subclass of MaskedArray, keeping some info on subclass.&quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__new__(cls</span><span class="s3">, </span><span class="s1">info=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s1">obj = super().__new__(cls</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s1">obj._optinfo[</span><span class="s4">'info'</span><span class="s1">] = info</span>
        <span class="s3">return </span><span class="s1">obj</span>


<span class="s3">class </span><span class="s1">MSubArray(SubArray</span><span class="s3">, </span><span class="s1">MaskedArray):</span>

    <span class="s3">def </span><span class="s1">__new__(cls</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">info={}</span><span class="s3">, </span><span class="s1">mask=nomask):</span>
        <span class="s1">subarr = SubArray(data</span><span class="s3">, </span><span class="s1">info)</span>
        <span class="s1">_data = MaskedArray.__new__(cls</span><span class="s3">, </span><span class="s1">data=subarr</span><span class="s3">, </span><span class="s1">mask=mask)</span>
        <span class="s1">_data.info = subarr.info</span>
        <span class="s3">return </span><span class="s1">_data</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_series(self):</span>
        <span class="s1">_view = self.view(MaskedArray)</span>
        <span class="s1">_view._sharedmask = </span><span class="s3">False</span>
        <span class="s3">return </span><span class="s1">_view</span>

<span class="s1">msubarray = MSubArray</span>


<span class="s0"># Also a subclass that overrides __str__, __repr__ and __setitem__, disallowing</span>
<span class="s0"># setting to non-class values (and thus np.ma.core.masked_print_option)</span>
<span class="s0"># and overrides __array_wrap__, updating the info dict, to check that this</span>
<span class="s0"># doesn't get destroyed by MaskedArray._update_from.  But this one also needs</span>
<span class="s0"># its own iterator...</span>
<span class="s3">class </span><span class="s1">CSAIterator:</span>
    <span class="s2">&quot;&quot;&quot; 
    Flat iterator object that uses its own setter/getter 
    (works around ndarray.flat not propagating subclass setters/getters 
    see https://github.com/numpy/numpy/issues/4564) 
    roughly following MaskedIterator 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">a):</span>
        <span class="s1">self._original = a</span>
        <span class="s1">self._dataiter = a.view(np.ndarray).flat</span>

    <span class="s3">def </span><span class="s1">__iter__(self):</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">indx):</span>
        <span class="s1">out = self._dataiter.__getitem__(indx)</span>
        <span class="s3">if not </span><span class="s1">isinstance(out</span><span class="s3">, </span><span class="s1">np.ndarray):</span>
            <span class="s1">out = out.__array__()</span>
        <span class="s1">out = out.view(type(self._original))</span>
        <span class="s3">return </span><span class="s1">out</span>

    <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s1">self._dataiter[index] = self._original._validate_input(value)</span>

    <span class="s3">def </span><span class="s1">__next__(self):</span>
        <span class="s3">return </span><span class="s1">next(self._dataiter).__array__().view(type(self._original))</span>


<span class="s3">class </span><span class="s1">ComplicatedSubArray(SubArray):</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">return </span><span class="s4">f'myprefix </span><span class="s3">{</span><span class="s1">self.view(SubArray)</span><span class="s3">} </span><span class="s4">mypostfix'</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s0"># Return a repr that does not start with 'name('</span>
        <span class="s3">return </span><span class="s4">f'&lt;</span><span class="s3">{</span><span class="s1">self.__class__.__name__</span><span class="s3">} {</span><span class="s1">self</span><span class="s3">}</span><span class="s4">&gt;'</span>

    <span class="s3">def </span><span class="s1">_validate_input(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">if not </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">ComplicatedSubArray):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Can only set to MySubArray values&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">item</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0"># validation ensures direct assignment with ndarray or</span>
        <span class="s0"># masked_print_option will fail</span>
        <span class="s1">super().__setitem__(item</span><span class="s3">, </span><span class="s1">self._validate_input(value))</span>

    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">item):</span>
        <span class="s0"># ensure getter returns our own class also for scalars</span>
        <span class="s1">value = super().__getitem__(item)</span>
        <span class="s3">if not </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">np.ndarray):  </span><span class="s0"># scalar</span>
            <span class="s1">value = value.__array__().view(ComplicatedSubArray)</span>
        <span class="s3">return </span><span class="s1">value</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">flat(self):</span>
        <span class="s3">return </span><span class="s1">CSAIterator(self)</span>

    <span class="s1">@flat.setter</span>
    <span class="s3">def </span><span class="s1">flat(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s1">y = self.ravel()</span>
        <span class="s1">y[:] = value</span>

    <span class="s3">def </span><span class="s1">__array_wrap__(self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">context=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">obj = super().__array_wrap__(obj</span><span class="s3">, </span><span class="s1">context)</span>
        <span class="s3">if </span><span class="s1">context </span><span class="s3">is not None and </span><span class="s1">context[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">is </span><span class="s1">np.multiply:</span>
            <span class="s1">obj.info[</span><span class="s4">'multiplied'</span><span class="s1">] = obj.info.get(</span><span class="s4">'multiplied'</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) + </span><span class="s5">1</span>

        <span class="s3">return </span><span class="s1">obj</span>


<span class="s3">class </span><span class="s1">TestSubclassing:</span>
    <span class="s0"># Test suite for masked subclasses of ndarray.</span>

    <span class="s3">def </span><span class="s1">setup(self):</span>
        <span class="s1">x = np.arange(</span><span class="s5">5</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s4">'float'</span><span class="s1">)</span>
        <span class="s1">mx = msubarray(x</span><span class="s3">, </span><span class="s1">mask=[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">self.data = (x</span><span class="s3">, </span><span class="s1">mx)</span>

    <span class="s3">def </span><span class="s1">test_data_subclassing(self):</span>
        <span class="s0"># Tests whether the subclass is kept.</span>
        <span class="s1">x = np.arange(</span><span class="s5">5</span><span class="s1">)</span>
        <span class="s1">m = [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">xsub = SubArray(x)</span>
        <span class="s1">xmsub = masked_array(xsub</span><span class="s3">, </span><span class="s1">mask=m)</span>
        <span class="s1">assert_(isinstance(xmsub</span><span class="s3">, </span><span class="s1">MaskedArray))</span>
        <span class="s1">assert_equal(xmsub._data</span><span class="s3">, </span><span class="s1">xsub)</span>
        <span class="s1">assert_(isinstance(xmsub._data</span><span class="s3">, </span><span class="s1">SubArray))</span>

    <span class="s3">def </span><span class="s1">test_maskedarray_subclassing(self):</span>
        <span class="s0"># Tests subclassing MaskedArray</span>
        <span class="s1">(x</span><span class="s3">, </span><span class="s1">mx) = self.data</span>
        <span class="s1">assert_(isinstance(mx._data</span><span class="s3">, </span><span class="s1">subarray))</span>

    <span class="s3">def </span><span class="s1">test_masked_unary_operations(self):</span>
        <span class="s0"># Tests masked_unary_operation</span>
        <span class="s1">(x</span><span class="s3">, </span><span class="s1">mx) = self.data</span>
        <span class="s3">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s1">):</span>
            <span class="s1">assert_(isinstance(log(mx)</span><span class="s3">, </span><span class="s1">msubarray))</span>
            <span class="s1">assert_equal(log(x)</span><span class="s3">, </span><span class="s1">np.log(x))</span>

    <span class="s3">def </span><span class="s1">test_masked_binary_operations(self):</span>
        <span class="s0"># Tests masked_binary_operation</span>
        <span class="s1">(x</span><span class="s3">, </span><span class="s1">mx) = self.data</span>
        <span class="s0"># Result should be a msubarray</span>
        <span class="s1">assert_(isinstance(add(mx</span><span class="s3">, </span><span class="s1">mx)</span><span class="s3">, </span><span class="s1">msubarray))</span>
        <span class="s1">assert_(isinstance(add(mx</span><span class="s3">, </span><span class="s1">x)</span><span class="s3">, </span><span class="s1">msubarray))</span>
        <span class="s0"># Result should work</span>
        <span class="s1">assert_equal(add(mx</span><span class="s3">, </span><span class="s1">x)</span><span class="s3">, </span><span class="s1">mx+x)</span>
        <span class="s1">assert_(isinstance(add(mx</span><span class="s3">, </span><span class="s1">mx)._data</span><span class="s3">, </span><span class="s1">subarray))</span>
        <span class="s1">assert_(isinstance(add.outer(mx</span><span class="s3">, </span><span class="s1">mx)</span><span class="s3">, </span><span class="s1">msubarray))</span>
        <span class="s1">assert_(isinstance(hypot(mx</span><span class="s3">, </span><span class="s1">mx)</span><span class="s3">, </span><span class="s1">msubarray))</span>
        <span class="s1">assert_(isinstance(hypot(mx</span><span class="s3">, </span><span class="s1">x)</span><span class="s3">, </span><span class="s1">msubarray))</span>

    <span class="s3">def </span><span class="s1">test_masked_binary_operations2(self):</span>
        <span class="s0"># Tests domained_masked_binary_operation</span>
        <span class="s1">(x</span><span class="s3">, </span><span class="s1">mx) = self.data</span>
        <span class="s1">xmx = masked_array(mx.data.__array__()</span><span class="s3">, </span><span class="s1">mask=mx.mask)</span>
        <span class="s1">assert_(isinstance(divide(mx</span><span class="s3">, </span><span class="s1">mx)</span><span class="s3">, </span><span class="s1">msubarray))</span>
        <span class="s1">assert_(isinstance(divide(mx</span><span class="s3">, </span><span class="s1">x)</span><span class="s3">, </span><span class="s1">msubarray))</span>
        <span class="s1">assert_equal(divide(mx</span><span class="s3">, </span><span class="s1">mx)</span><span class="s3">, </span><span class="s1">divide(xmx</span><span class="s3">, </span><span class="s1">xmx))</span>

    <span class="s3">def </span><span class="s1">test_attributepropagation(self):</span>
        <span class="s1">x = array(arange(</span><span class="s5">5</span><span class="s1">)</span><span class="s3">, </span><span class="s1">mask=[</span><span class="s5">0</span><span class="s1">]+[</span><span class="s5">1</span><span class="s1">]*</span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">my = masked_array(subarray(x))</span>
        <span class="s1">ym = msubarray(x)</span>
        <span class="s0">#</span>
        <span class="s1">z = (my+</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(z</span><span class="s3">, </span><span class="s1">MaskedArray))</span>
        <span class="s1">assert_(</span><span class="s3">not </span><span class="s1">isinstance(z</span><span class="s3">, </span><span class="s1">MSubArray))</span>
        <span class="s1">assert_(isinstance(z._data</span><span class="s3">, </span><span class="s1">SubArray))</span>
        <span class="s1">assert_equal(z._data.info</span><span class="s3">, </span><span class="s1">{})</span>
        <span class="s0">#</span>
        <span class="s1">z = (ym+</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(z</span><span class="s3">, </span><span class="s1">MaskedArray))</span>
        <span class="s1">assert_(isinstance(z</span><span class="s3">, </span><span class="s1">MSubArray))</span>
        <span class="s1">assert_(isinstance(z._data</span><span class="s3">, </span><span class="s1">SubArray))</span>
        <span class="s1">assert_(z._data.info[</span><span class="s4">'added'</span><span class="s1">] &gt; </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0"># Test that inplace methods from data get used (gh-4617)</span>
        <span class="s1">ym += </span><span class="s5">1</span>
        <span class="s1">assert_(isinstance(ym</span><span class="s3">, </span><span class="s1">MaskedArray))</span>
        <span class="s1">assert_(isinstance(ym</span><span class="s3">, </span><span class="s1">MSubArray))</span>
        <span class="s1">assert_(isinstance(ym._data</span><span class="s3">, </span><span class="s1">SubArray))</span>
        <span class="s1">assert_(ym._data.info[</span><span class="s4">'iadded'</span><span class="s1">] &gt; </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">#</span>
        <span class="s1">ym._set_mask([</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(ym._mask</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">ym._series._set_mask([</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(ym._mask</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s0">#</span>
        <span class="s1">xsub = subarray(x</span><span class="s3">, </span><span class="s1">info={</span><span class="s4">'name'</span><span class="s1">:</span><span class="s4">'x'</span><span class="s1">})</span>
        <span class="s1">mxsub = masked_array(xsub)</span>
        <span class="s1">assert_(hasattr(mxsub</span><span class="s3">, </span><span class="s4">'info'</span><span class="s1">))</span>
        <span class="s1">assert_equal(mxsub.info</span><span class="s3">, </span><span class="s1">xsub.info)</span>

    <span class="s3">def </span><span class="s1">test_subclasspreservation(self):</span>
        <span class="s0"># Checks that masked_array(...,subok=True) preserves the class.</span>
        <span class="s1">x = np.arange(</span><span class="s5">5</span><span class="s1">)</span>
        <span class="s1">m = [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">xinfo = [(i</span><span class="s3">, </span><span class="s1">j) </span><span class="s3">for </span><span class="s1">(i</span><span class="s3">, </span><span class="s1">j) </span><span class="s3">in </span><span class="s1">zip(x</span><span class="s3">, </span><span class="s1">m)]</span>
        <span class="s1">xsub = MSubArray(x</span><span class="s3">, </span><span class="s1">mask=m</span><span class="s3">, </span><span class="s1">info={</span><span class="s4">'xsub'</span><span class="s1">:xinfo})</span>
        <span class="s0">#</span>
        <span class="s1">mxsub = masked_array(xsub</span><span class="s3">, </span><span class="s1">subok=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">assert_(</span><span class="s3">not </span><span class="s1">isinstance(mxsub</span><span class="s3">, </span><span class="s1">MSubArray))</span>
        <span class="s1">assert_(isinstance(mxsub</span><span class="s3">, </span><span class="s1">MaskedArray))</span>
        <span class="s1">assert_equal(mxsub._mask</span><span class="s3">, </span><span class="s1">m)</span>
        <span class="s0">#</span>
        <span class="s1">mxsub = asarray(xsub)</span>
        <span class="s1">assert_(</span><span class="s3">not </span><span class="s1">isinstance(mxsub</span><span class="s3">, </span><span class="s1">MSubArray))</span>
        <span class="s1">assert_(isinstance(mxsub</span><span class="s3">, </span><span class="s1">MaskedArray))</span>
        <span class="s1">assert_equal(mxsub._mask</span><span class="s3">, </span><span class="s1">m)</span>
        <span class="s0">#</span>
        <span class="s1">mxsub = masked_array(xsub</span><span class="s3">, </span><span class="s1">subok=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(mxsub</span><span class="s3">, </span><span class="s1">MSubArray))</span>
        <span class="s1">assert_equal(mxsub.info</span><span class="s3">, </span><span class="s1">xsub.info)</span>
        <span class="s1">assert_equal(mxsub._mask</span><span class="s3">, </span><span class="s1">xsub._mask)</span>
        <span class="s0">#</span>
        <span class="s1">mxsub = asanyarray(xsub)</span>
        <span class="s1">assert_(isinstance(mxsub</span><span class="s3">, </span><span class="s1">MSubArray))</span>
        <span class="s1">assert_equal(mxsub.info</span><span class="s3">, </span><span class="s1">xsub.info)</span>
        <span class="s1">assert_equal(mxsub._mask</span><span class="s3">, </span><span class="s1">m)</span>

    <span class="s3">def </span><span class="s1">test_subclass_items(self):</span>
        <span class="s2">&quot;&quot;&quot;test that getter and setter go via baseclass&quot;&quot;&quot;</span>
        <span class="s1">x = np.arange(</span><span class="s5">5</span><span class="s1">)</span>
        <span class="s1">xcsub = ComplicatedSubArray(x)</span>
        <span class="s1">mxcsub = masked_array(xcsub</span><span class="s3">, </span><span class="s1">mask=[</span><span class="s3">True, False, True, False, False</span><span class="s1">])</span>
        <span class="s0"># getter should  return a ComplicatedSubArray, even for single item</span>
        <span class="s0"># first check we wrote ComplicatedSubArray correctly</span>
        <span class="s1">assert_(isinstance(xcsub[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ComplicatedSubArray))</span>
        <span class="s1">assert_(isinstance(xcsub[</span><span class="s5">1</span><span class="s3">,</span><span class="s1">...]</span><span class="s3">, </span><span class="s1">ComplicatedSubArray))</span>
        <span class="s1">assert_(isinstance(xcsub[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">4</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ComplicatedSubArray))</span>

        <span class="s0"># now that it propagates inside the MaskedArray</span>
        <span class="s1">assert_(isinstance(mxcsub[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ComplicatedSubArray))</span>
        <span class="s1">assert_(isinstance(mxcsub[</span><span class="s5">1</span><span class="s3">,</span><span class="s1">...].data</span><span class="s3">, </span><span class="s1">ComplicatedSubArray))</span>
        <span class="s1">assert_(mxcsub[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">is </span><span class="s1">masked)</span>
        <span class="s1">assert_(isinstance(mxcsub[</span><span class="s5">0</span><span class="s3">,</span><span class="s1">...].data</span><span class="s3">, </span><span class="s1">ComplicatedSubArray))</span>
        <span class="s1">assert_(isinstance(mxcsub[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">4</span><span class="s1">].data</span><span class="s3">, </span><span class="s1">ComplicatedSubArray))</span>

        <span class="s0"># also for flattened version (which goes via MaskedIterator)</span>
        <span class="s1">assert_(isinstance(mxcsub.flat[</span><span class="s5">1</span><span class="s1">].data</span><span class="s3">, </span><span class="s1">ComplicatedSubArray))</span>
        <span class="s1">assert_(mxcsub.flat[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">is </span><span class="s1">masked)</span>
        <span class="s1">assert_(isinstance(mxcsub.flat[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">4</span><span class="s1">].base</span><span class="s3">, </span><span class="s1">ComplicatedSubArray))</span>

        <span class="s0"># setter should only work with ComplicatedSubArray input</span>
        <span class="s0"># first check we wrote ComplicatedSubArray correctly</span>
        <span class="s1">assert_raises(ValueError</span><span class="s3">, </span><span class="s1">xcsub.__setitem__</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">x[</span><span class="s5">4</span><span class="s1">])</span>
        <span class="s0"># now that it propagates inside the MaskedArray</span>
        <span class="s1">assert_raises(ValueError</span><span class="s3">, </span><span class="s1">mxcsub.__setitem__</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">x[</span><span class="s5">4</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s3">, </span><span class="s1">mxcsub.__setitem__</span><span class="s3">, </span><span class="s1">slice(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">x[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">4</span><span class="s1">])</span>
        <span class="s1">mxcsub[</span><span class="s5">1</span><span class="s1">] = xcsub[</span><span class="s5">4</span><span class="s1">]</span>
        <span class="s1">mxcsub[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">4</span><span class="s1">] = xcsub[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">4</span><span class="s1">]</span>
        <span class="s0"># also for flattened version (which goes via MaskedIterator)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s3">, </span><span class="s1">mxcsub.flat.__setitem__</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">x[</span><span class="s5">4</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s3">, </span><span class="s1">mxcsub.flat.__setitem__</span><span class="s3">, </span><span class="s1">slice(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">x[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">4</span><span class="s1">])</span>
        <span class="s1">mxcsub.flat[</span><span class="s5">1</span><span class="s1">] = xcsub[</span><span class="s5">4</span><span class="s1">]</span>
        <span class="s1">mxcsub.flat[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">4</span><span class="s1">] = xcsub[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">4</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">test_subclass_nomask_items(self):</span>
        <span class="s1">x = np.arange(</span><span class="s5">5</span><span class="s1">)</span>
        <span class="s1">xcsub = ComplicatedSubArray(x)</span>
        <span class="s1">mxcsub_nomask = masked_array(xcsub)</span>

        <span class="s1">assert_(isinstance(mxcsub_nomask[</span><span class="s5">1</span><span class="s3">,</span><span class="s1">...].data</span><span class="s3">, </span><span class="s1">ComplicatedSubArray))</span>
        <span class="s1">assert_(isinstance(mxcsub_nomask[</span><span class="s5">0</span><span class="s3">,</span><span class="s1">...].data</span><span class="s3">, </span><span class="s1">ComplicatedSubArray))</span>

        <span class="s1">assert_(isinstance(mxcsub_nomask[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ComplicatedSubArray))</span>
        <span class="s1">assert_(isinstance(mxcsub_nomask[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ComplicatedSubArray))</span>

    <span class="s3">def </span><span class="s1">test_subclass_repr(self):</span>
        <span class="s2">&quot;&quot;&quot;test that repr uses the name of the subclass 
        and 'array' for np.ndarray&quot;&quot;&quot;</span>
        <span class="s1">x = np.arange(</span><span class="s5">5</span><span class="s1">)</span>
        <span class="s1">mx = masked_array(x</span><span class="s3">, </span><span class="s1">mask=[</span><span class="s3">True, False, True, False, False</span><span class="s1">])</span>
        <span class="s1">assert_startswith(repr(mx)</span><span class="s3">, </span><span class="s4">'masked_array'</span><span class="s1">)</span>
        <span class="s1">xsub = SubArray(x)</span>
        <span class="s1">mxsub = masked_array(xsub</span><span class="s3">, </span><span class="s1">mask=[</span><span class="s3">True, False, True, False, False</span><span class="s1">])</span>
        <span class="s1">assert_startswith(repr(mxsub)</span><span class="s3">, </span>
            <span class="s4">f'masked_</span><span class="s3">{</span><span class="s1">SubArray.__name__</span><span class="s3">}</span><span class="s4">(data=[--, 1, --, 3, 4]'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_subclass_str(self):</span>
        <span class="s2">&quot;&quot;&quot;test str with subclass that has overridden str, setitem&quot;&quot;&quot;</span>
        <span class="s0"># first without override</span>
        <span class="s1">x = np.arange(</span><span class="s5">5</span><span class="s1">)</span>
        <span class="s1">xsub = SubArray(x)</span>
        <span class="s1">mxsub = masked_array(xsub</span><span class="s3">, </span><span class="s1">mask=[</span><span class="s3">True, False, True, False, False</span><span class="s1">])</span>
        <span class="s1">assert_equal(str(mxsub)</span><span class="s3">, </span><span class="s4">'[-- 1 -- 3 4]'</span><span class="s1">)</span>

        <span class="s1">xcsub = ComplicatedSubArray(x)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s3">, </span><span class="s1">xcsub.__setitem__</span><span class="s3">, </span><span class="s5">0</span><span class="s3">,</span>
                      <span class="s1">np.ma.core.masked_print_option)</span>
        <span class="s1">mxcsub = masked_array(xcsub</span><span class="s3">, </span><span class="s1">mask=[</span><span class="s3">True, False, True, False, False</span><span class="s1">])</span>
        <span class="s1">assert_equal(str(mxcsub)</span><span class="s3">, </span><span class="s4">'myprefix [-- 1 -- 3 4] mypostfix'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_pure_subclass_info_preservation(self):</span>
        <span class="s0"># Test that ufuncs and methods conserve extra information consistently;</span>
        <span class="s0"># see gh-7122.</span>
        <span class="s1">arr1 = SubMaskedArray(</span><span class="s4">'test'</span><span class="s3">, </span><span class="s1">data=[</span><span class="s5">1</span><span class="s3">,</span><span class="s5">2</span><span class="s3">,</span><span class="s5">3</span><span class="s3">,</span><span class="s5">4</span><span class="s3">,</span><span class="s5">5</span><span class="s3">,</span><span class="s5">6</span><span class="s1">])</span>
        <span class="s1">arr2 = SubMaskedArray(data=[</span><span class="s5">0</span><span class="s3">,</span><span class="s5">1</span><span class="s3">,</span><span class="s5">2</span><span class="s3">,</span><span class="s5">3</span><span class="s3">,</span><span class="s5">4</span><span class="s3">,</span><span class="s5">5</span><span class="s1">])</span>
        <span class="s1">diff1 = np.subtract(arr1</span><span class="s3">, </span><span class="s1">arr2)</span>
        <span class="s1">assert_(</span><span class="s4">'info' </span><span class="s3">in </span><span class="s1">diff1._optinfo)</span>
        <span class="s1">assert_(diff1._optinfo[</span><span class="s4">'info'</span><span class="s1">] == </span><span class="s4">'test'</span><span class="s1">)</span>
        <span class="s1">diff2 = arr1 - arr2</span>
        <span class="s1">assert_(</span><span class="s4">'info' </span><span class="s3">in </span><span class="s1">diff2._optinfo)</span>
        <span class="s1">assert_(diff2._optinfo[</span><span class="s4">'info'</span><span class="s1">] == </span><span class="s4">'test'</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">ArrayNoInheritance:</span>
    <span class="s2">&quot;&quot;&quot;Quantity-like class that does not inherit from ndarray&quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">units):</span>
        <span class="s1">self.magnitude = data</span>
        <span class="s1">self.units = units</span>

    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">attr):</span>
        <span class="s3">return </span><span class="s1">getattr(self.magnitude</span><span class="s3">, </span><span class="s1">attr)</span>


<span class="s3">def </span><span class="s1">test_array_no_inheritance():</span>
    <span class="s1">data_masked = np.ma.array([</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">]</span><span class="s3">, </span><span class="s1">mask=[</span><span class="s3">True, False, True</span><span class="s1">])</span>
    <span class="s1">data_masked_units = ArrayNoInheritance(data_masked</span><span class="s3">, </span><span class="s4">'meters'</span><span class="s1">)</span>

    <span class="s0"># Get the masked representation of the Quantity-like class</span>
    <span class="s1">new_array = np.ma.array(data_masked_units)</span>
    <span class="s1">assert_equal(data_masked.data</span><span class="s3">, </span><span class="s1">new_array.data)</span>
    <span class="s1">assert_equal(data_masked.mask</span><span class="s3">, </span><span class="s1">new_array.mask)</span>
    <span class="s0"># Test sharing the mask</span>
    <span class="s1">data_masked.mask = [</span><span class="s3">True, False, False</span><span class="s1">]</span>
    <span class="s1">assert_equal(data_masked.mask</span><span class="s3">, </span><span class="s1">new_array.mask)</span>
    <span class="s1">assert_(new_array.sharedmask)</span>

    <span class="s0"># Get the masked representation of the Quantity-like class</span>
    <span class="s1">new_array = np.ma.array(data_masked_units</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">assert_equal(data_masked.data</span><span class="s3">, </span><span class="s1">new_array.data)</span>
    <span class="s1">assert_equal(data_masked.mask</span><span class="s3">, </span><span class="s1">new_array.mask)</span>
    <span class="s0"># Test that the mask is not shared when copy=True</span>
    <span class="s1">data_masked.mask = [</span><span class="s3">True, False, True</span><span class="s1">]</span>
    <span class="s1">assert_equal([</span><span class="s3">True, False, False</span><span class="s1">]</span><span class="s3">, </span><span class="s1">new_array.mask)</span>
    <span class="s1">assert_(</span><span class="s3">not </span><span class="s1">new_array.sharedmask)</span>

    <span class="s0"># Get the masked representation of the Quantity-like class</span>
    <span class="s1">new_array = np.ma.array(data_masked_units</span><span class="s3">, </span><span class="s1">keep_mask=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s1">assert_equal(data_masked.data</span><span class="s3">, </span><span class="s1">new_array.data)</span>
    <span class="s0"># The change did not affect the original mask</span>
    <span class="s1">assert_equal(data_masked.mask</span><span class="s3">, </span><span class="s1">[</span><span class="s3">True, False, True</span><span class="s1">])</span>
    <span class="s0"># Test that the mask is False and not shared when keep_mask=False</span>
    <span class="s1">assert_(</span><span class="s3">not </span><span class="s1">new_array.mask)</span>
    <span class="s1">assert_(</span><span class="s3">not </span><span class="s1">new_array.sharedmask)</span>
</pre>
</body>
</html>