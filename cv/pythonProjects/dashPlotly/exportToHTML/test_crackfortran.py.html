<html>
<head>
<title>test_crackfortran.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #a5c261;}
.s6 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_crackfortran.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_array_equal</span><span class="s0">, </span><span class="s1">assert_equal</span>
<span class="s0">from </span><span class="s1">numpy.f2py.crackfortran </span><span class="s0">import </span><span class="s1">markinnerspaces</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">util</span>
<span class="s0">from </span><span class="s1">numpy.f2py </span><span class="s0">import </span><span class="s1">crackfortran</span>
<span class="s0">import </span><span class="s1">textwrap</span>


<span class="s0">class </span><span class="s1">TestNoSpace(util.F2PyTest):</span>
    <span class="s2"># issue gh-15035: add handling for endsubroutine, endfunction with no space</span>
    <span class="s2"># between &quot;end&quot; and the block name</span>
    <span class="s1">code = </span><span class="s3">&quot;&quot;&quot; 
        subroutine subb(k) 
          real(8), intent(inout) :: k(:) 
          k=k+1 
        endsubroutine 
 
        subroutine subc(w,k) 
          real(8), intent(in) :: w(:) 
          real(8), intent(out) :: k(size(w)) 
          k=w+1 
        endsubroutine 
 
        function t0(value) 
          character value 
          character t0 
          t0 = value 
        endfunction 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_module(self):</span>
        <span class="s1">k = np.array([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">w = np.array([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">self.module.subb(k)</span>
        <span class="s1">assert_array_equal(k</span><span class="s0">, </span><span class="s1">w + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.module.subc([w</span><span class="s0">, </span><span class="s1">k])</span>
        <span class="s1">assert_array_equal(k</span><span class="s0">, </span><span class="s1">w + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">self.module.t0(</span><span class="s4">23</span><span class="s1">) == </span><span class="s5">b'2'</span>


<span class="s0">class </span><span class="s1">TestPublicPrivate():</span>

    <span class="s0">def </span><span class="s1">test_defaultPrivate(self</span><span class="s0">, </span><span class="s1">tmp_path):</span>
        <span class="s1">f_path = tmp_path / </span><span class="s3">&quot;mod.f90&quot;</span>
        <span class="s0">with </span><span class="s1">f_path.open(</span><span class="s3">'w'</span><span class="s1">) </span><span class="s0">as </span><span class="s1">ff:</span>
            <span class="s1">ff.write(textwrap.dedent(</span><span class="s3">&quot;&quot;&quot;</span><span class="s0">\ 
            </span><span class="s3">module foo 
              private 
              integer :: a 
              public :: setA 
              integer :: b 
            contains 
              subroutine setA(v) 
                integer, intent(in) :: v 
                a = v 
              end subroutine setA 
            end module foo 
            &quot;&quot;&quot;</span><span class="s1">))</span>
        <span class="s1">mod = crackfortran.crackfortran([str(f_path)])</span>
        <span class="s0">assert </span><span class="s1">len(mod) == </span><span class="s4">1</span>
        <span class="s1">mod = mod[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">'private' </span><span class="s0">in </span><span class="s1">mod[</span><span class="s3">'vars'</span><span class="s1">][</span><span class="s3">'a'</span><span class="s1">][</span><span class="s3">'attrspec'</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">'public' </span><span class="s0">not in </span><span class="s1">mod[</span><span class="s3">'vars'</span><span class="s1">][</span><span class="s3">'a'</span><span class="s1">][</span><span class="s3">'attrspec'</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">'private' </span><span class="s0">in </span><span class="s1">mod[</span><span class="s3">'vars'</span><span class="s1">][</span><span class="s3">'b'</span><span class="s1">][</span><span class="s3">'attrspec'</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">'public' </span><span class="s0">not in </span><span class="s1">mod[</span><span class="s3">'vars'</span><span class="s1">][</span><span class="s3">'b'</span><span class="s1">][</span><span class="s3">'attrspec'</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">'private' </span><span class="s0">not in </span><span class="s1">mod[</span><span class="s3">'vars'</span><span class="s1">][</span><span class="s3">'seta'</span><span class="s1">][</span><span class="s3">'attrspec'</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">'public' </span><span class="s0">in </span><span class="s1">mod[</span><span class="s3">'vars'</span><span class="s1">][</span><span class="s3">'seta'</span><span class="s1">][</span><span class="s3">'attrspec'</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_defaultPublic(self</span><span class="s0">, </span><span class="s1">tmp_path):</span>
        <span class="s1">f_path = tmp_path / </span><span class="s3">&quot;mod.f90&quot;</span>
        <span class="s0">with </span><span class="s1">f_path.open(</span><span class="s3">'w'</span><span class="s1">) </span><span class="s0">as </span><span class="s1">ff:</span>
            <span class="s1">ff.write(textwrap.dedent(</span><span class="s3">&quot;&quot;&quot;</span><span class="s0">\ 
            </span><span class="s3">module foo 
              public 
              integer, private :: a 
              public :: setA 
            contains 
              subroutine setA(v) 
                integer, intent(in) :: v 
                a = v 
              end subroutine setA 
            end module foo 
            &quot;&quot;&quot;</span><span class="s1">))</span>
        <span class="s1">mod = crackfortran.crackfortran([str(f_path)])</span>
        <span class="s0">assert </span><span class="s1">len(mod) == </span><span class="s4">1</span>
        <span class="s1">mod = mod[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">'private' </span><span class="s0">in </span><span class="s1">mod[</span><span class="s3">'vars'</span><span class="s1">][</span><span class="s3">'a'</span><span class="s1">][</span><span class="s3">'attrspec'</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">'public' </span><span class="s0">not in </span><span class="s1">mod[</span><span class="s3">'vars'</span><span class="s1">][</span><span class="s3">'a'</span><span class="s1">][</span><span class="s3">'attrspec'</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">'private' </span><span class="s0">not in </span><span class="s1">mod[</span><span class="s3">'vars'</span><span class="s1">][</span><span class="s3">'seta'</span><span class="s1">][</span><span class="s3">'attrspec'</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">'public' </span><span class="s0">in </span><span class="s1">mod[</span><span class="s3">'vars'</span><span class="s1">][</span><span class="s3">'seta'</span><span class="s1">][</span><span class="s3">'attrspec'</span><span class="s1">]</span>


<span class="s0">class </span><span class="s1">TestExternal(util.F2PyTest):</span>
    <span class="s2"># issue gh-17859: add external attribute support</span>
    <span class="s1">code = </span><span class="s3">&quot;&quot;&quot; 
        integer(8) function external_as_statement(fcn) 
        implicit none 
        external fcn 
        integer(8) :: fcn 
        external_as_statement = fcn(0) 
        end 
 
        integer(8) function external_as_attribute(fcn) 
        implicit none 
        integer(8), external :: fcn 
        external_as_attribute = fcn(0) 
        end 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_external_as_statement(self):</span>
        <span class="s0">def </span><span class="s1">incr(x):</span>
            <span class="s0">return </span><span class="s1">x + </span><span class="s4">123</span>
        <span class="s1">r = self.module.external_as_statement(incr)</span>
        <span class="s0">assert </span><span class="s1">r == </span><span class="s4">123</span>

    <span class="s0">def </span><span class="s1">test_external_as_attribute(self):</span>
        <span class="s0">def </span><span class="s1">incr(x):</span>
            <span class="s0">return </span><span class="s1">x + </span><span class="s4">123</span>
        <span class="s1">r = self.module.external_as_attribute(incr)</span>
        <span class="s0">assert </span><span class="s1">r == </span><span class="s4">123</span>


<span class="s0">class </span><span class="s1">TestCrackFortran(util.F2PyTest):</span>

    <span class="s1">suffix = </span><span class="s3">'.f90'</span>

    <span class="s1">code = textwrap.dedent(</span><span class="s3">&quot;&quot;&quot; 
      subroutine gh2848( &amp; 
        ! first 2 parameters 
        par1, par2,&amp; 
        ! last 2 parameters 
        par3, par4) 
 
        integer, intent(in)  :: par1, par2 
        integer, intent(out) :: par3, par4 
 
        par3 = par1 
        par4 = par2 
 
      end subroutine gh2848 
    &quot;&quot;&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_gh2848(self):</span>
        <span class="s1">r = self.module.gh2848(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">r == (</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestMarkinnerspaces():</span>
    <span class="s2"># issue #14118: markinnerspaces does not handle multiple quotations</span>

    <span class="s0">def </span><span class="s1">test_do_not_touch_normal_spaces(self):</span>
        <span class="s1">test_list = [</span><span class="s3">&quot;a &quot;</span><span class="s0">, </span><span class="s3">&quot; a&quot;</span><span class="s0">, </span><span class="s3">&quot;a b c&quot;</span><span class="s0">, </span><span class="s3">&quot;'abcdefghij'&quot;</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">test_list:</span>
            <span class="s1">assert_equal(markinnerspaces(i)</span><span class="s0">, </span><span class="s1">i)</span>

    <span class="s0">def </span><span class="s1">test_one_relevant_space(self):</span>
        <span class="s1">assert_equal(markinnerspaces(</span><span class="s3">&quot;a 'b c' </span><span class="s0">\\\' \\\'</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">&quot;a 'b@_@c' </span><span class="s0">\\</span><span class="s3">' </span><span class="s0">\\</span><span class="s3">'&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(markinnerspaces(</span><span class="s3">r'a &quot;b c&quot; \&quot; \&quot;'</span><span class="s1">)</span><span class="s0">, </span><span class="s3">r'a &quot;b@_@c&quot; \&quot; \&quot;'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_ignore_inner_quotes(self):</span>
        <span class="s1">assert_equal(markinnerspaces(</span><span class="s3">'a </span><span class="s0">\'</span><span class="s3">b c&quot; &quot; d</span><span class="s0">\' </span><span class="s3">e'</span><span class="s1">)</span><span class="s0">,</span>
                     <span class="s3">&quot;a 'b@_@c</span><span class="s0">\&quot;</span><span class="s3">@_@</span><span class="s0">\&quot;</span><span class="s3">@_@d' e&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(markinnerspaces(</span><span class="s3">'a &quot;b c</span><span class="s0">\' \' </span><span class="s3">d&quot; e'</span><span class="s1">)</span><span class="s0">,</span>
                     <span class="s3">&quot;a </span><span class="s0">\&quot;</span><span class="s3">b@_@c'@_@'@_@d</span><span class="s0">\&quot; </span><span class="s3">e&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_multiple_relevant_spaces(self):</span>
        <span class="s1">assert_equal(markinnerspaces(</span><span class="s3">&quot;a 'b c' 'd e'&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">&quot;a 'b@_@c' 'd@_@e'&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(markinnerspaces(</span><span class="s3">r'a &quot;b c&quot; &quot;d e&quot;'</span><span class="s1">)</span><span class="s0">, </span><span class="s3">r'a &quot;b@_@c&quot; &quot;d@_@e&quot;'</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestDimSpec(util.F2PyTest):</span>
    <span class="s6">&quot;&quot;&quot;This test suite tests various expressions that are used as dimension 
    specifications. 
 
    There exists two usage cases where analyzing dimensions 
    specifications are important. 
 
    In the first case, the size of output arrays must be defined based 
    on the inputs to a Fortran function. Because Fortran supports 
    arbitrary bases for indexing, for instance, `arr(lower:upper)`, 
    f2py has to evaluate an expression `upper - lower + 1` where 
    `lower` and `upper` are arbitrary expressions of input parameters. 
    The evaluation is performed in C, so f2py has to translate Fortran 
    expressions to valid C expressions (an alternative approach is 
    that a developer specifies the corresponding C expressions in a 
    .pyf file). 
 
    In the second case, when user provides an input array with a given 
    size but some hidden parameters used in dimensions specifications 
    need to be determined based on the input array size. This is a 
    harder problem because f2py has to solve the inverse problem: find 
    a parameter `p` such that `upper(p) - lower(p) + 1` equals to the 
    size of input array. In the case when this equation cannot be 
    solved (e.g. because the input array size is wrong), raise an 
    error before calling the Fortran function (that otherwise would 
    likely crash Python process when the size of input arrays is 
    wrong). f2py currently supports this case only when the equation 
    is linear with respect to unknown parameter. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">suffix = </span><span class="s3">'.f90'</span>

    <span class="s1">code_template = textwrap.dedent(</span><span class="s3">&quot;&quot;&quot; 
      function get_arr_size_{count}(a, n) result (length) 
        integer, intent(in) :: n 
        integer, dimension({dimspec}), intent(out) :: a 
        integer length 
        length = size(a) 
      end function 
 
      subroutine get_inv_arr_size_{count}(a, n) 
        integer :: n 
        ! the value of n is computed in f2py wrapper 
        !f2py intent(out) n 
        integer, dimension({dimspec}), intent(in) :: a 
        if (a({first}).gt.0) then 
          print*, &quot;a=&quot;, a 
        endif 
      end subroutine 
    &quot;&quot;&quot;</span><span class="s1">)</span>

    <span class="s1">linear_dimspecs = [</span>
        <span class="s3">&quot;n&quot;</span><span class="s0">, </span><span class="s3">&quot;2*n&quot;</span><span class="s0">, </span><span class="s3">&quot;2:n&quot;</span><span class="s0">, </span><span class="s3">&quot;n/2&quot;</span><span class="s0">, </span><span class="s3">&quot;5 - n/2&quot;</span><span class="s0">, </span><span class="s3">&quot;3*n:20&quot;</span><span class="s0">, </span><span class="s3">&quot;n*(n+1):n*(n+5)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;2*n, n&quot;</span>
    <span class="s1">]</span>
    <span class="s1">nonlinear_dimspecs = [</span><span class="s3">&quot;2*n:3*n*n+2*n&quot;</span><span class="s1">]</span>
    <span class="s1">all_dimspecs = linear_dimspecs + nonlinear_dimspecs</span>

    <span class="s1">code = </span><span class="s3">''</span>
    <span class="s0">for </span><span class="s1">count</span><span class="s0">, </span><span class="s1">dimspec </span><span class="s0">in </span><span class="s1">enumerate(all_dimspecs):</span>
        <span class="s1">lst = [(d.split(</span><span class="s3">&quot;:&quot;</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">if </span><span class="s3">&quot;:&quot; </span><span class="s0">in </span><span class="s1">d </span><span class="s0">else </span><span class="s3">&quot;1&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">dimspec.split(</span><span class="s3">','</span><span class="s1">)]</span>
        <span class="s1">code += code_template.format(</span>
            <span class="s1">count=count</span><span class="s0">,</span>
            <span class="s1">dimspec=dimspec</span><span class="s0">,</span>
            <span class="s1">first=</span><span class="s3">&quot;, &quot;</span><span class="s1">.join(lst)</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dimspec'</span><span class="s0">, </span><span class="s1">all_dimspecs)</span>
    <span class="s0">def </span><span class="s1">test_array_size(self</span><span class="s0">, </span><span class="s1">dimspec):</span>

        <span class="s1">count = self.all_dimspecs.index(dimspec)</span>
        <span class="s1">get_arr_size = getattr(self.module</span><span class="s0">, </span><span class="s3">f'get_arr_size_</span><span class="s0">{</span><span class="s1">count</span><span class="s0">}</span><span class="s3">'</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s1">]:</span>
            <span class="s1">sz</span><span class="s0">, </span><span class="s1">a = get_arr_size(n)</span>
            <span class="s0">assert </span><span class="s1">a.size == sz</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dimspec'</span><span class="s0">, </span><span class="s1">all_dimspecs)</span>
    <span class="s0">def </span><span class="s1">test_inv_array_size(self</span><span class="s0">, </span><span class="s1">dimspec):</span>

        <span class="s1">count = self.all_dimspecs.index(dimspec)</span>
        <span class="s1">get_arr_size = getattr(self.module</span><span class="s0">, </span><span class="s3">f'get_arr_size_</span><span class="s0">{</span><span class="s1">count</span><span class="s0">}</span><span class="s3">'</span><span class="s1">)</span>
        <span class="s1">get_inv_arr_size = getattr(self.module</span><span class="s0">, </span><span class="s3">f'get_inv_arr_size_</span><span class="s0">{</span><span class="s1">count</span><span class="s0">}</span><span class="s3">'</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s1">]:</span>
            <span class="s1">sz</span><span class="s0">, </span><span class="s1">a = get_arr_size(n)</span>
            <span class="s0">if </span><span class="s1">dimspec </span><span class="s0">in </span><span class="s1">self.nonlinear_dimspecs:</span>
                <span class="s2"># one must specify n as input, the call we'll ensure</span>
                <span class="s2"># that a and n are compatible:</span>
                <span class="s1">n1 = get_inv_arr_size(a</span><span class="s0">, </span><span class="s1">n)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># in case of linear dependence, n can be determined</span>
                <span class="s2"># from the shape of a:</span>
                <span class="s1">n1 = get_inv_arr_size(a)</span>
            <span class="s2"># n1 may be different from n (for instance, when `a` size</span>
            <span class="s2"># is a function of some `n` fraction) but it must produce</span>
            <span class="s2"># the same sized array</span>
            <span class="s1">sz1</span><span class="s0">, </span><span class="s1">_ = get_arr_size(n1)</span>
            <span class="s0">assert </span><span class="s1">sz == sz1</span><span class="s0">, </span><span class="s1">(n</span><span class="s0">, </span><span class="s1">n1</span><span class="s0">, </span><span class="s1">sz</span><span class="s0">, </span><span class="s1">sz1)</span>


<span class="s0">class </span><span class="s1">TestModuleDeclaration():</span>
    <span class="s0">def </span><span class="s1">test_dependencies(self</span><span class="s0">, </span><span class="s1">tmp_path):</span>
        <span class="s1">f_path = tmp_path / </span><span class="s3">&quot;mod.f90&quot;</span>
        <span class="s0">with </span><span class="s1">f_path.open(</span><span class="s3">'w'</span><span class="s1">) </span><span class="s0">as </span><span class="s1">ff:</span>
            <span class="s1">ff.write(textwrap.dedent(</span><span class="s3">&quot;&quot;&quot;</span><span class="s0">\ 
            </span><span class="s3">module foo 
              type bar 
                character(len = 4) :: text 
              end type bar 
              type(bar), parameter :: abar = bar('abar') 
            end module foo 
            &quot;&quot;&quot;</span><span class="s1">))</span>
        <span class="s1">mod = crackfortran.crackfortran([str(f_path)])</span>
        <span class="s0">assert </span><span class="s1">len(mod) == </span><span class="s4">1</span>
        <span class="s0">assert </span><span class="s1">mod[</span><span class="s4">0</span><span class="s1">][</span><span class="s3">'vars'</span><span class="s1">][</span><span class="s3">'abar'</span><span class="s1">][</span><span class="s3">'='</span><span class="s1">] == </span><span class="s3">&quot;bar('abar')&quot;</span>
</pre>
</body>
</html>