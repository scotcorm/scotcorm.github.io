<html>
<head>
<title>test_numeric.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_numeric.py</font>
</center></td></tr></table>
<pre><span class="s0"># Arithmetic tests for DataFrame/Series/Index/Array classes that should</span>
<span class="s0"># behave identically.</span>
<span class="s0"># Specifically for numeric dtypes</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">abc</span>
<span class="s2">from </span><span class="s1">decimal </span><span class="s2">import </span><span class="s1">Decimal</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">combinations</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Index</span><span class="s2">,</span>
    <span class="s1">RangeIndex</span><span class="s2">,</span>
    <span class="s1">Series</span><span class="s2">,</span>
    <span class="s1">Timedelta</span><span class="s2">,</span>
    <span class="s1">TimedeltaIndex</span><span class="s2">,</span>
    <span class="s1">array</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas._testing </span><span class="s2">as </span><span class="s1">tm</span>
<span class="s2">from </span><span class="s1">pandas.core </span><span class="s2">import </span><span class="s1">ops</span>
<span class="s2">from </span><span class="s1">pandas.core.api </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Float64Index</span><span class="s2">,</span>
    <span class="s1">Int64Index</span><span class="s2">,</span>
    <span class="s1">UInt64Index</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.computation </span><span class="s2">import </span><span class="s1">expressions </span><span class="s2">as </span><span class="s1">expr</span>
<span class="s2">from </span><span class="s1">pandas.tests.arithmetic.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">assert_invalid_addsub_type</span><span class="s2">,</span>
    <span class="s1">assert_invalid_comparison</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s1">@pytest.fixture(params=[Index</span><span class="s2">, </span><span class="s1">Series</span><span class="s2">, </span><span class="s1">tm.to_array])</span>
<span class="s2">def </span><span class="s1">box_pandas_1d_array(request):</span>
    <span class="s3">&quot;&quot;&quot; 
    Fixture to test behavior for Index, Series and tm.to_array classes 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">request.param</span>


<span class="s2">def </span><span class="s1">adjust_negative_zero(zero</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s3">&quot;&quot;&quot; 
    Helper to adjust the expected result if we are dividing by -0.0 
    as opposed to 0.0 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">np.signbit(np.array(zero)).any():</span>
        <span class="s0"># All entries in the `zero` fixture should be either</span>
        <span class="s0">#  all-negative or no-negative.</span>
        <span class="s2">assert </span><span class="s1">np.signbit(np.array(zero)).all()</span>

        <span class="s1">expected *= -</span><span class="s4">1</span>

    <span class="s2">return </span><span class="s1">expected</span>


<span class="s2">def </span><span class="s1">compare_op(series</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">op):</span>
    <span class="s1">left = np.abs(series) </span><span class="s2">if </span><span class="s1">op </span><span class="s2">in </span><span class="s1">(ops.rpow</span><span class="s2">, </span><span class="s1">operator.pow) </span><span class="s2">else </span><span class="s1">series</span>
    <span class="s1">right = np.abs(other) </span><span class="s2">if </span><span class="s1">op </span><span class="s2">in </span><span class="s1">(ops.rpow</span><span class="s2">, </span><span class="s1">operator.pow) </span><span class="s2">else </span><span class="s1">other</span>

    <span class="s1">cython_or_numpy = op(left</span><span class="s2">, </span><span class="s1">right)</span>
    <span class="s1">python = left.combine(right</span><span class="s2">, </span><span class="s1">op)</span>
    <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">Series) </span><span class="s2">and not </span><span class="s1">other.index.equals(series.index):</span>
        <span class="s1">python.index = python.index._with_freq(</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(cython_or_numpy</span><span class="s2">, </span><span class="s1">python)</span>


<span class="s0"># TODO: remove this kludge once mypy stops giving false positives here</span>
<span class="s0"># List comprehension has incompatible type List[PandasObject]; expected List[RangeIndex]</span>
<span class="s0">#  See GH#29725</span>
<span class="s1">ser_or_index: list[Any] = [Series</span><span class="s2">, </span><span class="s1">Index]</span>
<span class="s1">lefts: list[Any] = [RangeIndex(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">40</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)]</span>
<span class="s1">lefts.extend(</span>
    <span class="s1">[</span>
        <span class="s1">cls([</span><span class="s4">10</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">30</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">[</span><span class="s5">&quot;i1&quot;</span><span class="s2">, </span><span class="s5">&quot;i2&quot;</span><span class="s2">, </span><span class="s5">&quot;i4&quot;</span><span class="s2">, </span><span class="s5">&quot;i8&quot;</span><span class="s2">, </span><span class="s5">&quot;u1&quot;</span><span class="s2">, </span><span class="s5">&quot;u2&quot;</span><span class="s2">, </span><span class="s5">&quot;u4&quot;</span><span class="s2">, </span><span class="s5">&quot;u8&quot;</span><span class="s2">, </span><span class="s5">&quot;f2&quot;</span><span class="s2">, </span><span class="s5">&quot;f4&quot;</span><span class="s2">, </span><span class="s5">&quot;f8&quot;</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">cls </span><span class="s2">in </span><span class="s1">ser_or_index</span>
    <span class="s1">]</span>
<span class="s1">)</span>

<span class="s0"># ------------------------------------------------------------------</span>
<span class="s0"># Comparisons</span>


<span class="s2">class </span><span class="s1">TestNumericComparisons:</span>
    <span class="s2">def </span><span class="s1">test_operator_series_comparison_zerorank(self):</span>
        <span class="s0"># GH#13006</span>
        <span class="s1">result = np.float64(</span><span class="s4">0</span><span class="s1">) &gt; Series([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">expected = </span><span class="s4">0.0 </span><span class="s1">&gt; Series([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">result = Series([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]) &lt; np.float64(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]) &lt; </span><span class="s4">0.0</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">result = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])[</span><span class="s4">0</span><span class="s1">] &gt; Series([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
        <span class="s1">expected = </span><span class="s4">0.0 </span><span class="s1">&gt; Series([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_df_numeric_cmp_dt64_raises(self</span><span class="s2">, </span><span class="s1">box_with_array</span><span class="s2">, </span><span class="s1">fixed_now_ts):</span>
        <span class="s0"># GH#8932, GH#22163</span>
        <span class="s1">ts = fixed_now_ts</span>
        <span class="s1">obj = np.array(range(</span><span class="s4">5</span><span class="s1">))</span>
        <span class="s1">obj = tm.box_expected(obj</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">assert_invalid_comparison(obj</span><span class="s2">, </span><span class="s1">ts</span><span class="s2">, </span><span class="s1">box_with_array)</span>

    <span class="s2">def </span><span class="s1">test_compare_invalid(self):</span>
        <span class="s0"># GH#8058</span>
        <span class="s0"># ops testing</span>
        <span class="s1">a = Series(np.random.randn(</span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">b = Series(np.random.randn(</span><span class="s4">5</span><span class="s1">))</span>
        <span class="s1">b.name = pd.Timestamp(</span><span class="s5">&quot;2000-01-01&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(a / b</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">/ (b / a))</span>

    <span class="s2">def </span><span class="s1">test_numeric_cmp_string_numexpr_path(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#36377, GH#35700</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">xbox = box </span><span class="s2">if </span><span class="s1">box </span><span class="s2">is not </span><span class="s1">Index </span><span class="s2">else </span><span class="s1">np.ndarray</span>

        <span class="s1">obj = Series(np.random.randn(</span><span class="s4">10 </span><span class="s1">** </span><span class="s4">5</span><span class="s1">))</span>
        <span class="s1">obj = tm.box_expected(obj</span><span class="s2">, </span><span class="s1">box</span><span class="s2">, </span><span class="s1">transpose=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">result = obj == </span><span class="s5">&quot;a&quot;</span>

        <span class="s1">expected = Series(np.zeros(</span><span class="s4">10 </span><span class="s1">** </span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=bool))</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">xbox</span><span class="s2">, </span><span class="s1">transpose=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = obj != </span><span class="s5">&quot;a&quot;</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">~expected)</span>

        <span class="s1">msg = </span><span class="s5">&quot;Invalid comparison between dtype=float64 and str&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">obj &lt; </span><span class="s5">&quot;a&quot;</span>


<span class="s0"># ------------------------------------------------------------------</span>
<span class="s0"># Numeric dtypes Arithmetic with Datetime/Timedelta Scalar</span>


<span class="s2">class </span><span class="s1">TestNumericArraylikeArithmeticWithDatetimeLike:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;box_cls&quot;</span><span class="s2">, </span><span class="s1">[np.array</span><span class="s2">, </span><span class="s1">Index</span><span class="s2">, </span><span class="s1">Series])</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;left&quot;</span><span class="s2">, </span><span class="s1">lefts</span><span class="s2">, </span><span class="s1">ids=</span><span class="s2">lambda </span><span class="s1">x: type(x).__name__ + str(x.dtype)</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_mul_td64arr(self</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">box_cls):</span>
        <span class="s0"># GH#22390</span>
        <span class="s1">right = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;m8[s]&quot;</span><span class="s1">)</span>
        <span class="s1">right = box_cls(right)</span>

        <span class="s1">expected = TimedeltaIndex([</span><span class="s5">&quot;10s&quot;</span><span class="s2">, </span><span class="s5">&quot;40s&quot;</span><span class="s2">, </span><span class="s5">&quot;90s&quot;</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">isinstance(left</span><span class="s2">, </span><span class="s1">Series) </span><span class="s2">or </span><span class="s1">box_cls </span><span class="s2">is </span><span class="s1">Series:</span>
            <span class="s1">expected = Series(expected)</span>

        <span class="s1">result = left * right</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = right * left</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;box_cls&quot;</span><span class="s2">, </span><span class="s1">[np.array</span><span class="s2">, </span><span class="s1">Index</span><span class="s2">, </span><span class="s1">Series])</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;left&quot;</span><span class="s2">, </span><span class="s1">lefts</span><span class="s2">, </span><span class="s1">ids=</span><span class="s2">lambda </span><span class="s1">x: type(x).__name__ + str(x.dtype)</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_div_td64arr(self</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">box_cls):</span>
        <span class="s0"># GH#22390</span>
        <span class="s1">right = np.array([</span><span class="s4">10</span><span class="s2">, </span><span class="s4">40</span><span class="s2">, </span><span class="s4">90</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;m8[s]&quot;</span><span class="s1">)</span>
        <span class="s1">right = box_cls(right)</span>

        <span class="s1">expected = TimedeltaIndex([</span><span class="s5">&quot;1s&quot;</span><span class="s2">, </span><span class="s5">&quot;2s&quot;</span><span class="s2">, </span><span class="s5">&quot;3s&quot;</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">isinstance(left</span><span class="s2">, </span><span class="s1">Series) </span><span class="s2">or </span><span class="s1">box_cls </span><span class="s2">is </span><span class="s1">Series:</span>
            <span class="s1">expected = Series(expected)</span>

        <span class="s1">result = right / left</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = right // left</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">msg = </span><span class="s5">&quot;Cannot divide&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">left / right</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">left // right</span>

    <span class="s0"># TODO: also test Tick objects;</span>
    <span class="s0">#  see test_numeric_arr_rdiv_tdscalar for note on these failing</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;scalar_td&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">Timedelta(days=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timedelta(days=</span><span class="s4">1</span><span class="s1">).to_timedelta64()</span><span class="s2">,</span>
            <span class="s1">Timedelta(days=</span><span class="s4">1</span><span class="s1">).to_pytimedelta()</span><span class="s2">,</span>
            <span class="s1">Timedelta(days=</span><span class="s4">1</span><span class="s1">).to_timedelta64().astype(</span><span class="s5">&quot;timedelta64[s]&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timedelta(days=</span><span class="s4">1</span><span class="s1">).to_timedelta64().astype(</span><span class="s5">&quot;timedelta64[ms]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">ids=</span><span class="s2">lambda </span><span class="s1">x: type(x).__name__</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_numeric_arr_mul_tdscalar(self</span><span class="s2">, </span><span class="s1">scalar_td</span><span class="s2">, </span><span class="s1">numeric_idx</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#19333</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">index = numeric_idx</span>
        <span class="s1">expected = TimedeltaIndex([Timedelta(days=n) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(len(index))])</span>

        <span class="s1">index = tm.box_expected(index</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s1">result = index * scalar_td</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">commute = scalar_td * index</span>
        <span class="s1">tm.assert_equal(commute</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;scalar_td&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">Timedelta(days=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timedelta(days=</span><span class="s4">1</span><span class="s1">).to_timedelta64()</span><span class="s2">,</span>
            <span class="s1">Timedelta(days=</span><span class="s4">1</span><span class="s1">).to_pytimedelta()</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">ids=</span><span class="s2">lambda </span><span class="s1">x: type(x).__name__</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">[np.int64</span><span class="s2">, </span><span class="s1">np.float64])</span>
    <span class="s2">def </span><span class="s1">test_numeric_arr_mul_tdscalar_numexpr_path(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">scalar_td</span><span class="s2">, </span><span class="s1">box_with_array</span>
    <span class="s1">):</span>
        <span class="s0"># GH#44772 for the float64 case</span>
        <span class="s1">box = box_with_array</span>

        <span class="s1">arr_i8 = np.arange(</span><span class="s4">2 </span><span class="s1">* </span><span class="s4">10 </span><span class="s1">** </span><span class="s4">4</span><span class="s1">).astype(np.int64</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">arr = arr_i8.astype(dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">obj = tm.box_expected(arr</span><span class="s2">, </span><span class="s1">box</span><span class="s2">, </span><span class="s1">transpose=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">expected = arr_i8.view(</span><span class="s5">&quot;timedelta64[D]&quot;</span><span class="s1">).astype(</span><span class="s5">&quot;timedelta64[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box</span><span class="s2">, </span><span class="s1">transpose=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">result = obj * scalar_td</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = scalar_td * obj</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_numeric_arr_rdiv_tdscalar(self</span><span class="s2">, </span><span class="s1">three_days</span><span class="s2">, </span><span class="s1">numeric_idx</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">box = box_with_array</span>

        <span class="s1">index = numeric_idx[</span><span class="s4">1</span><span class="s1">:</span><span class="s4">3</span><span class="s1">]</span>

        <span class="s1">expected = TimedeltaIndex([</span><span class="s5">&quot;3 Days&quot;</span><span class="s2">, </span><span class="s5">&quot;36 Hours&quot;</span><span class="s1">])</span>

        <span class="s1">index = tm.box_expected(index</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s1">result = three_days / index</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">msg = </span><span class="s5">&quot;cannot use operands with types dtype&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">index / three_days</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;other&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">Timedelta(hours=</span><span class="s4">31</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timedelta(hours=</span><span class="s4">31</span><span class="s1">).to_pytimedelta()</span><span class="s2">,</span>
            <span class="s1">Timedelta(hours=</span><span class="s4">31</span><span class="s1">).to_timedelta64()</span><span class="s2">,</span>
            <span class="s1">Timedelta(hours=</span><span class="s4">31</span><span class="s1">).to_timedelta64().astype(</span><span class="s5">&quot;m8[h]&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">np.timedelta64(</span><span class="s5">&quot;NaT&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">np.timedelta64(</span><span class="s5">&quot;NaT&quot;</span><span class="s2">, </span><span class="s5">&quot;D&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pd.offsets.Minute(</span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pd.offsets.Second(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s0"># GH#28080 numeric+datetimelike should raise; Timestamp used</span>
            <span class="s0">#  to raise NullFrequencyError but that behavior was removed in 1.0</span>
            <span class="s1">pd.Timestamp(</span><span class="s5">&quot;2021-01-01&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s5">&quot;Asia/Tokyo&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pd.Timestamp(</span><span class="s5">&quot;2021-01-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pd.Timestamp(</span><span class="s5">&quot;2021-01-01&quot;</span><span class="s1">).to_pydatetime()</span><span class="s2">,</span>
            <span class="s1">pd.Timestamp(</span><span class="s5">&quot;2021-01-01&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s5">&quot;UTC&quot;</span><span class="s1">).to_pydatetime()</span><span class="s2">,</span>
            <span class="s1">pd.Timestamp(</span><span class="s5">&quot;2021-01-01&quot;</span><span class="s1">).to_datetime64()</span><span class="s2">,</span>
            <span class="s1">np.datetime64(</span><span class="s5">&quot;NaT&quot;</span><span class="s2">, </span><span class="s5">&quot;ns&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pd.NaT</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_add_sub_datetimedeltalike_invalid(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">numeric_idx</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">box_with_array</span>
    <span class="s1">):</span>
        <span class="s1">box = box_with_array</span>

        <span class="s1">left = tm.box_expected(numeric_idx</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">msg = </span><span class="s5">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s5">&quot;unsupported operand type&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;Addition/subtraction of integers and integer-arrays&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;Instead of adding/subtracting&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;cannot use operands with types dtype&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;Concatenation operation is not implemented for NumPy arrays&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;Cannot (add|subtract) NaT (to|from) ndarray&quot;</span><span class="s2">,</span>
                <span class="s0"># pd.array vs np.datetime64 case</span>
                <span class="s5">r&quot;operand type\(s\) all returned NotImplemented from __array_ufunc__&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;can only perform ops with numeric values&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;cannot subtract DatetimeArray from ndarray&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">assert_invalid_addsub_type(left</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">msg)</span>


<span class="s0"># ------------------------------------------------------------------</span>
<span class="s0"># Arithmetic</span>


<span class="s2">class </span><span class="s1">TestDivisionByZero:</span>
    <span class="s2">def </span><span class="s1">test_div_zero(self</span><span class="s2">, </span><span class="s1">zero</span><span class="s2">, </span><span class="s1">numeric_idx):</span>
        <span class="s1">idx = numeric_idx</span>

        <span class="s1">expected = Index([np.nan</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf]</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s0"># We only adjust for Index, because Series does not yet apply</span>
        <span class="s0">#  the adjustment correctly.</span>
        <span class="s1">expected2 = adjust_negative_zero(zero</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = idx / zero</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected2)</span>
        <span class="s1">ser_compat = Series(idx).astype(</span><span class="s5">&quot;i8&quot;</span><span class="s1">) / np.array(zero).astype(</span><span class="s5">&quot;i8&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(ser_compat</span><span class="s2">, </span><span class="s1">Series(expected))</span>

    <span class="s2">def </span><span class="s1">test_floordiv_zero(self</span><span class="s2">, </span><span class="s1">zero</span><span class="s2">, </span><span class="s1">numeric_idx):</span>
        <span class="s1">idx = numeric_idx</span>

        <span class="s1">expected = Index([np.nan</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf]</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s0"># We only adjust for Index, because Series does not yet apply</span>
        <span class="s0">#  the adjustment correctly.</span>
        <span class="s1">expected2 = adjust_negative_zero(zero</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = idx // zero</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected2)</span>
        <span class="s1">ser_compat = Series(idx).astype(</span><span class="s5">&quot;i8&quot;</span><span class="s1">) // np.array(zero).astype(</span><span class="s5">&quot;i8&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(ser_compat</span><span class="s2">, </span><span class="s1">Series(expected))</span>

    <span class="s2">def </span><span class="s1">test_mod_zero(self</span><span class="s2">, </span><span class="s1">zero</span><span class="s2">, </span><span class="s1">numeric_idx):</span>
        <span class="s1">idx = numeric_idx</span>

        <span class="s1">expected = Index([np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">result = idx % zero</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">ser_compat = Series(idx).astype(</span><span class="s5">&quot;i8&quot;</span><span class="s1">) % np.array(zero).astype(</span><span class="s5">&quot;i8&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(ser_compat</span><span class="s2">, </span><span class="s1">Series(result))</span>

    <span class="s2">def </span><span class="s1">test_divmod_zero(self</span><span class="s2">, </span><span class="s1">zero</span><span class="s2">, </span><span class="s1">numeric_idx):</span>
        <span class="s1">idx = numeric_idx</span>

        <span class="s1">exleft = Index([np.nan</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf]</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">exright = Index([np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">exleft = adjust_negative_zero(zero</span><span class="s2">, </span><span class="s1">exleft)</span>

        <span class="s1">result = divmod(idx</span><span class="s2">, </span><span class="s1">zero)</span>
        <span class="s1">tm.assert_index_equal(result[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exleft)</span>
        <span class="s1">tm.assert_index_equal(result[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exright)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;op&quot;</span><span class="s2">, </span><span class="s1">[operator.truediv</span><span class="s2">, </span><span class="s1">operator.floordiv])</span>
    <span class="s2">def </span><span class="s1">test_div_negative_zero(self</span><span class="s2">, </span><span class="s1">zero</span><span class="s2">, </span><span class="s1">numeric_idx</span><span class="s2">, </span><span class="s1">op):</span>
        <span class="s0"># Check that -1 / -0.0 returns np.inf, not -np.inf</span>
        <span class="s2">if </span><span class="s1">isinstance(numeric_idx</span><span class="s2">, </span><span class="s1">UInt64Index):</span>
            <span class="s2">return</span>
        <span class="s1">idx = numeric_idx - </span><span class="s4">3</span>

        <span class="s1">expected = Index([-np.inf</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.inf]</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">expected = adjust_negative_zero(zero</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = op(idx</span><span class="s2">, </span><span class="s1">zero)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s0"># ------------------------------------------------------------------</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;dtype1&quot;</span><span class="s2">, </span><span class="s1">[np.int64</span><span class="s2">, </span><span class="s1">np.float64</span><span class="s2">, </span><span class="s1">np.uint64])</span>
    <span class="s2">def </span><span class="s1">test_ser_div_ser(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">switch_numexpr_min_elements</span><span class="s2">,</span>
        <span class="s1">dtype1</span><span class="s2">,</span>
        <span class="s1">any_real_numpy_dtype</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s0"># no longer do integer div for any ops, but deal with the 0's</span>
        <span class="s1">dtype2 = any_real_numpy_dtype</span>

        <span class="s1">first = Series([</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;first&quot;</span><span class="s1">).astype(dtype1)</span>
        <span class="s1">second = Series([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;second&quot;</span><span class="s1">).astype(dtype2)</span>

        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">expected = Series(</span>
                <span class="s1">first.values.astype(np.float64) / second.values</span><span class="s2">,</span>
                <span class="s1">dtype=</span><span class="s5">&quot;float64&quot;</span><span class="s2">,</span>
                <span class="s1">name=</span><span class="s2">None,</span>
            <span class="s1">)</span>
        <span class="s1">expected.iloc[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">3</span><span class="s1">] = np.inf</span>
        <span class="s2">if </span><span class="s1">first.dtype == </span><span class="s5">&quot;int64&quot; </span><span class="s2">and </span><span class="s1">second.dtype == </span><span class="s5">&quot;float32&quot;</span><span class="s1">:</span>
            <span class="s0"># when using numexpr, the casting rules are slightly different</span>
            <span class="s0"># and int64/float32 combo results in float32 instead of float64</span>
            <span class="s2">if </span><span class="s1">expr.USE_NUMEXPR </span><span class="s2">and </span><span class="s1">switch_numexpr_min_elements == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">expected = expected.astype(</span><span class="s5">&quot;float32&quot;</span><span class="s1">)</span>

        <span class="s1">result = first / second</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s2">assert not </span><span class="s1">result.equals(second / first)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;dtype1&quot;</span><span class="s2">, </span><span class="s1">[np.int64</span><span class="s2">, </span><span class="s1">np.float64</span><span class="s2">, </span><span class="s1">np.uint64])</span>
    <span class="s2">def </span><span class="s1">test_ser_divmod_zero(self</span><span class="s2">, </span><span class="s1">dtype1</span><span class="s2">, </span><span class="s1">any_real_numpy_dtype):</span>
        <span class="s0"># GH#26987</span>
        <span class="s1">dtype2 = any_real_numpy_dtype</span>
        <span class="s1">left = Series([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]).astype(dtype1)</span>
        <span class="s1">right = Series([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]).astype(dtype2)</span>

        <span class="s0"># GH#27321 pandas convention is to set 1 // 0 to np.inf, as opposed</span>
        <span class="s0">#  to numpy which sets to np.nan; patch `expected[0]` below</span>
        <span class="s1">expected = left // right</span><span class="s2">, </span><span class="s1">left % right</span>
        <span class="s1">expected = list(expected)</span>
        <span class="s1">expected[</span><span class="s4">0</span><span class="s1">] = expected[</span><span class="s4">0</span><span class="s1">].astype(np.float64)</span>
        <span class="s1">expected[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">] = np.inf</span>
        <span class="s1">result = divmod(left</span><span class="s2">, </span><span class="s1">right)</span>

        <span class="s1">tm.assert_series_equal(result[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">expected[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">expected[</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s0"># rdivmod case</span>
        <span class="s1">result = divmod(left.values</span><span class="s2">, </span><span class="s1">right)</span>
        <span class="s1">tm.assert_series_equal(result[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">expected[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">expected[</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_ser_divmod_inf(self):</span>
        <span class="s1">left = Series([np.inf</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">])</span>
        <span class="s1">right = Series([np.inf</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">])</span>

        <span class="s1">expected = left // right</span><span class="s2">, </span><span class="s1">left % right</span>
        <span class="s1">result = divmod(left</span><span class="s2">, </span><span class="s1">right)</span>

        <span class="s1">tm.assert_series_equal(result[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">expected[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">expected[</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s0"># rdivmod case</span>
        <span class="s1">result = divmod(left.values</span><span class="s2">, </span><span class="s1">right)</span>
        <span class="s1">tm.assert_series_equal(result[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">expected[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">expected[</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_rdiv_zero_compat(self):</span>
        <span class="s0"># GH#8674</span>
        <span class="s1">zero_array = np.array([</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">data = np.random.randn(</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s4">0.0</span><span class="s1">] * </span><span class="s4">5</span><span class="s1">)</span>

        <span class="s1">result = zero_array / Series(data)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = Series(zero_array) / data</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = Series(zero_array) / Series(data)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_div_zero_inf_signs(self):</span>
        <span class="s0"># GH#9144, inf signing</span>
        <span class="s1">ser = Series([-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;first&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series([-np.inf</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.inf]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;first&quot;</span><span class="s1">)</span>

        <span class="s1">result = ser / </span><span class="s4">0</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_rdiv_zero(self):</span>
        <span class="s0"># GH#9144</span>
        <span class="s1">ser = Series([-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;first&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;first&quot;</span><span class="s1">)</span>

        <span class="s1">result = </span><span class="s4">0 </span><span class="s1">/ ser</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_floordiv_div(self):</span>
        <span class="s0"># GH#9144</span>
        <span class="s1">ser = Series([-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;first&quot;</span><span class="s1">)</span>

        <span class="s1">result = ser // </span><span class="s4">0</span>
        <span class="s1">expected = Series([-np.inf</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.inf]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;first&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_df_div_zero_df(self):</span>
        <span class="s0"># integer div, but deal with the 0's (GH#9144)</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s5">&quot;first&quot;</span><span class="s1">: [</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;second&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]})</span>
        <span class="s1">result = df / df</span>

        <span class="s1">first = Series([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">])</span>
        <span class="s1">second = Series([np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">expected = pd.DataFrame({</span><span class="s5">&quot;first&quot;</span><span class="s1">: first</span><span class="s2">, </span><span class="s5">&quot;second&quot;</span><span class="s1">: second})</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_df_div_zero_array(self):</span>
        <span class="s0"># integer div, but deal with the 0's (GH#9144)</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s5">&quot;first&quot;</span><span class="s1">: [</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;second&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]})</span>

        <span class="s1">first = Series([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">])</span>
        <span class="s1">second = Series([np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">expected = pd.DataFrame({</span><span class="s5">&quot;first&quot;</span><span class="s1">: first</span><span class="s2">, </span><span class="s5">&quot;second&quot;</span><span class="s1">: second})</span>

        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">arr = df.values.astype(</span><span class="s5">&quot;float&quot;</span><span class="s1">) / df.values</span>
        <span class="s1">result = pd.DataFrame(arr</span><span class="s2">, </span><span class="s1">index=df.index</span><span class="s2">, </span><span class="s1">columns=df.columns)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_df_div_zero_int(self):</span>
        <span class="s0"># integer div, but deal with the 0's (GH#9144)</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s5">&quot;first&quot;</span><span class="s1">: [</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;second&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]})</span>

        <span class="s1">result = df / </span><span class="s4">0</span>
        <span class="s1">expected = pd.DataFrame(np.inf</span><span class="s2">, </span><span class="s1">index=df.index</span><span class="s2">, </span><span class="s1">columns=df.columns)</span>
        <span class="s1">expected.iloc[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] = np.nan</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># numpy has a slightly different (wrong) treatment</span>
        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">arr = df.values.astype(</span><span class="s5">&quot;float64&quot;</span><span class="s1">) / </span><span class="s4">0</span>
        <span class="s1">result2 = pd.DataFrame(arr</span><span class="s2">, </span><span class="s1">index=df.index</span><span class="s2">, </span><span class="s1">columns=df.columns)</span>
        <span class="s1">tm.assert_frame_equal(result2</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_df_div_zero_series_does_not_commute(self):</span>
        <span class="s0"># integer div, but deal with the 0's (GH#9144)</span>
        <span class="s1">df = pd.DataFrame(np.random.randn(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">5</span><span class="s1">))</span>
        <span class="s1">ser = df[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">res = ser / df</span>
        <span class="s1">res2 = df / ser</span>
        <span class="s2">assert not </span><span class="s1">res.fillna(</span><span class="s4">0</span><span class="s1">).equals(res2.fillna(</span><span class="s4">0</span><span class="s1">))</span>

    <span class="s0"># ------------------------------------------------------------------</span>
    <span class="s0"># Mod By Zero</span>

    <span class="s2">def </span><span class="s1">test_df_mod_zero_df(self</span><span class="s2">, </span><span class="s1">using_array_manager):</span>
        <span class="s0"># GH#3590, modulo as ints</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s5">&quot;first&quot;</span><span class="s1">: [</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;second&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]})</span>
        <span class="s0"># this is technically wrong, as the integer portion is coerced to float</span>
        <span class="s1">first = Series([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
        <span class="s2">if not </span><span class="s1">using_array_manager:</span>
            <span class="s0"># INFO(ArrayManager) BlockManager doesn't preserve dtype per column</span>
            <span class="s0"># while ArrayManager performs op column-wisedoes and thus preserves</span>
            <span class="s0"># dtype if possible</span>
            <span class="s1">first = first.astype(</span><span class="s5">&quot;float64&quot;</span><span class="s1">)</span>
        <span class="s1">second = Series([np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">expected = pd.DataFrame({</span><span class="s5">&quot;first&quot;</span><span class="s1">: first</span><span class="s2">, </span><span class="s5">&quot;second&quot;</span><span class="s1">: second})</span>
        <span class="s1">result = df % df</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># GH#38939 If we dont pass copy=False, df is consolidated and</span>
        <span class="s0">#  result[&quot;first&quot;] is float64 instead of int64</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s5">&quot;first&quot;</span><span class="s1">: [</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;second&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]}</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">first = Series([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;int64&quot;</span><span class="s1">)</span>
        <span class="s1">second = Series([np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">expected = pd.DataFrame({</span><span class="s5">&quot;first&quot;</span><span class="s1">: first</span><span class="s2">, </span><span class="s5">&quot;second&quot;</span><span class="s1">: second})</span>
        <span class="s1">result = df % df</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_df_mod_zero_array(self):</span>
        <span class="s0"># GH#3590, modulo as ints</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s5">&quot;first&quot;</span><span class="s1">: [</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;second&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]})</span>

        <span class="s0"># this is technically wrong, as the integer portion is coerced to float</span>
        <span class="s0"># ###</span>
        <span class="s1">first = Series([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;float64&quot;</span><span class="s1">)</span>
        <span class="s1">second = Series([np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">expected = pd.DataFrame({</span><span class="s5">&quot;first&quot;</span><span class="s1">: first</span><span class="s2">, </span><span class="s5">&quot;second&quot;</span><span class="s1">: second})</span>

        <span class="s0"># numpy has a slightly different (wrong) treatment</span>
        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">arr = df.values % df.values</span>
        <span class="s1">result2 = pd.DataFrame(arr</span><span class="s2">, </span><span class="s1">index=df.index</span><span class="s2">, </span><span class="s1">columns=df.columns</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;float64&quot;</span><span class="s1">)</span>
        <span class="s1">result2.iloc[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] = np.nan</span>
        <span class="s1">tm.assert_frame_equal(result2</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_df_mod_zero_int(self):</span>
        <span class="s0"># GH#3590, modulo as ints</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s5">&quot;first&quot;</span><span class="s1">: [</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;second&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]})</span>

        <span class="s1">result = df % </span><span class="s4">0</span>
        <span class="s1">expected = pd.DataFrame(np.nan</span><span class="s2">, </span><span class="s1">index=df.index</span><span class="s2">, </span><span class="s1">columns=df.columns)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># numpy has a slightly different (wrong) treatment</span>
        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">arr = df.values.astype(</span><span class="s5">&quot;float64&quot;</span><span class="s1">) % </span><span class="s4">0</span>
        <span class="s1">result2 = pd.DataFrame(arr</span><span class="s2">, </span><span class="s1">index=df.index</span><span class="s2">, </span><span class="s1">columns=df.columns)</span>
        <span class="s1">tm.assert_frame_equal(result2</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_df_mod_zero_series_does_not_commute(self):</span>
        <span class="s0"># GH#3590, modulo as ints</span>
        <span class="s0"># not commutative with series</span>
        <span class="s1">df = pd.DataFrame(np.random.randn(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">5</span><span class="s1">))</span>
        <span class="s1">ser = df[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">res = ser % df</span>
        <span class="s1">res2 = df % ser</span>
        <span class="s2">assert not </span><span class="s1">res.fillna(</span><span class="s4">0</span><span class="s1">).equals(res2.fillna(</span><span class="s4">0</span><span class="s1">))</span>


<span class="s2">class </span><span class="s1">TestMultiplicationDivision:</span>
    <span class="s0"># __mul__, __rmul__, __div__, __rdiv__, __floordiv__, __rfloordiv__</span>
    <span class="s0"># for non-timestamp/timedelta/period dtypes</span>

    <span class="s2">def </span><span class="s1">test_divide_decimal(self</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># resolves issue GH#9787</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">ser = Series([Decimal(</span><span class="s4">10</span><span class="s1">)])</span>
        <span class="s1">expected = Series([Decimal(</span><span class="s4">5</span><span class="s1">)])</span>

        <span class="s1">ser = tm.box_expected(ser</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s1">result = ser / Decimal(</span><span class="s4">2</span><span class="s1">)</span>

        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = ser // Decimal(</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_div_equiv_binop(self):</span>
        <span class="s0"># Test Series.div as well as Series.__div__</span>
        <span class="s0"># float/integer issue</span>
        <span class="s0"># GH#7785</span>
        <span class="s1">first = Series([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;first&quot;</span><span class="s1">)</span>
        <span class="s1">second = Series([-</span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.02</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;second&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series([-</span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">-np.inf])</span>

        <span class="s1">result = second.div(first)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">check_names=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">result = second / first</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_div_int(self</span><span class="s2">, </span><span class="s1">numeric_idx):</span>
        <span class="s1">idx = numeric_idx</span>
        <span class="s1">result = idx / </span><span class="s4">1</span>
        <span class="s1">expected = idx.astype(</span><span class="s5">&quot;float64&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = idx / </span><span class="s4">2</span>
        <span class="s1">expected = Index(idx.values / </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;op&quot;</span><span class="s2">, </span><span class="s1">[operator.mul</span><span class="s2">, </span><span class="s1">ops.rmul</span><span class="s2">, </span><span class="s1">operator.floordiv])</span>
    <span class="s2">def </span><span class="s1">test_mul_int_identity(self</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">numeric_idx</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">idx = numeric_idx</span>
        <span class="s1">idx = tm.box_expected(idx</span><span class="s2">, </span><span class="s1">box_with_array)</span>

        <span class="s1">result = op(idx</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">idx)</span>

    <span class="s2">def </span><span class="s1">test_mul_int_array(self</span><span class="s2">, </span><span class="s1">numeric_idx):</span>
        <span class="s1">idx = numeric_idx</span>
        <span class="s1">didx = idx * idx</span>

        <span class="s1">result = idx * np.array(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;int64&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">idx * </span><span class="s4">5</span><span class="s1">)</span>

        <span class="s1">arr_dtype = </span><span class="s5">&quot;uint64&quot; </span><span class="s2">if </span><span class="s1">isinstance(idx</span><span class="s2">, </span><span class="s1">UInt64Index) </span><span class="s2">else </span><span class="s5">&quot;int64&quot;</span>
        <span class="s1">result = idx * np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=arr_dtype)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">didx)</span>

    <span class="s2">def </span><span class="s1">test_mul_int_series(self</span><span class="s2">, </span><span class="s1">numeric_idx):</span>
        <span class="s1">idx = numeric_idx</span>
        <span class="s1">didx = idx * idx</span>

        <span class="s1">arr_dtype = </span><span class="s5">&quot;uint64&quot; </span><span class="s2">if </span><span class="s1">isinstance(idx</span><span class="s2">, </span><span class="s1">UInt64Index) </span><span class="s2">else </span><span class="s5">&quot;int64&quot;</span>
        <span class="s1">result = idx * Series(np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=arr_dtype))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">Series(didx))</span>

    <span class="s2">def </span><span class="s1">test_mul_float_series(self</span><span class="s2">, </span><span class="s1">numeric_idx):</span>
        <span class="s1">idx = numeric_idx</span>
        <span class="s1">rng5 = np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;float64&quot;</span><span class="s1">)</span>

        <span class="s1">result = idx * Series(rng5 + </span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s1">expected = Series(rng5 * (rng5 + </span><span class="s4">0.1</span><span class="s1">))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_mul_index(self</span><span class="s2">, </span><span class="s1">numeric_idx):</span>
        <span class="s1">idx = numeric_idx</span>

        <span class="s1">result = idx * idx</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">idx ** </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_mul_datelike_raises(self</span><span class="s2">, </span><span class="s1">numeric_idx):</span>
        <span class="s1">idx = numeric_idx</span>
        <span class="s1">msg = </span><span class="s5">&quot;cannot perform __rmul__ with this index type&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">idx * pd.date_range(</span><span class="s5">&quot;20130101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_mul_size_mismatch_raises(self</span><span class="s2">, </span><span class="s1">numeric_idx):</span>
        <span class="s1">idx = numeric_idx</span>
        <span class="s1">msg = </span><span class="s5">&quot;operands could not be broadcast together&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">idx * idx[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">3</span><span class="s1">]</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">idx * np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;op&quot;</span><span class="s2">, </span><span class="s1">[operator.pow</span><span class="s2">, </span><span class="s1">ops.rpow])</span>
    <span class="s2">def </span><span class="s1">test_pow_float(self</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">numeric_idx</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># test power calculations both ways, GH#14973</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">idx = numeric_idx</span>
        <span class="s1">expected = Float64Index(op(idx.values</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">))</span>

        <span class="s1">idx = tm.box_expected(idx</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s1">result = op(idx</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_modulo(self</span><span class="s2">, </span><span class="s1">numeric_idx</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s0"># GH#9244</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">idx = numeric_idx</span>
        <span class="s1">expected = Index(idx.values % </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s1">idx = tm.box_expected(idx</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s1">result = idx % </span><span class="s4">2</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_divmod_scalar(self</span><span class="s2">, </span><span class="s1">numeric_idx):</span>
        <span class="s1">idx = numeric_idx</span>

        <span class="s1">result = divmod(idx</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">div</span><span class="s2">, </span><span class="s1">mod = divmod(idx.values</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s1">expected = Index(div)</span><span class="s2">, </span><span class="s1">Index(mod)</span>
        <span class="s2">for </span><span class="s1">r</span><span class="s2">, </span><span class="s1">e </span><span class="s2">in </span><span class="s1">zip(result</span><span class="s2">, </span><span class="s1">expected):</span>
            <span class="s1">tm.assert_index_equal(r</span><span class="s2">, </span><span class="s1">e)</span>

    <span class="s2">def </span><span class="s1">test_divmod_ndarray(self</span><span class="s2">, </span><span class="s1">numeric_idx):</span>
        <span class="s1">idx = numeric_idx</span>
        <span class="s1">other = np.ones(idx.values.shape</span><span class="s2">, </span><span class="s1">dtype=idx.values.dtype) * </span><span class="s4">2</span>

        <span class="s1">result = divmod(idx</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">div</span><span class="s2">, </span><span class="s1">mod = divmod(idx.values</span><span class="s2">, </span><span class="s1">other)</span>

        <span class="s1">expected = Index(div)</span><span class="s2">, </span><span class="s1">Index(mod)</span>
        <span class="s2">for </span><span class="s1">r</span><span class="s2">, </span><span class="s1">e </span><span class="s2">in </span><span class="s1">zip(result</span><span class="s2">, </span><span class="s1">expected):</span>
            <span class="s1">tm.assert_index_equal(r</span><span class="s2">, </span><span class="s1">e)</span>

    <span class="s2">def </span><span class="s1">test_divmod_series(self</span><span class="s2">, </span><span class="s1">numeric_idx):</span>
        <span class="s1">idx = numeric_idx</span>
        <span class="s1">other = np.ones(idx.values.shape</span><span class="s2">, </span><span class="s1">dtype=idx.values.dtype) * </span><span class="s4">2</span>

        <span class="s1">result = divmod(idx</span><span class="s2">, </span><span class="s1">Series(other))</span>
        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">div</span><span class="s2">, </span><span class="s1">mod = divmod(idx.values</span><span class="s2">, </span><span class="s1">other)</span>

        <span class="s1">expected = Series(div)</span><span class="s2">, </span><span class="s1">Series(mod)</span>
        <span class="s2">for </span><span class="s1">r</span><span class="s2">, </span><span class="s1">e </span><span class="s2">in </span><span class="s1">zip(result</span><span class="s2">, </span><span class="s1">expected):</span>
            <span class="s1">tm.assert_series_equal(r</span><span class="s2">, </span><span class="s1">e)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;other&quot;</span><span class="s2">, </span><span class="s1">[np.nan</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s1">-</span><span class="s4">23</span><span class="s2">, </span><span class="s4">2.718</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3.14</span><span class="s2">, </span><span class="s1">np.inf])</span>
    <span class="s2">def </span><span class="s1">test_ops_np_scalar(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s1">vals = np.random.randn(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">f = </span><span class="s2">lambda </span><span class="s1">x: pd.DataFrame(</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">index=list(</span><span class="s5">&quot;ABCDE&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s5">&quot;jim&quot;</span><span class="s2">, </span><span class="s5">&quot;joe&quot;</span><span class="s2">, </span><span class="s5">&quot;jolie&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>

        <span class="s1">df = f(vals)</span>

        <span class="s1">tm.assert_frame_equal(df / np.array(other)</span><span class="s2">, </span><span class="s1">f(vals / other))</span>
        <span class="s1">tm.assert_frame_equal(np.array(other) * df</span><span class="s2">, </span><span class="s1">f(vals * other))</span>
        <span class="s1">tm.assert_frame_equal(df + np.array(other)</span><span class="s2">, </span><span class="s1">f(vals + other))</span>
        <span class="s1">tm.assert_frame_equal(np.array(other) - df</span><span class="s2">, </span><span class="s1">f(other - vals))</span>

    <span class="s0"># TODO: This came from series.test.test_operators, needs cleanup</span>
    <span class="s2">def </span><span class="s1">test_operators_frame(self):</span>
        <span class="s0"># rpow does not work with DataFrame</span>
        <span class="s1">ts = tm.makeTimeSeries()</span>
        <span class="s1">ts.name = </span><span class="s5">&quot;ts&quot;</span>

        <span class="s1">df = pd.DataFrame({</span><span class="s5">&quot;A&quot;</span><span class="s1">: ts})</span>

        <span class="s1">tm.assert_series_equal(ts + ts</span><span class="s2">, </span><span class="s1">ts + df[</span><span class="s5">&quot;A&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">check_names=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(ts ** ts</span><span class="s2">, </span><span class="s1">ts ** df[</span><span class="s5">&quot;A&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">check_names=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(ts &lt; ts</span><span class="s2">, </span><span class="s1">ts &lt; df[</span><span class="s5">&quot;A&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">check_names=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(ts / ts</span><span class="s2">, </span><span class="s1">ts / df[</span><span class="s5">&quot;A&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">check_names=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s0"># TODO: this came from tests.series.test_analytics, needs cleanup and</span>
    <span class="s0">#  de-duplication with test_modulo above</span>
    <span class="s2">def </span><span class="s1">test_modulo2(self):</span>
        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>

            <span class="s0"># GH#3590, modulo as ints</span>
            <span class="s1">p = pd.DataFrame({</span><span class="s5">&quot;first&quot;</span><span class="s1">: [</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;second&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]})</span>
            <span class="s1">result = p[</span><span class="s5">&quot;first&quot;</span><span class="s1">] % p[</span><span class="s5">&quot;second&quot;</span><span class="s1">]</span>
            <span class="s1">expected = Series(p[</span><span class="s5">&quot;first&quot;</span><span class="s1">].values % p[</span><span class="s5">&quot;second&quot;</span><span class="s1">].values</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;float64&quot;</span><span class="s1">)</span>
            <span class="s1">expected.iloc[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">3</span><span class="s1">] = np.nan</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

            <span class="s1">result = p[</span><span class="s5">&quot;first&quot;</span><span class="s1">] % </span><span class="s4">0</span>
            <span class="s1">expected = Series(np.nan</span><span class="s2">, </span><span class="s1">index=p.index</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;first&quot;</span><span class="s1">)</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

            <span class="s1">p = p.astype(</span><span class="s5">&quot;float64&quot;</span><span class="s1">)</span>
            <span class="s1">result = p[</span><span class="s5">&quot;first&quot;</span><span class="s1">] % p[</span><span class="s5">&quot;second&quot;</span><span class="s1">]</span>
            <span class="s1">expected = Series(p[</span><span class="s5">&quot;first&quot;</span><span class="s1">].values % p[</span><span class="s5">&quot;second&quot;</span><span class="s1">].values)</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

            <span class="s1">p = p.astype(</span><span class="s5">&quot;float64&quot;</span><span class="s1">)</span>
            <span class="s1">result = p[</span><span class="s5">&quot;first&quot;</span><span class="s1">] % p[</span><span class="s5">&quot;second&quot;</span><span class="s1">]</span>
            <span class="s1">result2 = p[</span><span class="s5">&quot;second&quot;</span><span class="s1">] % p[</span><span class="s5">&quot;first&quot;</span><span class="s1">]</span>
            <span class="s2">assert not </span><span class="s1">result.equals(result2)</span>

    <span class="s2">def </span><span class="s1">test_modulo_zero_int(self):</span>
        <span class="s0"># GH#9144</span>
        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">s = Series([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>

            <span class="s1">result = s % </span><span class="s4">0</span>
            <span class="s1">expected = Series([np.nan</span><span class="s2">, </span><span class="s1">np.nan])</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

            <span class="s1">result = </span><span class="s4">0 </span><span class="s1">% s</span>
            <span class="s1">expected = Series([np.nan</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">])</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestAdditionSubtraction:</span>
    <span class="s0"># __add__, __sub__, __radd__, __rsub__, __iadd__, __isub__</span>
    <span class="s0"># for non-timestamp/timedelta/period dtypes</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;first, second, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s1">Series([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=list(</span><span class="s5">&quot;ABC&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Series([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=list(</span><span class="s5">&quot;ABD&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Series([</span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s1">index=list(</span><span class="s5">&quot;ABCD&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">Series([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=list(</span><span class="s5">&quot;ABC&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Series([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=list(</span><span class="s5">&quot;ABCD&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Series([</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s1">index=list(</span><span class="s5">&quot;ABCD&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_add_series(self</span><span class="s2">, </span><span class="s1">first</span><span class="s2">, </span><span class="s1">second</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s0"># GH#1134</span>
        <span class="s1">tm.assert_series_equal(first + second</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_series_equal(second + first</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;first, second, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s1">pd.DataFrame({</span><span class="s5">&quot;x&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]}</span><span class="s2">, </span><span class="s1">index=list(</span><span class="s5">&quot;ABC&quot;</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s1">pd.DataFrame({</span><span class="s5">&quot;x&quot;</span><span class="s1">: [</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]}</span><span class="s2">, </span><span class="s1">index=list(</span><span class="s5">&quot;ABD&quot;</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s1">pd.DataFrame({</span><span class="s5">&quot;x&quot;</span><span class="s1">: [</span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan]}</span><span class="s2">, </span><span class="s1">index=list(</span><span class="s5">&quot;ABCD&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">pd.DataFrame({</span><span class="s5">&quot;x&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]}</span><span class="s2">, </span><span class="s1">index=list(</span><span class="s5">&quot;ABC&quot;</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s1">pd.DataFrame({</span><span class="s5">&quot;x&quot;</span><span class="s1">: [</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]}</span><span class="s2">, </span><span class="s1">index=list(</span><span class="s5">&quot;ABCD&quot;</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s1">pd.DataFrame({</span><span class="s5">&quot;x&quot;</span><span class="s1">: [</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s1">np.nan]}</span><span class="s2">, </span><span class="s1">index=list(</span><span class="s5">&quot;ABCD&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_add_frames(self</span><span class="s2">, </span><span class="s1">first</span><span class="s2">, </span><span class="s1">second</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s0"># GH#1134</span>
        <span class="s1">tm.assert_frame_equal(first + second</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_frame_equal(second + first</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s0"># TODO: This came from series.test.test_operators, needs cleanup</span>
    <span class="s2">def </span><span class="s1">test_series_frame_radd_bug(self</span><span class="s2">, </span><span class="s1">fixed_now_ts):</span>
        <span class="s0"># GH#353</span>
        <span class="s1">vals = Series(tm.rands_array(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s1">))</span>
        <span class="s1">result = </span><span class="s5">&quot;foo_&quot; </span><span class="s1">+ vals</span>
        <span class="s1">expected = vals.map(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s5">&quot;foo_&quot; </span><span class="s1">+ x)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">frame = pd.DataFrame({</span><span class="s5">&quot;vals&quot;</span><span class="s1">: vals})</span>
        <span class="s1">result = </span><span class="s5">&quot;foo_&quot; </span><span class="s1">+ frame</span>
        <span class="s1">expected = pd.DataFrame({</span><span class="s5">&quot;vals&quot;</span><span class="s1">: vals.map(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s5">&quot;foo_&quot; </span><span class="s1">+ x)})</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">ts = tm.makeTimeSeries()</span>
        <span class="s1">ts.name = </span><span class="s5">&quot;ts&quot;</span>

        <span class="s0"># really raise this time</span>
        <span class="s1">fix_now = fixed_now_ts.to_pydatetime()</span>
        <span class="s1">msg = </span><span class="s5">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s5">&quot;unsupported operand type&quot;</span><span class="s2">,</span>
                <span class="s0"># wrong error message, see https://github.com/numpy/numpy/issues/18832</span>
                <span class="s5">&quot;Concatenation operation&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">fix_now + ts</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">ts + fix_now</span>

    <span class="s0"># TODO: This came from series.test.test_operators, needs cleanup</span>
    <span class="s2">def </span><span class="s1">test_datetime64_with_index(self):</span>
        <span class="s0"># arithmetic integer ops with an index</span>
        <span class="s1">ser = Series(np.random.randn(</span><span class="s4">5</span><span class="s1">))</span>
        <span class="s1">expected = ser - ser.index.to_series()</span>
        <span class="s1">result = ser - ser.index</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># GH#4629</span>
        <span class="s0"># arithmetic datetime64 ops with an index</span>
        <span class="s1">ser = Series(</span>
            <span class="s1">pd.date_range(</span><span class="s5">&quot;20130101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">5</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">index=pd.date_range(</span><span class="s5">&quot;20130101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">5</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">expected = ser - ser.index.to_series()</span>
        <span class="s1">result = ser - ser.index</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">msg = </span><span class="s5">&quot;cannot subtract period&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s0"># GH#18850</span>
            <span class="s1">result = ser - ser.index.to_period()</span>

        <span class="s1">df = pd.DataFrame(</span>
            <span class="s1">np.random.randn(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">index=pd.date_range(</span><span class="s5">&quot;20130101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">df[</span><span class="s5">&quot;date&quot;</span><span class="s1">] = pd.Timestamp(</span><span class="s5">&quot;20130102&quot;</span><span class="s1">)</span>
        <span class="s1">df[</span><span class="s5">&quot;expected&quot;</span><span class="s1">] = df[</span><span class="s5">&quot;date&quot;</span><span class="s1">] - df.index.to_series()</span>
        <span class="s1">df[</span><span class="s5">&quot;result&quot;</span><span class="s1">] = df[</span><span class="s5">&quot;date&quot;</span><span class="s1">] - df.index</span>
        <span class="s1">tm.assert_series_equal(df[</span><span class="s5">&quot;result&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">df[</span><span class="s5">&quot;expected&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">check_names=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s0"># TODO: taken from tests.frame.test_operators, needs cleanup</span>
    <span class="s2">def </span><span class="s1">test_frame_operators(self</span><span class="s2">, </span><span class="s1">float_frame):</span>
        <span class="s1">frame = float_frame</span>
        <span class="s1">frame2 = pd.DataFrame(float_frame</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s5">&quot;D&quot;</span><span class="s2">, </span><span class="s5">&quot;C&quot;</span><span class="s2">, </span><span class="s5">&quot;B&quot;</span><span class="s2">, </span><span class="s5">&quot;A&quot;</span><span class="s1">])</span>

        <span class="s1">garbage = np.random.random(</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">colSeries = Series(garbage</span><span class="s2">, </span><span class="s1">index=np.array(frame.columns))</span>

        <span class="s1">idSum = frame + frame</span>
        <span class="s1">seriesSum = frame + colSeries</span>

        <span class="s2">for </span><span class="s1">col</span><span class="s2">, </span><span class="s1">series </span><span class="s2">in </span><span class="s1">idSum.items():</span>
            <span class="s2">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">series.items():</span>
                <span class="s1">origVal = frame[col][idx] * </span><span class="s4">2</span>
                <span class="s2">if not </span><span class="s1">np.isnan(val):</span>
                    <span class="s2">assert </span><span class="s1">val == origVal</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">assert </span><span class="s1">np.isnan(origVal)</span>

        <span class="s2">for </span><span class="s1">col</span><span class="s2">, </span><span class="s1">series </span><span class="s2">in </span><span class="s1">seriesSum.items():</span>
            <span class="s2">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">series.items():</span>
                <span class="s1">origVal = frame[col][idx] + colSeries[col]</span>
                <span class="s2">if not </span><span class="s1">np.isnan(val):</span>
                    <span class="s2">assert </span><span class="s1">val == origVal</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">assert </span><span class="s1">np.isnan(origVal)</span>

        <span class="s1">added = frame2 + frame2</span>
        <span class="s1">expected = frame2 * </span><span class="s4">2</span>
        <span class="s1">tm.assert_frame_equal(added</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">df = pd.DataFrame({</span><span class="s5">&quot;a&quot;</span><span class="s1">: [</span><span class="s5">&quot;a&quot;</span><span class="s2">, None, </span><span class="s5">&quot;b&quot;</span><span class="s1">]})</span>
        <span class="s1">tm.assert_frame_equal(df + df</span><span class="s2">, </span><span class="s1">pd.DataFrame({</span><span class="s5">&quot;a&quot;</span><span class="s1">: [</span><span class="s5">&quot;aa&quot;</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s5">&quot;bb&quot;</span><span class="s1">]}))</span>

        <span class="s0"># Test for issue #10181</span>
        <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">(</span><span class="s5">&quot;float&quot;</span><span class="s2">, </span><span class="s5">&quot;int64&quot;</span><span class="s1">):</span>
            <span class="s1">frames = [</span>
                <span class="s1">pd.DataFrame(dtype=dtype)</span><span class="s2">,</span>
                <span class="s1">pd.DataFrame(columns=[</span><span class="s5">&quot;A&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span><span class="s2">,</span>
                <span class="s1">pd.DataFrame(index=[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span><span class="s2">,</span>
            <span class="s1">]</span>
            <span class="s2">for </span><span class="s1">df </span><span class="s2">in </span><span class="s1">frames:</span>
                <span class="s2">assert </span><span class="s1">(df + df).equals(df)</span>
                <span class="s1">tm.assert_frame_equal(df + df</span><span class="s2">, </span><span class="s1">df)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;func&quot;</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s2">lambda </span><span class="s1">x: x * </span><span class="s4">2</span><span class="s2">, lambda </span><span class="s1">x: x[::</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, lambda </span><span class="s1">x: </span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">ids=[</span><span class="s5">&quot;multiply&quot;</span><span class="s2">, </span><span class="s5">&quot;slice&quot;</span><span class="s2">, </span><span class="s5">&quot;constant&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_series_operators_arithmetic(self</span><span class="s2">, </span><span class="s1">all_arithmetic_functions</span><span class="s2">, </span><span class="s1">func):</span>
        <span class="s1">op = all_arithmetic_functions</span>
        <span class="s1">series = tm.makeTimeSeries().rename(</span><span class="s5">&quot;ts&quot;</span><span class="s1">)</span>
        <span class="s1">other = func(series)</span>
        <span class="s1">compare_op(series</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">op)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;func&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">lambda </span><span class="s1">x: x + </span><span class="s4">1</span><span class="s2">, lambda </span><span class="s1">x: </span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ids=[</span><span class="s5">&quot;add&quot;</span><span class="s2">, </span><span class="s5">&quot;constant&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_series_operators_compare(self</span><span class="s2">, </span><span class="s1">comparison_op</span><span class="s2">, </span><span class="s1">func):</span>
        <span class="s1">op = comparison_op</span>
        <span class="s1">series = tm.makeTimeSeries().rename(</span><span class="s5">&quot;ts&quot;</span><span class="s1">)</span>
        <span class="s1">other = func(series)</span>
        <span class="s1">compare_op(series</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">op)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;func&quot;</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s2">lambda </span><span class="s1">x: x * </span><span class="s4">2</span><span class="s2">, lambda </span><span class="s1">x: x[::</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, lambda </span><span class="s1">x: </span><span class="s4">5</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">ids=[</span><span class="s5">&quot;multiply&quot;</span><span class="s2">, </span><span class="s5">&quot;slice&quot;</span><span class="s2">, </span><span class="s5">&quot;constant&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_divmod(self</span><span class="s2">, </span><span class="s1">func):</span>
        <span class="s1">series = tm.makeTimeSeries().rename(</span><span class="s5">&quot;ts&quot;</span><span class="s1">)</span>
        <span class="s1">other = func(series)</span>
        <span class="s1">results = divmod(series</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">abc.Iterable) </span><span class="s2">and </span><span class="s1">len(series) != len(other):</span>
            <span class="s0"># if the lengths don't match, this is the test where we use</span>
            <span class="s0"># `tser[::2]`. Pad every other value in `other_np` with nan.</span>
            <span class="s1">other_np = []</span>
            <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">other:</span>
                <span class="s1">other_np.append(n)</span>
                <span class="s1">other_np.append(np.nan)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">other_np = other</span>
        <span class="s1">other_np = np.asarray(other_np)</span>
        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">expecteds = divmod(series.values</span><span class="s2">, </span><span class="s1">np.asarray(other_np))</span>

        <span class="s2">for </span><span class="s1">result</span><span class="s2">, </span><span class="s1">expected </span><span class="s2">in </span><span class="s1">zip(results</span><span class="s2">, </span><span class="s1">expecteds):</span>
            <span class="s0"># check the values, name, and index separately</span>
            <span class="s1">tm.assert_almost_equal(np.asarray(result)</span><span class="s2">, </span><span class="s1">expected)</span>

            <span class="s2">assert </span><span class="s1">result.name == series.name</span>
            <span class="s1">tm.assert_index_equal(result.index</span><span class="s2">, </span><span class="s1">series.index._with_freq(</span><span class="s2">None</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_series_divmod_zero(self):</span>
        <span class="s0"># Check that divmod uses pandas convention for division by zero,</span>
        <span class="s0">#  which does not match numpy.</span>
        <span class="s0"># pandas convention has</span>
        <span class="s0">#  1/0 == np.inf</span>
        <span class="s0">#  -1/0 == -np.inf</span>
        <span class="s0">#  1/-0.0 == -np.inf</span>
        <span class="s0">#  -1/-0.0 == np.inf</span>
        <span class="s1">tser = tm.makeTimeSeries().rename(</span><span class="s5">&quot;ts&quot;</span><span class="s1">)</span>
        <span class="s1">other = tser * </span><span class="s4">0</span>

        <span class="s1">result = divmod(tser</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">exp1 = Series([np.inf] * len(tser)</span><span class="s2">, </span><span class="s1">index=tser.index</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;ts&quot;</span><span class="s1">)</span>
        <span class="s1">exp2 = Series([np.nan] * len(tser)</span><span class="s2">, </span><span class="s1">index=tser.index</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;ts&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exp1)</span>
        <span class="s1">tm.assert_series_equal(result[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exp2)</span>


<span class="s2">class </span><span class="s1">TestUFuncCompat:</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;holder&quot;</span><span class="s2">,</span>
        <span class="s1">[Int64Index</span><span class="s2">, </span><span class="s1">UInt64Index</span><span class="s2">, </span><span class="s1">Float64Index</span><span class="s2">, </span><span class="s1">RangeIndex</span><span class="s2">, </span><span class="s1">Series]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_ufunc_compat(self</span><span class="s2">, </span><span class="s1">holder):</span>
        <span class="s1">box = Series </span><span class="s2">if </span><span class="s1">holder </span><span class="s2">is </span><span class="s1">Series </span><span class="s2">else </span><span class="s1">Index</span>

        <span class="s2">if </span><span class="s1">holder </span><span class="s2">is </span><span class="s1">RangeIndex:</span>
            <span class="s1">idx = RangeIndex(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">idx = holder(np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;int64&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">result = np.sin(idx)</span>
        <span class="s1">expected = box(np.sin(np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;int64&quot;</span><span class="s1">))</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;holder&quot;</span><span class="s2">, </span><span class="s1">[Int64Index</span><span class="s2">, </span><span class="s1">UInt64Index</span><span class="s2">, </span><span class="s1">Float64Index</span><span class="s2">, </span><span class="s1">Series])</span>
    <span class="s2">def </span><span class="s1">test_ufunc_coercions(self</span><span class="s2">, </span><span class="s1">holder):</span>
        <span class="s1">idx = holder([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">box = Series </span><span class="s2">if </span><span class="s1">holder </span><span class="s2">is </span><span class="s1">Series </span><span class="s2">else </span><span class="s1">Index</span>

        <span class="s1">result = np.sqrt(idx)</span>
        <span class="s2">assert </span><span class="s1">result.dtype == </span><span class="s5">&quot;f8&quot; </span><span class="s2">and </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">exp = Float64Index(np.sqrt(np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]))</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">exp = tm.box_expected(exp</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>

        <span class="s1">result = np.divide(idx</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result.dtype == </span><span class="s5">&quot;f8&quot; </span><span class="s2">and </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">exp = Float64Index([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">2.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">exp = tm.box_expected(exp</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>

        <span class="s0"># _evaluate_numeric_binop</span>
        <span class="s1">result = idx + </span><span class="s4">2.0</span>
        <span class="s2">assert </span><span class="s1">result.dtype == </span><span class="s5">&quot;f8&quot; </span><span class="s2">and </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">exp = Float64Index([</span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">5.0</span><span class="s2">, </span><span class="s4">6.0</span><span class="s2">, </span><span class="s4">7.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">exp = tm.box_expected(exp</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>

        <span class="s1">result = idx - </span><span class="s4">2.0</span>
        <span class="s2">assert </span><span class="s1">result.dtype == </span><span class="s5">&quot;f8&quot; </span><span class="s2">and </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">exp = Float64Index([-</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">exp = tm.box_expected(exp</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>

        <span class="s1">result = idx * </span><span class="s4">1.0</span>
        <span class="s2">assert </span><span class="s1">result.dtype == </span><span class="s5">&quot;f8&quot; </span><span class="s2">and </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">exp = Float64Index([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">5.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">exp = tm.box_expected(exp</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>

        <span class="s1">result = idx / </span><span class="s4">2.0</span>
        <span class="s2">assert </span><span class="s1">result.dtype == </span><span class="s5">&quot;f8&quot; </span><span class="s2">and </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">exp = Float64Index([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">2.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">exp = tm.box_expected(exp</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">exp)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;holder&quot;</span><span class="s2">, </span><span class="s1">[Int64Index</span><span class="s2">, </span><span class="s1">UInt64Index</span><span class="s2">, </span><span class="s1">Float64Index</span><span class="s2">, </span><span class="s1">Series])</span>
    <span class="s2">def </span><span class="s1">test_ufunc_multiple_return_values(self</span><span class="s2">, </span><span class="s1">holder):</span>
        <span class="s1">obj = holder([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">box = Series </span><span class="s2">if </span><span class="s1">holder </span><span class="s2">is </span><span class="s1">Series </span><span class="s2">else </span><span class="s1">Index</span>

        <span class="s1">result = np.modf(obj)</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">tuple)</span>
        <span class="s1">exp1 = Float64Index([</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">exp2 = Float64Index([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_equal(result[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tm.box_expected(exp1</span><span class="s2">, </span><span class="s1">box))</span>
        <span class="s1">tm.assert_equal(result[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tm.box_expected(exp2</span><span class="s2">, </span><span class="s1">box))</span>

    <span class="s2">def </span><span class="s1">test_ufunc_at(self):</span>
        <span class="s1">s = Series([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">np.add.at(s</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s4">10</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">12</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(s</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestObjectDtypeEquivalence:</span>
    <span class="s0"># Tests that arithmetic operations match operations executed elementwise</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s1">object])</span>
    <span class="s2">def </span><span class="s1">test_numarr_with_dtype_add_nan(self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">ser = Series([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">expected = Series([np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

        <span class="s1">ser = tm.box_expected(ser</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s1">result = np.nan + ser</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = ser + np.nan</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s1">object])</span>
    <span class="s2">def </span><span class="s1">test_numarr_with_dtype_add_int(self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">box_with_array):</span>
        <span class="s1">box = box_with_array</span>
        <span class="s1">ser = Series([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">expected = Series([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

        <span class="s1">ser = tm.box_expected(ser</span><span class="s2">, </span><span class="s1">box)</span>
        <span class="s1">expected = tm.box_expected(expected</span><span class="s2">, </span><span class="s1">box)</span>

        <span class="s1">result = </span><span class="s4">1 </span><span class="s1">+ ser</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = ser + </span><span class="s4">1</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s0"># TODO: moved from tests.series.test_operators; needs cleanup</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;op&quot;</span><span class="s2">,</span>
        <span class="s1">[operator.add</span><span class="s2">, </span><span class="s1">operator.sub</span><span class="s2">, </span><span class="s1">operator.mul</span><span class="s2">, </span><span class="s1">operator.truediv</span><span class="s2">, </span><span class="s1">operator.floordiv]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_operators_reverse_object(self</span><span class="s2">, </span><span class="s1">op):</span>
        <span class="s0"># GH#56</span>
        <span class="s1">arr = Series(np.random.randn(</span><span class="s4">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">index=np.arange(</span><span class="s4">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=object)</span>

        <span class="s1">result = op(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">arr)</span>
        <span class="s1">expected = op(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">arr.astype(float))</span>
        <span class="s1">tm.assert_series_equal(result.astype(float)</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestNumericArithmeticUnsorted:</span>
    <span class="s0"># Tests in this class have been moved from type-specific test modules</span>
    <span class="s0">#  but not yet sorted, parametrized, and de-duplicated</span>

    <span class="s2">def </span><span class="s1">check_binop(self</span><span class="s2">, </span><span class="s1">ops</span><span class="s2">, </span><span class="s1">scalars</span><span class="s2">, </span><span class="s1">idxs):</span>
        <span class="s2">for </span><span class="s1">op </span><span class="s2">in </span><span class="s1">ops:</span>
            <span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">combinations(idxs</span><span class="s2">, </span><span class="s4">2</span><span class="s1">):</span>
                <span class="s1">a = a._rename(</span><span class="s5">&quot;foo&quot;</span><span class="s1">)</span>
                <span class="s1">b = b._rename(</span><span class="s5">&quot;bar&quot;</span><span class="s1">)</span>
                <span class="s1">result = op(a</span><span class="s2">, </span><span class="s1">b)</span>
                <span class="s1">expected = op(Int64Index(a)</span><span class="s2">, </span><span class="s1">Int64Index(b))</span>
                <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">exact=</span><span class="s5">&quot;equiv&quot;</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">idxs:</span>
                <span class="s2">for </span><span class="s1">scalar </span><span class="s2">in </span><span class="s1">scalars:</span>
                    <span class="s1">result = op(idx</span><span class="s2">, </span><span class="s1">scalar)</span>
                    <span class="s1">expected = op(Int64Index(idx)</span><span class="s2">, </span><span class="s1">scalar)</span>
                    <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">exact=</span><span class="s5">&quot;equiv&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_binops(self):</span>
        <span class="s1">ops = [</span>
            <span class="s1">operator.add</span><span class="s2">,</span>
            <span class="s1">operator.sub</span><span class="s2">,</span>
            <span class="s1">operator.mul</span><span class="s2">,</span>
            <span class="s1">operator.floordiv</span><span class="s2">,</span>
            <span class="s1">operator.truediv</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">scalars = [-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">idxs = [</span>
            <span class="s1">RangeIndex(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">RangeIndex(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">RangeIndex(-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">RangeIndex(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">self.check_binop(ops</span><span class="s2">, </span><span class="s1">scalars</span><span class="s2">, </span><span class="s1">idxs)</span>

    <span class="s2">def </span><span class="s1">test_binops_pow(self):</span>
        <span class="s0"># numpy does not allow powers of negative integers so test separately</span>
        <span class="s0"># https://github.com/numpy/numpy/pull/8127</span>
        <span class="s1">ops = [pow]</span>
        <span class="s1">scalars = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">idxs = [RangeIndex(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">RangeIndex(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span>
        <span class="s1">self.check_binop(ops</span><span class="s2">, </span><span class="s1">scalars</span><span class="s2">, </span><span class="s1">idxs)</span>

    <span class="s0"># TODO: divmod?</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;op&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">operator.add</span><span class="s2">,</span>
            <span class="s1">operator.sub</span><span class="s2">,</span>
            <span class="s1">operator.mul</span><span class="s2">,</span>
            <span class="s1">operator.floordiv</span><span class="s2">,</span>
            <span class="s1">operator.truediv</span><span class="s2">,</span>
            <span class="s1">operator.pow</span><span class="s2">,</span>
            <span class="s1">operator.mod</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_arithmetic_with_frame_or_series(self</span><span class="s2">, </span><span class="s1">op):</span>
        <span class="s0"># check that we return NotImplemented when operating with Series</span>
        <span class="s0"># or DataFrame</span>
        <span class="s1">index = RangeIndex(</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">other = Series(np.random.randn(</span><span class="s4">5</span><span class="s1">))</span>

        <span class="s1">expected = op(Series(index)</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">result = op(index</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">other = pd.DataFrame(np.random.randn(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s1">))</span>
        <span class="s1">expected = op(pd.DataFrame([index</span><span class="s2">, </span><span class="s1">index])</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">result = op(index</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_numeric_compat2(self):</span>
        <span class="s0"># validate that we are handling the RangeIndex overrides to numeric ops</span>
        <span class="s0"># and returning RangeIndex where possible</span>

        <span class="s1">idx = RangeIndex(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s1">result = idx * </span><span class="s4">2</span>
        <span class="s1">expected = RangeIndex(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">exact=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">result = idx + </span><span class="s4">2</span>
        <span class="s1">expected = RangeIndex(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">exact=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">result = idx - </span><span class="s4">2</span>
        <span class="s1">expected = RangeIndex(-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">exact=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">result = idx / </span><span class="s4">2</span>
        <span class="s1">expected = RangeIndex(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">).astype(</span><span class="s5">&quot;float64&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">exact=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">result = idx / </span><span class="s4">4</span>
        <span class="s1">expected = RangeIndex(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">) / </span><span class="s4">4</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">exact=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">result = idx // </span><span class="s4">1</span>
        <span class="s1">expected = idx</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">exact=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s0"># __mul__</span>
        <span class="s1">result = idx * idx</span>
        <span class="s1">expected = Index(idx.values * idx.values)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">exact=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s0"># __pow__</span>
        <span class="s1">idx = RangeIndex(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1000</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">result = idx ** </span><span class="s4">2</span>
        <span class="s1">expected = Int64Index(idx._values) ** </span><span class="s4">2</span>
        <span class="s1">tm.assert_index_equal(Index(result.values)</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">exact=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s0"># __floordiv__</span>
        <span class="s1">cases_exact = [</span>
            <span class="s1">(RangeIndex(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1000</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">RangeIndex(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">500</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(RangeIndex(-</span><span class="s4">99</span><span class="s2">, </span><span class="s1">-</span><span class="s4">201</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s2">, </span><span class="s1">RangeIndex(</span><span class="s4">33</span><span class="s2">, </span><span class="s4">67</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">RangeIndex(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1000</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">2</span><span class="s2">,</span>
                <span class="s1">Int64Index(RangeIndex(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1000</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)._values) // </span><span class="s4">2</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">RangeIndex(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">2.0</span><span class="s2">,</span>
                <span class="s1">Int64Index(RangeIndex(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)._values) // </span><span class="s4">2.0</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(RangeIndex(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">50</span><span class="s2">, </span><span class="s1">RangeIndex(</span><span class="s4">0</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(RangeIndex(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">RangeIndex(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(RangeIndex(-</span><span class="s4">5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10</span><span class="s2">, </span><span class="s1">-</span><span class="s4">6</span><span class="s1">)</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s1">RangeIndex(-</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(RangeIndex(-</span><span class="s4">100</span><span class="s2">, </span><span class="s1">-</span><span class="s4">200</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">RangeIndex(</span><span class="s4">0</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s2">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">div</span><span class="s2">, </span><span class="s1">expected </span><span class="s2">in </span><span class="s1">cases_exact:</span>
            <span class="s1">tm.assert_index_equal(idx // div</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">exact=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">[np.int64</span><span class="s2">, </span><span class="s1">np.float64])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;delta&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_addsub_arithmetic(self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">delta):</span>
        <span class="s0"># GH#8142</span>
        <span class="s1">delta = dtype(delta)</span>
        <span class="s1">index = Index([</span><span class="s4">10</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">12</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">result = index + delta</span>
        <span class="s1">expected = Index(index.values + delta</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s0"># this subtraction used to fail</span>
        <span class="s1">result = index - delta</span>
        <span class="s1">expected = Index(index.values - delta</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">tm.assert_index_equal(index + index</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">* index)</span>
        <span class="s1">tm.assert_index_equal(index - index</span><span class="s2">, </span><span class="s4">0 </span><span class="s1">* index)</span>
        <span class="s2">assert not </span><span class="s1">(index - index).empty</span>


<span class="s2">def </span><span class="s1">test_fill_value_inf_masking():</span>
    <span class="s0"># GH #27464 make sure we mask 0/1 with Inf and not NaN</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s5">&quot;A&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;B&quot;</span><span class="s1">: [</span><span class="s4">1.1</span><span class="s2">, None, </span><span class="s4">1.1</span><span class="s1">]})</span>

    <span class="s1">other = pd.DataFrame({</span><span class="s5">&quot;A&quot;</span><span class="s1">: [</span><span class="s4">1.1</span><span class="s2">, </span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">1.3</span><span class="s1">]}</span><span class="s2">, </span><span class="s1">index=[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>

    <span class="s1">result = df.rfloordiv(other</span><span class="s2">, </span><span class="s1">fill_value=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">expected = pd.DataFrame(</span>
        <span class="s1">{</span><span class="s5">&quot;A&quot;</span><span class="s1">: [np.inf</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;B&quot;</span><span class="s1">: [</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">np.nan]}</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_dataframe_div_silenced():</span>
    <span class="s0"># GH#26793</span>
    <span class="s1">pdf1 = pd.DataFrame(</span>
        <span class="s1">{</span>
            <span class="s5">&quot;A&quot;</span><span class="s1">: np.arange(</span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5">&quot;B&quot;</span><span class="s1">: [np.nan</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">] * </span><span class="s4">2</span><span class="s2">,</span>
            <span class="s5">&quot;C&quot;</span><span class="s1">: [np.nan] * </span><span class="s4">10</span><span class="s2">,</span>
            <span class="s5">&quot;D&quot;</span><span class="s1">: np.arange(</span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">index=list(</span><span class="s5">&quot;abcdefghij&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">columns=list(</span><span class="s5">&quot;ABCD&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">pdf2 = pd.DataFrame(</span>
        <span class="s1">np.random.randn(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">index=list(</span><span class="s5">&quot;abcdefghjk&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">columns=list(</span><span class="s5">&quot;ABCX&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">tm.assert_produces_warning(</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">pdf1.div(pdf2</span><span class="s2">, </span><span class="s1">fill_value=</span><span class="s4">0</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s5">&quot;data, expected_data&quot;</span><span class="s2">,</span>
    <span class="s1">[([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">])]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_integer_array_add_list_like(</span>
    <span class="s1">box_pandas_1d_array</span><span class="s2">, </span><span class="s1">box_1d_array</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">expected_data</span>
<span class="s1">):</span>
    <span class="s0"># GH22606 Verify operators with IntegerArray and list-likes</span>
    <span class="s1">arr = array(data</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;Int64&quot;</span><span class="s1">)</span>
    <span class="s1">container = box_pandas_1d_array(arr)</span>
    <span class="s1">left = container + box_1d_array(data)</span>
    <span class="s1">right = box_1d_array(data) + container</span>

    <span class="s2">if </span><span class="s1">Series </span><span class="s2">in </span><span class="s1">[box_1d_array</span><span class="s2">, </span><span class="s1">box_pandas_1d_array]:</span>
        <span class="s1">cls = Series</span>
    <span class="s2">elif </span><span class="s1">Index </span><span class="s2">in </span><span class="s1">[box_1d_array</span><span class="s2">, </span><span class="s1">box_pandas_1d_array]:</span>
        <span class="s1">cls = Index</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">cls = array</span>

    <span class="s1">expected = cls(expected_data</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;Int64&quot;</span><span class="s1">)</span>

    <span class="s1">tm.assert_equal(left</span><span class="s2">, </span><span class="s1">expected)</span>
    <span class="s1">tm.assert_equal(right</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_sub_multiindex_swapped_levels():</span>
    <span class="s0"># GH 9952</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span><span class="s5">&quot;a&quot;</span><span class="s1">: np.random.randn(</span><span class="s4">6</span><span class="s1">)}</span><span class="s2">,</span>
        <span class="s1">index=pd.MultiIndex.from_product(</span>
            <span class="s1">[[</span><span class="s5">&quot;a&quot;</span><span class="s2">, </span><span class="s5">&quot;b&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">names=[</span><span class="s5">&quot;levA&quot;</span><span class="s2">, </span><span class="s5">&quot;levB&quot;</span><span class="s1">]</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">df2 = df.copy()</span>
    <span class="s1">df2.index = df2.index.swaplevel(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">result = df - df2</span>
    <span class="s1">expected = pd.DataFrame([</span><span class="s4">0.0</span><span class="s1">] * </span><span class="s4">6</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s5">&quot;a&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=df.index)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;power&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;string_size&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_empty_str_comparison(power</span><span class="s2">, </span><span class="s1">string_size):</span>
    <span class="s0"># GH 37348</span>
    <span class="s1">a = np.array(range(</span><span class="s4">10 </span><span class="s1">** power))</span>
    <span class="s1">right = pd.DataFrame(a</span><span class="s2">, </span><span class="s1">dtype=np.int64)</span>
    <span class="s1">left = </span><span class="s5">&quot; &quot; </span><span class="s1">* string_size</span>

    <span class="s1">result = right == left</span>
    <span class="s1">expected = pd.DataFrame(np.zeros(right.shape</span><span class="s2">, </span><span class="s1">dtype=bool))</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
</pre>
</body>
</html>