<html>
<head>
<title>test_ujson.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_ujson.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">calendar</span>
<span class="s0">import </span><span class="s1">datetime</span>
<span class="s0">import </span><span class="s1">decimal</span>
<span class="s0">import </span><span class="s1">json</span>
<span class="s0">import </span><span class="s1">locale</span>
<span class="s0">import </span><span class="s1">math</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">time</span>

<span class="s0">import </span><span class="s1">dateutil</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">import </span><span class="s1">pytz</span>

<span class="s0">import </span><span class="s1">pandas._libs.json </span><span class="s0">as </span><span class="s1">ujson</span>
<span class="s0">from </span><span class="s1">pandas.compat </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">IS64</span><span class="s0">,</span>
    <span class="s1">PY310</span><span class="s0">,</span>
    <span class="s1">is_platform_windows</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s0">,</span>
    <span class="s1">DatetimeIndex</span><span class="s0">,</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">NaT</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">Timedelta</span><span class="s0">,</span>
    <span class="s1">Timestamp</span><span class="s0">,</span>
    <span class="s1">date_range</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>


<span class="s0">def </span><span class="s1">_clean_dict(d):</span>
    <span class="s2">&quot;&quot;&quot; 
    Sanitize dictionary for JSON by converting all keys to strings. 
 
    Parameters 
    ---------- 
    d : dict 
        The dictionary to convert. 
 
    Returns 
    ------- 
    cleaned_dict : dict 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">{str(k): v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">d.items()}</span>


<span class="s1">@pytest.fixture(</span>
    <span class="s1">params=[</span><span class="s0">None, </span><span class="s3">&quot;split&quot;</span><span class="s0">, </span><span class="s3">&quot;records&quot;</span><span class="s0">, </span><span class="s3">&quot;values&quot;</span><span class="s0">, </span><span class="s3">&quot;index&quot;</span><span class="s1">]  </span><span class="s4"># Column indexed by default.</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">orient(request):</span>
    <span class="s0">return </span><span class="s1">request.param</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s0">None, True</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">numpy(request):</span>
    <span class="s0">return </span><span class="s1">request.param</span>


<span class="s0">def </span><span class="s1">get_int32_compat_dtype(numpy</span><span class="s0">, </span><span class="s1">orient):</span>
    <span class="s4"># See GH#32527</span>
    <span class="s1">dtype = np.int64</span>
    <span class="s0">if not </span><span class="s1">((numpy </span><span class="s0">is None or </span><span class="s1">orient == </span><span class="s3">&quot;index&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(numpy </span><span class="s0">is True and </span><span class="s1">orient </span><span class="s0">is None</span><span class="s1">)):</span>
        <span class="s0">if </span><span class="s1">is_platform_windows():</span>
            <span class="s1">dtype = np.int32</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">dtype = np.intp</span>

    <span class="s0">return </span><span class="s1">dtype</span>


<span class="s0">class </span><span class="s1">TestUltraJSONTests:</span>
    <span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">IS64</span><span class="s0">, </span><span class="s1">reason=</span><span class="s3">&quot;not compliant on 32-bit, xref #15865&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_encode_decimal(self):</span>
        <span class="s1">sut = decimal.Decimal(</span><span class="s3">&quot;1337.1337&quot;</span><span class="s1">)</span>
        <span class="s1">encoded = ujson.encode(sut</span><span class="s0">, </span><span class="s1">double_precision=</span><span class="s5">15</span><span class="s1">)</span>
        <span class="s1">decoded = ujson.decode(encoded)</span>
        <span class="s0">assert </span><span class="s1">decoded == </span><span class="s5">1337.1337</span>

        <span class="s1">sut = decimal.Decimal(</span><span class="s3">&quot;0.95&quot;</span><span class="s1">)</span>
        <span class="s1">encoded = ujson.encode(sut</span><span class="s0">, </span><span class="s1">double_precision=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">encoded == </span><span class="s3">&quot;1.0&quot;</span>

        <span class="s1">decoded = ujson.decode(encoded)</span>
        <span class="s0">assert </span><span class="s1">decoded == </span><span class="s5">1.0</span>

        <span class="s1">sut = decimal.Decimal(</span><span class="s3">&quot;0.94&quot;</span><span class="s1">)</span>
        <span class="s1">encoded = ujson.encode(sut</span><span class="s0">, </span><span class="s1">double_precision=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">encoded == </span><span class="s3">&quot;0.9&quot;</span>

        <span class="s1">decoded = ujson.decode(encoded)</span>
        <span class="s0">assert </span><span class="s1">decoded == </span><span class="s5">0.9</span>

        <span class="s1">sut = decimal.Decimal(</span><span class="s3">&quot;1.95&quot;</span><span class="s1">)</span>
        <span class="s1">encoded = ujson.encode(sut</span><span class="s0">, </span><span class="s1">double_precision=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">encoded == </span><span class="s3">&quot;2.0&quot;</span>

        <span class="s1">decoded = ujson.decode(encoded)</span>
        <span class="s0">assert </span><span class="s1">decoded == </span><span class="s5">2.0</span>

        <span class="s1">sut = decimal.Decimal(</span><span class="s3">&quot;-1.95&quot;</span><span class="s1">)</span>
        <span class="s1">encoded = ujson.encode(sut</span><span class="s0">, </span><span class="s1">double_precision=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">encoded == </span><span class="s3">&quot;-2.0&quot;</span>

        <span class="s1">decoded = ujson.decode(encoded)</span>
        <span class="s0">assert </span><span class="s1">decoded == -</span><span class="s5">2.0</span>

        <span class="s1">sut = decimal.Decimal(</span><span class="s3">&quot;0.995&quot;</span><span class="s1">)</span>
        <span class="s1">encoded = ujson.encode(sut</span><span class="s0">, </span><span class="s1">double_precision=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">encoded == </span><span class="s3">&quot;1.0&quot;</span>

        <span class="s1">decoded = ujson.decode(encoded)</span>
        <span class="s0">assert </span><span class="s1">decoded == </span><span class="s5">1.0</span>

        <span class="s1">sut = decimal.Decimal(</span><span class="s3">&quot;0.9995&quot;</span><span class="s1">)</span>
        <span class="s1">encoded = ujson.encode(sut</span><span class="s0">, </span><span class="s1">double_precision=</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">encoded == </span><span class="s3">&quot;1.0&quot;</span>

        <span class="s1">decoded = ujson.decode(encoded)</span>
        <span class="s0">assert </span><span class="s1">decoded == </span><span class="s5">1.0</span>

        <span class="s1">sut = decimal.Decimal(</span><span class="s3">&quot;0.99999999999999944&quot;</span><span class="s1">)</span>
        <span class="s1">encoded = ujson.encode(sut</span><span class="s0">, </span><span class="s1">double_precision=</span><span class="s5">15</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">encoded == </span><span class="s3">&quot;1.0&quot;</span>

        <span class="s1">decoded = ujson.decode(encoded)</span>
        <span class="s0">assert </span><span class="s1">decoded == </span><span class="s5">1.0</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;ensure_ascii&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_encode_string_conversion(self</span><span class="s0">, </span><span class="s1">ensure_ascii):</span>
        <span class="s1">string_input = </span><span class="s3">&quot;A string </span><span class="s0">\\ </span><span class="s3">/ </span><span class="s0">\b \f \n \r \t </span><span class="s3">&lt;/script&gt; &amp;&quot;</span>
        <span class="s1">not_html_encoded = </span><span class="s3">'&quot;A string </span><span class="s0">\\\\ \\</span><span class="s3">/ </span><span class="s0">\\</span><span class="s3">b </span><span class="s0">\\</span><span class="s3">f </span><span class="s0">\\</span><span class="s3">n </span><span class="s0">\\</span><span class="s3">r </span><span class="s0">\\</span><span class="s3">t &lt;</span><span class="s0">\\</span><span class="s3">/script&gt; &amp;&quot;'</span>
        <span class="s1">html_encoded = (</span>
            <span class="s3">'&quot;A string </span><span class="s0">\\\\ \\</span><span class="s3">/ </span><span class="s0">\\</span><span class="s3">b </span><span class="s0">\\</span><span class="s3">f </span><span class="s0">\\</span><span class="s3">n </span><span class="s0">\\</span><span class="s3">r </span><span class="s0">\\</span><span class="s3">t </span><span class="s0">\\</span><span class="s3">u003c</span><span class="s0">\\</span><span class="s3">/script</span><span class="s0">\\</span><span class="s3">u003e </span><span class="s0">\\</span><span class="s3">u0026&quot;'</span>
        <span class="s1">)</span>

        <span class="s0">def </span><span class="s1">helper(expected_output</span><span class="s0">, </span><span class="s1">**encode_kwargs):</span>
            <span class="s1">output = ujson.encode(</span>
                <span class="s1">string_input</span><span class="s0">, </span><span class="s1">ensure_ascii=ensure_ascii</span><span class="s0">, </span><span class="s1">**encode_kwargs</span>
            <span class="s1">)</span>

            <span class="s0">assert </span><span class="s1">output == expected_output</span>
            <span class="s0">assert </span><span class="s1">string_input == json.loads(output)</span>
            <span class="s0">assert </span><span class="s1">string_input == ujson.decode(output)</span>

        <span class="s4"># Default behavior assumes encode_html_chars=False.</span>
        <span class="s1">helper(not_html_encoded)</span>

        <span class="s4"># Make sure explicit encode_html_chars=False works.</span>
        <span class="s1">helper(not_html_encoded</span><span class="s0">, </span><span class="s1">encode_html_chars=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s4"># Make sure explicit encode_html_chars=True does the encoding.</span>
        <span class="s1">helper(html_encoded</span><span class="s0">, </span><span class="s1">encode_html_chars=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;long_number&quot;</span><span class="s0">, </span><span class="s1">[-</span><span class="s5">4342969734183514</span><span class="s0">, </span><span class="s1">-</span><span class="s5">12345678901234.56789012</span><span class="s0">, </span><span class="s1">-</span><span class="s5">528656961.4399388</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_double_long_numbers(self</span><span class="s0">, </span><span class="s1">long_number):</span>
        <span class="s1">sut = {</span><span class="s3">&quot;a&quot;</span><span class="s1">: long_number}</span>
        <span class="s1">encoded = ujson.encode(sut</span><span class="s0">, </span><span class="s1">double_precision=</span><span class="s5">15</span><span class="s1">)</span>

        <span class="s1">decoded = ujson.decode(encoded)</span>
        <span class="s0">assert </span><span class="s1">sut == decoded</span>

    <span class="s0">def </span><span class="s1">test_encode_non_c_locale(self):</span>
        <span class="s1">lc_category = locale.LC_NUMERIC</span>

        <span class="s4"># We just need one of these locales to work.</span>
        <span class="s0">for </span><span class="s1">new_locale </span><span class="s0">in </span><span class="s1">(</span><span class="s3">&quot;it_IT.UTF-8&quot;</span><span class="s0">, </span><span class="s3">&quot;Italian_Italy&quot;</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">tm.can_set_locale(new_locale</span><span class="s0">, </span><span class="s1">lc_category):</span>
                <span class="s0">with </span><span class="s1">tm.set_locale(new_locale</span><span class="s0">, </span><span class="s1">lc_category):</span>
                    <span class="s0">assert </span><span class="s1">ujson.loads(ujson.dumps(</span><span class="s5">4.78e60</span><span class="s1">)) == </span><span class="s5">4.78e60</span>
                    <span class="s0">assert </span><span class="s1">ujson.loads(</span><span class="s3">&quot;4.78&quot;</span><span class="s0">, </span><span class="s1">precise_float=</span><span class="s0">True</span><span class="s1">) == </span><span class="s5">4.78</span>
                <span class="s0">break</span>

    <span class="s0">def </span><span class="s1">test_decimal_decode_test_precise(self):</span>
        <span class="s1">sut = {</span><span class="s3">&quot;a&quot;</span><span class="s1">: </span><span class="s5">4.56</span><span class="s1">}</span>
        <span class="s1">encoded = ujson.encode(sut)</span>
        <span class="s1">decoded = ujson.decode(encoded</span><span class="s0">, </span><span class="s1">precise_float=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">sut == decoded</span>

    <span class="s0">def </span><span class="s1">test_encode_double_tiny_exponential(self):</span>
        <span class="s1">num = </span><span class="s5">1e-40</span>
        <span class="s0">assert </span><span class="s1">num == ujson.decode(ujson.encode(num))</span>
        <span class="s1">num = </span><span class="s5">1e-100</span>
        <span class="s0">assert </span><span class="s1">num == ujson.decode(ujson.encode(num))</span>
        <span class="s1">num = -</span><span class="s5">1e-45</span>
        <span class="s0">assert </span><span class="s1">num == ujson.decode(ujson.encode(num))</span>
        <span class="s1">num = -</span><span class="s5">1e-145</span>
        <span class="s0">assert </span><span class="s1">np.allclose(num</span><span class="s0">, </span><span class="s1">ujson.decode(ujson.encode(num)))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;unicode_key&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;key1&quot;</span><span class="s0">, </span><span class="s3">&quot;بن&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_encode_dict_with_unicode_keys(self</span><span class="s0">, </span><span class="s1">unicode_key):</span>
        <span class="s1">unicode_dict = {unicode_key: </span><span class="s3">&quot;value1&quot;</span><span class="s1">}</span>
        <span class="s0">assert </span><span class="s1">unicode_dict == ujson.decode(ujson.encode(unicode_dict))</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;double_input&quot;</span><span class="s0">, </span><span class="s1">[math.pi</span><span class="s0">, </span><span class="s1">-math.pi]  </span><span class="s4"># Should work with negatives too.</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_encode_double_conversion(self</span><span class="s0">, </span><span class="s1">double_input):</span>
        <span class="s1">output = ujson.encode(double_input)</span>
        <span class="s0">assert </span><span class="s1">round(double_input</span><span class="s0">, </span><span class="s5">5</span><span class="s1">) == round(json.loads(output)</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">round(double_input</span><span class="s0">, </span><span class="s5">5</span><span class="s1">) == round(ujson.decode(output)</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_encode_with_decimal(self):</span>
        <span class="s1">decimal_input = </span><span class="s5">1.0</span>
        <span class="s1">output = ujson.encode(decimal_input)</span>

        <span class="s0">assert </span><span class="s1">output == </span><span class="s3">&quot;1.0&quot;</span>

    <span class="s0">def </span><span class="s1">test_encode_array_of_nested_arrays(self):</span>
        <span class="s1">nested_input = [[[[]]]] * </span><span class="s5">20</span>
        <span class="s1">output = ujson.encode(nested_input)</span>

        <span class="s0">assert </span><span class="s1">nested_input == json.loads(output)</span>
        <span class="s0">assert </span><span class="s1">nested_input == ujson.decode(output)</span>

        <span class="s1">nested_input = np.array(nested_input)</span>
        <span class="s1">tm.assert_numpy_array_equal(</span>
            <span class="s1">nested_input</span><span class="s0">, </span><span class="s1">ujson.decode(output</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True, </span><span class="s1">dtype=nested_input.dtype)</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_encode_array_of_doubles(self):</span>
        <span class="s1">doubles_input = [</span><span class="s5">31337.31337</span><span class="s0">, </span><span class="s5">31337.31337</span><span class="s0">, </span><span class="s5">31337.31337</span><span class="s0">, </span><span class="s5">31337.31337</span><span class="s1">] * </span><span class="s5">10</span>
        <span class="s1">output = ujson.encode(doubles_input)</span>

        <span class="s0">assert </span><span class="s1">doubles_input == json.loads(output)</span>
        <span class="s0">assert </span><span class="s1">doubles_input == ujson.decode(output)</span>

        <span class="s1">tm.assert_numpy_array_equal(</span>
            <span class="s1">np.array(doubles_input)</span><span class="s0">, </span><span class="s1">ujson.decode(output</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_double_precision(self):</span>
        <span class="s1">double_input = </span><span class="s5">30.012345678901234</span>
        <span class="s1">output = ujson.encode(double_input</span><span class="s0">, </span><span class="s1">double_precision=</span><span class="s5">15</span><span class="s1">)</span>

        <span class="s0">assert </span><span class="s1">double_input == json.loads(output)</span>
        <span class="s0">assert </span><span class="s1">double_input == ujson.decode(output)</span>

        <span class="s0">for </span><span class="s1">double_precision </span><span class="s0">in </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">9</span><span class="s1">):</span>
            <span class="s1">output = ujson.encode(double_input</span><span class="s0">, </span><span class="s1">double_precision=double_precision)</span>
            <span class="s1">rounded_input = round(double_input</span><span class="s0">, </span><span class="s1">double_precision)</span>

            <span class="s0">assert </span><span class="s1">rounded_input == json.loads(output)</span>
            <span class="s0">assert </span><span class="s1">rounded_input == ujson.decode(output)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;invalid_val&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s5">20</span><span class="s0">,</span>
            <span class="s1">-</span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">pytest.param(</span>
                <span class="s3">&quot;9&quot;</span><span class="s0">,</span>
                <span class="s1">marks=pytest.mark.xfail(PY310</span><span class="s0">, </span><span class="s1">reason=</span><span class="s3">&quot;Failing on Python 3.10 GH41940&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">pytest.param(</span>
                <span class="s0">None,</span>
                <span class="s1">marks=pytest.mark.xfail(PY310</span><span class="s0">, </span><span class="s1">reason=</span><span class="s3">&quot;Failing on Python 3.10 GH41940&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_invalid_double_precision(self</span><span class="s0">, </span><span class="s1">invalid_val):</span>
        <span class="s1">double_input = </span><span class="s5">30.12345678901234567890</span>
        <span class="s1">expected_exception = ValueError </span><span class="s0">if </span><span class="s1">isinstance(invalid_val</span><span class="s0">, </span><span class="s1">int) </span><span class="s0">else </span><span class="s1">TypeError</span>
        <span class="s1">msg = (</span>
            <span class="s3">r&quot;Invalid value '.*' for option 'double_precision', max is '15'|&quot;</span>
            <span class="s3">r&quot;an integer is required \(got type &quot;</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(expected_exception</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">ujson.encode(double_input</span><span class="s0">, </span><span class="s1">double_precision=invalid_val)</span>

    <span class="s0">def </span><span class="s1">test_encode_string_conversion2(self):</span>
        <span class="s1">string_input = </span><span class="s3">&quot;A string </span><span class="s0">\\ </span><span class="s3">/ </span><span class="s0">\b \f \n \r \t</span><span class="s3">&quot;</span>
        <span class="s1">output = ujson.encode(string_input)</span>

        <span class="s0">assert </span><span class="s1">string_input == json.loads(output)</span>
        <span class="s0">assert </span><span class="s1">string_input == ujson.decode(output)</span>
        <span class="s0">assert </span><span class="s1">output == </span><span class="s3">'&quot;A string </span><span class="s0">\\\\ \\</span><span class="s3">/ </span><span class="s0">\\</span><span class="s3">b </span><span class="s0">\\</span><span class="s3">f </span><span class="s0">\\</span><span class="s3">n </span><span class="s0">\\</span><span class="s3">r </span><span class="s0">\\</span><span class="s3">t&quot;'</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;unicode_input&quot;</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">&quot;Räksmörgås اسامة بن محمد بن عوض بن لادن&quot;</span><span class="s0">, </span><span class="s3">&quot;</span><span class="s0">\xe6\x97\xa5\xd1\x88</span><span class="s3">&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_encode_unicode_conversion(self</span><span class="s0">, </span><span class="s1">unicode_input):</span>
        <span class="s1">enc = ujson.encode(unicode_input)</span>
        <span class="s1">dec = ujson.decode(enc)</span>

        <span class="s0">assert </span><span class="s1">enc == json.dumps(unicode_input)</span>
        <span class="s0">assert </span><span class="s1">dec == json.loads(enc)</span>

    <span class="s0">def </span><span class="s1">test_encode_control_escaping(self):</span>
        <span class="s1">escaped_input = </span><span class="s3">&quot;</span><span class="s0">\x19</span><span class="s3">&quot;</span>
        <span class="s1">enc = ujson.encode(escaped_input)</span>
        <span class="s1">dec = ujson.decode(enc)</span>

        <span class="s0">assert </span><span class="s1">escaped_input == dec</span>
        <span class="s0">assert </span><span class="s1">enc == json.dumps(escaped_input)</span>

    <span class="s0">def </span><span class="s1">test_encode_unicode_surrogate_pair(self):</span>
        <span class="s1">surrogate_input = </span><span class="s3">&quot;</span><span class="s0">\xf0\x90\x8d\x86</span><span class="s3">&quot;</span>
        <span class="s1">enc = ujson.encode(surrogate_input)</span>
        <span class="s1">dec = ujson.decode(enc)</span>

        <span class="s0">assert </span><span class="s1">enc == json.dumps(surrogate_input)</span>
        <span class="s0">assert </span><span class="s1">dec == json.loads(enc)</span>

    <span class="s0">def </span><span class="s1">test_encode_unicode_4bytes_utf8(self):</span>
        <span class="s1">four_bytes_input = </span><span class="s3">&quot;</span><span class="s0">\xf0\x91\x80\xb0</span><span class="s3">TRAILINGNORMAL&quot;</span>
        <span class="s1">enc = ujson.encode(four_bytes_input)</span>
        <span class="s1">dec = ujson.decode(enc)</span>

        <span class="s0">assert </span><span class="s1">enc == json.dumps(four_bytes_input)</span>
        <span class="s0">assert </span><span class="s1">dec == json.loads(enc)</span>

    <span class="s0">def </span><span class="s1">test_encode_unicode_4bytes_utf8highest(self):</span>
        <span class="s1">four_bytes_input = </span><span class="s3">&quot;</span><span class="s0">\xf3\xbf\xbf\xbf</span><span class="s3">TRAILINGNORMAL&quot;</span>
        <span class="s1">enc = ujson.encode(four_bytes_input)</span>

        <span class="s1">dec = ujson.decode(enc)</span>

        <span class="s0">assert </span><span class="s1">enc == json.dumps(four_bytes_input)</span>
        <span class="s0">assert </span><span class="s1">dec == json.loads(enc)</span>

    <span class="s0">def </span><span class="s1">test_encode_array_in_array(self):</span>
        <span class="s1">arr_in_arr_input = [[[[]]]]</span>
        <span class="s1">output = ujson.encode(arr_in_arr_input)</span>

        <span class="s0">assert </span><span class="s1">arr_in_arr_input == json.loads(output)</span>
        <span class="s0">assert </span><span class="s1">output == json.dumps(arr_in_arr_input)</span>
        <span class="s0">assert </span><span class="s1">arr_in_arr_input == ujson.decode(output)</span>

        <span class="s1">tm.assert_numpy_array_equal(</span>
            <span class="s1">np.array(arr_in_arr_input)</span><span class="s0">, </span><span class="s1">ujson.decode(output</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;num_input&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s5">31337</span><span class="s0">,</span>
            <span class="s1">-</span><span class="s5">31337</span><span class="s0">,  </span><span class="s4"># Negative number.</span>
            <span class="s1">-</span><span class="s5">9223372036854775808</span><span class="s0">,  </span><span class="s4"># Large negative number.</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_encode_num_conversion(self</span><span class="s0">, </span><span class="s1">num_input):</span>
        <span class="s1">output = ujson.encode(num_input)</span>
        <span class="s0">assert </span><span class="s1">num_input == json.loads(output)</span>
        <span class="s0">assert </span><span class="s1">output == json.dumps(num_input)</span>
        <span class="s0">assert </span><span class="s1">num_input == ujson.decode(output)</span>

    <span class="s0">def </span><span class="s1">test_encode_list_conversion(self):</span>
        <span class="s1">list_input = [</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span>
        <span class="s1">output = ujson.encode(list_input)</span>

        <span class="s0">assert </span><span class="s1">list_input == json.loads(output)</span>
        <span class="s0">assert </span><span class="s1">list_input == ujson.decode(output)</span>

        <span class="s1">tm.assert_numpy_array_equal(</span>
            <span class="s1">np.array(list_input)</span><span class="s0">, </span><span class="s1">ujson.decode(output</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_encode_dict_conversion(self):</span>
        <span class="s1">dict_input = {</span><span class="s3">&quot;k1&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">, </span><span class="s3">&quot;k2&quot;</span><span class="s1">: </span><span class="s5">2</span><span class="s0">, </span><span class="s3">&quot;k3&quot;</span><span class="s1">: </span><span class="s5">3</span><span class="s0">, </span><span class="s3">&quot;k4&quot;</span><span class="s1">: </span><span class="s5">4</span><span class="s1">}</span>
        <span class="s1">output = ujson.encode(dict_input)</span>

        <span class="s0">assert </span><span class="s1">dict_input == json.loads(output)</span>
        <span class="s0">assert </span><span class="s1">dict_input == ujson.decode(output)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;builtin_value&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_encode_builtin_values_conversion(self</span><span class="s0">, </span><span class="s1">builtin_value):</span>
        <span class="s1">output = ujson.encode(builtin_value)</span>
        <span class="s0">assert </span><span class="s1">builtin_value == json.loads(output)</span>
        <span class="s0">assert </span><span class="s1">output == json.dumps(builtin_value)</span>
        <span class="s0">assert </span><span class="s1">builtin_value == ujson.decode(output)</span>

    <span class="s0">def </span><span class="s1">test_encode_datetime_conversion(self):</span>
        <span class="s1">datetime_input = datetime.datetime.fromtimestamp(time.time())</span>
        <span class="s1">output = ujson.encode(datetime_input</span><span class="s0">, </span><span class="s1">date_unit=</span><span class="s3">&quot;s&quot;</span><span class="s1">)</span>
        <span class="s1">expected = calendar.timegm(datetime_input.utctimetuple())</span>

        <span class="s0">assert </span><span class="s1">int(expected) == json.loads(output)</span>
        <span class="s0">assert </span><span class="s1">int(expected) == ujson.decode(output)</span>

    <span class="s0">def </span><span class="s1">test_encode_date_conversion(self):</span>
        <span class="s1">date_input = datetime.date.fromtimestamp(time.time())</span>
        <span class="s1">output = ujson.encode(date_input</span><span class="s0">, </span><span class="s1">date_unit=</span><span class="s3">&quot;s&quot;</span><span class="s1">)</span>

        <span class="s1">tup = (date_input.year</span><span class="s0">, </span><span class="s1">date_input.month</span><span class="s0">, </span><span class="s1">date_input.day</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">expected = calendar.timegm(tup)</span>

        <span class="s0">assert </span><span class="s1">int(expected) == json.loads(output)</span>
        <span class="s0">assert </span><span class="s1">int(expected) == ujson.decode(output)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;test&quot;</span><span class="s0">,</span>
        <span class="s1">[datetime.time()</span><span class="s0">, </span><span class="s1">datetime.time(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">datetime.time(</span><span class="s5">10</span><span class="s0">, </span><span class="s5">12</span><span class="s0">, </span><span class="s5">15</span><span class="s0">, </span><span class="s5">343243</span><span class="s1">)]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_encode_time_conversion_basic(self</span><span class="s0">, </span><span class="s1">test):</span>
        <span class="s1">output = ujson.encode(test)</span>
        <span class="s1">expected = </span><span class="s3">f'&quot;</span><span class="s0">{</span><span class="s1">test.isoformat()</span><span class="s0">}</span><span class="s3">&quot;'</span>
        <span class="s0">assert </span><span class="s1">expected == output</span>

    <span class="s0">def </span><span class="s1">test_encode_time_conversion_pytz(self):</span>
        <span class="s4"># see gh-11473: to_json segfaults with timezone-aware datetimes</span>
        <span class="s1">test = datetime.time(</span><span class="s5">10</span><span class="s0">, </span><span class="s5">12</span><span class="s0">, </span><span class="s5">15</span><span class="s0">, </span><span class="s5">343243</span><span class="s0">, </span><span class="s1">pytz.utc)</span>
        <span class="s1">output = ujson.encode(test)</span>
        <span class="s1">expected = </span><span class="s3">f'&quot;</span><span class="s0">{</span><span class="s1">test.isoformat()</span><span class="s0">}</span><span class="s3">&quot;'</span>
        <span class="s0">assert </span><span class="s1">expected == output</span>

    <span class="s0">def </span><span class="s1">test_encode_time_conversion_dateutil(self):</span>
        <span class="s4"># see gh-11473: to_json segfaults with timezone-aware datetimes</span>
        <span class="s1">test = datetime.time(</span><span class="s5">10</span><span class="s0">, </span><span class="s5">12</span><span class="s0">, </span><span class="s5">15</span><span class="s0">, </span><span class="s5">343243</span><span class="s0">, </span><span class="s1">dateutil.tz.tzutc())</span>
        <span class="s1">output = ujson.encode(test)</span>
        <span class="s1">expected = </span><span class="s3">f'&quot;</span><span class="s0">{</span><span class="s1">test.isoformat()</span><span class="s0">}</span><span class="s3">&quot;'</span>
        <span class="s0">assert </span><span class="s1">expected == output</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;decoded_input&quot;</span><span class="s0">, </span><span class="s1">[NaT</span><span class="s0">, </span><span class="s1">np.datetime64(</span><span class="s3">&quot;NaT&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf]</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_encode_as_null(self</span><span class="s0">, </span><span class="s1">decoded_input):</span>
        <span class="s0">assert </span><span class="s1">ujson.encode(decoded_input) == </span><span class="s3">&quot;null&quot;</span><span class="s0">, </span><span class="s3">&quot;Expected null&quot;</span>

    <span class="s0">def </span><span class="s1">test_datetime_units(self):</span>
        <span class="s1">val = datetime.datetime(</span><span class="s5">2013</span><span class="s0">, </span><span class="s5">8</span><span class="s0">, </span><span class="s5">17</span><span class="s0">, </span><span class="s5">21</span><span class="s0">, </span><span class="s5">17</span><span class="s0">, </span><span class="s5">12</span><span class="s0">, </span><span class="s5">215504</span><span class="s1">)</span>
        <span class="s1">stamp = Timestamp(val)</span>

        <span class="s1">roundtrip = ujson.decode(ujson.encode(val</span><span class="s0">, </span><span class="s1">date_unit=</span><span class="s3">&quot;s&quot;</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">roundtrip == stamp.value // </span><span class="s5">10 </span><span class="s1">** </span><span class="s5">9</span>

        <span class="s1">roundtrip = ujson.decode(ujson.encode(val</span><span class="s0">, </span><span class="s1">date_unit=</span><span class="s3">&quot;ms&quot;</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">roundtrip == stamp.value // </span><span class="s5">10 </span><span class="s1">** </span><span class="s5">6</span>

        <span class="s1">roundtrip = ujson.decode(ujson.encode(val</span><span class="s0">, </span><span class="s1">date_unit=</span><span class="s3">&quot;us&quot;</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">roundtrip == stamp.value // </span><span class="s5">10 </span><span class="s1">** </span><span class="s5">3</span>

        <span class="s1">roundtrip = ujson.decode(ujson.encode(val</span><span class="s0">, </span><span class="s1">date_unit=</span><span class="s3">&quot;ns&quot;</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">roundtrip == stamp.value</span>

        <span class="s1">msg = </span><span class="s3">&quot;Invalid value 'foo' for option 'date_unit'&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">ujson.encode(val</span><span class="s0">, </span><span class="s1">date_unit=</span><span class="s3">&quot;foo&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_encode_to_utf8(self):</span>
        <span class="s1">unencoded = </span><span class="s3">&quot;</span><span class="s0">\xe6\x97\xa5\xd1\x88</span><span class="s3">&quot;</span>

        <span class="s1">enc = ujson.encode(unencoded</span><span class="s0">, </span><span class="s1">ensure_ascii=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">dec = ujson.decode(enc)</span>

        <span class="s0">assert </span><span class="s1">enc == json.dumps(unencoded</span><span class="s0">, </span><span class="s1">ensure_ascii=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">dec == json.loads(enc)</span>

    <span class="s0">def </span><span class="s1">test_decode_from_unicode(self):</span>
        <span class="s1">unicode_input = </span><span class="s3">'{&quot;obj&quot;: 31337}'</span>

        <span class="s1">dec1 = ujson.decode(unicode_input)</span>
        <span class="s1">dec2 = ujson.decode(str(unicode_input))</span>

        <span class="s0">assert </span><span class="s1">dec1 == dec2</span>

    <span class="s0">def </span><span class="s1">test_encode_recursion_max(self):</span>
        <span class="s4"># 8 is the max recursion depth</span>

        <span class="s0">class </span><span class="s1">O2:</span>
            <span class="s1">member = </span><span class="s5">0</span>
            <span class="s0">pass</span>

        <span class="s0">class </span><span class="s1">O1:</span>
            <span class="s1">member = </span><span class="s5">0</span>
            <span class="s0">pass</span>

        <span class="s1">decoded_input = O1()</span>
        <span class="s1">decoded_input.member = O2()</span>
        <span class="s1">decoded_input.member.member = decoded_input</span>

        <span class="s0">with </span><span class="s1">pytest.raises(OverflowError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;Maximum recursion level reached&quot;</span><span class="s1">):</span>
            <span class="s1">ujson.encode(decoded_input)</span>

    <span class="s0">def </span><span class="s1">test_decode_jibberish(self):</span>
        <span class="s1">jibberish = </span><span class="s3">&quot;fdsa sda v9sa fdsa&quot;</span>
        <span class="s1">msg = </span><span class="s3">&quot;Unexpected character found when decoding 'false'&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">ujson.decode(jibberish)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;broken_json&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s3">&quot;[&quot;</span><span class="s0">,  </span><span class="s4"># Broken array start.</span>
            <span class="s3">&quot;{&quot;</span><span class="s0">,  </span><span class="s4"># Broken object start.</span>
            <span class="s3">&quot;]&quot;</span><span class="s0">,  </span><span class="s4"># Broken array end.</span>
            <span class="s3">&quot;}&quot;</span><span class="s0">,  </span><span class="s4"># Broken object end.</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_decode_broken_json(self</span><span class="s0">, </span><span class="s1">broken_json):</span>
        <span class="s1">msg = </span><span class="s3">&quot;Expected object or value&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">ujson.decode(broken_json)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;too_big_char&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;[&quot;</span><span class="s0">, </span><span class="s3">&quot;{&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_decode_depth_too_big(self</span><span class="s0">, </span><span class="s1">too_big_char):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;Reached object decoding depth limit&quot;</span><span class="s1">):</span>
            <span class="s1">ujson.decode(too_big_char * (</span><span class="s5">1024 </span><span class="s1">* </span><span class="s5">1024</span><span class="s1">))</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;bad_string&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s3">'&quot;TESTING'</span><span class="s0">,  </span><span class="s4"># Unterminated.</span>
            <span class="s3">'&quot;TESTING</span><span class="s0">\\</span><span class="s3">&quot;'</span><span class="s0">,  </span><span class="s4"># Unterminated escape.</span>
            <span class="s3">&quot;tru&quot;</span><span class="s0">,  </span><span class="s4"># Broken True.</span>
            <span class="s3">&quot;fa&quot;</span><span class="s0">,  </span><span class="s4"># Broken False.</span>
            <span class="s3">&quot;n&quot;</span><span class="s0">,  </span><span class="s4"># Broken None.</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_decode_bad_string(self</span><span class="s0">, </span><span class="s1">bad_string):</span>
        <span class="s1">msg = (</span>
            <span class="s3">&quot;Unexpected character found when decoding|&quot;</span>
            <span class="s3">&quot;Unmatched ''</span><span class="s0">\&quot;</span><span class="s3">' when when decoding 'string'&quot;</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">ujson.decode(bad_string)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;broken_json, err_msg&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s3">'{{1337:&quot;&quot;}}'</span><span class="s0">,</span>
                <span class="s3">&quot;Key name of object must be 'string' when decoding 'object'&quot;</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">'{{&quot;key&quot;:&quot;}'</span><span class="s0">, </span><span class="s3">&quot;Unmatched ''</span><span class="s0">\&quot;</span><span class="s3">' when when decoding 'string'&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">&quot;[[[true&quot;</span><span class="s0">, </span><span class="s3">&quot;Unexpected character found when decoding array value (2)&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_decode_broken_json_leak(self</span><span class="s0">, </span><span class="s1">broken_json</span><span class="s0">, </span><span class="s1">err_msg):</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1000</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=re.escape(err_msg)):</span>
                <span class="s1">ujson.decode(broken_json)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;invalid_dict&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s3">&quot;{{{{31337}}}}&quot;</span><span class="s0">,  </span><span class="s4"># No key.</span>
            <span class="s3">'{{{{&quot;key&quot;:}}}}'</span><span class="s0">,  </span><span class="s4"># No value.</span>
            <span class="s3">'{{{{&quot;key&quot;}}}}'</span><span class="s0">,  </span><span class="s4"># No colon or value.</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_decode_invalid_dict(self</span><span class="s0">, </span><span class="s1">invalid_dict):</span>
        <span class="s1">msg = (</span>
            <span class="s3">&quot;Key name of object must be 'string' when decoding 'object'|&quot;</span>
            <span class="s3">&quot;No ':' found when decoding object value|&quot;</span>
            <span class="s3">&quot;Expected object or value&quot;</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">ujson.decode(invalid_dict)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;numeric_int_as_str&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;31337&quot;</span><span class="s0">, </span><span class="s3">&quot;-31337&quot;</span><span class="s1">]  </span><span class="s4"># Should work with negatives.</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_decode_numeric_int(self</span><span class="s0">, </span><span class="s1">numeric_int_as_str):</span>
        <span class="s0">assert </span><span class="s1">int(numeric_int_as_str) == ujson.decode(numeric_int_as_str)</span>

    <span class="s0">def </span><span class="s1">test_encode_null_character(self):</span>
        <span class="s1">wrapped_input = </span><span class="s3">&quot;31337 </span><span class="s0">\x00 </span><span class="s3">1337&quot;</span>
        <span class="s1">output = ujson.encode(wrapped_input)</span>

        <span class="s0">assert </span><span class="s1">wrapped_input == json.loads(output)</span>
        <span class="s0">assert </span><span class="s1">output == json.dumps(wrapped_input)</span>
        <span class="s0">assert </span><span class="s1">wrapped_input == ujson.decode(output)</span>

        <span class="s1">alone_input = </span><span class="s3">&quot;</span><span class="s0">\x00</span><span class="s3">&quot;</span>
        <span class="s1">output = ujson.encode(alone_input)</span>

        <span class="s0">assert </span><span class="s1">alone_input == json.loads(output)</span>
        <span class="s0">assert </span><span class="s1">output == json.dumps(alone_input)</span>
        <span class="s0">assert </span><span class="s1">alone_input == ujson.decode(output)</span>
        <span class="s0">assert </span><span class="s3">'&quot;  </span><span class="s0">\\</span><span class="s3">u0000</span><span class="s0">\\</span><span class="s3">r</span><span class="s0">\\</span><span class="s3">n &quot;' </span><span class="s1">== ujson.dumps(</span><span class="s3">&quot;  </span><span class="s0">\u0000\r\n </span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_decode_null_character(self):</span>
        <span class="s1">wrapped_input = </span><span class="s3">'&quot;31337 </span><span class="s0">\\</span><span class="s3">u0000 31337&quot;'</span>
        <span class="s0">assert </span><span class="s1">ujson.decode(wrapped_input) == json.loads(wrapped_input)</span>

    <span class="s0">def </span><span class="s1">test_encode_list_long_conversion(self):</span>
        <span class="s1">long_input = [</span>
            <span class="s5">9223372036854775807</span><span class="s0">,</span>
            <span class="s5">9223372036854775807</span><span class="s0">,</span>
            <span class="s5">9223372036854775807</span><span class="s0">,</span>
            <span class="s5">9223372036854775807</span><span class="s0">,</span>
            <span class="s5">9223372036854775807</span><span class="s0">,</span>
            <span class="s5">9223372036854775807</span><span class="s0">,</span>
        <span class="s1">]</span>
        <span class="s1">output = ujson.encode(long_input)</span>

        <span class="s0">assert </span><span class="s1">long_input == json.loads(output)</span>
        <span class="s0">assert </span><span class="s1">long_input == ujson.decode(output)</span>

        <span class="s1">tm.assert_numpy_array_equal(</span>
            <span class="s1">np.array(long_input)</span><span class="s0">, </span><span class="s1">ujson.decode(output</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True, </span><span class="s1">dtype=np.int64)</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;long_input&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">9223372036854775807</span><span class="s0">, </span><span class="s5">18446744073709551615</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_encode_long_conversion(self</span><span class="s0">, </span><span class="s1">long_input):</span>
        <span class="s1">output = ujson.encode(long_input)</span>

        <span class="s0">assert </span><span class="s1">long_input == json.loads(output)</span>
        <span class="s0">assert </span><span class="s1">output == json.dumps(long_input)</span>
        <span class="s0">assert </span><span class="s1">long_input == ujson.decode(output)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;bigNum&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">2 </span><span class="s1">** </span><span class="s5">64</span><span class="s0">, </span><span class="s1">-(</span><span class="s5">2 </span><span class="s1">** </span><span class="s5">63</span><span class="s1">) - </span><span class="s5">1</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_dumps_ints_larger_than_maxsize(self</span><span class="s0">, </span><span class="s1">bigNum):</span>
        <span class="s1">encoding = ujson.encode(bigNum)</span>
        <span class="s0">assert </span><span class="s1">str(bigNum) == encoding</span>

        <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s3">&quot;Value is too big|Value is too small&quot;</span><span class="s0">,</span>
        <span class="s1">):</span>
            <span class="s0">assert </span><span class="s1">ujson.loads(encoding) == bigNum</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;int_exp&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;1337E40&quot;</span><span class="s0">, </span><span class="s3">&quot;1.337E40&quot;</span><span class="s0">, </span><span class="s3">&quot;1337E+9&quot;</span><span class="s0">, </span><span class="s3">&quot;1.337e+40&quot;</span><span class="s0">, </span><span class="s3">&quot;1.337E-4&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_decode_numeric_int_exp(self</span><span class="s0">, </span><span class="s1">int_exp):</span>
        <span class="s0">assert </span><span class="s1">ujson.decode(int_exp) == json.loads(int_exp)</span>

    <span class="s0">def </span><span class="s1">test_loads_non_str_bytes_raises(self):</span>
        <span class="s1">msg = </span><span class="s3">&quot;Expected 'str' or 'bytes'&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">ujson.loads(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;val&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">3590016419</span><span class="s0">, </span><span class="s5">2 </span><span class="s1">** </span><span class="s5">31</span><span class="s0">, </span><span class="s5">2 </span><span class="s1">** </span><span class="s5">32</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2 </span><span class="s1">** </span><span class="s5">32</span><span class="s1">) - </span><span class="s5">1</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_decode_number_with_32bit_sign_bit(self</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s4"># Test that numbers that fit within 32 bits but would have the</span>
        <span class="s4"># sign bit set (2**31 &lt;= x &lt; 2**32) are decoded properly.</span>
        <span class="s1">doc = </span><span class="s3">f'</span><span class="s0">{{</span><span class="s3">&quot;id&quot;: </span><span class="s0">{</span><span class="s1">val</span><span class="s0">}}}</span><span class="s3">'</span>
        <span class="s0">assert </span><span class="s1">ujson.decode(doc)[</span><span class="s3">&quot;id&quot;</span><span class="s1">] == val</span>

    <span class="s0">def </span><span class="s1">test_encode_big_escape(self):</span>
        <span class="s4"># Make sure no Exception is raised.</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">10</span><span class="s1">):</span>
            <span class="s1">base = </span><span class="s3">&quot;</span><span class="s0">\u00e5</span><span class="s3">&quot;</span><span class="s1">.encode()</span>
            <span class="s1">escape_input = base * </span><span class="s5">1024 </span><span class="s1">* </span><span class="s5">1024 </span><span class="s1">* </span><span class="s5">2</span>
            <span class="s1">ujson.encode(escape_input)</span>

    <span class="s0">def </span><span class="s1">test_decode_big_escape(self):</span>
        <span class="s4"># Make sure no Exception is raised.</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">10</span><span class="s1">):</span>
            <span class="s1">base = </span><span class="s3">&quot;</span><span class="s0">\u00e5</span><span class="s3">&quot;</span><span class="s1">.encode()</span>
            <span class="s1">quote = </span><span class="s6">b'&quot;'</span>

            <span class="s1">escape_input = quote + (base * </span><span class="s5">1024 </span><span class="s1">* </span><span class="s5">1024 </span><span class="s1">* </span><span class="s5">2</span><span class="s1">) + quote</span>
            <span class="s1">ujson.decode(escape_input)</span>

    <span class="s0">def </span><span class="s1">test_to_dict(self):</span>
        <span class="s1">d = {</span><span class="s3">&quot;key&quot;</span><span class="s1">: </span><span class="s5">31337</span><span class="s1">}</span>

        <span class="s0">class </span><span class="s1">DictTest:</span>
            <span class="s0">def </span><span class="s1">toDict(self):</span>
                <span class="s0">return </span><span class="s1">d</span>

        <span class="s1">o = DictTest()</span>
        <span class="s1">output = ujson.encode(o)</span>

        <span class="s1">dec = ujson.decode(output)</span>
        <span class="s0">assert </span><span class="s1">dec == d</span>

    <span class="s0">def </span><span class="s1">test_default_handler(self):</span>
        <span class="s0">class </span><span class="s1">_TestObject:</span>
            <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">val):</span>
                <span class="s1">self.val = val</span>

            <span class="s1">@property</span>
            <span class="s0">def </span><span class="s1">recursive_attr(self):</span>
                <span class="s0">return </span><span class="s1">_TestObject(</span><span class="s3">&quot;recursive_attr&quot;</span><span class="s1">)</span>

            <span class="s0">def </span><span class="s1">__str__(self) -&gt; str:</span>
                <span class="s0">return </span><span class="s1">str(self.val)</span>

        <span class="s1">msg = </span><span class="s3">&quot;Maximum recursion level reached&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(OverflowError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">ujson.encode(_TestObject(</span><span class="s3">&quot;foo&quot;</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s3">'&quot;foo&quot;' </span><span class="s1">== ujson.encode(_TestObject(</span><span class="s3">&quot;foo&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">default_handler=str)</span>

        <span class="s0">def </span><span class="s1">my_handler(_):</span>
            <span class="s0">return </span><span class="s3">&quot;foobar&quot;</span>

        <span class="s0">assert </span><span class="s3">'&quot;foobar&quot;' </span><span class="s1">== ujson.encode(</span>
            <span class="s1">_TestObject(</span><span class="s3">&quot;foo&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">default_handler=my_handler</span>
        <span class="s1">)</span>

        <span class="s0">def </span><span class="s1">my_handler_raises(_):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;I raise for anything&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;I raise for anything&quot;</span><span class="s1">):</span>
            <span class="s1">ujson.encode(_TestObject(</span><span class="s3">&quot;foo&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">default_handler=my_handler_raises)</span>

        <span class="s0">def </span><span class="s1">my_int_handler(_):</span>
            <span class="s0">return </span><span class="s5">42</span>

        <span class="s0">assert </span><span class="s1">(</span>
            <span class="s1">ujson.decode(</span>
                <span class="s1">ujson.encode(_TestObject(</span><span class="s3">&quot;foo&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">default_handler=my_int_handler)</span>
            <span class="s1">)</span>
            <span class="s1">== </span><span class="s5">42</span>
        <span class="s1">)</span>

        <span class="s0">def </span><span class="s1">my_obj_handler(_):</span>
            <span class="s0">return </span><span class="s1">datetime.datetime(</span><span class="s5">2013</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span>

        <span class="s0">assert </span><span class="s1">ujson.decode(</span>
            <span class="s1">ujson.encode(datetime.datetime(</span><span class="s5">2013</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">) == ujson.decode(</span>
            <span class="s1">ujson.encode(_TestObject(</span><span class="s3">&quot;foo&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">default_handler=my_obj_handler)</span>
        <span class="s1">)</span>

        <span class="s1">obj_list = [_TestObject(</span><span class="s3">&quot;foo&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">_TestObject(</span><span class="s3">&quot;bar&quot;</span><span class="s1">)]</span>
        <span class="s0">assert </span><span class="s1">json.loads(json.dumps(obj_list</span><span class="s0">, </span><span class="s1">default=str)) == ujson.decode(</span>
            <span class="s1">ujson.encode(obj_list</span><span class="s0">, </span><span class="s1">default_handler=str)</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_encode_object(self):</span>
        <span class="s0">class </span><span class="s1">_TestObject:</span>
            <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">_c</span><span class="s0">, </span><span class="s1">d):</span>
                <span class="s1">self.a = a</span>
                <span class="s1">self.b = b</span>
                <span class="s1">self._c = _c</span>
                <span class="s1">self.d = d</span>

            <span class="s0">def </span><span class="s1">e(self):</span>
                <span class="s0">return </span><span class="s5">5</span>

        <span class="s4"># JSON keys should be all non-callable non-underscore attributes, see GH-42768</span>
        <span class="s1">test_object = _TestObject(a=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">b=</span><span class="s5">2</span><span class="s0">, </span><span class="s1">_c=</span><span class="s5">3</span><span class="s0">, </span><span class="s1">d=</span><span class="s5">4</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">ujson.decode(ujson.encode(test_object)) == {</span><span class="s3">&quot;a&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s1">: </span><span class="s5">2</span><span class="s0">, </span><span class="s3">&quot;d&quot;</span><span class="s1">: </span><span class="s5">4</span><span class="s1">}</span>


<span class="s0">class </span><span class="s1">TestNumpyJSONTests:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;bool_input&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_bool(self</span><span class="s0">, </span><span class="s1">bool_input):</span>
        <span class="s1">b = bool(bool_input)</span>
        <span class="s0">assert </span><span class="s1">ujson.decode(ujson.encode(b)) == b</span>

    <span class="s0">def </span><span class="s1">test_bool_array(self):</span>
        <span class="s1">bool_array = np.array(</span>
            <span class="s1">[</span><span class="s0">True, False, True, True, False, True, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=bool</span>
        <span class="s1">)</span>
        <span class="s1">output = np.array(ujson.decode(ujson.encode(bool_array))</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">tm.assert_numpy_array_equal(bool_array</span><span class="s0">, </span><span class="s1">output)</span>

    <span class="s0">def </span><span class="s1">test_int(self</span><span class="s0">, </span><span class="s1">any_int_numpy_dtype):</span>
        <span class="s1">klass = np.dtype(any_int_numpy_dtype).type</span>
        <span class="s1">num = klass(</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s0">assert </span><span class="s1">klass(ujson.decode(ujson.encode(num))) == num</span>

    <span class="s0">def </span><span class="s1">test_int_array(self</span><span class="s0">, </span><span class="s1">any_int_numpy_dtype):</span>
        <span class="s1">arr = np.arange(</span><span class="s5">100</span><span class="s0">, </span><span class="s1">dtype=int)</span>
        <span class="s1">arr_input = arr.astype(any_int_numpy_dtype)</span>

        <span class="s1">arr_output = np.array(</span>
            <span class="s1">ujson.decode(ujson.encode(arr_input))</span><span class="s0">, </span><span class="s1">dtype=any_int_numpy_dtype</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_numpy_array_equal(arr_input</span><span class="s0">, </span><span class="s1">arr_output)</span>

    <span class="s0">def </span><span class="s1">test_int_max(self</span><span class="s0">, </span><span class="s1">any_int_numpy_dtype):</span>
        <span class="s0">if </span><span class="s1">any_int_numpy_dtype </span><span class="s0">in </span><span class="s1">(</span><span class="s3">&quot;int64&quot;</span><span class="s0">, </span><span class="s3">&quot;uint64&quot;</span><span class="s1">) </span><span class="s0">and not </span><span class="s1">IS64:</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Cannot test 64-bit integer on 32-bit platform&quot;</span><span class="s1">)</span>

        <span class="s1">klass = np.dtype(any_int_numpy_dtype).type</span>

        <span class="s4"># uint64 max will always overflow,</span>
        <span class="s4"># as it's encoded to signed.</span>
        <span class="s0">if </span><span class="s1">any_int_numpy_dtype == </span><span class="s3">&quot;uint64&quot;</span><span class="s1">:</span>
            <span class="s1">num = np.iinfo(</span><span class="s3">&quot;int64&quot;</span><span class="s1">).max</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">num = np.iinfo(any_int_numpy_dtype).max</span>

        <span class="s0">assert </span><span class="s1">klass(ujson.decode(ujson.encode(num))) == num</span>

    <span class="s0">def </span><span class="s1">test_float(self</span><span class="s0">, </span><span class="s1">float_numpy_dtype):</span>
        <span class="s1">klass = np.dtype(float_numpy_dtype).type</span>
        <span class="s1">num = klass(</span><span class="s5">256.2013</span><span class="s1">)</span>

        <span class="s0">assert </span><span class="s1">klass(ujson.decode(ujson.encode(num))) == num</span>

    <span class="s0">def </span><span class="s1">test_float_array(self</span><span class="s0">, </span><span class="s1">float_numpy_dtype):</span>
        <span class="s1">arr = np.arange(</span><span class="s5">12.5</span><span class="s0">, </span><span class="s5">185.72</span><span class="s0">, </span><span class="s5">1.7322</span><span class="s0">, </span><span class="s1">dtype=float)</span>
        <span class="s1">float_input = arr.astype(float_numpy_dtype)</span>

        <span class="s1">float_output = np.array(</span>
            <span class="s1">ujson.decode(ujson.encode(float_input</span><span class="s0">, </span><span class="s1">double_precision=</span><span class="s5">15</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">dtype=float_numpy_dtype</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_almost_equal(float_input</span><span class="s0">, </span><span class="s1">float_output)</span>

    <span class="s0">def </span><span class="s1">test_float_max(self</span><span class="s0">, </span><span class="s1">float_numpy_dtype):</span>
        <span class="s1">klass = np.dtype(float_numpy_dtype).type</span>
        <span class="s1">num = klass(np.finfo(float_numpy_dtype).max / </span><span class="s5">10</span><span class="s1">)</span>

        <span class="s1">tm.assert_almost_equal(</span>
            <span class="s1">klass(ujson.decode(ujson.encode(num</span><span class="s0">, </span><span class="s1">double_precision=</span><span class="s5">15</span><span class="s1">)))</span><span class="s0">, </span><span class="s1">num</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_array_basic(self):</span>
        <span class="s1">arr = np.arange(</span><span class="s5">96</span><span class="s1">)</span>
        <span class="s1">arr = arr.reshape((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>

        <span class="s1">tm.assert_numpy_array_equal(np.array(ujson.decode(ujson.encode(arr)))</span><span class="s0">, </span><span class="s1">arr)</span>
        <span class="s1">tm.assert_numpy_array_equal(ujson.decode(ujson.encode(arr)</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">arr)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;shape&quot;</span><span class="s0">, </span><span class="s1">[(</span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">100</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test_array_reshaped(self</span><span class="s0">, </span><span class="s1">shape):</span>
        <span class="s1">arr = np.arange(</span><span class="s5">100</span><span class="s1">)</span>
        <span class="s1">arr = arr.reshape(shape)</span>

        <span class="s1">tm.assert_numpy_array_equal(np.array(ujson.decode(ujson.encode(arr)))</span><span class="s0">, </span><span class="s1">arr)</span>
        <span class="s1">tm.assert_numpy_array_equal(ujson.decode(ujson.encode(arr)</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">arr)</span>

    <span class="s0">def </span><span class="s1">test_array_list(self):</span>
        <span class="s1">arr_list = [</span>
            <span class="s3">&quot;a&quot;</span><span class="s0">,</span>
            <span class="s1">[]</span><span class="s0">,</span>
            <span class="s1">{}</span><span class="s0">,</span>
            <span class="s1">{}</span><span class="s0">,</span>
            <span class="s1">[]</span><span class="s0">,</span>
            <span class="s5">42</span><span class="s0">,</span>
            <span class="s5">97.8</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s3">&quot;key&quot;</span><span class="s1">: </span><span class="s3">&quot;val&quot;</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]</span>
        <span class="s1">arr = np.array(arr_list</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">result = np.array(ujson.decode(ujson.encode(arr))</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s0">, </span><span class="s1">arr)</span>

    <span class="s0">def </span><span class="s1">test_array_float(self):</span>
        <span class="s1">dtype = np.float32</span>

        <span class="s1">arr = np.arange(</span><span class="s5">100.202</span><span class="s0">, </span><span class="s5">200.202</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">arr = arr.reshape((</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>

        <span class="s1">arr_out = np.array(ujson.decode(ujson.encode(arr))</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">tm.assert_almost_equal(arr</span><span class="s0">, </span><span class="s1">arr_out)</span>

        <span class="s1">arr_out = ujson.decode(ujson.encode(arr)</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">tm.assert_almost_equal(arr</span><span class="s0">, </span><span class="s1">arr_out)</span>

    <span class="s0">def </span><span class="s1">test_0d_array(self):</span>
        <span class="s4"># gh-18878</span>
        <span class="s1">msg = re.escape(</span><span class="s3">&quot;array(1) (0d array) is not JSON serializable at the moment&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">ujson.encode(np.array(</span><span class="s5">1</span><span class="s1">))</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;bad_input,exc_type,err_msg,kwargs&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s1">[{}</span><span class="s0">, </span><span class="s1">[]]</span><span class="s0">,</span>
                <span class="s1">ValueError</span><span class="s0">,</span>
                <span class="s3">r&quot;nesting not supported for object or variable length dtypes&quot;</span><span class="s0">,</span>
                <span class="s1">{}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">[</span><span class="s5">42</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">TypeError</span><span class="s0">,</span>
                <span class="s3">r&quot;int\(\) argument must be a string, a bytes-like object or a( real)? &quot;</span>
                <span class="s3">r&quot;number, not 'NoneType'&quot;</span><span class="s0">,</span>
                <span class="s1">{}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">[[</span><span class="s3">&quot;a&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s5">42</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">ValueError</span><span class="s0">,</span>
                <span class="s3">r&quot;Cannot decode multidimensional arrays with variable length elements &quot;</span>
                <span class="s3">r&quot;to numpy&quot;</span><span class="s0">,</span>
                <span class="s1">{}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">[</span><span class="s5">42</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s3">&quot;a&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">TypeError</span><span class="s0">,</span>
                <span class="s3">r&quot;int\(\) argument must be a string, a bytes-like object or a( real)? &quot;</span>
                <span class="s3">r&quot;number, not 'dict'&quot;</span><span class="s0">,</span>
                <span class="s1">{}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">[</span><span class="s5">42</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s5">42</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">ValueError</span><span class="s0">,</span>
                <span class="s3">r&quot;invalid literal for int\(\) with base 10: 'a'&quot;</span><span class="s0">,</span>
                <span class="s1">{}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">ValueError</span><span class="s0">,</span>
                <span class="s3">r&quot;nesting not supported for object or variable length dtypes&quot;</span><span class="s0">,</span>
                <span class="s1">{}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">[{</span><span class="s3">&quot;a&quot;</span><span class="s1">: </span><span class="s3">&quot;b&quot;</span><span class="s1">}]</span><span class="s0">,</span>
                <span class="s1">ValueError</span><span class="s0">,</span>
                <span class="s3">r&quot;Cannot decode multidimensional arrays with variable length elements &quot;</span>
                <span class="s3">r&quot;to numpy&quot;</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s3">&quot;labelled&quot;</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">{</span><span class="s3">&quot;a&quot;</span><span class="s1">: {</span><span class="s3">&quot;b&quot;</span><span class="s1">: {</span><span class="s3">&quot;c&quot;</span><span class="s1">: </span><span class="s5">42</span><span class="s1">}}}</span><span class="s0">,</span>
                <span class="s1">ValueError</span><span class="s0">,</span>
                <span class="s3">r&quot;labels only supported up to 2 dimensions&quot;</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s3">&quot;labelled&quot;</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">[{</span><span class="s3">&quot;a&quot;</span><span class="s1">: </span><span class="s5">42</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s1">: </span><span class="s5">23</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s3">&quot;c&quot;</span><span class="s1">: </span><span class="s5">17</span><span class="s1">}]</span><span class="s0">,</span>
                <span class="s1">ValueError</span><span class="s0">,</span>
                <span class="s3">r&quot;cannot reshape array of size 3 into shape \(2,1\)&quot;</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s3">&quot;labelled&quot;</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_array_numpy_except(self</span><span class="s0">, </span><span class="s1">bad_input</span><span class="s0">, </span><span class="s1">exc_type</span><span class="s0">, </span><span class="s1">err_msg</span><span class="s0">, </span><span class="s1">kwargs):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(exc_type</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
            <span class="s1">ujson.decode(ujson.dumps(bad_input)</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_array_numpy_labelled(self):</span>
        <span class="s1">labelled_input = {</span><span class="s3">&quot;a&quot;</span><span class="s1">: []}</span>
        <span class="s1">output = ujson.loads(ujson.dumps(labelled_input)</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True, </span><span class="s1">labelled=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">(np.empty((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)) == output[</span><span class="s5">0</span><span class="s1">]).all()</span>
        <span class="s0">assert </span><span class="s1">(np.array([</span><span class="s3">&quot;a&quot;</span><span class="s1">]) == output[</span><span class="s5">1</span><span class="s1">]).all()</span>
        <span class="s0">assert </span><span class="s1">output[</span><span class="s5">2</span><span class="s1">] </span><span class="s0">is None</span>

        <span class="s1">labelled_input = [{</span><span class="s3">&quot;a&quot;</span><span class="s1">: </span><span class="s5">42</span><span class="s1">}]</span>
        <span class="s1">output = ujson.loads(ujson.dumps(labelled_input)</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True, </span><span class="s1">labelled=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">(np.array([</span><span class="s3">&quot;a&quot;</span><span class="s1">]) == output[</span><span class="s5">2</span><span class="s1">]).all()</span>
        <span class="s0">assert </span><span class="s1">(np.array([</span><span class="s5">42</span><span class="s1">]) == output[</span><span class="s5">0</span><span class="s1">]).all()</span>
        <span class="s0">assert </span><span class="s1">output[</span><span class="s5">1</span><span class="s1">] </span><span class="s0">is None</span>

        <span class="s4"># see gh-10837: write out the dump explicitly</span>
        <span class="s4"># so there is no dependency on iteration order</span>
        <span class="s1">input_dumps = </span><span class="s3">'[{&quot;a&quot;: 42, &quot;b&quot;:31}, {&quot;a&quot;: 24, &quot;c&quot;: 99}, {&quot;a&quot;: 2.4, &quot;b&quot;: 78}]'</span>
        <span class="s1">output = ujson.loads(input_dumps</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True, </span><span class="s1">labelled=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected_vals = np.array([</span><span class="s5">42</span><span class="s0">, </span><span class="s5">31</span><span class="s0">, </span><span class="s5">24</span><span class="s0">, </span><span class="s5">99</span><span class="s0">, </span><span class="s5">2.4</span><span class="s0">, </span><span class="s5">78</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=int).reshape((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">(expected_vals == output[</span><span class="s5">0</span><span class="s1">]).all()</span>
        <span class="s0">assert </span><span class="s1">output[</span><span class="s5">1</span><span class="s1">] </span><span class="s0">is None</span>
        <span class="s0">assert </span><span class="s1">(np.array([</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]) == output[</span><span class="s5">2</span><span class="s1">]).all()</span>

        <span class="s1">input_dumps = (</span>
            <span class="s3">'{&quot;1&quot;: {&quot;a&quot;: 42, &quot;b&quot;:31}, &quot;2&quot;: {&quot;a&quot;: 24, &quot;c&quot;: 99}, '</span>
            <span class="s3">'&quot;3&quot;: {&quot;a&quot;: 2.4, &quot;b&quot;: 78}}'</span>
        <span class="s1">)</span>
        <span class="s1">output = ujson.loads(input_dumps</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True, </span><span class="s1">labelled=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected_vals = np.array([</span><span class="s5">42</span><span class="s0">, </span><span class="s5">31</span><span class="s0">, </span><span class="s5">24</span><span class="s0">, </span><span class="s5">99</span><span class="s0">, </span><span class="s5">2.4</span><span class="s0">, </span><span class="s5">78</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=int).reshape((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">(expected_vals == output[</span><span class="s5">0</span><span class="s1">]).all()</span>
        <span class="s0">assert </span><span class="s1">(np.array([</span><span class="s3">&quot;1&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s0">, </span><span class="s3">&quot;3&quot;</span><span class="s1">]) == output[</span><span class="s5">1</span><span class="s1">]).all()</span>
        <span class="s0">assert </span><span class="s1">(np.array([</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]) == output[</span><span class="s5">2</span><span class="s1">]).all()</span>


<span class="s0">class </span><span class="s1">TestPandasJSONTests:</span>
    <span class="s0">def </span><span class="s1">test_dataframe(self</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">numpy):</span>
        <span class="s0">if </span><span class="s1">orient == </span><span class="s3">&quot;records&quot; </span><span class="s0">and </span><span class="s1">numpy:</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Not idiomatic pandas&quot;</span><span class="s1">)</span>

        <span class="s1">dtype = get_int32_compat_dtype(numpy</span><span class="s0">, </span><span class="s1">orient)</span>

        <span class="s1">df = DataFrame(</span>
            <span class="s1">[[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">6</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">index=[</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">columns=[</span><span class="s3">&quot;x&quot;</span><span class="s0">, </span><span class="s3">&quot;y&quot;</span><span class="s0">, </span><span class="s3">&quot;z&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">dtype=dtype</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">encode_kwargs = {} </span><span class="s0">if </span><span class="s1">orient </span><span class="s0">is None else </span><span class="s1">{</span><span class="s3">&quot;orient&quot;</span><span class="s1">: orient}</span>
        <span class="s1">decode_kwargs = {} </span><span class="s0">if </span><span class="s1">numpy </span><span class="s0">is None else </span><span class="s1">{</span><span class="s3">&quot;numpy&quot;</span><span class="s1">: numpy}</span>
        <span class="s0">assert </span><span class="s1">(df.dtypes == dtype).all()</span>

        <span class="s1">output = ujson.decode(ujson.encode(df</span><span class="s0">, </span><span class="s1">**encode_kwargs)</span><span class="s0">, </span><span class="s1">**decode_kwargs)</span>
        <span class="s0">assert </span><span class="s1">(df.dtypes == dtype).all()</span>

        <span class="s4"># Ensure proper DataFrame initialization.</span>
        <span class="s0">if </span><span class="s1">orient == </span><span class="s3">&quot;split&quot;</span><span class="s1">:</span>
            <span class="s1">dec = _clean_dict(output)</span>
            <span class="s1">output = DataFrame(**dec)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">output = DataFrame(output)</span>

        <span class="s4"># Corrections to enable DataFrame comparison.</span>
        <span class="s0">if </span><span class="s1">orient == </span><span class="s3">&quot;values&quot;</span><span class="s1">:</span>
            <span class="s1">df.columns = [</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span>
            <span class="s1">df.index = [</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s0">elif </span><span class="s1">orient == </span><span class="s3">&quot;records&quot;</span><span class="s1">:</span>
            <span class="s1">df.index = [</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s0">elif </span><span class="s1">orient == </span><span class="s3">&quot;index&quot;</span><span class="s1">:</span>
            <span class="s1">df = df.transpose()</span>

        <span class="s0">assert </span><span class="s1">(df.dtypes == dtype).all()</span>
        <span class="s1">tm.assert_frame_equal(output</span><span class="s0">, </span><span class="s1">df)</span>

    <span class="s0">def </span><span class="s1">test_dataframe_nested(self</span><span class="s0">, </span><span class="s1">orient):</span>
        <span class="s1">df = DataFrame(</span>
            <span class="s1">[[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">6</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s3">&quot;x&quot;</span><span class="s0">, </span><span class="s3">&quot;y&quot;</span><span class="s0">, </span><span class="s3">&quot;z&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>

        <span class="s1">nested = {</span><span class="s3">&quot;df1&quot;</span><span class="s1">: df</span><span class="s0">, </span><span class="s3">&quot;df2&quot;</span><span class="s1">: df.copy()}</span>
        <span class="s1">kwargs = {} </span><span class="s0">if </span><span class="s1">orient </span><span class="s0">is None else </span><span class="s1">{</span><span class="s3">&quot;orient&quot;</span><span class="s1">: orient}</span>

        <span class="s1">exp = {</span>
            <span class="s3">&quot;df1&quot;</span><span class="s1">: ujson.decode(ujson.encode(df</span><span class="s0">, </span><span class="s1">**kwargs))</span><span class="s0">,</span>
            <span class="s3">&quot;df2&quot;</span><span class="s1">: ujson.decode(ujson.encode(df</span><span class="s0">, </span><span class="s1">**kwargs))</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s0">assert </span><span class="s1">ujson.decode(ujson.encode(nested</span><span class="s0">, </span><span class="s1">**kwargs)) == exp</span>

    <span class="s0">def </span><span class="s1">test_dataframe_numpy_labelled(self</span><span class="s0">, </span><span class="s1">orient):</span>
        <span class="s0">if </span><span class="s1">orient </span><span class="s0">in </span><span class="s1">(</span><span class="s3">&quot;split&quot;</span><span class="s0">, </span><span class="s3">&quot;values&quot;</span><span class="s1">):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Incompatible with labelled=True&quot;</span><span class="s1">)</span>

        <span class="s1">df = DataFrame(</span>
            <span class="s1">[[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">6</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">index=[</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">columns=[</span><span class="s3">&quot;x&quot;</span><span class="s0">, </span><span class="s3">&quot;y&quot;</span><span class="s0">, </span><span class="s3">&quot;z&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">dtype=int</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">kwargs = {} </span><span class="s0">if </span><span class="s1">orient </span><span class="s0">is None else </span><span class="s1">{</span><span class="s3">&quot;orient&quot;</span><span class="s1">: orient}</span>

        <span class="s1">output = DataFrame(</span>
            <span class="s1">*ujson.decode(ujson.encode(df</span><span class="s0">, </span><span class="s1">**kwargs)</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True, </span><span class="s1">labelled=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">orient </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">df = df.T</span>
        <span class="s0">elif </span><span class="s1">orient == </span><span class="s3">&quot;records&quot;</span><span class="s1">:</span>
            <span class="s1">df.index = [</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span>

        <span class="s1">tm.assert_frame_equal(output</span><span class="s0">, </span><span class="s1">df)</span>

    <span class="s0">def </span><span class="s1">test_series(self</span><span class="s0">, </span><span class="s1">orient</span><span class="s0">, </span><span class="s1">numpy):</span>
        <span class="s1">dtype = get_int32_compat_dtype(numpy</span><span class="s0">, </span><span class="s1">orient)</span>
        <span class="s1">s = Series(</span>
            <span class="s1">[</span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">30</span><span class="s0">, </span><span class="s5">40</span><span class="s0">, </span><span class="s5">50</span><span class="s0">, </span><span class="s5">60</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">name=</span><span class="s3">&quot;series&quot;</span><span class="s0">,</span>
            <span class="s1">index=[</span><span class="s5">6</span><span class="s0">, </span><span class="s5">7</span><span class="s0">, </span><span class="s5">8</span><span class="s0">, </span><span class="s5">9</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">15</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">dtype=dtype</span><span class="s0">,</span>
        <span class="s1">).sort_values()</span>
        <span class="s0">assert </span><span class="s1">s.dtype == dtype</span>

        <span class="s1">encode_kwargs = {} </span><span class="s0">if </span><span class="s1">orient </span><span class="s0">is None else </span><span class="s1">{</span><span class="s3">&quot;orient&quot;</span><span class="s1">: orient}</span>
        <span class="s1">decode_kwargs = {} </span><span class="s0">if </span><span class="s1">numpy </span><span class="s0">is None else </span><span class="s1">{</span><span class="s3">&quot;numpy&quot;</span><span class="s1">: numpy}</span>

        <span class="s1">output = ujson.decode(ujson.encode(s</span><span class="s0">, </span><span class="s1">**encode_kwargs)</span><span class="s0">, </span><span class="s1">**decode_kwargs)</span>
        <span class="s0">assert </span><span class="s1">s.dtype == dtype</span>

        <span class="s0">if </span><span class="s1">orient == </span><span class="s3">&quot;split&quot;</span><span class="s1">:</span>
            <span class="s1">dec = _clean_dict(output)</span>
            <span class="s1">output = Series(**dec)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">output = Series(output)</span>

        <span class="s0">if </span><span class="s1">orient </span><span class="s0">in </span><span class="s1">(</span><span class="s0">None, </span><span class="s3">&quot;index&quot;</span><span class="s1">):</span>
            <span class="s1">s.name = </span><span class="s0">None</span>
            <span class="s1">output = output.sort_values()</span>
            <span class="s1">s.index = [</span><span class="s3">&quot;6&quot;</span><span class="s0">, </span><span class="s3">&quot;7&quot;</span><span class="s0">, </span><span class="s3">&quot;8&quot;</span><span class="s0">, </span><span class="s3">&quot;9&quot;</span><span class="s0">, </span><span class="s3">&quot;10&quot;</span><span class="s0">, </span><span class="s3">&quot;15&quot;</span><span class="s1">]</span>
        <span class="s0">elif </span><span class="s1">orient </span><span class="s0">in </span><span class="s1">(</span><span class="s3">&quot;records&quot;</span><span class="s0">, </span><span class="s3">&quot;values&quot;</span><span class="s1">):</span>
            <span class="s1">s.name = </span><span class="s0">None</span>
            <span class="s1">s.index = [</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s1">]</span>

        <span class="s0">assert </span><span class="s1">s.dtype == dtype</span>
        <span class="s1">tm.assert_series_equal(output</span><span class="s0">, </span><span class="s1">s)</span>

    <span class="s0">def </span><span class="s1">test_series_nested(self</span><span class="s0">, </span><span class="s1">orient):</span>
        <span class="s1">s = Series(</span>
            <span class="s1">[</span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">30</span><span class="s0">, </span><span class="s5">40</span><span class="s0">, </span><span class="s5">50</span><span class="s0">, </span><span class="s5">60</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;series&quot;</span><span class="s0">, </span><span class="s1">index=[</span><span class="s5">6</span><span class="s0">, </span><span class="s5">7</span><span class="s0">, </span><span class="s5">8</span><span class="s0">, </span><span class="s5">9</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">15</span><span class="s1">]</span>
        <span class="s1">).sort_values()</span>
        <span class="s1">nested = {</span><span class="s3">&quot;s1&quot;</span><span class="s1">: s</span><span class="s0">, </span><span class="s3">&quot;s2&quot;</span><span class="s1">: s.copy()}</span>
        <span class="s1">kwargs = {} </span><span class="s0">if </span><span class="s1">orient </span><span class="s0">is None else </span><span class="s1">{</span><span class="s3">&quot;orient&quot;</span><span class="s1">: orient}</span>

        <span class="s1">exp = {</span>
            <span class="s3">&quot;s1&quot;</span><span class="s1">: ujson.decode(ujson.encode(s</span><span class="s0">, </span><span class="s1">**kwargs))</span><span class="s0">,</span>
            <span class="s3">&quot;s2&quot;</span><span class="s1">: ujson.decode(ujson.encode(s</span><span class="s0">, </span><span class="s1">**kwargs))</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s0">assert </span><span class="s1">ujson.decode(ujson.encode(nested</span><span class="s0">, </span><span class="s1">**kwargs)) == exp</span>

    <span class="s0">def </span><span class="s1">test_index(self):</span>
        <span class="s1">i = Index([</span><span class="s5">23</span><span class="s0">, </span><span class="s5">45</span><span class="s0">, </span><span class="s5">18</span><span class="s0">, </span><span class="s5">98</span><span class="s0">, </span><span class="s5">43</span><span class="s0">, </span><span class="s5">11</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;index&quot;</span><span class="s1">)</span>

        <span class="s4"># Column indexed.</span>
        <span class="s1">output = Index(ujson.decode(ujson.encode(i))</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;index&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(i</span><span class="s0">, </span><span class="s1">output)</span>

        <span class="s1">output = Index(ujson.decode(ujson.encode(i)</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;index&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(i</span><span class="s0">, </span><span class="s1">output)</span>

        <span class="s1">dec = _clean_dict(ujson.decode(ujson.encode(i</span><span class="s0">, </span><span class="s1">orient=</span><span class="s3">&quot;split&quot;</span><span class="s1">)))</span>
        <span class="s1">output = Index(**dec)</span>

        <span class="s1">tm.assert_index_equal(i</span><span class="s0">, </span><span class="s1">output)</span>
        <span class="s0">assert </span><span class="s1">i.name == output.name</span>

        <span class="s1">dec = _clean_dict(ujson.decode(ujson.encode(i</span><span class="s0">, </span><span class="s1">orient=</span><span class="s3">&quot;split&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True</span><span class="s1">))</span>
        <span class="s1">output = Index(**dec)</span>

        <span class="s1">tm.assert_index_equal(i</span><span class="s0">, </span><span class="s1">output)</span>
        <span class="s0">assert </span><span class="s1">i.name == output.name</span>

        <span class="s1">output = Index(ujson.decode(ujson.encode(i</span><span class="s0">, </span><span class="s1">orient=</span><span class="s3">&quot;values&quot;</span><span class="s1">))</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;index&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(i</span><span class="s0">, </span><span class="s1">output)</span>

        <span class="s1">output = Index(</span>
            <span class="s1">ujson.decode(ujson.encode(i</span><span class="s0">, </span><span class="s1">orient=</span><span class="s3">&quot;values&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;index&quot;</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(i</span><span class="s0">, </span><span class="s1">output)</span>

        <span class="s1">output = Index(ujson.decode(ujson.encode(i</span><span class="s0">, </span><span class="s1">orient=</span><span class="s3">&quot;records&quot;</span><span class="s1">))</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;index&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(i</span><span class="s0">, </span><span class="s1">output)</span>

        <span class="s1">output = Index(</span>
            <span class="s1">ujson.decode(ujson.encode(i</span><span class="s0">, </span><span class="s1">orient=</span><span class="s3">&quot;records&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;index&quot;</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(i</span><span class="s0">, </span><span class="s1">output)</span>

        <span class="s1">output = Index(ujson.decode(ujson.encode(i</span><span class="s0">, </span><span class="s1">orient=</span><span class="s3">&quot;index&quot;</span><span class="s1">))</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;index&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(i</span><span class="s0">, </span><span class="s1">output)</span>

        <span class="s1">output = Index(</span>
            <span class="s1">ujson.decode(ujson.encode(i</span><span class="s0">, </span><span class="s1">orient=</span><span class="s3">&quot;index&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">numpy=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;index&quot;</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(i</span><span class="s0">, </span><span class="s1">output)</span>

    <span class="s0">def </span><span class="s1">test_datetime_index(self):</span>
        <span class="s1">date_unit = </span><span class="s3">&quot;ns&quot;</span>

        <span class="s4"># freq doesn't round-trip</span>
        <span class="s1">rng = DatetimeIndex(list(date_range(</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s5">20</span><span class="s1">))</span><span class="s0">, </span><span class="s1">freq=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">encoded = ujson.encode(rng</span><span class="s0">, </span><span class="s1">date_unit=date_unit)</span>

        <span class="s1">decoded = DatetimeIndex(np.array(ujson.decode(encoded)))</span>
        <span class="s1">tm.assert_index_equal(rng</span><span class="s0">, </span><span class="s1">decoded)</span>

        <span class="s1">ts = Series(np.random.randn(len(rng))</span><span class="s0">, </span><span class="s1">index=rng)</span>
        <span class="s1">decoded = Series(ujson.decode(ujson.encode(ts</span><span class="s0">, </span><span class="s1">date_unit=date_unit)))</span>

        <span class="s1">idx_values = decoded.index.values.astype(np.int64)</span>
        <span class="s1">decoded.index = DatetimeIndex(idx_values)</span>
        <span class="s1">tm.assert_series_equal(ts</span><span class="s0">, </span><span class="s1">decoded)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;invalid_arr&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s3">&quot;[31337,]&quot;</span><span class="s0">,  </span><span class="s4"># Trailing comma.</span>
            <span class="s3">&quot;[,31337]&quot;</span><span class="s0">,  </span><span class="s4"># Leading comma.</span>
            <span class="s3">&quot;[]]&quot;</span><span class="s0">,  </span><span class="s4"># Unmatched bracket.</span>
            <span class="s3">&quot;[,]&quot;</span><span class="s0">,  </span><span class="s4"># Only comma.</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_decode_invalid_array(self</span><span class="s0">, </span><span class="s1">invalid_arr):</span>
        <span class="s1">msg = (</span>
            <span class="s3">&quot;Expected object or value|Trailing data|&quot;</span>
            <span class="s3">&quot;Unexpected character found when decoding array value&quot;</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">ujson.decode(invalid_arr)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;arr&quot;</span><span class="s0">, </span><span class="s1">[[]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">31337</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_decode_array(self</span><span class="s0">, </span><span class="s1">arr):</span>
        <span class="s0">assert </span><span class="s1">arr == ujson.decode(str(arr))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;extreme_num&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">9223372036854775807</span><span class="s0">, </span><span class="s1">-</span><span class="s5">9223372036854775808</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_decode_extreme_numbers(self</span><span class="s0">, </span><span class="s1">extreme_num):</span>
        <span class="s0">assert </span><span class="s1">extreme_num == ujson.decode(str(extreme_num))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;too_extreme_num&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s5">2</span><span class="s1">**</span><span class="s5">64</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">-</span><span class="s5">2</span><span class="s1">**</span><span class="s5">63</span><span class="s1">-</span><span class="s5">1</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_decode_too_extreme_numbers(self</span><span class="s0">, </span><span class="s1">too_extreme_num):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s3">&quot;Value is too big|Value is too small&quot;</span><span class="s0">,</span>
        <span class="s1">):</span>
            <span class="s1">ujson.decode(too_extreme_num)</span>

    <span class="s0">def </span><span class="s1">test_decode_with_trailing_whitespaces(self):</span>
        <span class="s0">assert </span><span class="s1">{} == ujson.decode(</span><span class="s3">&quot;{}</span><span class="s0">\n\t </span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_decode_with_trailing_non_whitespaces(self):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;Trailing data&quot;</span><span class="s1">):</span>
            <span class="s1">ujson.decode(</span><span class="s3">&quot;{}</span><span class="s0">\n\t </span><span class="s3">a&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;value&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s5">2</span><span class="s1">**</span><span class="s5">64</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">-</span><span class="s5">2</span><span class="s1">**</span><span class="s5">63</span><span class="s1">-</span><span class="s5">1</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_decode_array_with_big_int(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s3">&quot;Value is too big|Value is too small&quot;</span><span class="s0">,</span>
        <span class="s1">):</span>
            <span class="s1">ujson.loads(value)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;float_number&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s5">1.1234567893</span><span class="s0">,</span>
            <span class="s5">1.234567893</span><span class="s0">,</span>
            <span class="s5">1.34567893</span><span class="s0">,</span>
            <span class="s5">1.4567893</span><span class="s0">,</span>
            <span class="s5">1.567893</span><span class="s0">,</span>
            <span class="s5">1.67893</span><span class="s0">,</span>
            <span class="s5">1.7893</span><span class="s0">,</span>
            <span class="s5">1.893</span><span class="s0">,</span>
            <span class="s5">1.3</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;sign&quot;</span><span class="s0">, </span><span class="s1">[-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_decode_floating_point(self</span><span class="s0">, </span><span class="s1">sign</span><span class="s0">, </span><span class="s1">float_number):</span>
        <span class="s1">float_number *= sign</span>
        <span class="s1">tm.assert_almost_equal(float_number</span><span class="s0">, </span><span class="s1">ujson.loads(str(float_number))</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-15</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_encode_big_set(self):</span>
        <span class="s1">s = set()</span>

        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">100000</span><span class="s1">):</span>
            <span class="s1">s.add(x)</span>

        <span class="s4"># Make sure no Exception is raised.</span>
        <span class="s1">ujson.encode(s)</span>

    <span class="s0">def </span><span class="s1">test_encode_empty_set(self):</span>
        <span class="s0">assert </span><span class="s3">&quot;[]&quot; </span><span class="s1">== ujson.encode(set())</span>

    <span class="s0">def </span><span class="s1">test_encode_set(self):</span>
        <span class="s1">s = {</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">6</span><span class="s0">, </span><span class="s5">7</span><span class="s0">, </span><span class="s5">8</span><span class="s0">, </span><span class="s5">9</span><span class="s1">}</span>
        <span class="s1">enc = ujson.encode(s)</span>
        <span class="s1">dec = ujson.decode(enc)</span>

        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">dec:</span>
            <span class="s0">assert </span><span class="s1">v </span><span class="s0">in </span><span class="s1">s</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;td&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">Timedelta(days=</span><span class="s5">366</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Timedelta(days=-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Timedelta(hours=</span><span class="s5">13</span><span class="s0">, </span><span class="s1">minutes=</span><span class="s5">5</span><span class="s0">, </span><span class="s1">seconds=</span><span class="s5">5</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Timedelta(hours=</span><span class="s5">13</span><span class="s0">, </span><span class="s1">minutes=</span><span class="s5">20</span><span class="s0">, </span><span class="s1">seconds=</span><span class="s5">30</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Timedelta(days=-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">nanoseconds=</span><span class="s5">5</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Timedelta(nanoseconds=</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Timedelta(microseconds=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">nanoseconds=</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Timedelta(milliseconds=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">microseconds=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">nanoseconds=</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Timedelta(milliseconds=</span><span class="s5">999</span><span class="s0">, </span><span class="s1">microseconds=</span><span class="s5">999</span><span class="s0">, </span><span class="s1">nanoseconds=</span><span class="s5">999</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_encode_timedelta_iso(self</span><span class="s0">, </span><span class="s1">td):</span>
        <span class="s4"># GH 28256</span>
        <span class="s1">result = ujson.encode(td</span><span class="s0">, </span><span class="s1">iso_dates=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected = </span><span class="s3">f'&quot;</span><span class="s0">{</span><span class="s1">td.isoformat()</span><span class="s0">}</span><span class="s3">&quot;'</span>

        <span class="s0">assert </span><span class="s1">result == expected</span>
</pre>
</body>
</html>