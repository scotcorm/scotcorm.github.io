<html>
<head>
<title>construction.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
construction.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Functions for preparing various inputs passed to the DataFrame or Series 
constructors before passing them to a BlockManager. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">abc</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Hashable</span><span class="s2">,</span>
    <span class="s1">Sequence</span><span class="s2">,</span>
    <span class="s1">cast</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">numpy.ma </span><span class="s2">as </span><span class="s1">ma</span>

<span class="s2">from </span><span class="s1">pandas._libs </span><span class="s2">import </span><span class="s1">lib</span>
<span class="s2">from </span><span class="s1">pandas._typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ArrayLike</span><span class="s2">,</span>
    <span class="s1">DtypeObj</span><span class="s2">,</span>
    <span class="s1">Manager</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.util._exceptions </span><span class="s2">import </span><span class="s1">find_stack_level</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">construct_1d_arraylike_from_scalar</span><span class="s2">,</span>
    <span class="s1">dict_compat</span><span class="s2">,</span>
    <span class="s1">maybe_cast_to_datetime</span><span class="s2">,</span>
    <span class="s1">maybe_convert_platform</span><span class="s2">,</span>
    <span class="s1">maybe_infer_to_datetimelike</span><span class="s2">,</span>
    <span class="s1">maybe_upcast</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">is_1d_only_ea_dtype</span><span class="s2">,</span>
    <span class="s1">is_datetime64tz_dtype</span><span class="s2">,</span>
    <span class="s1">is_datetime_or_timedelta_dtype</span><span class="s2">,</span>
    <span class="s1">is_dtype_equal</span><span class="s2">,</span>
    <span class="s1">is_extension_array_dtype</span><span class="s2">,</span>
    <span class="s1">is_integer_dtype</span><span class="s2">,</span>
    <span class="s1">is_list_like</span><span class="s2">,</span>
    <span class="s1">is_named_tuple</span><span class="s2">,</span>
    <span class="s1">is_object_dtype</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s2">import </span><span class="s1">ExtensionDtype</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.generic </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ABCDataFrame</span><span class="s2">,</span>
    <span class="s1">ABCSeries</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">pandas.core </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">algorithms</span><span class="s2">,</span>
    <span class="s1">common </span><span class="s2">as </span><span class="s1">com</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Categorical</span><span class="s2">,</span>
    <span class="s1">DatetimeArray</span><span class="s2">,</span>
    <span class="s1">ExtensionArray</span><span class="s2">,</span>
    <span class="s1">TimedeltaArray</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.construction </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ensure_wrapped_if_datetimelike</span><span class="s2">,</span>
    <span class="s1">extract_array</span><span class="s2">,</span>
    <span class="s1">range_to_ndarray</span><span class="s2">,</span>
    <span class="s1">sanitize_array</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.indexes.api </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DatetimeIndex</span><span class="s2">,</span>
    <span class="s1">Index</span><span class="s2">,</span>
    <span class="s1">TimedeltaIndex</span><span class="s2">,</span>
    <span class="s1">default_index</span><span class="s2">,</span>
    <span class="s1">ensure_index</span><span class="s2">,</span>
    <span class="s1">get_objs_combined_axis</span><span class="s2">,</span>
    <span class="s1">union_indexes</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.internals.array_manager </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ArrayManager</span><span class="s2">,</span>
    <span class="s1">SingleArrayManager</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.internals.blocks </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">BlockPlacement</span><span class="s2">,</span>
    <span class="s1">ensure_block_shape</span><span class="s2">,</span>
    <span class="s1">new_block_2d</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.internals.managers </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">BlockManager</span><span class="s2">,</span>
    <span class="s1">SingleBlockManager</span><span class="s2">,</span>
    <span class="s1">create_block_manager_from_blocks</span><span class="s2">,</span>
    <span class="s1">create_block_manager_from_column_arrays</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">numpy.ma.mrecords </span><span class="s2">import </span><span class="s1">MaskedRecords</span>


<span class="s3"># ---------------------------------------------------------------------</span>
<span class="s3"># BlockManager Interface</span>


<span class="s2">def </span><span class="s1">arrays_to_mgr(</span>
    <span class="s1">arrays</span><span class="s2">,</span>
    <span class="s1">columns: Index</span><span class="s2">,</span>
    <span class="s1">index</span><span class="s2">,</span>
    <span class="s1">*</span><span class="s2">,</span>
    <span class="s1">dtype: DtypeObj | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">verify_integrity: bool = </span><span class="s2">True,</span>
    <span class="s1">typ: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">consolidate: bool = </span><span class="s2">True,</span>
<span class="s1">) -&gt; Manager:</span>
    <span class="s0">&quot;&quot;&quot; 
    Segregate Series based on type and coerce into matrices. 
 
    Needs to handle a lot of exceptional cases. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">verify_integrity:</span>
        <span class="s3"># figure out the index, if necessary</span>
        <span class="s2">if </span><span class="s1">index </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">index = _extract_index(arrays)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">index = ensure_index(index)</span>

        <span class="s3"># don't force copy because getting jammed in an ndarray anyway</span>
        <span class="s1">arrays = _homogenize(arrays</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s3"># _homogenize ensures</span>
        <span class="s3">#  - all(len(x) == len(index) for x in arrays)</span>
        <span class="s3">#  - all(x.ndim == 1 for x in arrays)</span>
        <span class="s3">#  - all(isinstance(x, (np.ndarray, ExtensionArray)) for x in arrays)</span>
        <span class="s3">#  - all(type(x) is not PandasArray for x in arrays)</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">index = ensure_index(index)</span>
        <span class="s1">arrays = [extract_array(x</span><span class="s2">, </span><span class="s1">extract_numpy=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">arrays]</span>

        <span class="s3"># Reached via DataFrame._from_arrays; we do validation here</span>
        <span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">arrays:</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s2">not </span><span class="s1">isinstance(arr</span><span class="s2">, </span><span class="s1">(np.ndarray</span><span class="s2">, </span><span class="s1">ExtensionArray))</span>
                <span class="s2">or </span><span class="s1">arr.ndim != </span><span class="s4">1</span>
                <span class="s2">or </span><span class="s1">len(arr) != len(index)</span>
            <span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s5">&quot;Arrays must be 1-dimensional np.ndarray or ExtensionArray &quot;</span>
                    <span class="s5">&quot;with length matching len(index)&quot;</span>
                <span class="s1">)</span>

    <span class="s1">columns = ensure_index(columns)</span>
    <span class="s2">if </span><span class="s1">len(columns) != len(arrays):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;len(arrays) must match len(columns)&quot;</span><span class="s1">)</span>

    <span class="s3"># from BlockManager perspective</span>
    <span class="s1">axes = [columns</span><span class="s2">, </span><span class="s1">index]</span>

    <span class="s2">if </span><span class="s1">typ == </span><span class="s5">&quot;block&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">create_block_manager_from_column_arrays(</span>
            <span class="s1">arrays</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">consolidate=consolidate</span>
        <span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">typ == </span><span class="s5">&quot;array&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">ArrayManager(arrays</span><span class="s2">, </span><span class="s1">[index</span><span class="s2">, </span><span class="s1">columns])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;'typ' needs to be one of </span><span class="s2">{{</span><span class="s5">'block', 'array'</span><span class="s2">}}</span><span class="s5">, got '</span><span class="s2">{</span><span class="s1">typ</span><span class="s2">}</span><span class="s5">'&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">rec_array_to_mgr(</span>
    <span class="s1">data: MaskedRecords | np.recarray | np.ndarray</span><span class="s2">,</span>
    <span class="s1">index</span><span class="s2">,</span>
    <span class="s1">columns</span><span class="s2">,</span>
    <span class="s1">dtype: DtypeObj | </span><span class="s2">None,</span>
    <span class="s1">copy: bool</span><span class="s2">,</span>
    <span class="s1">typ: str</span><span class="s2">,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Extract from a masked rec array and create the manager. 
    &quot;&quot;&quot;</span>
    <span class="s3"># essentially process a record array then fill it</span>
    <span class="s1">fdata = ma.getdata(data)</span>
    <span class="s2">if </span><span class="s1">index </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">index = default_index(len(fdata))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">index = ensure_index(index)</span>

    <span class="s2">if </span><span class="s1">columns </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">columns = ensure_index(columns)</span>
    <span class="s1">arrays</span><span class="s2">, </span><span class="s1">arr_columns = to_arrays(fdata</span><span class="s2">, </span><span class="s1">columns)</span>

    <span class="s3"># fill if needed</span>
    <span class="s2">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">np.ma.MaskedArray):</span>
        <span class="s3"># GH#42200 we only get here with MaskedRecords, but check for the</span>
        <span class="s3">#  parent class MaskedArray to avoid the need to import MaskedRecords</span>
        <span class="s1">data = cast(</span><span class="s5">&quot;MaskedRecords&quot;</span><span class="s2">, </span><span class="s1">data)</span>
        <span class="s1">new_arrays = fill_masked_arrays(data</span><span class="s2">, </span><span class="s1">arr_columns)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># error: Incompatible types in assignment (expression has type</span>
        <span class="s3"># &quot;List[ExtensionArray]&quot;, variable has type &quot;List[ndarray]&quot;)</span>
        <span class="s1">new_arrays = arrays  </span><span class="s3"># type: ignore[assignment]</span>

    <span class="s3"># create the manager</span>

    <span class="s3"># error: Argument 1 to &quot;reorder_arrays&quot; has incompatible type &quot;List[ndarray]&quot;;</span>
    <span class="s3"># expected &quot;List[Union[ExtensionArray, ndarray]]&quot;</span>
    <span class="s1">arrays</span><span class="s2">, </span><span class="s1">arr_columns = reorder_arrays(</span>
        <span class="s1">new_arrays</span><span class="s2">, </span><span class="s1">arr_columns</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">len(index)  </span><span class="s3"># type: ignore[arg-type]</span>
    <span class="s1">)</span>
    <span class="s2">if </span><span class="s1">columns </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">columns = arr_columns</span>

    <span class="s1">mgr = arrays_to_mgr(arrays</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">typ=typ)</span>

    <span class="s2">if </span><span class="s1">copy:</span>
        <span class="s1">mgr = mgr.copy()</span>
    <span class="s2">return </span><span class="s1">mgr</span>


<span class="s2">def </span><span class="s1">fill_masked_arrays(data: MaskedRecords</span><span class="s2">, </span><span class="s1">arr_columns: Index) -&gt; list[np.ndarray]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert numpy MaskedRecords to ensure mask is softened. 
    &quot;&quot;&quot;</span>
    <span class="s1">new_arrays = []</span>

    <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">arr_columns:</span>
        <span class="s1">arr = data[col]</span>
        <span class="s1">fv = arr.fill_value</span>

        <span class="s1">mask = ma.getmaskarray(arr)</span>
        <span class="s2">if </span><span class="s1">mask.any():</span>
            <span class="s1">arr</span><span class="s2">, </span><span class="s1">fv = maybe_upcast(arr</span><span class="s2">, </span><span class="s1">fill_value=fv</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">arr[mask] = fv</span>
        <span class="s1">new_arrays.append(arr)</span>
    <span class="s2">return </span><span class="s1">new_arrays</span>


<span class="s2">def </span><span class="s1">mgr_to_mgr(mgr</span><span class="s2">, </span><span class="s1">typ: str</span><span class="s2">, </span><span class="s1">copy: bool = </span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert to specific type of Manager. Does not copy if the type is already 
    correct. Does not guarantee a copy otherwise. `copy` keyword only controls 
    whether conversion from Block-&gt;ArrayManager copies the 1D arrays. 
    &quot;&quot;&quot;</span>
    <span class="s1">new_mgr: Manager</span>

    <span class="s2">if </span><span class="s1">typ == </span><span class="s5">&quot;block&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(mgr</span><span class="s2">, </span><span class="s1">BlockManager):</span>
            <span class="s1">new_mgr = mgr</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">mgr.ndim == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">new_mgr = arrays_to_mgr(</span>
                    <span class="s1">mgr.arrays</span><span class="s2">, </span><span class="s1">mgr.axes[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">mgr.axes[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">typ=</span><span class="s5">&quot;block&quot;</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">new_mgr = SingleBlockManager.from_array(mgr.arrays[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">mgr.index)</span>
    <span class="s2">elif </span><span class="s1">typ == </span><span class="s5">&quot;array&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(mgr</span><span class="s2">, </span><span class="s1">ArrayManager):</span>
            <span class="s1">new_mgr = mgr</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">mgr.ndim == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">arrays = [mgr.iget_values(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(mgr.axes[</span><span class="s4">0</span><span class="s1">]))]</span>
                <span class="s2">if </span><span class="s1">copy:</span>
                    <span class="s1">arrays = [arr.copy() </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">arrays]</span>
                <span class="s1">new_mgr = ArrayManager(arrays</span><span class="s2">, </span><span class="s1">[mgr.axes[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">mgr.axes[</span><span class="s4">0</span><span class="s1">]])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">array = mgr.internal_values()</span>
                <span class="s2">if </span><span class="s1">copy:</span>
                    <span class="s1">array = array.copy()</span>
                <span class="s1">new_mgr = SingleArrayManager([array]</span><span class="s2">, </span><span class="s1">[mgr.index])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;'typ' needs to be one of </span><span class="s2">{{</span><span class="s5">'block', 'array'</span><span class="s2">}}</span><span class="s5">, got '</span><span class="s2">{</span><span class="s1">typ</span><span class="s2">}</span><span class="s5">'&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">new_mgr</span>


<span class="s3"># ---------------------------------------------------------------------</span>
<span class="s3"># DataFrame Constructor Interface</span>


<span class="s2">def </span><span class="s1">ndarray_to_mgr(</span>
    <span class="s1">values</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">dtype: DtypeObj | </span><span class="s2">None, </span><span class="s1">copy: bool</span><span class="s2">, </span><span class="s1">typ: str</span>
<span class="s1">) -&gt; Manager:</span>
    <span class="s3"># used in DataFrame.__init__</span>
    <span class="s3"># input must be a ndarray, list, Series, Index, ExtensionArray</span>

    <span class="s2">if </span><span class="s1">isinstance(values</span><span class="s2">, </span><span class="s1">ABCSeries):</span>
        <span class="s2">if </span><span class="s1">columns </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">values.name </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">columns = Index([values.name])</span>
        <span class="s2">if </span><span class="s1">index </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">index = values.index</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">values = values.reindex(index)</span>

        <span class="s3"># zero len case (GH #2234)</span>
        <span class="s2">if not </span><span class="s1">len(values) </span><span class="s2">and </span><span class="s1">columns </span><span class="s2">is not None and </span><span class="s1">len(columns):</span>
            <span class="s1">values = np.empty((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=object)</span>

    <span class="s3"># if the array preparation does a copy -&gt; avoid this for ArrayManager,</span>
    <span class="s3"># since the copy is done on conversion to 1D arrays</span>
    <span class="s1">copy_on_sanitize = </span><span class="s2">False if </span><span class="s1">typ == </span><span class="s5">&quot;array&quot; </span><span class="s2">else </span><span class="s1">copy</span>

    <span class="s1">vdtype = getattr(values</span><span class="s2">, </span><span class="s5">&quot;dtype&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">is_1d_only_ea_dtype(vdtype) </span><span class="s2">or </span><span class="s1">is_1d_only_ea_dtype(dtype):</span>
        <span class="s3"># GH#19157</span>

        <span class="s2">if </span><span class="s1">isinstance(values</span><span class="s2">, </span><span class="s1">(np.ndarray</span><span class="s2">, </span><span class="s1">ExtensionArray)) </span><span class="s2">and </span><span class="s1">values.ndim &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3"># GH#12513 a EA dtype passed with a 2D array, split into</span>
            <span class="s3">#  multiple EAs that view the values</span>
            <span class="s3"># error: No overload variant of &quot;__getitem__&quot; of &quot;ExtensionArray&quot;</span>
            <span class="s3"># matches argument type &quot;Tuple[slice, int]&quot;</span>
            <span class="s1">values = [</span>
                <span class="s1">values[:</span><span class="s2">, </span><span class="s1">n]  </span><span class="s3"># type: ignore[call-overload]</span>
                <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(values.shape[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">values = [values]</span>

        <span class="s2">if </span><span class="s1">columns </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">columns = Index(range(len(values)))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">columns = ensure_index(columns)</span>

        <span class="s2">return </span><span class="s1">arrays_to_mgr(values</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">typ=typ)</span>

    <span class="s2">elif </span><span class="s1">is_extension_array_dtype(vdtype) </span><span class="s2">and not </span><span class="s1">is_1d_only_ea_dtype(vdtype):</span>
        <span class="s3"># i.e. Datetime64TZ, PeriodDtype</span>
        <span class="s1">values = extract_array(values</span><span class="s2">, </span><span class="s1">extract_numpy=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">copy:</span>
            <span class="s1">values = values.copy()</span>
        <span class="s2">if </span><span class="s1">values.ndim == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">values = values.reshape(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># by definition an array here</span>
        <span class="s3"># the dtypes will be coerced to a single dtype</span>
        <span class="s1">values = _prep_ndarray(values</span><span class="s2">, </span><span class="s1">copy=copy_on_sanitize)</span>

    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is not None and not </span><span class="s1">is_dtype_equal(values.dtype</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">shape = values.shape</span>
        <span class="s1">flat = values.ravel()</span>

        <span class="s3"># GH#40110 see similar check inside sanitize_array</span>
        <span class="s1">rcf = </span><span class="s2">not </span><span class="s1">(is_integer_dtype(dtype) </span><span class="s2">and </span><span class="s1">values.dtype.kind == </span><span class="s5">&quot;f&quot;</span><span class="s1">)</span>

        <span class="s1">values = sanitize_array(</span>
            <span class="s1">flat</span><span class="s2">, None, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">copy=copy_on_sanitize</span><span class="s2">, </span><span class="s1">raise_cast_failure=rcf</span>
        <span class="s1">)</span>

        <span class="s1">values = values.reshape(shape)</span>

    <span class="s3"># _prep_ndarray ensures that values.ndim == 2 at this point</span>
    <span class="s1">index</span><span class="s2">, </span><span class="s1">columns = _get_axes(</span>
        <span class="s1">values.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">values.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=index</span><span class="s2">, </span><span class="s1">columns=columns</span>
    <span class="s1">)</span>

    <span class="s1">_check_values_indices_shape_match(values</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">columns)</span>

    <span class="s2">if </span><span class="s1">typ == </span><span class="s5">&quot;array&quot;</span><span class="s1">:</span>

        <span class="s2">if </span><span class="s1">issubclass(values.dtype.type</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">values = np.array(values</span><span class="s2">, </span><span class="s1">dtype=object)</span>

        <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None and </span><span class="s1">is_object_dtype(values.dtype):</span>
            <span class="s1">arrays = [</span>
                <span class="s1">ensure_wrapped_if_datetimelike(</span>
                    <span class="s1">maybe_infer_to_datetimelike(values[:</span><span class="s2">, </span><span class="s1">i])</span>
                <span class="s1">)</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(values.shape[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">is_datetime_or_timedelta_dtype(values.dtype):</span>
                <span class="s1">values = ensure_wrapped_if_datetimelike(values)</span>
            <span class="s1">arrays = [values[:</span><span class="s2">, </span><span class="s1">i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(values.shape[</span><span class="s4">1</span><span class="s1">])]</span>

        <span class="s2">if </span><span class="s1">copy:</span>
            <span class="s1">arrays = [arr.copy() </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">arrays]</span>

        <span class="s2">return </span><span class="s1">ArrayManager(arrays</span><span class="s2">, </span><span class="s1">[index</span><span class="s2">, </span><span class="s1">columns]</span><span class="s2">, </span><span class="s1">verify_integrity=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">values = values.T</span>

    <span class="s3"># if we don't have a dtype specified, then try to convert objects</span>
    <span class="s3"># on the entire block; this is to convert if we have datetimelike's</span>
    <span class="s3"># embedded in an object type</span>
    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None and </span><span class="s1">is_object_dtype(values.dtype):</span>
        <span class="s1">obj_columns = list(values)</span>
        <span class="s1">maybe_datetime = [maybe_infer_to_datetimelike(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">obj_columns]</span>
        <span class="s3"># don't convert (and copy) the objects if no type inference occurs</span>
        <span class="s2">if </span><span class="s1">any(x </span><span class="s2">is not </span><span class="s1">y </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">zip(obj_columns</span><span class="s2">, </span><span class="s1">maybe_datetime)):</span>
            <span class="s1">dvals_list = [ensure_block_shape(dval</span><span class="s2">, </span><span class="s4">2</span><span class="s1">) </span><span class="s2">for </span><span class="s1">dval </span><span class="s2">in </span><span class="s1">maybe_datetime]</span>
            <span class="s1">block_values = [</span>
                <span class="s1">new_block_2d(dvals_list[n]</span><span class="s2">, </span><span class="s1">placement=BlockPlacement(n))</span>
                <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(len(dvals_list))</span>
            <span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">bp = BlockPlacement(slice(len(columns)))</span>
            <span class="s1">nb = new_block_2d(values</span><span class="s2">, </span><span class="s1">placement=bp)</span>
            <span class="s1">block_values = [nb]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">bp = BlockPlacement(slice(len(columns)))</span>
        <span class="s1">nb = new_block_2d(values</span><span class="s2">, </span><span class="s1">placement=bp)</span>
        <span class="s1">block_values = [nb]</span>

    <span class="s2">if </span><span class="s1">len(columns) == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">block_values = []</span>

    <span class="s2">return </span><span class="s1">create_block_manager_from_blocks(</span>
        <span class="s1">block_values</span><span class="s2">, </span><span class="s1">[columns</span><span class="s2">, </span><span class="s1">index]</span><span class="s2">, </span><span class="s1">verify_integrity=</span><span class="s2">False</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_check_values_indices_shape_match(</span>
    <span class="s1">values: np.ndarray</span><span class="s2">, </span><span class="s1">index: Index</span><span class="s2">, </span><span class="s1">columns: Index</span>
<span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Check that the shape implied by our axes matches the actual shape of the 
    data. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">values.shape[</span><span class="s4">1</span><span class="s1">] != len(columns) </span><span class="s2">or </span><span class="s1">values.shape[</span><span class="s4">0</span><span class="s1">] != len(index):</span>
        <span class="s3"># Could let this raise in Block constructor, but we get a more</span>
        <span class="s3">#  helpful exception message this way.</span>
        <span class="s2">if </span><span class="s1">values.shape[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Empty data passed with indices specified.&quot;</span><span class="s1">)</span>

        <span class="s1">passed = values.shape</span>
        <span class="s1">implied = (len(index)</span><span class="s2">, </span><span class="s1">len(columns))</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;Shape of passed values is </span><span class="s2">{</span><span class="s1">passed</span><span class="s2">}</span><span class="s5">, indices imply </span><span class="s2">{</span><span class="s1">implied</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">dict_to_mgr(</span>
    <span class="s1">data: dict</span><span class="s2">,</span>
    <span class="s1">index</span><span class="s2">,</span>
    <span class="s1">columns</span><span class="s2">,</span>
    <span class="s1">*</span><span class="s2">,</span>
    <span class="s1">dtype: DtypeObj | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">typ: str = </span><span class="s5">&quot;block&quot;</span><span class="s2">,</span>
    <span class="s1">copy: bool = </span><span class="s2">True,</span>
<span class="s1">) -&gt; Manager:</span>
    <span class="s0">&quot;&quot;&quot; 
    Segregate Series based on type and coerce into matrices. 
    Needs to handle a lot of exceptional cases. 
 
    Used in DataFrame.__init__ 
    &quot;&quot;&quot;</span>
    <span class="s1">arrays: Sequence[Any] | Series</span>

    <span class="s2">if </span><span class="s1">columns </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">pandas.core.series </span><span class="s2">import </span><span class="s1">Series</span>

        <span class="s1">arrays = Series(data</span><span class="s2">, </span><span class="s1">index=columns</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s1">missing = arrays.isna()</span>
        <span class="s2">if </span><span class="s1">index </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># GH10856</span>
            <span class="s3"># raise ValueError if only scalars in dict</span>
            <span class="s1">index = _extract_index(arrays[~missing])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">index = ensure_index(index)</span>

        <span class="s3"># no obvious &quot;empty&quot; int column</span>
        <span class="s2">if </span><span class="s1">missing.any() </span><span class="s2">and not </span><span class="s1">is_integer_dtype(dtype):</span>
            <span class="s1">nan_dtype: DtypeObj</span>

            <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s3"># calling sanitize_array ensures we don't mix-and-match</span>
                <span class="s3">#  NA dtypes</span>
                <span class="s1">midxs = missing.values.nonzero()[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">midxs:</span>
                    <span class="s1">arr = sanitize_array(arrays.iat[i]</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
                    <span class="s1">arrays.iat[i] = arr</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s3"># GH#1783</span>
                <span class="s1">nan_dtype = np.dtype(</span><span class="s5">&quot;object&quot;</span><span class="s1">)</span>
                <span class="s1">val = construct_1d_arraylike_from_scalar(np.nan</span><span class="s2">, </span><span class="s1">len(index)</span><span class="s2">, </span><span class="s1">nan_dtype)</span>
                <span class="s1">nmissing = missing.sum()</span>
                <span class="s2">if </span><span class="s1">copy:</span>
                    <span class="s1">rhs = [val] * nmissing</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s3"># GH#45369</span>
                    <span class="s1">rhs = [val.copy() </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(nmissing)]</span>
                <span class="s1">arrays.loc[missing] = rhs</span>

        <span class="s1">arrays = list(arrays)</span>
        <span class="s1">columns = ensure_index(columns)</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">keys = list(data.keys())</span>
        <span class="s1">columns = Index(keys)</span>
        <span class="s1">arrays = [com.maybe_iterable_to_list(data[k]) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">keys]</span>
        <span class="s3"># GH#24096 need copy to be deep for datetime64tz case</span>
        <span class="s3"># TODO: See if we can avoid these copies</span>
        <span class="s1">arrays = [arr </span><span class="s2">if not </span><span class="s1">isinstance(arr</span><span class="s2">, </span><span class="s1">Index) </span><span class="s2">else </span><span class="s1">arr._data </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">arrays]</span>
        <span class="s1">arrays = [</span>
            <span class="s1">arr </span><span class="s2">if not </span><span class="s1">is_datetime64tz_dtype(arr) </span><span class="s2">else </span><span class="s1">arr.copy() </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">arrays</span>
        <span class="s1">]</span>

    <span class="s2">if </span><span class="s1">copy:</span>
        <span class="s3"># arrays_to_mgr (via form_blocks) won't make copies for EAs</span>
        <span class="s3"># dtype attr check to exclude EADtype-castable strs</span>
        <span class="s1">arrays = [</span>
            <span class="s1">x</span>
            <span class="s2">if not </span><span class="s1">hasattr(x</span><span class="s2">, </span><span class="s5">&quot;dtype&quot;</span><span class="s1">) </span><span class="s2">or not </span><span class="s1">isinstance(x.dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype)</span>
            <span class="s2">else </span><span class="s1">x.copy()</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">arrays</span>
        <span class="s1">]</span>
        <span class="s3"># TODO: can we get rid of the dt64tz special case above?</span>

    <span class="s2">return </span><span class="s1">arrays_to_mgr(arrays</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">typ=typ</span><span class="s2">, </span><span class="s1">consolidate=copy)</span>


<span class="s2">def </span><span class="s1">nested_data_to_arrays(</span>
    <span class="s1">data: Sequence</span><span class="s2">,</span>
    <span class="s1">columns: Index | </span><span class="s2">None,</span>
    <span class="s1">index: Index | </span><span class="s2">None,</span>
    <span class="s1">dtype: DtypeObj | </span><span class="s2">None,</span>
<span class="s1">) -&gt; tuple[list[ArrayLike]</span><span class="s2">, </span><span class="s1">Index</span><span class="s2">, </span><span class="s1">Index]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a single sequence of arrays to multiple arrays. 
    &quot;&quot;&quot;</span>
    <span class="s3"># By the time we get here we have already checked treat_as_nested(data)</span>

    <span class="s2">if </span><span class="s1">is_named_tuple(data[</span><span class="s4">0</span><span class="s1">]) </span><span class="s2">and </span><span class="s1">columns </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">columns = ensure_index(data[</span><span class="s4">0</span><span class="s1">]._fields)</span>

    <span class="s1">arrays</span><span class="s2">, </span><span class="s1">columns = to_arrays(data</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">columns = ensure_index(columns)</span>

    <span class="s2">if </span><span class="s1">index </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(data[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ABCSeries):</span>
            <span class="s1">index = _get_names_from_index(data)</span>
        <span class="s2">elif </span><span class="s1">isinstance(data[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Categorical):</span>
            <span class="s3"># GH#38845 hit in test_constructor_categorical</span>
            <span class="s1">index = default_index(len(data[</span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">index = default_index(len(data))</span>

    <span class="s2">return </span><span class="s1">arrays</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">index</span>


<span class="s2">def </span><span class="s1">treat_as_nested(data) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot; 
    Check if we should use nested_data_to_arrays. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">len(data) &gt; </span><span class="s4">0</span>
        <span class="s2">and </span><span class="s1">is_list_like(data[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s2">and </span><span class="s1">getattr(data[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;ndim&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">) == </span><span class="s4">1</span>
        <span class="s2">and not </span><span class="s1">(isinstance(data</span><span class="s2">, </span><span class="s1">ExtensionArray) </span><span class="s2">and </span><span class="s1">data.ndim == </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">)</span>


<span class="s3"># ---------------------------------------------------------------------</span>


<span class="s2">def </span><span class="s1">_prep_ndarray(values</span><span class="s2">, </span><span class="s1">copy: bool = </span><span class="s2">True</span><span class="s1">) -&gt; np.ndarray:</span>
    <span class="s2">if </span><span class="s1">isinstance(values</span><span class="s2">, </span><span class="s1">TimedeltaArray) </span><span class="s2">or </span><span class="s1">(</span>
        <span class="s1">isinstance(values</span><span class="s2">, </span><span class="s1">DatetimeArray) </span><span class="s2">and </span><span class="s1">values.tz </span><span class="s2">is None</span>
    <span class="s1">):</span>
        <span class="s3"># On older numpy, np.asarray below apparently does not call __array__,</span>
        <span class="s3">#  so nanoseconds get dropped.</span>
        <span class="s1">values = values._ndarray</span>

    <span class="s2">if not </span><span class="s1">isinstance(values</span><span class="s2">, </span><span class="s1">(np.ndarray</span><span class="s2">, </span><span class="s1">ABCSeries</span><span class="s2">, </span><span class="s1">Index)):</span>
        <span class="s2">if </span><span class="s1">len(values) == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.empty((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s2">elif </span><span class="s1">isinstance(values</span><span class="s2">, </span><span class="s1">range):</span>
            <span class="s1">arr = range_to_ndarray(values)</span>
            <span class="s2">return </span><span class="s1">arr[...</span><span class="s2">, </span><span class="s1">np.newaxis]</span>

        <span class="s2">def </span><span class="s1">convert(v):</span>
            <span class="s2">if not </span><span class="s1">is_list_like(v) </span><span class="s2">or </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">ABCDataFrame):</span>
                <span class="s2">return </span><span class="s1">v</span>

            <span class="s1">v = extract_array(v</span><span class="s2">, </span><span class="s1">extract_numpy=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">res = maybe_convert_platform(v)</span>
            <span class="s2">return </span><span class="s1">res</span>

        <span class="s3"># we could have a 1-dim or 2-dim list here</span>
        <span class="s3"># this is equiv of np.asarray, but does object conversion</span>
        <span class="s3"># and platform dtype preservation</span>
        <span class="s2">if </span><span class="s1">is_list_like(values[</span><span class="s4">0</span><span class="s1">]):</span>
            <span class="s1">values = np.array([convert(v) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">values])</span>
        <span class="s2">elif </span><span class="s1">isinstance(values[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">and </span><span class="s1">values[</span><span class="s4">0</span><span class="s1">].ndim == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3"># GH#21861 see test_constructor_list_of_lists</span>
            <span class="s1">values = np.array([convert(v) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">values])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">values = convert(values)</span>

    <span class="s2">else</span><span class="s1">:</span>

        <span class="s3"># drop subclass info</span>
        <span class="s1">values = np.array(values</span><span class="s2">, </span><span class="s1">copy=copy)</span>

    <span class="s2">if </span><span class="s1">values.ndim == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">values = values.reshape((values.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s2">elif </span><span class="s1">values.ndim != </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;Must pass 2-d input. shape=</span><span class="s2">{</span><span class="s1">values.shape</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">values</span>


<span class="s2">def </span><span class="s1">_homogenize(data</span><span class="s2">, </span><span class="s1">index: Index</span><span class="s2">, </span><span class="s1">dtype: DtypeObj | </span><span class="s2">None</span><span class="s1">) -&gt; list[ArrayLike]:</span>
    <span class="s1">oindex = </span><span class="s2">None</span>
    <span class="s1">homogenized = []</span>

    <span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">data:</span>
        <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">ABCSeries):</span>
            <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">val = val.astype(dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">val.index </span><span class="s2">is not </span><span class="s1">index:</span>
                <span class="s3"># Forces alignment. No need to copy data since we</span>
                <span class="s3"># are putting it into an ndarray later</span>
                <span class="s1">val = val.reindex(index</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

            <span class="s1">val = val._values</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">dict):</span>
                <span class="s3"># GH#41785 this _should_ be equivalent to (but faster than)</span>
                <span class="s3">#  val = create_series_with_explicit_dtype(val, index=index)._values</span>
                <span class="s2">if </span><span class="s1">oindex </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">oindex = index.astype(</span><span class="s5">&quot;O&quot;</span><span class="s1">)</span>

                <span class="s2">if </span><span class="s1">isinstance(index</span><span class="s2">, </span><span class="s1">(DatetimeIndex</span><span class="s2">, </span><span class="s1">TimedeltaIndex)):</span>
                    <span class="s3"># see test_constructor_dict_datetime64_index</span>
                    <span class="s1">val = dict_compat(val)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s3"># see test_constructor_subclass_dict</span>
                    <span class="s1">val = dict(val)</span>
                <span class="s1">val = lib.fast_multiget(val</span><span class="s2">, </span><span class="s1">oindex._values</span><span class="s2">, </span><span class="s1">default=np.nan)</span>

            <span class="s1">val = sanitize_array(</span>
                <span class="s1">val</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False, </span><span class="s1">raise_cast_failure=</span><span class="s2">False</span>
            <span class="s1">)</span>
            <span class="s1">com.require_length_match(val</span><span class="s2">, </span><span class="s1">index)</span>

        <span class="s1">homogenized.append(val)</span>

    <span class="s2">return </span><span class="s1">homogenized</span>


<span class="s2">def </span><span class="s1">_extract_index(data) -&gt; Index:</span>
    <span class="s0">&quot;&quot;&quot; 
    Try to infer an Index from the passed data, raise ValueError on failure. 
    &quot;&quot;&quot;</span>
    <span class="s1">index = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">len(data) == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">index = Index([])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">raw_lengths = []</span>
        <span class="s1">indexes: list[list[Hashable] | Index] = []</span>

        <span class="s1">have_raw_arrays = </span><span class="s2">False</span>
        <span class="s1">have_series = </span><span class="s2">False</span>
        <span class="s1">have_dicts = </span><span class="s2">False</span>

        <span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">data:</span>
            <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">ABCSeries):</span>
                <span class="s1">have_series = </span><span class="s2">True</span>
                <span class="s1">indexes.append(val.index)</span>
            <span class="s2">elif </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">dict):</span>
                <span class="s1">have_dicts = </span><span class="s2">True</span>
                <span class="s1">indexes.append(list(val.keys()))</span>
            <span class="s2">elif </span><span class="s1">is_list_like(val) </span><span class="s2">and </span><span class="s1">getattr(val</span><span class="s2">, </span><span class="s5">&quot;ndim&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">) == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">have_raw_arrays = </span><span class="s2">True</span>
                <span class="s1">raw_lengths.append(len(val))</span>
            <span class="s2">elif </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">and </span><span class="s1">val.ndim &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Per-column arrays must each be 1-dimensional&quot;</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">indexes </span><span class="s2">and not </span><span class="s1">raw_lengths:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;If using all scalar values, you must pass an index&quot;</span><span class="s1">)</span>

        <span class="s2">elif </span><span class="s1">have_series:</span>
            <span class="s1">index = union_indexes(indexes)</span>
        <span class="s2">elif </span><span class="s1">have_dicts:</span>
            <span class="s1">index = union_indexes(indexes</span><span class="s2">, </span><span class="s1">sort=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">have_raw_arrays:</span>
            <span class="s1">lengths = list(set(raw_lengths))</span>
            <span class="s2">if </span><span class="s1">len(lengths) &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;All arrays must be of the same length&quot;</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">have_dicts:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s5">&quot;Mixing dicts with non-Series may lead to ambiguous ordering.&quot;</span>
                <span class="s1">)</span>

            <span class="s2">if </span><span class="s1">have_series:</span>
                <span class="s2">assert </span><span class="s1">index </span><span class="s2">is not None  </span><span class="s3"># for mypy</span>
                <span class="s2">if </span><span class="s1">lengths[</span><span class="s4">0</span><span class="s1">] != len(index):</span>
                    <span class="s1">msg = (</span>
                        <span class="s5">f&quot;array length </span><span class="s2">{</span><span class="s1">lengths[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">} </span><span class="s5">does not match index &quot;</span>
                        <span class="s5">f&quot;length </span><span class="s2">{</span><span class="s1">len(index)</span><span class="s2">}</span><span class="s5">&quot;</span>
                    <span class="s1">)</span>
                    <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">index = default_index(lengths[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s3"># error: Argument 1 to &quot;ensure_index&quot; has incompatible type &quot;Optional[Index]&quot;;</span>
    <span class="s3"># expected &quot;Union[Union[Union[ExtensionArray, ndarray], Index, Series],</span>
    <span class="s3"># Sequence[Any]]&quot;</span>
    <span class="s2">return </span><span class="s1">ensure_index(index)  </span><span class="s3"># type: ignore[arg-type]</span>


<span class="s2">def </span><span class="s1">reorder_arrays(</span>
    <span class="s1">arrays: list[ArrayLike]</span><span class="s2">, </span><span class="s1">arr_columns: Index</span><span class="s2">, </span><span class="s1">columns: Index | </span><span class="s2">None, </span><span class="s1">length: int</span>
<span class="s1">) -&gt; tuple[list[ArrayLike]</span><span class="s2">, </span><span class="s1">Index]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Pre-emptively (cheaply) reindex arrays with new columns. 
    &quot;&quot;&quot;</span>
    <span class="s3"># reorder according to the columns</span>
    <span class="s2">if </span><span class="s1">columns </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">columns.equals(arr_columns):</span>
            <span class="s3"># if they are equal, there is nothing to do</span>
            <span class="s1">new_arrays: list[ArrayLike | </span><span class="s2">None</span><span class="s1">]</span>
            <span class="s1">new_arrays = [</span><span class="s2">None</span><span class="s1">] * len(columns)</span>
            <span class="s1">indexer = arr_columns.get_indexer(columns)</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">k </span><span class="s2">in </span><span class="s1">enumerate(indexer):</span>
                <span class="s2">if </span><span class="s1">k == -</span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s3"># by convention default is all-NaN object dtype</span>
                    <span class="s1">arr = np.empty(length</span><span class="s2">, </span><span class="s1">dtype=object)</span>
                    <span class="s1">arr.fill(np.nan)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">arr = arrays[k]</span>
                <span class="s1">new_arrays[i] = arr</span>

            <span class="s3"># Incompatible types in assignment (expression has type</span>
            <span class="s3"># &quot;List[Union[ExtensionArray, ndarray[Any, Any], None]]&quot;, variable</span>
            <span class="s3"># has type &quot;List[Union[ExtensionArray, ndarray[Any, Any]]]&quot;)</span>
            <span class="s1">arrays = new_arrays  </span><span class="s3"># type: ignore[assignment]</span>
            <span class="s1">arr_columns = columns</span>

    <span class="s2">return </span><span class="s1">arrays</span><span class="s2">, </span><span class="s1">arr_columns</span>


<span class="s2">def </span><span class="s1">_get_names_from_index(data) -&gt; Index:</span>
    <span class="s1">has_some_name = any(getattr(s</span><span class="s2">, </span><span class="s5">&quot;name&quot;</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is not None for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">data)</span>
    <span class="s2">if not </span><span class="s1">has_some_name:</span>
        <span class="s2">return </span><span class="s1">default_index(len(data))</span>

    <span class="s1">index: list[Hashable] = list(range(len(data)))</span>
    <span class="s1">count = </span><span class="s4">0</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">s </span><span class="s2">in </span><span class="s1">enumerate(data):</span>
        <span class="s1">n = getattr(s</span><span class="s2">, </span><span class="s5">&quot;name&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">index[i] = n</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">index[i] = </span><span class="s5">f&quot;Unnamed </span><span class="s2">{</span><span class="s1">count</span><span class="s2">}</span><span class="s5">&quot;</span>
            <span class="s1">count += </span><span class="s4">1</span>

    <span class="s2">return </span><span class="s1">Index(index)</span>


<span class="s2">def </span><span class="s1">_get_axes(</span>
    <span class="s1">N: int</span><span class="s2">, </span><span class="s1">K: int</span><span class="s2">, </span><span class="s1">index: Index | </span><span class="s2">None, </span><span class="s1">columns: Index | </span><span class="s2">None</span>
<span class="s1">) -&gt; tuple[Index</span><span class="s2">, </span><span class="s1">Index]:</span>
    <span class="s3"># helper to create the axes as indexes</span>
    <span class="s3"># return axes or defaults</span>

    <span class="s2">if </span><span class="s1">index </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">index = default_index(N)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">index = ensure_index(index)</span>

    <span class="s2">if </span><span class="s1">columns </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">columns = default_index(K)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">columns = ensure_index(columns)</span>
    <span class="s2">return </span><span class="s1">index</span><span class="s2">, </span><span class="s1">columns</span>


<span class="s2">def </span><span class="s1">dataclasses_to_dicts(data):</span>
    <span class="s0">&quot;&quot;&quot; 
    Converts a list of dataclass instances to a list of dictionaries. 
 
    Parameters 
    ---------- 
    data : List[Type[dataclass]] 
 
    Returns 
    -------- 
    list_dict : List[dict] 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from dataclasses import dataclass 
    &gt;&gt;&gt; @dataclass 
    ... class Point: 
    ...     x: int 
    ...     y: int 
 
    &gt;&gt;&gt; dataclasses_to_dicts([Point(1, 2), Point(2, 3)]) 
    [{'x': 1, 'y': 2}, {'x': 2, 'y': 3}] 
 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">dataclasses </span><span class="s2">import </span><span class="s1">asdict</span>

    <span class="s2">return </span><span class="s1">list(map(asdict</span><span class="s2">, </span><span class="s1">data))</span>


<span class="s3"># ---------------------------------------------------------------------</span>
<span class="s3"># Conversion of Inputs to Arrays</span>


<span class="s2">def </span><span class="s1">to_arrays(</span>
    <span class="s1">data</span><span class="s2">, </span><span class="s1">columns: Index | </span><span class="s2">None, </span><span class="s1">dtype: DtypeObj | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span>
<span class="s1">) -&gt; tuple[list[ArrayLike]</span><span class="s2">, </span><span class="s1">Index]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Return list of arrays, columns. 
 
    Returns 
    ------- 
    list[ArrayLike] 
        These will become columns in a DataFrame. 
    Index 
        This will become frame.columns. 
 
    Notes 
    ----- 
    Ensures that len(result_arrays) == len(result_index). 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">ABCDataFrame):</span>
        <span class="s3"># see test_from_records_with_index_data, test_from_records_bad_index_column</span>
        <span class="s2">if </span><span class="s1">columns </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">arrays = [</span>
                <span class="s1">data._ixs(i</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">).values</span>
                <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">col </span><span class="s2">in </span><span class="s1">enumerate(data.columns)</span>
                <span class="s2">if </span><span class="s1">col </span><span class="s2">in </span><span class="s1">columns</span>
            <span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">columns = data.columns</span>
            <span class="s1">arrays = [data._ixs(i</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">).values </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(columns))]</span>

        <span class="s2">return </span><span class="s1">arrays</span><span class="s2">, </span><span class="s1">columns</span>

    <span class="s2">if not </span><span class="s1">len(data):</span>
        <span class="s2">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s2">if </span><span class="s1">data.dtype.names </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s3"># i.e. numpy structured array</span>
                <span class="s1">columns = ensure_index(data.dtype.names)</span>
                <span class="s1">arrays = [data[name] </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">columns]</span>

                <span class="s2">if </span><span class="s1">len(data) == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s3"># GH#42456 the indexing above results in list of 2D ndarrays</span>
                    <span class="s3"># TODO: is that an issue with numpy?</span>
                    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">enumerate(arrays):</span>
                        <span class="s2">if </span><span class="s1">arr.ndim == </span><span class="s4">2</span><span class="s1">:</span>
                            <span class="s1">arrays[i] = arr[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>

                <span class="s2">return </span><span class="s1">arrays</span><span class="s2">, </span><span class="s1">columns</span>
        <span class="s2">return </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">ensure_index([])</span>

    <span class="s2">elif </span><span class="s1">isinstance(data[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Categorical):</span>
        <span class="s3"># GH#38845 deprecate special case</span>
        <span class="s1">warnings.warn(</span>
            <span class="s5">&quot;The behavior of DataFrame([categorical, ...]) is deprecated and &quot;</span>
            <span class="s5">&quot;in a future version will be changed to match the behavior of &quot;</span>
            <span class="s5">&quot;DataFrame([any_listlike, ...]). &quot;</span>
            <span class="s5">&quot;To retain the old behavior, pass as a dictionary &quot;</span>
            <span class="s5">&quot;DataFrame({col: categorical, ..})&quot;</span><span class="s2">,</span>
            <span class="s1">FutureWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">columns </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">columns = default_index(len(data))</span>
        <span class="s2">elif </span><span class="s1">len(columns) &gt; len(data):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;len(columns) &gt; len(data)&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">len(columns) &lt; len(data):</span>
            <span class="s3"># doing this here is akin to a pre-emptive reindex</span>
            <span class="s1">data = data[: len(columns)]</span>
        <span class="s2">return </span><span class="s1">data</span><span class="s2">, </span><span class="s1">columns</span>

    <span class="s2">elif </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">and </span><span class="s1">data.dtype.names </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s3"># e.g. recarray</span>
        <span class="s1">columns = Index(list(data.dtype.names))</span>
        <span class="s1">arrays = [data[k] </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">columns]</span>
        <span class="s2">return </span><span class="s1">arrays</span><span class="s2">, </span><span class="s1">columns</span>

    <span class="s2">if </span><span class="s1">isinstance(data[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
        <span class="s1">arr = _list_to_arrays(data)</span>
    <span class="s2">elif </span><span class="s1">isinstance(data[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">abc.Mapping):</span>
        <span class="s1">arr</span><span class="s2">, </span><span class="s1">columns = _list_of_dict_to_arrays(data</span><span class="s2">, </span><span class="s1">columns)</span>
    <span class="s2">elif </span><span class="s1">isinstance(data[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ABCSeries):</span>
        <span class="s1">arr</span><span class="s2">, </span><span class="s1">columns = _list_of_series_to_arrays(data</span><span class="s2">, </span><span class="s1">columns)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># last ditch effort</span>
        <span class="s1">data = [tuple(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">data]</span>
        <span class="s1">arr = _list_to_arrays(data)</span>

    <span class="s1">content</span><span class="s2">, </span><span class="s1">columns = _finalize_columns_and_data(arr</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">, </span><span class="s1">dtype)</span>
    <span class="s2">return </span><span class="s1">content</span><span class="s2">, </span><span class="s1">columns</span>


<span class="s2">def </span><span class="s1">_list_to_arrays(data: list[tuple | list]) -&gt; np.ndarray:</span>
    <span class="s3"># Returned np.ndarray has ndim = 2</span>
    <span class="s3"># Note: we already check len(data) &gt; 0 before getting hre</span>
    <span class="s2">if </span><span class="s1">isinstance(data[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tuple):</span>
        <span class="s1">content = lib.to_object_array_tuples(data)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># list of lists</span>
        <span class="s1">content = lib.to_object_array(data)</span>
    <span class="s2">return </span><span class="s1">content</span>


<span class="s2">def </span><span class="s1">_list_of_series_to_arrays(</span>
    <span class="s1">data: list</span><span class="s2">,</span>
    <span class="s1">columns: Index | </span><span class="s2">None,</span>
<span class="s1">) -&gt; tuple[np.ndarray</span><span class="s2">, </span><span class="s1">Index]:</span>
    <span class="s3"># returned np.ndarray has ndim == 2</span>

    <span class="s2">if </span><span class="s1">columns </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s3"># We know pass_data is non-empty because data[0] is a Series</span>
        <span class="s1">pass_data = [x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">data </span><span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">(ABCSeries</span><span class="s2">, </span><span class="s1">ABCDataFrame))]</span>
        <span class="s1">columns = get_objs_combined_axis(pass_data</span><span class="s2">, </span><span class="s1">sort=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">indexer_cache: dict[int</span><span class="s2">, </span><span class="s1">np.ndarray] = {}</span>

    <span class="s1">aligned_values = []</span>
    <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">data:</span>
        <span class="s1">index = getattr(s</span><span class="s2">, </span><span class="s5">&quot;index&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">index </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">index = default_index(len(s))</span>

        <span class="s2">if </span><span class="s1">id(index) </span><span class="s2">in </span><span class="s1">indexer_cache:</span>
            <span class="s1">indexer = indexer_cache[id(index)]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">indexer = indexer_cache[id(index)] = index.get_indexer(columns)</span>

        <span class="s1">values = extract_array(s</span><span class="s2">, </span><span class="s1">extract_numpy=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">aligned_values.append(algorithms.take_nd(values</span><span class="s2">, </span><span class="s1">indexer))</span>

    <span class="s3"># error: Argument 1 to &quot;vstack&quot; has incompatible type &quot;List[ExtensionArray]&quot;;</span>
    <span class="s3"># expected &quot;Sequence[Union[Union[int, float, complex, str, bytes, generic],</span>
    <span class="s3"># Sequence[Union[int, float, complex, str, bytes, generic]],</span>
    <span class="s3"># Sequence[Sequence[Any]], _SupportsArray]]&quot;</span>
    <span class="s1">content = np.vstack(aligned_values)  </span><span class="s3"># type: ignore[arg-type]</span>

    <span class="s2">return </span><span class="s1">content</span><span class="s2">, </span><span class="s1">columns</span>


<span class="s2">def </span><span class="s1">_list_of_dict_to_arrays(</span>
    <span class="s1">data: list[dict]</span><span class="s2">,</span>
    <span class="s1">columns: Index | </span><span class="s2">None,</span>
<span class="s1">) -&gt; tuple[np.ndarray</span><span class="s2">, </span><span class="s1">Index]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert list of dicts to numpy arrays 
 
    if `columns` is not passed, column names are inferred from the records 
    - for OrderedDict and dicts, the column names match 
      the key insertion-order from the first record to the last. 
    - For other kinds of dict-likes, the keys are lexically sorted. 
 
    Parameters 
    ---------- 
    data : iterable 
        collection of records (OrderedDict, dict) 
    columns: iterables or None 
 
    Returns 
    ------- 
    content : np.ndarray[object, ndim=2] 
    columns : Index 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">columns </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">gen = (list(x.keys()) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">data)</span>
        <span class="s1">sort = </span><span class="s2">not </span><span class="s1">any(isinstance(d</span><span class="s2">, </span><span class="s1">dict) </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">data)</span>
        <span class="s1">pre_cols = lib.fast_unique_multiple_list_gen(gen</span><span class="s2">, </span><span class="s1">sort=sort)</span>
        <span class="s1">columns = ensure_index(pre_cols)</span>

    <span class="s3"># assure that they are of the base dict class and not of derived</span>
    <span class="s3"># classes</span>
    <span class="s1">data = [d </span><span class="s2">if </span><span class="s1">type(d) </span><span class="s2">is </span><span class="s1">dict </span><span class="s2">else </span><span class="s1">dict(d) </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">data]</span>

    <span class="s1">content = lib.dicts_to_array(data</span><span class="s2">, </span><span class="s1">list(columns))</span>
    <span class="s2">return </span><span class="s1">content</span><span class="s2">, </span><span class="s1">columns</span>


<span class="s2">def </span><span class="s1">_finalize_columns_and_data(</span>
    <span class="s1">content: np.ndarray</span><span class="s2">,  </span><span class="s3"># ndim == 2</span>
    <span class="s1">columns: Index | </span><span class="s2">None,</span>
    <span class="s1">dtype: DtypeObj | </span><span class="s2">None,</span>
<span class="s1">) -&gt; tuple[list[ArrayLike]</span><span class="s2">, </span><span class="s1">Index]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Ensure we have valid columns, cast object dtypes if possible. 
    &quot;&quot;&quot;</span>
    <span class="s1">contents = list(content.T)</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">columns = _validate_or_indexify_columns(contents</span><span class="s2">, </span><span class="s1">columns)</span>
    <span class="s2">except </span><span class="s1">AssertionError </span><span class="s2">as </span><span class="s1">err:</span>
        <span class="s3"># GH#26429 do not raise user-facing AssertionError</span>
        <span class="s2">raise </span><span class="s1">ValueError(err) </span><span class="s2">from </span><span class="s1">err</span>

    <span class="s2">if </span><span class="s1">len(contents) </span><span class="s2">and </span><span class="s1">contents[</span><span class="s4">0</span><span class="s1">].dtype == np.object_:</span>
        <span class="s1">contents = _convert_object_array(contents</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s2">return </span><span class="s1">contents</span><span class="s2">, </span><span class="s1">columns</span>


<span class="s2">def </span><span class="s1">_validate_or_indexify_columns(</span>
    <span class="s1">content: list[np.ndarray]</span><span class="s2">, </span><span class="s1">columns: Index | </span><span class="s2">None</span>
<span class="s1">) -&gt; Index:</span>
    <span class="s0">&quot;&quot;&quot; 
    If columns is None, make numbers as column names; Otherwise, validate that 
    columns have valid length. 
 
    Parameters 
    ---------- 
    content : list of np.ndarrays 
    columns : Index or None 
 
    Returns 
    ------- 
    Index 
        If columns is None, assign positional column index value as columns. 
 
    Raises 
    ------ 
    1. AssertionError when content is not composed of list of lists, and if 
        length of columns is not equal to length of content. 
    2. ValueError when content is list of lists, but length of each sub-list 
        is not equal 
    3. ValueError when content is list of lists, but length of sub-list is 
        not equal to length of content 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">columns </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">columns = default_index(len(content))</span>
    <span class="s2">else</span><span class="s1">:</span>

        <span class="s3"># Add mask for data which is composed of list of lists</span>
        <span class="s1">is_mi_list = isinstance(columns</span><span class="s2">, </span><span class="s1">list) </span><span class="s2">and </span><span class="s1">all(</span>
            <span class="s1">isinstance(col</span><span class="s2">, </span><span class="s1">list) </span><span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">columns</span>
        <span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">is_mi_list </span><span class="s2">and </span><span class="s1">len(columns) != len(content):  </span><span class="s3"># pragma: no cover</span>
            <span class="s3"># caller's responsibility to check for this...</span>
            <span class="s2">raise </span><span class="s1">AssertionError(</span>
                <span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">len(columns)</span><span class="s2">} </span><span class="s5">columns passed, passed data had &quot;</span>
                <span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">len(content)</span><span class="s2">} </span><span class="s5">columns&quot;</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">is_mi_list:</span>

            <span class="s3"># check if nested list column, length of each sub-list should be equal</span>
            <span class="s2">if </span><span class="s1">len({len(col) </span><span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">columns}) &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s5">&quot;Length of columns passed for MultiIndex columns is different&quot;</span>
                <span class="s1">)</span>

            <span class="s3"># if columns is not empty and length of sublist is not equal to content</span>
            <span class="s2">elif </span><span class="s1">columns </span><span class="s2">and </span><span class="s1">len(columns[</span><span class="s4">0</span><span class="s1">]) != len(content):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">len(columns[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">} </span><span class="s5">columns passed, passed data had &quot;</span>
                    <span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">len(content)</span><span class="s2">} </span><span class="s5">columns&quot;</span>
                <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">columns</span>


<span class="s2">def </span><span class="s1">_convert_object_array(</span>
    <span class="s1">content: list[np.ndarray]</span><span class="s2">, </span><span class="s1">dtype: DtypeObj | </span><span class="s2">None</span>
<span class="s1">) -&gt; list[ArrayLike]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Internal function to convert object array. 
 
    Parameters 
    ---------- 
    content: List[np.ndarray] 
    dtype: np.dtype or ExtensionDtype 
 
    Returns 
    ------- 
    List[ArrayLike] 
    &quot;&quot;&quot;</span>
    <span class="s3"># provide soft conversion of object dtypes</span>
    <span class="s2">def </span><span class="s1">convert(arr):</span>
        <span class="s2">if </span><span class="s1">dtype != np.dtype(</span><span class="s5">&quot;O&quot;</span><span class="s1">):</span>
            <span class="s1">arr = lib.maybe_convert_objects(arr)</span>
            <span class="s1">arr = maybe_cast_to_datetime(arr</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s2">return </span><span class="s1">arr</span>

    <span class="s1">arrays = [convert(arr) </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">content]</span>

    <span class="s2">return </span><span class="s1">arrays</span>
</pre>
</body>
</html>