<html>
<head>
<title>test_common_basic.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_common_basic.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests that work on both the Python and C engines but do not have a 
specific classification into the other test modules. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">datetime</span>
<span class="s2">from </span><span class="s1">inspect </span><span class="s2">import </span><span class="s1">signature</span>
<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">StringIO</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">from </span><span class="s1">pathlib </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">import </span><span class="s1">sys</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">pandas.compat </span><span class="s2">import </span><span class="s1">PY310</span>
<span class="s2">from </span><span class="s1">pandas.errors </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">EmptyDataError</span><span class="s2">,</span>
    <span class="s1">ParserError</span><span class="s2">,</span>
    <span class="s1">ParserWarning</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s2">,</span>
    <span class="s1">Index</span><span class="s2">,</span>
    <span class="s1">Series</span><span class="s2">,</span>
    <span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">compat</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas._testing </span><span class="s2">as </span><span class="s1">tm</span>

<span class="s2">from </span><span class="s1">pandas.io.parsers </span><span class="s2">import </span><span class="s1">TextFileReader</span>
<span class="s2">from </span><span class="s1">pandas.io.parsers.c_parser_wrapper </span><span class="s2">import </span><span class="s1">CParserWrapper</span>

<span class="s1">xfail_pyarrow = pytest.mark.usefixtures(</span><span class="s3">&quot;pyarrow_xfail&quot;</span><span class="s1">)</span>
<span class="s1">skip_pyarrow = pytest.mark.usefixtures(</span><span class="s3">&quot;pyarrow_skip&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_override_set_noconvert_columns():</span>
    <span class="s4"># see gh-17351</span>
    <span class="s4">#</span>
    <span class="s4"># Usecols needs to be sorted in _set_noconvert_columns based</span>
    <span class="s4"># on the test_usecols_with_parse_dates test from test_usecols.py</span>
    <span class="s2">class </span><span class="s1">MyTextFileReader(TextFileReader):</span>
        <span class="s2">def </span><span class="s1">__init__(self):</span>
            <span class="s1">self._currow = </span><span class="s5">0</span>
            <span class="s1">self.squeeze = </span><span class="s2">False</span>

    <span class="s2">class </span><span class="s1">MyCParserWrapper(CParserWrapper):</span>
        <span class="s2">def </span><span class="s1">_set_noconvert_columns(self):</span>
            <span class="s2">if </span><span class="s1">self.usecols_dtype == </span><span class="s3">&quot;integer&quot;</span><span class="s1">:</span>
                <span class="s4"># self.usecols is a set, which is documented as unordered</span>
                <span class="s4"># but in practice, a CPython set of integers is sorted.</span>
                <span class="s4"># In other implementations this assumption does not hold.</span>
                <span class="s4"># The following code simulates a different order, which</span>
                <span class="s4"># before GH 17351 would cause the wrong columns to be</span>
                <span class="s4"># converted via the parse_dates parameter</span>
                <span class="s1">self.usecols = list(self.usecols)</span>
                <span class="s1">self.usecols.reverse()</span>
            <span class="s2">return </span><span class="s1">CParserWrapper._set_noconvert_columns(self)</span>

    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot;a,b,c,d,e 
0,1,20140101,0900,4 
0,1,20140102,1000,4&quot;&quot;&quot;</span>

    <span class="s1">parse_dates = [[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]]</span>
    <span class="s1">cols = {</span>
        <span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;c_d&quot;</span><span class="s1">: [Timestamp(</span><span class="s3">&quot;2014-01-01 09:00:00&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2014-01-02 10:00:00&quot;</span><span class="s1">)]</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">expected = DataFrame(cols</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;c_d&quot;</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s1">])</span>

    <span class="s1">parser = MyTextFileReader()</span>
    <span class="s1">parser.options = {</span>
        <span class="s3">&quot;usecols&quot;</span><span class="s1">: [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;parse_dates&quot;</span><span class="s1">: parse_dates</span><span class="s2">,</span>
        <span class="s3">&quot;delimiter&quot;</span><span class="s1">: </span><span class="s3">&quot;,&quot;</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">parser.engine = </span><span class="s3">&quot;c&quot;</span>
    <span class="s1">parser._engine = MyCParserWrapper(StringIO(data)</span><span class="s2">, </span><span class="s1">**parser.options)</span>

    <span class="s1">result = parser.read()</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_read_csv_local(all_parsers</span><span class="s2">, </span><span class="s1">csv1):</span>
    <span class="s1">prefix = </span><span class="s3">&quot;file:///&quot; </span><span class="s2">if </span><span class="s1">compat.is_platform_windows() </span><span class="s2">else </span><span class="s3">&quot;file://&quot;</span>
    <span class="s1">parser = all_parsers</span>

    <span class="s1">fname = prefix + str(os.path.abspath(csv1))</span>
    <span class="s1">result = parser.read_csv(fname</span><span class="s2">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">parse_dates=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s5">0.980269</span><span class="s2">, </span><span class="s5">3.685731</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.364216805298</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.159738</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">1.047916</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.041232</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.16181208307</span><span class="s2">, </span><span class="s5">0.212549</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.498581</span><span class="s2">, </span><span class="s5">0.731168</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.537677223318</span><span class="s2">, </span><span class="s5">1.346270</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">1.120202</span><span class="s2">, </span><span class="s5">1.567621</span><span class="s2">, </span><span class="s5">0.00364077397681</span><span class="s2">, </span><span class="s5">0.675253</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[-</span><span class="s5">0.487094</span><span class="s2">, </span><span class="s5">0.571455</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.6116394093</span><span class="s2">, </span><span class="s5">0.103469</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.836649</span><span class="s2">, </span><span class="s5">0.246462</span><span class="s2">, </span><span class="s5">0.588542635376</span><span class="s2">, </span><span class="s5">1.062782</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[-</span><span class="s5">0.157161</span><span class="s2">, </span><span class="s5">1.340307</span><span class="s2">, </span><span class="s5">1.1957779562</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.097007</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">columns=[</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">index=Index(</span>
            <span class="s1">[</span>
                <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">6</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">7</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">11</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">name=</span><span class="s3">&quot;index&quot;</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s2">def </span><span class="s1">test_1000_sep(all_parsers):</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot;A|B|C 
1|2,334|5 
10|13|10. 
&quot;&quot;&quot;</span>
    <span class="s1">expected = DataFrame({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">10</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: [</span><span class="s5">2334</span><span class="s2">, </span><span class="s5">13</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s1">: [</span><span class="s5">5</span><span class="s2">, </span><span class="s5">10.0</span><span class="s1">]})</span>

    <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">sep=</span><span class="s3">&quot;|&quot;</span><span class="s2">, </span><span class="s1">thousands=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;squeeze&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_squeeze(all_parsers</span><span class="s2">, </span><span class="s1">squeeze):</span>
    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">a,1 
b,2 
c,3 
&quot;&quot;&quot;</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">index = Index([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">expected = Series([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">index=index)</span>

    <span class="s1">result = parser.read_csv_check_warnings(</span>
        <span class="s1">FutureWarning</span><span class="s2">,</span>
        <span class="s3">&quot;The squeeze argument has been deprecated &quot;</span>
        <span class="s3">&quot;and will be removed in a future version. &quot;</span>
        <span class="s3">'Append .squeeze</span><span class="s2">\\</span><span class="s3">(&quot;columns&quot;</span><span class="s2">\\</span><span class="s3">) to the call to squeeze.</span><span class="s2">\n\n</span><span class="s3">'</span><span class="s2">,</span>
        <span class="s1">StringIO(data)</span><span class="s2">,</span>
        <span class="s1">index_col=</span><span class="s5">0</span><span class="s2">,</span>
        <span class="s1">header=</span><span class="s2">None,</span>
        <span class="s1">squeeze=squeeze</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">squeeze:</span>
        <span class="s1">expected = DataFrame(expected)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s4"># see gh-8217</span>
        <span class="s4">#</span>
        <span class="s4"># Series should not be a view.</span>
        <span class="s2">assert not </span><span class="s1">result._is_view</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s2">def </span><span class="s1">test_unnamed_columns(all_parsers):</span>
    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot;A,B,C,, 
1,2,3,4,5 
6,7,8,9,10 
11,12,13,14,15 
&quot;&quot;&quot;</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">6</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">11</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">13</span><span class="s2">, </span><span class="s5">14</span><span class="s2">, </span><span class="s5">15</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">dtype=np.int64</span><span class="s2">,</span>
        <span class="s1">columns=[</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;Unnamed: 3&quot;</span><span class="s2">, </span><span class="s3">&quot;Unnamed: 4&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">result = parser.read_csv(StringIO(data))</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_csv_mixed_type(all_parsers):</span>
    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot;A,B,C 
a,1,2 
b,3,4 
c,4,5 
&quot;&quot;&quot;</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">expected = DataFrame({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]})</span>
    <span class="s1">result = parser.read_csv(StringIO(data))</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s2">def </span><span class="s1">test_read_csv_low_memory_no_rows_with_index(all_parsers):</span>
    <span class="s4"># see gh-21141</span>
    <span class="s1">parser = all_parsers</span>

    <span class="s2">if not </span><span class="s1">parser.low_memory:</span>
        <span class="s1">pytest.skip(</span><span class="s3">&quot;This is a low-memory specific test&quot;</span><span class="s1">)</span>

    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot;A,B,C 
1,1,1,2 
2,2,3,4 
3,3,4,5 
&quot;&quot;&quot;</span>
    <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">low_memory=</span><span class="s2">True, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">nrows=</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(columns=[</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_read_csv_dataframe(all_parsers</span><span class="s2">, </span><span class="s1">csv1):</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">result = parser.read_csv(csv1</span><span class="s2">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">parse_dates=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s5">0.980269</span><span class="s2">, </span><span class="s5">3.685731</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.364216805298</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.159738</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">1.047916</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.041232</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.16181208307</span><span class="s2">, </span><span class="s5">0.212549</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.498581</span><span class="s2">, </span><span class="s5">0.731168</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.537677223318</span><span class="s2">, </span><span class="s5">1.346270</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">1.120202</span><span class="s2">, </span><span class="s5">1.567621</span><span class="s2">, </span><span class="s5">0.00364077397681</span><span class="s2">, </span><span class="s5">0.675253</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[-</span><span class="s5">0.487094</span><span class="s2">, </span><span class="s5">0.571455</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.6116394093</span><span class="s2">, </span><span class="s5">0.103469</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.836649</span><span class="s2">, </span><span class="s5">0.246462</span><span class="s2">, </span><span class="s5">0.588542635376</span><span class="s2">, </span><span class="s5">1.062782</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[-</span><span class="s5">0.157161</span><span class="s2">, </span><span class="s5">1.340307</span><span class="s2">, </span><span class="s5">1.1957779562</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.097007</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">columns=[</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">index=Index(</span>
            <span class="s1">[</span>
                <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">6</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">7</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">11</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">name=</span><span class="s3">&quot;index&quot;</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;nrows&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3.0</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_read_nrows(all_parsers</span><span class="s2">, </span><span class="s1">nrows):</span>
    <span class="s4"># see gh-10476</span>
    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot;index,A,B,C,D 
foo,2,3,4,5 
bar,7,8,9,10 
baz,12,13,14,15 
qux,12,13,14,15 
foo2,12,13,14,15 
bar2,12,13,14,15 
&quot;&quot;&quot;</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s3">&quot;foo&quot;</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;bar&quot;</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;baz&quot;</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">13</span><span class="s2">, </span><span class="s5">14</span><span class="s2">, </span><span class="s5">15</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">columns=[</span><span class="s3">&quot;index&quot;</span><span class="s2">, </span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">parser = all_parsers</span>

    <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">nrows=nrows)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;nrows&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1.2</span><span class="s2">, </span><span class="s3">&quot;foo&quot;</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_read_nrows_bad(all_parsers</span><span class="s2">, </span><span class="s1">nrows):</span>
    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot;index,A,B,C,D 
foo,2,3,4,5 
bar,7,8,9,10 
baz,12,13,14,15 
qux,12,13,14,15 
foo2,12,13,14,15 
bar2,12,13,14,15 
&quot;&quot;&quot;</span>
    <span class="s1">msg = </span><span class="s3">r&quot;'nrows' must be an integer &gt;=0&quot;</span>
    <span class="s1">parser = all_parsers</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">nrows=nrows)</span>


<span class="s2">def </span><span class="s1">test_nrows_skipfooter_errors(all_parsers):</span>
    <span class="s1">msg = </span><span class="s3">&quot;'skipfooter' not supported with 'nrows'&quot;</span>
    <span class="s1">data = </span><span class="s3">&quot;a</span><span class="s2">\n</span><span class="s3">1</span><span class="s2">\n</span><span class="s3">2</span><span class="s2">\n</span><span class="s3">3</span><span class="s2">\n</span><span class="s3">4</span><span class="s2">\n</span><span class="s3">5</span><span class="s2">\n</span><span class="s3">6&quot;</span>
    <span class="s1">parser = all_parsers</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">skipfooter=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">nrows=</span><span class="s5">5</span><span class="s1">)</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s2">def </span><span class="s1">test_missing_trailing_delimiters(all_parsers):</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot;A,B,C,D 
1,2,3,4 
1,3,3, 
1,4,5&quot;&quot;&quot;</span>

    <span class="s1">result = parser.read_csv(StringIO(data))</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s1">np.nan]]</span><span class="s2">,</span>
        <span class="s1">columns=[</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s2">def </span><span class="s1">test_skip_initial_space(all_parsers):</span>
    <span class="s1">data = (</span>
        <span class="s3">'&quot;09-Apr-2012&quot;, &quot;01:10:18.300&quot;, 2456026.548822908, 12849, '</span>
        <span class="s3">&quot;1.00361,  1.12551, 330.65659, 0355626618.16711,  73.48821, &quot;</span>
        <span class="s3">&quot;314.11625,  1917.09447,   179.71425,  80.000, 240.000, -350,  &quot;</span>
        <span class="s3">&quot;70.06056, 344.98370, 1,   1, -0.689265, -0.692787,  &quot;</span>
        <span class="s3">&quot;0.212036,    14.7674,   41.605,   -9999.0,   -9999.0,   &quot;</span>
        <span class="s3">&quot;-9999.0,   -9999.0,   -9999.0,  -9999.0, 000, 012, 128&quot;</span>
    <span class="s1">)</span>
    <span class="s1">parser = all_parsers</span>

    <span class="s1">result = parser.read_csv(</span>
        <span class="s1">StringIO(data)</span><span class="s2">,</span>
        <span class="s1">names=list(range(</span><span class="s5">33</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">header=</span><span class="s2">None,</span>
        <span class="s1">na_values=[</span><span class="s3">&quot;-9999.0&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">skipinitialspace=</span><span class="s2">True,</span>
    <span class="s1">)</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[</span>
            <span class="s1">[</span>
                <span class="s3">&quot;09-Apr-2012&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;01:10:18.300&quot;</span><span class="s2">,</span>
                <span class="s5">2456026.548822908</span><span class="s2">,</span>
                <span class="s5">12849</span><span class="s2">,</span>
                <span class="s5">1.00361</span><span class="s2">,</span>
                <span class="s5">1.12551</span><span class="s2">,</span>
                <span class="s5">330.65659</span><span class="s2">,</span>
                <span class="s5">355626618.16711</span><span class="s2">,</span>
                <span class="s5">73.48821</span><span class="s2">,</span>
                <span class="s5">314.11625</span><span class="s2">,</span>
                <span class="s5">1917.09447</span><span class="s2">,</span>
                <span class="s5">179.71425</span><span class="s2">,</span>
                <span class="s5">80.0</span><span class="s2">,</span>
                <span class="s5">240.0</span><span class="s2">,</span>
                <span class="s1">-</span><span class="s5">350</span><span class="s2">,</span>
                <span class="s5">70.06056</span><span class="s2">,</span>
                <span class="s5">344.9837</span><span class="s2">,</span>
                <span class="s5">1</span><span class="s2">,</span>
                <span class="s5">1</span><span class="s2">,</span>
                <span class="s1">-</span><span class="s5">0.689265</span><span class="s2">,</span>
                <span class="s1">-</span><span class="s5">0.692787</span><span class="s2">,</span>
                <span class="s5">0.212036</span><span class="s2">,</span>
                <span class="s5">14.7674</span><span class="s2">,</span>
                <span class="s5">41.605</span><span class="s2">,</span>
                <span class="s1">np.nan</span><span class="s2">,</span>
                <span class="s1">np.nan</span><span class="s2">,</span>
                <span class="s1">np.nan</span><span class="s2">,</span>
                <span class="s1">np.nan</span><span class="s2">,</span>
                <span class="s1">np.nan</span><span class="s2">,</span>
                <span class="s1">np.nan</span><span class="s2">,</span>
                <span class="s5">0</span><span class="s2">,</span>
                <span class="s5">12</span><span class="s2">,</span>
                <span class="s5">128</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s2">def </span><span class="s1">test_trailing_delimiters(all_parsers):</span>
    <span class="s4"># see gh-2442</span>
    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot;A,B,C 
1,2,3, 
4,5,6, 
7,8,9,&quot;&quot;&quot;</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">index_col=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">expected = DataFrame({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">7</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">8</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s1">: [</span><span class="s5">3</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">9</span><span class="s1">]})</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_escapechar(all_parsers):</span>
    <span class="s4"># https://stackoverflow.com/questions/13824840/feature-request-for-</span>
    <span class="s4"># pandas-read-csv</span>
    <span class="s1">data = </span><span class="s3">'''SEARCH_TERM,ACTUAL_URL 
&quot;bra tv board&quot;,&quot;http://www.ikea.com/se/sv/catalog/categories/departments/living_room/10475/?se%7cps%7cnonbranded%7cvardagsrum%7cgoogle%7ctv_bord&quot; 
&quot;tv p</span><span class="s2">\xc3\xa5 </span><span class="s3">hjul&quot;,&quot;http://www.ikea.com/se/sv/catalog/categories/departments/living_room/10475/?se%7cps%7cnonbranded%7cvardagsrum%7cgoogle%7ctv_bord&quot; 
&quot;SLAGBORD, </span><span class="s2">\\</span><span class="s3">&quot;Bergslagen</span><span class="s2">\\</span><span class="s3">&quot;, IKEA:s 1700-tals series&quot;,&quot;http://www.ikea.com/se/sv/catalog/categories/departments/living_room/10475/?se%7cps%7cnonbranded%7cvardagsrum%7cgoogle%7ctv_bord&quot;'''  </span><span class="s4"># noqa:E501</span>

    <span class="s1">parser = all_parsers</span>
    <span class="s1">result = parser.read_csv(</span>
        <span class="s1">StringIO(data)</span><span class="s2">, </span><span class="s1">escapechar=</span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">quotechar=</span><span class="s3">'&quot;'</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s3">&quot;utf-8&quot;</span>
    <span class="s1">)</span>

    <span class="s2">assert </span><span class="s1">result[</span><span class="s3">&quot;SEARCH_TERM&quot;</span><span class="s1">][</span><span class="s5">2</span><span class="s1">] == </span><span class="s3">'SLAGBORD, &quot;Bergslagen&quot;, IKEA:s 1700-tals series'</span>

    <span class="s1">tm.assert_index_equal(result.columns</span><span class="s2">, </span><span class="s1">Index([</span><span class="s3">&quot;SEARCH_TERM&quot;</span><span class="s2">, </span><span class="s3">&quot;ACTUAL_URL&quot;</span><span class="s1">]))</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s2">def </span><span class="s1">test_ignore_leading_whitespace(all_parsers):</span>
    <span class="s4"># see gh-3374, gh-6607</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">data = </span><span class="s3">&quot; a b c</span><span class="s2">\n </span><span class="s3">1 2 3</span><span class="s2">\n </span><span class="s3">4 5 6</span><span class="s2">\n </span><span class="s3">7 8 9&quot;</span>
    <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">sep=</span><span class="s3">r&quot;\s+&quot;</span><span class="s1">)</span>

    <span class="s1">expected = DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">7</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">8</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">: [</span><span class="s5">3</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">9</span><span class="s1">]})</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;usecols&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]])</span>
<span class="s2">def </span><span class="s1">test_uneven_lines_with_usecols(all_parsers</span><span class="s2">, </span><span class="s1">usecols):</span>
    <span class="s4"># see gh-12203</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">data = </span><span class="s3">r&quot;&quot;&quot;a,b,c 
0,1,2 
3,4,5,6,7 
8,9,10&quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">usecols </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s4"># Make sure that an error is still raised</span>
        <span class="s4"># when the &quot;usecols&quot; parameter is not provided.</span>
        <span class="s1">msg = </span><span class="s3">r&quot;Expected \d+ fields in line \d+, saw \d+&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ParserError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">parser.read_csv(StringIO(data))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">expected = DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">8</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">9</span><span class="s1">]})</span>

        <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">usecols=usecols)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;data,kwargs,expected&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s4"># First, check to see that the response of parser when faced with no</span>
        <span class="s4"># provided columns raises the correct error, with or without usecols.</span>
        <span class="s1">(</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">{}</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;usecols&quot;</span><span class="s1">: [</span><span class="s3">&quot;X&quot;</span><span class="s1">]}</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;,,&quot;</span><span class="s2">,</span>
            <span class="s1">{</span><span class="s3">&quot;names&quot;</span><span class="s1">: [</span><span class="s3">&quot;Dummy&quot;</span><span class="s2">, </span><span class="s3">&quot;X&quot;</span><span class="s2">, </span><span class="s3">&quot;Dummy_2&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;usecols&quot;</span><span class="s1">: [</span><span class="s3">&quot;X&quot;</span><span class="s1">]}</span><span class="s2">,</span>
            <span class="s1">DataFrame(columns=[</span><span class="s3">&quot;X&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;&quot;</span><span class="s2">,</span>
            <span class="s1">{</span><span class="s3">&quot;names&quot;</span><span class="s1">: [</span><span class="s3">&quot;Dummy&quot;</span><span class="s2">, </span><span class="s3">&quot;X&quot;</span><span class="s2">, </span><span class="s3">&quot;Dummy_2&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;usecols&quot;</span><span class="s1">: [</span><span class="s3">&quot;X&quot;</span><span class="s1">]}</span><span class="s2">,</span>
            <span class="s1">DataFrame(columns=[</span><span class="s3">&quot;X&quot;</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_read_empty_with_usecols(all_parsers</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s4"># see gh-12493</span>
    <span class="s1">parser = all_parsers</span>

    <span class="s2">if </span><span class="s1">expected </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s3">&quot;No columns to parse from file&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(EmptyDataError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;kwargs,expected&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s4"># gh-8661, gh-8679: this should ignore six lines, including</span>
        <span class="s4"># lines with trailing whitespace and blank lines.</span>
        <span class="s1">(</span>
            <span class="s1">{</span>
                <span class="s3">&quot;header&quot;</span><span class="s1">: </span><span class="s2">None,</span>
                <span class="s3">&quot;delim_whitespace&quot;</span><span class="s1">: </span><span class="s2">True,</span>
                <span class="s3">&quot;skiprows&quot;</span><span class="s1">: [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">6</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;skip_blank_lines&quot;</span><span class="s1">: </span><span class="s2">True,</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">DataFrame([[</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">4.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">5.1</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s5">10.0</span><span class="s1">]])</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s4"># gh-8983: test skipping set of rows after a row with trailing spaces.</span>
        <span class="s1">(</span>
            <span class="s1">{</span>
                <span class="s3">&quot;delim_whitespace&quot;</span><span class="s1">: </span><span class="s2">True,</span>
                <span class="s3">&quot;skiprows&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">6</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;skip_blank_lines&quot;</span><span class="s1">: </span><span class="s2">True,</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">DataFrame({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">5.1</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: [</span><span class="s5">2.0</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s1">: [</span><span class="s5">4.0</span><span class="s2">, </span><span class="s5">10</span><span class="s1">]})</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_trailing_spaces(all_parsers</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s1">data = </span><span class="s3">&quot;A B C  </span><span class="s2">\n</span><span class="s3">random line with trailing spaces    </span><span class="s2">\n</span><span class="s3">skip</span><span class="s2">\n</span><span class="s3">1,2,3</span><span class="s2">\n</span><span class="s3">1,2.,4.</span><span class="s2">\n</span><span class="s3">random line with trailing tabs</span><span class="s2">\t\t\t\n   \n</span><span class="s3">5.1,NaN,10.0</span><span class="s2">\n</span><span class="s3">&quot;  </span><span class="s4"># noqa:E501</span>
    <span class="s1">parser = all_parsers</span>

    <span class="s1">result = parser.read_csv(StringIO(data.replace(</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s3">&quot;  &quot;</span><span class="s1">))</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_raise_on_sep_with_delim_whitespace(all_parsers):</span>
    <span class="s4"># see gh-6607</span>
    <span class="s1">data = </span><span class="s3">&quot;a b c</span><span class="s2">\n</span><span class="s3">1 2 3&quot;</span>
    <span class="s1">parser = all_parsers</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;you can only specify one&quot;</span><span class="s1">):</span>
        <span class="s1">parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">sep=</span><span class="s3">r&quot;\s&quot;</span><span class="s2">, </span><span class="s1">delim_whitespace=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_read_filepath_or_buffer(all_parsers):</span>
    <span class="s4"># see gh-43366</span>
    <span class="s1">parser = all_parsers</span>

    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Expected file path name or file-like&quot;</span><span class="s1">):</span>
        <span class="s1">parser.read_csv(filepath_or_buffer=</span><span class="s6">b&quot;input&quot;</span><span class="s1">)</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;delim_whitespace&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_single_char_leading_whitespace(all_parsers</span><span class="s2">, </span><span class="s1">delim_whitespace):</span>
    <span class="s4"># see gh-9710</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">MyColumn 
a 
b 
a 
b</span><span class="s2">\n</span><span class="s3">&quot;&quot;&quot;</span>

    <span class="s1">expected = DataFrame({</span><span class="s3">&quot;MyColumn&quot;</span><span class="s1">: list(</span><span class="s3">&quot;abab&quot;</span><span class="s1">)})</span>
    <span class="s1">result = parser.read_csv(</span>
        <span class="s1">StringIO(data)</span><span class="s2">, </span><span class="s1">skipinitialspace=</span><span class="s2">True, </span><span class="s1">delim_whitespace=delim_whitespace</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s4"># Skip for now, actually only one test fails though, but its tricky to xfail</span>
<span class="s1">@skip_pyarrow</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;sep,skip_blank_lines,exp_data&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s3">&quot;,&quot;</span><span class="s2">, True, </span><span class="s1">[[</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">4.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">5.0</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s5">10.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s5">70.0</span><span class="s2">, </span><span class="s5">0.4</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">]])</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">r&quot;\s+&quot;</span><span class="s2">, True, </span><span class="s1">[[</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">4.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">5.0</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s5">10.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s5">70.0</span><span class="s2">, </span><span class="s5">0.4</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">]])</span><span class="s2">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;,&quot;</span><span class="s2">,</span>
            <span class="s2">False,</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">4.0</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">,</span>
                <span class="s1">[np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s5">5.0</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s5">10.0</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">,</span>
                <span class="s1">[-</span><span class="s5">70.0</span><span class="s2">, </span><span class="s5">0.4</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_empty_lines(all_parsers</span><span class="s2">, </span><span class="s1">sep</span><span class="s2">, </span><span class="s1">skip_blank_lines</span><span class="s2">, </span><span class="s1">exp_data):</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">A,B,C 
1,2.,4. 
 
 
5.,NaN,10.0 
 
-70,.4,1 
&quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">sep == </span><span class="s3">r&quot;\s+&quot;</span><span class="s1">:</span>
        <span class="s1">data = data.replace(</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s3">&quot;  &quot;</span><span class="s1">)</span>

    <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">sep=sep</span><span class="s2">, </span><span class="s1">skip_blank_lines=skip_blank_lines)</span>
    <span class="s1">expected = DataFrame(exp_data</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s2">def </span><span class="s1">test_whitespace_lines(all_parsers):</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot; 
 
</span><span class="s2">\t  \t\t</span>
<span class="s2">\t</span>
<span class="s3">A,B,C 
</span><span class="s2">\t    </span><span class="s3">1,2.,4. 
5.,NaN,10.0 
&quot;&quot;&quot;</span>
    <span class="s1">expected = DataFrame([[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">4.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">5.0</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s5">10.0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s1">])</span>
    <span class="s1">result = parser.read_csv(StringIO(data))</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;data,expected&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s3">&quot;&quot;&quot;   A   B   C   D 
a   1   2   3   4 
b   1   2   3   4 
c   1   2   3   4 
&quot;&quot;&quot;</span><span class="s2">,</span>
            <span class="s1">DataFrame(</span>
                <span class="s1">[[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">]]</span><span class="s2">,</span>
                <span class="s1">columns=[</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">index=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;    a b c</span><span class="s2">\n</span><span class="s3">1 2 3 </span><span class="s2">\n</span><span class="s3">4 5  6</span><span class="s2">\n </span><span class="s3">7 8 9&quot;</span><span class="s2">,</span>
            <span class="s1">DataFrame([[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">7</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">9</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_whitespace_regex_separator(all_parsers</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s4"># see gh-6607</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">sep=</span><span class="s3">r&quot;\s+&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_sub_character(all_parsers</span><span class="s2">, </span><span class="s1">csv_dir_path):</span>
    <span class="s4"># see gh-16893</span>
    <span class="s1">filename = os.path.join(csv_dir_path</span><span class="s2">, </span><span class="s3">&quot;sub_char.csv&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame([[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\x1a</span><span class="s3">b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span>

    <span class="s1">parser = all_parsers</span>
    <span class="s1">result = parser.read_csv(filename)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;filename&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;sé-es-vé.csv&quot;</span><span class="s2">, </span><span class="s3">&quot;ru-sй.csv&quot;</span><span class="s2">, </span><span class="s3">&quot;中文文件名.csv&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_filename_with_special_chars(all_parsers</span><span class="s2">, </span><span class="s1">filename):</span>
    <span class="s4"># see gh-15086.</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">df = DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]})</span>

    <span class="s2">with </span><span class="s1">tm.ensure_clean(filename) </span><span class="s2">as </span><span class="s1">path:</span>
        <span class="s1">df.to_csv(path</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">result = parser.read_csv(path)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">df)</span>


<span class="s2">def </span><span class="s1">test_read_table_same_signature_as_read_csv(all_parsers):</span>
    <span class="s4"># GH-34976</span>
    <span class="s1">parser = all_parsers</span>

    <span class="s1">table_sign = signature(parser.read_table)</span>
    <span class="s1">csv_sign = signature(parser.read_csv)</span>

    <span class="s2">assert </span><span class="s1">table_sign.parameters.keys() == csv_sign.parameters.keys()</span>
    <span class="s2">assert </span><span class="s1">table_sign.return_annotation == csv_sign.return_annotation</span>

    <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">csv_param </span><span class="s2">in </span><span class="s1">csv_sign.parameters.items():</span>
        <span class="s1">table_param = table_sign.parameters[key]</span>
        <span class="s2">if </span><span class="s1">key == </span><span class="s3">&quot;sep&quot;</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">csv_param.default == </span><span class="s3">&quot;,&quot;</span>
            <span class="s2">assert </span><span class="s1">table_param.default == </span><span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">&quot;</span>
            <span class="s2">assert </span><span class="s1">table_param.annotation == csv_param.annotation</span>
            <span class="s2">assert </span><span class="s1">table_param.kind == csv_param.kind</span>
            <span class="s2">continue</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">table_param == csv_param</span>


<span class="s2">def </span><span class="s1">test_read_table_equivalency_to_read_csv(all_parsers):</span>
    <span class="s4"># see gh-21948</span>
    <span class="s4"># As of 0.25.0, read_table is undeprecated</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">data = </span><span class="s3">&quot;a</span><span class="s2">\t</span><span class="s3">b</span><span class="s2">\n</span><span class="s3">1</span><span class="s2">\t</span><span class="s3">2</span><span class="s2">\n</span><span class="s3">3</span><span class="s2">\t</span><span class="s3">4&quot;</span>
    <span class="s1">expected = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">sep=</span><span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">result = parser.read_table(StringIO(data))</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.skipif(</span>
    <span class="s1">PY310</span><span class="s2">,</span>
    <span class="s1">reason=</span><span class="s3">&quot;GH41935 This test is leaking only on Python 3.10,&quot;</span>
    <span class="s3">&quot;causing other tests to fail with a cryptic error.&quot;</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;read_func&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;read_csv&quot;</span><span class="s2">, </span><span class="s3">&quot;read_table&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_read_csv_and_table_sys_setprofile(all_parsers</span><span class="s2">, </span><span class="s1">read_func):</span>
    <span class="s4"># GH#41069</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">data = </span><span class="s3">&quot;a b</span><span class="s2">\n</span><span class="s3">0 1&quot;</span>

    <span class="s1">sys.setprofile(</span><span class="s2">lambda </span><span class="s1">*a</span><span class="s2">, </span><span class="s1">**k: </span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">result = getattr(parser</span><span class="s2">, </span><span class="s1">read_func)(StringIO(data))</span>
    <span class="s1">sys.setprofile(</span><span class="s2">None</span><span class="s1">)</span>

    <span class="s1">expected = DataFrame({</span><span class="s3">&quot;a b&quot;</span><span class="s1">: [</span><span class="s3">&quot;0 1&quot;</span><span class="s1">]})</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s2">def </span><span class="s1">test_first_row_bom(all_parsers):</span>
    <span class="s4"># see gh-26545</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">data = </span><span class="s3">'''</span><span class="s2">\ufeff</span><span class="s3">&quot;Head1&quot;   &quot;Head2&quot; &quot;Head3&quot;'''</span>

    <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(columns=[</span><span class="s3">&quot;Head1&quot;</span><span class="s2">, </span><span class="s3">&quot;Head2&quot;</span><span class="s2">, </span><span class="s3">&quot;Head3&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s2">def </span><span class="s1">test_first_row_bom_unquoted(all_parsers):</span>
    <span class="s4"># see gh-36343</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ufeff</span><span class="s3">Head1 Head2   Head3&quot;&quot;&quot;</span>

    <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame(columns=[</span><span class="s3">&quot;Head1&quot;</span><span class="s2">, </span><span class="s3">&quot;Head2&quot;</span><span class="s2">, </span><span class="s3">&quot;Head3&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;nrows&quot;</span><span class="s2">, </span><span class="s1">range(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">6</span><span class="s1">))</span>
<span class="s2">def </span><span class="s1">test_blank_lines_between_header_and_data_rows(all_parsers</span><span class="s2">, </span><span class="s1">nrows):</span>
    <span class="s4"># GH 28071</span>
    <span class="s1">ref = DataFrame(</span>
        <span class="s1">[[np.nan</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s1">[np.nan</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[np.nan</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">columns=list(</span><span class="s3">&quot;ab&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">csv = </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">header</span><span class="s2">\n\n</span><span class="s3">a,b</span><span class="s2">\n\n\n</span><span class="s3">1,2</span><span class="s2">\n\n</span><span class="s3">3,4&quot;</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">df = parser.read_csv(StringIO(csv)</span><span class="s2">, </span><span class="s1">header=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">nrows=nrows</span><span class="s2">, </span><span class="s1">skip_blank_lines=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(df</span><span class="s2">, </span><span class="s1">ref[:nrows])</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s2">def </span><span class="s1">test_no_header_two_extra_columns(all_parsers):</span>
    <span class="s4"># GH 26218</span>
    <span class="s1">column_names = [</span><span class="s3">&quot;one&quot;</span><span class="s2">, </span><span class="s3">&quot;two&quot;</span><span class="s2">, </span><span class="s3">&quot;three&quot;</span><span class="s1">]</span>
    <span class="s1">ref = DataFrame([[</span><span class="s3">&quot;foo&quot;</span><span class="s2">, </span><span class="s3">&quot;bar&quot;</span><span class="s2">, </span><span class="s3">&quot;baz&quot;</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">columns=column_names)</span>
    <span class="s1">stream = StringIO(</span><span class="s3">&quot;foo,bar,baz,bam,blah&quot;</span><span class="s1">)</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s2">with </span><span class="s1">tm.assert_produces_warning(ParserWarning):</span>
        <span class="s1">df = parser.read_csv(stream</span><span class="s2">, </span><span class="s1">header=</span><span class="s2">None, </span><span class="s1">names=column_names</span><span class="s2">, </span><span class="s1">index_col=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(df</span><span class="s2">, </span><span class="s1">ref)</span>


<span class="s2">def </span><span class="s1">test_read_csv_names_not_accepting_sets(all_parsers):</span>
    <span class="s4"># GH 34946</span>
    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
    </span><span class="s3">1,2,3 
    4,5,6</span><span class="s2">\n</span><span class="s3">&quot;&quot;&quot;</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Names should be an ordered collection.&quot;</span><span class="s1">):</span>
        <span class="s1">parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">names=set(</span><span class="s3">&quot;QAZ&quot;</span><span class="s1">))</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s2">def </span><span class="s1">test_read_table_delim_whitespace_default_sep(all_parsers):</span>
    <span class="s4"># GH: 35958</span>
    <span class="s1">f = StringIO(</span><span class="s3">&quot;a  b  c</span><span class="s2">\n</span><span class="s3">1 -2 -3</span><span class="s2">\n</span><span class="s3">4  5   6&quot;</span><span class="s1">)</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">result = parser.read_table(f</span><span class="s2">, </span><span class="s1">delim_whitespace=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">: [-</span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">: [-</span><span class="s5">3</span><span class="s2">, </span><span class="s5">6</span><span class="s1">]})</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;delimiter&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_read_csv_delim_whitespace_non_default_sep(all_parsers</span><span class="s2">, </span><span class="s1">delimiter):</span>
    <span class="s4"># GH: 35958</span>
    <span class="s1">f = StringIO(</span><span class="s3">&quot;a  b  c</span><span class="s2">\n</span><span class="s3">1 -2 -3</span><span class="s2">\n</span><span class="s3">4  5   6&quot;</span><span class="s1">)</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">msg = (</span>
        <span class="s3">&quot;Specified a delimiter with both sep and &quot;</span>
        <span class="s3">&quot;delim_whitespace=True; you can only specify one.&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">parser.read_csv(f</span><span class="s2">, </span><span class="s1">delim_whitespace=</span><span class="s2">True, </span><span class="s1">sep=delimiter)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">parser.read_csv(f</span><span class="s2">, </span><span class="s1">delim_whitespace=</span><span class="s2">True, </span><span class="s1">delimiter=delimiter)</span>


<span class="s2">def </span><span class="s1">test_read_csv_delimiter_and_sep_no_default(all_parsers):</span>
    <span class="s4"># GH#39823</span>
    <span class="s1">f = StringIO(</span><span class="s3">&quot;a,b</span><span class="s2">\n</span><span class="s3">1,2&quot;</span><span class="s1">)</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">msg = </span><span class="s3">&quot;Specified a sep and a delimiter; you can only specify one.&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">parser.read_csv(f</span><span class="s2">, </span><span class="s1">sep=</span><span class="s3">&quot; &quot;</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;.&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;kwargs&quot;</span><span class="s2">, </span><span class="s1">[{</span><span class="s3">&quot;delimiter&quot;</span><span class="s1">: </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">}</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;sep&quot;</span><span class="s1">: </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">}])</span>
<span class="s2">def </span><span class="s1">test_read_csv_line_break_as_separator(kwargs</span><span class="s2">, </span><span class="s1">all_parsers):</span>
    <span class="s4"># GH#43528</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">data = </span><span class="s3">&quot;&quot;&quot;a,b,c 
1,2,3 
    &quot;&quot;&quot;</span>
    <span class="s1">msg = (</span>
        <span class="s3">r&quot;Specified \\n as separator or delimiter. This forces the python engine &quot;</span>
        <span class="s3">r&quot;which does not accept a line terminator. Hence it is not allowed to use &quot;</span>
        <span class="s3">r&quot;the line terminator as separator.&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">def </span><span class="s1">test_read_csv_posargs_deprecation(all_parsers):</span>
    <span class="s4"># GH 41485</span>
    <span class="s1">f = StringIO(</span><span class="s3">&quot;a,b</span><span class="s2">\n</span><span class="s3">1,2&quot;</span><span class="s1">)</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">msg = (</span>
        <span class="s3">&quot;In a future version of pandas all arguments of read_csv &quot;</span>
        <span class="s3">&quot;except for the argument 'filepath_or_buffer' will be keyword-only&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">parser.read_csv(f</span><span class="s2">, </span><span class="s3">&quot; &quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;delimiter&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_read_table_delim_whitespace_non_default_sep(all_parsers</span><span class="s2">, </span><span class="s1">delimiter):</span>
    <span class="s4"># GH: 35958</span>
    <span class="s1">f = StringIO(</span><span class="s3">&quot;a  b  c</span><span class="s2">\n</span><span class="s3">1 -2 -3</span><span class="s2">\n</span><span class="s3">4  5   6&quot;</span><span class="s1">)</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">msg = (</span>
        <span class="s3">&quot;Specified a delimiter with both sep and &quot;</span>
        <span class="s3">&quot;delim_whitespace=True; you can only specify one.&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">parser.read_table(f</span><span class="s2">, </span><span class="s1">delim_whitespace=</span><span class="s2">True, </span><span class="s1">sep=delimiter)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">parser.read_table(f</span><span class="s2">, </span><span class="s1">delim_whitespace=</span><span class="s2">True, </span><span class="s1">delimiter=delimiter)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;func&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;read_csv&quot;</span><span class="s2">, </span><span class="s3">&quot;read_table&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_names_and_prefix_not_None_raises(all_parsers</span><span class="s2">, </span><span class="s1">func):</span>
    <span class="s4"># GH#39123</span>
    <span class="s1">f = StringIO(</span><span class="s3">&quot;a,b</span><span class="s2">\n</span><span class="s3">1,2&quot;</span><span class="s1">)</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">msg = </span><span class="s3">&quot;Specified named and prefix; you can only specify one.&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
            <span class="s1">getattr(parser</span><span class="s2">, </span><span class="s1">func)(f</span><span class="s2">, </span><span class="s1">names=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prefix=</span><span class="s3">&quot;x&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;func&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;read_csv&quot;</span><span class="s2">, </span><span class="s3">&quot;read_table&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;prefix, names&quot;</span><span class="s2">, </span><span class="s1">[(</span><span class="s2">None, </span><span class="s1">[</span><span class="s3">&quot;x0&quot;</span><span class="s2">, </span><span class="s3">&quot;x1&quot;</span><span class="s1">])</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;x&quot;</span><span class="s2">, None</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_names_and_prefix_explicit_None(all_parsers</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">func):</span>
    <span class="s4"># GH42387</span>
    <span class="s1">f = StringIO(</span><span class="s3">&quot;a,b</span><span class="s2">\n</span><span class="s3">1,2&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame({</span><span class="s3">&quot;x0&quot;</span><span class="s1">: [</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;x1&quot;</span><span class="s1">: [</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;2&quot;</span><span class="s1">]})</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s2">if </span><span class="s1">prefix </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">check_stacklevel=</span><span class="s2">False</span><span class="s1">):</span>
            <span class="s1">result = getattr(parser</span><span class="s2">, </span><span class="s1">func)(</span>
                <span class="s1">f</span><span class="s2">, </span><span class="s1">names=names</span><span class="s2">, </span><span class="s1">sep=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">prefix=prefix</span><span class="s2">, </span><span class="s1">header=</span><span class="s2">None</span>
            <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">result = getattr(parser</span><span class="s2">, </span><span class="s1">func)(</span>
            <span class="s1">f</span><span class="s2">, </span><span class="s1">names=names</span><span class="s2">, </span><span class="s1">sep=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">prefix=prefix</span><span class="s2">, </span><span class="s1">header=</span><span class="s2">None</span>
        <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s2">def </span><span class="s1">test_dict_keys_as_names(all_parsers):</span>
    <span class="s4"># GH: 36928</span>
    <span class="s1">data = </span><span class="s3">&quot;1,2&quot;</span>

    <span class="s1">keys = {</span><span class="s3">&quot;a&quot;</span><span class="s1">: int</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">: int}.keys()</span>
    <span class="s1">parser = all_parsers</span>

    <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">names=keys)</span>
    <span class="s1">expected = DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s1">]})</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s2">def </span><span class="s1">test_encoding_surrogatepass(all_parsers):</span>
    <span class="s4"># GH39017</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">content = </span><span class="s6">b&quot;</span><span class="s2">\xed\xbd\xbf</span><span class="s6">&quot;</span>
    <span class="s1">decoded = content.decode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;surrogatepass&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame({decoded: [decoded]}</span><span class="s2">, </span><span class="s1">index=[decoded * </span><span class="s5">2</span><span class="s1">])</span>
    <span class="s1">expected.index.name = decoded * </span><span class="s5">2</span>

    <span class="s2">with </span><span class="s1">tm.ensure_clean() </span><span class="s2">as </span><span class="s1">path:</span>
        <span class="s1">Path(path).write_bytes(</span>
            <span class="s1">content * </span><span class="s5">2 </span><span class="s1">+ </span><span class="s6">b&quot;,&quot; </span><span class="s1">+ content + </span><span class="s6">b&quot;</span><span class="s2">\n</span><span class="s6">&quot; </span><span class="s1">+ content * </span><span class="s5">2 </span><span class="s1">+ </span><span class="s6">b&quot;,&quot; </span><span class="s1">+ content</span>
        <span class="s1">)</span>
        <span class="s1">df = parser.read_csv(path</span><span class="s2">, </span><span class="s1">encoding_errors=</span><span class="s3">&quot;surrogatepass&quot;</span><span class="s2">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(UnicodeDecodeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;'utf-8' codec can't decode byte&quot;</span><span class="s1">):</span>
            <span class="s1">parser.read_csv(path)</span>


<span class="s1">@xfail_pyarrow</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;on_bad_lines&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;error&quot;</span><span class="s2">, </span><span class="s3">&quot;warn&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_deprecated_bad_lines_warns(all_parsers</span><span class="s2">, </span><span class="s1">csv1</span><span class="s2">, </span><span class="s1">on_bad_lines):</span>
    <span class="s4"># GH 15122</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">kwds = {</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">on_bad_lines</span><span class="s2">}</span><span class="s3">_bad_lines&quot;</span><span class="s1">: </span><span class="s2">False</span><span class="s1">}</span>
    <span class="s1">parser.read_csv_check_warnings(</span>
        <span class="s1">FutureWarning</span><span class="s2">,</span>
        <span class="s3">f&quot;The </span><span class="s2">{</span><span class="s1">on_bad_lines</span><span class="s2">}</span><span class="s3">_bad_lines argument has been deprecated &quot;</span>
        <span class="s3">&quot;and will be removed in a future version. &quot;</span>
        <span class="s3">&quot;Use on_bad_lines in the future.</span><span class="s2">\n\n</span><span class="s3">&quot;</span><span class="s2">,</span>
        <span class="s1">csv1</span><span class="s2">,</span>
        <span class="s1">**kwds</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_malformed_second_line(all_parsers):</span>
    <span class="s4"># see GH14782</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">data = </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">a</span><span class="s2">\n</span><span class="s3">b</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">result = parser.read_csv(StringIO(data)</span><span class="s2">, </span><span class="s1">skip_blank_lines=</span><span class="s2">False, </span><span class="s1">header=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">expected = DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">&quot;b&quot;</span><span class="s1">]})</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_read_table_posargs_deprecation(all_parsers):</span>
    <span class="s4"># https://github.com/pandas-dev/pandas/issues/41485</span>
    <span class="s1">data = StringIO(</span><span class="s3">&quot;a</span><span class="s2">\t</span><span class="s3">b</span><span class="s2">\n</span><span class="s3">1</span><span class="s2">\t</span><span class="s3">2&quot;</span><span class="s1">)</span>
    <span class="s1">parser = all_parsers</span>
    <span class="s1">msg = (</span>
        <span class="s3">&quot;In a future version of pandas all arguments of read_table &quot;</span>
        <span class="s3">&quot;except for the argument 'filepath_or_buffer' will be keyword-only&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">parser.read_table(data</span><span class="s2">, </span><span class="s3">&quot; &quot;</span><span class="s1">)</span>
</pre>
</body>
</html>