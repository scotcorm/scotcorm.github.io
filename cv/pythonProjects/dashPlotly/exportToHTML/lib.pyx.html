<html>
<head>
<title>lib.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
lib.pyx</font>
</center></td></tr></table>
<pre><span class="s0">from collections import abc</span>
<span class="s0">from decimal import Decimal</span>
<span class="s0">from enum import Enum</span>
<span class="s0">import warnings</span>

<span class="s0">import cython</span>
<span class="s0">from cython import Py_ssize_t</span>

<span class="s0">from cpython.datetime cimport (</span>
    <span class="s0">PyDate_Check,</span>
    <span class="s0">PyDateTime_Check,</span>
    <span class="s0">PyDateTime_IMPORT,</span>
    <span class="s0">PyDelta_Check,</span>
    <span class="s0">PyTime_Check,</span>
<span class="s0">)</span>
<span class="s0">from cpython.iterator cimport PyIter_Check</span>
<span class="s0">from cpython.number cimport PyNumber_Check</span>
<span class="s0">from cpython.object cimport (</span>
    <span class="s0">Py_EQ,</span>
    <span class="s0">PyObject_RichCompareBool,</span>
<span class="s0">)</span>
<span class="s0">from cpython.ref cimport Py_INCREF</span>
<span class="s0">from cpython.sequence cimport PySequence_Check</span>
<span class="s0">from cpython.tuple cimport (</span>
    <span class="s0">PyTuple_New,</span>
    <span class="s0">PyTuple_SET_ITEM,</span>
<span class="s0">)</span>
<span class="s0">from cython cimport floating</span>

<span class="s0">PyDateTime_IMPORT</span>

<span class="s0">import numpy as np</span>

<span class="s0">cimport numpy as cnp</span>
<span class="s0">from numpy cimport (</span>
    <span class="s0">NPY_OBJECT,</span>
    <span class="s0">PyArray_Check,</span>
    <span class="s0">PyArray_GETITEM,</span>
    <span class="s0">PyArray_ITER_DATA,</span>
    <span class="s0">PyArray_ITER_NEXT,</span>
    <span class="s0">PyArray_IterNew,</span>
    <span class="s0">complex128_t,</span>
    <span class="s0">flatiter,</span>
    <span class="s0">float32_t,</span>
    <span class="s0">float64_t,</span>
    <span class="s0">int64_t,</span>
    <span class="s0">intp_t,</span>
    <span class="s0">ndarray,</span>
    <span class="s0">uint8_t,</span>
    <span class="s0">uint64_t,</span>
<span class="s0">)</span>

<span class="s0">cnp.import_array()</span>

<span class="s0">cdef extern from &quot;numpy/arrayobject.h&quot;:</span>
    <span class="s0"># cython's numpy.dtype specification is incorrect, which leads to</span>
    <span class="s0"># errors in issubclass(self.dtype.type, np.bool_), so we directly</span>
    <span class="s0"># include the correct version</span>
    <span class="s0"># https://github.com/cython/cython/issues/2022</span>

    <span class="s0">ctypedef class numpy.dtype [object PyArray_Descr]:</span>
        <span class="s0"># Use PyDataType_* macros when possible, however there are no macros</span>
        <span class="s0"># for accessing some of the fields, so some are defined. Please</span>
        <span class="s0"># ask on cython-dev if you need more.</span>
        <span class="s0">cdef:</span>
            <span class="s0">int type_num</span>
            <span class="s0">int itemsize &quot;elsize&quot;</span>
            <span class="s0">char byteorder</span>
            <span class="s0">object fields</span>
            <span class="s0">tuple names</span>

<span class="s0">cdef extern from &quot;numpy/ndarrayobject.h&quot;:</span>
    <span class="s0">bint PyArray_CheckScalar(obj) nogil</span>


<span class="s0">cdef extern from &quot;src/parse_helper.h&quot;:</span>
    <span class="s0">int floatify(object, float64_t *result, int *maybe_int) except -1</span>

<span class="s0">from pandas._libs cimport util</span>
<span class="s0">from pandas._libs.util cimport (</span>
    <span class="s0">INT64_MAX,</span>
    <span class="s0">INT64_MIN,</span>
    <span class="s0">UINT64_MAX,</span>
    <span class="s0">is_nan,</span>
<span class="s0">)</span>

<span class="s0">from pandas._libs.tslib import array_to_datetime</span>
<span class="s0">from pandas._libs.tslibs import (</span>
    <span class="s0">OutOfBoundsDatetime,</span>
    <span class="s0">OutOfBoundsTimedelta,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.period import Period</span>

<span class="s0">from pandas._libs.missing cimport (</span>
    <span class="s0">C_NA,</span>
    <span class="s0">checknull,</span>
    <span class="s0">is_matching_na,</span>
    <span class="s0">is_null_datetime64,</span>
    <span class="s0">is_null_timedelta64,</span>
    <span class="s0">isnaobj,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.conversion cimport convert_to_tsobject</span>
<span class="s0">from pandas._libs.tslibs.nattype cimport (</span>
    <span class="s0">NPY_NAT,</span>
    <span class="s0">c_NaT as NaT,</span>
    <span class="s0">checknull_with_nat,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.offsets cimport is_offset_object</span>
<span class="s0">from pandas._libs.tslibs.period cimport is_period_object</span>
<span class="s0">from pandas._libs.tslibs.timedeltas cimport convert_to_timedelta64</span>
<span class="s0">from pandas._libs.tslibs.timezones cimport tz_compare</span>

<span class="s0"># constants that will be compared to potentially arbitrarily large</span>
<span class="s0"># python int</span>
<span class="s0">cdef:</span>
    <span class="s0">object oINT64_MAX = &lt;int64_t&gt;INT64_MAX</span>
    <span class="s0">object oINT64_MIN = &lt;int64_t&gt;INT64_MIN</span>
    <span class="s0">object oUINT64_MAX = &lt;uint64_t&gt;UINT64_MAX</span>

    <span class="s0">float64_t NaN = &lt;float64_t&gt;np.NaN</span>

<span class="s0"># python-visible</span>
<span class="s0">i8max = &lt;int64_t&gt;INT64_MAX</span>
<span class="s0">u8max = &lt;uint64_t&gt;UINT64_MAX</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def memory_usage_of_objects(arr: object[:]) -&gt; int64_t:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Return the memory usage of an object array in bytes.</span>

    <span class="s0">Does not include the actual bytes of the pointers</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">i: Py_ssize_t</span>
    <span class="s0">n: Py_ssize_t</span>
    <span class="s0">size: int64_t</span>

    <span class="s0">size = 0</span>
    <span class="s0">n = len(arr)</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">size += arr[i].__sizeof__()</span>
    <span class="s0">return size</span>


<span class="s0"># ----------------------------------------------------------------------</span>


<span class="s0">def is_scalar(val: object) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Return True if given object is scalar.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">val : object</span>
        <span class="s0">This includes:</span>

        <span class="s0">- numpy array scalar (e.g. np.int64)</span>
        <span class="s0">- Python builtin numerics</span>
        <span class="s0">- Python builtin byte arrays and strings</span>
        <span class="s0">- None</span>
        <span class="s0">- datetime.datetime</span>
        <span class="s0">- datetime.timedelta</span>
        <span class="s0">- Period</span>
        <span class="s0">- decimal.Decimal</span>
        <span class="s0">- Interval</span>
        <span class="s0">- DateOffset</span>
        <span class="s0">- Fraction</span>
        <span class="s0">- Number.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">bool</span>
        <span class="s0">Return True if given object is scalar.</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">&gt;&gt;&gt; import datetime</span>
    <span class="s0">&gt;&gt;&gt; dt = datetime.datetime(2018, 10, 3)</span>
    <span class="s0">&gt;&gt;&gt; pd.api.types.is_scalar(dt)</span>
    <span class="s0">True</span>

    <span class="s0">&gt;&gt;&gt; pd.api.types.is_scalar([2, 3])</span>
    <span class="s0">False</span>

    <span class="s0">&gt;&gt;&gt; pd.api.types.is_scalar({0: 1, 2: 3})</span>
    <span class="s0">False</span>

    <span class="s0">&gt;&gt;&gt; pd.api.types.is_scalar((0, 2))</span>
    <span class="s0">False</span>

    <span class="s0">pandas supports PEP 3141 numbers:</span>

    <span class="s0">&gt;&gt;&gt; from fractions import Fraction</span>
    <span class="s0">&gt;&gt;&gt; pd.api.types.is_scalar(Fraction(3, 5))</span>
    <span class="s0">True</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0"># Start with C-optimized checks</span>
    <span class="s0">if (cnp.PyArray_IsAnyScalar(val)</span>
            <span class="s0"># PyArray_IsAnyScalar is always False for bytearrays on Py3</span>
            <span class="s0">or PyDate_Check(val)</span>
            <span class="s0">or PyDelta_Check(val)</span>
            <span class="s0">or PyTime_Check(val)</span>
            <span class="s0"># We differ from numpy, which claims that None is not scalar;</span>
            <span class="s0"># see np.isscalar</span>
            <span class="s0">or val is C_NA</span>
            <span class="s0">or val is None):</span>
        <span class="s0">return True</span>

    <span class="s0"># Next use C-optimized checks to exclude common non-scalars before falling</span>
    <span class="s0">#  back to non-optimized checks.</span>
    <span class="s0">if PySequence_Check(val):</span>
        <span class="s0"># e.g. list, tuple</span>
        <span class="s0"># includes np.ndarray, Series which PyNumber_Check can return True for</span>
        <span class="s0">return False</span>

    <span class="s0"># Note: PyNumber_Check check includes Decimal, Fraction, numbers.Number</span>
    <span class="s0">return (PyNumber_Check(val)</span>
            <span class="s0">or is_period_object(val)</span>
            <span class="s0">or is_interval(val)</span>
            <span class="s0">or is_offset_object(val))</span>


<span class="s0">cdef inline int64_t get_itemsize(object val):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Get the itemsize of a NumPy scalar, -1 if not a NumPy scalar.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">val : object</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">is_ndarray : bool</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if PyArray_CheckScalar(val):</span>
        <span class="s0">return cnp.PyArray_DescrFromScalar(val).itemsize</span>
    <span class="s0">else:</span>
        <span class="s0">return -1</span>


<span class="s0">def is_iterator(obj: object) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Check if the object is an iterator.</span>

    <span class="s0">This is intended for generators, not list-like objects.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">obj : The object to check</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">is_iter : bool</span>
        <span class="s0">Whether `obj` is an iterator.</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">&gt;&gt;&gt; import datetime</span>
    <span class="s0">&gt;&gt;&gt; is_iterator((x for x in []))</span>
    <span class="s0">True</span>
    <span class="s0">&gt;&gt;&gt; is_iterator([1, 2, 3])</span>
    <span class="s0">False</span>
    <span class="s0">&gt;&gt;&gt; is_iterator(datetime.datetime(2017, 1, 1))</span>
    <span class="s0">False</span>
    <span class="s0">&gt;&gt;&gt; is_iterator(&quot;foo&quot;)</span>
    <span class="s0">False</span>
    <span class="s0">&gt;&gt;&gt; is_iterator(1)</span>
    <span class="s0">False</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">return PyIter_Check(obj)</span>


<span class="s0">def item_from_zerodim(val: object) -&gt; object:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">If the value is a zerodim array, return the item it contains.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">val : object</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">object</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">&gt;&gt;&gt; item_from_zerodim(1)</span>
    <span class="s0">1</span>
    <span class="s0">&gt;&gt;&gt; item_from_zerodim('foobar')</span>
    <span class="s0">'foobar'</span>
    <span class="s0">&gt;&gt;&gt; item_from_zerodim(np.array(1))</span>
    <span class="s0">1</span>
    <span class="s0">&gt;&gt;&gt; item_from_zerodim(np.array([1]))</span>
    <span class="s0">array([1])</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if cnp.PyArray_IsZeroDim(val):</span>
        <span class="s0">return cnp.PyArray_ToScalar(cnp.PyArray_DATA(val), val)</span>
    <span class="s0">return val</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def fast_unique_multiple(list arrays, sort: bool = True):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Generate a list of unique values from a list of arrays.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">list : array-like</span>
        <span class="s0">List of array-like objects.</span>
    <span class="s0">sort : bool</span>
        <span class="s0">Whether or not to sort the resulting unique list.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">list of unique values</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">ndarray[object] buf</span>
        <span class="s0">Py_ssize_t k = len(arrays)</span>
        <span class="s0">Py_ssize_t i, j, n</span>
        <span class="s0">list uniques = []</span>
        <span class="s0">dict table = {}</span>
        <span class="s0">object val, stub = 0</span>

    <span class="s0">for i in range(k):</span>
        <span class="s0">buf = arrays[i]</span>
        <span class="s0">n = len(buf)</span>
        <span class="s0">for j in range(n):</span>
            <span class="s0">val = buf[j]</span>
            <span class="s0">if val not in table:</span>
                <span class="s0">table[val] = stub</span>
                <span class="s0">uniques.append(val)</span>

    <span class="s0">if sort is None:</span>
        <span class="s0">try:</span>
            <span class="s0">uniques.sort()</span>
        <span class="s0">except TypeError:</span>
            <span class="s0">warnings.warn(</span>
                <span class="s0">&quot;The values in the array are unorderable. &quot;</span>
                <span class="s0">&quot;Pass `sort=False` to suppress this warning.&quot;,</span>
                <span class="s0">RuntimeWarning,</span>
            <span class="s0">)</span>
            <span class="s0">pass</span>

    <span class="s0">return uniques</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def fast_unique_multiple_list(lists: list, sort: bool | None = True) -&gt; list:</span>
    <span class="s0">cdef:</span>
        <span class="s0">list buf</span>
        <span class="s0">Py_ssize_t k = len(lists)</span>
        <span class="s0">Py_ssize_t i, j, n</span>
        <span class="s0">list uniques = []</span>
        <span class="s0">dict table = {}</span>
        <span class="s0">object val, stub = 0</span>

    <span class="s0">for i in range(k):</span>
        <span class="s0">buf = lists[i]</span>
        <span class="s0">n = len(buf)</span>
        <span class="s0">for j in range(n):</span>
            <span class="s0">val = buf[j]</span>
            <span class="s0">if val not in table:</span>
                <span class="s0">table[val] = stub</span>
                <span class="s0">uniques.append(val)</span>
    <span class="s0">if sort:</span>
        <span class="s0">try:</span>
            <span class="s0">uniques.sort()</span>
        <span class="s0">except TypeError:</span>
            <span class="s0">pass</span>

    <span class="s0">return uniques</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def fast_unique_multiple_list_gen(object gen, bint sort=True) -&gt; list:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Generate a list of unique values from a generator of lists.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">gen : generator object</span>
        <span class="s0">Generator of lists from which the unique list is created.</span>
    <span class="s0">sort : bool</span>
        <span class="s0">Whether or not to sort the resulting unique list.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">list of unique values</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">list buf</span>
        <span class="s0">Py_ssize_t j, n</span>
        <span class="s0">list uniques = []</span>
        <span class="s0">dict table = {}</span>
        <span class="s0">object val, stub = 0</span>

    <span class="s0">for buf in gen:</span>
        <span class="s0">n = len(buf)</span>
        <span class="s0">for j in range(n):</span>
            <span class="s0">val = buf[j]</span>
            <span class="s0">if val not in table:</span>
                <span class="s0">table[val] = stub</span>
                <span class="s0">uniques.append(val)</span>
    <span class="s0">if sort:</span>
        <span class="s0">try:</span>
            <span class="s0">uniques.sort()</span>
        <span class="s0">except TypeError:</span>
            <span class="s0">pass</span>

    <span class="s0">return uniques</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def dicts_to_array(dicts: list, columns: list):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, k, n</span>
        <span class="s0">ndarray[object, ndim=2] result</span>
        <span class="s0">dict row</span>
        <span class="s0">object col, onan = np.nan</span>

    <span class="s0">k = len(columns)</span>
    <span class="s0">n = len(dicts)</span>

    <span class="s0">result = np.empty((n, k), dtype='O')</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">row = dicts[i]</span>
        <span class="s0">for j in range(k):</span>
            <span class="s0">col = columns[j]</span>
            <span class="s0">if col in row:</span>
                <span class="s0">result[i, j] = row[col]</span>
            <span class="s0">else:</span>
                <span class="s0">result[i, j] = onan</span>

    <span class="s0">return result</span>


<span class="s0">def fast_zip(list ndarrays) -&gt; ndarray[object]:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">For zipping multiple ndarrays into an ndarray of tuples.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, k, n</span>
        <span class="s0">ndarray[object, ndim=1] result</span>
        <span class="s0">flatiter it</span>
        <span class="s0">object val, tup</span>

    <span class="s0">k = len(ndarrays)</span>
    <span class="s0">n = len(ndarrays[0])</span>

    <span class="s0">result = np.empty(n, dtype=object)</span>

    <span class="s0"># initialize tuples on first pass</span>
    <span class="s0">arr = ndarrays[0]</span>
    <span class="s0">it = &lt;flatiter&gt;PyArray_IterNew(arr)</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">val = PyArray_GETITEM(arr, PyArray_ITER_DATA(it))</span>
        <span class="s0">tup = PyTuple_New(k)</span>

        <span class="s0">PyTuple_SET_ITEM(tup, 0, val)</span>
        <span class="s0">Py_INCREF(val)</span>
        <span class="s0">result[i] = tup</span>
        <span class="s0">PyArray_ITER_NEXT(it)</span>

    <span class="s0">for j in range(1, k):</span>
        <span class="s0">arr = ndarrays[j]</span>
        <span class="s0">it = &lt;flatiter&gt;PyArray_IterNew(arr)</span>
        <span class="s0">if len(arr) != n:</span>
            <span class="s0">raise ValueError(&quot;all arrays must be same length&quot;)</span>

        <span class="s0">for i in range(n):</span>
            <span class="s0">val = PyArray_GETITEM(arr, PyArray_ITER_DATA(it))</span>
            <span class="s0">PyTuple_SET_ITEM(result[i], j, val)</span>
            <span class="s0">Py_INCREF(val)</span>
            <span class="s0">PyArray_ITER_NEXT(it)</span>

    <span class="s0">return result</span>


<span class="s0">def get_reverse_indexer(const intp_t[:] indexer, Py_ssize_t length) -&gt; ndarray:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Reverse indexing operation.</span>

    <span class="s0">Given `indexer`, make `indexer_inv` of it, such that::</span>

        <span class="s0">indexer_inv[indexer[x]] = x</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">indexer : np.ndarray[np.intp]</span>
    <span class="s0">length : int</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">np.ndarray[np.intp]</span>

    <span class="s0">Notes</span>
    <span class="s0">-----</span>
    <span class="s0">If indexer is not unique, only first occurrence is accounted.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(indexer)</span>
        <span class="s0">ndarray[intp_t, ndim=1] rev_indexer</span>
        <span class="s0">intp_t idx</span>

    <span class="s0">rev_indexer = np.empty(length, dtype=np.intp)</span>
    <span class="s0">rev_indexer[:] = -1</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">idx = indexer[i]</span>
        <span class="s0">if idx != -1:</span>
            <span class="s0">rev_indexer[idx] = i</span>

    <span class="s0">return rev_indexer</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0"># Can add const once https://github.com/cython/cython/issues/1772 resolved</span>
<span class="s0">def has_infs(floating[:] arr) -&gt; bool:</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(arr)</span>
        <span class="s0">floating inf, neginf, val</span>
        <span class="s0">bint ret = False</span>

    <span class="s0">inf = np.inf</span>
    <span class="s0">neginf = -inf</span>
    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">val = arr[i]</span>
            <span class="s0">if val == inf or val == neginf:</span>
                <span class="s0">ret = True</span>
                <span class="s0">break</span>
    <span class="s0">return ret</span>


<span class="s0">def maybe_indices_to_slice(ndarray[intp_t, ndim=1] indices, int max_len):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(indices)</span>
        <span class="s0">intp_t k, vstart, vlast, v</span>

    <span class="s0">if n == 0:</span>
        <span class="s0">return slice(0, 0)</span>

    <span class="s0">vstart = indices[0]</span>
    <span class="s0">if vstart &lt; 0 or max_len &lt;= vstart:</span>
        <span class="s0">return indices</span>

    <span class="s0">if n == 1:</span>
        <span class="s0">return slice(vstart, &lt;intp_t&gt;(vstart + 1))</span>

    <span class="s0">vlast = indices[n - 1]</span>
    <span class="s0">if vlast &lt; 0 or max_len &lt;= vlast:</span>
        <span class="s0">return indices</span>

    <span class="s0">k = indices[1] - indices[0]</span>
    <span class="s0">if k == 0:</span>
        <span class="s0">return indices</span>
    <span class="s0">else:</span>
        <span class="s0">for i in range(2, n):</span>
            <span class="s0">v = indices[i]</span>
            <span class="s0">if v - indices[i - 1] != k:</span>
                <span class="s0">return indices</span>

        <span class="s0">if k &gt; 0:</span>
            <span class="s0">return slice(vstart, &lt;intp_t&gt;(vlast + 1), k)</span>
        <span class="s0">else:</span>
            <span class="s0">if vlast == 0:</span>
                <span class="s0">return slice(vstart, None, k)</span>
            <span class="s0">else:</span>
                <span class="s0">return slice(vstart, &lt;intp_t&gt;(vlast - 1), k)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def maybe_booleans_to_slice(ndarray[uint8_t, ndim=1] mask):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(mask)</span>
        <span class="s0">Py_ssize_t start = 0, end = 0</span>
        <span class="s0">bint started = False, finished = False</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">if mask[i]:</span>
            <span class="s0">if finished:</span>
                <span class="s0">return mask.view(np.bool_)</span>
            <span class="s0">if not started:</span>
                <span class="s0">started = True</span>
                <span class="s0">start = i</span>
        <span class="s0">else:</span>
            <span class="s0">if finished:</span>
                <span class="s0">continue</span>

            <span class="s0">if started:</span>
                <span class="s0">end = i</span>
                <span class="s0">finished = True</span>

    <span class="s0">if not started:</span>
        <span class="s0">return slice(0, 0)</span>
    <span class="s0">if not finished:</span>
        <span class="s0">return slice(start, None)</span>
    <span class="s0">else:</span>
        <span class="s0">return slice(start, end)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def array_equivalent_object(left: object[:], right: object[:]) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Perform an element by element comparison on 1-d object arrays</span>
    <span class="s0">taking into account nan positions.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = left.shape[0]</span>
        <span class="s0">object x, y</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">x = left[i]</span>
        <span class="s0">y = right[i]</span>

        <span class="s0"># we are either not equal or both nan</span>
        <span class="s0"># I think None == None will be true here</span>
        <span class="s0">try:</span>
            <span class="s0">if PyArray_Check(x) and PyArray_Check(y):</span>
                <span class="s0">if not array_equivalent_object(x, y):</span>
                    <span class="s0">return False</span>
            <span class="s0">elif (x is C_NA) ^ (y is C_NA):</span>
                <span class="s0">return False</span>
            <span class="s0">elif not (</span>
                <span class="s0">PyObject_RichCompareBool(x, y, Py_EQ)</span>
                <span class="s0">or is_matching_na(x, y, nan_matches_none=True)</span>
            <span class="s0">):</span>
                <span class="s0">return False</span>
        <span class="s0">except ValueError:</span>
            <span class="s0"># Avoid raising ValueError when comparing Numpy arrays to other types</span>
            <span class="s0">if cnp.PyArray_IsAnyScalar(x) != cnp.PyArray_IsAnyScalar(y):</span>
                <span class="s0"># Only compare scalars to scalars and non-scalars to non-scalars</span>
                <span class="s0">return False</span>
            <span class="s0">elif (not (cnp.PyArray_IsPythonScalar(x) or cnp.PyArray_IsPythonScalar(y))</span>
                  <span class="s0">and not (isinstance(x, type(y)) or isinstance(y, type(x)))):</span>
                <span class="s0"># Check if non-scalars have the same type</span>
                <span class="s0">return False</span>
            <span class="s0">raise</span>
    <span class="s0">return True</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def astype_intsafe(ndarray[object] arr, cnp.dtype new_dtype) -&gt; ndarray:</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(arr)</span>
        <span class="s0">object val</span>
        <span class="s0">bint is_datelike</span>
        <span class="s0">ndarray result</span>

    <span class="s0">is_datelike = new_dtype == 'm8[ns]'</span>
    <span class="s0">result = np.empty(n, dtype=new_dtype)</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">val = arr[i]</span>
        <span class="s0">if is_datelike and checknull(val):</span>
            <span class="s0">result[i] = NPY_NAT</span>
        <span class="s0">else:</span>
            <span class="s0">result[i] = val</span>

    <span class="s0">return result</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">cpdef ndarray[object] ensure_string_array(</span>
        <span class="s0">arr,</span>
        <span class="s0">object na_value=np.nan,</span>
        <span class="s0">bint convert_na_value=True,</span>
        <span class="s0">bint copy=True,</span>
        <span class="s0">bint skipna=True,</span>
<span class="s0">):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Returns a new numpy array with object dtype and only strings and na values.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">arr : array-like</span>
        <span class="s0">The values to be converted to str, if needed.</span>
    <span class="s0">na_value : Any, default np.nan</span>
        <span class="s0">The value to use for na. For example, np.nan or pd.NA.</span>
    <span class="s0">convert_na_value : bool, default True</span>
        <span class="s0">If False, existing na values will be used unchanged in the new array.</span>
    <span class="s0">copy : bool, default True</span>
        <span class="s0">Whether to ensure that a new array is returned.</span>
    <span class="s0">skipna : bool, default True</span>
        <span class="s0">Whether or not to coerce nulls to their stringified form</span>
        <span class="s0">(e.g. if False, NaN becomes 'nan').</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">np.ndarray[object]</span>
        <span class="s0">An array with the input array's elements casted to str or nan-like.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i = 0, n = len(arr)</span>

    <span class="s0">if hasattr(arr, &quot;to_numpy&quot;):</span>

        <span class="s0">if hasattr(arr, &quot;dtype&quot;) and arr.dtype.kind in [&quot;m&quot;, &quot;M&quot;]:</span>
            <span class="s0"># dtype check to exclude DataFrame</span>
            <span class="s0"># GH#41409 TODO: not a great place for this</span>
            <span class="s0">out = arr.astype(str).astype(object)</span>
            <span class="s0">out[arr.isna()] = na_value</span>
            <span class="s0">return out</span>

        <span class="s0">arr = arr.to_numpy()</span>
    <span class="s0">elif not util.is_array(arr):</span>
        <span class="s0">arr = np.array(arr, dtype=&quot;object&quot;)</span>

    <span class="s0">result = np.asarray(arr, dtype=&quot;object&quot;)</span>

    <span class="s0">if copy and result is arr:</span>
        <span class="s0">result = result.copy()</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">val = arr[i]</span>

        <span class="s0">if isinstance(val, str):</span>
            <span class="s0">continue</span>

        <span class="s0">if not checknull(val):</span>
            <span class="s0">if not util.is_float_object(val):</span>
                <span class="s0"># f&quot;{val}&quot; is faster than str(val)</span>
                <span class="s0">result[i] = f&quot;{val}&quot;</span>
            <span class="s0">else:</span>
                <span class="s0"># f&quot;{val}&quot; is not always equivalent to str(val) for floats</span>
                <span class="s0">result[i] = str(val)</span>
        <span class="s0">else:</span>
            <span class="s0">if convert_na_value:</span>
                <span class="s0">val = na_value</span>
            <span class="s0">if skipna:</span>
                <span class="s0">result[i] = val</span>
            <span class="s0">else:</span>
                <span class="s0">result[i] = f&quot;{val}&quot;</span>

    <span class="s0">return result</span>


<span class="s0">def is_all_arraylike(obj: list) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Should we treat these as levels of a MultiIndex, as opposed to Index items?</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(obj)</span>
        <span class="s0">object val</span>
        <span class="s0">bint all_arrays = True</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">val = obj[i]</span>
        <span class="s0">if not (isinstance(val, list) or</span>
                <span class="s0">util.is_array(val) or hasattr(val, '_data')):</span>
            <span class="s0"># TODO: EA?</span>
            <span class="s0"># exclude tuples, frozensets as they may be contained in an Index</span>
            <span class="s0">all_arrays = False</span>
            <span class="s0">break</span>

    <span class="s0">return all_arrays</span>


<span class="s0"># ------------------------------------------------------------------------------</span>
<span class="s0"># Groupby-related functions</span>

<span class="s0"># TODO: could do even better if we know something about the data. eg, index has</span>
<span class="s0"># 1-min data, binner has 5-min data, then bins are just strides in index. This</span>
<span class="s0"># is a general, O(max(len(values), len(binner))) method.</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def generate_bins_dt64(ndarray[int64_t, ndim=1] values, const int64_t[:] binner,</span>
                       <span class="s0">object closed='left', bint hasnans=False):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Int64 (datetime64) version of generic python version in ``groupby.py``.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t lenidx, lenbin, i, j, bc, vc</span>
        <span class="s0">ndarray[int64_t, ndim=1] bins</span>
        <span class="s0">int64_t l_bin, r_bin, nat_count</span>
        <span class="s0">bint right_closed = closed == 'right'</span>

    <span class="s0">nat_count = 0</span>
    <span class="s0">if hasnans:</span>
        <span class="s0">mask = values == NPY_NAT</span>
        <span class="s0">nat_count = np.sum(mask)</span>
        <span class="s0">values = values[~mask]</span>

    <span class="s0">lenidx = len(values)</span>
    <span class="s0">lenbin = len(binner)</span>

    <span class="s0">if lenidx &lt;= 0 or lenbin &lt;= 0:</span>
        <span class="s0">raise ValueError(&quot;Invalid length for values or for binner&quot;)</span>

    <span class="s0"># check binner fits data</span>
    <span class="s0">if values[0] &lt; binner[0]:</span>
        <span class="s0">raise ValueError(&quot;Values falls before first bin&quot;)</span>

    <span class="s0">if values[lenidx - 1] &gt; binner[lenbin - 1]:</span>
        <span class="s0">raise ValueError(&quot;Values falls after last bin&quot;)</span>

    <span class="s0">bins = np.empty(lenbin - 1, dtype=np.int64)</span>

    <span class="s0">j = 0  # index into values</span>
    <span class="s0">bc = 0  # bin count</span>

    <span class="s0"># linear scan</span>
    <span class="s0">if right_closed:</span>
        <span class="s0">for i in range(0, lenbin - 1):</span>
            <span class="s0">r_bin = binner[i + 1]</span>
            <span class="s0"># count values in current bin, advance to next bin</span>
            <span class="s0">while j &lt; lenidx and values[j] &lt;= r_bin:</span>
                <span class="s0">j += 1</span>
            <span class="s0">bins[bc] = j</span>
            <span class="s0">bc += 1</span>
    <span class="s0">else:</span>
        <span class="s0">for i in range(0, lenbin - 1):</span>
            <span class="s0">r_bin = binner[i + 1]</span>
            <span class="s0"># count values in current bin, advance to next bin</span>
            <span class="s0">while j &lt; lenidx and values[j] &lt; r_bin:</span>
                <span class="s0">j += 1</span>
            <span class="s0">bins[bc] = j</span>
            <span class="s0">bc += 1</span>

    <span class="s0">if nat_count &gt; 0:</span>
        <span class="s0"># shift bins by the number of NaT</span>
        <span class="s0">bins = bins + nat_count</span>
        <span class="s0">bins = np.insert(bins, 0, nat_count)</span>

    <span class="s0">return bins</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def get_level_sorter(</span>
    <span class="s0">ndarray[int64_t, ndim=1] codes, const intp_t[:] starts</span>
<span class="s0">) -&gt; ndarray:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Argsort for a single level of a multi-index, keeping the order of higher</span>
    <span class="s0">levels unchanged. `starts` points to starts of same-key indices w.r.t</span>
    <span class="s0">to leading levels; equivalent to:</span>
        <span class="s0">np.hstack([codes[starts[i]:starts[i+1]].argsort(kind='mergesort')</span>
            <span class="s0">+ starts[i] for i in range(len(starts) - 1)])</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">codes : np.ndarray[int64_t, ndim=1]</span>
    <span class="s0">starts : np.ndarray[intp, ndim=1]</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">np.ndarray[np.int, ndim=1]</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, l, r</span>
        <span class="s0">ndarray[intp_t, ndim=1] out = np.empty(len(codes), dtype=np.intp)</span>

    <span class="s0">for i in range(len(starts) - 1):</span>
        <span class="s0">l, r = starts[i], starts[i + 1]</span>
        <span class="s0">out[l:r] = l + codes[l:r].argsort(kind='mergesort')</span>

    <span class="s0">return out</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def count_level_2d(ndarray[uint8_t, ndim=2, cast=True] mask,</span>
                   <span class="s0">const intp_t[:] labels,</span>
                   <span class="s0">Py_ssize_t max_bin,</span>
                   <span class="s0">int axis):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, k, n</span>
        <span class="s0">ndarray[int64_t, ndim=2] counts</span>

    <span class="s0">assert (axis == 0 or axis == 1)</span>
    <span class="s0">n, k = (&lt;object&gt;mask).shape</span>

    <span class="s0">if axis == 0:</span>
        <span class="s0">counts = np.zeros((max_bin, k), dtype='i8')</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(n):</span>
                <span class="s0">for j in range(k):</span>
                    <span class="s0">if mask[i, j]:</span>
                        <span class="s0">counts[labels[i], j] += 1</span>

    <span class="s0">else:  # axis == 1</span>
        <span class="s0">counts = np.zeros((n, max_bin), dtype='i8')</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(n):</span>
                <span class="s0">for j in range(k):</span>
                    <span class="s0">if mask[i, j]:</span>
                        <span class="s0">counts[i, labels[j]] += 1</span>

    <span class="s0">return counts</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def generate_slices(const intp_t[:] labels, Py_ssize_t ngroups):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, group_size, n, start</span>
        <span class="s0">intp_t lab</span>
        <span class="s0">int64_t[::1] starts, ends</span>

    <span class="s0">n = len(labels)</span>

    <span class="s0">starts = np.zeros(ngroups, dtype=np.int64)</span>
    <span class="s0">ends = np.zeros(ngroups, dtype=np.int64)</span>

    <span class="s0">start = 0</span>
    <span class="s0">group_size = 0</span>
    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">lab = labels[i]</span>
            <span class="s0">if lab &lt; 0:</span>
                <span class="s0">start += 1</span>
            <span class="s0">else:</span>
                <span class="s0">group_size += 1</span>
                <span class="s0">if i == n - 1 or lab != labels[i + 1]:</span>
                    <span class="s0">starts[lab] = start</span>
                    <span class="s0">ends[lab] = start + group_size</span>
                    <span class="s0">start += group_size</span>
                    <span class="s0">group_size = 0</span>

    <span class="s0">return np.asarray(starts), np.asarray(ends)</span>


<span class="s0">def indices_fast(ndarray[intp_t, ndim=1] index, const int64_t[:] labels, list keys,</span>
                 <span class="s0">list sorted_labels) -&gt; dict:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">index : ndarray[intp]</span>
    <span class="s0">labels : ndarray[int64]</span>
    <span class="s0">keys : list</span>
    <span class="s0">sorted_labels : list[ndarray[int64]]</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, k, lab, cur, start, n = len(labels)</span>
        <span class="s0">dict result = {}</span>
        <span class="s0">object tup</span>

    <span class="s0">k = len(keys)</span>

    <span class="s0"># Start at the first non-null entry</span>
    <span class="s0">j = 0</span>
    <span class="s0">for j in range(0, n):</span>
        <span class="s0">if labels[j] != -1:</span>
            <span class="s0">break</span>
    <span class="s0">else:</span>
        <span class="s0">return result</span>
    <span class="s0">cur = labels[j]</span>
    <span class="s0">start = j</span>

    <span class="s0">for i in range(j+1, n):</span>
        <span class="s0">lab = labels[i]</span>

        <span class="s0">if lab != cur:</span>
            <span class="s0">if lab != -1:</span>
                <span class="s0">if k == 1:</span>
                    <span class="s0"># When k = 1 we do not want to return a tuple as key</span>
                    <span class="s0">tup = keys[0][sorted_labels[0][i - 1]]</span>
                <span class="s0">else:</span>
                    <span class="s0">tup = PyTuple_New(k)</span>
                    <span class="s0">for j in range(k):</span>
                        <span class="s0">val = keys[j][sorted_labels[j][i - 1]]</span>
                        <span class="s0">PyTuple_SET_ITEM(tup, j, val)</span>
                        <span class="s0">Py_INCREF(val)</span>
                <span class="s0">result[tup] = index[start:i]</span>
            <span class="s0">start = i</span>
        <span class="s0">cur = lab</span>

    <span class="s0">if k == 1:</span>
        <span class="s0"># When k = 1 we do not want to return a tuple as key</span>
        <span class="s0">tup = keys[0][sorted_labels[0][n - 1]]</span>
    <span class="s0">else:</span>
        <span class="s0">tup = PyTuple_New(k)</span>
        <span class="s0">for j in range(k):</span>
            <span class="s0">val = keys[j][sorted_labels[j][n - 1]]</span>
            <span class="s0">PyTuple_SET_ITEM(tup, j, val)</span>
            <span class="s0">Py_INCREF(val)</span>
    <span class="s0">result[tup] = index[start:]</span>

    <span class="s0">return result</span>


<span class="s0"># core.common import for fast inference checks</span>

<span class="s0">def is_float(obj: object) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Return True if given object is float.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">bool</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">return util.is_float_object(obj)</span>


<span class="s0">def is_integer(obj: object) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Return True if given object is integer.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">bool</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">return util.is_integer_object(obj)</span>


<span class="s0">def is_bool(obj: object) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Return True if given object is boolean.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">bool</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">return util.is_bool_object(obj)</span>


<span class="s0">def is_complex(obj: object) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Return True if given object is complex.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">bool</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">return util.is_complex_object(obj)</span>


<span class="s0">cpdef bint is_decimal(object obj):</span>
    <span class="s0">return isinstance(obj, Decimal)</span>


<span class="s0">cpdef bint is_interval(object obj):</span>
    <span class="s0">return getattr(obj, '_typ', '_typ') == 'interval'</span>


<span class="s0">def is_period(val: object) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Return True if given object is Period.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">bool</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">return is_period_object(val)</span>


<span class="s0">def is_list_like(obj: object, allow_sets: bool = True) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Check if the object is list-like.</span>

    <span class="s0">Objects that are considered list-like are for example Python</span>
    <span class="s0">lists, tuples, sets, NumPy arrays, and Pandas Series.</span>

    <span class="s0">Strings and datetime objects, however, are not considered list-like.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">obj : object</span>
        <span class="s0">Object to check.</span>
    <span class="s0">allow_sets : bool, default True</span>
        <span class="s0">If this parameter is False, sets will not be considered list-like.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">bool</span>
        <span class="s0">Whether `obj` has list-like properties.</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">&gt;&gt;&gt; import datetime</span>
    <span class="s0">&gt;&gt;&gt; is_list_like([1, 2, 3])</span>
    <span class="s0">True</span>
    <span class="s0">&gt;&gt;&gt; is_list_like({1, 2, 3})</span>
    <span class="s0">True</span>
    <span class="s0">&gt;&gt;&gt; is_list_like(datetime.datetime(2017, 1, 1))</span>
    <span class="s0">False</span>
    <span class="s0">&gt;&gt;&gt; is_list_like(&quot;foo&quot;)</span>
    <span class="s0">False</span>
    <span class="s0">&gt;&gt;&gt; is_list_like(1)</span>
    <span class="s0">False</span>
    <span class="s0">&gt;&gt;&gt; is_list_like(np.array([2]))</span>
    <span class="s0">True</span>
    <span class="s0">&gt;&gt;&gt; is_list_like(np.array(2))</span>
    <span class="s0">False</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">return c_is_list_like(obj, allow_sets)</span>


<span class="s0">cdef inline bint c_is_list_like(object obj, bint allow_sets) except -1:</span>
    <span class="s0"># first, performance short-cuts for the most common cases</span>
    <span class="s0">if util.is_array(obj):</span>
        <span class="s0"># exclude zero-dimensional numpy arrays, effectively scalars</span>
        <span class="s0">return not cnp.PyArray_IsZeroDim(obj)</span>
    <span class="s0">elif isinstance(obj, list):</span>
        <span class="s0">return True</span>
    <span class="s0"># then the generic implementation</span>
    <span class="s0">return (</span>
        <span class="s0"># equiv: `isinstance(obj, abc.Iterable)`</span>
        <span class="s0">getattr(obj, &quot;__iter__&quot;, None) is not None and not isinstance(obj, type)</span>
        <span class="s0"># we do not count strings/unicode/bytes as list-like</span>
        <span class="s0">and not isinstance(obj, (str, bytes))</span>
        <span class="s0"># exclude zero-dimensional duck-arrays, effectively scalars</span>
        <span class="s0">and not (hasattr(obj, &quot;ndim&quot;) and obj.ndim == 0)</span>
        <span class="s0"># exclude sets if allow_sets is False</span>
        <span class="s0">and not (allow_sets is False and isinstance(obj, abc.Set))</span>
    <span class="s0">)</span>


<span class="s0">_TYPE_MAP = {</span>
    <span class="s0">&quot;categorical&quot;: &quot;categorical&quot;,</span>
    <span class="s0">&quot;category&quot;: &quot;categorical&quot;,</span>
    <span class="s0">&quot;int8&quot;: &quot;integer&quot;,</span>
    <span class="s0">&quot;int16&quot;: &quot;integer&quot;,</span>
    <span class="s0">&quot;int32&quot;: &quot;integer&quot;,</span>
    <span class="s0">&quot;int64&quot;: &quot;integer&quot;,</span>
    <span class="s0">&quot;i&quot;: &quot;integer&quot;,</span>
    <span class="s0">&quot;uint8&quot;: &quot;integer&quot;,</span>
    <span class="s0">&quot;uint16&quot;: &quot;integer&quot;,</span>
    <span class="s0">&quot;uint32&quot;: &quot;integer&quot;,</span>
    <span class="s0">&quot;uint64&quot;: &quot;integer&quot;,</span>
    <span class="s0">&quot;u&quot;: &quot;integer&quot;,</span>
    <span class="s0">&quot;float32&quot;: &quot;floating&quot;,</span>
    <span class="s0">&quot;float64&quot;: &quot;floating&quot;,</span>
    <span class="s0">&quot;f&quot;: &quot;floating&quot;,</span>
    <span class="s0">&quot;complex64&quot;: &quot;complex&quot;,</span>
    <span class="s0">&quot;complex128&quot;: &quot;complex&quot;,</span>
    <span class="s0">&quot;c&quot;: &quot;complex&quot;,</span>
    <span class="s0">&quot;string&quot;: &quot;string&quot;,</span>
    <span class="s0">str: &quot;string&quot;,</span>
    <span class="s0">&quot;S&quot;: &quot;bytes&quot;,</span>
    <span class="s0">&quot;U&quot;: &quot;string&quot;,</span>
    <span class="s0">&quot;bool&quot;: &quot;boolean&quot;,</span>
    <span class="s0">&quot;b&quot;: &quot;boolean&quot;,</span>
    <span class="s0">&quot;datetime64[ns]&quot;: &quot;datetime64&quot;,</span>
    <span class="s0">&quot;M&quot;: &quot;datetime64&quot;,</span>
    <span class="s0">&quot;timedelta64[ns]&quot;: &quot;timedelta64&quot;,</span>
    <span class="s0">&quot;m&quot;: &quot;timedelta64&quot;,</span>
    <span class="s0">&quot;interval&quot;: &quot;interval&quot;,</span>
    <span class="s0">Period: &quot;period&quot;,</span>
<span class="s0">}</span>

<span class="s0"># types only exist on certain platform</span>
<span class="s0">try:</span>
    <span class="s0">np.float128</span>
    <span class="s0">_TYPE_MAP['float128'] = 'floating'</span>
<span class="s0">except AttributeError:</span>
    <span class="s0">pass</span>
<span class="s0">try:</span>
    <span class="s0">np.complex256</span>
    <span class="s0">_TYPE_MAP['complex256'] = 'complex'</span>
<span class="s0">except AttributeError:</span>
    <span class="s0">pass</span>
<span class="s0">try:</span>
    <span class="s0">np.float16</span>
    <span class="s0">_TYPE_MAP['float16'] = 'floating'</span>
<span class="s0">except AttributeError:</span>
    <span class="s0">pass</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class Seen:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Class for keeping track of the types of elements</span>
    <span class="s0">encountered when trying to perform type conversions.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">cdef:</span>
        <span class="s0">bint int_             # seen_int</span>
        <span class="s0">bint nat_             # seen nat</span>
        <span class="s0">bint bool_            # seen_bool</span>
        <span class="s0">bint null_            # seen_null</span>
        <span class="s0">bint nan_             # seen_np.nan</span>
        <span class="s0">bint uint_            # seen_uint (unsigned integer)</span>
        <span class="s0">bint sint_            # seen_sint (signed integer)</span>
        <span class="s0">bint float_           # seen_float</span>
        <span class="s0">bint object_          # seen_object</span>
        <span class="s0">bint complex_         # seen_complex</span>
        <span class="s0">bint datetime_        # seen_datetime</span>
        <span class="s0">bint coerce_numeric   # coerce data to numeric</span>
        <span class="s0">bint timedelta_       # seen_timedelta</span>
        <span class="s0">bint datetimetz_      # seen_datetimetz</span>
        <span class="s0">bint period_          # seen_period</span>
        <span class="s0">bint interval_        # seen_interval</span>

    <span class="s0">def __cinit__(self, bint coerce_numeric=False):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Initialize a Seen instance.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">coerce_numeric : bool, default False</span>
            <span class="s0">Whether or not to force conversion to a numeric data type if</span>
            <span class="s0">initial methods to convert to numeric fail.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self.int_ = False</span>
        <span class="s0">self.nat_ = False</span>
        <span class="s0">self.bool_ = False</span>
        <span class="s0">self.null_ = False</span>
        <span class="s0">self.nan_ = False</span>
        <span class="s0">self.uint_ = False</span>
        <span class="s0">self.sint_ = False</span>
        <span class="s0">self.float_ = False</span>
        <span class="s0">self.object_ = False</span>
        <span class="s0">self.complex_ = False</span>
        <span class="s0">self.datetime_ = False</span>
        <span class="s0">self.timedelta_ = False</span>
        <span class="s0">self.datetimetz_ = False</span>
        <span class="s0">self.period_ = False</span>
        <span class="s0">self.interval_ = False</span>
        <span class="s0">self.coerce_numeric = coerce_numeric</span>

    <span class="s0">cdef inline bint check_uint64_conflict(self) except -1:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Check whether we can safely convert a uint64 array to a numeric dtype.</span>

        <span class="s0">There are two cases when conversion to numeric dtype with a uint64</span>
        <span class="s0">array is not safe (and will therefore not be performed)</span>

        <span class="s0">1) A NaN element is encountered.</span>

           <span class="s0">uint64 cannot be safely cast to float64 due to truncation issues</span>
           <span class="s0">at the extreme ends of the range.</span>

        <span class="s0">2) A negative number is encountered.</span>

           <span class="s0">There is no numerical dtype that can hold both negative numbers</span>
           <span class="s0">and numbers greater than INT64_MAX. Hence, at least one number</span>
           <span class="s0">will be improperly cast if we convert to a numeric dtype.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">bool</span>
            <span class="s0">Whether or not we should return the original input array to avoid</span>
            <span class="s0">data truncation.</span>

        <span class="s0">Raises</span>
        <span class="s0">------</span>
        <span class="s0">ValueError</span>
            <span class="s0">uint64 elements were detected, and at least one of the</span>
            <span class="s0">two conflict cases was also detected. However, we are</span>
            <span class="s0">trying to force conversion to a numeric dtype.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return (self.uint_ and (self.null_ or self.sint_)</span>
                <span class="s0">and not self.coerce_numeric)</span>

    <span class="s0">cdef inline saw_null(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Set flags indicating that a null value was encountered.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self.null_ = True</span>
        <span class="s0">self.float_ = True</span>

    <span class="s0">cdef saw_int(self, object val):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Set flags indicating that an integer value was encountered.</span>

        <span class="s0">In addition to setting a flag that an integer was seen, we</span>
        <span class="s0">also set two flags depending on the type of integer seen:</span>

        <span class="s0">1) sint_ : a negative (signed) number in the</span>
                   <span class="s0">range of [-2**63, 0) was encountered</span>
        <span class="s0">2) uint_ : a positive number in the range of</span>
                   <span class="s0">[2**63, 2**64) was encountered</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">val : Python int</span>
            <span class="s0">Value with which to set the flags.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self.int_ = True</span>
        <span class="s0">self.sint_ = self.sint_ or (oINT64_MIN &lt;= val &lt; 0)</span>
        <span class="s0">self.uint_ = self.uint_ or (oINT64_MAX &lt; val &lt;= oUINT64_MAX)</span>

    <span class="s0">@property</span>
    <span class="s0">def numeric_(self):</span>
        <span class="s0">return self.complex_ or self.float_ or self.int_</span>

    <span class="s0">@property</span>
    <span class="s0">def is_bool(self):</span>
        <span class="s0">return not (self.datetime_ or self.numeric_ or self.timedelta_</span>
                    <span class="s0">or self.nat_)</span>

    <span class="s0">@property</span>
    <span class="s0">def is_float_or_complex(self):</span>
        <span class="s0">return not (self.bool_ or self.datetime_ or self.timedelta_</span>
                    <span class="s0">or self.nat_)</span>


<span class="s0">cdef object _try_infer_map(object dtype):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">If its in our map, just return the dtype.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">object val</span>
        <span class="s0">str attr</span>
    <span class="s0">for attr in [&quot;name&quot;, &quot;kind&quot;, &quot;base&quot;, &quot;type&quot;]:</span>
        <span class="s0">val = getattr(dtype, attr, None)</span>
        <span class="s0">if val in _TYPE_MAP:</span>
            <span class="s0">return _TYPE_MAP[val]</span>
    <span class="s0">return None</span>


<span class="s0">def infer_dtype(value: object, skipna: bool = True) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Efficiently infer the type of a passed val, or list-like</span>
    <span class="s0">array of values. Return a string describing the type.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">value : scalar, list, ndarray, or pandas type</span>
    <span class="s0">skipna : bool, default True</span>
        <span class="s0">Ignore NaN values when inferring the type.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">str</span>
        <span class="s0">Describing the common type of the input data.</span>
    <span class="s0">Results can include:</span>

    <span class="s0">- string</span>
    <span class="s0">- bytes</span>
    <span class="s0">- floating</span>
    <span class="s0">- integer</span>
    <span class="s0">- mixed-integer</span>
    <span class="s0">- mixed-integer-float</span>
    <span class="s0">- decimal</span>
    <span class="s0">- complex</span>
    <span class="s0">- categorical</span>
    <span class="s0">- boolean</span>
    <span class="s0">- datetime64</span>
    <span class="s0">- datetime</span>
    <span class="s0">- date</span>
    <span class="s0">- timedelta64</span>
    <span class="s0">- timedelta</span>
    <span class="s0">- time</span>
    <span class="s0">- period</span>
    <span class="s0">- mixed</span>
    <span class="s0">- unknown-array</span>

    <span class="s0">Raises</span>
    <span class="s0">------</span>
    <span class="s0">TypeError</span>
        <span class="s0">If ndarray-like but cannot infer the dtype</span>

    <span class="s0">Notes</span>
    <span class="s0">-----</span>
    <span class="s0">- 'mixed' is the catchall for anything that is not otherwise</span>
      <span class="s0">specialized</span>
    <span class="s0">- 'mixed-integer-float' are floats and integers</span>
    <span class="s0">- 'mixed-integer' are integers mixed with non-integers</span>
    <span class="s0">- 'unknown-array' is the catchall for something that *is* an array (has</span>
      <span class="s0">a dtype attribute), but has a dtype unknown to pandas (e.g. external</span>
      <span class="s0">extension array)</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">&gt;&gt;&gt; import datetime</span>
    <span class="s0">&gt;&gt;&gt; infer_dtype(['foo', 'bar'])</span>
    <span class="s0">'string'</span>

    <span class="s0">&gt;&gt;&gt; infer_dtype(['a', np.nan, 'b'], skipna=True)</span>
    <span class="s0">'string'</span>

    <span class="s0">&gt;&gt;&gt; infer_dtype(['a', np.nan, 'b'], skipna=False)</span>
    <span class="s0">'mixed'</span>

    <span class="s0">&gt;&gt;&gt; infer_dtype([b'foo', b'bar'])</span>
    <span class="s0">'bytes'</span>

    <span class="s0">&gt;&gt;&gt; infer_dtype([1, 2, 3])</span>
    <span class="s0">'integer'</span>

    <span class="s0">&gt;&gt;&gt; infer_dtype([1, 2, 3.5])</span>
    <span class="s0">'mixed-integer-float'</span>

    <span class="s0">&gt;&gt;&gt; infer_dtype([1.0, 2.0, 3.5])</span>
    <span class="s0">'floating'</span>

    <span class="s0">&gt;&gt;&gt; infer_dtype(['a', 1])</span>
    <span class="s0">'mixed-integer'</span>

    <span class="s0">&gt;&gt;&gt; infer_dtype([Decimal(1), Decimal(2.0)])</span>
    <span class="s0">'decimal'</span>

    <span class="s0">&gt;&gt;&gt; infer_dtype([True, False])</span>
    <span class="s0">'boolean'</span>

    <span class="s0">&gt;&gt;&gt; infer_dtype([True, False, np.nan])</span>
    <span class="s0">'boolean'</span>

    <span class="s0">&gt;&gt;&gt; infer_dtype([pd.Timestamp('20130101')])</span>
    <span class="s0">'datetime'</span>

    <span class="s0">&gt;&gt;&gt; infer_dtype([datetime.date(2013, 1, 1)])</span>
    <span class="s0">'date'</span>

    <span class="s0">&gt;&gt;&gt; infer_dtype([np.datetime64('2013-01-01')])</span>
    <span class="s0">'datetime64'</span>

    <span class="s0">&gt;&gt;&gt; infer_dtype([datetime.timedelta(0, 1, 1)])</span>
    <span class="s0">'timedelta'</span>

    <span class="s0">&gt;&gt;&gt; infer_dtype(pd.Series(list('aabc')).astype('category'))</span>
    <span class="s0">'categorical'</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n</span>
        <span class="s0">object val</span>
        <span class="s0">ndarray values</span>
        <span class="s0">bint seen_pdnat = False</span>
        <span class="s0">bint seen_val = False</span>

    <span class="s0">if util.is_array(value):</span>
        <span class="s0">values = value</span>
    <span class="s0">elif hasattr(value, &quot;inferred_type&quot;) and skipna is False:</span>
        <span class="s0"># Index, use the cached attribute if possible, populate the cache otherwise</span>
        <span class="s0">return value.inferred_type</span>
    <span class="s0">elif hasattr(value, &quot;dtype&quot;):</span>
        <span class="s0"># this will handle ndarray-like</span>
        <span class="s0"># e.g. categoricals</span>
        <span class="s0">dtype = value.dtype</span>
        <span class="s0">if not cnp.PyArray_DescrCheck(dtype):</span>
            <span class="s0"># i.e. not isinstance(dtype, np.dtype)</span>
            <span class="s0">inferred = _try_infer_map(value.dtype)</span>
            <span class="s0">if inferred is not None:</span>
                <span class="s0">return inferred</span>
            <span class="s0">return &quot;unknown-array&quot;</span>

        <span class="s0"># Unwrap Series/Index</span>
        <span class="s0">values = np.asarray(value)</span>

    <span class="s0">else:</span>
        <span class="s0">if not isinstance(value, list):</span>
            <span class="s0">value = list(value)</span>

        <span class="s0">from pandas.core.dtypes.cast import construct_1d_object_array_from_listlike</span>
        <span class="s0">values = construct_1d_object_array_from_listlike(value)</span>

    <span class="s0">val = _try_infer_map(values.dtype)</span>
    <span class="s0">if val is not None:</span>
        <span class="s0"># Anything other than object-dtype should return here.</span>
        <span class="s0">return val</span>

    <span class="s0">if values.descr.type_num != NPY_OBJECT:</span>
        <span class="s0"># i.e. values.dtype != np.object</span>
        <span class="s0"># This should not be reached</span>
        <span class="s0">values = values.astype(object)</span>

    <span class="s0"># for f-contiguous array 1000 x 1000, passing order=&quot;K&quot; gives 5000x speedup</span>
    <span class="s0">values = values.ravel(order=&quot;K&quot;)</span>

    <span class="s0">if skipna:</span>
        <span class="s0">values = values[~isnaobj(values)]</span>

    <span class="s0">n = cnp.PyArray_SIZE(values)</span>
    <span class="s0">if n == 0:</span>
        <span class="s0">return &quot;empty&quot;</span>

    <span class="s0"># Iterate until we find our first valid value. We will use this</span>
    <span class="s0">#  value to decide which of the is_foo_array functions to call.</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">val = values[i]</span>

        <span class="s0"># do not use checknull to keep</span>
        <span class="s0"># np.datetime64('nat') and np.timedelta64('nat')</span>
        <span class="s0">if val is None or util.is_nan(val):</span>
            <span class="s0">pass</span>
        <span class="s0">elif val is NaT:</span>
            <span class="s0">seen_pdnat = True</span>
        <span class="s0">else:</span>
            <span class="s0">seen_val = True</span>
            <span class="s0">break</span>

    <span class="s0"># if all values are nan/NaT</span>
    <span class="s0">if seen_val is False and seen_pdnat is True:</span>
        <span class="s0">return &quot;datetime&quot;</span>
        <span class="s0"># float/object nan is handled in latter logic</span>

    <span class="s0">if util.is_datetime64_object(val):</span>
        <span class="s0">if is_datetime64_array(values):</span>
            <span class="s0">return &quot;datetime64&quot;</span>

    <span class="s0">elif is_timedelta(val):</span>
        <span class="s0">if is_timedelta_or_timedelta64_array(values):</span>
            <span class="s0">return &quot;timedelta&quot;</span>

    <span class="s0">elif util.is_integer_object(val):</span>
        <span class="s0"># ordering matters here; this check must come after the is_timedelta</span>
        <span class="s0">#  check otherwise numpy timedelta64 objects would come through here</span>

        <span class="s0">if is_integer_array(values):</span>
            <span class="s0">return &quot;integer&quot;</span>
        <span class="s0">elif is_integer_float_array(values):</span>
            <span class="s0">if is_integer_na_array(values):</span>
                <span class="s0">return &quot;integer-na&quot;</span>
            <span class="s0">else:</span>
                <span class="s0">return &quot;mixed-integer-float&quot;</span>
        <span class="s0">return &quot;mixed-integer&quot;</span>

    <span class="s0">elif PyDateTime_Check(val):</span>
        <span class="s0">if is_datetime_array(values, skipna=skipna):</span>
            <span class="s0">return &quot;datetime&quot;</span>
        <span class="s0">elif is_date_array(values, skipna=skipna):</span>
            <span class="s0">return &quot;date&quot;</span>

    <span class="s0">elif PyDate_Check(val):</span>
        <span class="s0">if is_date_array(values, skipna=skipna):</span>
            <span class="s0">return &quot;date&quot;</span>

    <span class="s0">elif PyTime_Check(val):</span>
        <span class="s0">if is_time_array(values, skipna=skipna):</span>
            <span class="s0">return &quot;time&quot;</span>

    <span class="s0">elif is_decimal(val):</span>
        <span class="s0">if is_decimal_array(values):</span>
            <span class="s0">return &quot;decimal&quot;</span>

    <span class="s0">elif util.is_complex_object(val):</span>
        <span class="s0">if is_complex_array(values):</span>
            <span class="s0">return &quot;complex&quot;</span>

    <span class="s0">elif util.is_float_object(val):</span>
        <span class="s0">if is_float_array(values):</span>
            <span class="s0">return &quot;floating&quot;</span>
        <span class="s0">elif is_integer_float_array(values):</span>
            <span class="s0">if is_integer_na_array(values):</span>
                <span class="s0">return &quot;integer-na&quot;</span>
            <span class="s0">else:</span>
                <span class="s0">return &quot;mixed-integer-float&quot;</span>

    <span class="s0">elif util.is_bool_object(val):</span>
        <span class="s0">if is_bool_array(values, skipna=skipna):</span>
            <span class="s0">return &quot;boolean&quot;</span>

    <span class="s0">elif isinstance(val, str):</span>
        <span class="s0">if is_string_array(values, skipna=skipna):</span>
            <span class="s0">return &quot;string&quot;</span>

    <span class="s0">elif isinstance(val, bytes):</span>
        <span class="s0">if is_bytes_array(values, skipna=skipna):</span>
            <span class="s0">return &quot;bytes&quot;</span>

    <span class="s0">elif is_period_object(val):</span>
        <span class="s0">if is_period_array(values):</span>
            <span class="s0">return &quot;period&quot;</span>

    <span class="s0">elif is_interval(val):</span>
        <span class="s0">if is_interval_array(values):</span>
            <span class="s0">return &quot;interval&quot;</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">val = values[i]</span>
        <span class="s0">if util.is_integer_object(val):</span>
            <span class="s0">return &quot;mixed-integer&quot;</span>

    <span class="s0">return &quot;mixed&quot;</span>


<span class="s0">def infer_datetimelike_array(arr: ndarray[object]) -&gt; tuple[str, bool]:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Infer if we have a datetime or timedelta array.</span>
    <span class="s0">- date: we have *only* date and maybe strings, nulls</span>
    <span class="s0">- datetime: we have *only* datetimes and maybe strings, nulls</span>
    <span class="s0">- timedelta: we have *only* timedeltas and maybe strings, nulls</span>
    <span class="s0">- nat: we do not have *any* date, datetimes or timedeltas, but do have</span>
      <span class="s0">at least a NaT</span>
    <span class="s0">- mixed: other objects (strings, a mix of tz-aware and tz-naive, or</span>
                            <span class="s0">actual objects)</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">arr : ndarray[object]</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">str: {datetime, timedelta, date, nat, mixed}</span>
    <span class="s0">bool</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(arr)</span>
        <span class="s0">bint seen_timedelta = False, seen_date = False, seen_datetime = False</span>
        <span class="s0">bint seen_tz_aware = False, seen_tz_naive = False</span>
        <span class="s0">bint seen_nat = False, seen_str = False</span>
        <span class="s0">bint seen_period = False, seen_interval = False</span>
        <span class="s0">list objs = []</span>
        <span class="s0">object v</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">v = arr[i]</span>
        <span class="s0">if isinstance(v, str):</span>
            <span class="s0">objs.append(v)</span>
            <span class="s0">seen_str = True</span>

            <span class="s0">if len(objs) == 3:</span>
                <span class="s0">break</span>

        <span class="s0">elif v is None or util.is_nan(v):</span>
            <span class="s0"># nan or None</span>
            <span class="s0">pass</span>
        <span class="s0">elif v is NaT:</span>
            <span class="s0">seen_nat = True</span>
        <span class="s0">elif PyDateTime_Check(v):</span>
            <span class="s0"># datetime</span>
            <span class="s0">seen_datetime = True</span>

            <span class="s0"># disambiguate between tz-naive and tz-aware</span>
            <span class="s0">if v.tzinfo is None:</span>
                <span class="s0">seen_tz_naive = True</span>
            <span class="s0">else:</span>
                <span class="s0">seen_tz_aware = True</span>

            <span class="s0">if seen_tz_naive and seen_tz_aware:</span>
                <span class="s0">return &quot;mixed&quot;, seen_str</span>
        <span class="s0">elif util.is_datetime64_object(v):</span>
            <span class="s0"># np.datetime64</span>
            <span class="s0">seen_datetime = True</span>
        <span class="s0">elif PyDate_Check(v):</span>
            <span class="s0">seen_date = True</span>
        <span class="s0">elif is_timedelta(v):</span>
            <span class="s0"># timedelta, or timedelta64</span>
            <span class="s0">seen_timedelta = True</span>
        <span class="s0">elif is_period_object(v):</span>
            <span class="s0">seen_period = True</span>
            <span class="s0">break</span>
        <span class="s0">elif is_interval(v):</span>
            <span class="s0">seen_interval = True</span>
            <span class="s0">break</span>
        <span class="s0">else:</span>
            <span class="s0">return &quot;mixed&quot;, seen_str</span>

    <span class="s0">if seen_period:</span>
        <span class="s0">if is_period_array(arr):</span>
            <span class="s0">return &quot;period&quot;, seen_str</span>
        <span class="s0">return &quot;mixed&quot;, seen_str</span>

    <span class="s0">if seen_interval:</span>
        <span class="s0">if is_interval_array(arr):</span>
            <span class="s0">return &quot;interval&quot;, seen_str</span>
        <span class="s0">return &quot;mixed&quot;, seen_str</span>

    <span class="s0">if seen_date and not (seen_datetime or seen_timedelta):</span>
        <span class="s0">return &quot;date&quot;, seen_str</span>
    <span class="s0">elif seen_datetime and not seen_timedelta:</span>
        <span class="s0">return &quot;datetime&quot;, seen_str</span>
    <span class="s0">elif seen_timedelta and not seen_datetime:</span>
        <span class="s0">return &quot;timedelta&quot;, seen_str</span>
    <span class="s0">elif seen_nat:</span>
        <span class="s0">return &quot;nat&quot;, seen_str</span>

    <span class="s0"># short-circuit by trying to</span>
    <span class="s0"># actually convert these strings</span>
    <span class="s0"># this is for performance as we don't need to try</span>
    <span class="s0"># convert *every* string array</span>
    <span class="s0">if len(objs):</span>
        <span class="s0">try:</span>
            <span class="s0"># require_iso8601 as in maybe_infer_to_datetimelike</span>
            <span class="s0">array_to_datetime(objs, errors=&quot;raise&quot;, require_iso8601=True)</span>
            <span class="s0">return &quot;datetime&quot;, seen_str</span>
        <span class="s0">except (ValueError, TypeError):</span>
            <span class="s0">pass</span>

        <span class="s0"># we are *not* going to infer from strings</span>
        <span class="s0"># for timedelta as too much ambiguity</span>

    <span class="s0">return &quot;mixed&quot;, seen_str</span>


<span class="s0">cdef inline bint is_timedelta(object o):</span>
    <span class="s0">return PyDelta_Check(o) or util.is_timedelta64_object(o)</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class Validator:</span>

    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t n</span>
        <span class="s0">dtype dtype</span>
        <span class="s0">bint skipna</span>

    <span class="s0">def __cinit__(self, Py_ssize_t n, dtype dtype=np.dtype(np.object_),</span>
                  <span class="s0">bint skipna=False):</span>
        <span class="s0">self.n = n</span>
        <span class="s0">self.dtype = dtype</span>
        <span class="s0">self.skipna = skipna</span>

    <span class="s0">cdef bint validate(self, ndarray values) except -1:</span>
        <span class="s0">if not self.n:</span>
            <span class="s0">return False</span>

        <span class="s0">if self.is_array_typed():</span>
            <span class="s0"># i.e. this ndarray is already of the desired dtype</span>
            <span class="s0">return True</span>
        <span class="s0">elif self.dtype.type_num == NPY_OBJECT:</span>
            <span class="s0">if self.skipna:</span>
                <span class="s0">return self._validate_skipna(values)</span>
            <span class="s0">else:</span>
                <span class="s0">return self._validate(values)</span>
        <span class="s0">else:</span>
            <span class="s0">return False</span>

    <span class="s0">@cython.wraparound(False)</span>
    <span class="s0">@cython.boundscheck(False)</span>
    <span class="s0">cdef bint _validate(self, ndarray values) except -1:</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t i</span>
            <span class="s0">Py_ssize_t n = values.size</span>
            <span class="s0">flatiter it = PyArray_IterNew(values)</span>

        <span class="s0">for i in range(n):</span>
            <span class="s0"># The PyArray_GETITEM and PyArray_ITER_NEXT are faster</span>
            <span class="s0">#  equivalents to `val = values[i]`</span>
            <span class="s0">val = PyArray_GETITEM(values, PyArray_ITER_DATA(it))</span>
            <span class="s0">PyArray_ITER_NEXT(it)</span>
            <span class="s0">if not self.is_valid(val):</span>
                <span class="s0">return False</span>

        <span class="s0">return True</span>

    <span class="s0">@cython.wraparound(False)</span>
    <span class="s0">@cython.boundscheck(False)</span>
    <span class="s0">cdef bint _validate_skipna(self, ndarray values) except -1:</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t i</span>
            <span class="s0">Py_ssize_t n = values.size</span>
            <span class="s0">flatiter it = PyArray_IterNew(values)</span>

        <span class="s0">for i in range(n):</span>
            <span class="s0"># The PyArray_GETITEM and PyArray_ITER_NEXT are faster</span>
            <span class="s0">#  equivalents to `val = values[i]`</span>
            <span class="s0">val = PyArray_GETITEM(values, PyArray_ITER_DATA(it))</span>
            <span class="s0">PyArray_ITER_NEXT(it)</span>
            <span class="s0">if not self.is_valid_skipna(val):</span>
                <span class="s0">return False</span>

        <span class="s0">return True</span>

    <span class="s0">cdef bint is_valid(self, object value) except -1:</span>
        <span class="s0">return self.is_value_typed(value)</span>

    <span class="s0">cdef bint is_valid_skipna(self, object value) except -1:</span>
        <span class="s0">return self.is_valid(value) or self.is_valid_null(value)</span>

    <span class="s0">cdef bint is_value_typed(self, object value) except -1:</span>
        <span class="s0">raise NotImplementedError(f&quot;{type(self).__name__} child class &quot;</span>
                                  <span class="s0">&quot;must define is_value_typed&quot;)</span>

    <span class="s0">cdef bint is_valid_null(self, object value) except -1:</span>
        <span class="s0">return value is None or value is C_NA or util.is_nan(value)</span>

    <span class="s0">cdef bint is_array_typed(self) except -1:</span>
        <span class="s0">return False</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class BoolValidator(Validator):</span>
    <span class="s0">cdef inline bint is_value_typed(self, object value) except -1:</span>
        <span class="s0">return util.is_bool_object(value)</span>

    <span class="s0">cdef inline bint is_array_typed(self) except -1:</span>
        <span class="s0">return issubclass(self.dtype.type, np.bool_)</span>


<span class="s0">cpdef bint is_bool_array(ndarray values, bint skipna=False):</span>
    <span class="s0">cdef:</span>
        <span class="s0">BoolValidator validator = BoolValidator(len(values),</span>
                                                <span class="s0">values.dtype,</span>
                                                <span class="s0">skipna=skipna)</span>
    <span class="s0">return validator.validate(values)</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class IntegerValidator(Validator):</span>
    <span class="s0">cdef inline bint is_value_typed(self, object value) except -1:</span>
        <span class="s0">return util.is_integer_object(value)</span>

    <span class="s0">cdef inline bint is_array_typed(self) except -1:</span>
        <span class="s0">return issubclass(self.dtype.type, np.integer)</span>


<span class="s0"># Note: only python-exposed for tests</span>
<span class="s0">cpdef bint is_integer_array(ndarray values):</span>
    <span class="s0">cdef:</span>
        <span class="s0">IntegerValidator validator = IntegerValidator(len(values),</span>
                                                      <span class="s0">values.dtype)</span>
    <span class="s0">return validator.validate(values)</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class IntegerNaValidator(Validator):</span>
    <span class="s0">cdef inline bint is_value_typed(self, object value) except -1:</span>
        <span class="s0">return (util.is_integer_object(value)</span>
                <span class="s0">or (util.is_nan(value) and util.is_float_object(value)))</span>


<span class="s0">cdef bint is_integer_na_array(ndarray values):</span>
    <span class="s0">cdef:</span>
        <span class="s0">IntegerNaValidator validator = IntegerNaValidator(len(values),</span>
                                                          <span class="s0">values.dtype)</span>
    <span class="s0">return validator.validate(values)</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class IntegerFloatValidator(Validator):</span>
    <span class="s0">cdef inline bint is_value_typed(self, object value) except -1:</span>
        <span class="s0">return util.is_integer_object(value) or util.is_float_object(value)</span>

    <span class="s0">cdef inline bint is_array_typed(self) except -1:</span>
        <span class="s0">return issubclass(self.dtype.type, np.integer)</span>


<span class="s0">cdef bint is_integer_float_array(ndarray values):</span>
    <span class="s0">cdef:</span>
        <span class="s0">IntegerFloatValidator validator = IntegerFloatValidator(len(values),</span>
                                                                <span class="s0">values.dtype)</span>
    <span class="s0">return validator.validate(values)</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class FloatValidator(Validator):</span>
    <span class="s0">cdef inline bint is_value_typed(self, object value) except -1:</span>
        <span class="s0">return util.is_float_object(value)</span>

    <span class="s0">cdef inline bint is_array_typed(self) except -1:</span>
        <span class="s0">return issubclass(self.dtype.type, np.floating)</span>


<span class="s0"># Note: only python-exposed for tests</span>
<span class="s0">cpdef bint is_float_array(ndarray values):</span>
    <span class="s0">cdef:</span>
        <span class="s0">FloatValidator validator = FloatValidator(len(values), values.dtype)</span>
    <span class="s0">return validator.validate(values)</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class ComplexValidator(Validator):</span>
    <span class="s0">cdef inline bint is_value_typed(self, object value) except -1:</span>
        <span class="s0">return (</span>
            <span class="s0">util.is_complex_object(value)</span>
            <span class="s0">or (util.is_float_object(value) and is_nan(value))</span>
        <span class="s0">)</span>

    <span class="s0">cdef inline bint is_array_typed(self) except -1:</span>
        <span class="s0">return issubclass(self.dtype.type, np.complexfloating)</span>


<span class="s0">cdef bint is_complex_array(ndarray values):</span>
    <span class="s0">cdef:</span>
        <span class="s0">ComplexValidator validator = ComplexValidator(len(values), values.dtype)</span>
    <span class="s0">return validator.validate(values)</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class DecimalValidator(Validator):</span>
    <span class="s0">cdef inline bint is_value_typed(self, object value) except -1:</span>
        <span class="s0">return is_decimal(value)</span>


<span class="s0">cdef bint is_decimal_array(ndarray values):</span>
    <span class="s0">cdef:</span>
        <span class="s0">DecimalValidator validator = DecimalValidator(len(values), values.dtype)</span>
    <span class="s0">return validator.validate(values)</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class StringValidator(Validator):</span>
    <span class="s0">cdef inline bint is_value_typed(self, object value) except -1:</span>
        <span class="s0">return isinstance(value, str)</span>

    <span class="s0">cdef inline bint is_array_typed(self) except -1:</span>
        <span class="s0">return issubclass(self.dtype.type, np.str_)</span>

    <span class="s0">cdef bint is_valid_null(self, object value) except -1:</span>
        <span class="s0"># We deliberately exclude None / NaN here since StringArray uses NA</span>
        <span class="s0">return value is C_NA</span>


<span class="s0">cpdef bint is_string_array(ndarray values, bint skipna=False):</span>
    <span class="s0">cdef:</span>
        <span class="s0">StringValidator validator = StringValidator(len(values),</span>
                                                    <span class="s0">values.dtype,</span>
                                                    <span class="s0">skipna=skipna)</span>
    <span class="s0">return validator.validate(values)</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class BytesValidator(Validator):</span>
    <span class="s0">cdef inline bint is_value_typed(self, object value) except -1:</span>
        <span class="s0">return isinstance(value, bytes)</span>

    <span class="s0">cdef inline bint is_array_typed(self) except -1:</span>
        <span class="s0">return issubclass(self.dtype.type, np.bytes_)</span>


<span class="s0">cdef bint is_bytes_array(ndarray values, bint skipna=False):</span>
    <span class="s0">cdef:</span>
        <span class="s0">BytesValidator validator = BytesValidator(len(values), values.dtype,</span>
                                                  <span class="s0">skipna=skipna)</span>
    <span class="s0">return validator.validate(values)</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class TemporalValidator(Validator):</span>
    <span class="s0">cdef:</span>
        <span class="s0">bint all_generic_na</span>

    <span class="s0">def __cinit__(self, Py_ssize_t n, dtype dtype=np.dtype(np.object_),</span>
                  <span class="s0">bint skipna=False):</span>
        <span class="s0">self.n = n</span>
        <span class="s0">self.dtype = dtype</span>
        <span class="s0">self.skipna = skipna</span>
        <span class="s0">self.all_generic_na = True</span>

    <span class="s0">cdef inline bint is_valid(self, object value) except -1:</span>
        <span class="s0">return self.is_value_typed(value) or self.is_valid_null(value)</span>

    <span class="s0">cdef bint is_valid_null(self, object value) except -1:</span>
        <span class="s0">raise NotImplementedError(f&quot;{type(self).__name__} child class &quot;</span>
                                  <span class="s0">&quot;must define is_valid_null&quot;)</span>

    <span class="s0">cdef inline bint is_valid_skipna(self, object value) except -1:</span>
        <span class="s0">cdef:</span>
            <span class="s0">bint is_typed_null = self.is_valid_null(value)</span>
            <span class="s0">bint is_generic_null = value is None or util.is_nan(value)</span>
        <span class="s0">if not is_generic_null:</span>
            <span class="s0">self.all_generic_na = False</span>
        <span class="s0">return self.is_value_typed(value) or is_typed_null or is_generic_null</span>

    <span class="s0">cdef bint _validate_skipna(self, ndarray values) except -1:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">If we _only_ saw non-dtype-specific NA values, even if they are valid</span>
        <span class="s0">for this dtype, we do not infer this dtype.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return Validator._validate_skipna(self, values) and not self.all_generic_na</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class DatetimeValidator(TemporalValidator):</span>
    <span class="s0">cdef bint is_value_typed(self, object value) except -1:</span>
        <span class="s0">return PyDateTime_Check(value)</span>

    <span class="s0">cdef inline bint is_valid_null(self, object value) except -1:</span>
        <span class="s0">return is_null_datetime64(value)</span>


<span class="s0">cpdef bint is_datetime_array(ndarray values, bint skipna=True):</span>
    <span class="s0">cdef:</span>
        <span class="s0">DatetimeValidator validator = DatetimeValidator(len(values),</span>
                                                        <span class="s0">skipna=skipna)</span>
    <span class="s0">return validator.validate(values)</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class Datetime64Validator(DatetimeValidator):</span>
    <span class="s0">cdef inline bint is_value_typed(self, object value) except -1:</span>
        <span class="s0">return util.is_datetime64_object(value)</span>


<span class="s0"># Note: only python-exposed for tests</span>
<span class="s0">cpdef bint is_datetime64_array(ndarray values):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Datetime64Validator validator = Datetime64Validator(len(values),</span>
                                                            <span class="s0">skipna=True)</span>
    <span class="s0">return validator.validate(values)</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class AnyDatetimeValidator(DatetimeValidator):</span>
    <span class="s0">cdef inline bint is_value_typed(self, object value) except -1:</span>
        <span class="s0">return util.is_datetime64_object(value) or (</span>
            <span class="s0">PyDateTime_Check(value) and value.tzinfo is None</span>
        <span class="s0">)</span>


<span class="s0">cdef bint is_datetime_or_datetime64_array(ndarray values):</span>
    <span class="s0">cdef:</span>
        <span class="s0">AnyDatetimeValidator validator = AnyDatetimeValidator(len(values),</span>
                                                              <span class="s0">skipna=True)</span>
    <span class="s0">return validator.validate(values)</span>


<span class="s0"># Note: only python-exposed for tests</span>
<span class="s0">def is_datetime_with_singletz_array(values: ndarray) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Check values have the same tzinfo attribute.</span>
    <span class="s0">Doesn't check values are datetime-like types.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i = 0, j, n = len(values)</span>
        <span class="s0">object base_val, base_tz, val, tz</span>

    <span class="s0">if n == 0:</span>
        <span class="s0">return False</span>

    <span class="s0"># Get a reference timezone to compare with the rest of the tzs in the array</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">base_val = values[i]</span>
        <span class="s0">if base_val is not NaT and base_val is not None and not util.is_nan(base_val):</span>
            <span class="s0">base_tz = getattr(base_val, 'tzinfo', None)</span>
            <span class="s0">break</span>

    <span class="s0">for j in range(i, n):</span>
        <span class="s0"># Compare val's timezone with the reference timezone</span>
        <span class="s0"># NaT can coexist with tz-aware datetimes, so skip if encountered</span>
        <span class="s0">val = values[j]</span>
        <span class="s0">if val is not NaT and val is not None and not util.is_nan(val):</span>
            <span class="s0">tz = getattr(val, 'tzinfo', None)</span>
            <span class="s0">if not tz_compare(base_tz, tz):</span>
                <span class="s0">return False</span>

    <span class="s0"># Note: we should only be called if a tzaware datetime has been seen,</span>
    <span class="s0">#  so base_tz should always be set at this point.</span>
    <span class="s0">return True</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class TimedeltaValidator(TemporalValidator):</span>
    <span class="s0">cdef bint is_value_typed(self, object value) except -1:</span>
        <span class="s0">return PyDelta_Check(value)</span>

    <span class="s0">cdef inline bint is_valid_null(self, object value) except -1:</span>
        <span class="s0">return is_null_timedelta64(value)</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class AnyTimedeltaValidator(TimedeltaValidator):</span>
    <span class="s0">cdef inline bint is_value_typed(self, object value) except -1:</span>
        <span class="s0">return is_timedelta(value)</span>


<span class="s0"># Note: only python-exposed for tests</span>
<span class="s0">cpdef bint is_timedelta_or_timedelta64_array(ndarray values):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Infer with timedeltas and/or nat/none.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">AnyTimedeltaValidator validator = AnyTimedeltaValidator(len(values),</span>
                                                                <span class="s0">skipna=True)</span>
    <span class="s0">return validator.validate(values)</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class DateValidator(Validator):</span>
    <span class="s0">cdef inline bint is_value_typed(self, object value) except -1:</span>
        <span class="s0">return PyDate_Check(value)</span>


<span class="s0"># Note: only python-exposed for tests</span>
<span class="s0">cpdef bint is_date_array(ndarray values, bint skipna=False):</span>
    <span class="s0">cdef:</span>
        <span class="s0">DateValidator validator = DateValidator(len(values), skipna=skipna)</span>
    <span class="s0">return validator.validate(values)</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class TimeValidator(Validator):</span>
    <span class="s0">cdef inline bint is_value_typed(self, object value) except -1:</span>
        <span class="s0">return PyTime_Check(value)</span>


<span class="s0"># Note: only python-exposed for tests</span>
<span class="s0">cpdef bint is_time_array(ndarray values, bint skipna=False):</span>
    <span class="s0">cdef:</span>
        <span class="s0">TimeValidator validator = TimeValidator(len(values), skipna=skipna)</span>
    <span class="s0">return validator.validate(values)</span>


<span class="s0">cdef bint is_period_array(ndarray[object] values):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Is this an ndarray of Period objects (or NaT) with a single `freq`?</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(values)</span>
        <span class="s0">int dtype_code = -10000  # i.e. c_FreqGroup.FR_UND</span>
        <span class="s0">object val</span>

    <span class="s0">if len(values) == 0:</span>
        <span class="s0">return False</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">val = values[i]</span>

        <span class="s0">if is_period_object(val):</span>
            <span class="s0">if dtype_code == -10000:</span>
                <span class="s0">dtype_code = val._dtype._dtype_code</span>
            <span class="s0">elif dtype_code != val._dtype._dtype_code:</span>
                <span class="s0"># mismatched freqs</span>
                <span class="s0">return False</span>
        <span class="s0">elif checknull_with_nat(val):</span>
            <span class="s0">pass</span>
        <span class="s0">else:</span>
            <span class="s0"># Not a Period or NaT-like</span>
            <span class="s0">return False</span>

    <span class="s0">if dtype_code == -10000:</span>
        <span class="s0"># we saw all-NaTs, no actual Periods</span>
        <span class="s0">return False</span>
    <span class="s0">return True</span>


<span class="s0"># Note: only python-exposed for tests</span>
<span class="s0">cpdef bint is_interval_array(ndarray values):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Is this an ndarray of Interval (or np.nan) with a single dtype?</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(values)</span>
        <span class="s0">str closed = None</span>
        <span class="s0">bint numeric = False</span>
        <span class="s0">bint dt64 = False</span>
        <span class="s0">bint td64 = False</span>
        <span class="s0">object val</span>

    <span class="s0">if len(values) == 0:</span>
        <span class="s0">return False</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">val = values[i]</span>

        <span class="s0">if is_interval(val):</span>
            <span class="s0">if closed is None:</span>
                <span class="s0">closed = val.closed</span>
                <span class="s0">numeric = (</span>
                    <span class="s0">util.is_float_object(val.left)</span>
                    <span class="s0">or util.is_integer_object(val.left)</span>
                <span class="s0">)</span>
                <span class="s0">td64 = is_timedelta(val.left)</span>
                <span class="s0">dt64 = PyDateTime_Check(val.left)</span>
            <span class="s0">elif val.closed != closed:</span>
                <span class="s0"># mismatched closedness</span>
                <span class="s0">return False</span>
            <span class="s0">elif numeric:</span>
                <span class="s0">if not (</span>
                    <span class="s0">util.is_float_object(val.left)</span>
                    <span class="s0">or util.is_integer_object(val.left)</span>
                <span class="s0">):</span>
                    <span class="s0"># i.e. datetime64 or timedelta64</span>
                    <span class="s0">return False</span>
            <span class="s0">elif td64:</span>
                <span class="s0">if not is_timedelta(val.left):</span>
                    <span class="s0">return False</span>
            <span class="s0">elif dt64:</span>
                <span class="s0">if not PyDateTime_Check(val.left):</span>
                    <span class="s0">return False</span>
            <span class="s0">else:</span>
                <span class="s0">raise ValueError(val)</span>
        <span class="s0">elif util.is_nan(val) or val is None:</span>
            <span class="s0">pass</span>
        <span class="s0">else:</span>
            <span class="s0">return False</span>

    <span class="s0">if closed is None:</span>
        <span class="s0"># we saw all-NAs, no actual Intervals</span>
        <span class="s0">return False</span>
    <span class="s0">return True</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def maybe_convert_numeric(</span>
    <span class="s0">ndarray[object, ndim=1] values,</span>
    <span class="s0">set na_values,</span>
    <span class="s0">bint convert_empty=True,</span>
    <span class="s0">bint coerce_numeric=False,</span>
    <span class="s0">bint convert_to_masked_nullable=False,</span>
<span class="s0">) -&gt; tuple[np.ndarray, np.ndarray | None]:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Convert object array to a numeric array if possible.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">values : ndarray[object]</span>
        <span class="s0">Array of object elements to convert.</span>
    <span class="s0">na_values : set</span>
        <span class="s0">Set of values that should be interpreted as NaN.</span>
    <span class="s0">convert_empty : bool, default True</span>
        <span class="s0">If an empty array-like object is encountered, whether to interpret</span>
        <span class="s0">that element as NaN or not. If set to False, a ValueError will be</span>
        <span class="s0">raised if such an element is encountered and 'coerce_numeric' is False.</span>
    <span class="s0">coerce_numeric : bool, default False</span>
        <span class="s0">If initial attempts to convert to numeric have failed, whether to</span>
        <span class="s0">force conversion to numeric via alternative methods or by setting the</span>
        <span class="s0">element to NaN. Otherwise, an Exception will be raised when such an</span>
        <span class="s0">element is encountered.</span>

        <span class="s0">This boolean also has an impact on how conversion behaves when a</span>
        <span class="s0">numeric array has no suitable numerical dtype to return (i.e. uint64,</span>
        <span class="s0">int32, uint8). If set to False, the original object array will be</span>
        <span class="s0">returned. Otherwise, a ValueError will be raised.</span>
    <span class="s0">convert_to_masked_nullable : bool, default False</span>
        <span class="s0">Whether to return a mask for the converted values. This also disables</span>
        <span class="s0">upcasting for ints with nulls to float64.</span>
    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">np.ndarray</span>
        <span class="s0">Array of converted object values to numerical ones.</span>

    <span class="s0">Optional[np.ndarray]</span>
        <span class="s0">If convert_to_masked_nullable is True,</span>
        <span class="s0">returns a boolean mask for the converted values, otherwise returns None.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if len(values) == 0:</span>
        <span class="s0">return (np.array([], dtype='i8'), None)</span>

    <span class="s0"># fastpath for ints - try to convert all based on first value</span>
    <span class="s0">cdef:</span>
        <span class="s0">object val = values[0]</span>

    <span class="s0">if util.is_integer_object(val):</span>
        <span class="s0">try:</span>
            <span class="s0">maybe_ints = values.astype('i8')</span>
            <span class="s0">if (maybe_ints == values).all():</span>
                <span class="s0">return (maybe_ints, None)</span>
        <span class="s0">except (ValueError, OverflowError, TypeError):</span>
            <span class="s0">pass</span>

    <span class="s0"># Otherwise, iterate and do full inference.</span>
    <span class="s0">cdef:</span>
        <span class="s0">int status, maybe_int</span>
        <span class="s0">Py_ssize_t i, n = values.size</span>
        <span class="s0">Seen seen = Seen(coerce_numeric)</span>
        <span class="s0">ndarray[float64_t, ndim=1] floats = np.empty(n, dtype='f8')</span>
        <span class="s0">ndarray[complex128_t, ndim=1] complexes = np.empty(n, dtype='c16')</span>
        <span class="s0">ndarray[int64_t, ndim=1] ints = np.empty(n, dtype='i8')</span>
        <span class="s0">ndarray[uint64_t, ndim=1] uints = np.empty(n, dtype='u8')</span>
        <span class="s0">ndarray[uint8_t, ndim=1] bools = np.empty(n, dtype='u1')</span>
        <span class="s0">ndarray[uint8_t, ndim=1] mask = np.zeros(n, dtype=&quot;u1&quot;)</span>
        <span class="s0">float64_t fval</span>
        <span class="s0">bint allow_null_in_int = convert_to_masked_nullable</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">val = values[i]</span>
        <span class="s0"># We only want to disable NaNs showing as float if</span>
        <span class="s0"># a) convert_to_masked_nullable = True</span>
        <span class="s0"># b) no floats have been seen ( assuming an int shows up later )</span>
        <span class="s0"># However, if no ints present (all null array), we need to return floats</span>
        <span class="s0">allow_null_in_int = convert_to_masked_nullable and not seen.float_</span>

        <span class="s0">if val.__hash__ is not None and val in na_values:</span>
            <span class="s0">if allow_null_in_int:</span>
                <span class="s0">seen.null_ = True</span>
                <span class="s0">mask[i] = 1</span>
            <span class="s0">else:</span>
                <span class="s0">if convert_to_masked_nullable:</span>
                    <span class="s0">mask[i] = 1</span>
                <span class="s0">seen.saw_null()</span>
            <span class="s0">floats[i] = complexes[i] = NaN</span>
        <span class="s0">elif util.is_float_object(val):</span>
            <span class="s0">fval = val</span>
            <span class="s0">if fval != fval:</span>
                <span class="s0">seen.null_ = True</span>
                <span class="s0">if allow_null_in_int:</span>
                    <span class="s0">mask[i] = 1</span>
                <span class="s0">else:</span>
                    <span class="s0">if convert_to_masked_nullable:</span>
                        <span class="s0">mask[i] = 1</span>
                    <span class="s0">seen.float_ = True</span>
            <span class="s0">else:</span>
                <span class="s0">seen.float_ = True</span>
            <span class="s0">floats[i] = complexes[i] = fval</span>
        <span class="s0">elif util.is_integer_object(val):</span>
            <span class="s0">floats[i] = complexes[i] = val</span>

            <span class="s0">val = int(val)</span>
            <span class="s0">seen.saw_int(val)</span>

            <span class="s0">if val &gt;= 0:</span>
                <span class="s0">if val &lt;= oUINT64_MAX:</span>
                    <span class="s0">uints[i] = val</span>
                <span class="s0">else:</span>
                    <span class="s0">seen.float_ = True</span>

            <span class="s0">if oINT64_MIN &lt;= val &lt;= oINT64_MAX:</span>
                <span class="s0">ints[i] = val</span>

            <span class="s0">if val &lt; oINT64_MIN or (seen.sint_ and seen.uint_):</span>
                <span class="s0">seen.float_ = True</span>

        <span class="s0">elif util.is_bool_object(val):</span>
            <span class="s0">floats[i] = uints[i] = ints[i] = bools[i] = val</span>
            <span class="s0">seen.bool_ = True</span>
        <span class="s0">elif val is None or val is C_NA:</span>
            <span class="s0">if allow_null_in_int:</span>
                <span class="s0">seen.null_ = True</span>
                <span class="s0">mask[i] = 1</span>
            <span class="s0">else:</span>
                <span class="s0">if convert_to_masked_nullable:</span>
                    <span class="s0">mask[i] = 1</span>
                <span class="s0">seen.saw_null()</span>
            <span class="s0">floats[i] = complexes[i] = NaN</span>
        <span class="s0">elif hasattr(val, '__len__') and len(val) == 0:</span>
            <span class="s0">if convert_empty or seen.coerce_numeric:</span>
                <span class="s0">seen.saw_null()</span>
                <span class="s0">floats[i] = complexes[i] = NaN</span>
            <span class="s0">else:</span>
                <span class="s0">raise ValueError(&quot;Empty string encountered&quot;)</span>
        <span class="s0">elif util.is_complex_object(val):</span>
            <span class="s0">complexes[i] = val</span>
            <span class="s0">seen.complex_ = True</span>
        <span class="s0">elif is_decimal(val):</span>
            <span class="s0">floats[i] = complexes[i] = val</span>
            <span class="s0">seen.float_ = True</span>
        <span class="s0">else:</span>
            <span class="s0">try:</span>
                <span class="s0">status = floatify(val, &amp;fval, &amp;maybe_int)</span>

                <span class="s0">if fval in na_values:</span>
                    <span class="s0">seen.saw_null()</span>
                    <span class="s0">floats[i] = complexes[i] = NaN</span>
                    <span class="s0">mask[i] = 1</span>
                <span class="s0">else:</span>
                    <span class="s0">if fval != fval:</span>
                        <span class="s0">seen.null_ = True</span>
                        <span class="s0">mask[i] = 1</span>

                    <span class="s0">floats[i] = fval</span>

                <span class="s0">if maybe_int:</span>
                    <span class="s0">as_int = int(val)</span>

                    <span class="s0">if as_int in na_values:</span>
                        <span class="s0">mask[i] = 1</span>
                        <span class="s0">seen.null_ = True</span>
                        <span class="s0">if not allow_null_in_int:</span>
                            <span class="s0">seen.float_ = True</span>
                    <span class="s0">else:</span>
                        <span class="s0">seen.saw_int(as_int)</span>

                    <span class="s0">if as_int not in na_values:</span>
                        <span class="s0">if as_int &lt; oINT64_MIN or as_int &gt; oUINT64_MAX:</span>
                            <span class="s0">if seen.coerce_numeric:</span>
                                <span class="s0">seen.float_ = True</span>
                            <span class="s0">else:</span>
                                <span class="s0">raise ValueError(&quot;Integer out of range.&quot;)</span>
                        <span class="s0">else:</span>
                            <span class="s0">if as_int &gt;= 0:</span>
                                <span class="s0">uints[i] = as_int</span>

                            <span class="s0">if as_int &lt;= oINT64_MAX:</span>
                                <span class="s0">ints[i] = as_int</span>

                    <span class="s0">seen.float_ = seen.float_ or (seen.uint_ and seen.sint_)</span>
                <span class="s0">else:</span>
                    <span class="s0">seen.float_ = True</span>
            <span class="s0">except (TypeError, ValueError) as err:</span>
                <span class="s0">if not seen.coerce_numeric:</span>
                    <span class="s0">raise type(err)(f&quot;{err} at position {i}&quot;)</span>

                <span class="s0">seen.saw_null()</span>
                <span class="s0">floats[i] = NaN</span>

    <span class="s0">if seen.check_uint64_conflict():</span>
        <span class="s0">return (values, None)</span>

    <span class="s0"># This occurs since we disabled float nulls showing as null in anticipation</span>
    <span class="s0"># of seeing ints that were never seen. So then, we return float</span>
    <span class="s0">if allow_null_in_int and seen.null_ and not seen.int_:</span>
        <span class="s0">seen.float_ = True</span>

    <span class="s0">if seen.complex_:</span>
        <span class="s0">return (complexes, None)</span>
    <span class="s0">elif seen.float_:</span>
        <span class="s0">if seen.null_ and convert_to_masked_nullable:</span>
            <span class="s0">return (floats, mask.view(np.bool_))</span>
        <span class="s0">return (floats, None)</span>
    <span class="s0">elif seen.int_:</span>
        <span class="s0">if seen.null_ and convert_to_masked_nullable:</span>
            <span class="s0">if seen.uint_:</span>
                <span class="s0">return (uints, mask.view(np.bool_))</span>
            <span class="s0">else:</span>
                <span class="s0">return (ints, mask.view(np.bool_))</span>
        <span class="s0">if seen.uint_:</span>
            <span class="s0">return (uints, None)</span>
        <span class="s0">else:</span>
            <span class="s0">return (ints, None)</span>
    <span class="s0">elif seen.bool_:</span>
        <span class="s0">return (bools.view(np.bool_), None)</span>
    <span class="s0">elif seen.uint_:</span>
        <span class="s0">return (uints, None)</span>
    <span class="s0">return (ints, None)</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def maybe_convert_objects(ndarray[object] objects,</span>
                          <span class="s0">*,</span>
                          <span class="s0">bint try_float=False,</span>
                          <span class="s0">bint safe=False,</span>
                          <span class="s0">bint convert_datetime=False,</span>
                          <span class="s0">bint convert_timedelta=False,</span>
                          <span class="s0">bint convert_period=False,</span>
                          <span class="s0">bint convert_interval=False,</span>
                          <span class="s0">bint convert_to_nullable_integer=False,</span>
                          <span class="s0">object dtype_if_all_nat=None) -&gt; &quot;ArrayLike&quot;:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Type inference function-- convert object array to proper dtype</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">objects : ndarray[object]</span>
        <span class="s0">Array of object elements to convert.</span>
    <span class="s0">try_float : bool, default False</span>
        <span class="s0">If an array-like object contains only float or NaN values is</span>
        <span class="s0">encountered, whether to convert and return an array of float dtype.</span>
    <span class="s0">safe : bool, default False</span>
        <span class="s0">Whether to upcast numeric type (e.g. int cast to float). If set to</span>
        <span class="s0">True, no upcasting will be performed.</span>
    <span class="s0">convert_datetime : bool, default False</span>
        <span class="s0">If an array-like object contains only datetime values or NaT is</span>
        <span class="s0">encountered, whether to convert and return an array of M8[ns] dtype.</span>
    <span class="s0">convert_timedelta : bool, default False</span>
        <span class="s0">If an array-like object contains only timedelta values or NaT is</span>
        <span class="s0">encountered, whether to convert and return an array of m8[ns] dtype.</span>
    <span class="s0">convert_period : bool, default False</span>
        <span class="s0">If an array-like object contains only (homogeneous-freq) Period values</span>
        <span class="s0">or NaT, whether to convert and return a PeriodArray.</span>
    <span class="s0">convert_interval : bool, default False</span>
        <span class="s0">If an array-like object contains only Interval objects (with matching</span>
        <span class="s0">dtypes and closedness) or NaN, whether to convert to IntervalArray.</span>
    <span class="s0">convert_to_nullable_integer : bool, default False</span>
        <span class="s0">If an array-like object contains only integer values (and NaN) is</span>
        <span class="s0">encountered, whether to convert and return an IntegerArray.</span>
    <span class="s0">dtype_if_all_nat : np.dtype, ExtensionDtype, or None, default None</span>
        <span class="s0">Dtype to cast to if we have all-NaT.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">np.ndarray or ExtensionArray</span>
        <span class="s0">Array of converted object values to more specific dtypes if applicable.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n, itemsize_max = 0</span>
        <span class="s0">ndarray[float64_t] floats</span>
        <span class="s0">ndarray[complex128_t] complexes</span>
        <span class="s0">ndarray[int64_t] ints</span>
        <span class="s0">ndarray[uint64_t] uints</span>
        <span class="s0">ndarray[uint8_t] bools</span>
        <span class="s0">int64_t[:]  idatetimes</span>
        <span class="s0">int64_t[:] itimedeltas</span>
        <span class="s0">Seen seen = Seen()</span>
        <span class="s0">object val</span>
        <span class="s0">float64_t fval, fnan = np.nan</span>

    <span class="s0">n = len(objects)</span>

    <span class="s0">floats = np.empty(n, dtype='f8')</span>
    <span class="s0">complexes = np.empty(n, dtype='c16')</span>
    <span class="s0">ints = np.empty(n, dtype='i8')</span>
    <span class="s0">uints = np.empty(n, dtype='u8')</span>
    <span class="s0">bools = np.empty(n, dtype=np.uint8)</span>
    <span class="s0">mask = np.full(n, False)</span>

    <span class="s0">if convert_datetime:</span>
        <span class="s0">datetimes = np.empty(n, dtype='M8[ns]')</span>
        <span class="s0">idatetimes = datetimes.view(np.int64)</span>

    <span class="s0">if convert_timedelta:</span>
        <span class="s0">timedeltas = np.empty(n, dtype='m8[ns]')</span>
        <span class="s0">itimedeltas = timedeltas.view(np.int64)</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">val = objects[i]</span>
        <span class="s0">if itemsize_max != -1:</span>
            <span class="s0">itemsize = get_itemsize(val)</span>
            <span class="s0">if itemsize &gt; itemsize_max or itemsize == -1:</span>
                <span class="s0">itemsize_max = itemsize</span>

        <span class="s0">if val is None:</span>
            <span class="s0">seen.null_ = True</span>
            <span class="s0">floats[i] = complexes[i] = fnan</span>
            <span class="s0">mask[i] = True</span>
        <span class="s0">elif val is NaT:</span>
            <span class="s0">seen.nat_ = True</span>
            <span class="s0">if convert_datetime:</span>
                <span class="s0">idatetimes[i] = NPY_NAT</span>
            <span class="s0">if convert_timedelta:</span>
                <span class="s0">itimedeltas[i] = NPY_NAT</span>
            <span class="s0">if not (convert_datetime or convert_timedelta or convert_period):</span>
                <span class="s0">seen.object_ = True</span>
                <span class="s0">break</span>
        <span class="s0">elif val is np.nan:</span>
            <span class="s0">seen.nan_ = True</span>
            <span class="s0">mask[i] = True</span>
            <span class="s0">floats[i] = complexes[i] = val</span>
        <span class="s0">elif util.is_bool_object(val):</span>
            <span class="s0">seen.bool_ = True</span>
            <span class="s0">bools[i] = val</span>
        <span class="s0">elif util.is_float_object(val):</span>
            <span class="s0">floats[i] = complexes[i] = val</span>
            <span class="s0">seen.float_ = True</span>
        <span class="s0">elif is_timedelta(val):</span>
            <span class="s0">if convert_timedelta:</span>
                <span class="s0">seen.timedelta_ = True</span>
                <span class="s0">try:</span>
                    <span class="s0">itimedeltas[i] = convert_to_timedelta64(val, &quot;ns&quot;).view(&quot;i8&quot;)</span>
                <span class="s0">except OutOfBoundsTimedelta:</span>
                    <span class="s0">seen.object_ = True</span>
                    <span class="s0">break</span>
                <span class="s0">break</span>
            <span class="s0">else:</span>
                <span class="s0">seen.object_ = True</span>
                <span class="s0">break</span>
        <span class="s0">elif util.is_integer_object(val):</span>
            <span class="s0">seen.int_ = True</span>
            <span class="s0">floats[i] = &lt;float64_t&gt;val</span>
            <span class="s0">complexes[i] = &lt;double complex&gt;val</span>
            <span class="s0">if not seen.null_:</span>
                <span class="s0">val = int(val)</span>
                <span class="s0">seen.saw_int(val)</span>

                <span class="s0">if ((seen.uint_ and seen.sint_) or</span>
                        <span class="s0">val &gt; oUINT64_MAX or val &lt; oINT64_MIN):</span>
                    <span class="s0">seen.object_ = True</span>
                    <span class="s0">break</span>

                <span class="s0">if seen.uint_:</span>
                    <span class="s0">uints[i] = val</span>
                <span class="s0">elif seen.sint_:</span>
                    <span class="s0">ints[i] = val</span>
                <span class="s0">else:</span>
                    <span class="s0">uints[i] = val</span>
                    <span class="s0">ints[i] = val</span>

        <span class="s0">elif util.is_complex_object(val):</span>
            <span class="s0">complexes[i] = val</span>
            <span class="s0">seen.complex_ = True</span>
        <span class="s0">elif PyDateTime_Check(val) or util.is_datetime64_object(val):</span>

            <span class="s0"># if we have an tz's attached then return the objects</span>
            <span class="s0">if convert_datetime:</span>
                <span class="s0">if getattr(val, 'tzinfo', None) is not None:</span>
                    <span class="s0">seen.datetimetz_ = True</span>
                    <span class="s0">break</span>
                <span class="s0">else:</span>
                    <span class="s0">seen.datetime_ = True</span>
                    <span class="s0">try:</span>
                        <span class="s0">idatetimes[i] = convert_to_tsobject(</span>
                            <span class="s0">val, None, None, 0, 0).value</span>
                    <span class="s0">except OutOfBoundsDatetime:</span>
                        <span class="s0">seen.object_ = True</span>
                        <span class="s0">break</span>
            <span class="s0">else:</span>
                <span class="s0">seen.object_ = True</span>
                <span class="s0">break</span>
        <span class="s0">elif is_period_object(val):</span>
            <span class="s0">if convert_period:</span>
                <span class="s0">seen.period_ = True</span>
                <span class="s0">break</span>
            <span class="s0">else:</span>
                <span class="s0">seen.object_ = True</span>
                <span class="s0">break</span>
        <span class="s0">elif try_float and not isinstance(val, str):</span>
            <span class="s0"># this will convert Decimal objects</span>
            <span class="s0">try:</span>
                <span class="s0">floats[i] = float(val)</span>
                <span class="s0">complexes[i] = complex(val)</span>
                <span class="s0">seen.float_ = True</span>
            <span class="s0">except (ValueError, TypeError):</span>
                <span class="s0">seen.object_ = True</span>
                <span class="s0">break</span>
        <span class="s0">elif is_interval(val):</span>
            <span class="s0">if convert_interval:</span>
                <span class="s0">seen.interval_ = True</span>
                <span class="s0">break</span>
            <span class="s0">else:</span>
                <span class="s0">seen.object_ = True</span>
                <span class="s0">break</span>
        <span class="s0">else:</span>
            <span class="s0">seen.object_ = True</span>
            <span class="s0">break</span>

    <span class="s0"># we try to coerce datetime w/tz but must all have the same tz</span>
    <span class="s0">if seen.datetimetz_:</span>
        <span class="s0">if is_datetime_with_singletz_array(objects):</span>
            <span class="s0">from pandas import DatetimeIndex</span>
            <span class="s0">dti = DatetimeIndex(objects)</span>

            <span class="s0"># unbox to DatetimeArray</span>
            <span class="s0">return dti._data</span>
        <span class="s0">seen.object_ = True</span>

    <span class="s0">elif seen.datetime_:</span>
        <span class="s0">if is_datetime_or_datetime64_array(objects):</span>
            <span class="s0">from pandas import DatetimeIndex</span>

            <span class="s0">try:</span>
                <span class="s0">dti = DatetimeIndex(objects)</span>
            <span class="s0">except OutOfBoundsDatetime:</span>
                <span class="s0">pass</span>
            <span class="s0">else:</span>
                <span class="s0"># unbox to ndarray[datetime64[ns]]</span>
                <span class="s0">return dti._data._ndarray</span>
        <span class="s0">seen.object_ = True</span>

    <span class="s0">elif seen.timedelta_:</span>
        <span class="s0">if is_timedelta_or_timedelta64_array(objects):</span>
            <span class="s0">from pandas import TimedeltaIndex</span>

            <span class="s0">try:</span>
                <span class="s0">tdi = TimedeltaIndex(objects)</span>
            <span class="s0">except OutOfBoundsTimedelta:</span>
                <span class="s0">pass</span>
            <span class="s0">else:</span>
                <span class="s0"># unbox to ndarray[timedelta64[ns]]</span>
                <span class="s0">return tdi._data._ndarray</span>
        <span class="s0">seen.object_ = True</span>

    <span class="s0">if seen.period_:</span>
        <span class="s0">if is_period_array(objects):</span>
            <span class="s0">from pandas import PeriodIndex</span>
            <span class="s0">pi = PeriodIndex(objects)</span>

            <span class="s0"># unbox to PeriodArray</span>
            <span class="s0">return pi._data</span>
        <span class="s0">seen.object_ = True</span>

    <span class="s0">if seen.interval_:</span>
        <span class="s0">if is_interval_array(objects):</span>
            <span class="s0">from pandas import IntervalIndex</span>
            <span class="s0">ii = IntervalIndex(objects)</span>

            <span class="s0"># unbox to IntervalArray</span>
            <span class="s0">return ii._data</span>

        <span class="s0">seen.object_ = True</span>

    <span class="s0">if not seen.object_:</span>
        <span class="s0">result = None</span>
        <span class="s0">if not safe:</span>
            <span class="s0">if seen.null_ or seen.nan_:</span>
                <span class="s0">if seen.is_float_or_complex:</span>
                    <span class="s0">if seen.complex_:</span>
                        <span class="s0">result = complexes</span>
                    <span class="s0">elif seen.float_:</span>
                        <span class="s0">result = floats</span>
                    <span class="s0">elif seen.int_:</span>
                        <span class="s0">if convert_to_nullable_integer:</span>
                            <span class="s0">from pandas.core.arrays import IntegerArray</span>
                            <span class="s0">result = IntegerArray(ints, mask)</span>
                        <span class="s0">else:</span>
                            <span class="s0">result = floats</span>
                    <span class="s0">elif seen.nan_:</span>
                        <span class="s0">result = floats</span>
            <span class="s0">else:</span>
                <span class="s0">if not seen.bool_:</span>
                    <span class="s0">if seen.datetime_:</span>
                        <span class="s0">if not seen.numeric_ and not seen.timedelta_:</span>
                            <span class="s0">result = datetimes</span>
                    <span class="s0">elif seen.timedelta_:</span>
                        <span class="s0">if not seen.numeric_:</span>
                            <span class="s0">result = timedeltas</span>
                    <span class="s0">elif seen.nat_:</span>
                        <span class="s0">if not seen.numeric_:</span>
                            <span class="s0">if convert_datetime and convert_timedelta:</span>
                                <span class="s0">dtype = dtype_if_all_nat</span>
                                <span class="s0">if dtype is not None:</span>
                                    <span class="s0"># otherwise we keep object dtype</span>
                                    <span class="s0">result = _infer_all_nats(</span>
                                        <span class="s0">dtype, datetimes, timedeltas</span>
                                    <span class="s0">)</span>

                            <span class="s0">elif convert_datetime:</span>
                                <span class="s0">result = datetimes</span>
                            <span class="s0">elif convert_timedelta:</span>
                                <span class="s0">result = timedeltas</span>
                    <span class="s0">else:</span>
                        <span class="s0">if seen.complex_:</span>
                            <span class="s0">result = complexes</span>
                        <span class="s0">elif seen.float_:</span>
                            <span class="s0">result = floats</span>
                        <span class="s0">elif seen.int_:</span>
                            <span class="s0">if seen.uint_:</span>
                                <span class="s0">result = uints</span>
                            <span class="s0">else:</span>
                                <span class="s0">result = ints</span>
                <span class="s0">elif seen.is_bool:</span>
                    <span class="s0">result = bools.view(np.bool_)</span>

        <span class="s0">else:</span>
            <span class="s0"># don't cast int to float, etc.</span>
            <span class="s0">if seen.null_:</span>
                <span class="s0">if seen.is_float_or_complex:</span>
                    <span class="s0">if seen.complex_:</span>
                        <span class="s0">if not seen.int_:</span>
                            <span class="s0">result = complexes</span>
                    <span class="s0">elif seen.float_ or seen.nan_:</span>
                        <span class="s0">if not seen.int_:</span>
                            <span class="s0">result = floats</span>
            <span class="s0">else:</span>
                <span class="s0">if not seen.bool_:</span>
                    <span class="s0">if seen.datetime_:</span>
                        <span class="s0">if not seen.numeric_ and not seen.timedelta_:</span>
                            <span class="s0">result = datetimes</span>
                    <span class="s0">elif seen.timedelta_:</span>
                        <span class="s0">if not seen.numeric_:</span>
                            <span class="s0">result = timedeltas</span>
                    <span class="s0">elif seen.nat_:</span>
                        <span class="s0">if not seen.numeric_:</span>
                            <span class="s0">if convert_datetime and convert_timedelta:</span>
                                <span class="s0">dtype = dtype_if_all_nat</span>
                                <span class="s0">if dtype is not None:</span>
                                    <span class="s0"># otherwise we keep object dtype</span>
                                    <span class="s0">result = _infer_all_nats(</span>
                                        <span class="s0">dtype, datetimes, timedeltas</span>
                                    <span class="s0">)</span>

                            <span class="s0">elif convert_datetime:</span>
                                <span class="s0">result = datetimes</span>
                            <span class="s0">elif convert_timedelta:</span>
                                <span class="s0">result = timedeltas</span>
                    <span class="s0">else:</span>
                        <span class="s0">if seen.complex_:</span>
                            <span class="s0">if not seen.int_:</span>
                                <span class="s0">result = complexes</span>
                        <span class="s0">elif seen.float_ or seen.nan_:</span>
                            <span class="s0">if not seen.int_:</span>
                                <span class="s0">result = floats</span>
                        <span class="s0">elif seen.int_:</span>
                            <span class="s0">if seen.uint_:</span>
                                <span class="s0">result = uints</span>
                            <span class="s0">else:</span>
                                <span class="s0">result = ints</span>
                <span class="s0">elif seen.is_bool and not seen.nan_:</span>
                    <span class="s0">result = bools.view(np.bool_)</span>

        <span class="s0">if result is uints or result is ints or result is floats or result is complexes:</span>
            <span class="s0"># cast to the largest itemsize when all values are NumPy scalars</span>
            <span class="s0">if itemsize_max &gt; 0 and itemsize_max != result.dtype.itemsize:</span>
                <span class="s0">result = result.astype(result.dtype.kind + str(itemsize_max))</span>
            <span class="s0">return result</span>
        <span class="s0">elif result is not None:</span>
            <span class="s0">return result</span>

    <span class="s0">return objects</span>


<span class="s0">cdef _infer_all_nats(dtype, ndarray datetimes, ndarray timedeltas):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">If we have all-NaT values, cast these to the given dtype.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if cnp.PyArray_DescrCheck(dtype):</span>
        <span class="s0"># i.e. isinstance(dtype, np.dtype):</span>
        <span class="s0">if dtype == &quot;M8[ns]&quot;:</span>
            <span class="s0">result = datetimes</span>
        <span class="s0">elif dtype == &quot;m8[ns]&quot;:</span>
            <span class="s0">result = timedeltas</span>
        <span class="s0">else:</span>
            <span class="s0">raise ValueError(dtype)</span>
    <span class="s0">else:</span>
        <span class="s0"># ExtensionDtype</span>
        <span class="s0">cls = dtype.construct_array_type()</span>
        <span class="s0">i8vals = np.empty(len(datetimes), dtype=&quot;i8&quot;)</span>
        <span class="s0">i8vals.fill(NPY_NAT)</span>
        <span class="s0">result = cls(i8vals, dtype=dtype)</span>
    <span class="s0">return result</span>


<span class="s0">class NoDefault(Enum):</span>
    <span class="s0"># We make this an Enum</span>
    <span class="s0"># 1) because it round-trips through pickle correctly (see GH#40397)</span>
    <span class="s0"># 2) because mypy does not understand singletons</span>
    <span class="s0">no_default = &quot;NO_DEFAULT&quot;</span>

    <span class="s0">def __repr__(self) -&gt; str:</span>
        <span class="s0">return &quot;&lt;no_default&gt;&quot;</span>


<span class="s0"># Note: no_default is exported to the public API in pandas.api.extensions</span>
<span class="s0">no_default = NoDefault.no_default  # Sentinel indicating the default value.</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def map_infer_mask(ndarray arr, object f, const uint8_t[:] mask, bint convert=True,</span>
                   <span class="s0">object na_value=no_default, cnp.dtype dtype=np.dtype(object)</span>
                   <span class="s0">) -&gt; np.ndarray:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Substitute for np.vectorize with pandas-friendly dtype inference.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">arr : ndarray</span>
    <span class="s0">f : function</span>
    <span class="s0">mask : ndarray</span>
        <span class="s0">uint8 dtype ndarray indicating values not to apply `f` to.</span>
    <span class="s0">convert : bool, default True</span>
        <span class="s0">Whether to call `maybe_convert_objects` on the resulting ndarray</span>
    <span class="s0">na_value : Any, optional</span>
        <span class="s0">The result value to use for masked values. By default, the</span>
        <span class="s0">input value is used</span>
    <span class="s0">dtype : numpy.dtype</span>
        <span class="s0">The numpy dtype to use for the result ndarray.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">np.ndarray</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n</span>
        <span class="s0">ndarray result</span>
        <span class="s0">object val</span>

    <span class="s0">n = len(arr)</span>
    <span class="s0">result = np.empty(n, dtype=dtype)</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">if mask[i]:</span>
            <span class="s0">if na_value is no_default:</span>
                <span class="s0">val = arr[i]</span>
            <span class="s0">else:</span>
                <span class="s0">val = na_value</span>
        <span class="s0">else:</span>
            <span class="s0">val = f(arr[i])</span>

            <span class="s0">if cnp.PyArray_IsZeroDim(val):</span>
                <span class="s0"># unbox 0-dim arrays, GH#690</span>
                <span class="s0">val = val.item()</span>

        <span class="s0">result[i] = val</span>

    <span class="s0">if convert:</span>
        <span class="s0">return maybe_convert_objects(result,</span>
                                     <span class="s0">try_float=False,</span>
                                     <span class="s0">convert_datetime=False,</span>
                                     <span class="s0">convert_timedelta=False)</span>

    <span class="s0">return result</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def map_infer(</span>
    <span class="s0">ndarray arr, object f, bint convert=True, bint ignore_na=False</span>
<span class="s0">) -&gt; np.ndarray:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Substitute for np.vectorize with pandas-friendly dtype inference.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">arr : ndarray</span>
    <span class="s0">f : function</span>
    <span class="s0">convert : bint</span>
    <span class="s0">ignore_na : bint</span>
        <span class="s0">If True, NA values will not have f applied</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">np.ndarray</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n</span>
        <span class="s0">ndarray[object] result</span>
        <span class="s0">object val</span>

    <span class="s0">n = len(arr)</span>
    <span class="s0">result = np.empty(n, dtype=object)</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">if ignore_na and checknull(arr[i]):</span>
            <span class="s0">result[i] = arr[i]</span>
            <span class="s0">continue</span>
        <span class="s0">val = f(arr[i])</span>

        <span class="s0">if cnp.PyArray_IsZeroDim(val):</span>
            <span class="s0"># unbox 0-dim arrays, GH#690</span>
            <span class="s0">val = val.item()</span>

        <span class="s0">result[i] = val</span>

    <span class="s0">if convert:</span>
        <span class="s0">return maybe_convert_objects(result,</span>
                                     <span class="s0">try_float=False,</span>
                                     <span class="s0">convert_datetime=False,</span>
                                     <span class="s0">convert_timedelta=False)</span>

    <span class="s0">return result</span>


<span class="s0">def to_object_array(rows: object, min_width: int = 0) -&gt; ndarray:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Convert a list of lists into an object array.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">rows : 2-d array (N, K)</span>
        <span class="s0">List of lists to be converted into an array.</span>
    <span class="s0">min_width : int</span>
        <span class="s0">Minimum width of the object array. If a list</span>
        <span class="s0">in `rows` contains fewer than `width` elements,</span>
        <span class="s0">the remaining elements in the corresponding row</span>
        <span class="s0">will all be `NaN`.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">np.ndarray[object, ndim=2]</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, n, k, tmp</span>
        <span class="s0">ndarray[object, ndim=2] result</span>
        <span class="s0">list row</span>

    <span class="s0">rows = list(rows)</span>
    <span class="s0">n = len(rows)</span>

    <span class="s0">k = min_width</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">tmp = len(rows[i])</span>
        <span class="s0">if tmp &gt; k:</span>
            <span class="s0">k = tmp</span>

    <span class="s0">result = np.empty((n, k), dtype=object)</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">row = list(rows[i])</span>

        <span class="s0">for j in range(len(row)):</span>
            <span class="s0">result[i, j] = row[j]</span>

    <span class="s0">return result</span>


<span class="s0">def tuples_to_object_array(ndarray[object] tuples):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, n, k, tmp</span>
        <span class="s0">ndarray[object, ndim=2] result</span>
        <span class="s0">tuple tup</span>

    <span class="s0">n = len(tuples)</span>
    <span class="s0">k = len(tuples[0])</span>
    <span class="s0">result = np.empty((n, k), dtype=object)</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">tup = tuples[i]</span>
        <span class="s0">for j in range(k):</span>
            <span class="s0">result[i, j] = tup[j]</span>

    <span class="s0">return result</span>


<span class="s0">def to_object_array_tuples(rows: object) -&gt; np.ndarray:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Convert a list of tuples into an object array. Any subclass of</span>
    <span class="s0">tuple in `rows` will be casted to tuple.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">rows : 2-d array (N, K)</span>
        <span class="s0">List of tuples to be converted into an array.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">np.ndarray[object, ndim=2]</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, n, k, tmp</span>
        <span class="s0">ndarray[object, ndim=2] result</span>
        <span class="s0">tuple row</span>

    <span class="s0">rows = list(rows)</span>
    <span class="s0">n = len(rows)</span>

    <span class="s0">k = 0</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">tmp = 1 if checknull(rows[i]) else len(rows[i])</span>
        <span class="s0">if tmp &gt; k:</span>
            <span class="s0">k = tmp</span>

    <span class="s0">result = np.empty((n, k), dtype=object)</span>

    <span class="s0">try:</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">row = rows[i]</span>
            <span class="s0">for j in range(len(row)):</span>
                <span class="s0">result[i, j] = row[j]</span>
    <span class="s0">except TypeError:</span>
        <span class="s0"># e.g. &quot;Expected tuple, got list&quot;</span>
        <span class="s0"># upcast any subclasses to tuple</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">row = (rows[i],) if checknull(rows[i]) else tuple(rows[i])</span>
            <span class="s0">for j in range(len(row)):</span>
                <span class="s0">result[i, j] = row[j]</span>

    <span class="s0">return result</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def fast_multiget(dict mapping, ndarray keys, default=np.nan) -&gt; np.ndarray:</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(keys)</span>
        <span class="s0">object val</span>
        <span class="s0">ndarray[object] output = np.empty(n, dtype='O')</span>

    <span class="s0">if n == 0:</span>
        <span class="s0"># kludge, for Series</span>
        <span class="s0">return np.empty(0, dtype='f8')</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">val = keys[i]</span>
        <span class="s0">if val in mapping:</span>
            <span class="s0">output[i] = mapping[val]</span>
        <span class="s0">else:</span>
            <span class="s0">output[i] = default</span>

    <span class="s0">return maybe_convert_objects(output)</span>


<span class="s0">def is_bool_list(obj: list) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Check if this list contains only bool or np.bool_ objects.</span>

    <span class="s0">This is appreciably faster than checking `np.array(obj).dtype == bool`</span>

    <span class="s0">obj1 = [True, False] * 100</span>
    <span class="s0">obj2 = obj1 * 100</span>
    <span class="s0">obj3 = obj2 * 100</span>
    <span class="s0">obj4 = [True, None] + obj1</span>

    <span class="s0">for obj in [obj1, obj2, obj3, obj4]:</span>
        <span class="s0">%timeit is_bool_list(obj)</span>
        <span class="s0">%timeit np.array(obj).dtype.kind == &quot;b&quot;</span>

    <span class="s0">340 ns ± 8.22 ns</span>
    <span class="s0">8.78 µs ± 253 ns</span>

    <span class="s0">28.8 µs ± 704 ns</span>
    <span class="s0">813 µs ± 17.8 µs</span>

    <span class="s0">3.4 ms ± 168 µs</span>
    <span class="s0">78.4 ms ± 1.05 ms</span>

    <span class="s0">48.1 ns ± 1.26 ns</span>
    <span class="s0">8.1 µs ± 198 ns</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">object item</span>

    <span class="s0">for item in obj:</span>
        <span class="s0">if not util.is_bool_object(item):</span>
            <span class="s0">return False</span>

    <span class="s0"># Note: we return True for empty list</span>
    <span class="s0">return True</span>


<span class="s0">cpdef ndarray eq_NA_compat(ndarray[object] arr, object key):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Check for `arr == key`, treating all values as not-equal to pd.NA.</span>

    <span class="s0">key is assumed to have `not isna(key)`</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">ndarray[uint8_t, cast=True] result = np.empty(len(arr), dtype=bool)</span>
        <span class="s0">Py_ssize_t i</span>
        <span class="s0">object item</span>

    <span class="s0">for i in range(len(arr)):</span>
        <span class="s0">item = arr[i]</span>
        <span class="s0">if item is C_NA:</span>
            <span class="s0">result[i] = False</span>
        <span class="s0">else:</span>
            <span class="s0">result[i] = item == key</span>

    <span class="s0">return result</span>


<span class="s0">def dtypes_all_equal(list types not None) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Faster version for:</span>

    <span class="s0">first = types[0]</span>
    <span class="s0">all(is_dtype_equal(first, t) for t in types[1:])</span>

    <span class="s0">And assuming all elements in the list are np.dtype/ExtensionDtype objects</span>

    <span class="s0">See timings at https://github.com/pandas-dev/pandas/pull/44594</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">first = types[0]</span>
    <span class="s0">for t in types[1:]:</span>
        <span class="s0">try:</span>
            <span class="s0">if not t == first:</span>
                <span class="s0">return False</span>
        <span class="s0">except (TypeError, AttributeError):</span>
            <span class="s0">return False</span>
    <span class="s0">else:</span>
        <span class="s0">return True</span>
</pre>
</body>
</html>