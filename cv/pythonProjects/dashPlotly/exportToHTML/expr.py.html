<html>
<head>
<title>expr.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
expr.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
:func:`~pandas.eval` parsers. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">ast</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">partial</span><span class="s2">,</span>
    <span class="s1">reduce</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">keyword </span><span class="s2">import </span><span class="s1">iskeyword</span>
<span class="s2">import </span><span class="s1">tokenize</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">TypeVar</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">pandas.compat </span><span class="s2">import </span><span class="s1">PY39</span>

<span class="s2">import </span><span class="s1">pandas.core.common </span><span class="s2">as </span><span class="s1">com</span>
<span class="s2">from </span><span class="s1">pandas.core.computation.ops </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ARITH_OPS_SYMS</span><span class="s2">,</span>
    <span class="s1">BOOL_OPS_SYMS</span><span class="s2">,</span>
    <span class="s1">CMP_OPS_SYMS</span><span class="s2">,</span>
    <span class="s1">LOCAL_TAG</span><span class="s2">,</span>
    <span class="s1">MATHOPS</span><span class="s2">,</span>
    <span class="s1">REDUCTIONS</span><span class="s2">,</span>
    <span class="s1">UNARY_OPS_SYMS</span><span class="s2">,</span>
    <span class="s1">BinOp</span><span class="s2">,</span>
    <span class="s1">Constant</span><span class="s2">,</span>
    <span class="s1">Div</span><span class="s2">,</span>
    <span class="s1">FuncNode</span><span class="s2">,</span>
    <span class="s1">Op</span><span class="s2">,</span>
    <span class="s1">Term</span><span class="s2">,</span>
    <span class="s1">UnaryOp</span><span class="s2">,</span>
    <span class="s1">UndefinedVariableError</span><span class="s2">,</span>
    <span class="s1">is_term</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.computation.parsing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">clean_backtick_quoted_toks</span><span class="s2">,</span>
    <span class="s1">tokenize_string</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.computation.scope </span><span class="s2">import </span><span class="s1">Scope</span>

<span class="s2">import </span><span class="s1">pandas.io.formats.printing </span><span class="s2">as </span><span class="s1">printing</span>


<span class="s2">def </span><span class="s1">_rewrite_assign(tok: tuple[int</span><span class="s2">, </span><span class="s1">str]) -&gt; tuple[int</span><span class="s2">, </span><span class="s1">str]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Rewrite the assignment operator for PyTables expressions that use ``=`` 
    as a substitute for ``==``. 
 
    Parameters 
    ---------- 
    tok : tuple of int, str 
        ints correspond to the all caps constants in the tokenize module 
 
    Returns 
    ------- 
    tuple of int, str 
        Either the input or token or the replacement values 
    &quot;&quot;&quot;</span>
    <span class="s1">toknum</span><span class="s2">, </span><span class="s1">tokval = tok</span>
    <span class="s2">return </span><span class="s1">toknum</span><span class="s2">, </span><span class="s3">&quot;==&quot; </span><span class="s2">if </span><span class="s1">tokval == </span><span class="s3">&quot;=&quot; </span><span class="s2">else </span><span class="s1">tokval</span>


<span class="s2">def </span><span class="s1">_replace_booleans(tok: tuple[int</span><span class="s2">, </span><span class="s1">str]) -&gt; tuple[int</span><span class="s2">, </span><span class="s1">str]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Replace ``&amp;`` with ``and`` and ``|`` with ``or`` so that bitwise 
    precedence is changed to boolean precedence. 
 
    Parameters 
    ---------- 
    tok : tuple of int, str 
        ints correspond to the all caps constants in the tokenize module 
 
    Returns 
    ------- 
    tuple of int, str 
        Either the input or token or the replacement values 
    &quot;&quot;&quot;</span>
    <span class="s1">toknum</span><span class="s2">, </span><span class="s1">tokval = tok</span>
    <span class="s2">if </span><span class="s1">toknum == tokenize.OP:</span>
        <span class="s2">if </span><span class="s1">tokval == </span><span class="s3">&quot;&amp;&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">tokenize.NAME</span><span class="s2">, </span><span class="s3">&quot;and&quot;</span>
        <span class="s2">elif </span><span class="s1">tokval == </span><span class="s3">&quot;|&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">tokenize.NAME</span><span class="s2">, </span><span class="s3">&quot;or&quot;</span>
        <span class="s2">return </span><span class="s1">toknum</span><span class="s2">, </span><span class="s1">tokval</span>
    <span class="s2">return </span><span class="s1">toknum</span><span class="s2">, </span><span class="s1">tokval</span>


<span class="s2">def </span><span class="s1">_replace_locals(tok: tuple[int</span><span class="s2">, </span><span class="s1">str]) -&gt; tuple[int</span><span class="s2">, </span><span class="s1">str]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Replace local variables with a syntactically valid name. 
 
    Parameters 
    ---------- 
    tok : tuple of int, str 
        ints correspond to the all caps constants in the tokenize module 
 
    Returns 
    ------- 
    tuple of int, str 
        Either the input or token or the replacement values 
 
    Notes 
    ----- 
    This is somewhat of a hack in that we rewrite a string such as ``'@a'`` as 
    ``'__pd_eval_local_a'`` by telling the tokenizer that ``__pd_eval_local_`` 
    is a ``tokenize.OP`` and to replace the ``'@'`` symbol with it. 
    &quot;&quot;&quot;</span>
    <span class="s1">toknum</span><span class="s2">, </span><span class="s1">tokval = tok</span>
    <span class="s2">if </span><span class="s1">toknum == tokenize.OP </span><span class="s2">and </span><span class="s1">tokval == </span><span class="s3">&quot;@&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">tokenize.OP</span><span class="s2">, </span><span class="s1">LOCAL_TAG</span>
    <span class="s2">return </span><span class="s1">toknum</span><span class="s2">, </span><span class="s1">tokval</span>


<span class="s2">def </span><span class="s1">_compose2(f</span><span class="s2">, </span><span class="s1">g):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compose 2 callables. 
    &quot;&quot;&quot;</span>
    <span class="s2">return lambda </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs: f(g(*args</span><span class="s2">, </span><span class="s1">**kwargs))</span>


<span class="s2">def </span><span class="s1">_compose(*funcs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compose 2 or more callables. 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">len(funcs) &gt; </span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;At least 2 callables must be passed to compose&quot;</span>
    <span class="s2">return </span><span class="s1">reduce(_compose2</span><span class="s2">, </span><span class="s1">funcs)</span>


<span class="s2">def </span><span class="s1">_preparse(</span>
    <span class="s1">source: str</span><span class="s2">,</span>
    <span class="s1">f=_compose(</span>
        <span class="s1">_replace_locals</span><span class="s2">, </span><span class="s1">_replace_booleans</span><span class="s2">, </span><span class="s1">_rewrite_assign</span><span class="s2">, </span><span class="s1">clean_backtick_quoted_toks</span>
    <span class="s1">)</span><span class="s2">,</span>
<span class="s1">) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot; 
    Compose a collection of tokenization functions. 
 
    Parameters 
    ---------- 
    source : str 
        A Python source code string 
    f : callable 
        This takes a tuple of (toknum, tokval) as its argument and returns a 
        tuple with the same structure but possibly different elements. Defaults 
        to the composition of ``_rewrite_assign``, ``_replace_booleans``, and 
        ``_replace_locals``. 
 
    Returns 
    ------- 
    str 
        Valid Python source code 
 
    Notes 
    ----- 
    The `f` parameter can be any callable that takes *and* returns input of the 
    form ``(toknum, tokval)``, where ``toknum`` is one of the constants from 
    the ``tokenize`` module and ``tokval`` is a string. 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">callable(f)</span><span class="s2">, </span><span class="s3">&quot;f must be callable&quot;</span>
    <span class="s2">return </span><span class="s1">tokenize.untokenize(f(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">tokenize_string(source))</span>


<span class="s2">def </span><span class="s1">_is_type(t):</span>
    <span class="s0">&quot;&quot;&quot; 
    Factory for a type checking function of type ``t`` or tuple of types. 
    &quot;&quot;&quot;</span>
    <span class="s2">return lambda </span><span class="s1">x: isinstance(x.value</span><span class="s2">, </span><span class="s1">t)</span>


<span class="s1">_is_list = _is_type(list)</span>
<span class="s1">_is_str = _is_type(str)</span>


<span class="s5"># partition all AST nodes</span>
<span class="s1">_all_nodes = frozenset(</span>
    <span class="s1">node</span>
    <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">(getattr(ast</span><span class="s2">, </span><span class="s1">name) </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">dir(ast))</span>
    <span class="s2">if </span><span class="s1">isinstance(node</span><span class="s2">, </span><span class="s1">type) </span><span class="s2">and </span><span class="s1">issubclass(node</span><span class="s2">, </span><span class="s1">ast.AST)</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">_filter_nodes(superclass</span><span class="s2">, </span><span class="s1">all_nodes=_all_nodes):</span>
    <span class="s0">&quot;&quot;&quot; 
    Filter out AST nodes that are subclasses of ``superclass``. 
    &quot;&quot;&quot;</span>
    <span class="s1">node_names = (node.__name__ </span><span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">all_nodes </span><span class="s2">if </span><span class="s1">issubclass(node</span><span class="s2">, </span><span class="s1">superclass))</span>
    <span class="s2">return </span><span class="s1">frozenset(node_names)</span>


<span class="s1">_all_node_names = frozenset(map(</span><span class="s2">lambda </span><span class="s1">x: x.__name__</span><span class="s2">, </span><span class="s1">_all_nodes))</span>
<span class="s1">_mod_nodes = _filter_nodes(ast.mod)</span>
<span class="s1">_stmt_nodes = _filter_nodes(ast.stmt)</span>
<span class="s1">_expr_nodes = _filter_nodes(ast.expr)</span>
<span class="s1">_expr_context_nodes = _filter_nodes(ast.expr_context)</span>
<span class="s1">_boolop_nodes = _filter_nodes(ast.boolop)</span>
<span class="s1">_operator_nodes = _filter_nodes(ast.operator)</span>
<span class="s1">_unary_op_nodes = _filter_nodes(ast.unaryop)</span>
<span class="s1">_cmp_op_nodes = _filter_nodes(ast.cmpop)</span>
<span class="s1">_comprehension_nodes = _filter_nodes(ast.comprehension)</span>
<span class="s1">_handler_nodes = _filter_nodes(ast.excepthandler)</span>
<span class="s1">_arguments_nodes = _filter_nodes(ast.arguments)</span>
<span class="s1">_keyword_nodes = _filter_nodes(ast.keyword)</span>
<span class="s1">_alias_nodes = _filter_nodes(ast.alias)</span>

<span class="s2">if not </span><span class="s1">PY39:</span>
    <span class="s1">_slice_nodes = _filter_nodes(ast.slice)</span>


<span class="s5"># nodes that we don't support directly but are needed for parsing</span>
<span class="s1">_hacked_nodes = frozenset([</span><span class="s3">&quot;Assign&quot;</span><span class="s2">, </span><span class="s3">&quot;Module&quot;</span><span class="s2">, </span><span class="s3">&quot;Expr&quot;</span><span class="s1">])</span>


<span class="s1">_unsupported_expr_nodes = frozenset(</span>
    <span class="s1">[</span>
        <span class="s3">&quot;Yield&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;GeneratorExp&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;IfExp&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;DictComp&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;SetComp&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;Repr&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;Lambda&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;Set&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;AST&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;Is&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;IsNot&quot;</span><span class="s2">,</span>
    <span class="s1">]</span>
<span class="s1">)</span>

<span class="s5"># these nodes are low priority or won't ever be supported (e.g., AST)</span>
<span class="s1">_unsupported_nodes = (</span>
    <span class="s1">_stmt_nodes</span>
    <span class="s1">| _mod_nodes</span>
    <span class="s1">| _handler_nodes</span>
    <span class="s1">| _arguments_nodes</span>
    <span class="s1">| _keyword_nodes</span>
    <span class="s1">| _alias_nodes</span>
    <span class="s1">| _expr_context_nodes</span>
    <span class="s1">| _unsupported_expr_nodes</span>
<span class="s1">) - _hacked_nodes</span>

<span class="s5"># we're adding a different assignment in some cases to be equality comparison</span>
<span class="s5"># and we don't want `stmt` and friends in their so get only the class whose</span>
<span class="s5"># names are capitalized</span>
<span class="s1">_base_supported_nodes = (_all_node_names - _unsupported_nodes) | _hacked_nodes</span>
<span class="s1">intersection = _unsupported_nodes &amp; _base_supported_nodes</span>
<span class="s1">_msg = </span><span class="s3">f&quot;cannot both support and not support </span><span class="s2">{</span><span class="s1">intersection</span><span class="s2">}</span><span class="s3">&quot;</span>
<span class="s2">assert not </span><span class="s1">intersection</span><span class="s2">, </span><span class="s1">_msg</span>


<span class="s2">def </span><span class="s1">_node_not_implemented(node_name: str) -&gt; Callable[...</span><span class="s2">, None</span><span class="s1">]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a function that raises a NotImplementedError with a passed node name. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">f(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">f&quot;'</span><span class="s2">{</span><span class="s1">node_name</span><span class="s2">}</span><span class="s3">' nodes are not implemented&quot;</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">f</span>


<span class="s5"># should be bound by BaseExprVisitor but that creates a circular dependency:</span>
<span class="s5"># _T is used in disallow, but disallow is used to define BaseExprVisitor</span>
<span class="s5"># https://github.com/microsoft/pyright/issues/2315</span>
<span class="s1">_T = TypeVar(</span><span class="s3">&quot;_T&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">disallow(nodes: set[str]) -&gt; Callable[[type[_T]]</span><span class="s2">, </span><span class="s1">type[_T]]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Decorator to disallow certain nodes from parsing. Raises a 
    NotImplementedError instead. 
 
    Returns 
    ------- 
    callable 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">disallowed(cls: type[_T]) -&gt; type[_T]:</span>
        <span class="s5"># error: &quot;Type[_T]&quot; has no attribute &quot;unsupported_nodes&quot;</span>
        <span class="s1">cls.unsupported_nodes = ()  </span><span class="s5"># type: ignore[attr-defined]</span>
        <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">nodes:</span>
            <span class="s1">new_method = _node_not_implemented(node)</span>
            <span class="s1">name = </span><span class="s3">f&quot;visit_</span><span class="s2">{</span><span class="s1">node</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s5"># error: &quot;Type[_T]&quot; has no attribute &quot;unsupported_nodes&quot;</span>
            <span class="s1">cls.unsupported_nodes += (name</span><span class="s2">,</span><span class="s1">)  </span><span class="s5"># type: ignore[attr-defined]</span>
            <span class="s1">setattr(cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">new_method)</span>
        <span class="s2">return </span><span class="s1">cls</span>

    <span class="s2">return </span><span class="s1">disallowed</span>


<span class="s2">def </span><span class="s1">_op_maker(op_class</span><span class="s2">, </span><span class="s1">op_symbol):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a function to create an op class with its symbol already passed. 
 
    Returns 
    ------- 
    callable 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">f(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a partial function with an Op subclass with an operator already passed. 
 
        Returns 
        ------- 
        callable 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">partial(op_class</span><span class="s2">, </span><span class="s1">op_symbol</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">return </span><span class="s1">f</span>


<span class="s1">_op_classes = {</span><span class="s3">&quot;binary&quot;</span><span class="s1">: BinOp</span><span class="s2">, </span><span class="s3">&quot;unary&quot;</span><span class="s1">: UnaryOp}</span>


<span class="s2">def </span><span class="s1">add_ops(op_classes):</span>
    <span class="s0">&quot;&quot;&quot; 
    Decorator to add default implementation of ops. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">f(cls):</span>
        <span class="s2">for </span><span class="s1">op_attr_name</span><span class="s2">, </span><span class="s1">op_class </span><span class="s2">in </span><span class="s1">op_classes.items():</span>
            <span class="s1">ops = getattr(cls</span><span class="s2">, </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">op_attr_name</span><span class="s2">}</span><span class="s3">_ops&quot;</span><span class="s1">)</span>
            <span class="s1">ops_map = getattr(cls</span><span class="s2">, </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">op_attr_name</span><span class="s2">}</span><span class="s3">_op_nodes_map&quot;</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">op </span><span class="s2">in </span><span class="s1">ops:</span>
                <span class="s1">op_node = ops_map[op]</span>
                <span class="s2">if </span><span class="s1">op_node </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">made_op = _op_maker(op_class</span><span class="s2">, </span><span class="s1">op)</span>
                    <span class="s1">setattr(cls</span><span class="s2">, </span><span class="s3">f&quot;visit_</span><span class="s2">{</span><span class="s1">op_node</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">made_op)</span>
        <span class="s2">return </span><span class="s1">cls</span>

    <span class="s2">return </span><span class="s1">f</span>


<span class="s1">@disallow(_unsupported_nodes)</span>
<span class="s1">@add_ops(_op_classes)</span>
<span class="s2">class </span><span class="s1">BaseExprVisitor(ast.NodeVisitor):</span>
    <span class="s0">&quot;&quot;&quot; 
    Custom ast walker. Parsers of other engines should subclass this class 
    if necessary. 
 
    Parameters 
    ---------- 
    env : Scope 
    engine : str 
    parser : str 
    preparser : callable 
    &quot;&quot;&quot;</span>

    <span class="s1">const_type: type[Term] = Constant</span>
    <span class="s1">term_type = Term</span>

    <span class="s1">binary_ops = CMP_OPS_SYMS + BOOL_OPS_SYMS + ARITH_OPS_SYMS</span>
    <span class="s1">binary_op_nodes = (</span>
        <span class="s3">&quot;Gt&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;Lt&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;GtE&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;LtE&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;Eq&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;NotEq&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;In&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;NotIn&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;BitAnd&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;BitOr&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;And&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;Or&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;Add&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;Sub&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;Mult&quot;</span><span class="s2">,</span>
        <span class="s2">None,</span>
        <span class="s3">&quot;Pow&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;FloorDiv&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;Mod&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">binary_op_nodes_map = dict(zip(binary_ops</span><span class="s2">, </span><span class="s1">binary_op_nodes))</span>

    <span class="s1">unary_ops = UNARY_OPS_SYMS</span>
    <span class="s1">unary_op_nodes = </span><span class="s3">&quot;UAdd&quot;</span><span class="s2">, </span><span class="s3">&quot;USub&quot;</span><span class="s2">, </span><span class="s3">&quot;Invert&quot;</span><span class="s2">, </span><span class="s3">&quot;Not&quot;</span>
    <span class="s1">unary_op_nodes_map = {k: v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">zip(unary_ops</span><span class="s2">, </span><span class="s1">unary_op_nodes)}</span>

    <span class="s1">rewrite_map = {</span>
        <span class="s1">ast.Eq: ast.In</span><span class="s2">,</span>
        <span class="s1">ast.NotEq: ast.NotIn</span><span class="s2">,</span>
        <span class="s1">ast.In: ast.In</span><span class="s2">,</span>
        <span class="s1">ast.NotIn: ast.NotIn</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s1">unsupported_nodes: tuple[str</span><span class="s2">, </span><span class="s1">...]</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">engine</span><span class="s2">, </span><span class="s1">parser</span><span class="s2">, </span><span class="s1">preparser=_preparse):</span>
        <span class="s1">self.env = env</span>
        <span class="s1">self.engine = engine</span>
        <span class="s1">self.parser = parser</span>
        <span class="s1">self.preparser = preparser</span>
        <span class="s1">self.assigner = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">visit(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">if </span><span class="s1">isinstance(node</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">clean = self.preparser(node)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">node = ast.fix_missing_locations(ast.parse(clean))</span>
            <span class="s2">except </span><span class="s1">SyntaxError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s2">if </span><span class="s1">any(iskeyword(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">clean.split()):</span>
                    <span class="s1">e.msg = </span><span class="s3">&quot;Python keyword not valid identifier in numexpr query&quot;</span>
                <span class="s2">raise </span><span class="s1">e</span>

        <span class="s1">method = </span><span class="s3">&quot;visit_&quot; </span><span class="s1">+ type(node).__name__</span>
        <span class="s1">visitor = getattr(self</span><span class="s2">, </span><span class="s1">method)</span>
        <span class="s2">return </span><span class="s1">visitor(node</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">visit_Module(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">if </span><span class="s1">len(node.body) != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">&quot;only a single expression is allowed&quot;</span><span class="s1">)</span>
        <span class="s1">expr = node.body[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">self.visit(expr</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">visit_Expr(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">self.visit(node.value</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">_rewrite_membership_op(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right):</span>
        <span class="s5"># the kind of the operator (is actually an instance)</span>
        <span class="s1">op_instance = node.op</span>
        <span class="s1">op_type = type(op_instance)</span>

        <span class="s5"># must be two terms and the comparison operator must be ==/!=/in/not in</span>
        <span class="s2">if </span><span class="s1">is_term(left) </span><span class="s2">and </span><span class="s1">is_term(right) </span><span class="s2">and </span><span class="s1">op_type </span><span class="s2">in </span><span class="s1">self.rewrite_map:</span>

            <span class="s1">left_list</span><span class="s2">, </span><span class="s1">right_list = map(_is_list</span><span class="s2">, </span><span class="s1">(left</span><span class="s2">, </span><span class="s1">right))</span>
            <span class="s1">left_str</span><span class="s2">, </span><span class="s1">right_str = map(_is_str</span><span class="s2">, </span><span class="s1">(left</span><span class="s2">, </span><span class="s1">right))</span>

            <span class="s5"># if there are any strings or lists in the expression</span>
            <span class="s2">if </span><span class="s1">left_list </span><span class="s2">or </span><span class="s1">right_list </span><span class="s2">or </span><span class="s1">left_str </span><span class="s2">or </span><span class="s1">right_str:</span>
                <span class="s1">op_instance = self.rewrite_map[op_type]()</span>

            <span class="s5"># pop the string variable out of locals and replace it with a list</span>
            <span class="s5"># of one string, kind of a hack</span>
            <span class="s2">if </span><span class="s1">right_str:</span>
                <span class="s1">name = self.env.add_tmp([right.value])</span>
                <span class="s1">right = self.term_type(name</span><span class="s2">, </span><span class="s1">self.env)</span>

            <span class="s2">if </span><span class="s1">left_str:</span>
                <span class="s1">name = self.env.add_tmp([left.value])</span>
                <span class="s1">left = self.term_type(name</span><span class="s2">, </span><span class="s1">self.env)</span>

        <span class="s1">op = self.visit(op_instance)</span>
        <span class="s2">return </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op_instance</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span>

    <span class="s2">def </span><span class="s1">_maybe_transform_eq_ne(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">left=</span><span class="s2">None, </span><span class="s1">right=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">left </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">left = self.visit(node.left</span><span class="s2">, </span><span class="s1">side=</span><span class="s3">&quot;left&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">right </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">right = self.visit(node.right</span><span class="s2">, </span><span class="s1">side=</span><span class="s3">&quot;right&quot;</span><span class="s1">)</span>
        <span class="s1">op</span><span class="s2">, </span><span class="s1">op_class</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right = self._rewrite_membership_op(node</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right)</span>
        <span class="s2">return </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op_class</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span>

    <span class="s2">def </span><span class="s1">_maybe_downcast_constants(self</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right):</span>
        <span class="s1">f32 = np.dtype(np.float32)</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">left.is_scalar</span>
            <span class="s2">and </span><span class="s1">hasattr(left</span><span class="s2">, </span><span class="s3">&quot;value&quot;</span><span class="s1">)</span>
            <span class="s2">and not </span><span class="s1">right.is_scalar</span>
            <span class="s2">and </span><span class="s1">right.return_type == f32</span>
        <span class="s1">):</span>
            <span class="s5"># right is a float32 array, left is a scalar</span>
            <span class="s1">name = self.env.add_tmp(np.float32(left.value))</span>
            <span class="s1">left = self.term_type(name</span><span class="s2">, </span><span class="s1">self.env)</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">right.is_scalar</span>
            <span class="s2">and </span><span class="s1">hasattr(right</span><span class="s2">, </span><span class="s3">&quot;value&quot;</span><span class="s1">)</span>
            <span class="s2">and not </span><span class="s1">left.is_scalar</span>
            <span class="s2">and </span><span class="s1">left.return_type == f32</span>
        <span class="s1">):</span>
            <span class="s5"># left is a float32 array, right is a scalar</span>
            <span class="s1">name = self.env.add_tmp(np.float32(right.value))</span>
            <span class="s1">right = self.term_type(name</span><span class="s2">, </span><span class="s1">self.env)</span>

        <span class="s2">return </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span>

    <span class="s2">def </span><span class="s1">_maybe_eval(self</span><span class="s2">, </span><span class="s1">binop</span><span class="s2">, </span><span class="s1">eval_in_python):</span>
        <span class="s5"># eval `in` and `not in` (for now) in &quot;partial&quot; python space</span>
        <span class="s5"># things that can be evaluated in &quot;eval&quot; space will be turned into</span>
        <span class="s5"># temporary variables. for example,</span>
        <span class="s5"># [1,2] in a + 2 * b</span>
        <span class="s5"># in that case a + 2 * b will be evaluated using numexpr, and the &quot;in&quot;</span>
        <span class="s5"># call will be evaluated using isin (in python space)</span>
        <span class="s2">return </span><span class="s1">binop.evaluate(</span>
            <span class="s1">self.env</span><span class="s2">, </span><span class="s1">self.engine</span><span class="s2">, </span><span class="s1">self.parser</span><span class="s2">, </span><span class="s1">self.term_type</span><span class="s2">, </span><span class="s1">eval_in_python</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_maybe_evaluate_binop(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">op</span><span class="s2">,</span>
        <span class="s1">op_class</span><span class="s2">,</span>
        <span class="s1">lhs</span><span class="s2">,</span>
        <span class="s1">rhs</span><span class="s2">,</span>
        <span class="s1">eval_in_python=(</span><span class="s3">&quot;in&quot;</span><span class="s2">, </span><span class="s3">&quot;not in&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">maybe_eval_in_python=(</span><span class="s3">&quot;==&quot;</span><span class="s2">, </span><span class="s3">&quot;!=&quot;</span><span class="s2">, </span><span class="s3">&quot;&lt;&quot;</span><span class="s2">, </span><span class="s3">&quot;&gt;&quot;</span><span class="s2">, </span><span class="s3">&quot;&lt;=&quot;</span><span class="s2">, </span><span class="s3">&quot;&gt;=&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">res = op(lhs</span><span class="s2">, </span><span class="s1">rhs)</span>

        <span class="s2">if </span><span class="s1">res.has_invalid_return_type:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s3">f&quot;unsupported operand type(s) for </span><span class="s2">{</span><span class="s1">res.op</span><span class="s2">}</span><span class="s3">: &quot;</span>
                <span class="s3">f&quot;'</span><span class="s2">{</span><span class="s1">lhs.type</span><span class="s2">}</span><span class="s3">' and '</span><span class="s2">{</span><span class="s1">rhs.type</span><span class="s2">}</span><span class="s3">'&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.engine != </span><span class="s3">&quot;pytables&quot; </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">res.op </span><span class="s2">in </span><span class="s1">CMP_OPS_SYMS</span>
            <span class="s2">and </span><span class="s1">getattr(lhs</span><span class="s2">, </span><span class="s3">&quot;is_datetime&quot;</span><span class="s2">, False</span><span class="s1">)</span>
            <span class="s2">or </span><span class="s1">getattr(rhs</span><span class="s2">, </span><span class="s3">&quot;is_datetime&quot;</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s5"># all date ops must be done in python bc numexpr doesn't work</span>
            <span class="s5"># well with NaT</span>
            <span class="s2">return </span><span class="s1">self._maybe_eval(res</span><span class="s2">, </span><span class="s1">self.binary_ops)</span>

        <span class="s2">if </span><span class="s1">res.op </span><span class="s2">in </span><span class="s1">eval_in_python:</span>
            <span class="s5"># &quot;in&quot;/&quot;not in&quot; ops are always evaluated in python</span>
            <span class="s2">return </span><span class="s1">self._maybe_eval(res</span><span class="s2">, </span><span class="s1">eval_in_python)</span>
        <span class="s2">elif </span><span class="s1">self.engine != </span><span class="s3">&quot;pytables&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">getattr(lhs</span><span class="s2">, </span><span class="s3">&quot;return_type&quot;</span><span class="s2">, None</span><span class="s1">) == object</span>
                <span class="s2">or </span><span class="s1">getattr(rhs</span><span class="s2">, </span><span class="s3">&quot;return_type&quot;</span><span class="s2">, None</span><span class="s1">) == object</span>
            <span class="s1">):</span>
                <span class="s5"># evaluate &quot;==&quot; and &quot;!=&quot; in python if either of our operands</span>
                <span class="s5"># has an object return type</span>
                <span class="s2">return </span><span class="s1">self._maybe_eval(res</span><span class="s2">, </span><span class="s1">eval_in_python + maybe_eval_in_python)</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">visit_BinOp(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">op</span><span class="s2">, </span><span class="s1">op_class</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right = self._maybe_transform_eq_ne(node)</span>
        <span class="s1">left</span><span class="s2">, </span><span class="s1">right = self._maybe_downcast_constants(left</span><span class="s2">, </span><span class="s1">right)</span>
        <span class="s2">return </span><span class="s1">self._maybe_evaluate_binop(op</span><span class="s2">, </span><span class="s1">op_class</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right)</span>

    <span class="s2">def </span><span class="s1">visit_Div(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">return lambda </span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs: Div(lhs</span><span class="s2">, </span><span class="s1">rhs)</span>

    <span class="s2">def </span><span class="s1">visit_UnaryOp(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">op = self.visit(node.op)</span>
        <span class="s1">operand = self.visit(node.operand)</span>
        <span class="s2">return </span><span class="s1">op(operand)</span>

    <span class="s2">def </span><span class="s1">visit_Name(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">self.term_type(node.id</span><span class="s2">, </span><span class="s1">self.env</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">visit_NameConstant(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">self.const_type(node.value</span><span class="s2">, </span><span class="s1">self.env)</span>

    <span class="s2">def </span><span class="s1">visit_Num(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">self.const_type(node.n</span><span class="s2">, </span><span class="s1">self.env)</span>

    <span class="s2">def </span><span class="s1">visit_Constant(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">self.const_type(node.n</span><span class="s2">, </span><span class="s1">self.env)</span>

    <span class="s2">def </span><span class="s1">visit_Str(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">name = self.env.add_tmp(node.s)</span>
        <span class="s2">return </span><span class="s1">self.term_type(name</span><span class="s2">, </span><span class="s1">self.env)</span>

    <span class="s2">def </span><span class="s1">visit_List(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">name = self.env.add_tmp([self.visit(e)(self.env) </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">node.elts])</span>
        <span class="s2">return </span><span class="s1">self.term_type(name</span><span class="s2">, </span><span class="s1">self.env)</span>

    <span class="s1">visit_Tuple = visit_List</span>

    <span class="s2">def </span><span class="s1">visit_Index(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot;df.index[4]&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.visit(node.value)</span>

    <span class="s2">def </span><span class="s1">visit_Subscript(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">eval </span><span class="s2">as </span><span class="s1">pd_eval</span>

        <span class="s1">value = self.visit(node.value)</span>
        <span class="s1">slobj = self.visit(node.slice)</span>
        <span class="s1">result = pd_eval(</span>
            <span class="s1">slobj</span><span class="s2">, </span><span class="s1">local_dict=self.env</span><span class="s2">, </span><span class="s1">engine=self.engine</span><span class="s2">, </span><span class="s1">parser=self.parser</span>
        <span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s5"># a Term instance</span>
            <span class="s1">v = value.value[result]</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s5"># an Op instance</span>
            <span class="s1">lhs = pd_eval(</span>
                <span class="s1">value</span><span class="s2">, </span><span class="s1">local_dict=self.env</span><span class="s2">, </span><span class="s1">engine=self.engine</span><span class="s2">, </span><span class="s1">parser=self.parser</span>
            <span class="s1">)</span>
            <span class="s1">v = lhs[result]</span>
        <span class="s1">name = self.env.add_tmp(v)</span>
        <span class="s2">return </span><span class="s1">self.term_type(name</span><span class="s2">, </span><span class="s1">env=self.env)</span>

    <span class="s2">def </span><span class="s1">visit_Slice(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot;df.index[slice(4,6)]&quot;&quot;&quot;</span>
        <span class="s1">lower = node.lower</span>
        <span class="s2">if </span><span class="s1">lower </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">lower = self.visit(lower).value</span>
        <span class="s1">upper = node.upper</span>
        <span class="s2">if </span><span class="s1">upper </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">upper = self.visit(upper).value</span>
        <span class="s1">step = node.step</span>
        <span class="s2">if </span><span class="s1">step </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">step = self.visit(step).value</span>

        <span class="s2">return </span><span class="s1">slice(lower</span><span class="s2">, </span><span class="s1">upper</span><span class="s2">, </span><span class="s1">step)</span>

    <span class="s2">def </span><span class="s1">visit_Assign(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        support a single assignment node, like 
 
        c = a + b 
 
        set the assigner at the top level, must be a Name node which 
        might or might not exist in the resolvers 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(node.targets) != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">&quot;can only assign a single expression&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">isinstance(node.targets[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ast.Name):</span>
            <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">&quot;left hand side of an assignment must be a single name&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.env.target </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;cannot assign without a target object&quot;</span><span class="s1">)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">assigner = self.visit(node.targets[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">except </span><span class="s1">UndefinedVariableError:</span>
            <span class="s1">assigner = node.targets[</span><span class="s4">0</span><span class="s1">].id</span>

        <span class="s1">self.assigner = getattr(assigner</span><span class="s2">, </span><span class="s3">&quot;name&quot;</span><span class="s2">, </span><span class="s1">assigner)</span>
        <span class="s2">if </span><span class="s1">self.assigner </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">SyntaxError(</span>
                <span class="s3">&quot;left hand side of an assignment must be a single resolvable name&quot;</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">self.visit(node.value</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">visit_Attribute(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">attr = node.attr</span>
        <span class="s1">value = node.value</span>

        <span class="s1">ctx = node.ctx</span>
        <span class="s2">if </span><span class="s1">isinstance(ctx</span><span class="s2">, </span><span class="s1">ast.Load):</span>
            <span class="s5"># resolve the value</span>
            <span class="s1">resolved = self.visit(value).value</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">v = getattr(resolved</span><span class="s2">, </span><span class="s1">attr)</span>
                <span class="s1">name = self.env.add_tmp(v)</span>
                <span class="s2">return </span><span class="s1">self.term_type(name</span><span class="s2">, </span><span class="s1">self.env)</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s5"># something like datetime.datetime where scope is overridden</span>
                <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">ast.Name) </span><span class="s2">and </span><span class="s1">value.id == attr:</span>
                    <span class="s2">return </span><span class="s1">resolved</span>
                <span class="s2">raise</span>

        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Invalid Attribute context </span><span class="s2">{</span><span class="s1">type(ctx).__name__</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">visit_Call(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">side=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>

        <span class="s2">if </span><span class="s1">isinstance(node.func</span><span class="s2">, </span><span class="s1">ast.Attribute) </span><span class="s2">and </span><span class="s1">node.func.attr != </span><span class="s3">&quot;__call__&quot;</span><span class="s1">:</span>
            <span class="s1">res = self.visit_Attribute(node.func)</span>
        <span class="s2">elif not </span><span class="s1">isinstance(node.func</span><span class="s2">, </span><span class="s1">ast.Name):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only named functions are supported&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">res = self.visit(node.func)</span>
            <span class="s2">except </span><span class="s1">UndefinedVariableError:</span>
                <span class="s5"># Check if this is a supported function name</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">res = FuncNode(node.func.id)</span>
                <span class="s2">except </span><span class="s1">ValueError:</span>
                    <span class="s5"># Raise original error</span>
                    <span class="s2">raise</span>

        <span class="s2">if </span><span class="s1">res </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s5"># error: &quot;expr&quot; has no attribute &quot;id&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">f&quot;Invalid function call </span><span class="s2">{</span><span class="s1">node.func.id</span><span class="s2">}</span><span class="s3">&quot;  </span><span class="s5"># type: ignore[attr-defined]</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">hasattr(res</span><span class="s2">, </span><span class="s3">&quot;value&quot;</span><span class="s1">):</span>
            <span class="s1">res = res.value</span>

        <span class="s2">if </span><span class="s1">isinstance(res</span><span class="s2">, </span><span class="s1">FuncNode):</span>

            <span class="s1">new_args = [self.visit(arg) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">node.args]</span>

            <span class="s2">if </span><span class="s1">node.keywords:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">f'Function &quot;</span><span class="s2">{</span><span class="s1">res.name</span><span class="s2">}</span><span class="s3">&quot; does not support keyword arguments'</span>
                <span class="s1">)</span>

            <span class="s2">return </span><span class="s1">res(*new_args)</span>

        <span class="s2">else</span><span class="s1">:</span>

            <span class="s1">new_args = [self.visit(arg).value </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">node.args]</span>

            <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">node.keywords:</span>
                <span class="s2">if not </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">ast.keyword):</span>
                    <span class="s5"># error: &quot;expr&quot; has no attribute &quot;id&quot;</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">&quot;keyword error in function call &quot;  </span><span class="s5"># type: ignore[attr-defined]</span>
                        <span class="s3">f&quot;'</span><span class="s2">{</span><span class="s1">node.func.id</span><span class="s2">}</span><span class="s3">'&quot;</span>
                    <span class="s1">)</span>

                <span class="s2">if </span><span class="s1">key.arg:</span>
                    <span class="s1">kwargs[key.arg] = self.visit(key.value).value</span>

            <span class="s1">name = self.env.add_tmp(res(*new_args</span><span class="s2">, </span><span class="s1">**kwargs))</span>
            <span class="s2">return </span><span class="s1">self.term_type(name=name</span><span class="s2">, </span><span class="s1">env=self.env)</span>

    <span class="s2">def </span><span class="s1">translate_In(self</span><span class="s2">, </span><span class="s1">op):</span>
        <span class="s2">return </span><span class="s1">op</span>

    <span class="s2">def </span><span class="s1">visit_Compare(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">ops = node.ops</span>
        <span class="s1">comps = node.comparators</span>

        <span class="s5"># base case: we have something like a CMP b</span>
        <span class="s2">if </span><span class="s1">len(comps) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">op = self.translate_In(ops[</span><span class="s4">0</span><span class="s1">])</span>
            <span class="s1">binop = ast.BinOp(op=op</span><span class="s2">, </span><span class="s1">left=node.left</span><span class="s2">, </span><span class="s1">right=comps[</span><span class="s4">0</span><span class="s1">])</span>
            <span class="s2">return </span><span class="s1">self.visit(binop)</span>

        <span class="s5"># recursive case: we have a chained comparison, a CMP b CMP c, etc.</span>
        <span class="s1">left = node.left</span>
        <span class="s1">values = []</span>
        <span class="s2">for </span><span class="s1">op</span><span class="s2">, </span><span class="s1">comp </span><span class="s2">in </span><span class="s1">zip(ops</span><span class="s2">, </span><span class="s1">comps):</span>
            <span class="s1">new_node = self.visit(</span>
                <span class="s1">ast.Compare(comparators=[comp]</span><span class="s2">, </span><span class="s1">left=left</span><span class="s2">, </span><span class="s1">ops=[self.translate_In(op)])</span>
            <span class="s1">)</span>
            <span class="s1">left = comp</span>
            <span class="s1">values.append(new_node)</span>
        <span class="s2">return </span><span class="s1">self.visit(ast.BoolOp(op=ast.And()</span><span class="s2">, </span><span class="s1">values=values))</span>

    <span class="s2">def </span><span class="s1">_try_visit_binop(self</span><span class="s2">, </span><span class="s1">bop):</span>
        <span class="s2">if </span><span class="s1">isinstance(bop</span><span class="s2">, </span><span class="s1">(Op</span><span class="s2">, </span><span class="s1">Term)):</span>
            <span class="s2">return </span><span class="s1">bop</span>
        <span class="s2">return </span><span class="s1">self.visit(bop)</span>

    <span class="s2">def </span><span class="s1">visit_BoolOp(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">def </span><span class="s1">visitor(x</span><span class="s2">, </span><span class="s1">y):</span>
            <span class="s1">lhs = self._try_visit_binop(x)</span>
            <span class="s1">rhs = self._try_visit_binop(y)</span>

            <span class="s1">op</span><span class="s2">, </span><span class="s1">op_class</span><span class="s2">, </span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs = self._maybe_transform_eq_ne(node</span><span class="s2">, </span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs)</span>
            <span class="s2">return </span><span class="s1">self._maybe_evaluate_binop(op</span><span class="s2">, </span><span class="s1">node.op</span><span class="s2">, </span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs)</span>

        <span class="s1">operands = node.values</span>
        <span class="s2">return </span><span class="s1">reduce(visitor</span><span class="s2">, </span><span class="s1">operands)</span>


<span class="s1">_python_not_supported = frozenset([</span><span class="s3">&quot;Dict&quot;</span><span class="s2">, </span><span class="s3">&quot;BoolOp&quot;</span><span class="s2">, </span><span class="s3">&quot;In&quot;</span><span class="s2">, </span><span class="s3">&quot;NotIn&quot;</span><span class="s1">])</span>
<span class="s1">_numexpr_supported_calls = frozenset(REDUCTIONS + MATHOPS)</span>


<span class="s1">@disallow(</span>
    <span class="s1">(_unsupported_nodes | _python_not_supported)</span>
    <span class="s1">- (_boolop_nodes | frozenset([</span><span class="s3">&quot;BoolOp&quot;</span><span class="s2">, </span><span class="s3">&quot;Attribute&quot;</span><span class="s2">, </span><span class="s3">&quot;In&quot;</span><span class="s2">, </span><span class="s3">&quot;NotIn&quot;</span><span class="s2">, </span><span class="s3">&quot;Tuple&quot;</span><span class="s1">]))</span>
<span class="s1">)</span>
<span class="s2">class </span><span class="s1">PandasExprVisitor(BaseExprVisitor):</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">env</span><span class="s2">,</span>
        <span class="s1">engine</span><span class="s2">,</span>
        <span class="s1">parser</span><span class="s2">,</span>
        <span class="s1">preparser=partial(</span>
            <span class="s1">_preparse</span><span class="s2">,</span>
            <span class="s1">f=_compose(_replace_locals</span><span class="s2">, </span><span class="s1">_replace_booleans</span><span class="s2">, </span><span class="s1">clean_backtick_quoted_toks)</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(env</span><span class="s2">, </span><span class="s1">engine</span><span class="s2">, </span><span class="s1">parser</span><span class="s2">, </span><span class="s1">preparser)</span>


<span class="s1">@disallow(_unsupported_nodes | _python_not_supported | frozenset([</span><span class="s3">&quot;Not&quot;</span><span class="s1">]))</span>
<span class="s2">class </span><span class="s1">PythonExprVisitor(BaseExprVisitor):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">engine</span><span class="s2">, </span><span class="s1">parser</span><span class="s2">, </span><span class="s1">preparser=</span><span class="s2">lambda </span><span class="s1">x: x):</span>
        <span class="s1">super().__init__(env</span><span class="s2">, </span><span class="s1">engine</span><span class="s2">, </span><span class="s1">parser</span><span class="s2">, </span><span class="s1">preparser=preparser)</span>


<span class="s2">class </span><span class="s1">Expr:</span>
    <span class="s0">&quot;&quot;&quot; 
    Object encapsulating an expression. 
 
    Parameters 
    ---------- 
    expr : str 
    engine : str, optional, default 'numexpr' 
    parser : str, optional, default 'pandas' 
    env : Scope, optional, default None 
    level : int, optional, default 2 
    &quot;&quot;&quot;</span>

    <span class="s1">env: Scope</span>
    <span class="s1">engine: str</span>
    <span class="s1">parser: str</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">expr</span><span class="s2">,</span>
        <span class="s1">engine: str = </span><span class="s3">&quot;numexpr&quot;</span><span class="s2">,</span>
        <span class="s1">parser: str = </span><span class="s3">&quot;pandas&quot;</span><span class="s2">,</span>
        <span class="s1">env: Scope | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">level: int = </span><span class="s4">0</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">self.expr = expr</span>
        <span class="s1">self.env = env </span><span class="s2">or </span><span class="s1">Scope(level=level + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.engine = engine</span>
        <span class="s1">self.parser = parser</span>
        <span class="s1">self._visitor = PARSERS[parser](self.env</span><span class="s2">, </span><span class="s1">self.engine</span><span class="s2">, </span><span class="s1">self.parser)</span>
        <span class="s1">self.terms = self.parse()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">assigner(self):</span>
        <span class="s2">return </span><span class="s1">getattr(self._visitor</span><span class="s2">, </span><span class="s3">&quot;assigner&quot;</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s2">return </span><span class="s1">self.terms(self.env)</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">printing.pprint_thing(self.terms)</span>

    <span class="s2">def </span><span class="s1">__len__(self) -&gt; int:</span>
        <span class="s2">return </span><span class="s1">len(self.expr)</span>

    <span class="s2">def </span><span class="s1">parse(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parse an expression. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._visitor.visit(self.expr)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">names(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the names in an expression. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">is_term(self.terms):</span>
            <span class="s2">return </span><span class="s1">frozenset([self.terms.name])</span>
        <span class="s2">return </span><span class="s1">frozenset(term.name </span><span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">com.flatten(self.terms))</span>


<span class="s1">PARSERS = {</span><span class="s3">&quot;python&quot;</span><span class="s1">: PythonExprVisitor</span><span class="s2">, </span><span class="s3">&quot;pandas&quot;</span><span class="s1">: PandasExprVisitor}</span>
</pre>
</body>
</html>