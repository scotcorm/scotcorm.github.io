<html>
<head>
<title>test_readers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_readers.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">datetime</span><span class="s0">,</span>
    <span class="s1">time</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">from </span><span class="s1">pathlib </span><span class="s0">import </span><span class="s1">Path</span>
<span class="s0">from </span><span class="s1">urllib.error </span><span class="s0">import </span><span class="s1">URLError</span>
<span class="s0">from </span><span class="s1">zipfile </span><span class="s0">import </span><span class="s1">BadZipFile</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">pandas.util._test_decorators </span><span class="s0">as </span><span class="s1">td</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s0">,</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">MultiIndex</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>
<span class="s0">from </span><span class="s1">pandas.tests.io.excel </span><span class="s0">import </span><span class="s1">xlrd_version</span>
<span class="s0">from </span><span class="s1">pandas.util.version </span><span class="s0">import </span><span class="s1">Version</span>

<span class="s1">read_ext_params = [</span><span class="s2">&quot;.xls&quot;</span><span class="s0">, </span><span class="s2">&quot;.xlsx&quot;</span><span class="s0">, </span><span class="s2">&quot;.xlsm&quot;</span><span class="s0">, </span><span class="s2">&quot;.xlsb&quot;</span><span class="s0">, </span><span class="s2">&quot;.ods&quot;</span><span class="s1">]</span>
<span class="s1">engine_params = [</span>
    <span class="s3"># Add any engines to test here</span>
    <span class="s3"># When defusedxml is installed it triggers deprecation warnings for</span>
    <span class="s3"># xlrd and openpyxl, so catch those here</span>
    <span class="s1">pytest.param(</span>
        <span class="s2">&quot;xlrd&quot;</span><span class="s0">,</span>
        <span class="s1">marks=[</span>
            <span class="s1">td.skip_if_no(</span><span class="s2">&quot;xlrd&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">pytest.param(</span>
        <span class="s2">&quot;openpyxl&quot;</span><span class="s0">,</span>
        <span class="s1">marks=[</span>
            <span class="s1">td.skip_if_no(</span><span class="s2">&quot;openpyxl&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">pytest.mark.filterwarnings(</span><span class="s2">&quot;ignore:.*html argument&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">pytest.param(</span>
        <span class="s0">None,</span>
        <span class="s1">marks=[</span>
            <span class="s1">td.skip_if_no(</span><span class="s2">&quot;xlrd&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">pytest.param(</span><span class="s2">&quot;pyxlsb&quot;</span><span class="s0">, </span><span class="s1">marks=td.skip_if_no(</span><span class="s2">&quot;pyxlsb&quot;</span><span class="s1">))</span><span class="s0">,</span>
    <span class="s1">pytest.param(</span><span class="s2">&quot;odf&quot;</span><span class="s0">, </span><span class="s1">marks=td.skip_if_no(</span><span class="s2">&quot;odf&quot;</span><span class="s1">))</span><span class="s0">,</span>
<span class="s1">]</span>


<span class="s0">def </span><span class="s1">_is_valid_engine_ext_pair(engine</span><span class="s0">, </span><span class="s1">read_ext: str) -&gt; bool:</span>
    <span class="s4">&quot;&quot;&quot; 
    Filter out invalid (engine, ext) pairs instead of skipping, as that 
    produces 500+ pytest.skips. 
    &quot;&quot;&quot;</span>
    <span class="s1">engine = engine.values[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;openpyxl&quot; </span><span class="s0">and </span><span class="s1">read_ext == </span><span class="s2">&quot;.xls&quot;</span><span class="s1">:</span>
        <span class="s0">return False</span>
    <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;odf&quot; </span><span class="s0">and </span><span class="s1">read_ext != </span><span class="s2">&quot;.ods&quot;</span><span class="s1">:</span>
        <span class="s0">return False</span>
    <span class="s0">if </span><span class="s1">read_ext == </span><span class="s2">&quot;.ods&quot; </span><span class="s0">and </span><span class="s1">engine != </span><span class="s2">&quot;odf&quot;</span><span class="s1">:</span>
        <span class="s0">return False</span>
    <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;pyxlsb&quot; </span><span class="s0">and </span><span class="s1">read_ext != </span><span class="s2">&quot;.xlsb&quot;</span><span class="s1">:</span>
        <span class="s0">return False</span>
    <span class="s0">if </span><span class="s1">read_ext == </span><span class="s2">&quot;.xlsb&quot; </span><span class="s0">and </span><span class="s1">engine != </span><span class="s2">&quot;pyxlsb&quot;</span><span class="s1">:</span>
        <span class="s0">return False</span>
    <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">engine == </span><span class="s2">&quot;xlrd&quot;</span>
        <span class="s0">and </span><span class="s1">xlrd_version </span><span class="s0">is not None</span>
        <span class="s0">and </span><span class="s1">xlrd_version &gt;= Version(</span><span class="s2">&quot;2&quot;</span><span class="s1">)</span>
        <span class="s0">and </span><span class="s1">read_ext != </span><span class="s2">&quot;.xls&quot;</span>
    <span class="s1">):</span>
        <span class="s0">return False</span>
    <span class="s0">return True</span>


<span class="s0">def </span><span class="s1">_transfer_marks(engine</span><span class="s0">, </span><span class="s1">read_ext):</span>
    <span class="s4">&quot;&quot;&quot; 
    engine gives us a pytest.param object with some marks, read_ext is just 
    a string.  We need to generate a new pytest.param inheriting the marks. 
    &quot;&quot;&quot;</span>
    <span class="s1">values = engine.values + (read_ext</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s1">new_param = pytest.param(values</span><span class="s0">, </span><span class="s1">marks=engine.marks)</span>
    <span class="s0">return </span><span class="s1">new_param</span>


<span class="s1">@pytest.fixture(</span>
    <span class="s1">params=[</span>
        <span class="s1">_transfer_marks(eng</span><span class="s0">, </span><span class="s1">ext)</span>
        <span class="s0">for </span><span class="s1">eng </span><span class="s0">in </span><span class="s1">engine_params</span>
        <span class="s0">for </span><span class="s1">ext </span><span class="s0">in </span><span class="s1">read_ext_params</span>
        <span class="s0">if </span><span class="s1">_is_valid_engine_ext_pair(eng</span><span class="s0">, </span><span class="s1">ext)</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">engine_and_read_ext(request):</span>
    <span class="s4">&quot;&quot;&quot; 
    Fixture for Excel reader engine and read_ext, only including valid pairs. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">request.param</span>


<span class="s1">@pytest.fixture</span>
<span class="s0">def </span><span class="s1">engine(engine_and_read_ext):</span>
    <span class="s1">engine</span><span class="s0">, </span><span class="s1">read_ext = engine_and_read_ext</span>
    <span class="s0">return </span><span class="s1">engine</span>


<span class="s1">@pytest.fixture</span>
<span class="s0">def </span><span class="s1">read_ext(engine_and_read_ext):</span>
    <span class="s1">engine</span><span class="s0">, </span><span class="s1">read_ext = engine_and_read_ext</span>
    <span class="s0">return </span><span class="s1">read_ext</span>


<span class="s0">class </span><span class="s1">TestReaders:</span>
    <span class="s1">@pytest.fixture(autouse=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">cd_and_set_engine(self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">datapath</span><span class="s0">, </span><span class="s1">monkeypatch):</span>
        <span class="s4">&quot;&quot;&quot; 
        Change directory and set engine for read_excel calls. 
        &quot;&quot;&quot;</span>
        <span class="s1">func = partial(pd.read_excel</span><span class="s0">, </span><span class="s1">engine=engine)</span>
        <span class="s1">monkeypatch.chdir(datapath(</span><span class="s2">&quot;io&quot;</span><span class="s0">, </span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;excel&quot;</span><span class="s1">))</span>
        <span class="s1">monkeypatch.setattr(pd</span><span class="s0">, </span><span class="s2">&quot;read_excel&quot;</span><span class="s0">, </span><span class="s1">func)</span>

    <span class="s0">def </span><span class="s1">test_engine_used(self</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">monkeypatch):</span>
        <span class="s3"># GH 38884</span>
        <span class="s0">def </span><span class="s1">parser(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">return </span><span class="s1">self.engine</span>

        <span class="s1">monkeypatch.setattr(pd.ExcelFile</span><span class="s0">, </span><span class="s2">&quot;parse&quot;</span><span class="s0">, </span><span class="s1">parser)</span>

        <span class="s1">expected_defaults = {</span>
            <span class="s2">&quot;xlsx&quot;</span><span class="s1">: </span><span class="s2">&quot;openpyxl&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;xlsm&quot;</span><span class="s1">: </span><span class="s2">&quot;openpyxl&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;xlsb&quot;</span><span class="s1">: </span><span class="s2">&quot;pyxlsb&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;xls&quot;</span><span class="s1">: </span><span class="s2">&quot;xlrd&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;ods&quot;</span><span class="s1">: </span><span class="s2">&quot;odf&quot;</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">with </span><span class="s1">open(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
            <span class="s1">result = pd.read_excel(f)</span>

        <span class="s0">if </span><span class="s1">engine </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">expected = engine</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expected = expected_defaults[read_ext[</span><span class="s5">1</span><span class="s1">:]]</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s0">def </span><span class="s1">test_usecols_int(self</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">df_ref):</span>
        <span class="s1">df_ref = df_ref.reindex(columns=[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">])</span>

        <span class="s3"># usecols as int</span>
        <span class="s1">msg = </span><span class="s2">&quot;Passing an integer for `usecols`&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">pd.read_excel(</span>
                <span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">usecols=</span><span class="s5">3</span>
            <span class="s1">)</span>

        <span class="s3"># usecols as int</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">pd.read_excel(</span>
                <span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">,</span>
                <span class="s1">sheet_name=</span><span class="s2">&quot;Sheet2&quot;</span><span class="s0">,</span>
                <span class="s1">skiprows=[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">index_col=</span><span class="s5">0</span><span class="s0">,</span>
                <span class="s1">usecols=</span><span class="s5">3</span><span class="s0">,</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_usecols_list(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">df_ref):</span>
        <span class="s0">if </span><span class="s1">read_ext == </span><span class="s2">&quot;.xlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;Sheets containing datetimes not supported by pyxlsb&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">df_ref = df_ref.reindex(columns=[</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">])</span>
        <span class="s1">df1 = pd.read_excel(</span>
            <span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">usecols=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">df2 = pd.read_excel(</span>
            <span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">,</span>
            <span class="s1">sheet_name=</span><span class="s2">&quot;Sheet2&quot;</span><span class="s0">,</span>
            <span class="s1">skiprows=[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">index_col=</span><span class="s5">0</span><span class="s0">,</span>
            <span class="s1">usecols=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s3"># TODO add index to xls file)</span>
        <span class="s1">tm.assert_frame_equal(df1</span><span class="s0">, </span><span class="s1">df_ref</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df2</span><span class="s0">, </span><span class="s1">df_ref</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_usecols_str(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">df_ref):</span>
        <span class="s0">if </span><span class="s1">read_ext == </span><span class="s2">&quot;.xlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;Sheets containing datetimes not supported by pyxlsb&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">df1 = df_ref.reindex(columns=[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">])</span>
        <span class="s1">df2 = pd.read_excel(</span>
            <span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">usecols=</span><span class="s2">&quot;A:D&quot;</span>
        <span class="s1">)</span>
        <span class="s1">df3 = pd.read_excel(</span>
            <span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">,</span>
            <span class="s1">sheet_name=</span><span class="s2">&quot;Sheet2&quot;</span><span class="s0">,</span>
            <span class="s1">skiprows=[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">index_col=</span><span class="s5">0</span><span class="s0">,</span>
            <span class="s1">usecols=</span><span class="s2">&quot;A:D&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s3"># TODO add index to xls, read xls ignores index name ?</span>
        <span class="s1">tm.assert_frame_equal(df2</span><span class="s0">, </span><span class="s1">df1</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df3</span><span class="s0">, </span><span class="s1">df1</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">df1 = df_ref.reindex(columns=[</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">])</span>
        <span class="s1">df2 = pd.read_excel(</span>
            <span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">usecols=</span><span class="s2">&quot;A,C,D&quot;</span>
        <span class="s1">)</span>
        <span class="s1">df3 = pd.read_excel(</span>
            <span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">,</span>
            <span class="s1">sheet_name=</span><span class="s2">&quot;Sheet2&quot;</span><span class="s0">,</span>
            <span class="s1">skiprows=[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">index_col=</span><span class="s5">0</span><span class="s0">,</span>
            <span class="s1">usecols=</span><span class="s2">&quot;A,C,D&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s3"># TODO add index to xls file</span>
        <span class="s1">tm.assert_frame_equal(df2</span><span class="s0">, </span><span class="s1">df1</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df3</span><span class="s0">, </span><span class="s1">df1</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">df1 = df_ref.reindex(columns=[</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">])</span>
        <span class="s1">df2 = pd.read_excel(</span>
            <span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">usecols=</span><span class="s2">&quot;A,C:D&quot;</span>
        <span class="s1">)</span>
        <span class="s1">df3 = pd.read_excel(</span>
            <span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">,</span>
            <span class="s1">sheet_name=</span><span class="s2">&quot;Sheet2&quot;</span><span class="s0">,</span>
            <span class="s1">skiprows=[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">index_col=</span><span class="s5">0</span><span class="s0">,</span>
            <span class="s1">usecols=</span><span class="s2">&quot;A,C:D&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df2</span><span class="s0">, </span><span class="s1">df1</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df3</span><span class="s0">, </span><span class="s1">df1</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;usecols&quot;</span><span class="s0">, </span><span class="s1">[[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]]</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_usecols_diff_positional_int_columns_order(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">usecols</span><span class="s0">, </span><span class="s1">df_ref</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">read_ext == </span><span class="s2">&quot;.xlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;Sheets containing datetimes not supported by pyxlsb&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">expected = df_ref[[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">]]</span>
        <span class="s1">result = pd.read_excel(</span>
            <span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">usecols=usecols</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;usecols&quot;</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;D&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;D&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_usecols_diff_positional_str_columns_order(self</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">usecols</span><span class="s0">, </span><span class="s1">df_ref):</span>
        <span class="s1">expected = df_ref[[</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;D&quot;</span><span class="s1">]]</span>
        <span class="s1">expected.index = range(len(expected))</span>

        <span class="s1">result = pd.read_excel(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">usecols=usecols)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_read_excel_without_slicing(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">df_ref):</span>
        <span class="s0">if </span><span class="s1">read_ext == </span><span class="s2">&quot;.xlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;Sheets containing datetimes not supported by pyxlsb&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">expected = df_ref</span>
        <span class="s1">result = pd.read_excel(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_usecols_excel_range_str(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">df_ref):</span>
        <span class="s0">if </span><span class="s1">read_ext == </span><span class="s2">&quot;.xlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;Sheets containing datetimes not supported by pyxlsb&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">expected = df_ref[[</span><span class="s2">&quot;C&quot;</span><span class="s0">, </span><span class="s2">&quot;D&quot;</span><span class="s1">]]</span>
        <span class="s1">result = pd.read_excel(</span>
            <span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">usecols=</span><span class="s2">&quot;A,D:E&quot;</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_usecols_excel_range_str_invalid(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s1">msg = </span><span class="s2">&quot;Invalid column name: E1&quot;</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">pd.read_excel(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">usecols=</span><span class="s2">&quot;D:E1&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_index_col_label_error(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s1">msg = </span><span class="s2">&quot;list indices must be integers.*, not str&quot;</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">pd.read_excel(</span>
                <span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">,</span>
                <span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">,</span>
                <span class="s1">index_col=[</span><span class="s2">&quot;A&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">usecols=[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_index_col_empty(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># see gh-9208</span>
        <span class="s1">result = pd.read_excel(</span>
            <span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet3&quot;</span><span class="s0">, </span><span class="s1">index_col=[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">columns=[</span><span class="s2">&quot;D&quot;</span><span class="s0">, </span><span class="s2">&quot;E&quot;</span><span class="s0">, </span><span class="s2">&quot;F&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">index=MultiIndex(levels=[[]] * </span><span class="s5">3</span><span class="s0">, </span><span class="s1">codes=[[]] * </span><span class="s5">3</span><span class="s0">, </span><span class="s1">names=[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;index_col&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s5">2</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_index_col_with_unnamed(self</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">index_col):</span>
        <span class="s3"># see gh-18792</span>
        <span class="s1">result = pd.read_excel(</span>
            <span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet4&quot;</span><span class="s0">, </span><span class="s1">index_col=index_col</span>
        <span class="s1">)</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">[[</span><span class="s2">&quot;i1&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;i2&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;Unnamed: 0&quot;</span><span class="s0">, </span><span class="s2">&quot;col1&quot;</span><span class="s0">, </span><span class="s2">&quot;col2&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">index_col:</span>
            <span class="s1">expected = expected.set_index(expected.columns[index_col])</span>

        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_usecols_pass_non_existent_column(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s1">msg = (</span>
            <span class="s2">&quot;Usecols do not match columns, &quot;</span>
            <span class="s2">&quot;columns expected but not found: &quot; </span><span class="s1">+ </span><span class="s2">r&quot;\['E'\]&quot;</span>
        <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">pd.read_excel(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">usecols=[</span><span class="s2">&quot;E&quot;</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_usecols_wrong_type(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s1">msg = (</span>
            <span class="s2">&quot;'usecols' must either be list-like of &quot;</span>
            <span class="s2">&quot;all strings, all unicode, all integers or a callable.&quot;</span>
        <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">pd.read_excel(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">usecols=[</span><span class="s2">&quot;E1&quot;</span><span class="s0">, </span><span class="s5">0</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_excel_stop_iterator(self</span><span class="s0">, </span><span class="s1">read_ext):</span>

        <span class="s1">parsed = pd.read_excel(</span><span class="s2">&quot;test2&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s1">)</span>
        <span class="s1">expected = DataFrame([[</span><span class="s2">&quot;aaaa&quot;</span><span class="s0">, </span><span class="s2">&quot;bbbbb&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;Test&quot;</span><span class="s0">, </span><span class="s2">&quot;Test1&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_frame_equal(parsed</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_excel_cell_error_na(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s0">if </span><span class="s1">read_ext == </span><span class="s2">&quot;.xlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;Sheets containing datetimes not supported by pyxlsb&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">parsed = pd.read_excel(</span><span class="s2">&quot;test3&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s1">)</span>
        <span class="s1">expected = DataFrame([[np.nan]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;Test&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_frame_equal(parsed</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_excel_table(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">df_ref):</span>
        <span class="s0">if </span><span class="s1">read_ext == </span><span class="s2">&quot;.xlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;Sheets containing datetimes not supported by pyxlsb&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">df1 = pd.read_excel(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">df2 = pd.read_excel(</span>
            <span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet2&quot;</span><span class="s0">, </span><span class="s1">skiprows=[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span>
        <span class="s1">)</span>
        <span class="s3"># TODO add index to file</span>
        <span class="s1">tm.assert_frame_equal(df1</span><span class="s0">, </span><span class="s1">df_ref</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df2</span><span class="s0">, </span><span class="s1">df_ref</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">df3 = pd.read_excel(</span>
            <span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">skipfooter=</span><span class="s5">1</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df3</span><span class="s0">, </span><span class="s1">df1.iloc[:-</span><span class="s5">1</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_reader_special_dtypes(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s0">if </span><span class="s1">read_ext == </span><span class="s2">&quot;.xlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;Sheets containing datetimes not supported by pyxlsb&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">expected = DataFrame.from_dict(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;IntCol&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s1">-</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;FloatCol&quot;</span><span class="s1">: [</span><span class="s5">1.25</span><span class="s0">, </span><span class="s5">2.25</span><span class="s0">, </span><span class="s5">1.83</span><span class="s0">, </span><span class="s5">1.92</span><span class="s0">, </span><span class="s5">0.0000000005</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;BoolCol&quot;</span><span class="s1">: [</span><span class="s0">True, False, True, True, False</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;StrCol&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s3"># GH5394 - this is why convert_float isn't vectorized</span>
                <span class="s2">&quot;Str2Col&quot;</span><span class="s1">: [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;DateCol&quot;</span><span class="s1">: [</span>
                    <span class="s1">datetime(</span><span class="s5">2013</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">30</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">datetime(</span><span class="s5">2013</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">31</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">datetime(</span><span class="s5">1905</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">datetime(</span><span class="s5">2013</span><span class="s0">, </span><span class="s5">12</span><span class="s0">, </span><span class="s5">14</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">datetime(</span><span class="s5">2015</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">14</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">basename = </span><span class="s2">&quot;test_types&quot;</span>

        <span class="s3"># should read in correctly and infer types</span>
        <span class="s1">actual = pd.read_excel(basename + read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s3"># if not coercing number, then int comes in as float</span>
        <span class="s1">float_expected = expected.copy()</span>
        <span class="s1">float_expected[</span><span class="s2">&quot;IntCol&quot;</span><span class="s1">] = float_expected[</span><span class="s2">&quot;IntCol&quot;</span><span class="s1">].astype(float)</span>
        <span class="s1">float_expected.loc[float_expected.index[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;Str2Col&quot;</span><span class="s1">] = </span><span class="s5">3.0</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s2">&quot;convert_float is deprecated&quot;</span><span class="s0">,</span>
            <span class="s1">raise_on_extra_warnings=</span><span class="s0">False,</span>
        <span class="s1">):</span>
            <span class="s3"># raise_on_extra_warnings because xlrd raises a PendingDeprecationWarning</span>
            <span class="s3"># on database job Linux_py37_IO (ci/deps/actions-37-db.yaml)</span>
            <span class="s3"># See GH#41176</span>
            <span class="s1">actual = pd.read_excel(</span>
                <span class="s1">basename + read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">convert_float=</span><span class="s0">False</span>
            <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">float_expected)</span>

        <span class="s3"># check setting Index (assuming xls and xlsx are the same here)</span>
        <span class="s0">for </span><span class="s1">icol</span><span class="s0">, </span><span class="s1">name </span><span class="s0">in </span><span class="s1">enumerate(expected.columns):</span>
            <span class="s1">actual = pd.read_excel(</span>
                <span class="s1">basename + read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=icol</span>
            <span class="s1">)</span>
            <span class="s1">exp = expected.set_index(name)</span>
            <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">exp)</span>

        <span class="s3"># convert_float and converters should be different but both accepted</span>
        <span class="s1">expected[</span><span class="s2">&quot;StrCol&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;StrCol&quot;</span><span class="s1">].apply(str)</span>
        <span class="s1">actual = pd.read_excel(</span>
            <span class="s1">basename + read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">converters={</span><span class="s2">&quot;StrCol&quot;</span><span class="s1">: str}</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">no_convert_float = float_expected.copy()</span>
        <span class="s1">no_convert_float[</span><span class="s2">&quot;StrCol&quot;</span><span class="s1">] = no_convert_float[</span><span class="s2">&quot;StrCol&quot;</span><span class="s1">].apply(str)</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s2">&quot;convert_float is deprecated&quot;</span><span class="s0">,</span>
            <span class="s1">raise_on_extra_warnings=</span><span class="s0">False,</span>
        <span class="s1">):</span>
            <span class="s3"># raise_on_extra_warnings because xlrd raises a PendingDeprecationWarning</span>
            <span class="s3"># on database job Linux_py37_IO (ci/deps/actions-37-db.yaml)</span>
            <span class="s3"># See GH#41176</span>
            <span class="s1">actual = pd.read_excel(</span>
                <span class="s1">basename + read_ext</span><span class="s0">,</span>
                <span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">,</span>
                <span class="s1">convert_float=</span><span class="s0">False,</span>
                <span class="s1">converters={</span><span class="s2">&quot;StrCol&quot;</span><span class="s1">: str}</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">no_convert_float)</span>

    <span class="s3"># GH8212 - support for converters and missing values</span>
    <span class="s0">def </span><span class="s1">test_reader_converters(self</span><span class="s0">, </span><span class="s1">read_ext):</span>

        <span class="s1">basename = </span><span class="s2">&quot;test_converters&quot;</span>

        <span class="s1">expected = DataFrame.from_dict(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;IntCol&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s1">-</span><span class="s5">3</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1000</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;FloatCol&quot;</span><span class="s1">: [</span><span class="s5">12.5</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s5">18.3</span><span class="s0">, </span><span class="s5">19.2</span><span class="s0">, </span><span class="s5">0.000000005</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;BoolCol&quot;</span><span class="s1">: [</span><span class="s2">&quot;Found&quot;</span><span class="s0">, </span><span class="s2">&quot;Found&quot;</span><span class="s0">, </span><span class="s2">&quot;Found&quot;</span><span class="s0">, </span><span class="s2">&quot;Not found&quot;</span><span class="s0">, </span><span class="s2">&quot;Found&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;StrCol&quot;</span><span class="s1">: [</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">&quot;3&quot;</span><span class="s0">, </span><span class="s2">&quot;4&quot;</span><span class="s0">, </span><span class="s2">&quot;5&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

        <span class="s1">converters = {</span>
            <span class="s2">&quot;IntCol&quot;</span><span class="s1">: </span><span class="s0">lambda </span><span class="s1">x: int(x) </span><span class="s0">if </span><span class="s1">x != </span><span class="s2">&quot;&quot; </span><span class="s0">else </span><span class="s1">-</span><span class="s5">1000</span><span class="s0">,</span>
            <span class="s2">&quot;FloatCol&quot;</span><span class="s1">: </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s5">10 </span><span class="s1">* x </span><span class="s0">if </span><span class="s1">x </span><span class="s0">else </span><span class="s1">np.nan</span><span class="s0">,</span>
            <span class="s5">2</span><span class="s1">: </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;Found&quot; </span><span class="s0">if </span><span class="s1">x != </span><span class="s2">&quot;&quot; </span><span class="s0">else </span><span class="s2">&quot;Not found&quot;</span><span class="s0">,</span>
            <span class="s5">3</span><span class="s1">: </span><span class="s0">lambda </span><span class="s1">x: str(x) </span><span class="s0">if </span><span class="s1">x </span><span class="s0">else </span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s3"># should read in correctly and set types of single cells (not array</span>
        <span class="s3"># dtypes)</span>
        <span class="s1">actual = pd.read_excel(</span>
            <span class="s1">basename + read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">converters=converters</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_reader_dtype(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># GH 8212</span>
        <span class="s1">basename = </span><span class="s2">&quot;testdtype&quot;</span>
        <span class="s1">actual = pd.read_excel(basename + read_ext)</span>

        <span class="s1">expected = DataFrame(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s5">2.5</span><span class="s0">, </span><span class="s5">3.5</span><span class="s0">, </span><span class="s5">4.5</span><span class="s0">, </span><span class="s5">5.5</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;d&quot;</span><span class="s1">: [</span><span class="s5">1.0</span><span class="s0">, </span><span class="s5">2.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s5">4.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">}</span>
        <span class="s1">).reindex(columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">])</span>

        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">actual = pd.read_excel(</span>
            <span class="s1">basename + read_ext</span><span class="s0">, </span><span class="s1">dtype={</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s2">&quot;float64&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s2">&quot;float32&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: str}</span>
        <span class="s1">)</span>

        <span class="s1">expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">].astype(</span><span class="s2">&quot;float64&quot;</span><span class="s1">)</span>
        <span class="s1">expected[</span><span class="s2">&quot;b&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;b&quot;</span><span class="s1">].astype(</span><span class="s2">&quot;float32&quot;</span><span class="s1">)</span>
        <span class="s1">expected[</span><span class="s2">&quot;c&quot;</span><span class="s1">] = [</span><span class="s2">&quot;001&quot;</span><span class="s0">, </span><span class="s2">&quot;002&quot;</span><span class="s0">, </span><span class="s2">&quot;003&quot;</span><span class="s0">, </span><span class="s2">&quot;004&quot;</span><span class="s1">]</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">msg = </span><span class="s2">&quot;Unable to convert column d to type int64&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">pd.read_excel(basename + read_ext</span><span class="s0">, </span><span class="s1">dtype={</span><span class="s2">&quot;d&quot;</span><span class="s1">: </span><span class="s2">&quot;int64&quot;</span><span class="s1">})</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;dtype,expected&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s0">None,</span>
                <span class="s1">DataFrame(</span>
                    <span class="s1">{</span>
                        <span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s5">2.5</span><span class="s0">, </span><span class="s5">3.5</span><span class="s0">, </span><span class="s5">4.5</span><span class="s0">, </span><span class="s5">5.5</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s2">&quot;d&quot;</span><span class="s1">: [</span><span class="s5">1.0</span><span class="s0">, </span><span class="s5">2.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s5">4.0</span><span class="s1">]</span><span class="s0">,</span>
                    <span class="s1">}</span>
                <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s2">&quot;float64&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s2">&quot;float32&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: str</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">: str}</span><span class="s0">,</span>
                <span class="s1">DataFrame(</span>
                    <span class="s1">{</span>
                        <span class="s2">&quot;a&quot;</span><span class="s1">: Series([</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;float64&quot;</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s2">&quot;b&quot;</span><span class="s1">: Series([</span><span class="s5">2.5</span><span class="s0">, </span><span class="s5">3.5</span><span class="s0">, </span><span class="s5">4.5</span><span class="s0">, </span><span class="s5">5.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;float32&quot;</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s2">&quot;001&quot;</span><span class="s0">, </span><span class="s2">&quot;002&quot;</span><span class="s0">, </span><span class="s2">&quot;003&quot;</span><span class="s0">, </span><span class="s2">&quot;004&quot;</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s2">&quot;d&quot;</span><span class="s1">: [</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">&quot;4&quot;</span><span class="s1">]</span><span class="s0">,</span>
                    <span class="s1">}</span>
                <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_reader_dtype_str(self</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s3"># see gh-20377</span>
        <span class="s1">basename = </span><span class="s2">&quot;testdtype&quot;</span>

        <span class="s1">actual = pd.read_excel(basename + read_ext</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtypes, exp_value&quot;</span><span class="s0">, </span><span class="s1">[({}</span><span class="s0">, </span><span class="s2">&quot;1&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">({</span><span class="s2">&quot;a.1&quot;</span><span class="s1">: </span><span class="s2">&quot;int64&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test_dtype_mangle_dup_cols(self</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">dtypes</span><span class="s0">, </span><span class="s1">exp_value):</span>
        <span class="s3"># GH#35211</span>
        <span class="s1">basename = </span><span class="s2">&quot;df_mangle_dup_col_dtypes&quot;</span>
        <span class="s1">dtype_dict = {</span><span class="s2">&quot;a&quot;</span><span class="s1">: str</span><span class="s0">, </span><span class="s1">**dtypes}</span>
        <span class="s1">dtype_dict_copy = dtype_dict.copy()</span>
        <span class="s3"># GH#42462</span>
        <span class="s1">result = pd.read_excel(basename + read_ext</span><span class="s0">, </span><span class="s1">dtype=dtype_dict)</span>
        <span class="s1">expected = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s2">&quot;1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;a.1&quot;</span><span class="s1">: [exp_value]})</span>
        <span class="s0">assert </span><span class="s1">dtype_dict == dtype_dict_copy</span><span class="s0">, </span><span class="s2">&quot;dtype dict changed&quot;</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_reader_spaces(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># see gh-32207</span>
        <span class="s1">basename = </span><span class="s2">&quot;test_spaces&quot;</span>

        <span class="s1">actual = pd.read_excel(basename + read_ext)</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;testcol&quot;</span><span class="s1">: [</span>
                    <span class="s2">&quot;this is great&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;4    spaces&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;1 trailing &quot;</span><span class="s0">,</span>
                    <span class="s2">&quot; 1 leading&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot;2  spaces  multiple  times&quot;</span><span class="s0">,</span>
                <span class="s1">]</span>
            <span class="s1">}</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s3"># gh-36122, gh-35802</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;basename,expected&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s2">&quot;gh-35802&quot;</span><span class="s0">, </span><span class="s1">DataFrame({</span><span class="s2">&quot;COLUMN&quot;</span><span class="s1">: [</span><span class="s2">&quot;Test (1)&quot;</span><span class="s1">]}))</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;gh-36122&quot;</span><span class="s0">, </span><span class="s1">DataFrame(columns=[</span><span class="s2">&quot;got 2nd sa&quot;</span><span class="s1">]))</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_read_excel_ods_nested_xml(self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">basename</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s3"># see gh-35802</span>
        <span class="s0">if </span><span class="s1">engine != </span><span class="s2">&quot;odf&quot;</span><span class="s1">:</span>
            <span class="s1">pytest.skip(</span><span class="s2">f&quot;Skipped for engine: </span><span class="s0">{</span><span class="s1">engine</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

        <span class="s1">actual = pd.read_excel(basename + read_ext)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_reading_all_sheets(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># Test reading all sheet names by setting sheet_name to None,</span>
        <span class="s3"># Ensure a dict is returned.</span>
        <span class="s3"># See PR #9450</span>
        <span class="s1">basename = </span><span class="s2">&quot;test_multisheet&quot;</span>
        <span class="s1">dfs = pd.read_excel(basename + read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s3"># ensure this is not alphabetical to test order preservation</span>
        <span class="s1">expected_keys = [</span><span class="s2">&quot;Charlie&quot;</span><span class="s0">, </span><span class="s2">&quot;Alpha&quot;</span><span class="s0">, </span><span class="s2">&quot;Beta&quot;</span><span class="s1">]</span>
        <span class="s1">tm.assert_contains_all(expected_keys</span><span class="s0">, </span><span class="s1">dfs.keys())</span>
        <span class="s3"># Issue 9930</span>
        <span class="s3"># Ensure sheet order is preserved</span>
        <span class="s0">assert </span><span class="s1">expected_keys == list(dfs.keys())</span>

    <span class="s0">def </span><span class="s1">test_reading_multiple_specific_sheets(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># Test reading specific sheet names by specifying a mixed list</span>
        <span class="s3"># of integers and strings, and confirm that duplicated sheet</span>
        <span class="s3"># references (positions/names) are removed properly.</span>
        <span class="s3"># Ensure a dict is returned</span>
        <span class="s3"># See PR #9450</span>
        <span class="s1">basename = </span><span class="s2">&quot;test_multisheet&quot;</span>
        <span class="s3"># Explicitly request duplicates. Only the set should be returned.</span>
        <span class="s1">expected_keys = [</span><span class="s5">2</span><span class="s0">, </span><span class="s2">&quot;Charlie&quot;</span><span class="s0">, </span><span class="s2">&quot;Charlie&quot;</span><span class="s1">]</span>
        <span class="s1">dfs = pd.read_excel(basename + read_ext</span><span class="s0">, </span><span class="s1">sheet_name=expected_keys)</span>
        <span class="s1">expected_keys = list(set(expected_keys))</span>
        <span class="s1">tm.assert_contains_all(expected_keys</span><span class="s0">, </span><span class="s1">dfs.keys())</span>
        <span class="s0">assert </span><span class="s1">len(expected_keys) == len(dfs.keys())</span>

    <span class="s0">def </span><span class="s1">test_reading_all_sheets_with_blank(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># Test reading all sheet names by setting sheet_name to None,</span>
        <span class="s3"># In the case where some sheets are blank.</span>
        <span class="s3"># Issue #11711</span>
        <span class="s1">basename = </span><span class="s2">&quot;blank_with_header&quot;</span>
        <span class="s1">dfs = pd.read_excel(basename + read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">expected_keys = [</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s2">&quot;Sheet2&quot;</span><span class="s0">, </span><span class="s2">&quot;Sheet3&quot;</span><span class="s1">]</span>
        <span class="s1">tm.assert_contains_all(expected_keys</span><span class="s0">, </span><span class="s1">dfs.keys())</span>

    <span class="s3"># GH6403</span>
    <span class="s0">def </span><span class="s1">test_read_excel_blank(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s1">actual = pd.read_excel(</span><span class="s2">&quot;blank&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">DataFrame())</span>

    <span class="s0">def </span><span class="s1">test_read_excel_blank_with_header(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s1">expected = DataFrame(columns=[</span><span class="s2">&quot;col_1&quot;</span><span class="s0">, </span><span class="s2">&quot;col_2&quot;</span><span class="s1">])</span>
        <span class="s1">actual = pd.read_excel(</span><span class="s2">&quot;blank_with_header&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_date_conversion_overflow(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># GH 10001 : pandas.ExcelFile ignore parse_dates=False</span>
        <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;pyxlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;Sheets containing datetimes not supported by pyxlsb&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">expected = DataFrame(</span>
            <span class="s1">[</span>
                <span class="s1">[pd.Timestamp(</span><span class="s2">&quot;2016-03-12&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;Marc Johnson&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[pd.Timestamp(</span><span class="s2">&quot;2016-03-16&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;Jack Black&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s5">1e20</span><span class="s0">, </span><span class="s2">&quot;Timothy Brown&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">columns=[</span><span class="s2">&quot;DateColWithBigInt&quot;</span><span class="s0">, </span><span class="s2">&quot;StringCol&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;openpyxl&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(reason=</span><span class="s2">&quot;Maybe not supported by openpyxl&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">engine </span><span class="s0">is None and </span><span class="s1">read_ext </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;.xlsx&quot;</span><span class="s0">, </span><span class="s2">&quot;.xlsm&quot;</span><span class="s1">):</span>
            <span class="s3"># GH 35029</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(reason=</span><span class="s2">&quot;Defaults to openpyxl, maybe not supported&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">result = pd.read_excel(</span><span class="s2">&quot;testdateoverflow&quot; </span><span class="s1">+ read_ext)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_sheet_name(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">df_ref):</span>
        <span class="s0">if </span><span class="s1">read_ext == </span><span class="s2">&quot;.xlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;Sheets containing datetimes not supported by pyxlsb&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">filename = </span><span class="s2">&quot;test1&quot;</span>
        <span class="s1">sheet_name = </span><span class="s2">&quot;Sheet1&quot;</span>

        <span class="s1">df1 = pd.read_excel(</span>
            <span class="s1">filename + read_ext</span><span class="s0">, </span><span class="s1">sheet_name=sheet_name</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span>
        <span class="s1">)  </span><span class="s3"># doc</span>
        <span class="s1">df2 = pd.read_excel(filename + read_ext</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">sheet_name=sheet_name)</span>

        <span class="s1">tm.assert_frame_equal(df1</span><span class="s0">, </span><span class="s1">df_ref</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df2</span><span class="s0">, </span><span class="s1">df_ref</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_excel_read_buffer(self</span><span class="s0">, </span><span class="s1">read_ext):</span>

        <span class="s1">pth = </span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span>
        <span class="s1">expected = pd.read_excel(pth</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">open(pth</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
            <span class="s1">actual = pd.read_excel(f</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">actual)</span>

    <span class="s0">def </span><span class="s1">test_bad_engine_raises(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s1">bad_engine = </span><span class="s2">&quot;foo&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Unknown engine: foo&quot;</span><span class="s1">):</span>
            <span class="s1">pd.read_excel(</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">engine=bad_engine)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;sheet_name&quot;</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;Sheet4&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s2">&quot;Sheet4&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;Sheet4&quot;</span><span class="s0">, </span><span class="s2">&quot;Sheet1&quot;</span><span class="s1">]]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_bad_sheetname_raises(self</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">sheet_name):</span>
        <span class="s3"># GH 39250</span>
        <span class="s1">msg = </span><span class="s2">&quot;Worksheet index 3 is invalid|Worksheet named 'Sheet4' not found&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">pd.read_excel(</span><span class="s2">&quot;blank&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=sheet_name)</span>

    <span class="s0">def </span><span class="s1">test_missing_file_raises(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s1">bad_file = </span><span class="s2">f&quot;foo</span><span class="s0">{</span><span class="s1">read_ext</span><span class="s0">}</span><span class="s2">&quot;</span>
        <span class="s3"># CI tests with other languages, translates to &quot;No such file or directory&quot;</span>
        <span class="s1">match = </span><span class="s2">r&quot;(No such file or directory|没有那个文件或目录|File o directory non esistente)&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(FileNotFoundError</span><span class="s0">, </span><span class="s1">match=match):</span>
            <span class="s1">pd.read_excel(bad_file)</span>

    <span class="s0">def </span><span class="s1">test_corrupt_bytes_raises(self</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">engine):</span>
        <span class="s1">bad_stream = </span><span class="s6">b&quot;foo&quot;</span>
        <span class="s0">if </span><span class="s1">engine </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">error = ValueError</span>
            <span class="s1">msg = (</span>
                <span class="s2">&quot;Excel file format cannot be determined, you must &quot;</span>
                <span class="s2">&quot;specify an engine manually.&quot;</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">engine == </span><span class="s2">&quot;xlrd&quot;</span><span class="s1">:</span>
            <span class="s0">from </span><span class="s1">xlrd </span><span class="s0">import </span><span class="s1">XLRDError</span>

            <span class="s1">error = XLRDError</span>
            <span class="s1">msg = (</span>
                <span class="s2">&quot;Unsupported format, or corrupt file: Expected BOF &quot;</span>
                <span class="s2">&quot;record; found b'foo'&quot;</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">error = BadZipFile</span>
            <span class="s1">msg = </span><span class="s2">&quot;File is not a zip file&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(error</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">pd.read_excel(bad_stream)</span>

    <span class="s1">@tm.network</span>
    <span class="s0">def </span><span class="s1">test_read_from_http_url(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s1">url = (</span>
            <span class="s2">&quot;https://raw.githubusercontent.com/pandas-dev/pandas/main/&quot;</span>
            <span class="s2">&quot;pandas/tests/io/data/excel/test1&quot; </span><span class="s1">+ read_ext</span>
        <span class="s1">)</span>
        <span class="s1">url_table = pd.read_excel(url)</span>
        <span class="s1">local_table = pd.read_excel(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext)</span>
        <span class="s1">tm.assert_frame_equal(url_table</span><span class="s0">, </span><span class="s1">local_table)</span>

    <span class="s1">@td.skip_if_not_us_locale</span>
    <span class="s0">def </span><span class="s1">test_read_from_s3_url(self</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">s3_resource</span><span class="s0">, </span><span class="s1">s3so):</span>
        <span class="s3"># Bucket &quot;pandas-test&quot; created in tests/io/conftest.py</span>
        <span class="s0">with </span><span class="s1">open(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
            <span class="s1">s3_resource.Bucket(</span><span class="s2">&quot;pandas-test&quot;</span><span class="s1">).put_object(Key=</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">Body=f)</span>

        <span class="s1">url = </span><span class="s2">&quot;s3://pandas-test/test1&quot; </span><span class="s1">+ read_ext</span>

        <span class="s1">url_table = pd.read_excel(url</span><span class="s0">, </span><span class="s1">storage_options=s3so)</span>
        <span class="s1">local_table = pd.read_excel(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext)</span>
        <span class="s1">tm.assert_frame_equal(url_table</span><span class="s0">, </span><span class="s1">local_table)</span>

    <span class="s0">def </span><span class="s1">test_read_from_s3_object(self</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">s3_resource</span><span class="s0">, </span><span class="s1">s3so):</span>
        <span class="s3"># GH 38788</span>
        <span class="s3"># Bucket &quot;pandas-test&quot; created in tests/io/conftest.py</span>
        <span class="s0">with </span><span class="s1">open(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
            <span class="s1">s3_resource.Bucket(</span><span class="s2">&quot;pandas-test&quot;</span><span class="s1">).put_object(Key=</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">Body=f)</span>

        <span class="s0">import </span><span class="s1">s3fs</span>

        <span class="s1">s3 = s3fs.S3FileSystem(**s3so)</span>

        <span class="s0">with </span><span class="s1">s3.open(</span><span class="s2">&quot;s3://pandas-test/test1&quot; </span><span class="s1">+ read_ext) </span><span class="s0">as </span><span class="s1">f:</span>
            <span class="s1">url_table = pd.read_excel(f)</span>

        <span class="s1">local_table = pd.read_excel(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext)</span>
        <span class="s1">tm.assert_frame_equal(url_table</span><span class="s0">, </span><span class="s1">local_table)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_read_from_file_url(self</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">datapath):</span>

        <span class="s3"># FILE</span>
        <span class="s1">localtable = os.path.join(datapath(</span><span class="s2">&quot;io&quot;</span><span class="s0">, </span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;excel&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext)</span>
        <span class="s1">local_table = pd.read_excel(localtable)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">url_table = pd.read_excel(</span><span class="s2">&quot;file://localhost/&quot; </span><span class="s1">+ localtable)</span>
        <span class="s0">except </span><span class="s1">URLError:</span>
            <span class="s3"># fails on some systems</span>
            <span class="s0">import </span><span class="s1">platform</span>

            <span class="s1">platform_info = </span><span class="s2">&quot; &quot;</span><span class="s1">.join(platform.uname()).strip()</span>
            <span class="s1">pytest.skip(</span><span class="s2">f&quot;failing on </span><span class="s0">{</span><span class="s1">platform_info</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

        <span class="s1">tm.assert_frame_equal(url_table</span><span class="s0">, </span><span class="s1">local_table)</span>

    <span class="s0">def </span><span class="s1">test_read_from_pathlib_path(self</span><span class="s0">, </span><span class="s1">read_ext):</span>

        <span class="s3"># GH12655</span>
        <span class="s0">from </span><span class="s1">pathlib </span><span class="s0">import </span><span class="s1">Path</span>

        <span class="s1">str_path = </span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span>
        <span class="s1">expected = pd.read_excel(str_path</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">path_obj = Path(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext)</span>
        <span class="s1">actual = pd.read_excel(path_obj</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">actual)</span>

    <span class="s1">@td.skip_if_no(</span><span class="s2">&quot;py.path&quot;</span><span class="s1">)</span>
    <span class="s1">@td.check_file_leaks</span>
    <span class="s0">def </span><span class="s1">test_read_from_py_localpath(self</span><span class="s0">, </span><span class="s1">read_ext):</span>

        <span class="s3"># GH12655</span>
        <span class="s0">from </span><span class="s1">py.path </span><span class="s0">import </span><span class="s1">local </span><span class="s0">as </span><span class="s1">LocalPath</span>

        <span class="s1">str_path = os.path.join(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext)</span>
        <span class="s1">expected = pd.read_excel(str_path</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">path_obj = LocalPath().join(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext)</span>
        <span class="s1">actual = pd.read_excel(path_obj</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">actual)</span>

    <span class="s1">@td.check_file_leaks</span>
    <span class="s0">def </span><span class="s1">test_close_from_py_localpath(self</span><span class="s0">, </span><span class="s1">read_ext):</span>

        <span class="s3"># GH31467</span>
        <span class="s1">str_path = os.path.join(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext)</span>
        <span class="s0">with </span><span class="s1">open(str_path</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
            <span class="s1">x = pd.read_excel(f</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s0">del </span><span class="s1">x</span>
            <span class="s3"># should not throw an exception because the passed file was closed</span>
            <span class="s1">f.read()</span>

    <span class="s0">def </span><span class="s1">test_reader_seconds(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;pyxlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;Sheets containing datetimes not supported by pyxlsb&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s3"># Test reading times with and without milliseconds. GH5945.</span>
        <span class="s1">expected = DataFrame.from_dict(</span>
            <span class="s1">{</span>
                <span class="s2">&quot;Time&quot;</span><span class="s1">: [</span>
                    <span class="s1">time(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">time(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">45</span><span class="s0">, </span><span class="s5">56</span><span class="s0">, </span><span class="s5">100000</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">time(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">29</span><span class="s0">, </span><span class="s5">49</span><span class="s0">, </span><span class="s5">200000</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">time(</span><span class="s5">6</span><span class="s0">, </span><span class="s5">13</span><span class="s0">, </span><span class="s5">42</span><span class="s0">, </span><span class="s5">300000</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">time(</span><span class="s5">7</span><span class="s0">, </span><span class="s5">57</span><span class="s0">, </span><span class="s5">35</span><span class="s0">, </span><span class="s5">400000</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">time(</span><span class="s5">9</span><span class="s0">, </span><span class="s5">41</span><span class="s0">, </span><span class="s5">28</span><span class="s0">, </span><span class="s5">500000</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">time(</span><span class="s5">11</span><span class="s0">, </span><span class="s5">25</span><span class="s0">, </span><span class="s5">21</span><span class="s0">, </span><span class="s5">600000</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">time(</span><span class="s5">13</span><span class="s0">, </span><span class="s5">9</span><span class="s0">, </span><span class="s5">14</span><span class="s0">, </span><span class="s5">700000</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">time(</span><span class="s5">14</span><span class="s0">, </span><span class="s5">53</span><span class="s0">, </span><span class="s5">7</span><span class="s0">, </span><span class="s5">800000</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">time(</span><span class="s5">16</span><span class="s0">, </span><span class="s5">37</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">900000</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">time(</span><span class="s5">18</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">54</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">]</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

        <span class="s1">actual = pd.read_excel(</span><span class="s2">&quot;times_1900&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">actual = pd.read_excel(</span><span class="s2">&quot;times_1904&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_read_excel_multiindex(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># see gh-4679</span>
        <span class="s0">if </span><span class="s1">read_ext == </span><span class="s2">&quot;.xlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;Sheets containing datetimes not supported by pyxlsb&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">mi = MultiIndex.from_product([[</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]])</span>
        <span class="s1">mi_file = </span><span class="s2">&quot;testmultiindex&quot; </span><span class="s1">+ read_ext</span>

        <span class="s3"># &quot;mi_column&quot; sheet</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2.5</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s2">&quot;2015-01-01&quot;</span><span class="s1">)</span><span class="s0">, True</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3.5</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s2">&quot;2015-01-02&quot;</span><span class="s1">)</span><span class="s0">, False</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4.5</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s2">&quot;2015-01-03&quot;</span><span class="s1">)</span><span class="s0">, False</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">5.5</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s2">&quot;2015-01-04&quot;</span><span class="s1">)</span><span class="s0">, True</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">columns=mi</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">actual = pd.read_excel(</span>
            <span class="s1">mi_file</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;mi_column&quot;</span><span class="s0">, </span><span class="s1">header=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s3"># &quot;mi_index&quot; sheet</span>
        <span class="s1">expected.index = mi</span>
        <span class="s1">expected.columns = [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]</span>

        <span class="s1">actual = pd.read_excel(mi_file</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;mi_index&quot;</span><span class="s0">, </span><span class="s1">index_col=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s3"># &quot;both&quot; sheet</span>
        <span class="s1">expected.columns = mi</span>

        <span class="s1">actual = pd.read_excel(</span>
            <span class="s1">mi_file</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;both&quot;</span><span class="s0">, </span><span class="s1">index_col=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">header=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s3"># &quot;mi_index_name&quot; sheet</span>
        <span class="s1">expected.columns = [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]</span>
        <span class="s1">expected.index = mi.set_names([</span><span class="s2">&quot;ilvl1&quot;</span><span class="s0">, </span><span class="s2">&quot;ilvl2&quot;</span><span class="s1">])</span>

        <span class="s1">actual = pd.read_excel(mi_file</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;mi_index_name&quot;</span><span class="s0">, </span><span class="s1">index_col=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s3"># &quot;mi_column_name&quot; sheet</span>
        <span class="s1">expected.index = list(range(</span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">expected.columns = mi.set_names([</span><span class="s2">&quot;c1&quot;</span><span class="s0">, </span><span class="s2">&quot;c2&quot;</span><span class="s1">])</span>
        <span class="s1">actual = pd.read_excel(</span>
            <span class="s1">mi_file</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;mi_column_name&quot;</span><span class="s0">, </span><span class="s1">header=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s3"># see gh-11317</span>
        <span class="s3"># &quot;name_with_int&quot; sheet</span>
        <span class="s1">expected.columns = mi.set_levels([</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">level=</span><span class="s5">1</span><span class="s1">).set_names([</span><span class="s2">&quot;c1&quot;</span><span class="s0">, </span><span class="s2">&quot;c2&quot;</span><span class="s1">])</span>

        <span class="s1">actual = pd.read_excel(</span>
            <span class="s1">mi_file</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;name_with_int&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">header=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s3"># &quot;both_name&quot; sheet</span>
        <span class="s1">expected.columns = mi.set_names([</span><span class="s2">&quot;c1&quot;</span><span class="s0">, </span><span class="s2">&quot;c2&quot;</span><span class="s1">])</span>
        <span class="s1">expected.index = mi.set_names([</span><span class="s2">&quot;ilvl1&quot;</span><span class="s0">, </span><span class="s2">&quot;ilvl2&quot;</span><span class="s1">])</span>

        <span class="s1">actual = pd.read_excel(</span>
            <span class="s1">mi_file</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;both_name&quot;</span><span class="s0">, </span><span class="s1">index_col=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">header=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s3"># &quot;both_skiprows&quot; sheet</span>
        <span class="s1">actual = pd.read_excel(</span>
            <span class="s1">mi_file</span><span class="s0">,</span>
            <span class="s1">sheet_name=</span><span class="s2">&quot;both_name_skiprows&quot;</span><span class="s0">,</span>
            <span class="s1">index_col=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">header=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">skiprows=</span><span class="s5">2</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;sheet_name,idx_lvl2&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s2">&quot;both_name_blank_after_mi_name&quot;</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;both_name_multiple_blanks&quot;</span><span class="s0">, </span><span class="s1">[np.nan] * </span><span class="s5">4</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_read_excel_multiindex_blank_after_name(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">sheet_name</span><span class="s0">, </span><span class="s1">idx_lvl2</span>
    <span class="s1">):</span>
        <span class="s3"># GH34673</span>
        <span class="s0">if </span><span class="s1">read_ext == </span><span class="s2">&quot;.xlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;Sheets containing datetimes not supported by pyxlsb (GH4679&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">mi_file = </span><span class="s2">&quot;testmultiindex&quot; </span><span class="s1">+ read_ext</span>
        <span class="s1">mi = MultiIndex.from_product([[</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">names=[</span><span class="s2">&quot;c1&quot;</span><span class="s0">, </span><span class="s2">&quot;c2&quot;</span><span class="s1">])</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2.5</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s2">&quot;2015-01-01&quot;</span><span class="s1">)</span><span class="s0">, True</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3.5</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s2">&quot;2015-01-02&quot;</span><span class="s1">)</span><span class="s0">, False</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4.5</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s2">&quot;2015-01-03&quot;</span><span class="s1">)</span><span class="s0">, False</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">5.5</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s2">&quot;2015-01-04&quot;</span><span class="s1">)</span><span class="s0">, True</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">columns=mi</span><span class="s0">,</span>
            <span class="s1">index=MultiIndex.from_arrays(</span>
                <span class="s1">([</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">idx_lvl2)</span><span class="s0">,</span>
                <span class="s1">names=[</span><span class="s2">&quot;ilvl1&quot;</span><span class="s0">, </span><span class="s2">&quot;ilvl2&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">result = pd.read_excel(</span>
            <span class="s1">mi_file</span><span class="s0">,</span>
            <span class="s1">sheet_name=sheet_name</span><span class="s0">,</span>
            <span class="s1">index_col=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">header=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_read_excel_multiindex_header_only(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># see gh-11733.</span>
        <span class="s3">#</span>
        <span class="s3"># Don't try to parse a header name if there isn't one.</span>
        <span class="s1">mi_file = </span><span class="s2">&quot;testmultiindex&quot; </span><span class="s1">+ read_ext</span>
        <span class="s1">result = pd.read_excel(mi_file</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;index_col_none&quot;</span><span class="s0">, </span><span class="s1">header=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">])</span>

        <span class="s1">exp_columns = MultiIndex.from_product([(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;key&quot;</span><span class="s0">, </span><span class="s2">&quot;val&quot;</span><span class="s1">)])</span>
        <span class="s1">expected = DataFrame([[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]] * </span><span class="s5">2</span><span class="s0">, </span><span class="s1">columns=exp_columns)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_excel_old_index_format(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># see gh-4679</span>
        <span class="s1">filename = </span><span class="s2">&quot;test_index_name_pre17&quot; </span><span class="s1">+ read_ext</span>

        <span class="s3"># We detect headers to determine if index names exist, so</span>
        <span class="s3"># that &quot;index&quot; name in the &quot;names&quot; version of the data will</span>
        <span class="s3"># now be interpreted as rows that include null data.</span>
        <span class="s1">data = np.array(</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s0">None, None, None, None, None</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;R0C0&quot;</span><span class="s0">, </span><span class="s2">&quot;R0C1&quot;</span><span class="s0">, </span><span class="s2">&quot;R0C2&quot;</span><span class="s0">, </span><span class="s2">&quot;R0C3&quot;</span><span class="s0">, </span><span class="s2">&quot;R0C4&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;R1C0&quot;</span><span class="s0">, </span><span class="s2">&quot;R1C1&quot;</span><span class="s0">, </span><span class="s2">&quot;R1C2&quot;</span><span class="s0">, </span><span class="s2">&quot;R1C3&quot;</span><span class="s0">, </span><span class="s2">&quot;R1C4&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;R2C0&quot;</span><span class="s0">, </span><span class="s2">&quot;R2C1&quot;</span><span class="s0">, </span><span class="s2">&quot;R2C2&quot;</span><span class="s0">, </span><span class="s2">&quot;R2C3&quot;</span><span class="s0">, </span><span class="s2">&quot;R2C4&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;R3C0&quot;</span><span class="s0">, </span><span class="s2">&quot;R3C1&quot;</span><span class="s0">, </span><span class="s2">&quot;R3C2&quot;</span><span class="s0">, </span><span class="s2">&quot;R3C3&quot;</span><span class="s0">, </span><span class="s2">&quot;R3C4&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;R4C0&quot;</span><span class="s0">, </span><span class="s2">&quot;R4C1&quot;</span><span class="s0">, </span><span class="s2">&quot;R4C2&quot;</span><span class="s0">, </span><span class="s2">&quot;R4C3&quot;</span><span class="s0">, </span><span class="s2">&quot;R4C4&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">columns = [</span><span class="s2">&quot;C_l0_g0&quot;</span><span class="s0">, </span><span class="s2">&quot;C_l0_g1&quot;</span><span class="s0">, </span><span class="s2">&quot;C_l0_g2&quot;</span><span class="s0">, </span><span class="s2">&quot;C_l0_g3&quot;</span><span class="s0">, </span><span class="s2">&quot;C_l0_g4&quot;</span><span class="s1">]</span>
        <span class="s1">mi = MultiIndex(</span>
            <span class="s1">levels=[</span>
                <span class="s1">[</span><span class="s2">&quot;R0&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l0_g0&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l0_g1&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l0_g2&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l0_g3&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l0_g4&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;R1&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l1_g0&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l1_g1&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l1_g2&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l1_g3&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l1_g4&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">codes=[[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">names=[</span><span class="s0">None, None</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">si = Index(</span>
            <span class="s1">[</span><span class="s2">&quot;R0&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l0_g0&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l0_g1&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l0_g2&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l0_g3&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l0_g4&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None</span>
        <span class="s1">)</span>

        <span class="s1">expected = DataFrame(data</span><span class="s0">, </span><span class="s1">index=si</span><span class="s0">, </span><span class="s1">columns=columns)</span>

        <span class="s1">actual = pd.read_excel(filename</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;single_names&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected.index = mi</span>

        <span class="s1">actual = pd.read_excel(filename</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;multi_names&quot;</span><span class="s0">, </span><span class="s1">index_col=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s3"># The analogous versions of the &quot;names&quot; version data</span>
        <span class="s3"># where there are explicitly no names for the indices.</span>
        <span class="s1">data = np.array(</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s2">&quot;R0C0&quot;</span><span class="s0">, </span><span class="s2">&quot;R0C1&quot;</span><span class="s0">, </span><span class="s2">&quot;R0C2&quot;</span><span class="s0">, </span><span class="s2">&quot;R0C3&quot;</span><span class="s0">, </span><span class="s2">&quot;R0C4&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;R1C0&quot;</span><span class="s0">, </span><span class="s2">&quot;R1C1&quot;</span><span class="s0">, </span><span class="s2">&quot;R1C2&quot;</span><span class="s0">, </span><span class="s2">&quot;R1C3&quot;</span><span class="s0">, </span><span class="s2">&quot;R1C4&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;R2C0&quot;</span><span class="s0">, </span><span class="s2">&quot;R2C1&quot;</span><span class="s0">, </span><span class="s2">&quot;R2C2&quot;</span><span class="s0">, </span><span class="s2">&quot;R2C3&quot;</span><span class="s0">, </span><span class="s2">&quot;R2C4&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;R3C0&quot;</span><span class="s0">, </span><span class="s2">&quot;R3C1&quot;</span><span class="s0">, </span><span class="s2">&quot;R3C2&quot;</span><span class="s0">, </span><span class="s2">&quot;R3C3&quot;</span><span class="s0">, </span><span class="s2">&quot;R3C4&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;R4C0&quot;</span><span class="s0">, </span><span class="s2">&quot;R4C1&quot;</span><span class="s0">, </span><span class="s2">&quot;R4C2&quot;</span><span class="s0">, </span><span class="s2">&quot;R4C3&quot;</span><span class="s0">, </span><span class="s2">&quot;R4C4&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">columns = [</span><span class="s2">&quot;C_l0_g0&quot;</span><span class="s0">, </span><span class="s2">&quot;C_l0_g1&quot;</span><span class="s0">, </span><span class="s2">&quot;C_l0_g2&quot;</span><span class="s0">, </span><span class="s2">&quot;C_l0_g3&quot;</span><span class="s0">, </span><span class="s2">&quot;C_l0_g4&quot;</span><span class="s1">]</span>
        <span class="s1">mi = MultiIndex(</span>
            <span class="s1">levels=[</span>
                <span class="s1">[</span><span class="s2">&quot;R_l0_g0&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l0_g1&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l0_g2&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l0_g3&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l0_g4&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">&quot;R_l1_g0&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l1_g1&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l1_g2&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l1_g3&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l1_g4&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">codes=[[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">names=[</span><span class="s0">None, None</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">si = Index([</span><span class="s2">&quot;R_l0_g0&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l0_g1&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l0_g2&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l0_g3&quot;</span><span class="s0">, </span><span class="s2">&quot;R_l0_g4&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s1">expected = DataFrame(data</span><span class="s0">, </span><span class="s1">index=si</span><span class="s0">, </span><span class="s1">columns=columns)</span>

        <span class="s1">actual = pd.read_excel(filename</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;single_no_names&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected.index = mi</span>

        <span class="s1">actual = pd.read_excel(filename</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;multi_no_names&quot;</span><span class="s0">, </span><span class="s1">index_col=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_read_excel_bool_header_arg(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># GH 6114</span>
        <span class="s1">msg = </span><span class="s2">&quot;Passing a bool to header is invalid&quot;</span>
        <span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">]:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">pd.read_excel(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">header=arg)</span>

    <span class="s0">def </span><span class="s1">test_read_excel_skiprows(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># GH 4903</span>
        <span class="s0">if </span><span class="s1">read_ext == </span><span class="s2">&quot;.xlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;Sheets containing datetimes not supported by pyxlsb&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">actual = pd.read_excel(</span>
            <span class="s2">&quot;testskiprows&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;skiprows_list&quot;</span><span class="s0">, </span><span class="s1">skiprows=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2.5</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s2">&quot;2015-01-01&quot;</span><span class="s1">)</span><span class="s0">, True</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3.5</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s2">&quot;2015-01-02&quot;</span><span class="s1">)</span><span class="s0">, False</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4.5</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s2">&quot;2015-01-03&quot;</span><span class="s1">)</span><span class="s0">, False</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">5.5</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s2">&quot;2015-01-04&quot;</span><span class="s1">)</span><span class="s0">, True</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">actual = pd.read_excel(</span>
            <span class="s2">&quot;testskiprows&quot; </span><span class="s1">+ read_ext</span><span class="s0">,</span>
            <span class="s1">sheet_name=</span><span class="s2">&quot;skiprows_list&quot;</span><span class="s0">,</span>
            <span class="s1">skiprows=np.array([</span><span class="s5">0</span><span class="s0">, </span><span class="s5">2</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s3"># GH36435</span>
        <span class="s1">actual = pd.read_excel(</span>
            <span class="s2">&quot;testskiprows&quot; </span><span class="s1">+ read_ext</span><span class="s0">,</span>
            <span class="s1">sheet_name=</span><span class="s2">&quot;skiprows_list&quot;</span><span class="s0">,</span>
            <span class="s1">skiprows=</span><span class="s0">lambda </span><span class="s1">x: x </span><span class="s0">in </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">actual = pd.read_excel(</span>
            <span class="s2">&quot;testskiprows&quot; </span><span class="s1">+ read_ext</span><span class="s0">,</span>
            <span class="s1">sheet_name=</span><span class="s2">&quot;skiprows_list&quot;</span><span class="s0">,</span>
            <span class="s1">skiprows=</span><span class="s5">3</span><span class="s0">,</span>
            <span class="s1">names=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">[</span>
                <span class="s3"># [1, 2.5, pd.Timestamp(&quot;2015-01-01&quot;), True],</span>
                <span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3.5</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s2">&quot;2015-01-02&quot;</span><span class="s1">)</span><span class="s0">, False</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4.5</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s2">&quot;2015-01-03&quot;</span><span class="s1">)</span><span class="s0">, False</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">5.5</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s2">&quot;2015-01-04&quot;</span><span class="s1">)</span><span class="s0">, True</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_read_excel_nrows(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># GH 16645</span>
        <span class="s1">num_rows_to_pull = </span><span class="s5">5</span>
        <span class="s1">actual = pd.read_excel(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">nrows=num_rows_to_pull)</span>
        <span class="s1">expected = pd.read_excel(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext)</span>
        <span class="s1">expected = expected[:num_rows_to_pull]</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_read_excel_nrows_greater_than_nrows_in_file(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># GH 16645</span>
        <span class="s1">expected = pd.read_excel(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext)</span>
        <span class="s1">num_records_in_file = len(expected)</span>
        <span class="s1">num_rows_to_pull = num_records_in_file + </span><span class="s5">10</span>
        <span class="s1">actual = pd.read_excel(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">nrows=num_rows_to_pull)</span>
        <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_read_excel_nrows_non_integer_parameter(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># GH 16645</span>
        <span class="s1">msg = </span><span class="s2">&quot;'nrows' must be an integer &gt;=0&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">pd.read_excel(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">nrows=</span><span class="s2">&quot;5&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_read_excel_squeeze(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># GH 12157</span>
        <span class="s1">f = </span><span class="s2">&quot;test_squeeze&quot; </span><span class="s1">+ read_ext</span>

        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s2">&quot;The squeeze argument has been deprecated &quot;</span>
            <span class="s2">&quot;and will be removed in a future version. &quot;</span>
            <span class="s2">'Append .squeeze</span><span class="s0">\\</span><span class="s2">(&quot;columns&quot;</span><span class="s0">\\</span><span class="s2">) to the call to squeeze.</span><span class="s0">\n\n</span><span class="s2">'</span><span class="s0">,</span>
        <span class="s1">):</span>
            <span class="s1">actual = pd.read_excel(</span>
                <span class="s1">f</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;two_columns&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">squeeze=</span><span class="s0">True</span>
            <span class="s1">)</span>
            <span class="s1">expected = Series([</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;b&quot;</span><span class="s1">)</span>
            <span class="s1">expected.index.name = </span><span class="s2">&quot;a&quot;</span>
            <span class="s1">tm.assert_series_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

            <span class="s1">actual = pd.read_excel(f</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;two_columns&quot;</span><span class="s0">, </span><span class="s1">squeeze=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">expected = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">6</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]})</span>
            <span class="s1">tm.assert_frame_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

            <span class="s1">actual = pd.read_excel(f</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;one_column&quot;</span><span class="s0">, </span><span class="s1">squeeze=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">expected = Series([</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>
            <span class="s1">tm.assert_series_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_deprecated_kwargs(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">raise_on_extra_warnings=</span><span class="s0">False</span><span class="s1">):</span>
            <span class="s1">pd.read_excel(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">pd.read_excel(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext)</span>

    <span class="s0">def </span><span class="s1">test_no_header_with_list_index_col(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># GH 31783</span>
        <span class="s1">file_name = </span><span class="s2">&quot;testmultiindex&quot; </span><span class="s1">+ read_ext</span>
        <span class="s1">data = [(</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;key&quot;</span><span class="s0">, </span><span class="s2">&quot;val&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)]</span>
        <span class="s1">idx = MultiIndex.from_tuples(</span>
            <span class="s1">[(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;key&quot;</span><span class="s0">, </span><span class="s2">&quot;val&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">names=(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">expected = DataFrame(data</span><span class="s0">, </span><span class="s1">index=idx</span><span class="s0">, </span><span class="s1">columns=(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">result = pd.read_excel(</span>
            <span class="s1">file_name</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;index_col_none&quot;</span><span class="s0">, </span><span class="s1">index_col=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">header=</span><span class="s0">None</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">result)</span>

    <span class="s0">def </span><span class="s1">test_one_col_noskip_blank_line(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># GH 39808</span>
        <span class="s1">file_name = </span><span class="s2">&quot;one_col_blank_line&quot; </span><span class="s1">+ read_ext</span>
        <span class="s1">data = [</span><span class="s5">0.5</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">expected = DataFrame(data</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;numbers&quot;</span><span class="s1">])</span>
        <span class="s1">result = pd.read_excel(file_name)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_multiheader_two_blank_lines(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># GH 40442</span>
        <span class="s1">file_name = </span><span class="s2">&quot;testmultiindex&quot; </span><span class="s1">+ read_ext</span>
        <span class="s1">columns = MultiIndex.from_tuples([(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">)])</span>
        <span class="s1">data = [[np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]]</span>
        <span class="s1">expected = DataFrame(data</span><span class="s0">, </span><span class="s1">columns=columns)</span>
        <span class="s1">result = pd.read_excel(</span>
            <span class="s1">file_name</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;mi_column_empty_rows&quot;</span><span class="s0">, </span><span class="s1">header=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_trailing_blanks(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s4">&quot;&quot;&quot; 
        Sheets can contain blank cells with no data. Some of our readers 
        were including those cells, creating many empty rows and columns 
        &quot;&quot;&quot;</span>
        <span class="s1">file_name = </span><span class="s2">&quot;trailing_blanks&quot; </span><span class="s1">+ read_ext</span>
        <span class="s1">result = pd.read_excel(file_name)</span>
        <span class="s0">assert </span><span class="s1">result.shape == (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_ignore_chartsheets_by_str(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># GH 41448</span>
        <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;odf&quot;</span><span class="s1">:</span>
            <span class="s1">pytest.skip(</span><span class="s2">&quot;chartsheets do not exist in the ODF format&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;pyxlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;pyxlsb can't distinguish chartsheets from worksheets&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Worksheet named 'Chart1' not found&quot;</span><span class="s1">):</span>
            <span class="s1">pd.read_excel(</span><span class="s2">&quot;chartsheet&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Chart1&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_ignore_chartsheets_by_int(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># GH 41448</span>
        <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;odf&quot;</span><span class="s1">:</span>
            <span class="s1">pytest.skip(</span><span class="s2">&quot;chartsheets do not exist in the ODF format&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;pyxlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;pyxlsb can't distinguish chartsheets from worksheets&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Worksheet index 1 is invalid, 1 worksheets found&quot;</span>
        <span class="s1">):</span>
            <span class="s1">pd.read_excel(</span><span class="s2">&quot;chartsheet&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_euro_decimal_format(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># copied from read_csv</span>
        <span class="s1">result = pd.read_excel(</span><span class="s2">&quot;test_decimal&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">&quot;,&quot;</span><span class="s0">, </span><span class="s1">skiprows=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1521.1541</span><span class="s0">, </span><span class="s5">187101.9543</span><span class="s0">, </span><span class="s2">&quot;ABC&quot;</span><span class="s0">, </span><span class="s2">&quot;poi&quot;</span><span class="s0">, </span><span class="s5">4.738797819</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s5">121.12</span><span class="s0">, </span><span class="s5">14897.76</span><span class="s0">, </span><span class="s2">&quot;DEF&quot;</span><span class="s0">, </span><span class="s2">&quot;uyt&quot;</span><span class="s0">, </span><span class="s5">0.377320872</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s5">878.158</span><span class="s0">, </span><span class="s5">108013.434</span><span class="s0">, </span><span class="s2">&quot;GHI&quot;</span><span class="s0">, </span><span class="s2">&quot;rez&quot;</span><span class="s0">, </span><span class="s5">2.735694704</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">columns=[</span><span class="s2">&quot;Id&quot;</span><span class="s0">, </span><span class="s2">&quot;Number1&quot;</span><span class="s0">, </span><span class="s2">&quot;Number2&quot;</span><span class="s0">, </span><span class="s2">&quot;Text1&quot;</span><span class="s0">, </span><span class="s2">&quot;Text2&quot;</span><span class="s0">, </span><span class="s2">&quot;Number3&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">class </span><span class="s1">TestExcelFileRead:</span>
    <span class="s1">@pytest.fixture(autouse=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">cd_and_set_engine(self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">datapath</span><span class="s0">, </span><span class="s1">monkeypatch):</span>
        <span class="s4">&quot;&quot;&quot; 
        Change directory and set engine for ExcelFile objects. 
        &quot;&quot;&quot;</span>
        <span class="s1">func = partial(pd.ExcelFile</span><span class="s0">, </span><span class="s1">engine=engine)</span>
        <span class="s1">monkeypatch.chdir(datapath(</span><span class="s2">&quot;io&quot;</span><span class="s0">, </span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;excel&quot;</span><span class="s1">))</span>
        <span class="s1">monkeypatch.setattr(pd</span><span class="s0">, </span><span class="s2">&quot;ExcelFile&quot;</span><span class="s0">, </span><span class="s1">func)</span>

    <span class="s0">def </span><span class="s1">test_engine_used(self</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">monkeypatch):</span>
        <span class="s1">expected_defaults = {</span>
            <span class="s2">&quot;xlsx&quot;</span><span class="s1">: </span><span class="s2">&quot;openpyxl&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;xlsm&quot;</span><span class="s1">: </span><span class="s2">&quot;openpyxl&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;xlsb&quot;</span><span class="s1">: </span><span class="s2">&quot;pyxlsb&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;xls&quot;</span><span class="s1">: </span><span class="s2">&quot;xlrd&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;ods&quot;</span><span class="s1">: </span><span class="s2">&quot;odf&quot;</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">with </span><span class="s1">pd.ExcelFile(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext) </span><span class="s0">as </span><span class="s1">excel:</span>
            <span class="s1">result = excel.engine</span>

        <span class="s0">if </span><span class="s1">engine </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">expected = engine</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expected = expected_defaults[read_ext[</span><span class="s5">1</span><span class="s1">:]]</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s0">def </span><span class="s1">test_excel_passes_na(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s0">with </span><span class="s1">pd.ExcelFile(</span><span class="s2">&quot;test4&quot; </span><span class="s1">+ read_ext) </span><span class="s0">as </span><span class="s1">excel:</span>
            <span class="s1">parsed = pd.read_excel(</span>
                <span class="s1">excel</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">keep_default_na=</span><span class="s0">False, </span><span class="s1">na_values=[</span><span class="s2">&quot;apple&quot;</span><span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">[[</span><span class="s2">&quot;NA&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;NA&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;rabbit&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;Test&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(parsed</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s0">with </span><span class="s1">pd.ExcelFile(</span><span class="s2">&quot;test4&quot; </span><span class="s1">+ read_ext) </span><span class="s0">as </span><span class="s1">excel:</span>
            <span class="s1">parsed = pd.read_excel(</span>
                <span class="s1">excel</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">keep_default_na=</span><span class="s0">True, </span><span class="s1">na_values=[</span><span class="s2">&quot;apple&quot;</span><span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">[[np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan]</span><span class="s0">, </span><span class="s1">[np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;rabbit&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;Test&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(parsed</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s3"># 13967</span>
        <span class="s0">with </span><span class="s1">pd.ExcelFile(</span><span class="s2">&quot;test5&quot; </span><span class="s1">+ read_ext) </span><span class="s0">as </span><span class="s1">excel:</span>
            <span class="s1">parsed = pd.read_excel(</span>
                <span class="s1">excel</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">keep_default_na=</span><span class="s0">False, </span><span class="s1">na_values=[</span><span class="s2">&quot;apple&quot;</span><span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">[[</span><span class="s2">&quot;1.#QNAN&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;nan&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;rabbit&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;Test&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(parsed</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s0">with </span><span class="s1">pd.ExcelFile(</span><span class="s2">&quot;test5&quot; </span><span class="s1">+ read_ext) </span><span class="s0">as </span><span class="s1">excel:</span>
            <span class="s1">parsed = pd.read_excel(</span>
                <span class="s1">excel</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">keep_default_na=</span><span class="s0">True, </span><span class="s1">na_values=[</span><span class="s2">&quot;apple&quot;</span><span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">[[np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan]</span><span class="s0">, </span><span class="s1">[np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;rabbit&quot;</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;Test&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(parsed</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;na_filter&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_excel_passes_na_filter(self</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">na_filter):</span>
        <span class="s3"># gh-25453</span>
        <span class="s1">kwargs = {}</span>

        <span class="s0">if </span><span class="s1">na_filter </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;na_filter&quot;</span><span class="s1">] = na_filter</span>

        <span class="s0">with </span><span class="s1">pd.ExcelFile(</span><span class="s2">&quot;test5&quot; </span><span class="s1">+ read_ext) </span><span class="s0">as </span><span class="s1">excel:</span>
            <span class="s1">parsed = pd.read_excel(</span>
                <span class="s1">excel</span><span class="s0">,</span>
                <span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">,</span>
                <span class="s1">keep_default_na=</span><span class="s0">True,</span>
                <span class="s1">na_values=[</span><span class="s2">&quot;apple&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">**kwargs</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">na_filter </span><span class="s0">is False</span><span class="s1">:</span>
            <span class="s1">expected = [[</span><span class="s2">&quot;1.#QNAN&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;nan&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;apple&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;rabbit&quot;</span><span class="s1">]]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expected = [[np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan]</span><span class="s0">, </span><span class="s1">[np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;rabbit&quot;</span><span class="s1">]]</span>

        <span class="s1">expected = DataFrame(expected</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;Test&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_frame_equal(parsed</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_excel_table_sheet_by_index(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">df_ref):</span>
        <span class="s0">if </span><span class="s1">read_ext == </span><span class="s2">&quot;.xlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;Sheets containing datetimes not supported by pyxlsb&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pd.ExcelFile(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext) </span><span class="s0">as </span><span class="s1">excel:</span>
            <span class="s1">df1 = pd.read_excel(excel</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">df2 = pd.read_excel(excel</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">skiprows=[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df1</span><span class="s0">, </span><span class="s1">df_ref</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df2</span><span class="s0">, </span><span class="s1">df_ref</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pd.ExcelFile(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext) </span><span class="s0">as </span><span class="s1">excel:</span>
            <span class="s1">df1 = excel.parse(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">df2 = excel.parse(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">skiprows=[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df1</span><span class="s0">, </span><span class="s1">df_ref</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df2</span><span class="s0">, </span><span class="s1">df_ref</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pd.ExcelFile(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext) </span><span class="s0">as </span><span class="s1">excel:</span>
            <span class="s1">df3 = pd.read_excel(excel</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">skipfooter=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df3</span><span class="s0">, </span><span class="s1">df1.iloc[:-</span><span class="s5">1</span><span class="s1">])</span>

        <span class="s0">with </span><span class="s1">pd.ExcelFile(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext) </span><span class="s0">as </span><span class="s1">excel:</span>
            <span class="s1">df3 = excel.parse(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">skipfooter=</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s1">tm.assert_frame_equal(df3</span><span class="s0">, </span><span class="s1">df1.iloc[:-</span><span class="s5">1</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_sheet_name(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">df_ref):</span>
        <span class="s0">if </span><span class="s1">read_ext == </span><span class="s2">&quot;.xlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;Sheets containing datetimes not supported by pyxlsb&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">filename = </span><span class="s2">&quot;test1&quot;</span>
        <span class="s1">sheet_name = </span><span class="s2">&quot;Sheet1&quot;</span>

        <span class="s0">with </span><span class="s1">pd.ExcelFile(filename + read_ext) </span><span class="s0">as </span><span class="s1">excel:</span>
            <span class="s1">df1_parse = excel.parse(sheet_name=sheet_name</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s1">)  </span><span class="s3"># doc</span>

        <span class="s0">with </span><span class="s1">pd.ExcelFile(filename + read_ext) </span><span class="s0">as </span><span class="s1">excel:</span>
            <span class="s1">df2_parse = excel.parse(index_col=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">sheet_name=sheet_name)</span>

        <span class="s1">tm.assert_frame_equal(df1_parse</span><span class="s0">, </span><span class="s1">df_ref</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df2_parse</span><span class="s0">, </span><span class="s1">df_ref</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;sheet_name&quot;</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;Sheet4&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s2">&quot;Sheet4&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;Sheet4&quot;</span><span class="s0">, </span><span class="s2">&quot;Sheet1&quot;</span><span class="s1">]]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_bad_sheetname_raises(self</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">sheet_name):</span>
        <span class="s3"># GH 39250</span>
        <span class="s1">msg = </span><span class="s2">&quot;Worksheet index 3 is invalid|Worksheet named 'Sheet4' not found&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s0">with </span><span class="s1">pd.ExcelFile(</span><span class="s2">&quot;blank&quot; </span><span class="s1">+ read_ext) </span><span class="s0">as </span><span class="s1">excel:</span>
                <span class="s1">excel.parse(sheet_name=sheet_name)</span>

    <span class="s0">def </span><span class="s1">test_excel_read_buffer(self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s1">pth = </span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span>
        <span class="s1">expected = pd.read_excel(pth</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">engine=engine)</span>

        <span class="s0">with </span><span class="s1">open(pth</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
            <span class="s0">with </span><span class="s1">pd.ExcelFile(f) </span><span class="s0">as </span><span class="s1">xls:</span>
                <span class="s1">actual = pd.read_excel(xls</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">actual)</span>

    <span class="s0">def </span><span class="s1">test_reader_closes_file(self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s0">with </span><span class="s1">open(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
            <span class="s0">with </span><span class="s1">pd.ExcelFile(f) </span><span class="s0">as </span><span class="s1">xlsx:</span>
                <span class="s3"># parses okay</span>
                <span class="s1">pd.read_excel(xlsx</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">engine=engine)</span>

        <span class="s0">assert </span><span class="s1">f.closed</span>

    <span class="s0">def </span><span class="s1">test_conflicting_excel_engines(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># GH 26566</span>
        <span class="s1">msg = </span><span class="s2">&quot;Engine should not be specified when passing an ExcelFile&quot;</span>

        <span class="s0">with </span><span class="s1">pd.ExcelFile(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext) </span><span class="s0">as </span><span class="s1">xl:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">pd.read_excel(xl</span><span class="s0">, </span><span class="s1">engine=</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_excel_read_binary(self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># GH 15914</span>
        <span class="s1">expected = pd.read_excel(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">engine=engine)</span>

        <span class="s0">with </span><span class="s1">open(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
            <span class="s1">data = f.read()</span>

        <span class="s1">actual = pd.read_excel(data</span><span class="s0">, </span><span class="s1">engine=engine)</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">actual)</span>

    <span class="s0">def </span><span class="s1">test_excel_read_binary_via_read_excel(self</span><span class="s0">, </span><span class="s1">read_ext</span><span class="s0">, </span><span class="s1">engine):</span>
        <span class="s3"># GH 38424</span>
        <span class="s0">with </span><span class="s1">open(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
            <span class="s1">result = pd.read_excel(f)</span>
        <span class="s1">expected = pd.read_excel(</span><span class="s2">&quot;test1&quot; </span><span class="s1">+ read_ext</span><span class="s0">, </span><span class="s1">engine=engine)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.skipif(</span>
        <span class="s1">xlrd_version </span><span class="s0">is not None and </span><span class="s1">xlrd_version &gt;= Version(</span><span class="s2">&quot;2&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">reason=</span><span class="s2">&quot;xlrd no longer supports xlsx&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_excel_high_surrogate(self):</span>
        <span class="s3"># GH 23809</span>
        <span class="s1">expected = DataFrame([</span><span class="s2">&quot;</span><span class="s0">\udc88</span><span class="s2">&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;Column1&quot;</span><span class="s1">])</span>

        <span class="s3"># should not produce a segmentation violation</span>
        <span class="s1">actual = pd.read_excel(</span><span class="s2">&quot;high_surrogate.xlsx&quot;</span><span class="s0">, </span><span class="s1">engine=</span><span class="s2">&quot;xlrd&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">actual)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;filename&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;df_empty.xlsx&quot;</span><span class="s0">, </span><span class="s2">&quot;df_equals.xlsx&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_header_with_index_col(self</span><span class="s0">, </span><span class="s1">filename):</span>
        <span class="s3"># GH 33476</span>
        <span class="s1">idx = Index([</span><span class="s2">&quot;Z&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;I2&quot;</span><span class="s1">)</span>
        <span class="s1">cols = MultiIndex.from_tuples([(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B.1&quot;</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">names=[</span><span class="s2">&quot;I11&quot;</span><span class="s0">, </span><span class="s2">&quot;I12&quot;</span><span class="s1">])</span>
        <span class="s1">expected = DataFrame([[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">index=idx</span><span class="s0">, </span><span class="s1">columns=cols</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span>
        <span class="s1">result = pd.read_excel(</span>
            <span class="s1">filename</span><span class="s0">, </span><span class="s1">sheet_name=</span><span class="s2">&quot;Sheet1&quot;</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">header=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">result)</span>

    <span class="s0">def </span><span class="s1">test_read_datetime_multiindex(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># GH 34748</span>
        <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;pyxlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;Sheets containing datetimes not supported by pyxlsb&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">f = </span><span class="s2">&quot;test_datetime_mi&quot; </span><span class="s1">+ read_ext</span>
        <span class="s0">with </span><span class="s1">pd.ExcelFile(f) </span><span class="s0">as </span><span class="s1">excel:</span>
            <span class="s1">actual = pd.read_excel(excel</span><span class="s0">, </span><span class="s1">header=[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index_col=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">engine=engine)</span>
        <span class="s1">expected_column_index = MultiIndex.from_tuples(</span>
            <span class="s1">[(pd.to_datetime(</span><span class="s2">&quot;02/29/2020&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.to_datetime(</span><span class="s2">&quot;03/01/2020&quot;</span><span class="s1">))]</span><span class="s0">,</span>
            <span class="s1">names=[</span>
                <span class="s1">pd.to_datetime(</span><span class="s2">&quot;02/29/2020&quot;</span><span class="s1">).to_pydatetime()</span><span class="s0">,</span>
                <span class="s1">pd.to_datetime(</span><span class="s2">&quot;03/01/2020&quot;</span><span class="s1">).to_pydatetime()</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">expected = DataFrame([]</span><span class="s0">, </span><span class="s1">columns=expected_column_index)</span>

        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">actual)</span>

    <span class="s0">def </span><span class="s1">test_engine_invalid_option(self</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># read_ext includes the '.' hence the weird formatting</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Value must be one of *&quot;</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">pd.option_context(</span><span class="s2">f&quot;io.excel</span><span class="s0">{</span><span class="s1">read_ext</span><span class="s0">}</span><span class="s2">.reader&quot;</span><span class="s0">, </span><span class="s2">&quot;abc&quot;</span><span class="s1">):</span>
                <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">test_ignore_chartsheets(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># GH 41448</span>
        <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;odf&quot;</span><span class="s1">:</span>
            <span class="s1">pytest.skip(</span><span class="s2">&quot;chartsheets do not exist in the ODF format&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;pyxlsb&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s2">&quot;pyxlsb can't distinguish chartsheets from worksheets&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pd.ExcelFile(</span><span class="s2">&quot;chartsheet&quot; </span><span class="s1">+ read_ext) </span><span class="s0">as </span><span class="s1">excel:</span>
            <span class="s0">assert </span><span class="s1">excel.sheet_names == [</span><span class="s2">&quot;Sheet1&quot;</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_corrupt_files_closed(self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">read_ext):</span>
        <span class="s3"># GH41778</span>
        <span class="s1">errors = (BadZipFile</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">engine </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">pytest.skip()</span>
        <span class="s0">elif </span><span class="s1">engine == </span><span class="s2">&quot;xlrd&quot;</span><span class="s1">:</span>
            <span class="s0">import </span><span class="s1">xlrd</span>

            <span class="s1">errors = (BadZipFile</span><span class="s0">, </span><span class="s1">xlrd.biffh.XLRDError)</span>

        <span class="s0">with </span><span class="s1">tm.ensure_clean(</span><span class="s2">f&quot;corrupt</span><span class="s0">{</span><span class="s1">read_ext</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">file:</span>
            <span class="s1">Path(file).write_text(</span><span class="s2">&quot;corrupt&quot;</span><span class="s1">)</span>
            <span class="s0">with </span><span class="s1">tm.assert_produces_warning(</span><span class="s0">False</span><span class="s1">):</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">pd.ExcelFile(file</span><span class="s0">, </span><span class="s1">engine=engine)</span>
                <span class="s0">except </span><span class="s1">errors:</span>
                    <span class="s0">pass</span>
</pre>
</body>
</html>