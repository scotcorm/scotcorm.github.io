<html>
<head>
<title>filters.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
filters.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Built-in template filters used with the ``|`` operator.&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">random</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">typing</span>
<span class="s2">import </span><span class="s1">typing </span><span class="s2">as </span><span class="s1">t</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">abc</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">chain</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">groupby</span>

<span class="s2">from </span><span class="s1">markupsafe </span><span class="s2">import </span><span class="s1">escape</span>
<span class="s2">from </span><span class="s1">markupsafe </span><span class="s2">import </span><span class="s1">Markup</span>
<span class="s2">from </span><span class="s1">markupsafe </span><span class="s2">import </span><span class="s1">soft_str</span>

<span class="s2">from </span><span class="s1">.async_utils </span><span class="s2">import </span><span class="s1">async_variant</span>
<span class="s2">from </span><span class="s1">.async_utils </span><span class="s2">import </span><span class="s1">auto_aiter</span>
<span class="s2">from </span><span class="s1">.async_utils </span><span class="s2">import </span><span class="s1">auto_await</span>
<span class="s2">from </span><span class="s1">.async_utils </span><span class="s2">import </span><span class="s1">auto_to_list</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">FilterArgumentError</span>
<span class="s2">from </span><span class="s1">.runtime </span><span class="s2">import </span><span class="s1">Undefined</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">htmlsafe_json_dumps</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">pass_context</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">pass_environment</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">pass_eval_context</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">pformat</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">url_quote</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">urlize</span>

<span class="s2">if </span><span class="s1">t.TYPE_CHECKING:</span>
    <span class="s2">import </span><span class="s1">typing_extensions </span><span class="s2">as </span><span class="s1">te</span>
    <span class="s2">from </span><span class="s1">.environment </span><span class="s2">import </span><span class="s1">Environment</span>
    <span class="s2">from </span><span class="s1">.nodes </span><span class="s2">import </span><span class="s1">EvalContext</span>
    <span class="s2">from </span><span class="s1">.runtime </span><span class="s2">import </span><span class="s1">Context</span>
    <span class="s2">from </span><span class="s1">.sandbox </span><span class="s2">import </span><span class="s1">SandboxedEnvironment  </span><span class="s3"># noqa: F401</span>

    <span class="s2">class </span><span class="s1">HasHTML(te.Protocol):</span>
        <span class="s2">def </span><span class="s1">__html__(self) -&gt; str:</span>
            <span class="s2">pass</span>


<span class="s1">F = t.TypeVar(</span><span class="s4">&quot;F&quot;</span><span class="s2">, </span><span class="s1">bound=t.Callable[...</span><span class="s2">, </span><span class="s1">t.Any])</span>
<span class="s1">K = t.TypeVar(</span><span class="s4">&quot;K&quot;</span><span class="s1">)</span>
<span class="s1">V = t.TypeVar(</span><span class="s4">&quot;V&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">contextfilter(f: F) -&gt; F:</span>
    <span class="s0">&quot;&quot;&quot;Pass the context as the first argument to the decorated function. 
 
    .. deprecated:: 3.0 
        Will be removed in Jinja 3.1. Use :func:`~jinja2.pass_context` 
        instead. 
    &quot;&quot;&quot;</span>
    <span class="s1">warnings.warn(</span>
        <span class="s4">&quot;'contextfilter' is renamed to 'pass_context', the old name&quot;</span>
        <span class="s4">&quot; will be removed in Jinja 3.1.&quot;</span><span class="s2">,</span>
        <span class="s1">DeprecationWarning</span><span class="s2">,</span>
        <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">pass_context(f)</span>


<span class="s2">def </span><span class="s1">evalcontextfilter(f: F) -&gt; F:</span>
    <span class="s0">&quot;&quot;&quot;Pass the eval context as the first argument to the decorated 
    function. 
 
    .. deprecated:: 3.0 
        Will be removed in Jinja 3.1. Use 
        :func:`~jinja2.pass_eval_context` instead. 
 
    .. versionadded:: 2.4 
    &quot;&quot;&quot;</span>
    <span class="s1">warnings.warn(</span>
        <span class="s4">&quot;'evalcontextfilter' is renamed to 'pass_eval_context', the old&quot;</span>
        <span class="s4">&quot; name will be removed in Jinja 3.1.&quot;</span><span class="s2">,</span>
        <span class="s1">DeprecationWarning</span><span class="s2">,</span>
        <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">pass_eval_context(f)</span>


<span class="s2">def </span><span class="s1">environmentfilter(f: F) -&gt; F:</span>
    <span class="s0">&quot;&quot;&quot;Pass the environment as the first argument to the decorated 
    function. 
 
    .. deprecated:: 3.0 
        Will be removed in Jinja 3.1. Use 
        :func:`~jinja2.pass_environment` instead. 
    &quot;&quot;&quot;</span>
    <span class="s1">warnings.warn(</span>
        <span class="s4">&quot;'environmentfilter' is renamed to 'pass_environment', the old&quot;</span>
        <span class="s4">&quot; name will be removed in Jinja 3.1.&quot;</span><span class="s2">,</span>
        <span class="s1">DeprecationWarning</span><span class="s2">,</span>
        <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">pass_environment(f)</span>


<span class="s2">def </span><span class="s1">ignore_case(value: V) -&gt; V:</span>
    <span class="s0">&quot;&quot;&quot;For use as a postprocessor for :func:`make_attrgetter`. Converts strings 
    to lowercase and returns other types as-is.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">return </span><span class="s1">t.cast(V</span><span class="s2">, </span><span class="s1">value.lower())</span>

    <span class="s2">return </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">make_attrgetter(</span>
    <span class="s1">environment: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">,</span>
    <span class="s1">attribute: t.Optional[t.Union[str</span><span class="s2">, </span><span class="s1">int]]</span><span class="s2">,</span>
    <span class="s1">postprocess: t.Optional[t.Callable[[t.Any]</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
    <span class="s1">default: t.Optional[t.Any] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; t.Callable[[t.Any]</span><span class="s2">, </span><span class="s1">t.Any]:</span>
    <span class="s0">&quot;&quot;&quot;Returns a callable that looks up the given attribute from a 
    passed object with the rules of the environment.  Dots are allowed 
    to access attributes of attributes.  Integer parts in paths are 
    looked up as integers. 
    &quot;&quot;&quot;</span>
    <span class="s1">parts = _prepare_attribute_parts(attribute)</span>

    <span class="s2">def </span><span class="s1">attrgetter(item: t.Any) -&gt; t.Any:</span>
        <span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">parts:</span>
            <span class="s1">item = environment.getitem(item</span><span class="s2">, </span><span class="s1">part)</span>

            <span class="s2">if </span><span class="s1">default </span><span class="s2">is not None and </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">Undefined):</span>
                <span class="s1">item = default</span>

        <span class="s2">if </span><span class="s1">postprocess </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">item = postprocess(item)</span>

        <span class="s2">return </span><span class="s1">item</span>

    <span class="s2">return </span><span class="s1">attrgetter</span>


<span class="s2">def </span><span class="s1">make_multi_attrgetter(</span>
    <span class="s1">environment: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">,</span>
    <span class="s1">attribute: t.Optional[t.Union[str</span><span class="s2">, </span><span class="s1">int]]</span><span class="s2">,</span>
    <span class="s1">postprocess: t.Optional[t.Callable[[t.Any]</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; t.Callable[[t.Any]</span><span class="s2">, </span><span class="s1">t.List[t.Any]]:</span>
    <span class="s0">&quot;&quot;&quot;Returns a callable that looks up the given comma separated 
    attributes from a passed object with the rules of the environment. 
    Dots are allowed to access attributes of each attribute.  Integer 
    parts in paths are looked up as integers. 
 
    The value returned by the returned callable is a list of extracted 
    attribute values. 
 
    Examples of attribute: &quot;attr1,attr2&quot;, &quot;attr1.inner1.0,attr2.inner2.0&quot;, etc. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(attribute</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">split: t.Sequence[t.Union[str</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, None</span><span class="s1">]] = attribute.split(</span><span class="s4">&quot;,&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">split = [attribute]</span>

    <span class="s1">parts = [_prepare_attribute_parts(item) </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">split]</span>

    <span class="s2">def </span><span class="s1">attrgetter(item: t.Any) -&gt; t.List[t.Any]:</span>
        <span class="s1">items = [</span><span class="s2">None</span><span class="s1">] * len(parts)</span>

        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">attribute_part </span><span class="s2">in </span><span class="s1">enumerate(parts):</span>
            <span class="s1">item_i = item</span>

            <span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">attribute_part:</span>
                <span class="s1">item_i = environment.getitem(item_i</span><span class="s2">, </span><span class="s1">part)</span>

            <span class="s2">if </span><span class="s1">postprocess </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">item_i = postprocess(item_i)</span>

            <span class="s1">items[i] = item_i</span>

        <span class="s2">return </span><span class="s1">items</span>

    <span class="s2">return </span><span class="s1">attrgetter</span>


<span class="s2">def </span><span class="s1">_prepare_attribute_parts(</span>
    <span class="s1">attr: t.Optional[t.Union[str</span><span class="s2">, </span><span class="s1">int]]</span>
<span class="s1">) -&gt; t.List[t.Union[str</span><span class="s2">, </span><span class="s1">int]]:</span>
    <span class="s2">if </span><span class="s1">attr </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">if </span><span class="s1">isinstance(attr</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">return </span><span class="s1">[int(x) </span><span class="s2">if </span><span class="s1">x.isdigit() </span><span class="s2">else </span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">attr.split(</span><span class="s4">&quot;.&quot;</span><span class="s1">)]</span>

    <span class="s2">return </span><span class="s1">[attr]</span>


<span class="s2">def </span><span class="s1">do_forceescape(value: </span><span class="s4">&quot;t.Union[str, HasHTML]&quot;</span><span class="s1">) -&gt; Markup:</span>
    <span class="s0">&quot;&quot;&quot;Enforce HTML escaping.  This will probably double escape variables.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">hasattr(value</span><span class="s2">, </span><span class="s4">&quot;__html__&quot;</span><span class="s1">):</span>
        <span class="s1">value = t.cast(</span><span class="s4">&quot;HasHTML&quot;</span><span class="s2">, </span><span class="s1">value).__html__()</span>

    <span class="s2">return </span><span class="s1">escape(str(value))</span>


<span class="s2">def </span><span class="s1">do_urlencode(</span>
    <span class="s1">value: t.Union[str</span><span class="s2">, </span><span class="s1">t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">, </span><span class="s1">t.Iterable[t.Tuple[str</span><span class="s2">, </span><span class="s1">t.Any]]]</span>
<span class="s1">) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Quote data for use in a URL path or query using UTF-8. 
 
    Basic wrapper around :func:`urllib.parse.quote` when given a 
    string, or :func:`urllib.parse.urlencode` for a dict or iterable. 
 
    :param value: Data to quote. A string will be quoted directly. A 
        dict or iterable of ``(key, value)`` pairs will be joined as a 
        query string. 
 
    When given a string, &quot;/&quot; is not quoted. HTTP servers treat &quot;/&quot; and 
    &quot;%2F&quot; equivalently in paths. If you need quoted slashes, use the 
    ``|replace(&quot;/&quot;, &quot;%2F&quot;)`` filter. 
 
    .. versionadded:: 2.7 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">or not </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">abc.Iterable):</span>
        <span class="s2">return </span><span class="s1">url_quote(value)</span>

    <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">dict):</span>
        <span class="s1">items: t.Iterable[t.Tuple[str</span><span class="s2">, </span><span class="s1">t.Any]] = value.items()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">items = value  </span><span class="s3"># type: ignore</span>

    <span class="s2">return </span><span class="s4">&quot;&amp;&quot;</span><span class="s1">.join(</span>
        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">url_quote(k</span><span class="s2">, </span><span class="s1">for_qs=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">}</span><span class="s4">=</span><span class="s2">{</span><span class="s1">url_quote(v</span><span class="s2">, </span><span class="s1">for_qs=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">}</span><span class="s4">&quot; </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">items</span>
    <span class="s1">)</span>


<span class="s1">@pass_eval_context</span>
<span class="s2">def </span><span class="s1">do_replace(</span>
    <span class="s1">eval_ctx: </span><span class="s4">&quot;EvalContext&quot;</span><span class="s2">, </span><span class="s1">s: str</span><span class="s2">, </span><span class="s1">old: str</span><span class="s2">, </span><span class="s1">new: str</span><span class="s2">, </span><span class="s1">count: t.Optional[int] = </span><span class="s2">None</span>
<span class="s1">) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Return a copy of the value with all occurrences of a substring 
    replaced with a new one. The first argument is the substring 
    that should be replaced, the second is the replacement string. 
    If the optional third argument ``count`` is given, only the first 
    ``count`` occurrences are replaced: 
 
    .. sourcecode:: jinja 
 
        {{ &quot;Hello World&quot;|replace(&quot;Hello&quot;, &quot;Goodbye&quot;) }} 
            -&gt; Goodbye World 
 
        {{ &quot;aaaaargh&quot;|replace(&quot;a&quot;, &quot;d'oh, &quot;, 2) }} 
            -&gt; d'oh, d'oh, aaargh 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">count </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">count = -</span><span class="s5">1</span>

    <span class="s2">if not </span><span class="s1">eval_ctx.autoescape:</span>
        <span class="s2">return </span><span class="s1">str(s).replace(str(old)</span><span class="s2">, </span><span class="s1">str(new)</span><span class="s2">, </span><span class="s1">count)</span>

    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">hasattr(old</span><span class="s2">, </span><span class="s4">&quot;__html__&quot;</span><span class="s1">)</span>
        <span class="s2">or </span><span class="s1">hasattr(new</span><span class="s2">, </span><span class="s4">&quot;__html__&quot;</span><span class="s1">)</span>
        <span class="s2">and not </span><span class="s1">hasattr(s</span><span class="s2">, </span><span class="s4">&quot;__html__&quot;</span><span class="s1">)</span>
    <span class="s1">):</span>
        <span class="s1">s = escape(s)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">s = soft_str(s)</span>

    <span class="s2">return </span><span class="s1">s.replace(soft_str(old)</span><span class="s2">, </span><span class="s1">soft_str(new)</span><span class="s2">, </span><span class="s1">count)</span>


<span class="s2">def </span><span class="s1">do_upper(s: str) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Convert a value to uppercase.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">soft_str(s).upper()</span>


<span class="s2">def </span><span class="s1">do_lower(s: str) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Convert a value to lowercase.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">soft_str(s).lower()</span>


<span class="s1">@pass_eval_context</span>
<span class="s2">def </span><span class="s1">do_xmlattr(</span>
    <span class="s1">eval_ctx: </span><span class="s4">&quot;EvalContext&quot;</span><span class="s2">, </span><span class="s1">d: t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">, </span><span class="s1">autospace: bool = </span><span class="s2">True</span>
<span class="s1">) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Create an SGML/XML attribute string based on the items in a dict. 
    All values that are neither `none` nor `undefined` are automatically 
    escaped: 
 
    .. sourcecode:: html+jinja 
 
        &lt;ul{{ {'class': 'my_list', 'missing': none, 
                'id': 'list-%d'|format(variable)}|xmlattr }}&gt; 
        ... 
        &lt;/ul&gt; 
 
    Results in something like this: 
 
    .. sourcecode:: html 
 
        &lt;ul class=&quot;my_list&quot; id=&quot;list-42&quot;&gt; 
        ... 
        &lt;/ul&gt; 
 
    As you can see it automatically prepends a space in front of the item 
    if the filter returned something unless the second parameter is false. 
    &quot;&quot;&quot;</span>
    <span class="s1">rv = </span><span class="s4">&quot; &quot;</span><span class="s1">.join(</span>
        <span class="s4">f'</span><span class="s2">{</span><span class="s1">escape(key)</span><span class="s2">}</span><span class="s4">=&quot;</span><span class="s2">{</span><span class="s1">escape(value)</span><span class="s2">}</span><span class="s4">&quot;'</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">d.items()</span>
        <span class="s2">if </span><span class="s1">value </span><span class="s2">is not None and not </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">Undefined)</span>
    <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">autospace </span><span class="s2">and </span><span class="s1">rv:</span>
        <span class="s1">rv = </span><span class="s4">&quot; &quot; </span><span class="s1">+ rv</span>

    <span class="s2">if </span><span class="s1">eval_ctx.autoescape:</span>
        <span class="s1">rv = Markup(rv)</span>

    <span class="s2">return </span><span class="s1">rv</span>


<span class="s2">def </span><span class="s1">do_capitalize(s: str) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Capitalize a value. The first character will be uppercase, all others 
    lowercase. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">soft_str(s).capitalize()</span>


<span class="s1">_word_beginning_split_re = re.compile(</span><span class="s4">r&quot;([-\s({\[&lt;]+)&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">do_title(s: str) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Return a titlecased version of the value. I.e. words will start with 
    uppercase letters, all remaining characters are lowercase. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s4">&quot;&quot;</span><span class="s1">.join(</span>
        <span class="s1">[</span>
            <span class="s1">item[</span><span class="s5">0</span><span class="s1">].upper() + item[</span><span class="s5">1</span><span class="s1">:].lower()</span>
            <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">_word_beginning_split_re.split(soft_str(s))</span>
            <span class="s2">if </span><span class="s1">item</span>
        <span class="s1">]</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">do_dictsort(</span>
    <span class="s1">value: t.Mapping[K</span><span class="s2">, </span><span class="s1">V]</span><span class="s2">,</span>
    <span class="s1">case_sensitive: bool = </span><span class="s2">False,</span>
    <span class="s1">by: </span><span class="s4">'te.Literal[&quot;key&quot;, &quot;value&quot;]' </span><span class="s1">= </span><span class="s4">&quot;key&quot;</span><span class="s2">,</span>
    <span class="s1">reverse: bool = </span><span class="s2">False,</span>
<span class="s1">) -&gt; t.List[t.Tuple[K</span><span class="s2">, </span><span class="s1">V]]:</span>
    <span class="s0">&quot;&quot;&quot;Sort a dict and yield (key, value) pairs. Python dicts may not 
    be in the order you want to display them in, so sort them first. 
 
    .. sourcecode:: jinja 
 
        {% for key, value in mydict|dictsort %} 
            sort the dict by key, case insensitive 
 
        {% for key, value in mydict|dictsort(reverse=true) %} 
            sort the dict by key, case insensitive, reverse order 
 
        {% for key, value in mydict|dictsort(true) %} 
            sort the dict by key, case sensitive 
 
        {% for key, value in mydict|dictsort(false, 'value') %} 
            sort the dict by value, case insensitive 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">by == </span><span class="s4">&quot;key&quot;</span><span class="s1">:</span>
        <span class="s1">pos = </span><span class="s5">0</span>
    <span class="s2">elif </span><span class="s1">by == </span><span class="s4">&quot;value&quot;</span><span class="s1">:</span>
        <span class="s1">pos = </span><span class="s5">1</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">FilterArgumentError(</span><span class="s4">'You can only sort by either &quot;key&quot; or &quot;value&quot;'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">sort_func(item: t.Tuple[t.Any</span><span class="s2">, </span><span class="s1">t.Any]) -&gt; t.Any:</span>
        <span class="s1">value = item[pos]</span>

        <span class="s2">if not </span><span class="s1">case_sensitive:</span>
            <span class="s1">value = ignore_case(value)</span>

        <span class="s2">return </span><span class="s1">value</span>

    <span class="s2">return </span><span class="s1">sorted(value.items()</span><span class="s2">, </span><span class="s1">key=sort_func</span><span class="s2">, </span><span class="s1">reverse=reverse)</span>


<span class="s1">@pass_environment</span>
<span class="s2">def </span><span class="s1">do_sort(</span>
    <span class="s1">environment: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s4">&quot;t.Iterable[V]&quot;</span><span class="s2">,</span>
    <span class="s1">reverse: bool = </span><span class="s2">False,</span>
    <span class="s1">case_sensitive: bool = </span><span class="s2">False,</span>
    <span class="s1">attribute: t.Optional[t.Union[str</span><span class="s2">, </span><span class="s1">int]] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.List[V]&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Sort an iterable using Python's :func:`sorted`. 
 
    .. sourcecode:: jinja 
 
        {% for city in cities|sort %} 
            ... 
        {% endfor %} 
 
    :param reverse: Sort descending instead of ascending. 
    :param case_sensitive: When sorting strings, sort upper and lower 
        case separately. 
    :param attribute: When sorting objects or dicts, an attribute or 
        key to sort by. Can use dot notation like ``&quot;address.city&quot;``. 
        Can be a list of attributes like ``&quot;age,name&quot;``. 
 
    The sort is stable, it does not change the relative order of 
    elements that compare equal. This makes it is possible to chain 
    sorts on different attributes and ordering. 
 
    .. sourcecode:: jinja 
 
        {% for user in users|sort(attribute=&quot;name&quot;) 
            |sort(reverse=true, attribute=&quot;age&quot;) %} 
            ... 
        {% endfor %} 
 
    As a shortcut to chaining when the direction is the same for all 
    attributes, pass a comma separate list of attributes. 
 
    .. sourcecode:: jinja 
 
        {% for user users|sort(attribute=&quot;age,name&quot;) %} 
            ... 
        {% endfor %} 
 
    .. versionchanged:: 2.11.0 
        The ``attribute`` parameter can be a comma separated list of 
        attributes, e.g. ``&quot;age,name&quot;``. 
 
    .. versionchanged:: 2.6 
       The ``attribute`` parameter was added. 
    &quot;&quot;&quot;</span>
    <span class="s1">key_func = make_multi_attrgetter(</span>
        <span class="s1">environment</span><span class="s2">, </span><span class="s1">attribute</span><span class="s2">, </span><span class="s1">postprocess=ignore_case </span><span class="s2">if not </span><span class="s1">case_sensitive </span><span class="s2">else None</span>
    <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">sorted(value</span><span class="s2">, </span><span class="s1">key=key_func</span><span class="s2">, </span><span class="s1">reverse=reverse)</span>


<span class="s1">@pass_environment</span>
<span class="s2">def </span><span class="s1">do_unique(</span>
    <span class="s1">environment: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s4">&quot;t.Iterable[V]&quot;</span><span class="s2">,</span>
    <span class="s1">case_sensitive: bool = </span><span class="s2">False,</span>
    <span class="s1">attribute: t.Optional[t.Union[str</span><span class="s2">, </span><span class="s1">int]] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.Iterator[V]&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Returns a list of unique items from the given iterable. 
 
    .. sourcecode:: jinja 
 
        {{ ['foo', 'bar', 'foobar', 'FooBar']|unique|list }} 
            -&gt; ['foo', 'bar', 'foobar'] 
 
    The unique items are yielded in the same order as their first occurrence in 
    the iterable passed to the filter. 
 
    :param case_sensitive: Treat upper and lower case strings as distinct. 
    :param attribute: Filter objects with unique values for this attribute. 
    &quot;&quot;&quot;</span>
    <span class="s1">getter = make_attrgetter(</span>
        <span class="s1">environment</span><span class="s2">, </span><span class="s1">attribute</span><span class="s2">, </span><span class="s1">postprocess=ignore_case </span><span class="s2">if not </span><span class="s1">case_sensitive </span><span class="s2">else None</span>
    <span class="s1">)</span>
    <span class="s1">seen = set()</span>

    <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">value:</span>
        <span class="s1">key = getter(item)</span>

        <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">seen:</span>
            <span class="s1">seen.add(key)</span>
            <span class="s2">yield </span><span class="s1">item</span>


<span class="s2">def </span><span class="s1">_min_or_max(</span>
    <span class="s1">environment: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s4">&quot;t.Iterable[V]&quot;</span><span class="s2">,</span>
    <span class="s1">func: </span><span class="s4">&quot;t.Callable[..., V]&quot;</span><span class="s2">,</span>
    <span class="s1">case_sensitive: bool</span><span class="s2">,</span>
    <span class="s1">attribute: t.Optional[t.Union[str</span><span class="s2">, </span><span class="s1">int]]</span><span class="s2">,</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.Union[V, Undefined]&quot;</span><span class="s1">:</span>
    <span class="s1">it = iter(value)</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">first = next(it)</span>
    <span class="s2">except </span><span class="s1">StopIteration:</span>
        <span class="s2">return </span><span class="s1">environment.undefined(</span><span class="s4">&quot;No aggregated item, sequence was empty.&quot;</span><span class="s1">)</span>

    <span class="s1">key_func = make_attrgetter(</span>
        <span class="s1">environment</span><span class="s2">, </span><span class="s1">attribute</span><span class="s2">, </span><span class="s1">postprocess=ignore_case </span><span class="s2">if not </span><span class="s1">case_sensitive </span><span class="s2">else None</span>
    <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">func(chain([first]</span><span class="s2">, </span><span class="s1">it)</span><span class="s2">, </span><span class="s1">key=key_func)</span>


<span class="s1">@pass_environment</span>
<span class="s2">def </span><span class="s1">do_min(</span>
    <span class="s1">environment: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s4">&quot;t.Iterable[V]&quot;</span><span class="s2">,</span>
    <span class="s1">case_sensitive: bool = </span><span class="s2">False,</span>
    <span class="s1">attribute: t.Optional[t.Union[str</span><span class="s2">, </span><span class="s1">int]] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.Union[V, Undefined]&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Return the smallest item from the sequence. 
 
    .. sourcecode:: jinja 
 
        {{ [1, 2, 3]|min }} 
            -&gt; 1 
 
    :param case_sensitive: Treat upper and lower case strings as distinct. 
    :param attribute: Get the object with the min value of this attribute. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_min_or_max(environment</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">min</span><span class="s2">, </span><span class="s1">case_sensitive</span><span class="s2">, </span><span class="s1">attribute)</span>


<span class="s1">@pass_environment</span>
<span class="s2">def </span><span class="s1">do_max(</span>
    <span class="s1">environment: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s4">&quot;t.Iterable[V]&quot;</span><span class="s2">,</span>
    <span class="s1">case_sensitive: bool = </span><span class="s2">False,</span>
    <span class="s1">attribute: t.Optional[t.Union[str</span><span class="s2">, </span><span class="s1">int]] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.Union[V, Undefined]&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Return the largest item from the sequence. 
 
    .. sourcecode:: jinja 
 
        {{ [1, 2, 3]|max }} 
            -&gt; 3 
 
    :param case_sensitive: Treat upper and lower case strings as distinct. 
    :param attribute: Get the object with the max value of this attribute. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_min_or_max(environment</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">max</span><span class="s2">, </span><span class="s1">case_sensitive</span><span class="s2">, </span><span class="s1">attribute)</span>


<span class="s2">def </span><span class="s1">do_default(</span>
    <span class="s1">value: V</span><span class="s2">,</span>
    <span class="s1">default_value: V = </span><span class="s4">&quot;&quot;</span><span class="s2">,  </span><span class="s3"># type: ignore</span>
    <span class="s1">boolean: bool = </span><span class="s2">False,</span>
<span class="s1">) -&gt; V:</span>
    <span class="s0">&quot;&quot;&quot;If the value is undefined it will return the passed default value, 
    otherwise the value of the variable: 
 
    .. sourcecode:: jinja 
 
        {{ my_variable|default('my_variable is not defined') }} 
 
    This will output the value of ``my_variable`` if the variable was 
    defined, otherwise ``'my_variable is not defined'``. If you want 
    to use default with variables that evaluate to false you have to 
    set the second parameter to `true`: 
 
    .. sourcecode:: jinja 
 
        {{ ''|default('the string was empty', true) }} 
 
    .. versionchanged:: 2.11 
       It's now possible to configure the :class:`~jinja2.Environment` with 
       :class:`~jinja2.ChainableUndefined` to make the `default` filter work 
       on nested elements and attributes that may contain undefined values 
       in the chain without getting an :exc:`~jinja2.UndefinedError`. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">Undefined) </span><span class="s2">or </span><span class="s1">(boolean </span><span class="s2">and not </span><span class="s1">value):</span>
        <span class="s2">return </span><span class="s1">default_value</span>

    <span class="s2">return </span><span class="s1">value</span>


<span class="s1">@pass_eval_context</span>
<span class="s2">def </span><span class="s1">sync_do_join(</span>
    <span class="s1">eval_ctx: </span><span class="s4">&quot;EvalContext&quot;</span><span class="s2">,</span>
    <span class="s1">value: t.Iterable</span><span class="s2">,</span>
    <span class="s1">d: str = </span><span class="s4">&quot;&quot;</span><span class="s2">,</span>
    <span class="s1">attribute: t.Optional[t.Union[str</span><span class="s2">, </span><span class="s1">int]] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Return a string which is the concatenation of the strings in the 
    sequence. The separator between elements is an empty string per 
    default, you can define it with the optional parameter: 
 
    .. sourcecode:: jinja 
 
        {{ [1, 2, 3]|join('|') }} 
            -&gt; 1|2|3 
 
        {{ [1, 2, 3]|join }} 
            -&gt; 123 
 
    It is also possible to join certain attributes of an object: 
 
    .. sourcecode:: jinja 
 
        {{ users|join(', ', attribute='username') }} 
 
    .. versionadded:: 2.6 
       The `attribute` parameter was added. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">attribute </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">value = map(make_attrgetter(eval_ctx.environment</span><span class="s2">, </span><span class="s1">attribute)</span><span class="s2">, </span><span class="s1">value)</span>

    <span class="s3"># no automatic escaping?  joining is a lot easier then</span>
    <span class="s2">if not </span><span class="s1">eval_ctx.autoescape:</span>
        <span class="s2">return </span><span class="s1">str(d).join(map(str</span><span class="s2">, </span><span class="s1">value))</span>

    <span class="s3"># if the delimiter doesn't have an html representation we check</span>
    <span class="s3"># if any of the items has.  If yes we do a coercion to Markup</span>
    <span class="s2">if not </span><span class="s1">hasattr(d</span><span class="s2">, </span><span class="s4">&quot;__html__&quot;</span><span class="s1">):</span>
        <span class="s1">value = list(value)</span>
        <span class="s1">do_escape = </span><span class="s2">False</span>

        <span class="s2">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">item </span><span class="s2">in </span><span class="s1">enumerate(value):</span>
            <span class="s2">if </span><span class="s1">hasattr(item</span><span class="s2">, </span><span class="s4">&quot;__html__&quot;</span><span class="s1">):</span>
                <span class="s1">do_escape = </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">value[idx] = str(item)</span>

        <span class="s2">if </span><span class="s1">do_escape:</span>
            <span class="s1">d = escape(d)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">d = str(d)</span>

        <span class="s2">return </span><span class="s1">d.join(value)</span>

    <span class="s3"># no html involved, to normal joining</span>
    <span class="s2">return </span><span class="s1">soft_str(d).join(map(soft_str</span><span class="s2">, </span><span class="s1">value))</span>


<span class="s1">@async_variant(sync_do_join)  </span><span class="s3"># type: ignore</span>
<span class="s2">async def </span><span class="s1">do_join(</span>
    <span class="s1">eval_ctx: </span><span class="s4">&quot;EvalContext&quot;</span><span class="s2">,</span>
    <span class="s1">value: t.Union[t.AsyncIterable</span><span class="s2">, </span><span class="s1">t.Iterable]</span><span class="s2">,</span>
    <span class="s1">d: str = </span><span class="s4">&quot;&quot;</span><span class="s2">,</span>
    <span class="s1">attribute: t.Optional[t.Union[str</span><span class="s2">, </span><span class="s1">int]] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; str:</span>
    <span class="s2">return </span><span class="s1">sync_do_join(eval_ctx</span><span class="s2">, await </span><span class="s1">auto_to_list(value)</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">attribute)</span>


<span class="s2">def </span><span class="s1">do_center(value: str</span><span class="s2">, </span><span class="s1">width: int = </span><span class="s5">80</span><span class="s1">) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Centers the value in a field of a given width.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">soft_str(value).center(width)</span>


<span class="s1">@pass_environment</span>
<span class="s2">def </span><span class="s1">sync_do_first(</span>
    <span class="s1">environment: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">, </span><span class="s1">seq: </span><span class="s4">&quot;t.Iterable[V]&quot;</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.Union[V, Undefined]&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Return the first item of a sequence.&quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">next(iter(seq))</span>
    <span class="s2">except </span><span class="s1">StopIteration:</span>
        <span class="s2">return </span><span class="s1">environment.undefined(</span><span class="s4">&quot;No first item, sequence was empty.&quot;</span><span class="s1">)</span>


<span class="s1">@async_variant(sync_do_first)  </span><span class="s3"># type: ignore</span>
<span class="s2">async def </span><span class="s1">do_first(</span>
    <span class="s1">environment: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">, </span><span class="s1">seq: </span><span class="s4">&quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.Union[V, Undefined]&quot;</span><span class="s1">:</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return await </span><span class="s1">auto_aiter(seq).__anext__()</span>
    <span class="s2">except </span><span class="s1">StopAsyncIteration:</span>
        <span class="s2">return </span><span class="s1">environment.undefined(</span><span class="s4">&quot;No first item, sequence was empty.&quot;</span><span class="s1">)</span>


<span class="s1">@pass_environment</span>
<span class="s2">def </span><span class="s1">do_last(</span>
    <span class="s1">environment: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">, </span><span class="s1">seq: </span><span class="s4">&quot;t.Reversible[V]&quot;</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.Union[V, Undefined]&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Return the last item of a sequence. 
 
    Note: Does not work with generators. You may want to explicitly 
    convert it to a list: 
 
    .. sourcecode:: jinja 
 
        {{ data | selectattr('name', '==', 'Jinja') | list | last }} 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">next(iter(reversed(seq)))</span>
    <span class="s2">except </span><span class="s1">StopIteration:</span>
        <span class="s2">return </span><span class="s1">environment.undefined(</span><span class="s4">&quot;No last item, sequence was empty.&quot;</span><span class="s1">)</span>


<span class="s3"># No async do_last, it may not be safe in async mode.</span>


<span class="s1">@pass_context</span>
<span class="s2">def </span><span class="s1">do_random(context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">, </span><span class="s1">seq: </span><span class="s4">&quot;t.Sequence[V]&quot;</span><span class="s1">) -&gt; </span><span class="s4">&quot;t.Union[V, Undefined]&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Return a random item from the sequence.&quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">random.choice(seq)</span>
    <span class="s2">except </span><span class="s1">IndexError:</span>
        <span class="s2">return </span><span class="s1">context.environment.undefined(</span><span class="s4">&quot;No random item, sequence was empty.&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">do_filesizeformat(value: t.Union[str</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">int]</span><span class="s2">, </span><span class="s1">binary: bool = </span><span class="s2">False</span><span class="s1">) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Format the value like a 'human-readable' file size (i.e. 13 kB, 
    4.1 MB, 102 Bytes, etc).  Per default decimal prefixes are used (Mega, 
    Giga, etc.), if the second parameter is set to `True` the binary 
    prefixes are used (Mebi, Gibi). 
    &quot;&quot;&quot;</span>
    <span class="s1">bytes = float(value)</span>
    <span class="s1">base = </span><span class="s5">1024 </span><span class="s2">if </span><span class="s1">binary </span><span class="s2">else </span><span class="s5">1000</span>
    <span class="s1">prefixes = [</span>
        <span class="s1">(</span><span class="s4">&quot;KiB&quot; </span><span class="s2">if </span><span class="s1">binary </span><span class="s2">else </span><span class="s4">&quot;kB&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;MiB&quot; </span><span class="s2">if </span><span class="s1">binary </span><span class="s2">else </span><span class="s4">&quot;MB&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;GiB&quot; </span><span class="s2">if </span><span class="s1">binary </span><span class="s2">else </span><span class="s4">&quot;GB&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;TiB&quot; </span><span class="s2">if </span><span class="s1">binary </span><span class="s2">else </span><span class="s4">&quot;TB&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;PiB&quot; </span><span class="s2">if </span><span class="s1">binary </span><span class="s2">else </span><span class="s4">&quot;PB&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;EiB&quot; </span><span class="s2">if </span><span class="s1">binary </span><span class="s2">else </span><span class="s4">&quot;EB&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;ZiB&quot; </span><span class="s2">if </span><span class="s1">binary </span><span class="s2">else </span><span class="s4">&quot;ZB&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">&quot;YiB&quot; </span><span class="s2">if </span><span class="s1">binary </span><span class="s2">else </span><span class="s4">&quot;YB&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s2">if </span><span class="s1">bytes == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s4">&quot;1 Byte&quot;</span>
    <span class="s2">elif </span><span class="s1">bytes &lt; base:</span>
        <span class="s2">return </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">int(bytes)</span><span class="s2">} </span><span class="s4">Bytes&quot;</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">prefix </span><span class="s2">in </span><span class="s1">enumerate(prefixes):</span>
            <span class="s1">unit = base ** (i + </span><span class="s5">2</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">bytes &lt; unit:</span>
                <span class="s2">return </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">base * bytes / unit</span><span class="s2">:</span><span class="s4">.1f</span><span class="s2">} {</span><span class="s1">prefix</span><span class="s2">}</span><span class="s4">&quot;</span>

        <span class="s2">return </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">base * bytes / unit</span><span class="s2">:</span><span class="s4">.1f</span><span class="s2">} {</span><span class="s1">prefix</span><span class="s2">}</span><span class="s4">&quot;</span>


<span class="s2">def </span><span class="s1">do_pprint(value: t.Any) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Pretty print a variable. Useful for debugging.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">pformat(value)</span>


<span class="s1">_uri_scheme_re = re.compile(</span><span class="s4">r&quot;^([\w.+-]{2,}:(/){0,2})$&quot;</span><span class="s1">)</span>


<span class="s1">@pass_eval_context</span>
<span class="s2">def </span><span class="s1">do_urlize(</span>
    <span class="s1">eval_ctx: </span><span class="s4">&quot;EvalContext&quot;</span><span class="s2">,</span>
    <span class="s1">value: str</span><span class="s2">,</span>
    <span class="s1">trim_url_limit: t.Optional[int] = </span><span class="s2">None,</span>
    <span class="s1">nofollow: bool = </span><span class="s2">False,</span>
    <span class="s1">target: t.Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">rel: t.Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">extra_schemes: t.Optional[t.Iterable[str]] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Convert URLs in text into clickable links. 
 
    This may not recognize links in some situations. Usually, a more 
    comprehensive formatter, such as a Markdown library, is a better 
    choice. 
 
    Works on ``http://``, ``https://``, ``www.``, ``mailto:``, and email 
    addresses. Links with trailing punctuation (periods, commas, closing 
    parentheses) and leading punctuation (opening parentheses) are 
    recognized excluding the punctuation. Email addresses that include 
    header fields are not recognized (for example, 
    ``mailto:address@example.com?cc=copy@example.com``). 
 
    :param value: Original text containing URLs to link. 
    :param trim_url_limit: Shorten displayed URL values to this length. 
    :param nofollow: Add the ``rel=nofollow`` attribute to links. 
    :param target: Add the ``target`` attribute to links. 
    :param rel: Add the ``rel`` attribute to links. 
    :param extra_schemes: Recognize URLs that start with these schemes 
        in addition to the default behavior. Defaults to 
        ``env.policies[&quot;urlize.extra_schemes&quot;]``, which defaults to no 
        extra schemes. 
 
    .. versionchanged:: 3.0 
        The ``extra_schemes`` parameter was added. 
 
    .. versionchanged:: 3.0 
        Generate ``https://`` links for URLs without a scheme. 
 
    .. versionchanged:: 3.0 
        The parsing rules were updated. Recognize email addresses with 
        or without the ``mailto:`` scheme. Validate IP addresses. Ignore 
        parentheses and brackets in more cases. 
 
    .. versionchanged:: 2.8 
       The ``target`` parameter was added. 
    &quot;&quot;&quot;</span>
    <span class="s1">policies = eval_ctx.environment.policies</span>
    <span class="s1">rel_parts = set((rel </span><span class="s2">or </span><span class="s4">&quot;&quot;</span><span class="s1">).split())</span>

    <span class="s2">if </span><span class="s1">nofollow:</span>
        <span class="s1">rel_parts.add(</span><span class="s4">&quot;nofollow&quot;</span><span class="s1">)</span>

    <span class="s1">rel_parts.update((policies[</span><span class="s4">&quot;urlize.rel&quot;</span><span class="s1">] </span><span class="s2">or </span><span class="s4">&quot;&quot;</span><span class="s1">).split())</span>
    <span class="s1">rel = </span><span class="s4">&quot; &quot;</span><span class="s1">.join(sorted(rel_parts)) </span><span class="s2">or None</span>

    <span class="s2">if </span><span class="s1">target </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">target = policies[</span><span class="s4">&quot;urlize.target&quot;</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">extra_schemes </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">extra_schemes = policies[</span><span class="s4">&quot;urlize.extra_schemes&quot;</span><span class="s1">] </span><span class="s2">or </span><span class="s1">()</span>

    <span class="s2">for </span><span class="s1">scheme </span><span class="s2">in </span><span class="s1">extra_schemes:</span>
        <span class="s2">if </span><span class="s1">_uri_scheme_re.fullmatch(scheme) </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">FilterArgumentError(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">scheme</span><span class="s2">!r} </span><span class="s4">is not a valid URI scheme prefix.&quot;</span><span class="s1">)</span>

    <span class="s1">rv = urlize(</span>
        <span class="s1">value</span><span class="s2">,</span>
        <span class="s1">trim_url_limit=trim_url_limit</span><span class="s2">,</span>
        <span class="s1">rel=rel</span><span class="s2">,</span>
        <span class="s1">target=target</span><span class="s2">,</span>
        <span class="s1">extra_schemes=extra_schemes</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">eval_ctx.autoescape:</span>
        <span class="s1">rv = Markup(rv)</span>

    <span class="s2">return </span><span class="s1">rv</span>


<span class="s2">def </span><span class="s1">do_indent(</span>
    <span class="s1">s: str</span><span class="s2">, </span><span class="s1">width: t.Union[int</span><span class="s2">, </span><span class="s1">str] = </span><span class="s5">4</span><span class="s2">, </span><span class="s1">first: bool = </span><span class="s2">False, </span><span class="s1">blank: bool = </span><span class="s2">False</span>
<span class="s1">) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Return a copy of the string with each line indented by 4 spaces. The 
    first line and blank lines are not indented by default. 
 
    :param width: Number of spaces, or a string, to indent by. 
    :param first: Don't skip indenting the first line. 
    :param blank: Don't skip indenting empty lines. 
 
    .. versionchanged:: 3.0 
        ``width`` can be a string. 
 
    .. versionchanged:: 2.10 
        Blank lines are not indented by default. 
 
        Rename the ``indentfirst`` argument to ``first``. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(width</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">indention = width</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">indention = </span><span class="s4">&quot; &quot; </span><span class="s1">* width</span>

    <span class="s1">newline = </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span>

    <span class="s2">if </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">Markup):</span>
        <span class="s1">indention = Markup(indention)</span>
        <span class="s1">newline = Markup(newline)</span>

    <span class="s1">s += newline  </span><span class="s3"># this quirk is necessary for splitlines method</span>

    <span class="s2">if </span><span class="s1">blank:</span>
        <span class="s1">rv = (newline + indention).join(s.splitlines())</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">lines = s.splitlines()</span>
        <span class="s1">rv = lines.pop(</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">lines:</span>
            <span class="s1">rv += newline + newline.join(</span>
                <span class="s1">indention + line </span><span class="s2">if </span><span class="s1">line </span><span class="s2">else </span><span class="s1">line </span><span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines</span>
            <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">first:</span>
        <span class="s1">rv = indention + rv</span>

    <span class="s2">return </span><span class="s1">rv</span>


<span class="s1">@pass_environment</span>
<span class="s2">def </span><span class="s1">do_truncate(</span>
    <span class="s1">env: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">,</span>
    <span class="s1">s: str</span><span class="s2">,</span>
    <span class="s1">length: int = </span><span class="s5">255</span><span class="s2">,</span>
    <span class="s1">killwords: bool = </span><span class="s2">False,</span>
    <span class="s1">end: str = </span><span class="s4">&quot;...&quot;</span><span class="s2">,</span>
    <span class="s1">leeway: t.Optional[int] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Return a truncated copy of the string. The length is specified 
    with the first parameter which defaults to ``255``. If the second 
    parameter is ``true`` the filter will cut the text at length. Otherwise 
    it will discard the last word. If the text was in fact 
    truncated it will append an ellipsis sign (``&quot;...&quot;``). If you want a 
    different ellipsis sign than ``&quot;...&quot;`` you can specify it using the 
    third parameter. Strings that only exceed the length by the tolerance 
    margin given in the fourth parameter will not be truncated. 
 
    .. sourcecode:: jinja 
 
        {{ &quot;foo bar baz qux&quot;|truncate(9) }} 
            -&gt; &quot;foo...&quot; 
        {{ &quot;foo bar baz qux&quot;|truncate(9, True) }} 
            -&gt; &quot;foo ba...&quot; 
        {{ &quot;foo bar baz qux&quot;|truncate(11) }} 
            -&gt; &quot;foo bar baz qux&quot; 
        {{ &quot;foo bar baz qux&quot;|truncate(11, False, '...', 0) }} 
            -&gt; &quot;foo bar...&quot; 
 
    The default leeway on newer Jinja versions is 5 and was 0 before but 
    can be reconfigured globally. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">leeway </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">leeway = env.policies[</span><span class="s4">&quot;truncate.leeway&quot;</span><span class="s1">]</span>

    <span class="s2">assert </span><span class="s1">length &gt;= len(end)</span><span class="s2">, </span><span class="s4">f&quot;expected length &gt;= </span><span class="s2">{</span><span class="s1">len(end)</span><span class="s2">}</span><span class="s4">, got </span><span class="s2">{</span><span class="s1">length</span><span class="s2">}</span><span class="s4">&quot;</span>
    <span class="s2">assert </span><span class="s1">leeway &gt;= </span><span class="s5">0</span><span class="s2">, </span><span class="s4">f&quot;expected leeway &gt;= 0, got </span><span class="s2">{</span><span class="s1">leeway</span><span class="s2">}</span><span class="s4">&quot;</span>

    <span class="s2">if </span><span class="s1">len(s) &lt;= length + leeway:</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">if </span><span class="s1">killwords:</span>
        <span class="s2">return </span><span class="s1">s[: length - len(end)] + end</span>

    <span class="s1">result = s[: length - len(end)].rsplit(</span><span class="s4">&quot; &quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">result + end</span>


<span class="s1">@pass_environment</span>
<span class="s2">def </span><span class="s1">do_wordwrap(</span>
    <span class="s1">environment: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">,</span>
    <span class="s1">s: str</span><span class="s2">,</span>
    <span class="s1">width: int = </span><span class="s5">79</span><span class="s2">,</span>
    <span class="s1">break_long_words: bool = </span><span class="s2">True,</span>
    <span class="s1">wrapstring: t.Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">break_on_hyphens: bool = </span><span class="s2">True,</span>
<span class="s1">) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Wrap a string to the given width. Existing newlines are treated 
    as paragraphs to be wrapped separately. 
 
    :param s: Original text to wrap. 
    :param width: Maximum length of wrapped lines. 
    :param break_long_words: If a word is longer than ``width``, break 
        it across lines. 
    :param break_on_hyphens: If a word contains hyphens, it may be split 
        across lines. 
    :param wrapstring: String to join each wrapped line. Defaults to 
        :attr:`Environment.newline_sequence`. 
 
    .. versionchanged:: 2.11 
        Existing newlines are treated as paragraphs wrapped separately. 
 
    .. versionchanged:: 2.11 
        Added the ``break_on_hyphens`` parameter. 
 
    .. versionchanged:: 2.7 
        Added the ``wrapstring`` parameter. 
    &quot;&quot;&quot;</span>
    <span class="s2">import </span><span class="s1">textwrap</span>

    <span class="s2">if </span><span class="s1">wrapstring </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">wrapstring = environment.newline_sequence</span>

    <span class="s3"># textwrap.wrap doesn't consider existing newlines when wrapping.</span>
    <span class="s3"># If the string has a newline before width, wrap will still insert</span>
    <span class="s3"># a newline at width, resulting in a short line. Instead, split and</span>
    <span class="s3"># wrap each paragraph individually.</span>
    <span class="s2">return </span><span class="s1">wrapstring.join(</span>
        <span class="s1">[</span>
            <span class="s1">wrapstring.join(</span>
                <span class="s1">textwrap.wrap(</span>
                    <span class="s1">line</span><span class="s2">,</span>
                    <span class="s1">width=width</span><span class="s2">,</span>
                    <span class="s1">expand_tabs=</span><span class="s2">False,</span>
                    <span class="s1">replace_whitespace=</span><span class="s2">False,</span>
                    <span class="s1">break_long_words=break_long_words</span><span class="s2">,</span>
                    <span class="s1">break_on_hyphens=break_on_hyphens</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">s.splitlines()</span>
        <span class="s1">]</span>
    <span class="s1">)</span>


<span class="s1">_word_re = re.compile(</span><span class="s4">r&quot;\w+&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">do_wordcount(s: str) -&gt; int:</span>
    <span class="s0">&quot;&quot;&quot;Count the words in that string.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">len(_word_re.findall(soft_str(s)))</span>


<span class="s2">def </span><span class="s1">do_int(value: t.Any</span><span class="s2">, </span><span class="s1">default: int = </span><span class="s5">0</span><span class="s2">, </span><span class="s1">base: int = </span><span class="s5">10</span><span class="s1">) -&gt; int:</span>
    <span class="s0">&quot;&quot;&quot;Convert the value into an integer. If the 
    conversion doesn't work it will return ``0``. You can 
    override this default using the first parameter. You 
    can also override the default base (10) in the second 
    parameter, which handles input with prefixes such as 
    0b, 0o and 0x for bases 2, 8 and 16 respectively. 
    The base is ignored for decimal numbers and non-string values. 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">return </span><span class="s1">int(value</span><span class="s2">, </span><span class="s1">base)</span>

        <span class="s2">return </span><span class="s1">int(value)</span>
    <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError):</span>
        <span class="s3"># this quirk is necessary so that &quot;42.23&quot;|int gives 42.</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">int(float(value))</span>
        <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError):</span>
            <span class="s2">return </span><span class="s1">default</span>


<span class="s2">def </span><span class="s1">do_float(value: t.Any</span><span class="s2">, </span><span class="s1">default: float = </span><span class="s5">0.0</span><span class="s1">) -&gt; float:</span>
    <span class="s0">&quot;&quot;&quot;Convert the value into a floating point number. If the 
    conversion doesn't work it will return ``0.0``. You can 
    override this default using the first parameter. 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">float(value)</span>
    <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError):</span>
        <span class="s2">return </span><span class="s1">default</span>


<span class="s2">def </span><span class="s1">do_format(value: str</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Apply the given values to a `printf-style`_ format string, like 
    ``string % values``. 
 
    .. sourcecode:: jinja 
 
        {{ &quot;%s, %s!&quot;|format(greeting, name) }} 
        Hello, World! 
 
    In most cases it should be more convenient and efficient to use the 
    ``%`` operator or :meth:`str.format`. 
 
    .. code-block:: text 
 
        {{ &quot;%s, %s!&quot; % (greeting, name) }} 
        {{ &quot;{}, {}!&quot;.format(greeting, name) }} 
 
    .. _printf-style: https://docs.python.org/library/stdtypes.html 
        #printf-style-string-formatting 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">args </span><span class="s2">and </span><span class="s1">kwargs:</span>
        <span class="s2">raise </span><span class="s1">FilterArgumentError(</span>
            <span class="s4">&quot;can't handle positional and keyword arguments at the same time&quot;</span>
        <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">soft_str(value) % (kwargs </span><span class="s2">or </span><span class="s1">args)</span>


<span class="s2">def </span><span class="s1">do_trim(value: str</span><span class="s2">, </span><span class="s1">chars: t.Optional[str] = </span><span class="s2">None</span><span class="s1">) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Strip leading and trailing characters, by default whitespace.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">soft_str(value).strip(chars)</span>


<span class="s2">def </span><span class="s1">do_striptags(value: </span><span class="s4">&quot;t.Union[str, HasHTML]&quot;</span><span class="s1">) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Strip SGML/XML tags and replace adjacent whitespace by one space.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">hasattr(value</span><span class="s2">, </span><span class="s4">&quot;__html__&quot;</span><span class="s1">):</span>
        <span class="s1">value = t.cast(</span><span class="s4">&quot;HasHTML&quot;</span><span class="s2">, </span><span class="s1">value).__html__()</span>

    <span class="s2">return </span><span class="s1">Markup(str(value)).striptags()</span>


<span class="s2">def </span><span class="s1">sync_do_slice(</span>
    <span class="s1">value: </span><span class="s4">&quot;t.Collection[V]&quot;</span><span class="s2">, </span><span class="s1">slices: int</span><span class="s2">, </span><span class="s1">fill_with: </span><span class="s4">&quot;t.Optional[V]&quot; </span><span class="s1">= </span><span class="s2">None</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.Iterator[t.List[V]]&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Slice an iterator and return a list of lists containing 
    those items. Useful if you want to create a div containing 
    three ul tags that represent columns: 
 
    .. sourcecode:: html+jinja 
 
        &lt;div class=&quot;columnwrapper&quot;&gt; 
          {%- for column in items|slice(3) %} 
            &lt;ul class=&quot;column-{{ loop.index }}&quot;&gt; 
            {%- for item in column %} 
              &lt;li&gt;{{ item }}&lt;/li&gt; 
            {%- endfor %} 
            &lt;/ul&gt; 
          {%- endfor %} 
        &lt;/div&gt; 
 
    If you pass it a second argument it's used to fill missing 
    values on the last iteration. 
    &quot;&quot;&quot;</span>
    <span class="s1">seq = list(value)</span>
    <span class="s1">length = len(seq)</span>
    <span class="s1">items_per_slice = length // slices</span>
    <span class="s1">slices_with_extra = length % slices</span>
    <span class="s1">offset = </span><span class="s5">0</span>

    <span class="s2">for </span><span class="s1">slice_number </span><span class="s2">in </span><span class="s1">range(slices):</span>
        <span class="s1">start = offset + slice_number * items_per_slice</span>

        <span class="s2">if </span><span class="s1">slice_number &lt; slices_with_extra:</span>
            <span class="s1">offset += </span><span class="s5">1</span>

        <span class="s1">end = offset + (slice_number + </span><span class="s5">1</span><span class="s1">) * items_per_slice</span>
        <span class="s1">tmp = seq[start:end]</span>

        <span class="s2">if </span><span class="s1">fill_with </span><span class="s2">is not None and </span><span class="s1">slice_number &gt;= slices_with_extra:</span>
            <span class="s1">tmp.append(fill_with)</span>

        <span class="s2">yield </span><span class="s1">tmp</span>


<span class="s1">@async_variant(sync_do_slice)  </span><span class="s3"># type: ignore</span>
<span class="s2">async def </span><span class="s1">do_slice(</span>
    <span class="s1">value: </span><span class="s4">&quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;</span><span class="s2">,</span>
    <span class="s1">slices: int</span><span class="s2">,</span>
    <span class="s1">fill_with: t.Optional[t.Any] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.Iterator[t.List[V]]&quot;</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">sync_do_slice(</span><span class="s2">await </span><span class="s1">auto_to_list(value)</span><span class="s2">, </span><span class="s1">slices</span><span class="s2">, </span><span class="s1">fill_with)</span>


<span class="s2">def </span><span class="s1">do_batch(</span>
    <span class="s1">value: </span><span class="s4">&quot;t.Iterable[V]&quot;</span><span class="s2">, </span><span class="s1">linecount: int</span><span class="s2">, </span><span class="s1">fill_with: </span><span class="s4">&quot;t.Optional[V]&quot; </span><span class="s1">= </span><span class="s2">None</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.Iterator[t.List[V]]&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot; 
    A filter that batches items. It works pretty much like `slice` 
    just the other way round. It returns a list of lists with the 
    given number of items. If you provide a second parameter this 
    is used to fill up missing items. See this example: 
 
    .. sourcecode:: html+jinja 
 
        &lt;table&gt; 
        {%- for row in items|batch(3, '&amp;nbsp;') %} 
          &lt;tr&gt; 
          {%- for column in row %} 
            &lt;td&gt;{{ column }}&lt;/td&gt; 
          {%- endfor %} 
          &lt;/tr&gt; 
        {%- endfor %} 
        &lt;/table&gt; 
    &quot;&quot;&quot;</span>
    <span class="s1">tmp: </span><span class="s4">&quot;t.List[V]&quot; </span><span class="s1">= []</span>

    <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">value:</span>
        <span class="s2">if </span><span class="s1">len(tmp) == linecount:</span>
            <span class="s2">yield </span><span class="s1">tmp</span>
            <span class="s1">tmp = []</span>

        <span class="s1">tmp.append(item)</span>

    <span class="s2">if </span><span class="s1">tmp:</span>
        <span class="s2">if </span><span class="s1">fill_with </span><span class="s2">is not None and </span><span class="s1">len(tmp) &lt; linecount:</span>
            <span class="s1">tmp += [fill_with] * (linecount - len(tmp))</span>

        <span class="s2">yield </span><span class="s1">tmp</span>


<span class="s2">def </span><span class="s1">do_round(</span>
    <span class="s1">value: float</span><span class="s2">,</span>
    <span class="s1">precision: int = </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s1">method: </span><span class="s4">'te.Literal[&quot;common&quot;, &quot;ceil&quot;, &quot;floor&quot;]' </span><span class="s1">= </span><span class="s4">&quot;common&quot;</span><span class="s2">,</span>
<span class="s1">) -&gt; float:</span>
    <span class="s0">&quot;&quot;&quot;Round the number to a given precision. The first 
    parameter specifies the precision (default is ``0``), the 
    second the rounding method: 
 
    - ``'common'`` rounds either up or down 
    - ``'ceil'`` always rounds up 
    - ``'floor'`` always rounds down 
 
    If you don't specify a method ``'common'`` is used. 
 
    .. sourcecode:: jinja 
 
        {{ 42.55|round }} 
            -&gt; 43.0 
        {{ 42.55|round(1, 'floor') }} 
            -&gt; 42.5 
 
    Note that even if rounded to 0 precision, a float is returned.  If 
    you need a real integer, pipe it through `int`: 
 
    .. sourcecode:: jinja 
 
        {{ 42.55|round|int }} 
            -&gt; 43 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">method </span><span class="s2">not in </span><span class="s1">{</span><span class="s4">&quot;common&quot;</span><span class="s2">, </span><span class="s4">&quot;ceil&quot;</span><span class="s2">, </span><span class="s4">&quot;floor&quot;</span><span class="s1">}:</span>
        <span class="s2">raise </span><span class="s1">FilterArgumentError(</span><span class="s4">&quot;method must be common, ceil or floor&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">method == </span><span class="s4">&quot;common&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">round(value</span><span class="s2">, </span><span class="s1">precision)</span>

    <span class="s1">func = getattr(math</span><span class="s2">, </span><span class="s1">method)</span>
    <span class="s2">return </span><span class="s1">t.cast(float</span><span class="s2">, </span><span class="s1">func(value * (</span><span class="s5">10 </span><span class="s1">** precision)) / (</span><span class="s5">10 </span><span class="s1">** precision))</span>


<span class="s2">class </span><span class="s1">_GroupTuple(t.NamedTuple):</span>
    <span class="s1">grouper: t.Any</span>
    <span class="s1">list: t.List</span>

    <span class="s3"># Use the regular tuple repr to hide this subclass if users print</span>
    <span class="s3"># out the value during debugging.</span>
    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">tuple.__repr__(self)</span>

    <span class="s2">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">tuple.__str__(self)</span>


<span class="s1">@pass_environment</span>
<span class="s2">def </span><span class="s1">sync_do_groupby(</span>
    <span class="s1">environment: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s4">&quot;t.Iterable[V]&quot;</span><span class="s2">,</span>
    <span class="s1">attribute: t.Union[str</span><span class="s2">, </span><span class="s1">int]</span><span class="s2">,</span>
    <span class="s1">default: t.Optional[t.Any] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.List[t.Tuple[t.Any, t.List[V]]]&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Group a sequence of objects by an attribute using Python's 
    :func:`itertools.groupby`. The attribute can use dot notation for 
    nested access, like ``&quot;address.city&quot;``. Unlike Python's ``groupby``, 
    the values are sorted first so only one group is returned for each 
    unique value. 
 
    For example, a list of ``User`` objects with a ``city`` attribute 
    can be rendered in groups. In this example, ``grouper`` refers to 
    the ``city`` value of the group. 
 
    .. sourcecode:: html+jinja 
 
        &lt;ul&gt;{% for city, items in users|groupby(&quot;city&quot;) %} 
          &lt;li&gt;{{ city }} 
            &lt;ul&gt;{% for user in items %} 
              &lt;li&gt;{{ user.name }} 
            {% endfor %}&lt;/ul&gt; 
          &lt;/li&gt; 
        {% endfor %}&lt;/ul&gt; 
 
    ``groupby`` yields namedtuples of ``(grouper, list)``, which 
    can be used instead of the tuple unpacking above. ``grouper`` is the 
    value of the attribute, and ``list`` is the items with that value. 
 
    .. sourcecode:: html+jinja 
 
        &lt;ul&gt;{% for group in users|groupby(&quot;city&quot;) %} 
          &lt;li&gt;{{ group.grouper }}: {{ group.list|join(&quot;, &quot;) }} 
        {% endfor %}&lt;/ul&gt; 
 
    You can specify a ``default`` value to use if an object in the list 
    does not have the given attribute. 
 
    .. sourcecode:: jinja 
 
        &lt;ul&gt;{% for city, items in users|groupby(&quot;city&quot;, default=&quot;NY&quot;) %} 
          &lt;li&gt;{{ city }}: {{ items|map(attribute=&quot;name&quot;)|join(&quot;, &quot;) }}&lt;/li&gt; 
        {% endfor %}&lt;/ul&gt; 
 
    .. versionchanged:: 3.0 
        Added the ``default`` parameter. 
 
    .. versionchanged:: 2.6 
        The attribute supports dot notation for nested access. 
    &quot;&quot;&quot;</span>
    <span class="s1">expr = make_attrgetter(environment</span><span class="s2">, </span><span class="s1">attribute</span><span class="s2">, </span><span class="s1">default=default)</span>
    <span class="s2">return </span><span class="s1">[</span>
        <span class="s1">_GroupTuple(key</span><span class="s2">, </span><span class="s1">list(values))</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">values </span><span class="s2">in </span><span class="s1">groupby(sorted(value</span><span class="s2">, </span><span class="s1">key=expr)</span><span class="s2">, </span><span class="s1">expr)</span>
    <span class="s1">]</span>


<span class="s1">@async_variant(sync_do_groupby)  </span><span class="s3"># type: ignore</span>
<span class="s2">async def </span><span class="s1">do_groupby(</span>
    <span class="s1">environment: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s4">&quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;</span><span class="s2">,</span>
    <span class="s1">attribute: t.Union[str</span><span class="s2">, </span><span class="s1">int]</span><span class="s2">,</span>
    <span class="s1">default: t.Optional[t.Any] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.List[t.Tuple[t.Any, t.List[V]]]&quot;</span><span class="s1">:</span>
    <span class="s1">expr = make_attrgetter(environment</span><span class="s2">, </span><span class="s1">attribute</span><span class="s2">, </span><span class="s1">default=default)</span>
    <span class="s2">return </span><span class="s1">[</span>
        <span class="s1">_GroupTuple(key</span><span class="s2">, await </span><span class="s1">auto_to_list(values))</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">values </span><span class="s2">in </span><span class="s1">groupby(sorted(</span><span class="s2">await </span><span class="s1">auto_to_list(value)</span><span class="s2">, </span><span class="s1">key=expr)</span><span class="s2">, </span><span class="s1">expr)</span>
    <span class="s1">]</span>


<span class="s1">@pass_environment</span>
<span class="s2">def </span><span class="s1">sync_do_sum(</span>
    <span class="s1">environment: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">,</span>
    <span class="s1">iterable: </span><span class="s4">&quot;t.Iterable[V]&quot;</span><span class="s2">,</span>
    <span class="s1">attribute: t.Optional[t.Union[str</span><span class="s2">, </span><span class="s1">int]] = </span><span class="s2">None,</span>
    <span class="s1">start: V = </span><span class="s5">0</span><span class="s2">,  </span><span class="s3"># type: ignore</span>
<span class="s1">) -&gt; V:</span>
    <span class="s0">&quot;&quot;&quot;Returns the sum of a sequence of numbers plus the value of parameter 
    'start' (which defaults to 0).  When the sequence is empty it returns 
    start. 
 
    It is also possible to sum up only certain attributes: 
 
    .. sourcecode:: jinja 
 
        Total: {{ items|sum(attribute='price') }} 
 
    .. versionchanged:: 2.6 
       The `attribute` parameter was added to allow suming up over 
       attributes.  Also the `start` parameter was moved on to the right. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">attribute </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">iterable = map(make_attrgetter(environment</span><span class="s2">, </span><span class="s1">attribute)</span><span class="s2">, </span><span class="s1">iterable)</span>

    <span class="s2">return </span><span class="s1">sum(iterable</span><span class="s2">, </span><span class="s1">start)</span>


<span class="s1">@async_variant(sync_do_sum)  </span><span class="s3"># type: ignore</span>
<span class="s2">async def </span><span class="s1">do_sum(</span>
    <span class="s1">environment: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">,</span>
    <span class="s1">iterable: </span><span class="s4">&quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;</span><span class="s2">,</span>
    <span class="s1">attribute: t.Optional[t.Union[str</span><span class="s2">, </span><span class="s1">int]] = </span><span class="s2">None,</span>
    <span class="s1">start: V = </span><span class="s5">0</span><span class="s2">,  </span><span class="s3"># type: ignore</span>
<span class="s1">) -&gt; V:</span>
    <span class="s1">rv = start</span>

    <span class="s2">if </span><span class="s1">attribute </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">func = make_attrgetter(environment</span><span class="s2">, </span><span class="s1">attribute)</span>
    <span class="s2">else</span><span class="s1">:</span>

        <span class="s2">def </span><span class="s1">func(x: V) -&gt; V:</span>
            <span class="s2">return </span><span class="s1">x</span>

    <span class="s2">async for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">auto_aiter(iterable):</span>
        <span class="s1">rv += func(item)</span>

    <span class="s2">return </span><span class="s1">rv</span>


<span class="s2">def </span><span class="s1">sync_do_list(value: </span><span class="s4">&quot;t.Iterable[V]&quot;</span><span class="s1">) -&gt; </span><span class="s4">&quot;t.List[V]&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Convert the value into a list.  If it was a string the returned list 
    will be a list of characters. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">list(value)</span>


<span class="s1">@async_variant(sync_do_list)  </span><span class="s3"># type: ignore</span>
<span class="s2">async def </span><span class="s1">do_list(value: </span><span class="s4">&quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;</span><span class="s1">) -&gt; </span><span class="s4">&quot;t.List[V]&quot;</span><span class="s1">:</span>
    <span class="s2">return await </span><span class="s1">auto_to_list(value)</span>


<span class="s2">def </span><span class="s1">do_mark_safe(value: str) -&gt; Markup:</span>
    <span class="s0">&quot;&quot;&quot;Mark the value as safe which means that in an environment with automatic 
    escaping enabled this variable will not be escaped. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">Markup(value)</span>


<span class="s2">def </span><span class="s1">do_mark_unsafe(value: str) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Mark a value as unsafe.  This is the reverse operation for :func:`safe`.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">str(value)</span>


<span class="s1">@typing.overload</span>
<span class="s2">def </span><span class="s1">do_reverse(value: str) -&gt; str:</span>
    <span class="s1">...</span>


<span class="s1">@typing.overload</span>
<span class="s2">def </span><span class="s1">do_reverse(value: </span><span class="s4">&quot;t.Iterable[V]&quot;</span><span class="s1">) -&gt; </span><span class="s4">&quot;t.Iterable[V]&quot;</span><span class="s1">:</span>
    <span class="s1">...</span>


<span class="s2">def </span><span class="s1">do_reverse(value: t.Union[str</span><span class="s2">, </span><span class="s1">t.Iterable[V]]) -&gt; t.Union[str</span><span class="s2">, </span><span class="s1">t.Iterable[V]]:</span>
    <span class="s0">&quot;&quot;&quot;Reverse the object or return an iterator that iterates over it the other 
    way round. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">return </span><span class="s1">value[::-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">reversed(value)  </span><span class="s3"># type: ignore</span>
    <span class="s2">except </span><span class="s1">TypeError:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">rv = list(value)</span>
            <span class="s1">rv.reverse()</span>
            <span class="s2">return </span><span class="s1">rv</span>
        <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">FilterArgumentError(</span><span class="s4">&quot;argument must be iterable&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>


<span class="s1">@pass_environment</span>
<span class="s2">def </span><span class="s1">do_attr(</span>
    <span class="s1">environment: </span><span class="s4">&quot;Environment&quot;</span><span class="s2">, </span><span class="s1">obj: t.Any</span><span class="s2">, </span><span class="s1">name: str</span>
<span class="s1">) -&gt; t.Union[Undefined</span><span class="s2">, </span><span class="s1">t.Any]:</span>
    <span class="s0">&quot;&quot;&quot;Get an attribute of an object.  ``foo|attr(&quot;bar&quot;)`` works like 
    ``foo.bar`` just that always an attribute is returned and items are not 
    looked up. 
 
    See :ref:`Notes on subscriptions &lt;notes-on-subscriptions&gt;` for more details. 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">name = str(name)</span>
    <span class="s2">except </span><span class="s1">UnicodeError:</span>
        <span class="s2">pass</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">value = getattr(obj</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">environment.sandboxed:</span>
                <span class="s1">environment = t.cast(</span><span class="s4">&quot;SandboxedEnvironment&quot;</span><span class="s2">, </span><span class="s1">environment)</span>

                <span class="s2">if not </span><span class="s1">environment.is_safe_attribute(obj</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value):</span>
                    <span class="s2">return </span><span class="s1">environment.unsafe_undefined(obj</span><span class="s2">, </span><span class="s1">name)</span>

            <span class="s2">return </span><span class="s1">value</span>

    <span class="s2">return </span><span class="s1">environment.undefined(obj=obj</span><span class="s2">, </span><span class="s1">name=name)</span>


<span class="s1">@typing.overload</span>
<span class="s2">def </span><span class="s1">sync_do_map(</span>
    <span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">, </span><span class="s1">value: t.Iterable</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any</span>
<span class="s1">) -&gt; t.Iterable:</span>
    <span class="s1">...</span>


<span class="s1">@typing.overload</span>
<span class="s2">def </span><span class="s1">sync_do_map(</span>
    <span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">,</span>
    <span class="s1">value: t.Iterable</span><span class="s2">,</span>
    <span class="s1">*</span><span class="s2">,</span>
    <span class="s1">attribute: str = ...</span><span class="s2">,</span>
    <span class="s1">default: t.Optional[t.Any] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; t.Iterable:</span>
    <span class="s1">...</span>


<span class="s1">@pass_context</span>
<span class="s2">def </span><span class="s1">sync_do_map(</span>
    <span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">, </span><span class="s1">value: t.Iterable</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any</span>
<span class="s1">) -&gt; t.Iterable:</span>
    <span class="s0">&quot;&quot;&quot;Applies a filter on a sequence of objects or looks up an attribute. 
    This is useful when dealing with lists of objects but you are really 
    only interested in a certain value of it. 
 
    The basic usage is mapping on an attribute.  Imagine you have a list 
    of users but you are only interested in a list of usernames: 
 
    .. sourcecode:: jinja 
 
        Users on this page: {{ users|map(attribute='username')|join(', ') }} 
 
    You can specify a ``default`` value to use if an object in the list 
    does not have the given attribute. 
 
    .. sourcecode:: jinja 
 
        {{ users|map(attribute=&quot;username&quot;, default=&quot;Anonymous&quot;)|join(&quot;, &quot;) }} 
 
    Alternatively you can let it invoke a filter by passing the name of the 
    filter and the arguments afterwards.  A good example would be applying a 
    text conversion filter on a sequence: 
 
    .. sourcecode:: jinja 
 
        Users on this page: {{ titles|map('lower')|join(', ') }} 
 
    Similar to a generator comprehension such as: 
 
    .. code-block:: python 
 
        (u.username for u in users) 
        (getattr(u, &quot;username&quot;, &quot;Anonymous&quot;) for u in users) 
        (do_lower(x) for x in titles) 
 
    .. versionchanged:: 2.11.0 
        Added the ``default`` parameter. 
 
    .. versionadded:: 2.7 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">value:</span>
        <span class="s1">func = prepare_map(context</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>

        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">value:</span>
            <span class="s2">yield </span><span class="s1">func(item)</span>


<span class="s1">@typing.overload</span>
<span class="s2">def </span><span class="s1">do_map(</span>
    <span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">,</span>
    <span class="s1">value: t.Union[t.AsyncIterable</span><span class="s2">, </span><span class="s1">t.Iterable]</span><span class="s2">,</span>
    <span class="s1">name: str</span><span class="s2">,</span>
    <span class="s1">*args: t.Any</span><span class="s2">,</span>
    <span class="s1">**kwargs: t.Any</span><span class="s2">,</span>
<span class="s1">) -&gt; t.Iterable:</span>
    <span class="s1">...</span>


<span class="s1">@typing.overload</span>
<span class="s2">def </span><span class="s1">do_map(</span>
    <span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">,</span>
    <span class="s1">value: t.Union[t.AsyncIterable</span><span class="s2">, </span><span class="s1">t.Iterable]</span><span class="s2">,</span>
    <span class="s1">*</span><span class="s2">,</span>
    <span class="s1">attribute: str = ...</span><span class="s2">,</span>
    <span class="s1">default: t.Optional[t.Any] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; t.Iterable:</span>
    <span class="s1">...</span>


<span class="s1">@async_variant(sync_do_map)  </span><span class="s3"># type: ignore</span>
<span class="s2">async def </span><span class="s1">do_map(</span>
    <span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">,</span>
    <span class="s1">value: t.Union[t.AsyncIterable</span><span class="s2">, </span><span class="s1">t.Iterable]</span><span class="s2">,</span>
    <span class="s1">*args: t.Any</span><span class="s2">,</span>
    <span class="s1">**kwargs: t.Any</span><span class="s2">,</span>
<span class="s1">) -&gt; t.AsyncIterable:</span>
    <span class="s2">if </span><span class="s1">value:</span>
        <span class="s1">func = prepare_map(context</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>

        <span class="s2">async for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">auto_aiter(value):</span>
            <span class="s2">yield await </span><span class="s1">auto_await(func(item))</span>


<span class="s1">@pass_context</span>
<span class="s2">def </span><span class="s1">sync_do_select(</span>
    <span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">, </span><span class="s1">value: </span><span class="s4">&quot;t.Iterable[V]&quot;</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.Iterator[V]&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Filters a sequence of objects by applying a test to each object, 
    and only selecting the objects with the test succeeding. 
 
    If no test is specified, each object will be evaluated as a boolean. 
 
    Example usage: 
 
    .. sourcecode:: jinja 
 
        {{ numbers|select(&quot;odd&quot;) }} 
        {{ numbers|select(&quot;odd&quot;) }} 
        {{ numbers|select(&quot;divisibleby&quot;, 3) }} 
        {{ numbers|select(&quot;lessthan&quot;, 42) }} 
        {{ strings|select(&quot;equalto&quot;, &quot;mystring&quot;) }} 
 
    Similar to a generator comprehension such as: 
 
    .. code-block:: python 
 
        (n for n in numbers if test_odd(n)) 
        (n for n in numbers if test_divisibleby(n, 3)) 
 
    .. versionadded:: 2.7 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">select_or_reject(context</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, lambda </span><span class="s1">x: x</span><span class="s2">, False</span><span class="s1">)</span>


<span class="s1">@async_variant(sync_do_select)  </span><span class="s3"># type: ignore</span>
<span class="s2">async def </span><span class="s1">do_select(</span>
    <span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s4">&quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;</span><span class="s2">,</span>
    <span class="s1">*args: t.Any</span><span class="s2">,</span>
    <span class="s1">**kwargs: t.Any</span><span class="s2">,</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.AsyncIterator[V]&quot;</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">async_select_or_reject(context</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, lambda </span><span class="s1">x: x</span><span class="s2">, False</span><span class="s1">)</span>


<span class="s1">@pass_context</span>
<span class="s2">def </span><span class="s1">sync_do_reject(</span>
    <span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">, </span><span class="s1">value: </span><span class="s4">&quot;t.Iterable[V]&quot;</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.Iterator[V]&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Filters a sequence of objects by applying a test to each object, 
    and rejecting the objects with the test succeeding. 
 
    If no test is specified, each object will be evaluated as a boolean. 
 
    Example usage: 
 
    .. sourcecode:: jinja 
 
        {{ numbers|reject(&quot;odd&quot;) }} 
 
    Similar to a generator comprehension such as: 
 
    .. code-block:: python 
 
        (n for n in numbers if not test_odd(n)) 
 
    .. versionadded:: 2.7 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">select_or_reject(context</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, lambda </span><span class="s1">x: </span><span class="s2">not </span><span class="s1">x</span><span class="s2">, False</span><span class="s1">)</span>


<span class="s1">@async_variant(sync_do_reject)  </span><span class="s3"># type: ignore</span>
<span class="s2">async def </span><span class="s1">do_reject(</span>
    <span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s4">&quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;</span><span class="s2">,</span>
    <span class="s1">*args: t.Any</span><span class="s2">,</span>
    <span class="s1">**kwargs: t.Any</span><span class="s2">,</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.AsyncIterator[V]&quot;</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">async_select_or_reject(context</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, lambda </span><span class="s1">x: </span><span class="s2">not </span><span class="s1">x</span><span class="s2">, False</span><span class="s1">)</span>


<span class="s1">@pass_context</span>
<span class="s2">def </span><span class="s1">sync_do_selectattr(</span>
    <span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">, </span><span class="s1">value: </span><span class="s4">&quot;t.Iterable[V]&quot;</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.Iterator[V]&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Filters a sequence of objects by applying a test to the specified 
    attribute of each object, and only selecting the objects with the 
    test succeeding. 
 
    If no test is specified, the attribute's value will be evaluated as 
    a boolean. 
 
    Example usage: 
 
    .. sourcecode:: jinja 
 
        {{ users|selectattr(&quot;is_active&quot;) }} 
        {{ users|selectattr(&quot;email&quot;, &quot;none&quot;) }} 
 
    Similar to a generator comprehension such as: 
 
    .. code-block:: python 
 
        (u for user in users if user.is_active) 
        (u for user in users if test_none(user.email)) 
 
    .. versionadded:: 2.7 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">select_or_reject(context</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, lambda </span><span class="s1">x: x</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s1">@async_variant(sync_do_selectattr)  </span><span class="s3"># type: ignore</span>
<span class="s2">async def </span><span class="s1">do_selectattr(</span>
    <span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s4">&quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;</span><span class="s2">,</span>
    <span class="s1">*args: t.Any</span><span class="s2">,</span>
    <span class="s1">**kwargs: t.Any</span><span class="s2">,</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.AsyncIterator[V]&quot;</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">async_select_or_reject(context</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, lambda </span><span class="s1">x: x</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s1">@pass_context</span>
<span class="s2">def </span><span class="s1">sync_do_rejectattr(</span>
    <span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">, </span><span class="s1">value: </span><span class="s4">&quot;t.Iterable[V]&quot;</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.Iterator[V]&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Filters a sequence of objects by applying a test to the specified 
    attribute of each object, and rejecting the objects with the test 
    succeeding. 
 
    If no test is specified, the attribute's value will be evaluated as 
    a boolean. 
 
    .. sourcecode:: jinja 
 
        {{ users|rejectattr(&quot;is_active&quot;) }} 
        {{ users|rejectattr(&quot;email&quot;, &quot;none&quot;) }} 
 
    Similar to a generator comprehension such as: 
 
    .. code-block:: python 
 
        (u for user in users if not user.is_active) 
        (u for user in users if not test_none(user.email)) 
 
    .. versionadded:: 2.7 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">select_or_reject(context</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, lambda </span><span class="s1">x: </span><span class="s2">not </span><span class="s1">x</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s1">@async_variant(sync_do_rejectattr)  </span><span class="s3"># type: ignore</span>
<span class="s2">async def </span><span class="s1">do_rejectattr(</span>
    <span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s4">&quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;</span><span class="s2">,</span>
    <span class="s1">*args: t.Any</span><span class="s2">,</span>
    <span class="s1">**kwargs: t.Any</span><span class="s2">,</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.AsyncIterator[V]&quot;</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">async_select_or_reject(context</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, lambda </span><span class="s1">x: </span><span class="s2">not </span><span class="s1">x</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s1">@pass_eval_context</span>
<span class="s2">def </span><span class="s1">do_tojson(</span>
    <span class="s1">eval_ctx: </span><span class="s4">&quot;EvalContext&quot;</span><span class="s2">, </span><span class="s1">value: t.Any</span><span class="s2">, </span><span class="s1">indent: t.Optional[int] = </span><span class="s2">None</span>
<span class="s1">) -&gt; Markup:</span>
    <span class="s0">&quot;&quot;&quot;Serialize an object to a string of JSON, and mark it safe to 
    render in HTML. This filter is only for use in HTML documents. 
 
    The returned string is safe to render in HTML documents and 
    ``&lt;script&gt;`` tags. The exception is in HTML attributes that are 
    double quoted; either use single quotes or the ``|forceescape`` 
    filter. 
 
    :param value: The object to serialize to JSON. 
    :param indent: The ``indent`` parameter passed to ``dumps``, for 
        pretty-printing the value. 
 
    .. versionadded:: 2.9 
    &quot;&quot;&quot;</span>
    <span class="s1">policies = eval_ctx.environment.policies</span>
    <span class="s1">dumps = policies[</span><span class="s4">&quot;json.dumps_function&quot;</span><span class="s1">]</span>
    <span class="s1">kwargs = policies[</span><span class="s4">&quot;json.dumps_kwargs&quot;</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">indent </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">kwargs = kwargs.copy()</span>
        <span class="s1">kwargs[</span><span class="s4">&quot;indent&quot;</span><span class="s1">] = indent</span>

    <span class="s2">return </span><span class="s1">htmlsafe_json_dumps(value</span><span class="s2">, </span><span class="s1">dumps=dumps</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">def </span><span class="s1">prepare_map(</span>
    <span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">, </span><span class="s1">args: t.Tuple</span><span class="s2">, </span><span class="s1">kwargs: t.Dict[str</span><span class="s2">, </span><span class="s1">t.Any]</span>
<span class="s1">) -&gt; t.Callable[[t.Any]</span><span class="s2">, </span><span class="s1">t.Any]:</span>
    <span class="s2">if not </span><span class="s1">args </span><span class="s2">and </span><span class="s4">&quot;attribute&quot; </span><span class="s2">in </span><span class="s1">kwargs:</span>
        <span class="s1">attribute = kwargs.pop(</span><span class="s4">&quot;attribute&quot;</span><span class="s1">)</span>
        <span class="s1">default = kwargs.pop(</span><span class="s4">&quot;default&quot;</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">kwargs:</span>
            <span class="s2">raise </span><span class="s1">FilterArgumentError(</span>
                <span class="s4">f&quot;Unexpected keyword argument </span><span class="s2">{</span><span class="s1">next(iter(kwargs))</span><span class="s2">!r}</span><span class="s4">&quot;</span>
            <span class="s1">)</span>

        <span class="s1">func = make_attrgetter(context.environment</span><span class="s2">, </span><span class="s1">attribute</span><span class="s2">, </span><span class="s1">default=default)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">name = args[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">args = args[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">except </span><span class="s1">LookupError:</span>
            <span class="s2">raise </span><span class="s1">FilterArgumentError(</span><span class="s4">&quot;map requires a filter argument&quot;</span><span class="s1">) </span><span class="s2">from None</span>

        <span class="s2">def </span><span class="s1">func(item: t.Any) -&gt; t.Any:</span>
            <span class="s2">return </span><span class="s1">context.environment.call_filter(</span>
                <span class="s1">name</span><span class="s2">, </span><span class="s1">item</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">context=context</span>
            <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">func</span>


<span class="s2">def </span><span class="s1">prepare_select_or_reject(</span>
    <span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">,</span>
    <span class="s1">args: t.Tuple</span><span class="s2">,</span>
    <span class="s1">kwargs: t.Dict[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">,</span>
    <span class="s1">modfunc: t.Callable[[t.Any]</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">,</span>
    <span class="s1">lookup_attr: bool</span><span class="s2">,</span>
<span class="s1">) -&gt; t.Callable[[t.Any]</span><span class="s2">, </span><span class="s1">t.Any]:</span>
    <span class="s2">if </span><span class="s1">lookup_attr:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">attr = args[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">except </span><span class="s1">LookupError:</span>
            <span class="s2">raise </span><span class="s1">FilterArgumentError(</span><span class="s4">&quot;Missing parameter for attribute name&quot;</span><span class="s1">) </span><span class="s2">from None</span>

        <span class="s1">transfunc = make_attrgetter(context.environment</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s1">off = </span><span class="s5">1</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">off = </span><span class="s5">0</span>

        <span class="s2">def </span><span class="s1">transfunc(x: V) -&gt; V:</span>
            <span class="s2">return </span><span class="s1">x</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">name = args[off]</span>
        <span class="s1">args = args[</span><span class="s5">1 </span><span class="s1">+ off :]</span>

        <span class="s2">def </span><span class="s1">func(item: t.Any) -&gt; t.Any:</span>
            <span class="s2">return </span><span class="s1">context.environment.call_test(name</span><span class="s2">, </span><span class="s1">item</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>

    <span class="s2">except </span><span class="s1">LookupError:</span>
        <span class="s1">func = bool  </span><span class="s3"># type: ignore</span>

    <span class="s2">return lambda </span><span class="s1">item: modfunc(func(transfunc(item)))</span>


<span class="s2">def </span><span class="s1">select_or_reject(</span>
    <span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s4">&quot;t.Iterable[V]&quot;</span><span class="s2">,</span>
    <span class="s1">args: t.Tuple</span><span class="s2">,</span>
    <span class="s1">kwargs: t.Dict[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">,</span>
    <span class="s1">modfunc: t.Callable[[t.Any]</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">,</span>
    <span class="s1">lookup_attr: bool</span><span class="s2">,</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.Iterator[V]&quot;</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">value:</span>
        <span class="s1">func = prepare_select_or_reject(context</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">modfunc</span><span class="s2">, </span><span class="s1">lookup_attr)</span>

        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">value:</span>
            <span class="s2">if </span><span class="s1">func(item):</span>
                <span class="s2">yield </span><span class="s1">item</span>


<span class="s2">async def </span><span class="s1">async_select_or_reject(</span>
    <span class="s1">context: </span><span class="s4">&quot;Context&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s4">&quot;t.Union[t.AsyncIterable[V], t.Iterable[V]]&quot;</span><span class="s2">,</span>
    <span class="s1">args: t.Tuple</span><span class="s2">,</span>
    <span class="s1">kwargs: t.Dict[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">,</span>
    <span class="s1">modfunc: t.Callable[[t.Any]</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">,</span>
    <span class="s1">lookup_attr: bool</span><span class="s2">,</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;t.AsyncIterator[V]&quot;</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">value:</span>
        <span class="s1">func = prepare_select_or_reject(context</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">modfunc</span><span class="s2">, </span><span class="s1">lookup_attr)</span>

        <span class="s2">async for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">auto_aiter(value):</span>
            <span class="s2">if </span><span class="s1">func(item):</span>
                <span class="s2">yield </span><span class="s1">item</span>


<span class="s1">FILTERS = {</span>
    <span class="s4">&quot;abs&quot;</span><span class="s1">: abs</span><span class="s2">,</span>
    <span class="s4">&quot;attr&quot;</span><span class="s1">: do_attr</span><span class="s2">,</span>
    <span class="s4">&quot;batch&quot;</span><span class="s1">: do_batch</span><span class="s2">,</span>
    <span class="s4">&quot;capitalize&quot;</span><span class="s1">: do_capitalize</span><span class="s2">,</span>
    <span class="s4">&quot;center&quot;</span><span class="s1">: do_center</span><span class="s2">,</span>
    <span class="s4">&quot;count&quot;</span><span class="s1">: len</span><span class="s2">,</span>
    <span class="s4">&quot;d&quot;</span><span class="s1">: do_default</span><span class="s2">,</span>
    <span class="s4">&quot;default&quot;</span><span class="s1">: do_default</span><span class="s2">,</span>
    <span class="s4">&quot;dictsort&quot;</span><span class="s1">: do_dictsort</span><span class="s2">,</span>
    <span class="s4">&quot;e&quot;</span><span class="s1">: escape</span><span class="s2">,</span>
    <span class="s4">&quot;escape&quot;</span><span class="s1">: escape</span><span class="s2">,</span>
    <span class="s4">&quot;filesizeformat&quot;</span><span class="s1">: do_filesizeformat</span><span class="s2">,</span>
    <span class="s4">&quot;first&quot;</span><span class="s1">: do_first</span><span class="s2">,</span>
    <span class="s4">&quot;float&quot;</span><span class="s1">: do_float</span><span class="s2">,</span>
    <span class="s4">&quot;forceescape&quot;</span><span class="s1">: do_forceescape</span><span class="s2">,</span>
    <span class="s4">&quot;format&quot;</span><span class="s1">: do_format</span><span class="s2">,</span>
    <span class="s4">&quot;groupby&quot;</span><span class="s1">: do_groupby</span><span class="s2">,</span>
    <span class="s4">&quot;indent&quot;</span><span class="s1">: do_indent</span><span class="s2">,</span>
    <span class="s4">&quot;int&quot;</span><span class="s1">: do_int</span><span class="s2">,</span>
    <span class="s4">&quot;join&quot;</span><span class="s1">: do_join</span><span class="s2">,</span>
    <span class="s4">&quot;last&quot;</span><span class="s1">: do_last</span><span class="s2">,</span>
    <span class="s4">&quot;length&quot;</span><span class="s1">: len</span><span class="s2">,</span>
    <span class="s4">&quot;list&quot;</span><span class="s1">: do_list</span><span class="s2">,</span>
    <span class="s4">&quot;lower&quot;</span><span class="s1">: do_lower</span><span class="s2">,</span>
    <span class="s4">&quot;map&quot;</span><span class="s1">: do_map</span><span class="s2">,</span>
    <span class="s4">&quot;min&quot;</span><span class="s1">: do_min</span><span class="s2">,</span>
    <span class="s4">&quot;max&quot;</span><span class="s1">: do_max</span><span class="s2">,</span>
    <span class="s4">&quot;pprint&quot;</span><span class="s1">: do_pprint</span><span class="s2">,</span>
    <span class="s4">&quot;random&quot;</span><span class="s1">: do_random</span><span class="s2">,</span>
    <span class="s4">&quot;reject&quot;</span><span class="s1">: do_reject</span><span class="s2">,</span>
    <span class="s4">&quot;rejectattr&quot;</span><span class="s1">: do_rejectattr</span><span class="s2">,</span>
    <span class="s4">&quot;replace&quot;</span><span class="s1">: do_replace</span><span class="s2">,</span>
    <span class="s4">&quot;reverse&quot;</span><span class="s1">: do_reverse</span><span class="s2">,</span>
    <span class="s4">&quot;round&quot;</span><span class="s1">: do_round</span><span class="s2">,</span>
    <span class="s4">&quot;safe&quot;</span><span class="s1">: do_mark_safe</span><span class="s2">,</span>
    <span class="s4">&quot;select&quot;</span><span class="s1">: do_select</span><span class="s2">,</span>
    <span class="s4">&quot;selectattr&quot;</span><span class="s1">: do_selectattr</span><span class="s2">,</span>
    <span class="s4">&quot;slice&quot;</span><span class="s1">: do_slice</span><span class="s2">,</span>
    <span class="s4">&quot;sort&quot;</span><span class="s1">: do_sort</span><span class="s2">,</span>
    <span class="s4">&quot;string&quot;</span><span class="s1">: soft_str</span><span class="s2">,</span>
    <span class="s4">&quot;striptags&quot;</span><span class="s1">: do_striptags</span><span class="s2">,</span>
    <span class="s4">&quot;sum&quot;</span><span class="s1">: do_sum</span><span class="s2">,</span>
    <span class="s4">&quot;title&quot;</span><span class="s1">: do_title</span><span class="s2">,</span>
    <span class="s4">&quot;trim&quot;</span><span class="s1">: do_trim</span><span class="s2">,</span>
    <span class="s4">&quot;truncate&quot;</span><span class="s1">: do_truncate</span><span class="s2">,</span>
    <span class="s4">&quot;unique&quot;</span><span class="s1">: do_unique</span><span class="s2">,</span>
    <span class="s4">&quot;upper&quot;</span><span class="s1">: do_upper</span><span class="s2">,</span>
    <span class="s4">&quot;urlencode&quot;</span><span class="s1">: do_urlencode</span><span class="s2">,</span>
    <span class="s4">&quot;urlize&quot;</span><span class="s1">: do_urlize</span><span class="s2">,</span>
    <span class="s4">&quot;wordcount&quot;</span><span class="s1">: do_wordcount</span><span class="s2">,</span>
    <span class="s4">&quot;wordwrap&quot;</span><span class="s1">: do_wordwrap</span><span class="s2">,</span>
    <span class="s4">&quot;xmlattr&quot;</span><span class="s1">: do_xmlattr</span><span class="s2">,</span>
    <span class="s4">&quot;tojson&quot;</span><span class="s1">: do_tojson</span><span class="s2">,</span>
<span class="s1">}</span>
</pre>
</body>
</html>