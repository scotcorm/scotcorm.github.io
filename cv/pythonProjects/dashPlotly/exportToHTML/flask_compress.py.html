<html>
<head>
<title>flask_compress.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #808080;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
flask_compress.py</font>
</center></td></tr></table>
<pre>
<span class="s1"># Authors: William Fagan</span>
<span class="s1"># Copyright (c) 2013-2017 William Fagan</span>
<span class="s1"># License: The MIT License (MIT)</span>

<span class="s2">import </span><span class="s0">sys</span>
<span class="s2">import </span><span class="s0">functools</span>
<span class="s2">from </span><span class="s0">gzip </span><span class="s2">import </span><span class="s0">GzipFile</span>
<span class="s2">import </span><span class="s0">zlib</span>
<span class="s2">from </span><span class="s0">io </span><span class="s2">import </span><span class="s0">BytesIO</span>

<span class="s2">from </span><span class="s0">collections </span><span class="s2">import </span><span class="s0">defaultdict</span>

<span class="s2">import </span><span class="s0">brotli</span>
<span class="s2">from </span><span class="s0">flask </span><span class="s2">import </span><span class="s0">request</span><span class="s2">, </span><span class="s0">after_this_request</span><span class="s2">, </span><span class="s0">current_app</span>


<span class="s2">if </span><span class="s0">sys.version_info[:</span><span class="s3">2</span><span class="s0">] == (</span><span class="s3">2</span><span class="s2">, </span><span class="s3">6</span><span class="s0">):</span>
    <span class="s2">class </span><span class="s0">GzipFile(GzipFile):</span>
        <span class="s4">&quot;&quot;&quot; Backport of context manager support for python 2.6&quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s0">__enter__(self):</span>
            <span class="s2">if </span><span class="s0">self.fileobj </span><span class="s2">is None</span><span class="s0">:</span>
                <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s5">&quot;I/O operation on closed GzipFile object&quot;</span><span class="s0">)</span>
            <span class="s2">return </span><span class="s0">self</span>

        <span class="s2">def </span><span class="s0">__exit__(self</span><span class="s2">, </span><span class="s0">*args):</span>
            <span class="s0">self.close()</span>


<span class="s2">class </span><span class="s0">DictCache(object):</span>

    <span class="s2">def </span><span class="s0">__init__(self):</span>
        <span class="s0">self.data = {}</span>

    <span class="s2">def </span><span class="s0">get(self</span><span class="s2">, </span><span class="s0">key):</span>
        <span class="s2">return </span><span class="s0">self.data.get(key)</span>

    <span class="s2">def </span><span class="s0">set(self</span><span class="s2">, </span><span class="s0">key</span><span class="s2">, </span><span class="s0">value):</span>
        <span class="s0">self.data[key] = value</span>


<span class="s2">class </span><span class="s0">Compress(object):</span>
    <span class="s4">&quot;&quot;&quot; 
    The Compress object allows your application to use Flask-Compress. 
 
    When initialising a Compress object you may optionally provide your 
    :class:`flask.Flask` application object if it is ready. Otherwise, 
    you may provide it later by using the :meth:`init_app` method. 
 
    :param app: optional :class:`flask.Flask` application object 
    :type app: :class:`flask.Flask` or None 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s0">__init__(self</span><span class="s2">, </span><span class="s0">app=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s4">&quot;&quot;&quot; 
        An alternative way to pass your :class:`flask.Flask` application 
        object to Flask-Compress. :meth:`init_app` also takes care of some 
        default `settings`_. 
 
        :param app: the :class:`flask.Flask` application object. 
        &quot;&quot;&quot;</span>
        <span class="s0">self.app = app</span>
        <span class="s2">if </span><span class="s0">app </span><span class="s2">is not None</span><span class="s0">:</span>
            <span class="s0">self.init_app(app)</span>

    <span class="s2">def </span><span class="s0">init_app(self</span><span class="s2">, </span><span class="s0">app):</span>
        <span class="s0">defaults = [</span>
            <span class="s0">(</span><span class="s5">'COMPRESS_MIMETYPES'</span><span class="s2">, </span><span class="s0">[</span><span class="s5">'text/html'</span><span class="s2">, </span><span class="s5">'text/css'</span><span class="s2">, </span><span class="s5">'text/xml'</span><span class="s2">,</span>
                                    <span class="s5">'application/json'</span><span class="s2">,</span>
                                    <span class="s5">'application/javascript'</span><span class="s0">])</span><span class="s2">,</span>
            <span class="s0">(</span><span class="s5">'COMPRESS_LEVEL'</span><span class="s2">, </span><span class="s3">6</span><span class="s0">)</span><span class="s2">,</span>
            <span class="s0">(</span><span class="s5">'COMPRESS_BR_LEVEL'</span><span class="s2">, </span><span class="s3">4</span><span class="s0">)</span><span class="s2">,</span>
            <span class="s0">(</span><span class="s5">'COMPRESS_BR_MODE'</span><span class="s2">, </span><span class="s3">0</span><span class="s0">)</span><span class="s2">,</span>
            <span class="s0">(</span><span class="s5">'COMPRESS_BR_WINDOW'</span><span class="s2">, </span><span class="s3">22</span><span class="s0">)</span><span class="s2">,</span>
            <span class="s0">(</span><span class="s5">'COMPRESS_BR_BLOCK'</span><span class="s2">, </span><span class="s3">0</span><span class="s0">)</span><span class="s2">,</span>
            <span class="s0">(</span><span class="s5">'COMPRESS_DEFLATE_LEVEL'</span><span class="s2">, </span><span class="s0">-</span><span class="s3">1</span><span class="s0">)</span><span class="s2">,</span>
            <span class="s0">(</span><span class="s5">'COMPRESS_MIN_SIZE'</span><span class="s2">, </span><span class="s3">500</span><span class="s0">)</span><span class="s2">,</span>
            <span class="s0">(</span><span class="s5">'COMPRESS_CACHE_KEY'</span><span class="s2">, None</span><span class="s0">)</span><span class="s2">,</span>
            <span class="s0">(</span><span class="s5">'COMPRESS_CACHE_BACKEND'</span><span class="s2">, None</span><span class="s0">)</span><span class="s2">,</span>
            <span class="s0">(</span><span class="s5">'COMPRESS_REGISTER'</span><span class="s2">, True</span><span class="s0">)</span><span class="s2">,</span>
            <span class="s0">(</span><span class="s5">'COMPRESS_ALGORITHM'</span><span class="s2">, </span><span class="s0">[</span><span class="s5">'br'</span><span class="s2">, </span><span class="s5">'gzip'</span><span class="s2">, </span><span class="s5">'deflate'</span><span class="s0">])</span><span class="s2">,</span>
        <span class="s0">]</span>

        <span class="s2">for </span><span class="s0">k</span><span class="s2">, </span><span class="s0">v </span><span class="s2">in </span><span class="s0">defaults:</span>
            <span class="s0">app.config.setdefault(k</span><span class="s2">, </span><span class="s0">v)</span>

        <span class="s0">backend = app.config[</span><span class="s5">'COMPRESS_CACHE_BACKEND'</span><span class="s0">]</span>
        <span class="s0">self.cache = backend() </span><span class="s2">if </span><span class="s0">backend </span><span class="s2">else None</span>
        <span class="s0">self.cache_key = app.config[</span><span class="s5">'COMPRESS_CACHE_KEY'</span><span class="s0">]</span>

        <span class="s0">algo = app.config[</span><span class="s5">'COMPRESS_ALGORITHM'</span><span class="s0">]</span>
        <span class="s2">if </span><span class="s0">isinstance(algo</span><span class="s2">, </span><span class="s0">str):</span>
            <span class="s0">self.enabled_algorithms = [i.strip() </span><span class="s2">for </span><span class="s0">i </span><span class="s2">in </span><span class="s0">algo.split(</span><span class="s5">','</span><span class="s0">)]</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">self.enabled_algorithms = list(algo)</span>

        <span class="s2">if </span><span class="s0">(app.config[</span><span class="s5">'COMPRESS_REGISTER'</span><span class="s0">] </span><span class="s2">and</span>
                <span class="s0">app.config[</span><span class="s5">'COMPRESS_MIMETYPES'</span><span class="s0">]):</span>
            <span class="s0">app.after_request(self.after_request)</span>

    <span class="s2">def </span><span class="s0">_choose_compress_algorithm(self</span><span class="s2">, </span><span class="s0">accept_encoding_header):</span>
        <span class="s4">&quot;&quot;&quot; 
        Determine which compression algorithm we're going to use based on the 
        client request. The `Accept-Encoding` header may list one or more desired 
        algorithms, together with a &quot;quality factor&quot; for each one (higher quality 
        means the client prefers that algorithm more). 
 
        :param accept_encoding_header: Content of the `Accept-Encoding` header 
        :return: name of a compression algorithm (`gzip`, `deflate`, `br`) or `None` if 
            the client and server don't agree on any. 
        &quot;&quot;&quot;</span>
        <span class="s1"># A flag denoting that client requested using any (`*`) algorithm,</span>
        <span class="s1"># in case a specific one is not supported by the server</span>
        <span class="s0">fallback_to_any = </span><span class="s2">False</span>

        <span class="s1"># Map quality factors to requested algorithm names.</span>
        <span class="s0">algos_by_quality = defaultdict(set)</span>

        <span class="s1"># Set of supported algorithms</span>
        <span class="s0">server_algos_set = set(self.enabled_algorithms)</span>

        <span class="s2">for </span><span class="s0">part </span><span class="s2">in </span><span class="s0">accept_encoding_header.lower().split(</span><span class="s5">','</span><span class="s0">):</span>
            <span class="s0">part = part.strip()</span>
            <span class="s2">if </span><span class="s5">';q=' </span><span class="s2">in </span><span class="s0">part:</span>
                <span class="s1"># If the client associated a quality factor with an algorithm,</span>
                <span class="s1"># try to parse it. We could do the matching using a regex, but</span>
                <span class="s1"># the format is so simple that it would be overkill.</span>
                <span class="s0">algo = part.split(</span><span class="s5">';'</span><span class="s0">)[</span><span class="s3">0</span><span class="s0">].strip()</span>
                <span class="s2">try</span><span class="s0">:</span>
                    <span class="s0">quality = float(part.split(</span><span class="s5">'='</span><span class="s0">)[</span><span class="s3">1</span><span class="s0">].strip())</span>
                <span class="s2">except </span><span class="s0">ValueError:</span>
                    <span class="s0">quality = </span><span class="s3">1.0</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s1"># Otherwise, use the default quality</span>
                <span class="s0">algo = part</span>
                <span class="s0">quality = </span><span class="s3">1.0</span>

            <span class="s2">if </span><span class="s0">algo == </span><span class="s5">'*'</span><span class="s0">:</span>
                <span class="s2">if </span><span class="s0">quality &gt; </span><span class="s3">0</span><span class="s0">:</span>
                    <span class="s0">fallback_to_any = </span><span class="s2">True</span>
            <span class="s2">elif </span><span class="s0">algo == </span><span class="s5">'identity'</span><span class="s0">:  </span><span class="s1"># identity means 'no compression asked'</span>
                <span class="s0">algos_by_quality[quality].add(</span><span class="s2">None</span><span class="s0">)</span>
            <span class="s2">elif </span><span class="s0">algo </span><span class="s2">in </span><span class="s0">server_algos_set:</span>
                <span class="s0">algos_by_quality[quality].add(algo)</span>

        <span class="s1"># Choose the algorithm with the highest quality factor that the server supports.</span>
        <span class="s1">#</span>
        <span class="s1"># If there are multiple equally good options, choose the first supported algorithm</span>
        <span class="s1"># from server configuration.</span>
        <span class="s1">#</span>
        <span class="s1"># If the server doesn't support any algorithm that the client requested but</span>
        <span class="s1"># there's a special wildcard algorithm request (`*`), choose the first supported</span>
        <span class="s1"># algorithm.</span>
        <span class="s2">for </span><span class="s0">_</span><span class="s2">, </span><span class="s0">viable_algos </span><span class="s2">in </span><span class="s0">sorted(algos_by_quality.items()</span><span class="s2">, </span><span class="s0">reverse=</span><span class="s2">True</span><span class="s0">):</span>
            <span class="s2">if </span><span class="s0">len(viable_algos) == </span><span class="s3">1</span><span class="s0">:</span>
                <span class="s2">return </span><span class="s0">viable_algos.pop()</span>
            <span class="s2">elif </span><span class="s0">len(viable_algos) &gt; </span><span class="s3">1</span><span class="s0">:</span>
                <span class="s2">for </span><span class="s0">server_algo </span><span class="s2">in </span><span class="s0">self.enabled_algorithms:</span>
                    <span class="s2">if </span><span class="s0">server_algo </span><span class="s2">in </span><span class="s0">viable_algos:</span>
                        <span class="s2">return </span><span class="s0">server_algo</span>

        <span class="s2">if </span><span class="s0">fallback_to_any:</span>
            <span class="s2">return </span><span class="s0">self.enabled_algorithms[</span><span class="s3">0</span><span class="s0">]</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s0">after_request(self</span><span class="s2">, </span><span class="s0">response):</span>
        <span class="s0">app = self.app </span><span class="s2">or </span><span class="s0">current_app</span>

        <span class="s0">accept_encoding = request.headers.get(</span><span class="s5">'Accept-Encoding'</span><span class="s2">, </span><span class="s5">''</span><span class="s0">)</span>
        <span class="s0">chosen_algorithm = self._choose_compress_algorithm(accept_encoding)</span>

        <span class="s2">if </span><span class="s0">(chosen_algorithm </span><span class="s2">is None or</span>
            <span class="s0">response.mimetype </span><span class="s2">not in </span><span class="s0">app.config[</span><span class="s5">&quot;COMPRESS_MIMETYPES&quot;</span><span class="s0">] </span><span class="s2">or</span>
            <span class="s0">response.status_code &lt; </span><span class="s3">200 </span><span class="s2">or</span>
            <span class="s0">response.status_code &gt;= </span><span class="s3">300 </span><span class="s2">or</span>
            <span class="s5">&quot;Content-Encoding&quot; </span><span class="s2">in </span><span class="s0">response.headers </span><span class="s2">or</span>
            <span class="s0">(response.content_length </span><span class="s2">is not None and</span>
             <span class="s0">response.content_length &lt; app.config[</span><span class="s5">&quot;COMPRESS_MIN_SIZE&quot;</span><span class="s0">])):</span>
            <span class="s2">return </span><span class="s0">response</span>

        <span class="s0">response.direct_passthrough = </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s0">self.cache </span><span class="s2">is not None</span><span class="s0">:</span>
            <span class="s0">key = self.cache_key(request)</span>
            <span class="s0">compressed_content = self.cache.get(key)</span>
            <span class="s2">if </span><span class="s0">compressed_content </span><span class="s2">is None</span><span class="s0">:</span>
                <span class="s0">compressed_content = self.compress(app</span><span class="s2">, </span><span class="s0">response</span><span class="s2">, </span><span class="s0">chosen_algorithm)</span>
            <span class="s0">self.cache.set(key</span><span class="s2">, </span><span class="s0">compressed_content)</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">compressed_content = self.compress(app</span><span class="s2">, </span><span class="s0">response</span><span class="s2">, </span><span class="s0">chosen_algorithm)</span>

        <span class="s0">response.set_data(compressed_content)</span>

        <span class="s0">response.headers[</span><span class="s5">'Content-Encoding'</span><span class="s0">] = chosen_algorithm</span>
        <span class="s0">response.headers[</span><span class="s5">'Content-Length'</span><span class="s0">] = response.content_length</span>

        <span class="s1"># &quot;123456789&quot;   =&gt; &quot;123456789:gzip&quot;   - A strong ETag validator</span>
        <span class="s1"># W/&quot;123456789&quot; =&gt; W/&quot;123456789:gzip&quot; - A weak ETag validator</span>
        <span class="s0">etag = response.headers.get(</span><span class="s5">'ETag'</span><span class="s0">)</span>
        <span class="s2">if </span><span class="s0">etag:</span>
            <span class="s0">response.headers[</span><span class="s5">'ETag'</span><span class="s0">] = </span><span class="s5">'{0}:{1}&quot;'</span><span class="s0">.format(etag[:-</span><span class="s3">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">chosen_algorithm)</span>

        <span class="s0">vary = response.headers.get(</span><span class="s5">'Vary'</span><span class="s0">)</span>
        <span class="s2">if not </span><span class="s0">vary:</span>
            <span class="s0">response.headers[</span><span class="s5">'Vary'</span><span class="s0">] = </span><span class="s5">'Accept-Encoding'</span>
        <span class="s2">elif </span><span class="s5">'accept-encoding' </span><span class="s2">not in </span><span class="s0">vary.lower():</span>
            <span class="s0">response.headers[</span><span class="s5">'Vary'</span><span class="s0">] = </span><span class="s5">'{}, Accept-Encoding'</span><span class="s0">.format(vary)</span>

        <span class="s2">return </span><span class="s0">response</span>

    <span class="s2">def </span><span class="s0">compressed(self):</span>
        <span class="s2">def </span><span class="s0">decorator(f):</span>
            <span class="s0">@functools.wraps(f)</span>
            <span class="s2">def </span><span class="s0">decorated_function(*args</span><span class="s2">, </span><span class="s0">**kwargs):</span>
                <span class="s0">@after_this_request</span>
                <span class="s2">def </span><span class="s0">compressor(response):</span>
                    <span class="s2">return </span><span class="s0">self.after_request(response)</span>
                <span class="s2">return </span><span class="s0">f(*args</span><span class="s2">, </span><span class="s0">**kwargs)</span>
            <span class="s2">return </span><span class="s0">decorated_function</span>
        <span class="s2">return </span><span class="s0">decorator</span>

    <span class="s2">def </span><span class="s0">compress(self</span><span class="s2">, </span><span class="s0">app</span><span class="s2">, </span><span class="s0">response</span><span class="s2">, </span><span class="s0">algorithm):</span>
        <span class="s2">if </span><span class="s0">algorithm == </span><span class="s5">'gzip'</span><span class="s0">:</span>
            <span class="s0">gzip_buffer = BytesIO()</span>
            <span class="s2">with </span><span class="s0">GzipFile(mode=</span><span class="s5">'wb'</span><span class="s2">,</span>
                          <span class="s0">compresslevel=app.config[</span><span class="s5">'COMPRESS_LEVEL'</span><span class="s0">]</span><span class="s2">,</span>
                          <span class="s0">fileobj=gzip_buffer) </span><span class="s2">as </span><span class="s0">gzip_file:</span>
                <span class="s0">gzip_file.write(response.get_data())</span>
            <span class="s2">return </span><span class="s0">gzip_buffer.getvalue()</span>
        <span class="s2">elif </span><span class="s0">algorithm == </span><span class="s5">'deflate'</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">zlib.compress(response.get_data()</span><span class="s2">,</span>
                                 <span class="s0">app.config[</span><span class="s5">'COMPRESS_DEFLATE_LEVEL'</span><span class="s0">])</span>
        <span class="s2">elif </span><span class="s0">algorithm == </span><span class="s5">'br'</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">brotli.compress(response.get_data()</span><span class="s2">,</span>
                                   <span class="s0">mode=app.config[</span><span class="s5">'COMPRESS_BR_MODE'</span><span class="s0">]</span><span class="s2">,</span>
                                   <span class="s0">quality=app.config[</span><span class="s5">'COMPRESS_BR_LEVEL'</span><span class="s0">]</span><span class="s2">,</span>
                                   <span class="s0">lgwin=app.config[</span><span class="s5">'COMPRESS_BR_WINDOW'</span><span class="s0">]</span><span class="s2">,</span>
                                   <span class="s0">lgblock=app.config[</span><span class="s5">'COMPRESS_BR_BLOCK'</span><span class="s0">])</span>
</pre>
</body>
</html>