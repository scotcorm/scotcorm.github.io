<html>
<head>
<title>test_eval.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_eval.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">reduce</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">product</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">pandas.errors </span><span class="s0">import </span><span class="s1">PerformanceWarning</span>
<span class="s0">import </span><span class="s1">pandas.util._test_decorators </span><span class="s0">as </span><span class="s1">td</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">is_bool</span><span class="s0">,</span>
    <span class="s1">is_float</span><span class="s0">,</span>
    <span class="s1">is_list_like</span><span class="s0">,</span>
    <span class="s1">is_scalar</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">date_range</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>
<span class="s0">from </span><span class="s1">pandas.core.computation </span><span class="s0">import </span><span class="s1">pytables</span>
<span class="s0">from </span><span class="s1">pandas.core.computation.engines </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ENGINES</span><span class="s0">,</span>
    <span class="s1">NumExprClobberingError</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas.core.computation.expr </span><span class="s0">as </span><span class="s1">expr</span>
<span class="s0">from </span><span class="s1">pandas.core.computation.expr </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">BaseExprVisitor</span><span class="s0">,</span>
    <span class="s1">PandasExprVisitor</span><span class="s0">,</span>
    <span class="s1">PythonExprVisitor</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.computation.expressions </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">NUMEXPR_INSTALLED</span><span class="s0">,</span>
    <span class="s1">USE_NUMEXPR</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.computation.ops </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ARITH_OPS_SYMS</span><span class="s0">,</span>
    <span class="s1">SPECIAL_CASE_ARITH_OPS_SYMS</span><span class="s0">,</span>
    <span class="s1">_binary_math_ops</span><span class="s0">,</span>
    <span class="s1">_binary_ops_dict</span><span class="s0">,</span>
    <span class="s1">_unary_math_ops</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s1">@pytest.fixture(</span>
    <span class="s1">params=(</span>
        <span class="s1">pytest.param(</span>
            <span class="s1">engine</span><span class="s0">,</span>
            <span class="s1">marks=[</span>
                <span class="s1">pytest.mark.skipif(</span>
                    <span class="s1">engine == </span><span class="s2">&quot;numexpr&quot; </span><span class="s0">and not </span><span class="s1">USE_NUMEXPR</span><span class="s0">,</span>
                    <span class="s1">reason=</span><span class="s2">f&quot;numexpr enabled-&gt;</span><span class="s0">{</span><span class="s1">USE_NUMEXPR</span><span class="s0">}</span><span class="s2">, &quot;</span>
                    <span class="s2">f&quot;installed-&gt;</span><span class="s0">{</span><span class="s1">NUMEXPR_INSTALLED</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">,</span>
                <span class="s1">)</span><span class="s0">,</span>
                <span class="s1">td.skip_if_no_ne</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">for </span><span class="s1">engine </span><span class="s0">in </span><span class="s1">ENGINES</span>
    <span class="s1">)</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">engine(request):</span>
    <span class="s0">return </span><span class="s1">request.param</span>


<span class="s1">@pytest.fixture(params=expr.PARSERS)</span>
<span class="s0">def </span><span class="s1">parser(request):</span>
    <span class="s0">return </span><span class="s1">request.param</span>


<span class="s0">def </span><span class="s1">_get_unary_fns_for_ne():</span>
    <span class="s0">return </span><span class="s1">list(_unary_math_ops) </span><span class="s0">if </span><span class="s1">NUMEXPR_INSTALLED </span><span class="s0">else </span><span class="s1">[]</span>


<span class="s1">@pytest.fixture(params=_get_unary_fns_for_ne())</span>
<span class="s0">def </span><span class="s1">unary_fns_for_ne(request):</span>
    <span class="s0">return </span><span class="s1">request.param</span>


<span class="s0">def </span><span class="s1">engine_has_neg_frac(engine):</span>
    <span class="s0">return </span><span class="s1">ENGINES[engine].has_neg_frac</span>


<span class="s0">def </span><span class="s1">_eval_single_bin(lhs</span><span class="s0">, </span><span class="s1">cmp1</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">engine):</span>
    <span class="s1">c = _binary_ops_dict[cmp1]</span>
    <span class="s0">if </span><span class="s1">engine_has_neg_frac(engine):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">c(lhs</span><span class="s0">, </span><span class="s1">rhs)</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s0">if </span><span class="s1">str(e).startswith(</span>
                <span class="s2">&quot;negative number cannot be raised to a fractional power&quot;</span>
            <span class="s1">):</span>
                <span class="s0">return </span><span class="s1">np.nan</span>
            <span class="s0">raise</span>
    <span class="s0">return </span><span class="s1">c(lhs</span><span class="s0">, </span><span class="s1">rhs)</span>


<span class="s0">def </span><span class="s1">_series_and_2d_ndarray(lhs</span><span class="s0">, </span><span class="s1">rhs):</span>
    <span class="s0">return </span><span class="s1">(</span>
        <span class="s1">isinstance(lhs</span><span class="s0">, </span><span class="s1">Series) </span><span class="s0">and </span><span class="s1">isinstance(rhs</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">rhs.ndim &gt; </span><span class="s3">1</span>
    <span class="s1">) </span><span class="s0">or </span><span class="s1">(isinstance(rhs</span><span class="s0">, </span><span class="s1">Series) </span><span class="s0">and </span><span class="s1">isinstance(lhs</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">lhs.ndim &gt; </span><span class="s3">1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_series_and_frame(lhs</span><span class="s0">, </span><span class="s1">rhs):</span>
    <span class="s0">return </span><span class="s1">(isinstance(lhs</span><span class="s0">, </span><span class="s1">Series) </span><span class="s0">and </span><span class="s1">isinstance(rhs</span><span class="s0">, </span><span class="s1">DataFrame)) </span><span class="s0">or </span><span class="s1">(</span>
        <span class="s1">isinstance(rhs</span><span class="s0">, </span><span class="s1">Series) </span><span class="s0">and </span><span class="s1">isinstance(lhs</span><span class="s0">, </span><span class="s1">DataFrame)</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_bool_and_frame(lhs</span><span class="s0">, </span><span class="s1">rhs):</span>
    <span class="s0">return </span><span class="s1">isinstance(lhs</span><span class="s0">, </span><span class="s1">bool) </span><span class="s0">and </span><span class="s1">isinstance(rhs</span><span class="s0">, </span><span class="s1">pd.core.generic.NDFrame)</span>


<span class="s0">def </span><span class="s1">_is_py3_complex_incompat(result</span><span class="s0">, </span><span class="s1">expected):</span>
    <span class="s0">return </span><span class="s1">isinstance(expected</span><span class="s0">, </span><span class="s1">(complex</span><span class="s0">, </span><span class="s1">np.complexfloating)) </span><span class="s0">and </span><span class="s1">np.isnan(result)</span>


<span class="s1">_good_arith_ops = sorted(set(ARITH_OPS_SYMS).difference(SPECIAL_CASE_ARITH_OPS_SYMS))</span>


<span class="s4"># TODO: using range(5) here is a kludge</span>
<span class="s1">@pytest.fixture(</span>
    <span class="s1">params=list(range(</span><span class="s3">5</span><span class="s1">))</span><span class="s0">,</span>
    <span class="s1">ids=[</span><span class="s2">&quot;DataFrame&quot;</span><span class="s0">, </span><span class="s2">&quot;Series&quot;</span><span class="s0">, </span><span class="s2">&quot;SeriesNaN&quot;</span><span class="s0">, </span><span class="s2">&quot;DataFrameNaN&quot;</span><span class="s0">, </span><span class="s2">&quot;float&quot;</span><span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">lhs(request):</span>

    <span class="s1">nan_df1 = DataFrame(np.random.rand(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span>
    <span class="s1">nan_df1[nan_df1 &gt; </span><span class="s3">0.5</span><span class="s1">] = np.nan</span>

    <span class="s1">opts = (</span>
        <span class="s1">DataFrame(np.random.randn(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">Series(np.random.randn(</span><span class="s3">5</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">5</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">nan_df1</span><span class="s0">,</span>
        <span class="s1">np.random.randn()</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">opts[request.param]</span>


<span class="s1">rhs = lhs</span>
<span class="s1">midhs = lhs</span>


<span class="s0">class </span><span class="s1">TestEval:</span>
    <span class="s1">@pytest.fixture(autouse=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">set_engine_parser_attrs(self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">parser):</span>
        <span class="s4"># Older tests look for these as attributes, so we set them here.</span>
        <span class="s1">self.engine = engine</span>
        <span class="s1">self.parser = parser</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">setup_class(cls):</span>
        <span class="s0">import </span><span class="s1">numexpr </span><span class="s0">as </span><span class="s1">ne</span>

        <span class="s1">cls.ne = ne</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">current_engines(self):</span>
        <span class="s0">return </span><span class="s1">(engine </span><span class="s0">for </span><span class="s1">engine </span><span class="s0">in </span><span class="s1">ENGINES </span><span class="s0">if </span><span class="s1">engine != self.engine)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;cmp1&quot;</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">&quot;!=&quot;</span><span class="s0">, </span><span class="s2">&quot;==&quot;</span><span class="s0">, </span><span class="s2">&quot;&lt;=&quot;</span><span class="s0">, </span><span class="s2">&quot;&gt;=&quot;</span><span class="s0">, </span><span class="s2">&quot;&lt;&quot;</span><span class="s0">, </span><span class="s2">&quot;&gt;&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">ids=[</span><span class="s2">&quot;ne&quot;</span><span class="s0">, </span><span class="s2">&quot;eq&quot;</span><span class="s0">, </span><span class="s2">&quot;le&quot;</span><span class="s0">, </span><span class="s2">&quot;ge&quot;</span><span class="s0">, </span><span class="s2">&quot;lt&quot;</span><span class="s0">, </span><span class="s2">&quot;gt&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;cmp2&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;&lt;&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ids=[</span><span class="s2">&quot;gt&quot;</span><span class="s0">, </span><span class="s2">&quot;lt&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;binop&quot;</span><span class="s0">, </span><span class="s1">expr.BOOL_OPS_SYMS)</span>
    <span class="s0">def </span><span class="s1">test_complex_cmp_ops(self</span><span class="s0">, </span><span class="s1">cmp1</span><span class="s0">, </span><span class="s1">cmp2</span><span class="s0">, </span><span class="s1">binop</span><span class="s0">, </span><span class="s1">lhs</span><span class="s0">, </span><span class="s1">rhs):</span>
        <span class="s0">if </span><span class="s1">self.parser == </span><span class="s2">&quot;python&quot; </span><span class="s0">and </span><span class="s1">binop </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;and&quot;</span><span class="s0">, </span><span class="s2">&quot;or&quot;</span><span class="s1">]:</span>
            <span class="s1">msg = </span><span class="s2">&quot;'BoolOp' nodes are not implemented&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">ex = </span><span class="s2">f&quot;(lhs </span><span class="s0">{</span><span class="s1">cmp1</span><span class="s0">} </span><span class="s2">rhs) </span><span class="s0">{</span><span class="s1">binop</span><span class="s0">} </span><span class="s2">(lhs </span><span class="s0">{</span><span class="s1">cmp2</span><span class="s0">} </span><span class="s2">rhs)&quot;</span>
                <span class="s1">result = pd.eval(ex</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s0">return</span>

        <span class="s1">lhs_new = _eval_single_bin(lhs</span><span class="s0">, </span><span class="s1">cmp1</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">self.engine)</span>
        <span class="s1">rhs_new = _eval_single_bin(lhs</span><span class="s0">, </span><span class="s1">cmp2</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">self.engine)</span>
        <span class="s1">expected = _eval_single_bin(lhs_new</span><span class="s0">, </span><span class="s1">binop</span><span class="s0">, </span><span class="s1">rhs_new</span><span class="s0">, </span><span class="s1">self.engine)</span>

        <span class="s1">ex = </span><span class="s2">f&quot;(lhs </span><span class="s0">{</span><span class="s1">cmp1</span><span class="s0">} </span><span class="s2">rhs) </span><span class="s0">{</span><span class="s1">binop</span><span class="s0">} </span><span class="s2">(lhs </span><span class="s0">{</span><span class="s1">cmp2</span><span class="s0">} </span><span class="s2">rhs)&quot;</span>
        <span class="s1">result = pd.eval(ex</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s1">self.check_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;cmp_op&quot;</span><span class="s0">, </span><span class="s1">expr.CMP_OPS_SYMS)</span>
    <span class="s0">def </span><span class="s1">test_simple_cmp_ops(self</span><span class="s0">, </span><span class="s1">cmp_op</span><span class="s0">, </span><span class="s1">lhs</span><span class="s0">, </span><span class="s1">rhs):</span>
        <span class="s1">lhs = lhs &lt; </span><span class="s3">0</span>
        <span class="s1">rhs = rhs &lt; </span><span class="s3">0</span>

        <span class="s0">if </span><span class="s1">self.parser == </span><span class="s2">&quot;python&quot; </span><span class="s0">and </span><span class="s1">cmp_op </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;in&quot;</span><span class="s0">, </span><span class="s2">&quot;not in&quot;</span><span class="s1">]:</span>
            <span class="s1">msg = </span><span class="s2">&quot;'(In|NotIn)' nodes are not implemented&quot;</span>

            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">self.check_simple_cmp_op(lhs</span><span class="s0">, </span><span class="s1">cmp_op</span><span class="s0">, </span><span class="s1">rhs)</span>
            <span class="s0">return</span>

        <span class="s1">self.check_simple_cmp_op(lhs</span><span class="s0">, </span><span class="s1">cmp_op</span><span class="s0">, </span><span class="s1">rhs)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;op&quot;</span><span class="s0">, </span><span class="s1">expr.CMP_OPS_SYMS)</span>
    <span class="s0">def </span><span class="s1">test_compound_invert_op(self</span><span class="s0">, </span><span class="s1">op</span><span class="s0">, </span><span class="s1">lhs</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">request):</span>
        <span class="s0">if </span><span class="s1">self.parser == </span><span class="s2">&quot;python&quot; </span><span class="s0">and </span><span class="s1">op </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;in&quot;</span><span class="s0">, </span><span class="s2">&quot;not in&quot;</span><span class="s1">]:</span>

            <span class="s1">msg = </span><span class="s2">&quot;'(In|NotIn)' nodes are not implemented&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">self.check_compound_invert_op(lhs</span><span class="s0">, </span><span class="s1">op</span><span class="s0">, </span><span class="s1">rhs)</span>
            <span class="s0">return</span>

        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">is_float(lhs)</span>
            <span class="s0">and not </span><span class="s1">is_float(rhs)</span>
            <span class="s0">and </span><span class="s1">op </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;in&quot;</span><span class="s0">, </span><span class="s2">&quot;not in&quot;</span><span class="s1">]</span>
            <span class="s0">and </span><span class="s1">self.engine == </span><span class="s2">&quot;python&quot;</span>
            <span class="s0">and </span><span class="s1">self.parser == </span><span class="s2">&quot;pandas&quot;</span>
        <span class="s1">):</span>
            <span class="s1">mark = pytest.mark.xfail(</span>
                <span class="s1">reason=</span><span class="s2">&quot;Looks like expected is negative, unclear whether &quot;</span>
                <span class="s2">&quot;expected is incorrect or result is incorrect&quot;</span>
            <span class="s1">)</span>
            <span class="s1">request.node.add_marker(mark)</span>

        <span class="s1">self.check_compound_invert_op(lhs</span><span class="s0">, </span><span class="s1">op</span><span class="s0">, </span><span class="s1">rhs)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;cmp1&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;&lt;&quot;</span><span class="s0">, </span><span class="s2">&quot;&gt;&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;cmp2&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;&lt;&quot;</span><span class="s0">, </span><span class="s2">&quot;&gt;&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_chained_cmp_op(self</span><span class="s0">, </span><span class="s1">cmp1</span><span class="s0">, </span><span class="s1">cmp2</span><span class="s0">, </span><span class="s1">lhs</span><span class="s0">, </span><span class="s1">midhs</span><span class="s0">, </span><span class="s1">rhs):</span>
        <span class="s1">self.check_chained_cmp_op(lhs</span><span class="s0">, </span><span class="s1">cmp1</span><span class="s0">, </span><span class="s1">midhs</span><span class="s0">, </span><span class="s1">cmp2</span><span class="s0">, </span><span class="s1">rhs)</span>

    <span class="s0">def </span><span class="s1">check_equal(self</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s0">if </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">DataFrame):</span>
            <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s0">elif </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">Series):</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s0">elif </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
            <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s0">def </span><span class="s1">check_chained_cmp_op(self</span><span class="s0">, </span><span class="s1">lhs</span><span class="s0">, </span><span class="s1">cmp1</span><span class="s0">, </span><span class="s1">mid</span><span class="s0">, </span><span class="s1">cmp2</span><span class="s0">, </span><span class="s1">rhs):</span>

        <span class="s0">if </span><span class="s1">self.parser == </span><span class="s2">&quot;python&quot;</span><span class="s1">:</span>
            <span class="s1">ex1 = </span><span class="s2">f&quot;lhs </span><span class="s0">{</span><span class="s1">cmp1</span><span class="s0">} </span><span class="s2">mid </span><span class="s0">{</span><span class="s1">cmp2</span><span class="s0">} </span><span class="s2">rhs&quot;</span>
            <span class="s1">msg = </span><span class="s2">&quot;'BoolOp' nodes are not implemented&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">pd.eval(ex1</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s0">return</span>

        <span class="s1">lhs_new = _eval_single_bin(lhs</span><span class="s0">, </span><span class="s1">cmp1</span><span class="s0">, </span><span class="s1">mid</span><span class="s0">, </span><span class="s1">self.engine)</span>
        <span class="s1">rhs_new = _eval_single_bin(mid</span><span class="s0">, </span><span class="s1">cmp2</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">self.engine)</span>

        <span class="s0">if </span><span class="s1">lhs_new </span><span class="s0">is not None and </span><span class="s1">rhs_new </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">ex1 = </span><span class="s2">f&quot;lhs </span><span class="s0">{</span><span class="s1">cmp1</span><span class="s0">} </span><span class="s2">mid </span><span class="s0">{</span><span class="s1">cmp2</span><span class="s0">} </span><span class="s2">rhs&quot;</span>
            <span class="s1">ex2 = </span><span class="s2">f&quot;lhs </span><span class="s0">{</span><span class="s1">cmp1</span><span class="s0">} </span><span class="s2">mid and mid </span><span class="s0">{</span><span class="s1">cmp2</span><span class="s0">} </span><span class="s2">rhs&quot;</span>
            <span class="s1">ex3 = </span><span class="s2">f&quot;(lhs </span><span class="s0">{</span><span class="s1">cmp1</span><span class="s0">} </span><span class="s2">mid) &amp; (mid </span><span class="s0">{</span><span class="s1">cmp2</span><span class="s0">} </span><span class="s2">rhs)&quot;</span>
            <span class="s1">expected = _eval_single_bin(lhs_new</span><span class="s0">, </span><span class="s2">&quot;&amp;&quot;</span><span class="s0">, </span><span class="s1">rhs_new</span><span class="s0">, </span><span class="s1">self.engine)</span>

            <span class="s0">for </span><span class="s1">ex </span><span class="s0">in </span><span class="s1">(ex1</span><span class="s0">, </span><span class="s1">ex2</span><span class="s0">, </span><span class="s1">ex3):</span>
                <span class="s1">result = pd.eval(ex</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>

                <span class="s1">tm.assert_almost_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">check_simple_cmp_op(self</span><span class="s0">, </span><span class="s1">lhs</span><span class="s0">, </span><span class="s1">cmp1</span><span class="s0">, </span><span class="s1">rhs):</span>
        <span class="s1">ex = </span><span class="s2">f&quot;lhs </span><span class="s0">{</span><span class="s1">cmp1</span><span class="s0">} </span><span class="s2">rhs&quot;</span>
        <span class="s1">msg = </span><span class="s2">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s2">r&quot;only list-like( or dict-like)? objects are allowed to be &quot;</span>
                <span class="s2">r&quot;passed to (DataFrame\.)?isin\(\), you passed a &quot;</span>
                <span class="s2">r&quot;(\[|')bool(\]|')&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;argument of type 'bool' is not iterable&quot;</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">cmp1 </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;in&quot;</span><span class="s0">, </span><span class="s2">&quot;not in&quot;</span><span class="s1">) </span><span class="s0">and not </span><span class="s1">is_list_like(rhs):</span>
            <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">pd.eval(</span>
                    <span class="s1">ex</span><span class="s0">,</span>
                    <span class="s1">engine=self.engine</span><span class="s0">,</span>
                    <span class="s1">parser=self.parser</span><span class="s0">,</span>
                    <span class="s1">local_dict={</span><span class="s2">&quot;lhs&quot;</span><span class="s1">: lhs</span><span class="s0">, </span><span class="s2">&quot;rhs&quot;</span><span class="s1">: rhs}</span><span class="s0">,</span>
                <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expected = _eval_single_bin(lhs</span><span class="s0">, </span><span class="s1">cmp1</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">self.engine)</span>
            <span class="s1">result = pd.eval(ex</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s1">self.check_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;arith1&quot;</span><span class="s0">, </span><span class="s1">_good_arith_ops)</span>
    <span class="s0">def </span><span class="s1">test_binary_arith_ops(self</span><span class="s0">, </span><span class="s1">arith1</span><span class="s0">, </span><span class="s1">lhs</span><span class="s0">, </span><span class="s1">rhs):</span>
        <span class="s1">ex = </span><span class="s2">f&quot;lhs </span><span class="s0">{</span><span class="s1">arith1</span><span class="s0">} </span><span class="s2">rhs&quot;</span>
        <span class="s1">result = pd.eval(ex</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s1">expected = _eval_single_bin(lhs</span><span class="s0">, </span><span class="s1">arith1</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">self.engine)</span>

        <span class="s1">tm.assert_almost_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s1">ex = </span><span class="s2">f&quot;lhs </span><span class="s0">{</span><span class="s1">arith1</span><span class="s0">} </span><span class="s2">rhs </span><span class="s0">{</span><span class="s1">arith1</span><span class="s0">} </span><span class="s2">rhs&quot;</span>
        <span class="s1">result = pd.eval(ex</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s1">nlhs = _eval_single_bin(lhs</span><span class="s0">, </span><span class="s1">arith1</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">self.engine)</span>
        <span class="s1">self.check_alignment(result</span><span class="s0">, </span><span class="s1">nlhs</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">arith1)</span>

    <span class="s0">def </span><span class="s1">check_alignment(self</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">nlhs</span><span class="s0">, </span><span class="s1">ghs</span><span class="s0">, </span><span class="s1">op):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">nlhs</span><span class="s0">, </span><span class="s1">ghs = nlhs.align(ghs)</span>
        <span class="s0">except </span><span class="s1">(ValueError</span><span class="s0">, </span><span class="s1">TypeError</span><span class="s0">, </span><span class="s1">AttributeError):</span>
            <span class="s4"># ValueError: series frame or frame series align</span>
            <span class="s4"># TypeError, AttributeError: series or frame with scalar align</span>
            <span class="s0">pass</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.engine == </span><span class="s2">&quot;numexpr&quot;</span><span class="s1">:</span>
                <span class="s4"># direct numpy comparison</span>
                <span class="s1">expected = self.ne.evaluate(</span><span class="s2">f&quot;nlhs </span><span class="s0">{</span><span class="s1">op</span><span class="s0">} </span><span class="s2">ghs&quot;</span><span class="s1">)</span>
                <span class="s4"># Update assert statement due to unreliable numerical</span>
                <span class="s4"># precision component (GH37328)</span>
                <span class="s4"># TODO: update testing code so that assert_almost_equal statement</span>
                <span class="s4">#  can be replaced again by the assert_numpy_array_equal statement</span>
                <span class="s1">tm.assert_almost_equal(result.values</span><span class="s0">, </span><span class="s1">expected)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected = eval(</span><span class="s2">f&quot;nlhs </span><span class="s0">{</span><span class="s1">op</span><span class="s0">} </span><span class="s2">ghs&quot;</span><span class="s1">)</span>
                <span class="s1">tm.assert_almost_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s4"># modulus, pow, and floor division require special casing</span>

    <span class="s0">def </span><span class="s1">test_modulus(self</span><span class="s0">, </span><span class="s1">lhs</span><span class="s0">, </span><span class="s1">rhs):</span>
        <span class="s1">ex = </span><span class="s2">r&quot;lhs % rhs&quot;</span>
        <span class="s1">result = pd.eval(ex</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s1">expected = lhs % rhs</span>
        <span class="s1">tm.assert_almost_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s0">if </span><span class="s1">self.engine == </span><span class="s2">&quot;numexpr&quot;</span><span class="s1">:</span>
            <span class="s1">expected = self.ne.evaluate(</span><span class="s2">r&quot;expected % rhs&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">(DataFrame</span><span class="s0">, </span><span class="s1">Series)):</span>
                <span class="s1">tm.assert_almost_equal(result.values</span><span class="s0">, </span><span class="s1">expected)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">tm.assert_almost_equal(result</span><span class="s0">, </span><span class="s1">expected.item())</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expected = _eval_single_bin(expected</span><span class="s0">, </span><span class="s2">&quot;%&quot;</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">self.engine)</span>
            <span class="s1">tm.assert_almost_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_floor_division(self</span><span class="s0">, </span><span class="s1">lhs</span><span class="s0">, </span><span class="s1">rhs):</span>
        <span class="s1">ex = </span><span class="s2">&quot;lhs // rhs&quot;</span>

        <span class="s0">if </span><span class="s1">self.engine == </span><span class="s2">&quot;python&quot;</span><span class="s1">:</span>
            <span class="s1">res = pd.eval(ex</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s1">expected = lhs // rhs</span>
            <span class="s1">self.check_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">msg = (</span>
                <span class="s2">r&quot;unsupported operand type\(s\) for //: 'VariableNode' and &quot;</span>
                <span class="s2">&quot;'VariableNode'&quot;</span>
            <span class="s1">)</span>
            <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">pd.eval(</span>
                    <span class="s1">ex</span><span class="s0">,</span>
                    <span class="s1">local_dict={</span><span class="s2">&quot;lhs&quot;</span><span class="s1">: lhs</span><span class="s0">, </span><span class="s2">&quot;rhs&quot;</span><span class="s1">: rhs}</span><span class="s0">,</span>
                    <span class="s1">engine=self.engine</span><span class="s0">,</span>
                    <span class="s1">parser=self.parser</span><span class="s0">,</span>
                <span class="s1">)</span>

    <span class="s1">@td.skip_if_windows</span>
    <span class="s0">def </span><span class="s1">test_pow(self</span><span class="s0">, </span><span class="s1">lhs</span><span class="s0">, </span><span class="s1">rhs):</span>
        <span class="s4"># odd failure on win32 platform, so skip</span>
        <span class="s1">ex = </span><span class="s2">&quot;lhs ** rhs&quot;</span>
        <span class="s1">expected = _eval_single_bin(lhs</span><span class="s0">, </span><span class="s2">&quot;**&quot;</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">self.engine)</span>
        <span class="s1">result = pd.eval(ex</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>

        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">is_scalar(lhs)</span>
            <span class="s0">and </span><span class="s1">is_scalar(rhs)</span>
            <span class="s0">and </span><span class="s1">_is_py3_complex_incompat(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s1">):</span>
            <span class="s1">msg = </span><span class="s2">&quot;(DataFrame.columns|numpy array) are different&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(AssertionError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">tm.assert_almost_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

            <span class="s1">ex = </span><span class="s2">&quot;(lhs ** rhs) ** rhs&quot;</span>
            <span class="s1">result = pd.eval(ex</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>

            <span class="s1">middle = _eval_single_bin(lhs</span><span class="s0">, </span><span class="s2">&quot;**&quot;</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">self.engine)</span>
            <span class="s1">expected = _eval_single_bin(middle</span><span class="s0">, </span><span class="s2">&quot;**&quot;</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">self.engine)</span>
            <span class="s1">tm.assert_almost_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">check_single_invert_op(self</span><span class="s0">, </span><span class="s1">lhs):</span>
        <span class="s4"># simple</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">elb = lhs.astype(bool)</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s1">elb = np.array([bool(lhs)])</span>
        <span class="s1">expected = ~elb</span>
        <span class="s1">result = pd.eval(</span><span class="s2">&quot;~elb&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s1">tm.assert_almost_equal(expected</span><span class="s0">, </span><span class="s1">result)</span>

        <span class="s0">for </span><span class="s1">engine </span><span class="s0">in </span><span class="s1">self.current_engines:</span>
            <span class="s1">tm.assert_almost_equal(</span>
                <span class="s1">result</span><span class="s0">, </span><span class="s1">pd.eval(</span><span class="s2">&quot;~elb&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">check_compound_invert_op(self</span><span class="s0">, </span><span class="s1">lhs</span><span class="s0">, </span><span class="s1">cmp1</span><span class="s0">, </span><span class="s1">rhs):</span>
        <span class="s1">skip_these = [</span><span class="s2">&quot;in&quot;</span><span class="s0">, </span><span class="s2">&quot;not in&quot;</span><span class="s1">]</span>
        <span class="s1">ex = </span><span class="s2">f&quot;~(lhs </span><span class="s0">{</span><span class="s1">cmp1</span><span class="s0">} </span><span class="s2">rhs)&quot;</span>

        <span class="s1">msg = </span><span class="s2">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s2">r&quot;only list-like( or dict-like)? objects are allowed to be &quot;</span>
                <span class="s2">r&quot;passed to (DataFrame\.)?isin\(\), you passed a &quot;</span>
                <span class="s2">r&quot;(\[|')float(\]|')&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;argument of type 'float' is not iterable&quot;</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">is_scalar(rhs) </span><span class="s0">and </span><span class="s1">cmp1 </span><span class="s0">in </span><span class="s1">skip_these:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">pd.eval(</span>
                    <span class="s1">ex</span><span class="s0">,</span>
                    <span class="s1">engine=self.engine</span><span class="s0">,</span>
                    <span class="s1">parser=self.parser</span><span class="s0">,</span>
                    <span class="s1">local_dict={</span><span class="s2">&quot;lhs&quot;</span><span class="s1">: lhs</span><span class="s0">, </span><span class="s2">&quot;rhs&quot;</span><span class="s1">: rhs}</span><span class="s0">,</span>
                <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># compound</span>
            <span class="s0">if </span><span class="s1">is_scalar(lhs) </span><span class="s0">and </span><span class="s1">is_scalar(rhs):</span>
                <span class="s1">lhs</span><span class="s0">, </span><span class="s1">rhs = map(</span><span class="s0">lambda </span><span class="s1">x: np.array([x])</span><span class="s0">, </span><span class="s1">(lhs</span><span class="s0">, </span><span class="s1">rhs))</span>
            <span class="s1">expected = _eval_single_bin(lhs</span><span class="s0">, </span><span class="s1">cmp1</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">self.engine)</span>
            <span class="s0">if </span><span class="s1">is_scalar(expected):</span>
                <span class="s1">expected = </span><span class="s0">not </span><span class="s1">expected</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected = ~expected</span>
            <span class="s1">result = pd.eval(ex</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s1">tm.assert_almost_equal(expected</span><span class="s0">, </span><span class="s1">result)</span>

            <span class="s4"># make sure the other engines work the same as this one</span>
            <span class="s0">for </span><span class="s1">engine </span><span class="s0">in </span><span class="s1">self.current_engines:</span>
                <span class="s1">ev = pd.eval(ex</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
                <span class="s1">tm.assert_almost_equal(ev</span><span class="s0">, </span><span class="s1">result)</span>

    <span class="s0">def </span><span class="s1">test_frame_invert(self):</span>
        <span class="s1">expr = </span><span class="s2">&quot;~lhs&quot;</span>

        <span class="s4"># ~ ##</span>
        <span class="s4"># frame</span>
        <span class="s4"># float always raises</span>
        <span class="s1">lhs = DataFrame(np.random.randn(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s0">if </span><span class="s1">self.engine == </span><span class="s2">&quot;numexpr&quot;</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">&quot;couldn't find matching opcode for 'invert_dd'&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">&quot;ufunc 'invert' not supported for the input types&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>

        <span class="s4"># int raises on numexpr</span>
        <span class="s1">lhs = DataFrame(np.random.randint(</span><span class="s3">5</span><span class="s0">, </span><span class="s1">size=(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)))</span>
        <span class="s0">if </span><span class="s1">self.engine == </span><span class="s2">&quot;numexpr&quot;</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">&quot;couldn't find matching opcode for 'invert&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expect = ~lhs</span>
            <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s1">tm.assert_frame_equal(expect</span><span class="s0">, </span><span class="s1">result)</span>

        <span class="s4"># bool always works</span>
        <span class="s1">lhs = DataFrame(np.random.rand(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">) &gt; </span><span class="s3">0.5</span><span class="s1">)</span>
        <span class="s1">expect = ~lhs</span>
        <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s1">tm.assert_frame_equal(expect</span><span class="s0">, </span><span class="s1">result)</span>

        <span class="s4"># object raises</span>
        <span class="s1">lhs = DataFrame({</span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: np.random.rand(</span><span class="s3">3</span><span class="s1">) &gt; </span><span class="s3">0.5</span><span class="s1">})</span>
        <span class="s0">if </span><span class="s1">self.engine == </span><span class="s2">&quot;numexpr&quot;</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;unknown type object&quot;</span><span class="s1">):</span>
                <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">&quot;bad operand type for unary ~: 'str'&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>

    <span class="s0">def </span><span class="s1">test_series_invert(self):</span>
        <span class="s4"># ~ ####</span>
        <span class="s1">expr = </span><span class="s2">&quot;~lhs&quot;</span>

        <span class="s4"># series</span>
        <span class="s4"># float raises</span>
        <span class="s1">lhs = Series(np.random.randn(</span><span class="s3">5</span><span class="s1">))</span>
        <span class="s0">if </span><span class="s1">self.engine == </span><span class="s2">&quot;numexpr&quot;</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">&quot;couldn't find matching opcode for 'invert_dd'&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">&quot;ufunc 'invert' not supported for the input types&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>

        <span class="s4"># int raises on numexpr</span>
        <span class="s1">lhs = Series(np.random.randint(</span><span class="s3">5</span><span class="s0">, </span><span class="s1">size=</span><span class="s3">5</span><span class="s1">))</span>
        <span class="s0">if </span><span class="s1">self.engine == </span><span class="s2">&quot;numexpr&quot;</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">&quot;couldn't find matching opcode for 'invert&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expect = ~lhs</span>
            <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s1">tm.assert_series_equal(expect</span><span class="s0">, </span><span class="s1">result)</span>

        <span class="s4"># bool</span>
        <span class="s1">lhs = Series(np.random.rand(</span><span class="s3">5</span><span class="s1">) &gt; </span><span class="s3">0.5</span><span class="s1">)</span>
        <span class="s1">expect = ~lhs</span>
        <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s1">tm.assert_series_equal(expect</span><span class="s0">, </span><span class="s1">result)</span>

        <span class="s4"># float</span>
        <span class="s4"># int</span>
        <span class="s4"># bool</span>

        <span class="s4"># object</span>
        <span class="s1">lhs = Series([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">])</span>
        <span class="s0">if </span><span class="s1">self.engine == </span><span class="s2">&quot;numexpr&quot;</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;unknown type object&quot;</span><span class="s1">):</span>
                <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">&quot;bad operand type for unary ~: 'str'&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>

    <span class="s0">def </span><span class="s1">test_frame_negate(self):</span>
        <span class="s1">expr = </span><span class="s2">&quot;-lhs&quot;</span>

        <span class="s4"># float</span>
        <span class="s1">lhs = DataFrame(np.random.randn(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">expect = -lhs</span>
        <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s1">tm.assert_frame_equal(expect</span><span class="s0">, </span><span class="s1">result)</span>

        <span class="s4"># int</span>
        <span class="s1">lhs = DataFrame(np.random.randint(</span><span class="s3">5</span><span class="s0">, </span><span class="s1">size=(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)))</span>
        <span class="s1">expect = -lhs</span>
        <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s1">tm.assert_frame_equal(expect</span><span class="s0">, </span><span class="s1">result)</span>

        <span class="s4"># bool doesn't work with numexpr but works elsewhere</span>
        <span class="s1">lhs = DataFrame(np.random.rand(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">) &gt; </span><span class="s3">0.5</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self.engine == </span><span class="s2">&quot;numexpr&quot;</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">&quot;couldn't find matching opcode for 'neg_bb'&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expect = -lhs</span>
            <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s1">tm.assert_frame_equal(expect</span><span class="s0">, </span><span class="s1">result)</span>

    <span class="s0">def </span><span class="s1">test_series_negate(self):</span>
        <span class="s1">expr = </span><span class="s2">&quot;-lhs&quot;</span>

        <span class="s4"># float</span>
        <span class="s1">lhs = Series(np.random.randn(</span><span class="s3">5</span><span class="s1">))</span>
        <span class="s1">expect = -lhs</span>
        <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s1">tm.assert_series_equal(expect</span><span class="s0">, </span><span class="s1">result)</span>

        <span class="s4"># int</span>
        <span class="s1">lhs = Series(np.random.randint(</span><span class="s3">5</span><span class="s0">, </span><span class="s1">size=</span><span class="s3">5</span><span class="s1">))</span>
        <span class="s1">expect = -lhs</span>
        <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s1">tm.assert_series_equal(expect</span><span class="s0">, </span><span class="s1">result)</span>

        <span class="s4"># bool doesn't work with numexpr but works elsewhere</span>
        <span class="s1">lhs = Series(np.random.rand(</span><span class="s3">5</span><span class="s1">) &gt; </span><span class="s3">0.5</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self.engine == </span><span class="s2">&quot;numexpr&quot;</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">&quot;couldn't find matching opcode for 'neg_bb'&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expect = -lhs</span>
            <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s1">tm.assert_series_equal(expect</span><span class="s0">, </span><span class="s1">result)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;lhs&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s4"># Float</span>
            <span class="s1">DataFrame(np.random.randn(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s4"># Int</span>
            <span class="s1">DataFrame(np.random.randint(</span><span class="s3">5</span><span class="s0">, </span><span class="s1">size=(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)))</span><span class="s0">,</span>
            <span class="s4"># bool doesn't work with numexpr but works elsewhere</span>
            <span class="s1">DataFrame(np.random.rand(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">) &gt; </span><span class="s3">0.5</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_frame_pos(self</span><span class="s0">, </span><span class="s1">lhs):</span>
        <span class="s1">expr = </span><span class="s2">&quot;+lhs&quot;</span>
        <span class="s1">expect = lhs</span>

        <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s1">tm.assert_frame_equal(expect</span><span class="s0">, </span><span class="s1">result)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;lhs&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s4"># Float</span>
            <span class="s1">Series(np.random.randn(</span><span class="s3">5</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s4"># Int</span>
            <span class="s1">Series(np.random.randint(</span><span class="s3">5</span><span class="s0">, </span><span class="s1">size=</span><span class="s3">5</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s4"># bool doesn't work with numexpr but works elsewhere</span>
            <span class="s1">Series(np.random.rand(</span><span class="s3">5</span><span class="s1">) &gt; </span><span class="s3">0.5</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_series_pos(self</span><span class="s0">, </span><span class="s1">lhs):</span>
        <span class="s1">expr = </span><span class="s2">&quot;+lhs&quot;</span>
        <span class="s1">expect = lhs</span>

        <span class="s1">result = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s1">tm.assert_series_equal(expect</span><span class="s0">, </span><span class="s1">result)</span>

    <span class="s0">def </span><span class="s1">test_scalar_unary(self):</span>
        <span class="s1">msg = </span><span class="s2">&quot;bad operand type for unary ~: 'float'&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">pd.eval(</span><span class="s2">&quot;~1.0&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>

        <span class="s0">assert </span><span class="s1">pd.eval(</span><span class="s2">&quot;-1.0&quot;</span><span class="s0">, </span><span class="s1">parser=self.parser</span><span class="s0">, </span><span class="s1">engine=self.engine) == -</span><span class="s3">1.0</span>
        <span class="s0">assert </span><span class="s1">pd.eval(</span><span class="s2">&quot;+1.0&quot;</span><span class="s0">, </span><span class="s1">parser=self.parser</span><span class="s0">, </span><span class="s1">engine=self.engine) == +</span><span class="s3">1.0</span>
        <span class="s0">assert </span><span class="s1">pd.eval(</span><span class="s2">&quot;~1&quot;</span><span class="s0">, </span><span class="s1">parser=self.parser</span><span class="s0">, </span><span class="s1">engine=self.engine) == ~</span><span class="s3">1</span>
        <span class="s0">assert </span><span class="s1">pd.eval(</span><span class="s2">&quot;-1&quot;</span><span class="s0">, </span><span class="s1">parser=self.parser</span><span class="s0">, </span><span class="s1">engine=self.engine) == -</span><span class="s3">1</span>
        <span class="s0">assert </span><span class="s1">pd.eval(</span><span class="s2">&quot;+1&quot;</span><span class="s0">, </span><span class="s1">parser=self.parser</span><span class="s0">, </span><span class="s1">engine=self.engine) == +</span><span class="s3">1</span>
        <span class="s0">assert </span><span class="s1">pd.eval(</span><span class="s2">&quot;~True&quot;</span><span class="s0">, </span><span class="s1">parser=self.parser</span><span class="s0">, </span><span class="s1">engine=self.engine) == ~</span><span class="s0">True</span>
        <span class="s0">assert </span><span class="s1">pd.eval(</span><span class="s2">&quot;~False&quot;</span><span class="s0">, </span><span class="s1">parser=self.parser</span><span class="s0">, </span><span class="s1">engine=self.engine) == ~</span><span class="s0">False</span>
        <span class="s0">assert </span><span class="s1">pd.eval(</span><span class="s2">&quot;-True&quot;</span><span class="s0">, </span><span class="s1">parser=self.parser</span><span class="s0">, </span><span class="s1">engine=self.engine) == -</span><span class="s0">True</span>
        <span class="s0">assert </span><span class="s1">pd.eval(</span><span class="s2">&quot;-False&quot;</span><span class="s0">, </span><span class="s1">parser=self.parser</span><span class="s0">, </span><span class="s1">engine=self.engine) == -</span><span class="s0">False</span>
        <span class="s0">assert </span><span class="s1">pd.eval(</span><span class="s2">&quot;+True&quot;</span><span class="s0">, </span><span class="s1">parser=self.parser</span><span class="s0">, </span><span class="s1">engine=self.engine) == +</span><span class="s0">True</span>
        <span class="s0">assert </span><span class="s1">pd.eval(</span><span class="s2">&quot;+False&quot;</span><span class="s0">, </span><span class="s1">parser=self.parser</span><span class="s0">, </span><span class="s1">engine=self.engine) == +</span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">test_unary_in_array(self):</span>
        <span class="s4"># GH 11235</span>
        <span class="s1">tm.assert_numpy_array_equal(</span>
            <span class="s1">pd.eval(</span>
                <span class="s2">&quot;[-True, True, ~True, +True,&quot;</span>
                <span class="s2">&quot;-False, False, ~False, +False,&quot;</span>
                <span class="s2">&quot;-37, 37, ~37, +37]&quot;</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">np.array(</span>
                <span class="s1">[</span>
                    <span class="s1">-</span><span class="s0">True,</span>
                    <span class="s0">True,</span>
                    <span class="s1">~</span><span class="s0">True,</span>
                    <span class="s1">+</span><span class="s0">True,</span>
                    <span class="s1">-</span><span class="s0">False,</span>
                    <span class="s0">False,</span>
                    <span class="s1">~</span><span class="s0">False,</span>
                    <span class="s1">+</span><span class="s0">False,</span>
                    <span class="s1">-</span><span class="s3">37</span><span class="s0">,</span>
                    <span class="s3">37</span><span class="s0">,</span>
                    <span class="s1">~</span><span class="s3">37</span><span class="s0">,</span>
                    <span class="s1">+</span><span class="s3">37</span><span class="s0">,</span>
                <span class="s1">]</span><span class="s0">,</span>
                <span class="s1">dtype=np.object_</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[np.float32</span><span class="s0">, </span><span class="s1">np.float64])</span>
    <span class="s0">def </span><span class="s1">test_float_comparison_bin_op(self</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s4"># GH 16363</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: np.array([</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)})</span>
        <span class="s1">res = df.eval(</span><span class="s2">&quot;x &lt; -0.1&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">res.values == np.array([</span><span class="s0">False</span><span class="s1">])</span>

        <span class="s1">res = df.eval(</span><span class="s2">&quot;-5 &gt; x&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">res.values == np.array([</span><span class="s0">False</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_disallow_scalar_bool_ops(self):</span>
        <span class="s1">exprs = </span><span class="s2">&quot;1 or 2&quot;</span><span class="s0">, </span><span class="s2">&quot;1 and 2&quot;</span>
        <span class="s1">exprs += </span><span class="s2">&quot;a and b&quot;</span><span class="s0">, </span><span class="s2">&quot;a or b&quot;</span>
        <span class="s1">exprs += (</span><span class="s2">&quot;1 or 2 and (3 + 2) &gt; 3&quot;</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">exprs += (</span><span class="s2">&quot;2 * x &gt; 2 or 1 and 2&quot;</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">exprs += (</span><span class="s2">&quot;2 * df &gt; 3 and 1 or a&quot;</span><span class="s0">,</span><span class="s1">)</span>

        <span class="s1">x</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b = np.random.randn(</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2  </span><span class="s4"># noqa:F841</span>
        <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))  </span><span class="s4"># noqa:F841</span>

        <span class="s0">for </span><span class="s1">ex </span><span class="s0">in </span><span class="s1">exprs:</span>
            <span class="s1">msg = </span><span class="s2">&quot;cannot evaluate scalar only bool ops|'BoolOp' nodes are not&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">pd.eval(ex</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>

    <span class="s0">def </span><span class="s1">test_identical(self):</span>
        <span class="s4"># see gh-10546</span>
        <span class="s1">x = </span><span class="s3">1</span>
        <span class="s1">result = pd.eval(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s0">assert </span><span class="s1">result == </span><span class="s3">1</span>
        <span class="s0">assert </span><span class="s1">is_scalar(result)</span>

        <span class="s1">x = </span><span class="s3">1.5</span>
        <span class="s1">result = pd.eval(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s0">assert </span><span class="s1">result == </span><span class="s3">1.5</span>
        <span class="s0">assert </span><span class="s1">is_scalar(result)</span>

        <span class="s1">x = </span><span class="s0">False</span>
        <span class="s1">result = pd.eval(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s0">assert not </span><span class="s1">result</span>
        <span class="s0">assert </span><span class="s1">is_bool(result)</span>
        <span class="s0">assert </span><span class="s1">is_scalar(result)</span>

        <span class="s1">x = np.array([</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">result = pd.eval(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s3">1</span><span class="s1">]))</span>
        <span class="s0">assert </span><span class="s1">result.shape == (</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span>

        <span class="s1">x = np.array([</span><span class="s3">1.5</span><span class="s1">])</span>
        <span class="s1">result = pd.eval(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s3">1.5</span><span class="s1">]))</span>
        <span class="s0">assert </span><span class="s1">result.shape == (</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span>

        <span class="s1">x = np.array([</span><span class="s0">False</span><span class="s1">])  </span><span class="s4"># noqa:F841</span>
        <span class="s1">result = pd.eval(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s0">False</span><span class="s1">]))</span>
        <span class="s0">assert </span><span class="s1">result.shape == (</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_line_continuation(self):</span>
        <span class="s4"># GH 11149</span>
        <span class="s1">exp = </span><span class="s2">&quot;&quot;&quot;1 + 2 * </span><span class="s0">\ 
        </span><span class="s2">5 - 1 + 2 &quot;&quot;&quot;</span>
        <span class="s1">result = pd.eval(exp</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s0">assert </span><span class="s1">result == </span><span class="s3">12</span>

    <span class="s0">def </span><span class="s1">test_float_truncation(self):</span>
        <span class="s4"># GH 14241</span>
        <span class="s1">exp = </span><span class="s2">&quot;1000000000.006&quot;</span>
        <span class="s1">result = pd.eval(exp</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s1">expected = np.float64(exp)</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>

        <span class="s1">df = DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: [</span><span class="s3">1000000000.0009</span><span class="s0">, </span><span class="s3">1000000000.0011</span><span class="s0">, </span><span class="s3">1000000000.0015</span><span class="s1">]})</span>
        <span class="s1">cutoff = </span><span class="s3">1000000000.0006</span>
        <span class="s1">result = df.query(</span><span class="s2">f&quot;A &lt; </span><span class="s0">{</span><span class="s1">cutoff</span><span class="s0">:</span><span class="s2">.4f</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">result.empty</span>

        <span class="s1">cutoff = </span><span class="s3">1000000000.0010</span>
        <span class="s1">result = df.query(</span><span class="s2">f&quot;A &gt; </span><span class="s0">{</span><span class="s1">cutoff</span><span class="s0">:</span><span class="s2">.4f</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s1">expected = df.loc[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">:]</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">result)</span>

        <span class="s1">exact = </span><span class="s3">1000000000.0011</span>
        <span class="s1">result = df.query(</span><span class="s2">f&quot;A == </span><span class="s0">{</span><span class="s1">exact</span><span class="s0">:</span><span class="s2">.4f</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s1">expected = df.loc[[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">:]</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">result)</span>

    <span class="s0">def </span><span class="s1">test_disallow_python_keywords(self):</span>
        <span class="s4"># GH 18221</span>
        <span class="s1">df = DataFrame([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s0">, </span><span class="s2">&quot;class&quot;</span><span class="s1">])</span>
        <span class="s1">msg = </span><span class="s2">&quot;Python keyword not valid identifier in numexpr query&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(SyntaxError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">df.query(</span><span class="s2">&quot;class == 0&quot;</span><span class="s1">)</span>

        <span class="s1">df = DataFrame()</span>
        <span class="s1">df.index.name = </span><span class="s2">&quot;lambda&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(SyntaxError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">df.query(</span><span class="s2">&quot;lambda == 0&quot;</span><span class="s1">)</span>


<span class="s1">f = </span><span class="s0">lambda </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs: np.random.randn()</span>


<span class="s4"># -------------------------------------</span>
<span class="s4"># gh-12388: Typecasting rules consistency with python</span>


<span class="s0">class </span><span class="s1">TestTypeCasting:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;op&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;+&quot;</span><span class="s0">, </span><span class="s2">&quot;-&quot;</span><span class="s0">, </span><span class="s2">&quot;*&quot;</span><span class="s0">, </span><span class="s2">&quot;**&quot;</span><span class="s0">, </span><span class="s2">&quot;/&quot;</span><span class="s1">])</span>
    <span class="s4"># maybe someday... numexpr has too many upcasting rules now</span>
    <span class="s4"># chain(*(np.sctypes[x] for x in ['uint', 'int', 'float']))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dt&quot;</span><span class="s0">, </span><span class="s1">[np.float32</span><span class="s0">, </span><span class="s1">np.float64])</span>
    <span class="s0">def </span><span class="s1">test_binop_typecasting(self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">parser</span><span class="s0">, </span><span class="s1">op</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">df = tm.makeCustomDataframe(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s1">data_gen_f=f</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
        <span class="s1">s = </span><span class="s2">f&quot;df </span><span class="s0">{</span><span class="s1">op</span><span class="s0">} </span><span class="s2">3&quot;</span>
        <span class="s1">res = pd.eval(s</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
        <span class="s0">assert </span><span class="s1">df.values.dtype == dt</span>
        <span class="s0">assert </span><span class="s1">res.values.dtype == dt</span>
        <span class="s1">tm.assert_frame_equal(res</span><span class="s0">, </span><span class="s1">eval(s))</span>

        <span class="s1">s = </span><span class="s2">f&quot;3 </span><span class="s0">{</span><span class="s1">op</span><span class="s0">} </span><span class="s2">df&quot;</span>
        <span class="s1">res = pd.eval(s</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
        <span class="s0">assert </span><span class="s1">df.values.dtype == dt</span>
        <span class="s0">assert </span><span class="s1">res.values.dtype == dt</span>
        <span class="s1">tm.assert_frame_equal(res</span><span class="s0">, </span><span class="s1">eval(s))</span>


<span class="s4"># -------------------------------------</span>
<span class="s4"># Basic and complex alignment</span>


<span class="s0">def </span><span class="s1">_is_datetime(x):</span>
    <span class="s0">return </span><span class="s1">issubclass(x.dtype.type</span><span class="s0">, </span><span class="s1">np.datetime64)</span>


<span class="s0">def </span><span class="s1">should_warn(*args):</span>
    <span class="s1">not_mono = </span><span class="s0">not </span><span class="s1">any(map(operator.attrgetter(</span><span class="s2">&quot;is_monotonic&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">args))</span>
    <span class="s1">only_one_dt = reduce(operator.xor</span><span class="s0">, </span><span class="s1">map(_is_datetime</span><span class="s0">, </span><span class="s1">args))</span>
    <span class="s0">return </span><span class="s1">not_mono </span><span class="s0">and </span><span class="s1">only_one_dt</span>


<span class="s0">class </span><span class="s1">TestAlignment:</span>

    <span class="s1">index_types = [</span><span class="s2">&quot;i&quot;</span><span class="s0">, </span><span class="s2">&quot;u&quot;</span><span class="s0">, </span><span class="s2">&quot;dt&quot;</span><span class="s1">]</span>
    <span class="s1">lhs_index_types = index_types + [</span><span class="s2">&quot;s&quot;</span><span class="s1">]  </span><span class="s4"># 'p'</span>

    <span class="s0">def </span><span class="s1">test_align_nested_unary_op(self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">parser):</span>
        <span class="s1">s = </span><span class="s2">&quot;df * ~2&quot;</span>
        <span class="s1">df = tm.makeCustomDataframe(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s1">data_gen_f=f)</span>
        <span class="s1">res = pd.eval(s</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
        <span class="s1">tm.assert_frame_equal(res</span><span class="s0">, </span><span class="s1">df * ~</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;lr_idx_type&quot;</span><span class="s0">, </span><span class="s1">lhs_index_types)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;rr_idx_type&quot;</span><span class="s0">, </span><span class="s1">index_types)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;c_idx_type&quot;</span><span class="s0">, </span><span class="s1">index_types)</span>
    <span class="s0">def </span><span class="s1">test_basic_frame_alignment(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">parser</span><span class="s0">, </span><span class="s1">lr_idx_type</span><span class="s0">, </span><span class="s1">rr_idx_type</span><span class="s0">, </span><span class="s1">c_idx_type</span>
    <span class="s1">):</span>
        <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s1">warnings.simplefilter(</span><span class="s2">&quot;always&quot;</span><span class="s0">, </span><span class="s1">RuntimeWarning)</span>

            <span class="s1">df = tm.makeCustomDataframe(</span>
                <span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s1">data_gen_f=f</span><span class="s0">, </span><span class="s1">r_idx_type=lr_idx_type</span><span class="s0">, </span><span class="s1">c_idx_type=c_idx_type</span>
            <span class="s1">)</span>
            <span class="s1">df2 = tm.makeCustomDataframe(</span>
                <span class="s3">20</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s1">data_gen_f=f</span><span class="s0">, </span><span class="s1">r_idx_type=rr_idx_type</span><span class="s0">, </span><span class="s1">c_idx_type=c_idx_type</span>
            <span class="s1">)</span>
            <span class="s4"># only warns if not monotonic and not sortable</span>
            <span class="s0">if </span><span class="s1">should_warn(df.index</span><span class="s0">, </span><span class="s1">df2.index):</span>
                <span class="s0">with </span><span class="s1">tm.assert_produces_warning(RuntimeWarning):</span>
                    <span class="s1">res = pd.eval(</span><span class="s2">&quot;df + df2&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">res = pd.eval(</span><span class="s2">&quot;df + df2&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
            <span class="s1">tm.assert_frame_equal(res</span><span class="s0">, </span><span class="s1">df + df2)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;r_idx_type&quot;</span><span class="s0">, </span><span class="s1">lhs_index_types)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;c_idx_type&quot;</span><span class="s0">, </span><span class="s1">lhs_index_types)</span>
    <span class="s0">def </span><span class="s1">test_frame_comparison(self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">parser</span><span class="s0">, </span><span class="s1">r_idx_type</span><span class="s0">, </span><span class="s1">c_idx_type):</span>
        <span class="s1">df = tm.makeCustomDataframe(</span>
            <span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s1">data_gen_f=f</span><span class="s0">, </span><span class="s1">r_idx_type=r_idx_type</span><span class="s0">, </span><span class="s1">c_idx_type=c_idx_type</span>
        <span class="s1">)</span>
        <span class="s1">res = pd.eval(</span><span class="s2">&quot;df &lt; 2&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
        <span class="s1">tm.assert_frame_equal(res</span><span class="s0">, </span><span class="s1">df &lt; </span><span class="s3">2</span><span class="s1">)</span>

        <span class="s1">df3 = DataFrame(np.random.randn(*df.shape)</span><span class="s0">, </span><span class="s1">index=df.index</span><span class="s0">, </span><span class="s1">columns=df.columns)</span>
        <span class="s1">res = pd.eval(</span><span class="s2">&quot;df &lt; df3&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
        <span class="s1">tm.assert_frame_equal(res</span><span class="s0">, </span><span class="s1">df &lt; df3)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;r1&quot;</span><span class="s0">, </span><span class="s1">lhs_index_types)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;c1&quot;</span><span class="s0">, </span><span class="s1">index_types)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;r2&quot;</span><span class="s0">, </span><span class="s1">index_types)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;c2&quot;</span><span class="s0">, </span><span class="s1">index_types)</span>
    <span class="s0">def </span><span class="s1">test_medium_complex_frame_alignment(self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">parser</span><span class="s0">, </span><span class="s1">r1</span><span class="s0">, </span><span class="s1">c1</span><span class="s0">, </span><span class="s1">r2</span><span class="s0">, </span><span class="s1">c2):</span>

        <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s1">warnings.simplefilter(</span><span class="s2">&quot;always&quot;</span><span class="s0">, </span><span class="s1">RuntimeWarning)</span>

            <span class="s1">df = tm.makeCustomDataframe(</span>
                <span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">data_gen_f=f</span><span class="s0">, </span><span class="s1">r_idx_type=r1</span><span class="s0">, </span><span class="s1">c_idx_type=c1</span>
            <span class="s1">)</span>
            <span class="s1">df2 = tm.makeCustomDataframe(</span>
                <span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">data_gen_f=f</span><span class="s0">, </span><span class="s1">r_idx_type=r2</span><span class="s0">, </span><span class="s1">c_idx_type=c2</span>
            <span class="s1">)</span>
            <span class="s1">df3 = tm.makeCustomDataframe(</span>
                <span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">data_gen_f=f</span><span class="s0">, </span><span class="s1">r_idx_type=r2</span><span class="s0">, </span><span class="s1">c_idx_type=c2</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">should_warn(df.index</span><span class="s0">, </span><span class="s1">df2.index</span><span class="s0">, </span><span class="s1">df3.index):</span>
                <span class="s0">with </span><span class="s1">tm.assert_produces_warning(RuntimeWarning):</span>
                    <span class="s1">res = pd.eval(</span><span class="s2">&quot;df + df2 + df3&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">res = pd.eval(</span><span class="s2">&quot;df + df2 + df3&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
            <span class="s1">tm.assert_frame_equal(res</span><span class="s0">, </span><span class="s1">df + df2 + df3)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;index_name&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s2">&quot;columns&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;c_idx_type&quot;</span><span class="s0">, </span><span class="s1">index_types)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;r_idx_type&quot;</span><span class="s0">, </span><span class="s1">lhs_index_types)</span>
    <span class="s0">def </span><span class="s1">test_basic_frame_series_alignment(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">parser</span><span class="s0">, </span><span class="s1">index_name</span><span class="s0">, </span><span class="s1">r_idx_type</span><span class="s0">, </span><span class="s1">c_idx_type</span>
    <span class="s1">):</span>
        <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s1">warnings.simplefilter(</span><span class="s2">&quot;always&quot;</span><span class="s0">, </span><span class="s1">RuntimeWarning)</span>
            <span class="s1">df = tm.makeCustomDataframe(</span>
                <span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s1">data_gen_f=f</span><span class="s0">, </span><span class="s1">r_idx_type=r_idx_type</span><span class="s0">, </span><span class="s1">c_idx_type=c_idx_type</span>
            <span class="s1">)</span>
            <span class="s1">index = getattr(df</span><span class="s0">, </span><span class="s1">index_name)</span>
            <span class="s1">s = Series(np.random.randn(</span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index[:</span><span class="s3">5</span><span class="s1">])</span>

            <span class="s0">if </span><span class="s1">should_warn(df.index</span><span class="s0">, </span><span class="s1">s.index):</span>
                <span class="s0">with </span><span class="s1">tm.assert_produces_warning(RuntimeWarning):</span>
                    <span class="s1">res = pd.eval(</span><span class="s2">&quot;df + s&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">res = pd.eval(</span><span class="s2">&quot;df + s&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>

            <span class="s0">if </span><span class="s1">r_idx_type == </span><span class="s2">&quot;dt&quot; </span><span class="s0">or </span><span class="s1">c_idx_type == </span><span class="s2">&quot;dt&quot;</span><span class="s1">:</span>
                <span class="s1">expected = df.add(s) </span><span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;numexpr&quot; </span><span class="s0">else </span><span class="s1">df + s</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected = df + s</span>
            <span class="s1">tm.assert_frame_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;index_name&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s2">&quot;columns&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;r_idx_type, c_idx_type&quot;</span><span class="s0">,</span>
        <span class="s1">list(product([</span><span class="s2">&quot;i&quot;</span><span class="s0">, </span><span class="s2">&quot;u&quot;</span><span class="s0">, </span><span class="s2">&quot;s&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;i&quot;</span><span class="s0">, </span><span class="s2">&quot;u&quot;</span><span class="s0">, </span><span class="s2">&quot;s&quot;</span><span class="s1">])) + [(</span><span class="s2">&quot;dt&quot;</span><span class="s0">, </span><span class="s2">&quot;dt&quot;</span><span class="s1">)]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s2">&quot;ignore::RuntimeWarning&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_basic_series_frame_alignment(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">parser</span><span class="s0">, </span><span class="s1">index_name</span><span class="s0">, </span><span class="s1">r_idx_type</span><span class="s0">, </span><span class="s1">c_idx_type</span>
    <span class="s1">):</span>
        <span class="s1">df = tm.makeCustomDataframe(</span>
            <span class="s3">10</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s1">data_gen_f=f</span><span class="s0">, </span><span class="s1">r_idx_type=r_idx_type</span><span class="s0">, </span><span class="s1">c_idx_type=c_idx_type</span>
        <span class="s1">)</span>
        <span class="s1">index = getattr(df</span><span class="s0">, </span><span class="s1">index_name)</span>
        <span class="s1">s = Series(np.random.randn(</span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index[:</span><span class="s3">5</span><span class="s1">])</span>
        <span class="s0">if </span><span class="s1">should_warn(s.index</span><span class="s0">, </span><span class="s1">df.index):</span>
            <span class="s0">with </span><span class="s1">tm.assert_produces_warning(RuntimeWarning):</span>
                <span class="s1">res = pd.eval(</span><span class="s2">&quot;s + df&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">res = pd.eval(</span><span class="s2">&quot;s + df&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>

        <span class="s0">if </span><span class="s1">r_idx_type == </span><span class="s2">&quot;dt&quot; </span><span class="s0">or </span><span class="s1">c_idx_type == </span><span class="s2">&quot;dt&quot;</span><span class="s1">:</span>
            <span class="s1">expected = df.add(s) </span><span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;numexpr&quot; </span><span class="s0">else </span><span class="s1">s + df</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expected = s + df</span>
        <span class="s1">tm.assert_frame_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;c_idx_type&quot;</span><span class="s0">, </span><span class="s1">index_types)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;r_idx_type&quot;</span><span class="s0">, </span><span class="s1">lhs_index_types)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;index_name&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s2">&quot;columns&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;op&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;+&quot;</span><span class="s0">, </span><span class="s2">&quot;*&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_series_frame_commutativity(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">parser</span><span class="s0">, </span><span class="s1">index_name</span><span class="s0">, </span><span class="s1">op</span><span class="s0">, </span><span class="s1">r_idx_type</span><span class="s0">, </span><span class="s1">c_idx_type</span>
    <span class="s1">):</span>

        <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s1">warnings.simplefilter(</span><span class="s2">&quot;always&quot;</span><span class="s0">, </span><span class="s1">RuntimeWarning)</span>

            <span class="s1">df = tm.makeCustomDataframe(</span>
                <span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s1">data_gen_f=f</span><span class="s0">, </span><span class="s1">r_idx_type=r_idx_type</span><span class="s0">, </span><span class="s1">c_idx_type=c_idx_type</span>
            <span class="s1">)</span>
            <span class="s1">index = getattr(df</span><span class="s0">, </span><span class="s1">index_name)</span>
            <span class="s1">s = Series(np.random.randn(</span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index[:</span><span class="s3">5</span><span class="s1">])</span>

            <span class="s1">lhs = </span><span class="s2">f&quot;s </span><span class="s0">{</span><span class="s1">op</span><span class="s0">} </span><span class="s2">df&quot;</span>
            <span class="s1">rhs = </span><span class="s2">f&quot;df </span><span class="s0">{</span><span class="s1">op</span><span class="s0">} </span><span class="s2">s&quot;</span>
            <span class="s0">if </span><span class="s1">should_warn(df.index</span><span class="s0">, </span><span class="s1">s.index):</span>
                <span class="s0">with </span><span class="s1">tm.assert_produces_warning(RuntimeWarning):</span>
                    <span class="s1">a = pd.eval(lhs</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
                <span class="s0">with </span><span class="s1">tm.assert_produces_warning(RuntimeWarning):</span>
                    <span class="s1">b = pd.eval(rhs</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">a = pd.eval(lhs</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
                <span class="s1">b = pd.eval(rhs</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>

            <span class="s0">if </span><span class="s1">r_idx_type != </span><span class="s2">&quot;dt&quot; </span><span class="s0">and </span><span class="s1">c_idx_type != </span><span class="s2">&quot;dt&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;numexpr&quot;</span><span class="s1">:</span>
                    <span class="s1">tm.assert_frame_equal(a</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;r1&quot;</span><span class="s0">, </span><span class="s1">lhs_index_types)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;c1&quot;</span><span class="s0">, </span><span class="s1">index_types)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;r2&quot;</span><span class="s0">, </span><span class="s1">index_types)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;c2&quot;</span><span class="s0">, </span><span class="s1">index_types)</span>
    <span class="s0">def </span><span class="s1">test_complex_series_frame_alignment(self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">parser</span><span class="s0">, </span><span class="s1">r1</span><span class="s0">, </span><span class="s1">c1</span><span class="s0">, </span><span class="s1">r2</span><span class="s0">, </span><span class="s1">c2):</span>
        <span class="s0">import </span><span class="s1">random</span>

        <span class="s1">n = </span><span class="s3">3</span>
        <span class="s1">m1 = </span><span class="s3">5</span>
        <span class="s1">m2 = </span><span class="s3">2 </span><span class="s1">* m1</span>

        <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s1">warnings.simplefilter(</span><span class="s2">&quot;always&quot;</span><span class="s0">, </span><span class="s1">RuntimeWarning)</span>

            <span class="s1">index_name = random.choice([</span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s2">&quot;columns&quot;</span><span class="s1">])</span>
            <span class="s1">obj_name = random.choice([</span><span class="s2">&quot;df&quot;</span><span class="s0">, </span><span class="s2">&quot;df2&quot;</span><span class="s1">])</span>

            <span class="s1">df = tm.makeCustomDataframe(</span>
                <span class="s1">m1</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">data_gen_f=f</span><span class="s0">, </span><span class="s1">r_idx_type=r1</span><span class="s0">, </span><span class="s1">c_idx_type=c1</span>
            <span class="s1">)</span>
            <span class="s1">df2 = tm.makeCustomDataframe(</span>
                <span class="s1">m2</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">data_gen_f=f</span><span class="s0">, </span><span class="s1">r_idx_type=r2</span><span class="s0">, </span><span class="s1">c_idx_type=c2</span>
            <span class="s1">)</span>
            <span class="s1">index = getattr(locals().get(obj_name)</span><span class="s0">, </span><span class="s1">index_name)</span>
            <span class="s1">ser = Series(np.random.randn(n)</span><span class="s0">, </span><span class="s1">index[:n])</span>

            <span class="s0">if </span><span class="s1">r2 == </span><span class="s2">&quot;dt&quot; </span><span class="s0">or </span><span class="s1">c2 == </span><span class="s2">&quot;dt&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;numexpr&quot;</span><span class="s1">:</span>
                    <span class="s1">expected2 = df2.add(ser)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">expected2 = df2 + ser</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected2 = df2 + ser</span>

            <span class="s0">if </span><span class="s1">r1 == </span><span class="s2">&quot;dt&quot; </span><span class="s0">or </span><span class="s1">c1 == </span><span class="s2">&quot;dt&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;numexpr&quot;</span><span class="s1">:</span>
                    <span class="s1">expected = expected2.add(df)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">expected = expected2 + df</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected = expected2 + df</span>

            <span class="s0">if </span><span class="s1">should_warn(df2.index</span><span class="s0">, </span><span class="s1">ser.index</span><span class="s0">, </span><span class="s1">df.index):</span>
                <span class="s0">with </span><span class="s1">tm.assert_produces_warning(RuntimeWarning):</span>
                    <span class="s1">res = pd.eval(</span><span class="s2">&quot;df2 + ser + df&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">res = pd.eval(</span><span class="s2">&quot;df2 + ser + df&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
            <span class="s0">assert </span><span class="s1">res.shape == expected.shape</span>
            <span class="s1">tm.assert_frame_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_performance_warning_for_poor_alignment(self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">parser):</span>
        <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">1000</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>
        <span class="s1">s = Series(np.random.randn(</span><span class="s3">10000</span><span class="s1">))</span>
        <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;numexpr&quot;</span><span class="s1">:</span>
            <span class="s1">seen = PerformanceWarning</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">seen = </span><span class="s0">False</span>

        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(seen):</span>
            <span class="s1">pd.eval(</span><span class="s2">&quot;df + s&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>

        <span class="s1">s = Series(np.random.randn(</span><span class="s3">1000</span><span class="s1">))</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(</span><span class="s0">False</span><span class="s1">):</span>
            <span class="s1">pd.eval(</span><span class="s2">&quot;df + s&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>

        <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10000</span><span class="s1">))</span>
        <span class="s1">s = Series(np.random.randn(</span><span class="s3">10000</span><span class="s1">))</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(</span><span class="s0">False</span><span class="s1">):</span>
            <span class="s1">pd.eval(</span><span class="s2">&quot;df + s&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>

        <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>
        <span class="s1">s = Series(np.random.randn(</span><span class="s3">10000</span><span class="s1">))</span>

        <span class="s1">is_python_engine = engine == </span><span class="s2">&quot;python&quot;</span>

        <span class="s0">if not </span><span class="s1">is_python_engine:</span>
            <span class="s1">wrn = PerformanceWarning</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">wrn = </span><span class="s0">False</span>

        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(wrn) </span><span class="s0">as </span><span class="s1">w:</span>
            <span class="s1">pd.eval(</span><span class="s2">&quot;df + s&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>

            <span class="s0">if not </span><span class="s1">is_python_engine:</span>
                <span class="s0">assert </span><span class="s1">len(w) == </span><span class="s3">1</span>
                <span class="s1">msg = str(w[</span><span class="s3">0</span><span class="s1">].message)</span>
                <span class="s1">logged = np.log10(s.size - df.shape[</span><span class="s3">1</span><span class="s1">])</span>
                <span class="s1">expected = (</span>
                    <span class="s2">f&quot;Alignment difference on axis 1 is larger &quot;</span>
                    <span class="s2">f&quot;than an order of magnitude on term 'df', &quot;</span>
                    <span class="s2">f&quot;by more than </span><span class="s0">{</span><span class="s1">logged</span><span class="s0">:</span><span class="s2">.4g</span><span class="s0">}</span><span class="s2">; performance may suffer.&quot;</span>
                <span class="s1">)</span>
                <span class="s0">assert </span><span class="s1">msg == expected</span>


<span class="s4"># ------------------------------------</span>
<span class="s4"># Slightly more complex ops</span>


<span class="s0">class </span><span class="s1">TestOperations:</span>
    <span class="s1">@pytest.fixture(autouse=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">set_engine_parser_attrs(self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">parser):</span>
        <span class="s4"># Older tests look for these as attributes, so we set them here.</span>
        <span class="s1">self.engine = engine</span>
        <span class="s1">self.parser = parser</span>

    <span class="s0">def </span><span class="s1">eval(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;engine&quot;</span><span class="s1">] = self.engine</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;parser&quot;</span><span class="s1">] = self.parser</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;level&quot;</span><span class="s1">] = kwargs.pop(</span><span class="s2">&quot;level&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">) + </span><span class="s3">1</span>
        <span class="s0">return </span><span class="s1">pd.eval(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_simple_arith_ops(self):</span>
        <span class="s1">exclude_arith = []</span>
        <span class="s0">if </span><span class="s1">self.parser == </span><span class="s2">&quot;python&quot;</span><span class="s1">:</span>
            <span class="s1">exclude_arith = [</span><span class="s2">&quot;in&quot;</span><span class="s0">, </span><span class="s2">&quot;not in&quot;</span><span class="s1">]</span>

        <span class="s1">arith_ops = [</span>
            <span class="s1">op</span>
            <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">expr.ARITH_OPS_SYMS + expr.CMP_OPS_SYMS</span>
            <span class="s0">if </span><span class="s1">op </span><span class="s0">not in </span><span class="s1">exclude_arith</span>
        <span class="s1">]</span>

        <span class="s1">ops = (op </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">arith_ops </span><span class="s0">if </span><span class="s1">op != </span><span class="s2">&quot;//&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">ops:</span>
            <span class="s1">ex = </span><span class="s2">f&quot;1 </span><span class="s0">{</span><span class="s1">op</span><span class="s0">} </span><span class="s2">1&quot;</span>
            <span class="s1">ex2 = </span><span class="s2">f&quot;x </span><span class="s0">{</span><span class="s1">op</span><span class="s0">} </span><span class="s2">1&quot;</span>
            <span class="s1">ex3 = </span><span class="s2">f&quot;1 </span><span class="s0">{</span><span class="s1">op</span><span class="s0">} </span><span class="s2">(x + 1)&quot;</span>

            <span class="s0">if </span><span class="s1">op </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;in&quot;</span><span class="s0">, </span><span class="s2">&quot;not in&quot;</span><span class="s1">):</span>
                <span class="s1">msg = </span><span class="s2">&quot;argument of type 'int' is not iterable&quot;</span>
                <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                    <span class="s1">pd.eval(ex</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expec = _eval_single_bin(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">op</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">self.engine)</span>
                <span class="s1">x = self.eval(ex</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
                <span class="s0">assert </span><span class="s1">x == expec</span>

                <span class="s1">expec = _eval_single_bin(x</span><span class="s0">, </span><span class="s1">op</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">self.engine)</span>
                <span class="s1">y = self.eval(</span>
                    <span class="s1">ex2</span><span class="s0">, </span><span class="s1">local_dict={</span><span class="s2">&quot;x&quot;</span><span class="s1">: x}</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser</span>
                <span class="s1">)</span>
                <span class="s0">assert </span><span class="s1">y == expec</span>

                <span class="s1">expec = _eval_single_bin(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">op</span><span class="s0">, </span><span class="s1">x + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">self.engine)</span>
                <span class="s1">y = self.eval(</span>
                    <span class="s1">ex3</span><span class="s0">, </span><span class="s1">local_dict={</span><span class="s2">&quot;x&quot;</span><span class="s1">: x}</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser</span>
                <span class="s1">)</span>
                <span class="s0">assert </span><span class="s1">y == expec</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;rhs&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;lhs&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;op&quot;</span><span class="s0">, </span><span class="s1">expr.BOOL_OPS_SYMS)</span>
    <span class="s0">def </span><span class="s1">test_simple_bool_ops(self</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">lhs</span><span class="s0">, </span><span class="s1">op):</span>
        <span class="s1">ex = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">lhs</span><span class="s0">} {</span><span class="s1">op</span><span class="s0">} {</span><span class="s1">rhs</span><span class="s0">}</span><span class="s2">&quot;</span>

        <span class="s0">if </span><span class="s1">self.parser == </span><span class="s2">&quot;python&quot; </span><span class="s0">and </span><span class="s1">op </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;and&quot;</span><span class="s0">, </span><span class="s2">&quot;or&quot;</span><span class="s1">]:</span>
            <span class="s1">msg = </span><span class="s2">&quot;'BoolOp' nodes are not implemented&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">self.eval(ex)</span>
            <span class="s0">return</span>

        <span class="s1">res = self.eval(ex)</span>
        <span class="s1">exp = eval(ex)</span>
        <span class="s0">assert </span><span class="s1">res == exp</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;rhs&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;lhs&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;op&quot;</span><span class="s0">, </span><span class="s1">expr.BOOL_OPS_SYMS)</span>
    <span class="s0">def </span><span class="s1">test_bool_ops_with_constants(self</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">lhs</span><span class="s0">, </span><span class="s1">op):</span>
        <span class="s1">ex = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">lhs</span><span class="s0">} {</span><span class="s1">op</span><span class="s0">} {</span><span class="s1">rhs</span><span class="s0">}</span><span class="s2">&quot;</span>

        <span class="s0">if </span><span class="s1">self.parser == </span><span class="s2">&quot;python&quot; </span><span class="s0">and </span><span class="s1">op </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;and&quot;</span><span class="s0">, </span><span class="s2">&quot;or&quot;</span><span class="s1">]:</span>
            <span class="s1">msg = </span><span class="s2">&quot;'BoolOp' nodes are not implemented&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">self.eval(ex)</span>
            <span class="s0">return</span>

        <span class="s1">res = self.eval(ex)</span>
        <span class="s1">exp = eval(ex)</span>
        <span class="s0">assert </span><span class="s1">res == exp</span>

    <span class="s0">def </span><span class="s1">test_4d_ndarray_fails(self):</span>
        <span class="s1">x = np.random.randn(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span>
        <span class="s1">y = Series(np.random.randn(</span><span class="s3">10</span><span class="s1">))</span>
        <span class="s1">msg = </span><span class="s2">&quot;N-dimensional objects, where N &gt; 2, are not supported with eval&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">self.eval(</span><span class="s2">&quot;x + y&quot;</span><span class="s0">, </span><span class="s1">local_dict={</span><span class="s2">&quot;x&quot;</span><span class="s1">: x</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: y})</span>

    <span class="s0">def </span><span class="s1">test_constant(self):</span>
        <span class="s1">x = self.eval(</span><span class="s2">&quot;1&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">x == </span><span class="s3">1</span>

    <span class="s0">def </span><span class="s1">test_single_variable(self):</span>
        <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">df2 = self.eval(</span><span class="s2">&quot;df&quot;</span><span class="s0">, </span><span class="s1">local_dict={</span><span class="s2">&quot;df&quot;</span><span class="s1">: df})</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">df2)</span>

    <span class="s0">def </span><span class="s1">test_truediv(self):</span>
        <span class="s1">s = np.array([</span><span class="s3">1</span><span class="s1">])  </span><span class="s4"># noqa:F841</span>
        <span class="s1">ex = </span><span class="s2">&quot;s / 1&quot;</span>

        <span class="s4"># FutureWarning: The `truediv` parameter in pd.eval is deprecated and will be</span>
        <span class="s4"># removed in a future version.</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
            <span class="s1">res = self.eval(ex</span><span class="s0">, </span><span class="s1">truediv=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_numpy_array_equal(res</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s3">1.0</span><span class="s1">]))</span>

        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
            <span class="s1">res = self.eval(ex</span><span class="s0">, </span><span class="s1">truediv=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_numpy_array_equal(res</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s3">1.0</span><span class="s1">]))</span>

        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
            <span class="s1">res = self.eval(</span><span class="s2">&quot;1 / 2&quot;</span><span class="s0">, </span><span class="s1">truediv=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expec = </span><span class="s3">0.5</span>
        <span class="s0">assert </span><span class="s1">res == expec</span>

        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
            <span class="s1">res = self.eval(</span><span class="s2">&quot;1 / 2&quot;</span><span class="s0">, </span><span class="s1">truediv=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">expec = </span><span class="s3">0.5</span>
        <span class="s0">assert </span><span class="s1">res == expec</span>

        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
            <span class="s1">res = self.eval(</span><span class="s2">&quot;s / 2&quot;</span><span class="s0">, </span><span class="s1">truediv=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">expec = </span><span class="s3">0.5</span>
        <span class="s0">assert </span><span class="s1">res == expec</span>

        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
            <span class="s1">res = self.eval(</span><span class="s2">&quot;s / 2&quot;</span><span class="s0">, </span><span class="s1">truediv=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expec = </span><span class="s3">0.5</span>
        <span class="s0">assert </span><span class="s1">res == expec</span>

    <span class="s0">def </span><span class="s1">test_failing_subscript_with_name_error(self):</span>
        <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))  </span><span class="s4"># noqa:F841</span>
        <span class="s0">with </span><span class="s1">pytest.raises(NameError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;name 'x' is not defined&quot;</span><span class="s1">):</span>
            <span class="s1">self.eval(</span><span class="s2">&quot;df[x &gt; 2] &gt; 2&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_lhs_expression_subscript(self):</span>
        <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">result = self.eval(</span><span class="s2">&quot;(df + 1)[df &gt; 2]&quot;</span><span class="s0">, </span><span class="s1">local_dict={</span><span class="s2">&quot;df&quot;</span><span class="s1">: df})</span>
        <span class="s1">expected = (df + </span><span class="s3">1</span><span class="s1">)[df &gt; </span><span class="s3">2</span><span class="s1">]</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_attr_expression(self):</span>
        <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">columns=list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">))</span>
        <span class="s1">expr1 = </span><span class="s2">&quot;df.a &lt; df.b&quot;</span>
        <span class="s1">expec1 = df.a &lt; df.b</span>
        <span class="s1">expr2 = </span><span class="s2">&quot;df.a + df.b + df.c&quot;</span>
        <span class="s1">expec2 = df.a + df.b + df.c</span>
        <span class="s1">expr3 = </span><span class="s2">&quot;df.a + df.b + df.c[df.b &lt; 0]&quot;</span>
        <span class="s1">expec3 = df.a + df.b + df.c[df.b &lt; </span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">exprs = expr1</span><span class="s0">, </span><span class="s1">expr2</span><span class="s0">, </span><span class="s1">expr3</span>
        <span class="s1">expecs = expec1</span><span class="s0">, </span><span class="s1">expec2</span><span class="s0">, </span><span class="s1">expec3</span>
        <span class="s0">for </span><span class="s1">e</span><span class="s0">, </span><span class="s1">expec </span><span class="s0">in </span><span class="s1">zip(exprs</span><span class="s0">, </span><span class="s1">expecs):</span>
            <span class="s1">tm.assert_series_equal(expec</span><span class="s0">, </span><span class="s1">self.eval(e</span><span class="s0">, </span><span class="s1">local_dict={</span><span class="s2">&quot;df&quot;</span><span class="s1">: df}))</span>

    <span class="s0">def </span><span class="s1">test_assignment_fails(self):</span>
        <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">columns=list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">))</span>
        <span class="s1">df2 = DataFrame(np.random.randn(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">expr1 = </span><span class="s2">&quot;df = df2&quot;</span>
        <span class="s1">msg = </span><span class="s2">&quot;cannot assign without a target object&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">self.eval(expr1</span><span class="s0">, </span><span class="s1">local_dict={</span><span class="s2">&quot;df&quot;</span><span class="s1">: df</span><span class="s0">, </span><span class="s2">&quot;df2&quot;</span><span class="s1">: df2})</span>

    <span class="s0">def </span><span class="s1">test_assignment_column(self):</span>
        <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">columns=list(</span><span class="s2">&quot;ab&quot;</span><span class="s1">))</span>
        <span class="s1">orig_df = df.copy()</span>

        <span class="s4"># multiple assignees</span>
        <span class="s0">with </span><span class="s1">pytest.raises(SyntaxError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;invalid syntax&quot;</span><span class="s1">):</span>
            <span class="s1">df.eval(</span><span class="s2">&quot;d c = a + b&quot;</span><span class="s1">)</span>

        <span class="s4"># invalid assignees</span>
        <span class="s1">msg = </span><span class="s2">&quot;left hand side of an assignment must be a single name&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(SyntaxError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">df.eval(</span><span class="s2">&quot;d,c = a + b&quot;</span><span class="s1">)</span>

        <span class="s1">msg = </span><span class="s2">&quot;cannot assign to function call&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(SyntaxError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">df.eval(</span><span class="s2">'Timestamp(&quot;20131001&quot;) = a + b'</span><span class="s1">)</span>

        <span class="s4"># single assignment - existing variable</span>
        <span class="s1">expected = orig_df.copy()</span>
        <span class="s1">expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">] + expected[</span><span class="s2">&quot;b&quot;</span><span class="s1">]</span>
        <span class="s1">df = orig_df.copy()</span>
        <span class="s1">df.eval(</span><span class="s2">&quot;a = a + b&quot;</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># single assignment - new variable</span>
        <span class="s1">expected = orig_df.copy()</span>
        <span class="s1">expected[</span><span class="s2">&quot;c&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">] + expected[</span><span class="s2">&quot;b&quot;</span><span class="s1">]</span>
        <span class="s1">df = orig_df.copy()</span>
        <span class="s1">df.eval(</span><span class="s2">&quot;c = a + b&quot;</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># with a local name overlap</span>
        <span class="s0">def </span><span class="s1">f():</span>
            <span class="s1">df = orig_df.copy()</span>
            <span class="s1">a = </span><span class="s3">1  </span><span class="s4"># noqa:F841</span>
            <span class="s1">df.eval(</span><span class="s2">&quot;a = 1 + b&quot;</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">df</span>

        <span class="s1">df = f()</span>
        <span class="s1">expected = orig_df.copy()</span>
        <span class="s1">expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">] = </span><span class="s3">1 </span><span class="s1">+ expected[</span><span class="s2">&quot;b&quot;</span><span class="s1">]</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">df = orig_df.copy()</span>

        <span class="s0">def </span><span class="s1">f():</span>
            <span class="s1">a = </span><span class="s3">1  </span><span class="s4"># noqa:F841</span>
            <span class="s1">old_a = df.a.copy()</span>
            <span class="s1">df.eval(</span><span class="s2">&quot;a = a + b&quot;</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">result = old_a + df.b</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">df.a</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">assert </span><span class="s1">result.name </span><span class="s0">is None</span>

        <span class="s1">f()</span>

        <span class="s4"># multiple assignment</span>
        <span class="s1">df = orig_df.copy()</span>
        <span class="s1">df.eval(</span><span class="s2">&quot;c = a + b&quot;</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">msg = </span><span class="s2">&quot;can only assign a single expression&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(SyntaxError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">df.eval(</span><span class="s2">&quot;c = a = b&quot;</span><span class="s1">)</span>

        <span class="s4"># explicit targets</span>
        <span class="s1">df = orig_df.copy()</span>
        <span class="s1">self.eval(</span><span class="s2">&quot;c = df.a + df.b&quot;</span><span class="s0">, </span><span class="s1">local_dict={</span><span class="s2">&quot;df&quot;</span><span class="s1">: df}</span><span class="s0">, </span><span class="s1">target=df</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected = orig_df.copy()</span>
        <span class="s1">expected[</span><span class="s2">&quot;c&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">] + expected[</span><span class="s2">&quot;b&quot;</span><span class="s1">]</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_column_in(self):</span>
        <span class="s4"># GH 11235</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">11</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [-</span><span class="s3">32</span><span class="s1">]})</span>
        <span class="s1">result = df.eval(</span><span class="s2">&quot;a in [11, -32]&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s0">True</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">assignment_not_inplace(self):</span>
        <span class="s4"># see gh-9297</span>
        <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">columns=list(</span><span class="s2">&quot;ab&quot;</span><span class="s1">))</span>

        <span class="s1">actual = df.eval(</span><span class="s2">&quot;c = a + b&quot;</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">actual </span><span class="s0">is not None</span>

        <span class="s1">expected = df.copy()</span>
        <span class="s1">expected[</span><span class="s2">&quot;c&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">] + expected[</span><span class="s2">&quot;b&quot;</span><span class="s1">]</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_multi_line_expression(self):</span>
        <span class="s4"># GH 11149</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]})</span>
        <span class="s1">expected = df.copy()</span>

        <span class="s1">expected[</span><span class="s2">&quot;c&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">] + expected[</span><span class="s2">&quot;b&quot;</span><span class="s1">]</span>
        <span class="s1">expected[</span><span class="s2">&quot;d&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;c&quot;</span><span class="s1">] + expected[</span><span class="s2">&quot;b&quot;</span><span class="s1">]</span>
        <span class="s1">answer = df.eval(</span>
            <span class="s2">&quot;&quot;&quot; 
        c = a + b 
        d = c + b&quot;&quot;&quot;</span><span class="s0">,</span>
            <span class="s1">inplace=</span><span class="s0">True,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">df)</span>
        <span class="s0">assert </span><span class="s1">answer </span><span class="s0">is None</span>

        <span class="s1">expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">] - </span><span class="s3">1</span>
        <span class="s1">expected[</span><span class="s2">&quot;e&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">] + </span><span class="s3">2</span>
        <span class="s1">answer = df.eval(</span>
            <span class="s2">&quot;&quot;&quot; 
        a = a - 1 
        e = a + 2&quot;&quot;&quot;</span><span class="s0">,</span>
            <span class="s1">inplace=</span><span class="s0">True,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">df)</span>
        <span class="s0">assert </span><span class="s1">answer </span><span class="s0">is None</span>

        <span class="s4"># multi-line not valid if not all assignments</span>
        <span class="s1">msg = </span><span class="s2">&quot;Multi-line expressions are only valid if all expressions contain&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">df.eval(</span>
                <span class="s2">&quot;&quot;&quot; 
            a = b + 2 
            b - 2&quot;&quot;&quot;</span><span class="s0">,</span>
                <span class="s1">inplace=</span><span class="s0">False,</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_multi_line_expression_not_inplace(self):</span>
        <span class="s4"># GH 11149</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]})</span>
        <span class="s1">expected = df.copy()</span>

        <span class="s1">expected[</span><span class="s2">&quot;c&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">] + expected[</span><span class="s2">&quot;b&quot;</span><span class="s1">]</span>
        <span class="s1">expected[</span><span class="s2">&quot;d&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;c&quot;</span><span class="s1">] + expected[</span><span class="s2">&quot;b&quot;</span><span class="s1">]</span>
        <span class="s1">df = df.eval(</span>
            <span class="s2">&quot;&quot;&quot; 
        c = a + b 
        d = c + b&quot;&quot;&quot;</span><span class="s0">,</span>
            <span class="s1">inplace=</span><span class="s0">False,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">df)</span>

        <span class="s1">expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">] - </span><span class="s3">1</span>
        <span class="s1">expected[</span><span class="s2">&quot;e&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">] + </span><span class="s3">2</span>
        <span class="s1">df = df.eval(</span>
            <span class="s2">&quot;&quot;&quot; 
        a = a - 1 
        e = a + 2&quot;&quot;&quot;</span><span class="s0">,</span>
            <span class="s1">inplace=</span><span class="s0">False,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">df)</span>

    <span class="s0">def </span><span class="s1">test_multi_line_expression_local_variable(self):</span>
        <span class="s4"># GH 15342</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]})</span>
        <span class="s1">expected = df.copy()</span>

        <span class="s1">local_var = </span><span class="s3">7</span>
        <span class="s1">expected[</span><span class="s2">&quot;c&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">] * local_var</span>
        <span class="s1">expected[</span><span class="s2">&quot;d&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;c&quot;</span><span class="s1">] + local_var</span>
        <span class="s1">answer = df.eval(</span>
            <span class="s2">&quot;&quot;&quot; 
        c = a * @local_var 
        d = c + @local_var 
        &quot;&quot;&quot;</span><span class="s0">,</span>
            <span class="s1">inplace=</span><span class="s0">True,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">df)</span>
        <span class="s0">assert </span><span class="s1">answer </span><span class="s0">is None</span>

    <span class="s0">def </span><span class="s1">test_multi_line_expression_callable_local_variable(self):</span>
        <span class="s4"># 26426</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]})</span>

        <span class="s0">def </span><span class="s1">local_func(a</span><span class="s0">, </span><span class="s1">b):</span>
            <span class="s0">return </span><span class="s1">b</span>

        <span class="s1">expected = df.copy()</span>
        <span class="s1">expected[</span><span class="s2">&quot;c&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">] * local_func(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">expected[</span><span class="s2">&quot;d&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;c&quot;</span><span class="s1">] + local_func(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">answer = df.eval(</span>
            <span class="s2">&quot;&quot;&quot; 
        c = a * @local_func(1, 7) 
        d = c + @local_func(1, 7) 
        &quot;&quot;&quot;</span><span class="s0">,</span>
            <span class="s1">inplace=</span><span class="s0">True,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">df)</span>
        <span class="s0">assert </span><span class="s1">answer </span><span class="s0">is None</span>

    <span class="s0">def </span><span class="s1">test_multi_line_expression_callable_local_variable_with_kwargs(self):</span>
        <span class="s4"># 26426</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]})</span>

        <span class="s0">def </span><span class="s1">local_func(a</span><span class="s0">, </span><span class="s1">b):</span>
            <span class="s0">return </span><span class="s1">b</span>

        <span class="s1">expected = df.copy()</span>
        <span class="s1">expected[</span><span class="s2">&quot;c&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">] * local_func(b=</span><span class="s3">7</span><span class="s0">, </span><span class="s1">a=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">expected[</span><span class="s2">&quot;d&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;c&quot;</span><span class="s1">] + local_func(b=</span><span class="s3">7</span><span class="s0">, </span><span class="s1">a=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">answer = df.eval(</span>
            <span class="s2">&quot;&quot;&quot; 
        c = a * @local_func(b=7, a=1) 
        d = c + @local_func(b=7, a=1) 
        &quot;&quot;&quot;</span><span class="s0">,</span>
            <span class="s1">inplace=</span><span class="s0">True,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">df)</span>
        <span class="s0">assert </span><span class="s1">answer </span><span class="s0">is None</span>

    <span class="s0">def </span><span class="s1">test_assignment_in_query(self):</span>
        <span class="s4"># GH 8664</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]})</span>
        <span class="s1">df_orig = df.copy()</span>
        <span class="s1">msg = </span><span class="s2">&quot;cannot assign without a target object&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">df.query(</span><span class="s2">&quot;a = 1&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s0">, </span><span class="s1">df_orig)</span>

    <span class="s0">def </span><span class="s1">test_query_inplace(self):</span>
        <span class="s4"># see gh-11149</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]})</span>
        <span class="s1">expected = df.copy()</span>
        <span class="s1">expected = expected[expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">] == </span><span class="s3">2</span><span class="s1">]</span>
        <span class="s1">df.query(</span><span class="s2">&quot;a == 2&quot;</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s0">, </span><span class="s1">df)</span>

        <span class="s1">df = {}</span>
        <span class="s1">expected = {</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s3">3</span><span class="s1">}</span>

        <span class="s1">self.eval(</span><span class="s2">&quot;a = 1 + 2&quot;</span><span class="s0">, </span><span class="s1">target=df</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_dict_equal(df</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;invalid_target&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;cat&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([])</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)])</span>
    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s2">&quot;ignore::FutureWarning&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_cannot_item_assign(self</span><span class="s0">, </span><span class="s1">invalid_target):</span>
        <span class="s1">msg = </span><span class="s2">&quot;Cannot assign expression output to target&quot;</span>
        <span class="s1">expression = </span><span class="s2">&quot;a = 1 + 2&quot;</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">self.eval(expression</span><span class="s0">, </span><span class="s1">target=invalid_target</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">hasattr(invalid_target</span><span class="s0">, </span><span class="s2">&quot;copy&quot;</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">self.eval(expression</span><span class="s0">, </span><span class="s1">target=invalid_target</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;invalid_target&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;cat&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test_cannot_copy_item(self</span><span class="s0">, </span><span class="s1">invalid_target):</span>
        <span class="s1">msg = </span><span class="s2">&quot;Cannot return a copy of the target&quot;</span>
        <span class="s1">expression = </span><span class="s2">&quot;a = 1 + 2&quot;</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">self.eval(expression</span><span class="s0">, </span><span class="s1">target=invalid_target</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;target&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;cat&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([])</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{</span><span class="s3">1</span><span class="s1">: </span><span class="s3">2</span><span class="s1">}])</span>
    <span class="s0">def </span><span class="s1">test_inplace_no_assignment(self</span><span class="s0">, </span><span class="s1">target):</span>
        <span class="s1">expression = </span><span class="s2">&quot;1 + 2&quot;</span>

        <span class="s0">assert </span><span class="s1">self.eval(expression</span><span class="s0">, </span><span class="s1">target=target</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">False</span><span class="s1">) == </span><span class="s3">3</span>

        <span class="s1">msg = </span><span class="s2">&quot;Cannot operate inplace if there is no assignment&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">self.eval(expression</span><span class="s0">, </span><span class="s1">target=target</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_basic_period_index_boolean_expression(self):</span>
        <span class="s1">df = tm.makeCustomDataframe(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">data_gen_f=f</span><span class="s0">, </span><span class="s1">c_idx_type=</span><span class="s2">&quot;p&quot;</span><span class="s0">, </span><span class="s1">r_idx_type=</span><span class="s2">&quot;i&quot;</span><span class="s1">)</span>

        <span class="s1">e = df &lt; </span><span class="s3">2</span>
        <span class="s1">r = self.eval(</span><span class="s2">&quot;df &lt; 2&quot;</span><span class="s0">, </span><span class="s1">local_dict={</span><span class="s2">&quot;df&quot;</span><span class="s1">: df})</span>
        <span class="s1">x = df &lt; </span><span class="s3">2</span>

        <span class="s1">tm.assert_frame_equal(r</span><span class="s0">, </span><span class="s1">e)</span>
        <span class="s1">tm.assert_frame_equal(x</span><span class="s0">, </span><span class="s1">e)</span>

    <span class="s0">def </span><span class="s1">test_basic_period_index_subscript_expression(self):</span>
        <span class="s1">df = tm.makeCustomDataframe(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">data_gen_f=f</span><span class="s0">, </span><span class="s1">c_idx_type=</span><span class="s2">&quot;p&quot;</span><span class="s0">, </span><span class="s1">r_idx_type=</span><span class="s2">&quot;i&quot;</span><span class="s1">)</span>
        <span class="s1">r = self.eval(</span><span class="s2">&quot;df[df &lt; 2 + 3]&quot;</span><span class="s0">, </span><span class="s1">local_dict={</span><span class="s2">&quot;df&quot;</span><span class="s1">: df})</span>
        <span class="s1">e = df[df &lt; </span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">3</span><span class="s1">]</span>
        <span class="s1">tm.assert_frame_equal(r</span><span class="s0">, </span><span class="s1">e)</span>

    <span class="s0">def </span><span class="s1">test_nested_period_index_subscript_expression(self):</span>
        <span class="s1">df = tm.makeCustomDataframe(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">data_gen_f=f</span><span class="s0">, </span><span class="s1">c_idx_type=</span><span class="s2">&quot;p&quot;</span><span class="s0">, </span><span class="s1">r_idx_type=</span><span class="s2">&quot;i&quot;</span><span class="s1">)</span>
        <span class="s1">r = self.eval(</span><span class="s2">&quot;df[df[df &lt; 2] &lt; 2] + df * 2&quot;</span><span class="s0">, </span><span class="s1">local_dict={</span><span class="s2">&quot;df&quot;</span><span class="s1">: df})</span>
        <span class="s1">e = df[df[df &lt; </span><span class="s3">2</span><span class="s1">] &lt; </span><span class="s3">2</span><span class="s1">] + df * </span><span class="s3">2</span>
        <span class="s1">tm.assert_frame_equal(r</span><span class="s0">, </span><span class="s1">e)</span>

    <span class="s0">def </span><span class="s1">test_date_boolean(self):</span>
        <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">df[</span><span class="s2">&quot;dates1&quot;</span><span class="s1">] = date_range(</span><span class="s2">&quot;1/1/2012&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">res = self.eval(</span>
            <span class="s2">&quot;df.dates1 &lt; 20130101&quot;</span><span class="s0">,</span>
            <span class="s1">local_dict={</span><span class="s2">&quot;df&quot;</span><span class="s1">: df}</span><span class="s0">,</span>
            <span class="s1">engine=self.engine</span><span class="s0">,</span>
            <span class="s1">parser=self.parser</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">expec = df.dates1 &lt; </span><span class="s2">&quot;20130101&quot;</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">expec</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_simple_in_ops(self):</span>
        <span class="s0">if </span><span class="s1">self.parser != </span><span class="s2">&quot;python&quot;</span><span class="s1">:</span>
            <span class="s1">res = pd.eval(</span><span class="s2">&quot;1 in [1, 2]&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s0">assert </span><span class="s1">res</span>

            <span class="s1">res = pd.eval(</span><span class="s2">&quot;2 in (1, 2)&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s0">assert </span><span class="s1">res</span>

            <span class="s1">res = pd.eval(</span><span class="s2">&quot;3 in (1, 2)&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s0">assert not </span><span class="s1">res</span>

            <span class="s1">res = pd.eval(</span><span class="s2">&quot;3 not in (1, 2)&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s0">assert </span><span class="s1">res</span>

            <span class="s1">res = pd.eval(</span><span class="s2">&quot;[3] not in (1, 2)&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s0">assert </span><span class="s1">res</span>

            <span class="s1">res = pd.eval(</span><span class="s2">&quot;[3] in ([3], 2)&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s0">assert </span><span class="s1">res</span>

            <span class="s1">res = pd.eval(</span><span class="s2">&quot;[[3]] in [[[3]], 2]&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s0">assert </span><span class="s1">res</span>

            <span class="s1">res = pd.eval(</span><span class="s2">&quot;(3,) in [(3,), 2]&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s0">assert </span><span class="s1">res</span>

            <span class="s1">res = pd.eval(</span>
                <span class="s2">&quot;(3,) not in [(3,), 2]&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser</span>
            <span class="s1">)</span>
            <span class="s0">assert not </span><span class="s1">res</span>

            <span class="s1">res = pd.eval(</span>
                <span class="s2">&quot;[(3,)] in [[(3,)], 2]&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser</span>
            <span class="s1">)</span>
            <span class="s0">assert </span><span class="s1">res</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">&quot;'In' nodes are not implemented&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">pd.eval(</span><span class="s2">&quot;1 in [1, 2]&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">pd.eval(</span><span class="s2">&quot;2 in (1, 2)&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">pd.eval(</span><span class="s2">&quot;3 in (1, 2)&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">pd.eval(</span>
                    <span class="s2">&quot;[(3,)] in (1, 2, [(3,)])&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser</span>
                <span class="s1">)</span>
            <span class="s1">msg = </span><span class="s2">&quot;'NotIn' nodes are not implemented&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">pd.eval(</span><span class="s2">&quot;3 not in (1, 2)&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">pd.eval(</span>
                    <span class="s2">&quot;[3] not in (1, 2, [[3]])&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser</span>
                <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_check_many_exprs(self):</span>
        <span class="s1">a = </span><span class="s3">1  </span><span class="s4"># noqa:F841</span>
        <span class="s1">expr = </span><span class="s2">&quot; * &quot;</span><span class="s1">.join(</span><span class="s2">&quot;a&quot; </span><span class="s1">* </span><span class="s3">33</span><span class="s1">)</span>
        <span class="s1">expected = </span><span class="s3">1</span>
        <span class="s1">res = pd.eval(expr</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>
        <span class="s0">assert </span><span class="s1">res == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;expr&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s2">&quot;df &gt; 2 and df &gt; 3&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;df &gt; 2 or df &gt; 3&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;not df &gt; 2&quot;</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_fails_and_or_not(self</span><span class="s0">, </span><span class="s1">expr):</span>
        <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s0">if </span><span class="s1">self.parser == </span><span class="s2">&quot;python&quot;</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">&quot;'BoolOp' nodes are not implemented&quot;</span>
            <span class="s0">if </span><span class="s2">&quot;not&quot; </span><span class="s0">in </span><span class="s1">expr:</span>
                <span class="s1">msg = </span><span class="s2">&quot;'Not' nodes are not implemented&quot;</span>

            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">pd.eval(</span>
                    <span class="s1">expr</span><span class="s0">,</span>
                    <span class="s1">local_dict={</span><span class="s2">&quot;df&quot;</span><span class="s1">: df}</span><span class="s0">,</span>
                    <span class="s1">parser=self.parser</span><span class="s0">,</span>
                    <span class="s1">engine=self.engine</span><span class="s0">,</span>
                <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># smoke-test, should not raise</span>
            <span class="s1">pd.eval(</span>
                <span class="s1">expr</span><span class="s0">,</span>
                <span class="s1">local_dict={</span><span class="s2">&quot;df&quot;</span><span class="s1">: df}</span><span class="s0">,</span>
                <span class="s1">parser=self.parser</span><span class="s0">,</span>
                <span class="s1">engine=self.engine</span><span class="s0">,</span>
            <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;char&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;|&quot;</span><span class="s0">, </span><span class="s2">&quot;&amp;&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_fails_ampersand_pipe(self</span><span class="s0">, </span><span class="s1">char):</span>
        <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))  </span><span class="s4"># noqa:F841</span>
        <span class="s1">ex = </span><span class="s2">f&quot;(df + 2)[df &gt; 1] &gt; 0 </span><span class="s0">{</span><span class="s1">char</span><span class="s0">} </span><span class="s2">(df &gt; 0)&quot;</span>
        <span class="s0">if </span><span class="s1">self.parser == </span><span class="s2">&quot;python&quot;</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">&quot;cannot evaluate scalar only bool ops&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">pd.eval(ex</span><span class="s0">, </span><span class="s1">parser=self.parser</span><span class="s0">, </span><span class="s1">engine=self.engine)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># smoke-test, should not raise</span>
            <span class="s1">pd.eval(ex</span><span class="s0">, </span><span class="s1">parser=self.parser</span><span class="s0">, </span><span class="s1">engine=self.engine)</span>


<span class="s0">class </span><span class="s1">TestMath:</span>
    <span class="s1">@pytest.fixture(autouse=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">set_engine_parser_attrs(self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">parser):</span>
        <span class="s4"># Older tests look for these as attributes, so we set them here.</span>
        <span class="s1">self.engine = engine</span>
        <span class="s1">self.parser = parser</span>

    <span class="s0">def </span><span class="s1">eval(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;engine&quot;</span><span class="s1">] = self.engine</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;parser&quot;</span><span class="s1">] = self.parser</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;level&quot;</span><span class="s1">] = kwargs.pop(</span><span class="s2">&quot;level&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">) + </span><span class="s3">1</span>
        <span class="s0">return </span><span class="s1">pd.eval(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_unary_functions(self</span><span class="s0">, </span><span class="s1">unary_fns_for_ne):</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: np.random.randn(</span><span class="s3">10</span><span class="s1">)})</span>
        <span class="s1">a = df.a</span>

        <span class="s1">fn = unary_fns_for_ne</span>

        <span class="s1">expr = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">fn</span><span class="s0">}</span><span class="s2">(a)&quot;</span>
        <span class="s1">got = self.eval(expr)</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">expect = getattr(np</span><span class="s0">, </span><span class="s1">fn)(a)</span>
        <span class="s1">tm.assert_series_equal(got</span><span class="s0">, </span><span class="s1">expect</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;fn&quot;</span><span class="s0">, </span><span class="s1">_binary_math_ops)</span>
    <span class="s0">def </span><span class="s1">test_binary_functions(self</span><span class="s0">, </span><span class="s1">fn):</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: np.random.randn(</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: np.random.randn(</span><span class="s3">10</span><span class="s1">)})</span>
        <span class="s1">a = df.a</span>
        <span class="s1">b = df.b</span>

        <span class="s1">expr = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">fn</span><span class="s0">}</span><span class="s2">(a, b)&quot;</span>
        <span class="s1">got = self.eval(expr)</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">expect = getattr(np</span><span class="s0">, </span><span class="s1">fn)(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">tm.assert_almost_equal(got</span><span class="s0">, </span><span class="s1">expect</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_df_use_case(self):</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: np.random.randn(</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: np.random.randn(</span><span class="s3">10</span><span class="s1">)})</span>
        <span class="s1">df.eval(</span>
            <span class="s2">&quot;e = arctan2(sin(a), b)&quot;</span><span class="s0">,</span>
            <span class="s1">engine=self.engine</span><span class="s0">,</span>
            <span class="s1">parser=self.parser</span><span class="s0">,</span>
            <span class="s1">inplace=</span><span class="s0">True,</span>
        <span class="s1">)</span>
        <span class="s1">got = df.e</span>
        <span class="s1">expect = np.arctan2(np.sin(df.a)</span><span class="s0">, </span><span class="s1">df.b)</span>
        <span class="s1">tm.assert_series_equal(got</span><span class="s0">, </span><span class="s1">expect</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_df_arithmetic_subexpression(self):</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: np.random.randn(</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: np.random.randn(</span><span class="s3">10</span><span class="s1">)})</span>
        <span class="s1">df.eval(</span><span class="s2">&quot;e = sin(a + b)&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">got = df.e</span>
        <span class="s1">expect = np.sin(df.a + df.b)</span>
        <span class="s1">tm.assert_series_equal(got</span><span class="s0">, </span><span class="s1">expect</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">check_result_type(self</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">expect_dtype):</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: np.random.randn(</span><span class="s3">10</span><span class="s1">).astype(dtype)})</span>
        <span class="s0">assert </span><span class="s1">df.a.dtype == dtype</span>
        <span class="s1">df.eval(</span><span class="s2">&quot;b = sin(a)&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser</span><span class="s0">, </span><span class="s1">inplace=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">got = df.b</span>
        <span class="s1">expect = np.sin(df.a)</span>
        <span class="s0">assert </span><span class="s1">expect.dtype == got.dtype</span>
        <span class="s0">assert </span><span class="s1">expect_dtype == got.dtype</span>
        <span class="s1">tm.assert_series_equal(got</span><span class="s0">, </span><span class="s1">expect</span><span class="s0">, </span><span class="s1">check_names=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_result_types(self):</span>
        <span class="s1">self.check_result_type(np.int32</span><span class="s0">, </span><span class="s1">np.float64)</span>
        <span class="s1">self.check_result_type(np.int64</span><span class="s0">, </span><span class="s1">np.float64)</span>
        <span class="s1">self.check_result_type(np.float32</span><span class="s0">, </span><span class="s1">np.float32)</span>
        <span class="s1">self.check_result_type(np.float64</span><span class="s0">, </span><span class="s1">np.float64)</span>

    <span class="s1">@td.skip_if_windows</span>
    <span class="s0">def </span><span class="s1">test_result_complex128(self):</span>
        <span class="s4"># xref https://github.com/pandas-dev/pandas/issues/12293</span>
        <span class="s4">#  this fails on Windows, apparently a floating point precision issue</span>

        <span class="s4"># Did not test complex64 because DataFrame is converting it to</span>
        <span class="s4"># complex128. Due to https://github.com/pandas-dev/pandas/issues/10952</span>
        <span class="s1">self.check_result_type(np.complex128</span><span class="s0">, </span><span class="s1">np.complex128)</span>

    <span class="s0">def </span><span class="s1">test_undefined_func(self):</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: np.random.randn(</span><span class="s3">10</span><span class="s1">)})</span>
        <span class="s1">msg = </span><span class="s2">'&quot;mysin&quot; is not a supported function'</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">df.eval(</span><span class="s2">&quot;mysin(a)&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>

    <span class="s0">def </span><span class="s1">test_keyword_arg(self):</span>
        <span class="s1">df = DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: np.random.randn(</span><span class="s3">10</span><span class="s1">)})</span>
        <span class="s1">msg = </span><span class="s2">'Function &quot;sin&quot; does not support keyword arguments'</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">df.eval(</span><span class="s2">&quot;sin(x=a)&quot;</span><span class="s0">, </span><span class="s1">engine=self.engine</span><span class="s0">, </span><span class="s1">parser=self.parser)</span>


<span class="s1">_var_s = np.random.randn(</span><span class="s3">10</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestScope:</span>
    <span class="s0">def </span><span class="s1">test_global_scope(self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">parser):</span>
        <span class="s1">e = </span><span class="s2">&quot;_var_s * 2&quot;</span>
        <span class="s1">tm.assert_numpy_array_equal(</span>
            <span class="s1">_var_s * </span><span class="s3">2</span><span class="s0">, </span><span class="s1">pd.eval(e</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_no_new_locals(self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">parser):</span>
        <span class="s1">x = </span><span class="s3">1</span>
        <span class="s1">lcls = locals().copy()</span>
        <span class="s1">pd.eval(</span><span class="s2">&quot;x + 1&quot;</span><span class="s0">, </span><span class="s1">local_dict=lcls</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
        <span class="s1">lcls2 = locals().copy()</span>
        <span class="s1">lcls2.pop(</span><span class="s2">&quot;lcls&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">lcls == lcls2</span>

    <span class="s0">def </span><span class="s1">test_no_new_globals(self</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">parser):</span>
        <span class="s1">x = </span><span class="s3">1  </span><span class="s4"># noqa:F841</span>
        <span class="s1">gbls = globals().copy()</span>
        <span class="s1">pd.eval(</span><span class="s2">&quot;x + 1&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
        <span class="s1">gbls2 = globals().copy()</span>
        <span class="s0">assert </span><span class="s1">gbls == gbls2</span>


<span class="s1">@td.skip_if_no_ne</span>
<span class="s0">def </span><span class="s1">test_invalid_engine():</span>
    <span class="s1">msg = </span><span class="s2">&quot;Invalid engine 'asdf' passed&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(KeyError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">pd.eval(</span><span class="s2">&quot;x + y&quot;</span><span class="s0">, </span><span class="s1">local_dict={</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s3">2</span><span class="s1">}</span><span class="s0">, </span><span class="s1">engine=</span><span class="s2">&quot;asdf&quot;</span><span class="s1">)</span>


<span class="s1">@td.skip_if_no_ne</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s1">(</span><span class="s2">&quot;use_numexpr&quot;</span><span class="s0">, </span><span class="s2">&quot;expected&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span>
        <span class="s1">(</span><span class="s0">True, </span><span class="s2">&quot;numexpr&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s0">False, </span><span class="s2">&quot;python&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_numexpr_option_respected(use_numexpr</span><span class="s0">, </span><span class="s1">expected):</span>
    <span class="s4"># GH 32556</span>
    <span class="s0">from </span><span class="s1">pandas.core.computation.eval </span><span class="s0">import </span><span class="s1">_check_engine</span>

    <span class="s0">with </span><span class="s1">pd.option_context(</span><span class="s2">&quot;compute.use_numexpr&quot;</span><span class="s0">, </span><span class="s1">use_numexpr):</span>
        <span class="s1">result = _check_engine(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">result == expected</span>


<span class="s1">@td.skip_if_no_ne</span>
<span class="s0">def </span><span class="s1">test_numexpr_option_incompatible_op():</span>
    <span class="s4"># GH 32556</span>
    <span class="s0">with </span><span class="s1">pd.option_context(</span><span class="s2">&quot;compute.use_numexpr&quot;</span><span class="s0">, False</span><span class="s1">):</span>
        <span class="s1">df = DataFrame(</span>
            <span class="s1">{</span><span class="s2">&quot;A&quot;</span><span class="s1">: [</span><span class="s0">True, False, True, False, None, None</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]}</span>
        <span class="s1">)</span>
        <span class="s1">result = df.query(</span><span class="s2">&quot;A.isnull()&quot;</span><span class="s1">)</span>
        <span class="s1">expected = DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: [</span><span class="s0">None, None</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: [</span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">])</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@td.skip_if_no_ne</span>
<span class="s0">def </span><span class="s1">test_invalid_parser():</span>
    <span class="s1">msg = </span><span class="s2">&quot;Invalid parser 'asdf' passed&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(KeyError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">pd.eval(</span><span class="s2">&quot;x + y&quot;</span><span class="s0">, </span><span class="s1">local_dict={</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s3">2</span><span class="s1">}</span><span class="s0">, </span><span class="s1">parser=</span><span class="s2">&quot;asdf&quot;</span><span class="s1">)</span>


<span class="s1">_parsers: dict[str</span><span class="s0">, </span><span class="s1">type[BaseExprVisitor]] = {</span>
    <span class="s2">&quot;python&quot;</span><span class="s1">: PythonExprVisitor</span><span class="s0">,</span>
    <span class="s2">&quot;pytables&quot;</span><span class="s1">: pytables.PyTablesExprVisitor</span><span class="s0">,</span>
    <span class="s2">&quot;pandas&quot;</span><span class="s1">: PandasExprVisitor</span><span class="s0">,</span>
<span class="s1">}</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;engine&quot;</span><span class="s0">, </span><span class="s1">ENGINES)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;parser&quot;</span><span class="s0">, </span><span class="s1">_parsers)</span>
<span class="s0">def </span><span class="s1">test_disallowed_nodes(engine</span><span class="s0">, </span><span class="s1">parser):</span>
    <span class="s1">VisitorClass = _parsers[parser]</span>
    <span class="s1">inst = VisitorClass(</span><span class="s2">&quot;x + 1&quot;</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">parser)</span>

    <span class="s0">for </span><span class="s1">ops </span><span class="s0">in </span><span class="s1">VisitorClass.unsupported_nodes:</span>

        <span class="s1">msg = </span><span class="s2">&quot;nodes are not implemented&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">getattr(inst</span><span class="s0">, </span><span class="s1">ops)()</span>


<span class="s0">def </span><span class="s1">test_syntax_error_exprs(engine</span><span class="s0">, </span><span class="s1">parser):</span>
    <span class="s1">e = </span><span class="s2">&quot;s +&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(SyntaxError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;invalid syntax&quot;</span><span class="s1">):</span>
        <span class="s1">pd.eval(e</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>


<span class="s0">def </span><span class="s1">test_name_error_exprs(engine</span><span class="s0">, </span><span class="s1">parser):</span>
    <span class="s1">e = </span><span class="s2">&quot;s + t&quot;</span>
    <span class="s1">msg = </span><span class="s2">&quot;name 's' is not defined&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(NameError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">pd.eval(e</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;express&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a + @b&quot;</span><span class="s0">, </span><span class="s2">&quot;@a + b&quot;</span><span class="s0">, </span><span class="s2">&quot;@a + @b&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_invalid_local_variable_reference(engine</span><span class="s0">, </span><span class="s1">parser</span><span class="s0">, </span><span class="s1">express):</span>
    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2  </span><span class="s4"># noqa:F841</span>

    <span class="s0">if </span><span class="s1">parser != </span><span class="s2">&quot;pandas&quot;</span><span class="s1">:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(SyntaxError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;The '@' prefix is only&quot;</span><span class="s1">):</span>
            <span class="s1">pd.eval(express</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(SyntaxError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;The '@' prefix is not&quot;</span><span class="s1">):</span>
            <span class="s1">pd.eval(express</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>


<span class="s0">def </span><span class="s1">test_numexpr_builtin_raises(engine</span><span class="s0">, </span><span class="s1">parser):</span>
    <span class="s1">sin</span><span class="s0">, </span><span class="s1">dotted_line = </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span>
    <span class="s0">if </span><span class="s1">engine == </span><span class="s2">&quot;numexpr&quot;</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s2">&quot;Variables in expression .+&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(NumExprClobberingError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">pd.eval(</span><span class="s2">&quot;sin + dotted_line&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">res = pd.eval(</span><span class="s2">&quot;sin + dotted_line&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
        <span class="s0">assert </span><span class="s1">res == sin + dotted_line</span>


<span class="s0">def </span><span class="s1">test_bad_resolver_raises(engine</span><span class="s0">, </span><span class="s1">parser):</span>
    <span class="s1">cannot_resolve = </span><span class="s3">42</span><span class="s0">, </span><span class="s3">3.0</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Resolver of type .+&quot;</span><span class="s1">):</span>
        <span class="s1">pd.eval(</span><span class="s2">&quot;1 + 2&quot;</span><span class="s0">, </span><span class="s1">resolvers=cannot_resolve</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>


<span class="s0">def </span><span class="s1">test_empty_string_raises(engine</span><span class="s0">, </span><span class="s1">parser):</span>
    <span class="s4"># GH 13139</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;expr cannot be an empty string&quot;</span><span class="s1">):</span>
        <span class="s1">pd.eval(</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>


<span class="s0">def </span><span class="s1">test_more_than_one_expression_raises(engine</span><span class="s0">, </span><span class="s1">parser):</span>
    <span class="s0">with </span><span class="s1">pytest.raises(SyntaxError</span><span class="s0">, </span><span class="s1">match=(</span><span class="s2">&quot;only a single expression is allowed&quot;</span><span class="s1">)):</span>
        <span class="s1">pd.eval(</span><span class="s2">&quot;1 + 1; 2 + 2&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;cmp&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;and&quot;</span><span class="s0">, </span><span class="s2">&quot;or&quot;</span><span class="s1">))</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;lhs&quot;</span><span class="s0">, </span><span class="s1">(int</span><span class="s0">, </span><span class="s1">float))</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;rhs&quot;</span><span class="s0">, </span><span class="s1">(int</span><span class="s0">, </span><span class="s1">float))</span>
<span class="s0">def </span><span class="s1">test_bool_ops_fails_on_scalars(lhs</span><span class="s0">, </span><span class="s1">cmp</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">engine</span><span class="s0">, </span><span class="s1">parser):</span>
    <span class="s1">gen = {int: </span><span class="s0">lambda</span><span class="s1">: np.random.randint(</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">float: np.random.randn}</span>

    <span class="s1">mid = gen[lhs]()  </span><span class="s4"># noqa:F841</span>
    <span class="s1">lhs = gen[lhs]()</span>
    <span class="s1">rhs = gen[rhs]()</span>

    <span class="s1">ex1 = </span><span class="s2">f&quot;lhs </span><span class="s0">{</span><span class="s1">cmp</span><span class="s0">} </span><span class="s2">mid </span><span class="s0">{</span><span class="s1">cmp</span><span class="s0">} </span><span class="s2">rhs&quot;</span>
    <span class="s1">ex2 = </span><span class="s2">f&quot;lhs </span><span class="s0">{</span><span class="s1">cmp</span><span class="s0">} </span><span class="s2">mid and mid </span><span class="s0">{</span><span class="s1">cmp</span><span class="s0">} </span><span class="s2">rhs&quot;</span>
    <span class="s1">ex3 = </span><span class="s2">f&quot;(lhs </span><span class="s0">{</span><span class="s1">cmp</span><span class="s0">} </span><span class="s2">mid) &amp; (mid </span><span class="s0">{</span><span class="s1">cmp</span><span class="s0">} </span><span class="s2">rhs)&quot;</span>
    <span class="s0">for </span><span class="s1">ex </span><span class="s0">in </span><span class="s1">(ex1</span><span class="s0">, </span><span class="s1">ex2</span><span class="s0">, </span><span class="s1">ex3):</span>
        <span class="s1">msg = </span><span class="s2">&quot;cannot evaluate scalar only bool ops|'BoolOp' nodes are not&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">pd.eval(ex</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;other&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s2">&quot;'x'&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;...&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_equals_various(other):</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]})</span>
    <span class="s1">result = df.eval(</span><span class="s2">f&quot;A == </span><span class="s0">{</span><span class="s1">other</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
    <span class="s1">expected = Series([</span><span class="s0">False, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">USE_NUMEXPR:</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/10239</span>
        <span class="s4"># lose name with numexpr engine. Remove when that's fixed.</span>
        <span class="s1">expected.name = </span><span class="s0">None</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_inf(engine</span><span class="s0">, </span><span class="s1">parser):</span>
    <span class="s1">s = </span><span class="s2">&quot;inf + 1&quot;</span>
    <span class="s1">expected = np.inf</span>
    <span class="s1">result = pd.eval(s</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
    <span class="s0">assert </span><span class="s1">result == expected</span>


<span class="s0">def </span><span class="s1">test_truediv_deprecated(engine</span><span class="s0">, </span><span class="s1">parser):</span>
    <span class="s4"># GH#29182</span>
    <span class="s1">match = </span><span class="s2">&quot;The `truediv` parameter in pd.eval is deprecated&quot;</span>

    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning) </span><span class="s0">as </span><span class="s1">m:</span>
        <span class="s1">pd.eval(</span><span class="s2">&quot;1+1&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser</span><span class="s0">, </span><span class="s1">truediv=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">len(m) == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">match </span><span class="s0">in </span><span class="s1">str(m[</span><span class="s3">0</span><span class="s1">].message)</span>

    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning) </span><span class="s0">as </span><span class="s1">m:</span>
        <span class="s1">pd.eval(</span><span class="s2">&quot;1+1&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser</span><span class="s0">, </span><span class="s1">truediv=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">len(m) == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">match </span><span class="s0">in </span><span class="s1">str(m[</span><span class="s3">0</span><span class="s1">].message)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;column&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;Temp(°C)&quot;</span><span class="s0">, </span><span class="s2">&quot;Capacitance(μF)&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_query_token(engine</span><span class="s0">, </span><span class="s1">column):</span>
    <span class="s4"># See: https://github.com/pandas-dev/pandas/pull/42826</span>
    <span class="s1">df = DataFrame(np.random.randn(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">columns=[column</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>
    <span class="s1">expected = df[df[column] &gt; </span><span class="s3">5</span><span class="s1">]</span>
    <span class="s1">query_string = </span><span class="s2">f&quot;`</span><span class="s0">{</span><span class="s1">column</span><span class="s0">}</span><span class="s2">` &gt; 5&quot;</span>
    <span class="s1">result = df.query(query_string</span><span class="s0">, </span><span class="s1">engine=engine)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_negate_lt_eq_le(engine</span><span class="s0">, </span><span class="s1">parser):</span>
    <span class="s1">df = DataFrame([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">20</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;cat&quot;</span><span class="s0">, </span><span class="s2">&quot;count&quot;</span><span class="s1">])</span>
    <span class="s1">expected = df[~(df.cat &gt; </span><span class="s3">0</span><span class="s1">)]</span>

    <span class="s1">result = df.query(</span><span class="s2">&quot;~(cat &gt; 0)&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">if </span><span class="s1">parser == </span><span class="s2">&quot;python&quot;</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s2">&quot;'Not' nodes are not implemented&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">df.query(</span><span class="s2">&quot;not (cat &gt; 0)&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result = df.query(</span><span class="s2">&quot;not (cat &gt; 0)&quot;</span><span class="s0">, </span><span class="s1">engine=engine</span><span class="s0">, </span><span class="s1">parser=parser)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">class </span><span class="s1">TestValidate:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;value&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;True&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s3">5.0</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_validate_bool_args(self</span><span class="s0">, </span><span class="s1">value):</span>

        <span class="s1">msg = </span><span class="s2">'For argument &quot;inplace&quot; expected type bool, received type'</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">pd.eval(</span><span class="s2">&quot;2+2&quot;</span><span class="s0">, </span><span class="s1">inplace=value)</span>
</pre>
</body>
</html>