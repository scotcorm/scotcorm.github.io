<html>
<head>
<title>nattype.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
nattype.pyx</font>
</center></td></tr></table>
<pre><span class="s0">import warnings</span>

<span class="s0">from cpython.datetime cimport (</span>
    <span class="s0">PyDate_Check,</span>
    <span class="s0">PyDateTime_Check,</span>
    <span class="s0">PyDateTime_IMPORT,</span>
    <span class="s0">PyDelta_Check,</span>
    <span class="s0">datetime,</span>
    <span class="s0">timedelta,</span>
<span class="s0">)</span>
<span class="s0">from cpython.object cimport (</span>
    <span class="s0">Py_EQ,</span>
    <span class="s0">Py_GE,</span>
    <span class="s0">Py_GT,</span>
    <span class="s0">Py_LE,</span>
    <span class="s0">Py_LT,</span>
    <span class="s0">Py_NE,</span>
    <span class="s0">PyObject_RichCompare,</span>
<span class="s0">)</span>

<span class="s0">PyDateTime_IMPORT</span>

<span class="s0">from cpython.version cimport PY_MINOR_VERSION</span>

<span class="s0">import numpy as np</span>

<span class="s0">cimport numpy as cnp</span>
<span class="s0">from numpy cimport int64_t</span>

<span class="s0">cnp.import_array()</span>

<span class="s0">cimport pandas._libs.tslibs.util as util</span>
<span class="s0">from pandas._libs.tslibs.np_datetime cimport (</span>
    <span class="s0">get_datetime64_value,</span>
    <span class="s0">get_timedelta64_value,</span>
<span class="s0">)</span>

<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Constants</span>
<span class="s0">nat_strings = {&quot;NaT&quot;, &quot;nat&quot;, &quot;NAT&quot;, &quot;nan&quot;, &quot;NaN&quot;, &quot;NAN&quot;}</span>
<span class="s0">cdef set c_nat_strings = nat_strings</span>

<span class="s0">cdef int64_t NPY_NAT = util.get_nat()</span>
<span class="s0">iNaT = NPY_NAT  # python-visible constant</span>

<span class="s0">cdef bint _nat_scalar_rules[6]</span>
<span class="s0">_nat_scalar_rules[Py_EQ] = False</span>
<span class="s0">_nat_scalar_rules[Py_NE] = True</span>
<span class="s0">_nat_scalar_rules[Py_LT] = False</span>
<span class="s0">_nat_scalar_rules[Py_LE] = False</span>
<span class="s0">_nat_scalar_rules[Py_GT] = False</span>
<span class="s0">_nat_scalar_rules[Py_GE] = False</span>

<span class="s0"># ----------------------------------------------------------------------</span>


<span class="s0">def _make_nan_func(func_name: str, doc: str):</span>
    <span class="s0">def f(*args, **kwargs):</span>
        <span class="s0">return np.nan</span>
    <span class="s0">f.__name__ = func_name</span>
    <span class="s0">f.__doc__ = doc</span>
    <span class="s0">return f</span>


<span class="s0">def _make_nat_func(func_name: str, doc: str):</span>
    <span class="s0">def f(*args, **kwargs):</span>
        <span class="s0">return c_NaT</span>
    <span class="s0">f.__name__ = func_name</span>
    <span class="s0">f.__doc__ = doc</span>
    <span class="s0">return f</span>


<span class="s0">def _make_error_func(func_name: str, cls):</span>
    <span class="s0">def f(*args, **kwargs):</span>
        <span class="s0">raise ValueError(f&quot;NaTType does not support {func_name}&quot;)</span>

    <span class="s0">f.__name__ = func_name</span>
    <span class="s0">if isinstance(cls, str):</span>
        <span class="s0"># passed the literal docstring directly</span>
        <span class="s0">f.__doc__ = cls</span>
    <span class="s0">elif cls is not None:</span>
        <span class="s0">f.__doc__ = getattr(cls, func_name).__doc__</span>
    <span class="s0">return f</span>


<span class="s0">cdef _nat_divide_op(self, other):</span>
    <span class="s0">if PyDelta_Check(other) or util.is_timedelta64_object(other) or other is c_NaT:</span>
        <span class="s0">return np.nan</span>
    <span class="s0">if util.is_integer_object(other) or util.is_float_object(other):</span>
        <span class="s0">return c_NaT</span>
    <span class="s0">return NotImplemented</span>


<span class="s0">cdef _nat_rdivide_op(self, other):</span>
    <span class="s0">if PyDelta_Check(other):</span>
        <span class="s0">return np.nan</span>
    <span class="s0">return NotImplemented</span>


<span class="s0">def __nat_unpickle(*args):</span>
    <span class="s0"># return constant defined in the module</span>
    <span class="s0">return c_NaT</span>

<span class="s0"># ----------------------------------------------------------------------</span>


<span class="s0">cdef class _NaT(datetime):</span>
    <span class="s0"># cdef readonly:</span>
    <span class="s0">#    int64_t value</span>
    <span class="s0">#    object freq</span>

    <span class="s0"># higher than np.ndarray and np.matrix</span>
    <span class="s0">__array_priority__ = 100</span>

    <span class="s0">def __richcmp__(_NaT self, object other, int op):</span>
        <span class="s0">if util.is_datetime64_object(other) or PyDateTime_Check(other):</span>
            <span class="s0"># We treat NaT as datetime-like for this comparison</span>
            <span class="s0">return _nat_scalar_rules[op]</span>

        <span class="s0">elif util.is_timedelta64_object(other) or PyDelta_Check(other):</span>
            <span class="s0"># We treat NaT as timedelta-like for this comparison</span>
            <span class="s0">return _nat_scalar_rules[op]</span>

        <span class="s0">elif util.is_array(other):</span>
            <span class="s0">if other.dtype.kind in &quot;mM&quot;:</span>
                <span class="s0">result = np.empty(other.shape, dtype=np.bool_)</span>
                <span class="s0">result.fill(_nat_scalar_rules[op])</span>
            <span class="s0">elif other.dtype.kind == &quot;O&quot;:</span>
                <span class="s0">result = np.array([PyObject_RichCompare(self, x, op) for x in other])</span>
            <span class="s0">elif op == Py_EQ:</span>
                <span class="s0">result = np.zeros(other.shape, dtype=bool)</span>
            <span class="s0">elif op == Py_NE:</span>
                <span class="s0">result = np.ones(other.shape, dtype=bool)</span>
            <span class="s0">else:</span>
                <span class="s0">return NotImplemented</span>
            <span class="s0">return result</span>

        <span class="s0">elif PyDate_Check(other):</span>
            <span class="s0"># GH#39151 don't defer to datetime.date object</span>
            <span class="s0">if op == Py_EQ:</span>
                <span class="s0">return False</span>
            <span class="s0">if op == Py_NE:</span>
                <span class="s0">return True</span>
            <span class="s0">warnings.warn(</span>
                <span class="s0">&quot;Comparison of NaT with datetime.date is deprecated in &quot;</span>
                <span class="s0">&quot;order to match the standard library behavior. &quot;</span>
                <span class="s0">&quot;In a future version these will be considered non-comparable.&quot;,</span>
                <span class="s0">FutureWarning,</span>
                <span class="s0">stacklevel=1,</span>
            <span class="s0">)</span>
            <span class="s0">return False</span>

        <span class="s0">return NotImplemented</span>

    <span class="s0">def __add__(self, other):</span>
        <span class="s0">if self is not c_NaT:</span>
            <span class="s0"># cython __radd__ semantics</span>
            <span class="s0">self, other = other, self</span>

        <span class="s0">if PyDateTime_Check(other):</span>
            <span class="s0">return c_NaT</span>
        <span class="s0">elif PyDelta_Check(other):</span>
            <span class="s0">return c_NaT</span>
        <span class="s0">elif util.is_datetime64_object(other) or util.is_timedelta64_object(other):</span>
            <span class="s0">return c_NaT</span>

        <span class="s0">elif util.is_integer_object(other):</span>
            <span class="s0"># For Period compat</span>
            <span class="s0">return c_NaT</span>

        <span class="s0">elif util.is_array(other):</span>
            <span class="s0">if other.dtype.kind in &quot;mM&quot;:</span>
                <span class="s0"># If we are adding to datetime64, we treat NaT as timedelta</span>
                <span class="s0">#  Either way, result dtype is datetime64</span>
                <span class="s0">result = np.empty(other.shape, dtype=&quot;datetime64[ns]&quot;)</span>
                <span class="s0">result.fill(&quot;NaT&quot;)</span>
                <span class="s0">return result</span>
            <span class="s0">raise TypeError(f&quot;Cannot add NaT to ndarray with dtype {other.dtype}&quot;)</span>

        <span class="s0"># Includes Period, DateOffset going through here</span>
        <span class="s0">return NotImplemented</span>

    <span class="s0">def __sub__(self, other):</span>
        <span class="s0"># Duplicate some logic from _Timestamp.__sub__ to avoid needing</span>
        <span class="s0"># to subclass; allows us to @final(_Timestamp.__sub__)</span>
        <span class="s0">cdef:</span>
            <span class="s0">bint is_rsub = False</span>

        <span class="s0">if self is not c_NaT:</span>
            <span class="s0"># cython __rsub__ semantics</span>
            <span class="s0">self, other = other, self</span>
            <span class="s0">is_rsub = True</span>

        <span class="s0">if PyDateTime_Check(other):</span>
            <span class="s0">return c_NaT</span>
        <span class="s0">elif PyDelta_Check(other):</span>
            <span class="s0">return c_NaT</span>
        <span class="s0">elif util.is_datetime64_object(other) or util.is_timedelta64_object(other):</span>
            <span class="s0">return c_NaT</span>

        <span class="s0">elif util.is_integer_object(other):</span>
            <span class="s0"># For Period compat</span>
            <span class="s0">return c_NaT</span>

        <span class="s0">elif util.is_array(other):</span>
            <span class="s0">if other.dtype.kind == &quot;m&quot;:</span>
                <span class="s0">if not is_rsub:</span>
                    <span class="s0"># NaT - timedelta64 we treat NaT as datetime64, so result</span>
                    <span class="s0">#  is datetime64</span>
                    <span class="s0">result = np.empty(other.shape, dtype=&quot;datetime64[ns]&quot;)</span>
                    <span class="s0">result.fill(&quot;NaT&quot;)</span>
                    <span class="s0">return result</span>

                <span class="s0"># timedelta64 - NaT we have to treat NaT as timedelta64</span>
                <span class="s0">#  for this to be meaningful, and the result is timedelta64</span>
                <span class="s0">result = np.empty(other.shape, dtype=&quot;timedelta64[ns]&quot;)</span>
                <span class="s0">result.fill(&quot;NaT&quot;)</span>
                <span class="s0">return result</span>

            <span class="s0">elif other.dtype.kind == &quot;M&quot;:</span>
                <span class="s0"># We treat NaT as a datetime, so regardless of whether this is</span>
                <span class="s0">#  NaT - other or other - NaT, the result is timedelta64</span>
                <span class="s0">result = np.empty(other.shape, dtype=&quot;timedelta64[ns]&quot;)</span>
                <span class="s0">result.fill(&quot;NaT&quot;)</span>
                <span class="s0">return result</span>

            <span class="s0">raise TypeError(</span>
                <span class="s0">f&quot;Cannot subtract NaT from ndarray with dtype {other.dtype}&quot;</span>
            <span class="s0">)</span>

        <span class="s0"># Includes Period, DateOffset going through here</span>
        <span class="s0">return NotImplemented</span>

    <span class="s0">def __pos__(self):</span>
        <span class="s0">return NaT</span>

    <span class="s0">def __neg__(self):</span>
        <span class="s0">return NaT</span>

    <span class="s0">def __truediv__(self, other):</span>
        <span class="s0">return _nat_divide_op(self, other)</span>

    <span class="s0">def __floordiv__(self, other):</span>
        <span class="s0">return _nat_divide_op(self, other)</span>

    <span class="s0">def __mul__(self, other):</span>
        <span class="s0">if util.is_integer_object(other) or util.is_float_object(other):</span>
            <span class="s0">return NaT</span>
        <span class="s0">return NotImplemented</span>

    <span class="s0">@property</span>
    <span class="s0">def asm8(self) -&gt; np.datetime64:</span>
        <span class="s0">return np.datetime64(NPY_NAT, &quot;ns&quot;)</span>

    <span class="s0">def to_datetime64(self) -&gt; np.datetime64:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return a numpy.datetime64 object with 'ns' precision.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return np.datetime64('NaT', &quot;ns&quot;)</span>

    <span class="s0">def to_numpy(self, dtype=None, copy=False) -&gt; np.datetime64 | np.timedelta64:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Convert the Timestamp to a NumPy datetime64 or timedelta64.</span>

        <span class="s0">.. versionadded:: 0.25.0</span>

        <span class="s0">With the default 'dtype', this is an alias method for `NaT.to_datetime64()`.</span>

        <span class="s0">The copy parameter is available here only for compatibility. Its value</span>
        <span class="s0">will not affect the return value.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">numpy.datetime64 or numpy.timedelta64</span>

        <span class="s0">See Also</span>
        <span class="s0">--------</span>
        <span class="s0">DatetimeIndex.to_numpy : Similar method for DatetimeIndex.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651')</span>
        <span class="s0">&gt;&gt;&gt; ts.to_numpy()</span>
        <span class="s0">numpy.datetime64('2020-03-14T15:32:52.192548651')</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.to_numpy()</span>
        <span class="s0">numpy.datetime64('NaT')</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.to_numpy(&quot;m8[ns]&quot;)</span>
        <span class="s0">numpy.timedelta64('NaT','ns')</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if dtype is not None:</span>
            <span class="s0"># GH#44460</span>
            <span class="s0">dtype = np.dtype(dtype)</span>
            <span class="s0">if dtype.kind == &quot;M&quot;:</span>
                <span class="s0">return np.datetime64(&quot;NaT&quot;).astype(dtype)</span>
            <span class="s0">elif dtype.kind == &quot;m&quot;:</span>
                <span class="s0">return np.timedelta64(&quot;NaT&quot;).astype(dtype)</span>
            <span class="s0">else:</span>
                <span class="s0">raise ValueError(</span>
                    <span class="s0">&quot;NaT.to_numpy dtype must be a datetime64 dtype, timedelta64 &quot;</span>
                    <span class="s0">&quot;dtype, or None.&quot;</span>
                <span class="s0">)</span>
        <span class="s0">return self.to_datetime64()</span>

    <span class="s0">def __repr__(self) -&gt; str:</span>
        <span class="s0">return &quot;NaT&quot;</span>

    <span class="s0">def __str__(self) -&gt; str:</span>
        <span class="s0">return &quot;NaT&quot;</span>

    <span class="s0">def isoformat(self, sep: str = &quot;T&quot;, timespec: str = &quot;auto&quot;) -&gt; str:</span>
        <span class="s0"># This allows Timestamp(ts.isoformat()) to always correctly roundtrip.</span>
        <span class="s0">return &quot;NaT&quot;</span>

    <span class="s0">def __hash__(self) -&gt; int:</span>
        <span class="s0">return NPY_NAT</span>

    <span class="s0">@property</span>
    <span class="s0">def is_leap_year(self) -&gt; bool:</span>
        <span class="s0">return False</span>

    <span class="s0">@property</span>
    <span class="s0">def is_month_start(self) -&gt; bool:</span>
        <span class="s0">return False</span>

    <span class="s0">@property</span>
    <span class="s0">def is_quarter_start(self) -&gt; bool:</span>
        <span class="s0">return False</span>

    <span class="s0">@property</span>
    <span class="s0">def is_year_start(self) -&gt; bool:</span>
        <span class="s0">return False</span>

    <span class="s0">@property</span>
    <span class="s0">def is_month_end(self) -&gt; bool:</span>
        <span class="s0">return False</span>

    <span class="s0">@property</span>
    <span class="s0">def is_quarter_end(self) -&gt; bool:</span>
        <span class="s0">return False</span>

    <span class="s0">@property</span>
    <span class="s0">def is_year_end(self) -&gt; bool:</span>
        <span class="s0">return False</span>


<span class="s0">class NaTType(_NaT):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">(N)ot-(A)-(T)ime, the time equivalent of NaN.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">def __new__(cls):</span>
        <span class="s0">cdef _NaT base</span>

        <span class="s0">base = _NaT.__new__(cls, 1, 1, 1)</span>
        <span class="s0">base.value = NPY_NAT</span>

        <span class="s0">return base</span>

    <span class="s0">@property</span>
    <span class="s0">def freq(self):</span>
        <span class="s0">warnings.warn(</span>
            <span class="s0">&quot;NaT.freq is deprecated and will be removed in a future version.&quot;,</span>
            <span class="s0">FutureWarning,</span>
            <span class="s0">stacklevel=1,</span>
        <span class="s0">)</span>
        <span class="s0">return None</span>

    <span class="s0">def __reduce_ex__(self, protocol):</span>
        <span class="s0"># python 3.6 compat</span>
        <span class="s0"># https://bugs.python.org/issue28730</span>
        <span class="s0"># now __reduce_ex__ is defined and higher priority than __reduce__</span>
        <span class="s0">return self.__reduce__()</span>

    <span class="s0">def __reduce__(self):</span>
        <span class="s0">return (__nat_unpickle, (None, ))</span>

    <span class="s0">def __rtruediv__(self, other):</span>
        <span class="s0">return _nat_rdivide_op(self, other)</span>

    <span class="s0">def __rfloordiv__(self, other):</span>
        <span class="s0">return _nat_rdivide_op(self, other)</span>

    <span class="s0">def __rmul__(self, other):</span>
        <span class="s0">if util.is_integer_object(other) or util.is_float_object(other):</span>
            <span class="s0">return c_NaT</span>
        <span class="s0">return NotImplemented</span>

    <span class="s0"># ----------------------------------------------------------------------</span>
    <span class="s0"># inject the Timestamp field properties</span>
    <span class="s0"># these by definition return np.nan</span>

    <span class="s0">year = property(fget=lambda self: np.nan)</span>
    <span class="s0">quarter = property(fget=lambda self: np.nan)</span>
    <span class="s0">month = property(fget=lambda self: np.nan)</span>
    <span class="s0">day = property(fget=lambda self: np.nan)</span>
    <span class="s0">hour = property(fget=lambda self: np.nan)</span>
    <span class="s0">minute = property(fget=lambda self: np.nan)</span>
    <span class="s0">second = property(fget=lambda self: np.nan)</span>
    <span class="s0">millisecond = property(fget=lambda self: np.nan)</span>
    <span class="s0">microsecond = property(fget=lambda self: np.nan)</span>
    <span class="s0">nanosecond = property(fget=lambda self: np.nan)</span>

    <span class="s0">week = property(fget=lambda self: np.nan)</span>
    <span class="s0">dayofyear = property(fget=lambda self: np.nan)</span>
    <span class="s0">day_of_year = property(fget=lambda self: np.nan)</span>
    <span class="s0">weekofyear = property(fget=lambda self: np.nan)</span>
    <span class="s0">days_in_month = property(fget=lambda self: np.nan)</span>
    <span class="s0">daysinmonth = property(fget=lambda self: np.nan)</span>
    <span class="s0">dayofweek = property(fget=lambda self: np.nan)</span>
    <span class="s0">day_of_week = property(fget=lambda self: np.nan)</span>

    <span class="s0"># inject Timedelta properties</span>
    <span class="s0">days = property(fget=lambda self: np.nan)</span>
    <span class="s0">seconds = property(fget=lambda self: np.nan)</span>
    <span class="s0">microseconds = property(fget=lambda self: np.nan)</span>
    <span class="s0">nanoseconds = property(fget=lambda self: np.nan)</span>

    <span class="s0"># inject pd.Period properties</span>
    <span class="s0">qyear = property(fget=lambda self: np.nan)</span>

    <span class="s0"># ----------------------------------------------------------------------</span>
    <span class="s0"># GH9513 NaT methods (except to_datetime64) to raise, return np.nan, or</span>
    <span class="s0"># return NaT create functions that raise, for binding to NaTType</span>
    <span class="s0"># These are the ones that can get their docstrings from datetime.</span>

    <span class="s0"># nan methods</span>
    <span class="s0">weekday = _make_nan_func(</span>
        <span class="s0">&quot;weekday&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the day of the week represented by the date.</span>
        <span class="s0">Monday == 0 ... Sunday == 6.</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>
    <span class="s0">isoweekday = _make_nan_func(</span>
        <span class="s0">&quot;isoweekday&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the day of the week represented by the date.</span>
        <span class="s0">Monday == 1 ... Sunday == 7.</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>
    <span class="s0">total_seconds = _make_nan_func(&quot;total_seconds&quot;, timedelta.total_seconds.__doc__)</span>
    <span class="s0">month_name = _make_nan_func(</span>
        <span class="s0">&quot;month_name&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the month name of the Timestamp with specified locale.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">locale : str, default None (English locale)</span>
            <span class="s0">Locale determining the language in which to return the month name.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">str</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651')</span>
        <span class="s0">&gt;&gt;&gt; ts.month_name()</span>
        <span class="s0">'March'</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.month_name()</span>
        <span class="s0">nan</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>
    <span class="s0">day_name = _make_nan_func(</span>
        <span class="s0">&quot;day_name&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the day name of the Timestamp with specified locale.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">locale : str, default None (English locale)</span>
            <span class="s0">Locale determining the language in which to return the day name.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">str</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651')</span>
        <span class="s0">&gt;&gt;&gt; ts.day_name()</span>
        <span class="s0">'Saturday'</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.day_name()</span>
        <span class="s0">nan</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>
    <span class="s0"># _nat_methods</span>
    <span class="s0">date = _make_nat_func(&quot;date&quot;, datetime.date.__doc__)</span>

    <span class="s0">utctimetuple = _make_error_func(&quot;utctimetuple&quot;, datetime)</span>
    <span class="s0">timetz = _make_error_func(&quot;timetz&quot;, datetime)</span>
    <span class="s0">timetuple = _make_error_func(&quot;timetuple&quot;, datetime)</span>
    <span class="s0">isocalendar = _make_error_func(&quot;isocalendar&quot;, datetime)</span>
    <span class="s0">dst = _make_error_func(&quot;dst&quot;, datetime)</span>
    <span class="s0">ctime = _make_error_func(&quot;ctime&quot;, datetime)</span>
    <span class="s0">time = _make_error_func(&quot;time&quot;, datetime)</span>
    <span class="s0">toordinal = _make_error_func(&quot;toordinal&quot;, datetime)</span>
    <span class="s0">tzname = _make_error_func(&quot;tzname&quot;, datetime)</span>
    <span class="s0">utcoffset = _make_error_func(&quot;utcoffset&quot;, datetime)</span>

    <span class="s0"># &quot;fromisocalendar&quot; was introduced in 3.8</span>
    <span class="s0">if PY_MINOR_VERSION &gt;= 8:</span>
        <span class="s0">fromisocalendar = _make_error_func(&quot;fromisocalendar&quot;, datetime)</span>

    <span class="s0"># ----------------------------------------------------------------------</span>
    <span class="s0"># The remaining methods have docstrings copy/pasted from the analogous</span>
    <span class="s0"># Timestamp methods.</span>

    <span class="s0">strftime = _make_error_func(</span>
        <span class="s0">&quot;strftime&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Timestamp.strftime(format)</span>

        <span class="s0">Return a string representing the given POSIX timestamp</span>
        <span class="s0">controlled by an explicit format string.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">format : str</span>
            <span class="s0">Format string to convert Timestamp to string.</span>
            <span class="s0">See strftime documentation for more information on the format string:</span>
            <span class="s0">https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651')</span>
        <span class="s0">&gt;&gt;&gt; ts.strftime('%Y-%m-%d %X')</span>
        <span class="s0">'2020-03-14 15:32:52'</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>

    <span class="s0">strptime = _make_error_func(</span>
        <span class="s0">&quot;strptime&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Timestamp.strptime(string, format)</span>

        <span class="s0">Function is not implemented. Use pd.to_datetime().</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>

    <span class="s0">utcfromtimestamp = _make_error_func(</span>
        <span class="s0">&quot;utcfromtimestamp&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Timestamp.utcfromtimestamp(ts)</span>

        <span class="s0">Construct a naive UTC datetime from a POSIX timestamp.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; pd.Timestamp.utcfromtimestamp(1584199972)</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52')</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>
    <span class="s0">fromtimestamp = _make_error_func(</span>
        <span class="s0">&quot;fromtimestamp&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Timestamp.fromtimestamp(ts)</span>

        <span class="s0">Transform timestamp[, tz] to tz's local time from POSIX timestamp.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; pd.Timestamp.fromtimestamp(1584199972)</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52')</span>

        <span class="s0">Note that the output may change depending on your local time.</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>
    <span class="s0">combine = _make_error_func(</span>
        <span class="s0">&quot;combine&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Timestamp.combine(date, time)</span>

        <span class="s0">Combine date, time into datetime with same date and time fields.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; from datetime import date, time</span>
        <span class="s0">&gt;&gt;&gt; pd.Timestamp.combine(date(2020, 3, 14), time(15, 30, 15))</span>
        <span class="s0">Timestamp('2020-03-14 15:30:15')</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>
    <span class="s0">utcnow = _make_error_func(</span>
        <span class="s0">&quot;utcnow&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Timestamp.utcnow()</span>

        <span class="s0">Return a new Timestamp representing UTC day and time.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; pd.Timestamp.utcnow()   # doctest: +SKIP</span>
        <span class="s0">Timestamp('2020-11-16 22:50:18.092888+0000', tz='UTC')</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>

    <span class="s0">timestamp = _make_error_func(</span>
        <span class="s0">&quot;timestamp&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return POSIX timestamp as float.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548')</span>
        <span class="s0">&gt;&gt;&gt; ts.timestamp()</span>
        <span class="s0">1584199972.192548</span>
        <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">)</span>

    <span class="s0"># GH9513 NaT methods (except to_datetime64) to raise, return np.nan, or</span>
    <span class="s0"># return NaT create functions that raise, for binding to NaTType</span>
    <span class="s0">astimezone = _make_error_func(</span>
        <span class="s0">&quot;astimezone&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Convert timezone-aware Timestamp to another time zone.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">tz : str, pytz.timezone, dateutil.tz.tzfile or None</span>
            <span class="s0">Time zone for time which Timestamp will be converted to.</span>
            <span class="s0">None will remove timezone holding UTC time.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">converted : Timestamp</span>

        <span class="s0">Raises</span>
        <span class="s0">------</span>
        <span class="s0">TypeError</span>
            <span class="s0">If Timestamp is tz-naive.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">Create a timestamp object with UTC timezone:</span>

        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651', tz='UTC')</span>
        <span class="s0">&gt;&gt;&gt; ts</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52.192548651+0000', tz='UTC')</span>

        <span class="s0">Change to Tokyo timezone:</span>

        <span class="s0">&gt;&gt;&gt; ts.tz_convert(tz='Asia/Tokyo')</span>
        <span class="s0">Timestamp('2020-03-15 00:32:52.192548651+0900', tz='Asia/Tokyo')</span>

        <span class="s0">Can also use ``astimezone``:</span>

        <span class="s0">&gt;&gt;&gt; ts.astimezone(tz='Asia/Tokyo')</span>
        <span class="s0">Timestamp('2020-03-15 00:32:52.192548651+0900', tz='Asia/Tokyo')</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.tz_convert(tz='Asia/Tokyo')</span>
        <span class="s0">NaT</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>
    <span class="s0">fromordinal = _make_error_func(</span>
        <span class="s0">&quot;fromordinal&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Timestamp.fromordinal(ordinal, freq=None, tz=None)</span>

        <span class="s0">Passed an ordinal, translate and convert to a ts.</span>
        <span class="s0">Note: by definition there cannot be any tz info on the ordinal itself.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">ordinal : int</span>
            <span class="s0">Date corresponding to a proleptic Gregorian ordinal.</span>
        <span class="s0">freq : str, DateOffset</span>
            <span class="s0">Offset to apply to the Timestamp.</span>
        <span class="s0">tz : str, pytz.timezone, dateutil.tz.tzfile or None</span>
            <span class="s0">Time zone for the Timestamp.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; pd.Timestamp.fromordinal(737425)</span>
        <span class="s0">Timestamp('2020-01-01 00:00:00')</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>

    <span class="s0"># _nat_methods</span>
    <span class="s0">to_pydatetime = _make_nat_func(</span>
        <span class="s0">&quot;to_pydatetime&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Convert a Timestamp object to a native Python datetime object.</span>

        <span class="s0">If warn=True, issue a warning if nanoseconds is nonzero.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548')</span>
        <span class="s0">&gt;&gt;&gt; ts.to_pydatetime()</span>
        <span class="s0">datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.to_pydatetime()</span>
        <span class="s0">NaT</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>

    <span class="s0">now = _make_nat_func(</span>
        <span class="s0">&quot;now&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Timestamp.now(tz=None)</span>

        <span class="s0">Return new Timestamp object representing current time local to</span>
        <span class="s0">tz.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">tz : str or timezone object, default None</span>
            <span class="s0">Timezone to localize to.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; pd.Timestamp.now()  # doctest: +SKIP</span>
        <span class="s0">Timestamp('2020-11-16 22:06:16.378782')</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.now()</span>
        <span class="s0">NaT</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>
    <span class="s0">today = _make_nat_func(</span>
        <span class="s0">&quot;today&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Timestamp.today(cls, tz=None)</span>

        <span class="s0">Return the current time in the local timezone.  This differs</span>
        <span class="s0">from datetime.today() in that it can be localized to a</span>
        <span class="s0">passed timezone.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">tz : str or timezone object, default None</span>
            <span class="s0">Timezone to localize to.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">&gt;&gt;&gt; pd.Timestamp.today()    # doctest: +SKIP</span>
        <span class="s0">Timestamp('2020-11-16 22:37:39.969883')</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.today()</span>
        <span class="s0">NaT</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>
    <span class="s0">round = _make_nat_func(</span>
        <span class="s0">&quot;round&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Round the Timestamp to the specified resolution.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">freq : str</span>
            <span class="s0">Frequency string indicating the rounding resolution.</span>
        <span class="s0">ambiguous : bool or {'raise', 'NaT'}, default 'raise'</span>
            <span class="s0">The behavior is as follows:</span>

            <span class="s0">* bool contains flags to determine if time is dst or not (note</span>
              <span class="s0">that this flag is only applicable for ambiguous fall dst dates).</span>
            <span class="s0">* 'NaT' will return NaT for an ambiguous time.</span>
            <span class="s0">* 'raise' will raise an AmbiguousTimeError for an ambiguous time.</span>

        <span class="s0">nonexistent : {'raise', 'shift_forward', 'shift_backward, 'NaT', \</span>
<span class="s0">timedelta}, default 'raise'</span>
            <span class="s0">A nonexistent time does not exist in a particular timezone</span>
            <span class="s0">where clocks moved forward due to DST.</span>

            <span class="s0">* 'shift_forward' will shift the nonexistent time forward to the</span>
              <span class="s0">closest existing time.</span>
            <span class="s0">* 'shift_backward' will shift the nonexistent time backward to the</span>
              <span class="s0">closest existing time.</span>
            <span class="s0">* 'NaT' will return NaT where there are nonexistent times.</span>
            <span class="s0">* timedelta objects will shift nonexistent times by the timedelta.</span>
            <span class="s0">* 'raise' will raise an NonExistentTimeError if there are</span>
              <span class="s0">nonexistent times.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">a new Timestamp rounded to the given resolution of `freq`</span>

        <span class="s0">Raises</span>
        <span class="s0">------</span>
        <span class="s0">ValueError if the freq cannot be converted</span>

        <span class="s0">Notes</span>
        <span class="s0">-----</span>
        <span class="s0">If the Timestamp has a timezone, rounding will take place relative to the</span>
        <span class="s0">local (&quot;wall&quot;) time and re-localized to the same timezone. When rounding</span>
        <span class="s0">near daylight savings time, use ``nonexistent`` and ``ambiguous`` to</span>
        <span class="s0">control the re-localization behavior.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">Create a timestamp object:</span>

        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651')</span>

        <span class="s0">A timestamp can be rounded using multiple frequency units:</span>

        <span class="s0">&gt;&gt;&gt; ts.round(freq='H') # hour</span>
        <span class="s0">Timestamp('2020-03-14 16:00:00')</span>

        <span class="s0">&gt;&gt;&gt; ts.round(freq='T') # minute</span>
        <span class="s0">Timestamp('2020-03-14 15:33:00')</span>

        <span class="s0">&gt;&gt;&gt; ts.round(freq='S') # seconds</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52')</span>

        <span class="s0">&gt;&gt;&gt; ts.round(freq='L') # milliseconds</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52.193000')</span>

        <span class="s0">``freq`` can also be a multiple of a single unit, like '5T' (i.e.  5 minutes):</span>

        <span class="s0">&gt;&gt;&gt; ts.round(freq='5T')</span>
        <span class="s0">Timestamp('2020-03-14 15:35:00')</span>

        <span class="s0">or a combination of multiple units, like '1H30T' (i.e. 1 hour and 30 minutes):</span>

        <span class="s0">&gt;&gt;&gt; ts.round(freq='1H30T')</span>
        <span class="s0">Timestamp('2020-03-14 15:00:00')</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.round()</span>
        <span class="s0">NaT</span>

        <span class="s0">When rounding near a daylight savings time transition, use ``ambiguous`` or</span>
        <span class="s0">``nonexistent`` to control how the timestamp should be re-localized.</span>

        <span class="s0">&gt;&gt;&gt; ts_tz = pd.Timestamp(&quot;2021-10-31 01:30:00&quot;).tz_localize(&quot;Europe/Amsterdam&quot;)</span>

        <span class="s0">&gt;&gt;&gt; ts_tz.round(&quot;H&quot;, ambiguous=False)</span>
        <span class="s0">Timestamp('2021-10-31 02:00:00+0100', tz='Europe/Amsterdam')</span>

        <span class="s0">&gt;&gt;&gt; ts_tz.round(&quot;H&quot;, ambiguous=True)</span>
        <span class="s0">Timestamp('2021-10-31 02:00:00+0200', tz='Europe/Amsterdam')</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>
    <span class="s0">floor = _make_nat_func(</span>
        <span class="s0">&quot;floor&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return a new Timestamp floored to this resolution.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">freq : str</span>
            <span class="s0">Frequency string indicating the flooring resolution.</span>
        <span class="s0">ambiguous : bool or {'raise', 'NaT'}, default 'raise'</span>
            <span class="s0">The behavior is as follows:</span>

            <span class="s0">* bool contains flags to determine if time is dst or not (note</span>
              <span class="s0">that this flag is only applicable for ambiguous fall dst dates).</span>
            <span class="s0">* 'NaT' will return NaT for an ambiguous time.</span>
            <span class="s0">* 'raise' will raise an AmbiguousTimeError for an ambiguous time.</span>

        <span class="s0">nonexistent : {'raise', 'shift_forward', 'shift_backward, 'NaT', \</span>
<span class="s0">timedelta}, default 'raise'</span>
            <span class="s0">A nonexistent time does not exist in a particular timezone</span>
            <span class="s0">where clocks moved forward due to DST.</span>

            <span class="s0">* 'shift_forward' will shift the nonexistent time forward to the</span>
              <span class="s0">closest existing time.</span>
            <span class="s0">* 'shift_backward' will shift the nonexistent time backward to the</span>
              <span class="s0">closest existing time.</span>
            <span class="s0">* 'NaT' will return NaT where there are nonexistent times.</span>
            <span class="s0">* timedelta objects will shift nonexistent times by the timedelta.</span>
            <span class="s0">* 'raise' will raise an NonExistentTimeError if there are</span>
              <span class="s0">nonexistent times.</span>

        <span class="s0">Raises</span>
        <span class="s0">------</span>
        <span class="s0">ValueError if the freq cannot be converted.</span>

        <span class="s0">Notes</span>
        <span class="s0">-----</span>
        <span class="s0">If the Timestamp has a timezone, flooring will take place relative to the</span>
        <span class="s0">local (&quot;wall&quot;) time and re-localized to the same timezone. When flooring</span>
        <span class="s0">near daylight savings time, use ``nonexistent`` and ``ambiguous`` to</span>
        <span class="s0">control the re-localization behavior.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">Create a timestamp object:</span>

        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651')</span>

        <span class="s0">A timestamp can be floored using multiple frequency units:</span>

        <span class="s0">&gt;&gt;&gt; ts.floor(freq='H') # hour</span>
        <span class="s0">Timestamp('2020-03-14 15:00:00')</span>

        <span class="s0">&gt;&gt;&gt; ts.floor(freq='T') # minute</span>
        <span class="s0">Timestamp('2020-03-14 15:32:00')</span>

        <span class="s0">&gt;&gt;&gt; ts.floor(freq='S') # seconds</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52')</span>

        <span class="s0">&gt;&gt;&gt; ts.floor(freq='N') # nanoseconds</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52.192548651')</span>

        <span class="s0">``freq`` can also be a multiple of a single unit, like '5T' (i.e.  5 minutes):</span>

        <span class="s0">&gt;&gt;&gt; ts.floor(freq='5T')</span>
        <span class="s0">Timestamp('2020-03-14 15:30:00')</span>

        <span class="s0">or a combination of multiple units, like '1H30T' (i.e. 1 hour and 30 minutes):</span>

        <span class="s0">&gt;&gt;&gt; ts.floor(freq='1H30T')</span>
        <span class="s0">Timestamp('2020-03-14 15:00:00')</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.floor()</span>
        <span class="s0">NaT</span>

        <span class="s0">When rounding near a daylight savings time transition, use ``ambiguous`` or</span>
        <span class="s0">``nonexistent`` to control how the timestamp should be re-localized.</span>

        <span class="s0">&gt;&gt;&gt; ts_tz = pd.Timestamp(&quot;2021-10-31 03:30:00&quot;).tz_localize(&quot;Europe/Amsterdam&quot;)</span>

        <span class="s0">&gt;&gt;&gt; ts_tz.floor(&quot;2H&quot;, ambiguous=False)</span>
        <span class="s0">Timestamp('2021-10-31 02:00:00+0100', tz='Europe/Amsterdam')</span>

        <span class="s0">&gt;&gt;&gt; ts_tz.floor(&quot;2H&quot;, ambiguous=True)</span>
        <span class="s0">Timestamp('2021-10-31 02:00:00+0200', tz='Europe/Amsterdam')</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>
    <span class="s0">ceil = _make_nat_func(</span>
        <span class="s0">&quot;ceil&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return a new Timestamp ceiled to this resolution.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">freq : str</span>
            <span class="s0">Frequency string indicating the ceiling resolution.</span>
        <span class="s0">ambiguous : bool or {'raise', 'NaT'}, default 'raise'</span>
            <span class="s0">The behavior is as follows:</span>

            <span class="s0">* bool contains flags to determine if time is dst or not (note</span>
              <span class="s0">that this flag is only applicable for ambiguous fall dst dates).</span>
            <span class="s0">* 'NaT' will return NaT for an ambiguous time.</span>
            <span class="s0">* 'raise' will raise an AmbiguousTimeError for an ambiguous time.</span>

        <span class="s0">nonexistent : {'raise', 'shift_forward', 'shift_backward, 'NaT', \</span>
<span class="s0">timedelta}, default 'raise'</span>
            <span class="s0">A nonexistent time does not exist in a particular timezone</span>
            <span class="s0">where clocks moved forward due to DST.</span>

            <span class="s0">* 'shift_forward' will shift the nonexistent time forward to the</span>
              <span class="s0">closest existing time.</span>
            <span class="s0">* 'shift_backward' will shift the nonexistent time backward to the</span>
              <span class="s0">closest existing time.</span>
            <span class="s0">* 'NaT' will return NaT where there are nonexistent times.</span>
            <span class="s0">* timedelta objects will shift nonexistent times by the timedelta.</span>
            <span class="s0">* 'raise' will raise an NonExistentTimeError if there are</span>
              <span class="s0">nonexistent times.</span>

        <span class="s0">Raises</span>
        <span class="s0">------</span>
        <span class="s0">ValueError if the freq cannot be converted.</span>

        <span class="s0">Notes</span>
        <span class="s0">-----</span>
        <span class="s0">If the Timestamp has a timezone, ceiling will take place relative to the</span>
        <span class="s0">local (&quot;wall&quot;) time and re-localized to the same timezone. When ceiling</span>
        <span class="s0">near daylight savings time, use ``nonexistent`` and ``ambiguous`` to</span>
        <span class="s0">control the re-localization behavior.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">Create a timestamp object:</span>

        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651')</span>

        <span class="s0">A timestamp can be ceiled using multiple frequency units:</span>

        <span class="s0">&gt;&gt;&gt; ts.ceil(freq='H') # hour</span>
        <span class="s0">Timestamp('2020-03-14 16:00:00')</span>

        <span class="s0">&gt;&gt;&gt; ts.ceil(freq='T') # minute</span>
        <span class="s0">Timestamp('2020-03-14 15:33:00')</span>

        <span class="s0">&gt;&gt;&gt; ts.ceil(freq='S') # seconds</span>
        <span class="s0">Timestamp('2020-03-14 15:32:53')</span>

        <span class="s0">&gt;&gt;&gt; ts.ceil(freq='U') # microseconds</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52.192549')</span>

        <span class="s0">``freq`` can also be a multiple of a single unit, like '5T' (i.e.  5 minutes):</span>

        <span class="s0">&gt;&gt;&gt; ts.ceil(freq='5T')</span>
        <span class="s0">Timestamp('2020-03-14 15:35:00')</span>

        <span class="s0">or a combination of multiple units, like '1H30T' (i.e. 1 hour and 30 minutes):</span>

        <span class="s0">&gt;&gt;&gt; ts.ceil(freq='1H30T')</span>
        <span class="s0">Timestamp('2020-03-14 16:30:00')</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.ceil()</span>
        <span class="s0">NaT</span>

        <span class="s0">When rounding near a daylight savings time transition, use ``ambiguous`` or</span>
        <span class="s0">``nonexistent`` to control how the timestamp should be re-localized.</span>

        <span class="s0">&gt;&gt;&gt; ts_tz = pd.Timestamp(&quot;2021-10-31 01:30:00&quot;).tz_localize(&quot;Europe/Amsterdam&quot;)</span>

        <span class="s0">&gt;&gt;&gt; ts_tz.ceil(&quot;H&quot;, ambiguous=False)</span>
        <span class="s0">Timestamp('2021-10-31 02:00:00+0100', tz='Europe/Amsterdam')</span>

        <span class="s0">&gt;&gt;&gt; ts_tz.ceil(&quot;H&quot;, ambiguous=True)</span>
        <span class="s0">Timestamp('2021-10-31 02:00:00+0200', tz='Europe/Amsterdam')</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>

    <span class="s0">tz_convert = _make_nat_func(</span>
        <span class="s0">&quot;tz_convert&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Convert timezone-aware Timestamp to another time zone.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">tz : str, pytz.timezone, dateutil.tz.tzfile or None</span>
            <span class="s0">Time zone for time which Timestamp will be converted to.</span>
            <span class="s0">None will remove timezone holding UTC time.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">converted : Timestamp</span>

        <span class="s0">Raises</span>
        <span class="s0">------</span>
        <span class="s0">TypeError</span>
            <span class="s0">If Timestamp is tz-naive.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">Create a timestamp object with UTC timezone:</span>

        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651', tz='UTC')</span>
        <span class="s0">&gt;&gt;&gt; ts</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52.192548651+0000', tz='UTC')</span>

        <span class="s0">Change to Tokyo timezone:</span>

        <span class="s0">&gt;&gt;&gt; ts.tz_convert(tz='Asia/Tokyo')</span>
        <span class="s0">Timestamp('2020-03-15 00:32:52.192548651+0900', tz='Asia/Tokyo')</span>

        <span class="s0">Can also use ``astimezone``:</span>

        <span class="s0">&gt;&gt;&gt; ts.astimezone(tz='Asia/Tokyo')</span>
        <span class="s0">Timestamp('2020-03-15 00:32:52.192548651+0900', tz='Asia/Tokyo')</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.tz_convert(tz='Asia/Tokyo')</span>
        <span class="s0">NaT</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>
    <span class="s0">tz_localize = _make_nat_func(</span>
        <span class="s0">&quot;tz_localize&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Convert naive Timestamp to local time zone, or remove</span>
        <span class="s0">timezone from timezone-aware Timestamp.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">tz : str, pytz.timezone, dateutil.tz.tzfile or None</span>
            <span class="s0">Time zone for time which Timestamp will be converted to.</span>
            <span class="s0">None will remove timezone holding local time.</span>

        <span class="s0">ambiguous : bool, 'NaT', default 'raise'</span>
            <span class="s0">When clocks moved backward due to DST, ambiguous times may arise.</span>
            <span class="s0">For example in Central European Time (UTC+01), when going from</span>
            <span class="s0">03:00 DST to 02:00 non-DST, 02:30:00 local time occurs both at</span>
            <span class="s0">00:30:00 UTC and at 01:30:00 UTC. In such a situation, the</span>
            <span class="s0">`ambiguous` parameter dictates how ambiguous times should be</span>
            <span class="s0">handled.</span>

            <span class="s0">The behavior is as follows:</span>

            <span class="s0">* bool contains flags to determine if time is dst or not (note</span>
              <span class="s0">that this flag is only applicable for ambiguous fall dst dates).</span>
            <span class="s0">* 'NaT' will return NaT for an ambiguous time.</span>
            <span class="s0">* 'raise' will raise an AmbiguousTimeError for an ambiguous time.</span>

        <span class="s0">nonexistent : 'shift_forward', 'shift_backward, 'NaT', timedelta, \</span>
<span class="s0">default 'raise'</span>
            <span class="s0">A nonexistent time does not exist in a particular timezone</span>
            <span class="s0">where clocks moved forward due to DST.</span>

            <span class="s0">The behavior is as follows:</span>

            <span class="s0">* 'shift_forward' will shift the nonexistent time forward to the</span>
              <span class="s0">closest existing time.</span>
            <span class="s0">* 'shift_backward' will shift the nonexistent time backward to the</span>
              <span class="s0">closest existing time.</span>
            <span class="s0">* 'NaT' will return NaT where there are nonexistent times.</span>
            <span class="s0">* timedelta objects will shift nonexistent times by the timedelta.</span>
            <span class="s0">* 'raise' will raise an NonExistentTimeError if there are</span>
              <span class="s0">nonexistent times.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">localized : Timestamp</span>

        <span class="s0">Raises</span>
        <span class="s0">------</span>
        <span class="s0">TypeError</span>
            <span class="s0">If the Timestamp is tz-aware and tz is not None.</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">Create a naive timestamp object:</span>

        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651')</span>
        <span class="s0">&gt;&gt;&gt; ts</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52.192548651')</span>

        <span class="s0">Add 'Europe/Stockholm' as timezone:</span>

        <span class="s0">&gt;&gt;&gt; ts.tz_localize(tz='Europe/Stockholm')</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52.192548651+0100', tz='Europe/Stockholm')</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.tz_localize()</span>
        <span class="s0">NaT</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>
    <span class="s0">replace = _make_nat_func(</span>
        <span class="s0">&quot;replace&quot;,</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Implements datetime.replace, handles nanoseconds.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">year : int, optional</span>
        <span class="s0">month : int, optional</span>
        <span class="s0">day : int, optional</span>
        <span class="s0">hour : int, optional</span>
        <span class="s0">minute : int, optional</span>
        <span class="s0">second : int, optional</span>
        <span class="s0">microsecond : int, optional</span>
        <span class="s0">nanosecond : int, optional</span>
        <span class="s0">tzinfo : tz-convertible, optional</span>
        <span class="s0">fold : int, optional</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">Timestamp with fields replaced</span>

        <span class="s0">Examples</span>
        <span class="s0">--------</span>
        <span class="s0">Create a timestamp object:</span>

        <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-03-14T15:32:52.192548651', tz='UTC')</span>
        <span class="s0">&gt;&gt;&gt; ts</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52.192548651+0000', tz='UTC')</span>

        <span class="s0">Replace year and the hour:</span>

        <span class="s0">&gt;&gt;&gt; ts.replace(year=1999, hour=10)</span>
        <span class="s0">Timestamp('1999-03-14 10:32:52.192548651+0000', tz='UTC')</span>

        <span class="s0">Replace timezone (not a conversion):</span>

        <span class="s0">&gt;&gt;&gt; import pytz</span>
        <span class="s0">&gt;&gt;&gt; ts.replace(tzinfo=pytz.timezone('US/Pacific'))</span>
        <span class="s0">Timestamp('2020-03-14 15:32:52.192548651-0700', tz='US/Pacific')</span>

        <span class="s0">Analogous for ``pd.NaT``:</span>

        <span class="s0">&gt;&gt;&gt; pd.NaT.replace(tzinfo=pytz.timezone('US/Pacific'))</span>
        <span class="s0">NaT</span>
        <span class="s0">&quot;&quot;&quot;,</span>
    <span class="s0">)</span>


<span class="s0">c_NaT = NaTType()  # C-visible</span>
<span class="s0">NaT = c_NaT        # Python-visible</span>


<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0">cdef inline bint checknull_with_nat(object val):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Utility to check if a value is a nat or not.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">return val is None or util.is_nan(val) or val is c_NaT</span>


<span class="s0">cdef inline bint is_dt64nat(object val):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Is this a np.datetime64 object np.datetime64(&quot;NaT&quot;).</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if util.is_datetime64_object(val):</span>
        <span class="s0">return get_datetime64_value(val) == NPY_NAT</span>
    <span class="s0">return False</span>


<span class="s0">cdef inline bint is_td64nat(object val):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Is this a np.timedelta64 object np.timedelta64(&quot;NaT&quot;).</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if util.is_timedelta64_object(val):</span>
        <span class="s0">return get_timedelta64_value(val) == NPY_NAT</span>
    <span class="s0">return False</span>
</pre>
</body>
</html>