<html>
<head>
<title>defmatrix.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
defmatrix.py</font>
</center></td></tr></table>
<pre><span class="s0">__all__ = [</span><span class="s1">'matrix'</span><span class="s2">, </span><span class="s1">'bmat'</span><span class="s2">, </span><span class="s1">'mat'</span><span class="s2">, </span><span class="s1">'asmatrix'</span><span class="s0">]</span>

<span class="s2">import </span><span class="s0">sys</span>
<span class="s2">import </span><span class="s0">warnings</span>
<span class="s2">import </span><span class="s0">ast</span>
<span class="s2">import </span><span class="s0">numpy.core.numeric </span><span class="s2">as </span><span class="s0">N</span>
<span class="s2">from </span><span class="s0">numpy.core.numeric </span><span class="s2">import </span><span class="s0">concatenate</span><span class="s2">, </span><span class="s0">isscalar</span>
<span class="s2">from </span><span class="s0">numpy.core.overrides </span><span class="s2">import </span><span class="s0">set_module</span>
<span class="s3"># While not in __all__, matrix_power used to be defined here, so we import</span>
<span class="s3"># it for backward compatibility.</span>
<span class="s2">from </span><span class="s0">numpy.linalg </span><span class="s2">import </span><span class="s0">matrix_power</span>


<span class="s2">def </span><span class="s0">_convert_from_string(data):</span>
    <span class="s2">for </span><span class="s0">char </span><span class="s2">in </span><span class="s1">'[]'</span><span class="s0">:</span>
        <span class="s0">data = data.replace(char</span><span class="s2">, </span><span class="s1">''</span><span class="s0">)</span>

    <span class="s0">rows = data.split(</span><span class="s1">';'</span><span class="s0">)</span>
    <span class="s0">newdata = []</span>
    <span class="s0">count = </span><span class="s4">0</span>
    <span class="s2">for </span><span class="s0">row </span><span class="s2">in </span><span class="s0">rows:</span>
        <span class="s0">trow = row.split(</span><span class="s1">','</span><span class="s0">)</span>
        <span class="s0">newrow = []</span>
        <span class="s2">for </span><span class="s0">col </span><span class="s2">in </span><span class="s0">trow:</span>
            <span class="s0">temp = col.split()</span>
            <span class="s0">newrow.extend(map(ast.literal_eval</span><span class="s2">, </span><span class="s0">temp))</span>
        <span class="s2">if </span><span class="s0">count == </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s0">Ncols = len(newrow)</span>
        <span class="s2">elif </span><span class="s0">len(newrow) != Ncols:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;Rows not the same size.&quot;</span><span class="s0">)</span>
        <span class="s0">count += </span><span class="s4">1</span>
        <span class="s0">newdata.append(newrow)</span>
    <span class="s2">return </span><span class="s0">newdata</span>


<span class="s0">@set_module(</span><span class="s1">'numpy'</span><span class="s0">)</span>
<span class="s2">def </span><span class="s0">asmatrix(data</span><span class="s2">, </span><span class="s0">dtype=</span><span class="s2">None</span><span class="s0">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Interpret the input as a matrix. 
 
    Unlike `matrix`, `asmatrix` does not make a copy if the input is already 
    a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``. 
 
    Parameters 
    ---------- 
    data : array_like 
        Input data. 
    dtype : data-type 
       Data-type of the output matrix. 
 
    Returns 
    ------- 
    mat : matrix 
        `data` interpreted as a matrix. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; x = np.array([[1, 2], [3, 4]]) 
 
    &gt;&gt;&gt; m = np.asmatrix(x) 
 
    &gt;&gt;&gt; x[0,0] = 5 
 
    &gt;&gt;&gt; m 
    matrix([[5, 2], 
            [3, 4]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s0">matrix(data</span><span class="s2">, </span><span class="s0">dtype=dtype</span><span class="s2">, </span><span class="s0">copy=</span><span class="s2">False</span><span class="s0">)</span>


<span class="s0">@set_module(</span><span class="s1">'numpy'</span><span class="s0">)</span>
<span class="s2">class </span><span class="s0">matrix(N.ndarray):</span>
    <span class="s5">&quot;&quot;&quot; 
    matrix(data, dtype=None, copy=True) 
 
    .. note:: It is no longer recommended to use this class, even for linear 
              algebra. Instead use regular arrays. The class may be removed 
              in the future. 
 
    Returns a matrix from an array-like object, or from a string of data. 
    A matrix is a specialized 2-D array that retains its 2-D nature 
    through operations.  It has certain special operators, such as ``*`` 
    (matrix multiplication) and ``**`` (matrix power). 
 
    Parameters 
    ---------- 
    data : array_like or string 
       If `data` is a string, it is interpreted as a matrix with commas 
       or spaces separating columns, and semicolons separating rows. 
    dtype : data-type 
       Data-type of the output matrix. 
    copy : bool 
       If `data` is already an `ndarray`, then this flag determines 
       whether the data is copied (the default), or whether a view is 
       constructed. 
 
    See Also 
    -------- 
    array 
 
    Examples 
    -------- 
    &gt;&gt;&gt; a = np.matrix('1 2; 3 4') 
    &gt;&gt;&gt; a 
    matrix([[1, 2], 
            [3, 4]]) 
 
    &gt;&gt;&gt; np.matrix([[1, 2], [3, 4]]) 
    matrix([[1, 2], 
            [3, 4]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s0">__array_priority__ = </span><span class="s4">10.0</span>
    <span class="s2">def </span><span class="s0">__new__(subtype</span><span class="s2">, </span><span class="s0">data</span><span class="s2">, </span><span class="s0">dtype=</span><span class="s2">None, </span><span class="s0">copy=</span><span class="s2">True</span><span class="s0">):</span>
        <span class="s0">warnings.warn(</span><span class="s1">'the matrix subclass is not the recommended way to '</span>
                      <span class="s1">'represent matrices or deal with linear algebra (see '</span>
                      <span class="s1">'https://docs.scipy.org/doc/numpy/user/'</span>
                      <span class="s1">'numpy-for-matlab-users.html). '</span>
                      <span class="s1">'Please adjust your code to use regular ndarray.'</span><span class="s2">,</span>
                      <span class="s0">PendingDeprecationWarning</span><span class="s2">, </span><span class="s0">stacklevel=</span><span class="s4">2</span><span class="s0">)</span>
        <span class="s2">if </span><span class="s0">isinstance(data</span><span class="s2">, </span><span class="s0">matrix):</span>
            <span class="s0">dtype2 = data.dtype</span>
            <span class="s2">if </span><span class="s0">(dtype </span><span class="s2">is None</span><span class="s0">):</span>
                <span class="s0">dtype = dtype2</span>
            <span class="s2">if </span><span class="s0">(dtype2 == dtype) </span><span class="s2">and </span><span class="s0">(</span><span class="s2">not </span><span class="s0">copy):</span>
                <span class="s2">return </span><span class="s0">data</span>
            <span class="s2">return </span><span class="s0">data.astype(dtype)</span>

        <span class="s2">if </span><span class="s0">isinstance(data</span><span class="s2">, </span><span class="s0">N.ndarray):</span>
            <span class="s2">if </span><span class="s0">dtype </span><span class="s2">is None</span><span class="s0">:</span>
                <span class="s0">intype = data.dtype</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s0">intype = N.dtype(dtype)</span>
            <span class="s0">new = data.view(subtype)</span>
            <span class="s2">if </span><span class="s0">intype != data.dtype:</span>
                <span class="s2">return </span><span class="s0">new.astype(intype)</span>
            <span class="s2">if </span><span class="s0">copy: </span><span class="s2">return </span><span class="s0">new.copy()</span>
            <span class="s2">else</span><span class="s0">: </span><span class="s2">return </span><span class="s0">new</span>

        <span class="s2">if </span><span class="s0">isinstance(data</span><span class="s2">, </span><span class="s0">str):</span>
            <span class="s0">data = _convert_from_string(data)</span>

        <span class="s3"># now convert data to an array</span>
        <span class="s0">arr = N.array(data</span><span class="s2">, </span><span class="s0">dtype=dtype</span><span class="s2">, </span><span class="s0">copy=copy)</span>
        <span class="s0">ndim = arr.ndim</span>
        <span class="s0">shape = arr.shape</span>
        <span class="s2">if </span><span class="s0">(ndim &gt; </span><span class="s4">2</span><span class="s0">):</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;matrix must be 2-dimensional&quot;</span><span class="s0">)</span>
        <span class="s2">elif </span><span class="s0">ndim == </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s0">shape = (</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s0">)</span>
        <span class="s2">elif </span><span class="s0">ndim == </span><span class="s4">1</span><span class="s0">:</span>
            <span class="s0">shape = (</span><span class="s4">1</span><span class="s2">, </span><span class="s0">shape[</span><span class="s4">0</span><span class="s0">])</span>

        <span class="s0">order = </span><span class="s1">'C'</span>
        <span class="s2">if </span><span class="s0">(ndim == </span><span class="s4">2</span><span class="s0">) </span><span class="s2">and </span><span class="s0">arr.flags.fortran:</span>
            <span class="s0">order = </span><span class="s1">'F'</span>

        <span class="s2">if not </span><span class="s0">(order </span><span class="s2">or </span><span class="s0">arr.flags.contiguous):</span>
            <span class="s0">arr = arr.copy()</span>

        <span class="s0">ret = N.ndarray.__new__(subtype</span><span class="s2">, </span><span class="s0">shape</span><span class="s2">, </span><span class="s0">arr.dtype</span><span class="s2">,</span>
                                <span class="s0">buffer=arr</span><span class="s2">,</span>
                                <span class="s0">order=order)</span>
        <span class="s2">return </span><span class="s0">ret</span>

    <span class="s2">def </span><span class="s0">__array_finalize__(self</span><span class="s2">, </span><span class="s0">obj):</span>
        <span class="s0">self._getitem = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s0">(isinstance(obj</span><span class="s2">, </span><span class="s0">matrix) </span><span class="s2">and </span><span class="s0">obj._getitem): </span><span class="s2">return</span>
        <span class="s0">ndim = self.ndim</span>
        <span class="s2">if </span><span class="s0">(ndim == </span><span class="s4">2</span><span class="s0">):</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s0">(ndim &gt; </span><span class="s4">2</span><span class="s0">):</span>
            <span class="s0">newshape = tuple([x </span><span class="s2">for </span><span class="s0">x </span><span class="s2">in </span><span class="s0">self.shape </span><span class="s2">if </span><span class="s0">x &gt; </span><span class="s4">1</span><span class="s0">])</span>
            <span class="s0">ndim = len(newshape)</span>
            <span class="s2">if </span><span class="s0">ndim == </span><span class="s4">2</span><span class="s0">:</span>
                <span class="s0">self.shape = newshape</span>
                <span class="s2">return</span>
            <span class="s2">elif </span><span class="s0">(ndim &gt; </span><span class="s4">2</span><span class="s0">):</span>
                <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;shape too large to be a matrix.&quot;</span><span class="s0">)</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">newshape = self.shape</span>
        <span class="s2">if </span><span class="s0">ndim == </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s0">self.shape = (</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s0">)</span>
        <span class="s2">elif </span><span class="s0">ndim == </span><span class="s4">1</span><span class="s0">:</span>
            <span class="s0">self.shape = (</span><span class="s4">1</span><span class="s2">, </span><span class="s0">newshape[</span><span class="s4">0</span><span class="s0">])</span>
        <span class="s2">return</span>

    <span class="s2">def </span><span class="s0">__getitem__(self</span><span class="s2">, </span><span class="s0">index):</span>
        <span class="s0">self._getitem = </span><span class="s2">True</span>

        <span class="s2">try</span><span class="s0">:</span>
            <span class="s0">out = N.ndarray.__getitem__(self</span><span class="s2">, </span><span class="s0">index)</span>
        <span class="s2">finally</span><span class="s0">:</span>
            <span class="s0">self._getitem = </span><span class="s2">False</span>

        <span class="s2">if not </span><span class="s0">isinstance(out</span><span class="s2">, </span><span class="s0">N.ndarray):</span>
            <span class="s2">return </span><span class="s0">out</span>

        <span class="s2">if </span><span class="s0">out.ndim == </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">out[()]</span>
        <span class="s2">if </span><span class="s0">out.ndim == </span><span class="s4">1</span><span class="s0">:</span>
            <span class="s0">sh = out.shape[</span><span class="s4">0</span><span class="s0">]</span>
            <span class="s3"># Determine when we should have a column array</span>
            <span class="s2">try</span><span class="s0">:</span>
                <span class="s0">n = len(index)</span>
            <span class="s2">except </span><span class="s0">Exception:</span>
                <span class="s0">n = </span><span class="s4">0</span>
            <span class="s2">if </span><span class="s0">n &gt; </span><span class="s4">1 </span><span class="s2">and </span><span class="s0">isscalar(index[</span><span class="s4">1</span><span class="s0">]):</span>
                <span class="s0">out.shape = (sh</span><span class="s2">, </span><span class="s4">1</span><span class="s0">)</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s0">out.shape = (</span><span class="s4">1</span><span class="s2">, </span><span class="s0">sh)</span>
        <span class="s2">return </span><span class="s0">out</span>

    <span class="s2">def </span><span class="s0">__mul__(self</span><span class="s2">, </span><span class="s0">other):</span>
        <span class="s2">if </span><span class="s0">isinstance(other</span><span class="s2">, </span><span class="s0">(N.ndarray</span><span class="s2">, </span><span class="s0">list</span><span class="s2">, </span><span class="s0">tuple)) :</span>
            <span class="s3"># This promotes 1-D vectors to row vectors</span>
            <span class="s2">return </span><span class="s0">N.dot(self</span><span class="s2">, </span><span class="s0">asmatrix(other))</span>
        <span class="s2">if </span><span class="s0">isscalar(other) </span><span class="s2">or not </span><span class="s0">hasattr(other</span><span class="s2">, </span><span class="s1">'__rmul__'</span><span class="s0">) :</span>
            <span class="s2">return </span><span class="s0">N.dot(self</span><span class="s2">, </span><span class="s0">other)</span>
        <span class="s2">return </span><span class="s0">NotImplemented</span>

    <span class="s2">def </span><span class="s0">__rmul__(self</span><span class="s2">, </span><span class="s0">other):</span>
        <span class="s2">return </span><span class="s0">N.dot(other</span><span class="s2">, </span><span class="s0">self)</span>

    <span class="s2">def </span><span class="s0">__imul__(self</span><span class="s2">, </span><span class="s0">other):</span>
        <span class="s0">self[:] = self * other</span>
        <span class="s2">return </span><span class="s0">self</span>

    <span class="s2">def </span><span class="s0">__pow__(self</span><span class="s2">, </span><span class="s0">other):</span>
        <span class="s2">return </span><span class="s0">matrix_power(self</span><span class="s2">, </span><span class="s0">other)</span>

    <span class="s2">def </span><span class="s0">__ipow__(self</span><span class="s2">, </span><span class="s0">other):</span>
        <span class="s0">self[:] = self ** other</span>
        <span class="s2">return </span><span class="s0">self</span>

    <span class="s2">def </span><span class="s0">__rpow__(self</span><span class="s2">, </span><span class="s0">other):</span>
        <span class="s2">return </span><span class="s0">NotImplemented</span>

    <span class="s2">def </span><span class="s0">_align(self</span><span class="s2">, </span><span class="s0">axis):</span>
        <span class="s5">&quot;&quot;&quot;A convenience function for operations that need to preserve axis 
        orientation. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s0">axis </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">self[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s0">]</span>
        <span class="s2">elif </span><span class="s0">axis==</span><span class="s4">0</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">self</span>
        <span class="s2">elif </span><span class="s0">axis==</span><span class="s4">1</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">self.transpose()</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;unsupported axis&quot;</span><span class="s0">)</span>

    <span class="s2">def </span><span class="s0">_collapse(self</span><span class="s2">, </span><span class="s0">axis):</span>
        <span class="s5">&quot;&quot;&quot;A convenience function for operations that want to collapse 
        to a scalar like _align, but are using keepdims=True 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s0">axis </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">self[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s0">]</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">self</span>

    <span class="s3"># Necessary because base-class tolist expects dimension</span>
    <span class="s3">#  reduction by x[0]</span>
    <span class="s2">def </span><span class="s0">tolist(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the matrix as a (possibly nested) list. 
 
        See `ndarray.tolist` for full documentation. 
 
        See Also 
        -------- 
        ndarray.tolist 
 
        Examples 
        -------- 
        &gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4))); x 
        matrix([[ 0,  1,  2,  3], 
                [ 4,  5,  6,  7], 
                [ 8,  9, 10, 11]]) 
        &gt;&gt;&gt; x.tolist() 
        [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]] 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">self.__array__().tolist()</span>

    <span class="s3"># To preserve orientation of result...</span>
    <span class="s2">def </span><span class="s0">sum(self</span><span class="s2">, </span><span class="s0">axis=</span><span class="s2">None, </span><span class="s0">dtype=</span><span class="s2">None, </span><span class="s0">out=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the sum of the matrix elements, along the given axis. 
 
        Refer to `numpy.sum` for full documentation. 
 
        See Also 
        -------- 
        numpy.sum 
 
        Notes 
        ----- 
        This is the same as `ndarray.sum`, except that where an `ndarray` would 
        be returned, a `matrix` object is returned instead. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; x = np.matrix([[1, 2], [4, 3]]) 
        &gt;&gt;&gt; x.sum() 
        10 
        &gt;&gt;&gt; x.sum(axis=1) 
        matrix([[3], 
                [7]]) 
        &gt;&gt;&gt; x.sum(axis=1, dtype='float') 
        matrix([[3.], 
                [7.]]) 
        &gt;&gt;&gt; out = np.zeros((2, 1), dtype='float') 
        &gt;&gt;&gt; x.sum(axis=1, dtype='float', out=np.asmatrix(out)) 
        matrix([[3.], 
                [7.]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">N.ndarray.sum(self</span><span class="s2">, </span><span class="s0">axis</span><span class="s2">, </span><span class="s0">dtype</span><span class="s2">, </span><span class="s0">out</span><span class="s2">, </span><span class="s0">keepdims=</span><span class="s2">True</span><span class="s0">)._collapse(axis)</span>


    <span class="s3"># To update docstring from array to matrix...</span>
    <span class="s2">def </span><span class="s0">squeeze(self</span><span class="s2">, </span><span class="s0">axis=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return a possibly reshaped matrix. 
 
        Refer to `numpy.squeeze` for more documentation. 
 
        Parameters 
        ---------- 
        axis : None or int or tuple of ints, optional 
            Selects a subset of the axes of length one in the shape. 
            If an axis is selected with shape entry greater than one, 
            an error is raised. 
 
        Returns 
        ------- 
        squeezed : matrix 
            The matrix, but as a (1, N) matrix if it had shape (N, 1). 
 
        See Also 
        -------- 
        numpy.squeeze : related function 
 
        Notes 
        ----- 
        If `m` has a single column then that column is returned 
        as the single row of a matrix.  Otherwise `m` is returned. 
        The returned matrix is always either `m` itself or a view into `m`. 
        Supplying an axis keyword argument will not affect the returned matrix 
        but it may cause an error to be raised. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; c = np.matrix([[1], [2]]) 
        &gt;&gt;&gt; c 
        matrix([[1], 
                [2]]) 
        &gt;&gt;&gt; c.squeeze() 
        matrix([[1, 2]]) 
        &gt;&gt;&gt; r = c.T 
        &gt;&gt;&gt; r 
        matrix([[1, 2]]) 
        &gt;&gt;&gt; r.squeeze() 
        matrix([[1, 2]]) 
        &gt;&gt;&gt; m = np.matrix([[1, 2], [3, 4]]) 
        &gt;&gt;&gt; m.squeeze() 
        matrix([[1, 2], 
                [3, 4]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">N.ndarray.squeeze(self</span><span class="s2">, </span><span class="s0">axis=axis)</span>


    <span class="s3"># To update docstring from array to matrix...</span>
    <span class="s2">def </span><span class="s0">flatten(self</span><span class="s2">, </span><span class="s0">order=</span><span class="s1">'C'</span><span class="s0">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return a flattened copy of the matrix. 
 
        All `N` elements of the matrix are placed into a single row. 
 
        Parameters 
        ---------- 
        order : {'C', 'F', 'A', 'K'}, optional 
            'C' means to flatten in row-major (C-style) order. 'F' means to 
            flatten in column-major (Fortran-style) order. 'A' means to 
            flatten in column-major order if `m` is Fortran *contiguous* in 
            memory, row-major order otherwise. 'K' means to flatten `m` in 
            the order the elements occur in memory. The default is 'C'. 
 
        Returns 
        ------- 
        y : matrix 
            A copy of the matrix, flattened to a `(1, N)` matrix where `N` 
            is the number of elements in the original matrix. 
 
        See Also 
        -------- 
        ravel : Return a flattened array. 
        flat : A 1-D flat iterator over the matrix. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; m = np.matrix([[1,2], [3,4]]) 
        &gt;&gt;&gt; m.flatten() 
        matrix([[1, 2, 3, 4]]) 
        &gt;&gt;&gt; m.flatten('F') 
        matrix([[1, 3, 2, 4]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">N.ndarray.flatten(self</span><span class="s2">, </span><span class="s0">order=order)</span>

    <span class="s2">def </span><span class="s0">mean(self</span><span class="s2">, </span><span class="s0">axis=</span><span class="s2">None, </span><span class="s0">dtype=</span><span class="s2">None, </span><span class="s0">out=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the average of the matrix elements along the given axis. 
 
        Refer to `numpy.mean` for full documentation. 
 
        See Also 
        -------- 
        numpy.mean 
 
        Notes 
        ----- 
        Same as `ndarray.mean` except that, where that returns an `ndarray`, 
        this returns a `matrix` object. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3, 4))) 
        &gt;&gt;&gt; x 
        matrix([[ 0,  1,  2,  3], 
                [ 4,  5,  6,  7], 
                [ 8,  9, 10, 11]]) 
        &gt;&gt;&gt; x.mean() 
        5.5 
        &gt;&gt;&gt; x.mean(0) 
        matrix([[4., 5., 6., 7.]]) 
        &gt;&gt;&gt; x.mean(1) 
        matrix([[ 1.5], 
                [ 5.5], 
                [ 9.5]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">N.ndarray.mean(self</span><span class="s2">, </span><span class="s0">axis</span><span class="s2">, </span><span class="s0">dtype</span><span class="s2">, </span><span class="s0">out</span><span class="s2">, </span><span class="s0">keepdims=</span><span class="s2">True</span><span class="s0">)._collapse(axis)</span>

    <span class="s2">def </span><span class="s0">std(self</span><span class="s2">, </span><span class="s0">axis=</span><span class="s2">None, </span><span class="s0">dtype=</span><span class="s2">None, </span><span class="s0">out=</span><span class="s2">None, </span><span class="s0">ddof=</span><span class="s4">0</span><span class="s0">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the standard deviation of the array elements along the given axis. 
 
        Refer to `numpy.std` for full documentation. 
 
        See Also 
        -------- 
        numpy.std 
 
        Notes 
        ----- 
        This is the same as `ndarray.std`, except that where an `ndarray` would 
        be returned, a `matrix` object is returned instead. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3, 4))) 
        &gt;&gt;&gt; x 
        matrix([[ 0,  1,  2,  3], 
                [ 4,  5,  6,  7], 
                [ 8,  9, 10, 11]]) 
        &gt;&gt;&gt; x.std() 
        3.4520525295346629 # may vary 
        &gt;&gt;&gt; x.std(0) 
        matrix([[ 3.26598632,  3.26598632,  3.26598632,  3.26598632]]) # may vary 
        &gt;&gt;&gt; x.std(1) 
        matrix([[ 1.11803399], 
                [ 1.11803399], 
                [ 1.11803399]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">N.ndarray.std(self</span><span class="s2">, </span><span class="s0">axis</span><span class="s2">, </span><span class="s0">dtype</span><span class="s2">, </span><span class="s0">out</span><span class="s2">, </span><span class="s0">ddof</span><span class="s2">, </span><span class="s0">keepdims=</span><span class="s2">True</span><span class="s0">)._collapse(axis)</span>

    <span class="s2">def </span><span class="s0">var(self</span><span class="s2">, </span><span class="s0">axis=</span><span class="s2">None, </span><span class="s0">dtype=</span><span class="s2">None, </span><span class="s0">out=</span><span class="s2">None, </span><span class="s0">ddof=</span><span class="s4">0</span><span class="s0">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the variance of the matrix elements, along the given axis. 
 
        Refer to `numpy.var` for full documentation. 
 
        See Also 
        -------- 
        numpy.var 
 
        Notes 
        ----- 
        This is the same as `ndarray.var`, except that where an `ndarray` would 
        be returned, a `matrix` object is returned instead. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3, 4))) 
        &gt;&gt;&gt; x 
        matrix([[ 0,  1,  2,  3], 
                [ 4,  5,  6,  7], 
                [ 8,  9, 10, 11]]) 
        &gt;&gt;&gt; x.var() 
        11.916666666666666 
        &gt;&gt;&gt; x.var(0) 
        matrix([[ 10.66666667,  10.66666667,  10.66666667,  10.66666667]]) # may vary 
        &gt;&gt;&gt; x.var(1) 
        matrix([[1.25], 
                [1.25], 
                [1.25]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">N.ndarray.var(self</span><span class="s2">, </span><span class="s0">axis</span><span class="s2">, </span><span class="s0">dtype</span><span class="s2">, </span><span class="s0">out</span><span class="s2">, </span><span class="s0">ddof</span><span class="s2">, </span><span class="s0">keepdims=</span><span class="s2">True</span><span class="s0">)._collapse(axis)</span>

    <span class="s2">def </span><span class="s0">prod(self</span><span class="s2">, </span><span class="s0">axis=</span><span class="s2">None, </span><span class="s0">dtype=</span><span class="s2">None, </span><span class="s0">out=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the product of the array elements over the given axis. 
 
        Refer to `prod` for full documentation. 
 
        See Also 
        -------- 
        prod, ndarray.prod 
 
        Notes 
        ----- 
        Same as `ndarray.prod`, except, where that returns an `ndarray`, this 
        returns a `matrix` object instead. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4))); x 
        matrix([[ 0,  1,  2,  3], 
                [ 4,  5,  6,  7], 
                [ 8,  9, 10, 11]]) 
        &gt;&gt;&gt; x.prod() 
        0 
        &gt;&gt;&gt; x.prod(0) 
        matrix([[  0,  45, 120, 231]]) 
        &gt;&gt;&gt; x.prod(1) 
        matrix([[   0], 
                [ 840], 
                [7920]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">N.ndarray.prod(self</span><span class="s2">, </span><span class="s0">axis</span><span class="s2">, </span><span class="s0">dtype</span><span class="s2">, </span><span class="s0">out</span><span class="s2">, </span><span class="s0">keepdims=</span><span class="s2">True</span><span class="s0">)._collapse(axis)</span>

    <span class="s2">def </span><span class="s0">any(self</span><span class="s2">, </span><span class="s0">axis=</span><span class="s2">None, </span><span class="s0">out=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Test whether any array element along a given axis evaluates to True. 
 
        Refer to `numpy.any` for full documentation. 
 
        Parameters 
        ---------- 
        axis : int, optional 
            Axis along which logical OR is performed 
        out : ndarray, optional 
            Output to existing array instead of creating new one, must have 
            same shape as expected output 
 
        Returns 
        ------- 
            any : bool, ndarray 
                Returns a single bool if `axis` is ``None``; otherwise, 
                returns `ndarray` 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">N.ndarray.any(self</span><span class="s2">, </span><span class="s0">axis</span><span class="s2">, </span><span class="s0">out</span><span class="s2">, </span><span class="s0">keepdims=</span><span class="s2">True</span><span class="s0">)._collapse(axis)</span>

    <span class="s2">def </span><span class="s0">all(self</span><span class="s2">, </span><span class="s0">axis=</span><span class="s2">None, </span><span class="s0">out=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Test whether all matrix elements along a given axis evaluate to True. 
 
        Parameters 
        ---------- 
        See `numpy.all` for complete descriptions 
 
        See Also 
        -------- 
        numpy.all 
 
        Notes 
        ----- 
        This is the same as `ndarray.all`, but it returns a `matrix` object. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4))); x 
        matrix([[ 0,  1,  2,  3], 
                [ 4,  5,  6,  7], 
                [ 8,  9, 10, 11]]) 
        &gt;&gt;&gt; y = x[0]; y 
        matrix([[0, 1, 2, 3]]) 
        &gt;&gt;&gt; (x == y) 
        matrix([[ True,  True,  True,  True], 
                [False, False, False, False], 
                [False, False, False, False]]) 
        &gt;&gt;&gt; (x == y).all() 
        False 
        &gt;&gt;&gt; (x == y).all(0) 
        matrix([[False, False, False, False]]) 
        &gt;&gt;&gt; (x == y).all(1) 
        matrix([[ True], 
                [False], 
                [False]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">N.ndarray.all(self</span><span class="s2">, </span><span class="s0">axis</span><span class="s2">, </span><span class="s0">out</span><span class="s2">, </span><span class="s0">keepdims=</span><span class="s2">True</span><span class="s0">)._collapse(axis)</span>

    <span class="s2">def </span><span class="s0">max(self</span><span class="s2">, </span><span class="s0">axis=</span><span class="s2">None, </span><span class="s0">out=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the maximum value along an axis. 
 
        Parameters 
        ---------- 
        See `amax` for complete descriptions 
 
        See Also 
        -------- 
        amax, ndarray.max 
 
        Notes 
        ----- 
        This is the same as `ndarray.max`, but returns a `matrix` object 
        where `ndarray.max` would return an ndarray. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4))); x 
        matrix([[ 0,  1,  2,  3], 
                [ 4,  5,  6,  7], 
                [ 8,  9, 10, 11]]) 
        &gt;&gt;&gt; x.max() 
        11 
        &gt;&gt;&gt; x.max(0) 
        matrix([[ 8,  9, 10, 11]]) 
        &gt;&gt;&gt; x.max(1) 
        matrix([[ 3], 
                [ 7], 
                [11]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">N.ndarray.max(self</span><span class="s2">, </span><span class="s0">axis</span><span class="s2">, </span><span class="s0">out</span><span class="s2">, </span><span class="s0">keepdims=</span><span class="s2">True</span><span class="s0">)._collapse(axis)</span>

    <span class="s2">def </span><span class="s0">argmax(self</span><span class="s2">, </span><span class="s0">axis=</span><span class="s2">None, </span><span class="s0">out=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Indexes of the maximum values along an axis. 
 
        Return the indexes of the first occurrences of the maximum values 
        along the specified axis.  If axis is None, the index is for the 
        flattened matrix. 
 
        Parameters 
        ---------- 
        See `numpy.argmax` for complete descriptions 
 
        See Also 
        -------- 
        numpy.argmax 
 
        Notes 
        ----- 
        This is the same as `ndarray.argmax`, but returns a `matrix` object 
        where `ndarray.argmax` would return an `ndarray`. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4))); x 
        matrix([[ 0,  1,  2,  3], 
                [ 4,  5,  6,  7], 
                [ 8,  9, 10, 11]]) 
        &gt;&gt;&gt; x.argmax() 
        11 
        &gt;&gt;&gt; x.argmax(0) 
        matrix([[2, 2, 2, 2]]) 
        &gt;&gt;&gt; x.argmax(1) 
        matrix([[3], 
                [3], 
                [3]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">N.ndarray.argmax(self</span><span class="s2">, </span><span class="s0">axis</span><span class="s2">, </span><span class="s0">out)._align(axis)</span>

    <span class="s2">def </span><span class="s0">min(self</span><span class="s2">, </span><span class="s0">axis=</span><span class="s2">None, </span><span class="s0">out=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the minimum value along an axis. 
 
        Parameters 
        ---------- 
        See `amin` for complete descriptions. 
 
        See Also 
        -------- 
        amin, ndarray.min 
 
        Notes 
        ----- 
        This is the same as `ndarray.min`, but returns a `matrix` object 
        where `ndarray.min` would return an ndarray. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; x = -np.matrix(np.arange(12).reshape((3,4))); x 
        matrix([[  0,  -1,  -2,  -3], 
                [ -4,  -5,  -6,  -7], 
                [ -8,  -9, -10, -11]]) 
        &gt;&gt;&gt; x.min() 
        -11 
        &gt;&gt;&gt; x.min(0) 
        matrix([[ -8,  -9, -10, -11]]) 
        &gt;&gt;&gt; x.min(1) 
        matrix([[ -3], 
                [ -7], 
                [-11]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">N.ndarray.min(self</span><span class="s2">, </span><span class="s0">axis</span><span class="s2">, </span><span class="s0">out</span><span class="s2">, </span><span class="s0">keepdims=</span><span class="s2">True</span><span class="s0">)._collapse(axis)</span>

    <span class="s2">def </span><span class="s0">argmin(self</span><span class="s2">, </span><span class="s0">axis=</span><span class="s2">None, </span><span class="s0">out=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Indexes of the minimum values along an axis. 
 
        Return the indexes of the first occurrences of the minimum values 
        along the specified axis.  If axis is None, the index is for the 
        flattened matrix. 
 
        Parameters 
        ---------- 
        See `numpy.argmin` for complete descriptions. 
 
        See Also 
        -------- 
        numpy.argmin 
 
        Notes 
        ----- 
        This is the same as `ndarray.argmin`, but returns a `matrix` object 
        where `ndarray.argmin` would return an `ndarray`. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; x = -np.matrix(np.arange(12).reshape((3,4))); x 
        matrix([[  0,  -1,  -2,  -3], 
                [ -4,  -5,  -6,  -7], 
                [ -8,  -9, -10, -11]]) 
        &gt;&gt;&gt; x.argmin() 
        11 
        &gt;&gt;&gt; x.argmin(0) 
        matrix([[2, 2, 2, 2]]) 
        &gt;&gt;&gt; x.argmin(1) 
        matrix([[3], 
                [3], 
                [3]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">N.ndarray.argmin(self</span><span class="s2">, </span><span class="s0">axis</span><span class="s2">, </span><span class="s0">out)._align(axis)</span>

    <span class="s2">def </span><span class="s0">ptp(self</span><span class="s2">, </span><span class="s0">axis=</span><span class="s2">None, </span><span class="s0">out=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Peak-to-peak (maximum - minimum) value along the given axis. 
 
        Refer to `numpy.ptp` for full documentation. 
 
        See Also 
        -------- 
        numpy.ptp 
 
        Notes 
        ----- 
        Same as `ndarray.ptp`, except, where that would return an `ndarray` object, 
        this returns a `matrix` object. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4))); x 
        matrix([[ 0,  1,  2,  3], 
                [ 4,  5,  6,  7], 
                [ 8,  9, 10, 11]]) 
        &gt;&gt;&gt; x.ptp() 
        11 
        &gt;&gt;&gt; x.ptp(0) 
        matrix([[8, 8, 8, 8]]) 
        &gt;&gt;&gt; x.ptp(1) 
        matrix([[3], 
                [3], 
                [3]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">N.ndarray.ptp(self</span><span class="s2">, </span><span class="s0">axis</span><span class="s2">, </span><span class="s0">out)._align(axis)</span>

    <span class="s0">@property</span>
    <span class="s2">def </span><span class="s0">I(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the (multiplicative) inverse of invertible `self`. 
 
        Parameters 
        ---------- 
        None 
 
        Returns 
        ------- 
        ret : matrix object 
            If `self` is non-singular, `ret` is such that ``ret * self`` == 
            ``self * ret`` == ``np.matrix(np.eye(self[0,:].size))`` all return 
            ``True``. 
 
        Raises 
        ------ 
        numpy.linalg.LinAlgError: Singular matrix 
            If `self` is singular. 
 
        See Also 
        -------- 
        linalg.inv 
 
        Examples 
        -------- 
        &gt;&gt;&gt; m = np.matrix('[1, 2; 3, 4]'); m 
        matrix([[1, 2], 
                [3, 4]]) 
        &gt;&gt;&gt; m.getI() 
        matrix([[-2. ,  1. ], 
                [ 1.5, -0.5]]) 
        &gt;&gt;&gt; m.getI() * m 
        matrix([[ 1.,  0.], # may vary 
                [ 0.,  1.]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s0">M</span><span class="s2">, </span><span class="s0">N = self.shape</span>
        <span class="s2">if </span><span class="s0">M == N:</span>
            <span class="s2">from </span><span class="s0">numpy.linalg </span><span class="s2">import </span><span class="s0">inv </span><span class="s2">as </span><span class="s0">func</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s2">from </span><span class="s0">numpy.linalg </span><span class="s2">import </span><span class="s0">pinv </span><span class="s2">as </span><span class="s0">func</span>
        <span class="s2">return </span><span class="s0">asmatrix(func(self))</span>

    <span class="s0">@property</span>
    <span class="s2">def </span><span class="s0">A(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return `self` as an `ndarray` object. 
 
        Equivalent to ``np.asarray(self)``. 
 
        Parameters 
        ---------- 
        None 
 
        Returns 
        ------- 
        ret : ndarray 
            `self` as an `ndarray` 
 
        Examples 
        -------- 
        &gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4))); x 
        matrix([[ 0,  1,  2,  3], 
                [ 4,  5,  6,  7], 
                [ 8,  9, 10, 11]]) 
        &gt;&gt;&gt; x.getA() 
        array([[ 0,  1,  2,  3], 
               [ 4,  5,  6,  7], 
               [ 8,  9, 10, 11]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">self.__array__()</span>

    <span class="s0">@property</span>
    <span class="s2">def </span><span class="s0">A1(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return `self` as a flattened `ndarray`. 
 
        Equivalent to ``np.asarray(x).ravel()`` 
 
        Parameters 
        ---------- 
        None 
 
        Returns 
        ------- 
        ret : ndarray 
            `self`, 1-D, as an `ndarray` 
 
        Examples 
        -------- 
        &gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4))); x 
        matrix([[ 0,  1,  2,  3], 
                [ 4,  5,  6,  7], 
                [ 8,  9, 10, 11]]) 
        &gt;&gt;&gt; x.getA1() 
        array([ 0,  1,  2, ...,  9, 10, 11]) 
 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">self.__array__().ravel()</span>


    <span class="s2">def </span><span class="s0">ravel(self</span><span class="s2">, </span><span class="s0">order=</span><span class="s1">'C'</span><span class="s0">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return a flattened matrix. 
 
        Refer to `numpy.ravel` for more documentation. 
 
        Parameters 
        ---------- 
        order : {'C', 'F', 'A', 'K'}, optional 
            The elements of `m` are read using this index order. 'C' means to 
            index the elements in C-like order, with the last axis index 
            changing fastest, back to the first axis index changing slowest. 
            'F' means to index the elements in Fortran-like index order, with 
            the first index changing fastest, and the last index changing 
            slowest. Note that the 'C' and 'F' options take no account of the 
            memory layout of the underlying array, and only refer to the order 
            of axis indexing.  'A' means to read the elements in Fortran-like 
            index order if `m` is Fortran *contiguous* in memory, C-like order 
            otherwise.  'K' means to read the elements in the order they occur 
            in memory, except for reversing the data when strides are negative. 
            By default, 'C' index order is used. 
 
        Returns 
        ------- 
        ret : matrix 
            Return the matrix flattened to shape `(1, N)` where `N` 
            is the number of elements in the original matrix. 
            A copy is made only if necessary. 
 
        See Also 
        -------- 
        matrix.flatten : returns a similar output matrix but always a copy 
        matrix.flat : a flat iterator on the array. 
        numpy.ravel : related function which returns an ndarray 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">N.ndarray.ravel(self</span><span class="s2">, </span><span class="s0">order=order)</span>

    <span class="s0">@property</span>
    <span class="s2">def </span><span class="s0">T(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the transpose of the matrix. 
 
        Does *not* conjugate!  For the complex conjugate transpose, use ``.H``. 
 
        Parameters 
        ---------- 
        None 
 
        Returns 
        ------- 
        ret : matrix object 
            The (non-conjugated) transpose of the matrix. 
 
        See Also 
        -------- 
        transpose, getH 
 
        Examples 
        -------- 
        &gt;&gt;&gt; m = np.matrix('[1, 2; 3, 4]') 
        &gt;&gt;&gt; m 
        matrix([[1, 2], 
                [3, 4]]) 
        &gt;&gt;&gt; m.getT() 
        matrix([[1, 3], 
                [2, 4]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">self.transpose()</span>

    <span class="s0">@property</span>
    <span class="s2">def </span><span class="s0">H(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the (complex) conjugate transpose of `self`. 
 
        Equivalent to ``np.transpose(self)`` if `self` is real-valued. 
 
        Parameters 
        ---------- 
        None 
 
        Returns 
        ------- 
        ret : matrix object 
            complex conjugate transpose of `self` 
 
        Examples 
        -------- 
        &gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4))) 
        &gt;&gt;&gt; z = x - 1j*x; z 
        matrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j], 
                [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j], 
                [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]]) 
        &gt;&gt;&gt; z.getH() 
        matrix([[ 0. -0.j,  4. +4.j,  8. +8.j], 
                [ 1. +1.j,  5. +5.j,  9. +9.j], 
                [ 2. +2.j,  6. +6.j, 10.+10.j], 
                [ 3. +3.j,  7. +7.j, 11.+11.j]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s0">issubclass(self.dtype.type</span><span class="s2">, </span><span class="s0">N.complexfloating):</span>
            <span class="s2">return </span><span class="s0">self.transpose().conjugate()</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">self.transpose()</span>

    <span class="s3"># kept for compatibility</span>
    <span class="s0">getT = T.fget</span>
    <span class="s0">getA = A.fget</span>
    <span class="s0">getA1 = A1.fget</span>
    <span class="s0">getH = H.fget</span>
    <span class="s0">getI = I.fget</span>

<span class="s2">def </span><span class="s0">_from_string(str</span><span class="s2">, </span><span class="s0">gdict</span><span class="s2">, </span><span class="s0">ldict):</span>
    <span class="s0">rows = str.split(</span><span class="s1">';'</span><span class="s0">)</span>
    <span class="s0">rowtup = []</span>
    <span class="s2">for </span><span class="s0">row </span><span class="s2">in </span><span class="s0">rows:</span>
        <span class="s0">trow = row.split(</span><span class="s1">','</span><span class="s0">)</span>
        <span class="s0">newrow = []</span>
        <span class="s2">for </span><span class="s0">x </span><span class="s2">in </span><span class="s0">trow:</span>
            <span class="s0">newrow.extend(x.split())</span>
        <span class="s0">trow = newrow</span>
        <span class="s0">coltup = []</span>
        <span class="s2">for </span><span class="s0">col </span><span class="s2">in </span><span class="s0">trow:</span>
            <span class="s0">col = col.strip()</span>
            <span class="s2">try</span><span class="s0">:</span>
                <span class="s0">thismat = ldict[col]</span>
            <span class="s2">except </span><span class="s0">KeyError:</span>
                <span class="s2">try</span><span class="s0">:</span>
                    <span class="s0">thismat = gdict[col]</span>
                <span class="s2">except </span><span class="s0">KeyError </span><span class="s2">as </span><span class="s0">e:</span>
                    <span class="s2">raise </span><span class="s0">NameError(</span><span class="s1">f&quot;name </span><span class="s2">{</span><span class="s0">col</span><span class="s2">!r} </span><span class="s1">is not defined&quot;</span><span class="s0">) </span><span class="s2">from None</span>

            <span class="s0">coltup.append(thismat)</span>
        <span class="s0">rowtup.append(concatenate(coltup</span><span class="s2">, </span><span class="s0">axis=-</span><span class="s4">1</span><span class="s0">))</span>
    <span class="s2">return </span><span class="s0">concatenate(rowtup</span><span class="s2">, </span><span class="s0">axis=</span><span class="s4">0</span><span class="s0">)</span>


<span class="s0">@set_module(</span><span class="s1">'numpy'</span><span class="s0">)</span>
<span class="s2">def </span><span class="s0">bmat(obj</span><span class="s2">, </span><span class="s0">ldict=</span><span class="s2">None, </span><span class="s0">gdict=</span><span class="s2">None</span><span class="s0">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Build a matrix object from a string, nested sequence, or array. 
 
    Parameters 
    ---------- 
    obj : str or array_like 
        Input data. If a string, variables in the current scope may be 
        referenced by name. 
    ldict : dict, optional 
        A dictionary that replaces local operands in current frame. 
        Ignored if `obj` is not a string or `gdict` is None. 
    gdict : dict, optional 
        A dictionary that replaces global operands in current frame. 
        Ignored if `obj` is not a string. 
 
    Returns 
    ------- 
    out : matrix 
        Returns a matrix object, which is a specialized 2-D array. 
 
    See Also 
    -------- 
    block : 
        A generalization of this function for N-d arrays, that returns normal 
        ndarrays. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; A = np.mat('1 1; 1 1') 
    &gt;&gt;&gt; B = np.mat('2 2; 2 2') 
    &gt;&gt;&gt; C = np.mat('3 4; 5 6') 
    &gt;&gt;&gt; D = np.mat('7 8; 9 0') 
 
    All the following expressions construct the same block matrix: 
 
    &gt;&gt;&gt; np.bmat([[A, B], [C, D]]) 
    matrix([[1, 1, 2, 2], 
            [1, 1, 2, 2], 
            [3, 4, 7, 8], 
            [5, 6, 9, 0]]) 
    &gt;&gt;&gt; np.bmat(np.r_[np.c_[A, B], np.c_[C, D]]) 
    matrix([[1, 1, 2, 2], 
            [1, 1, 2, 2], 
            [3, 4, 7, 8], 
            [5, 6, 9, 0]]) 
    &gt;&gt;&gt; np.bmat('A,B; C,D') 
    matrix([[1, 1, 2, 2], 
            [1, 1, 2, 2], 
            [3, 4, 7, 8], 
            [5, 6, 9, 0]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s0">isinstance(obj</span><span class="s2">, </span><span class="s0">str):</span>
        <span class="s2">if </span><span class="s0">gdict </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s3"># get previous frame</span>
            <span class="s0">frame = sys._getframe().f_back</span>
            <span class="s0">glob_dict = frame.f_globals</span>
            <span class="s0">loc_dict = frame.f_locals</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">glob_dict = gdict</span>
            <span class="s0">loc_dict = ldict</span>

        <span class="s2">return </span><span class="s0">matrix(_from_string(obj</span><span class="s2">, </span><span class="s0">glob_dict</span><span class="s2">, </span><span class="s0">loc_dict))</span>

    <span class="s2">if </span><span class="s0">isinstance(obj</span><span class="s2">, </span><span class="s0">(tuple</span><span class="s2">, </span><span class="s0">list)):</span>
        <span class="s3"># [[A,B],[C,D]]</span>
        <span class="s0">arr_rows = []</span>
        <span class="s2">for </span><span class="s0">row </span><span class="s2">in </span><span class="s0">obj:</span>
            <span class="s2">if </span><span class="s0">isinstance(row</span><span class="s2">, </span><span class="s0">N.ndarray):  </span><span class="s3"># not 2-d</span>
                <span class="s2">return </span><span class="s0">matrix(concatenate(obj</span><span class="s2">, </span><span class="s0">axis=-</span><span class="s4">1</span><span class="s0">))</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s0">arr_rows.append(concatenate(row</span><span class="s2">, </span><span class="s0">axis=-</span><span class="s4">1</span><span class="s0">))</span>
        <span class="s2">return </span><span class="s0">matrix(concatenate(arr_rows</span><span class="s2">, </span><span class="s0">axis=</span><span class="s4">0</span><span class="s0">))</span>
    <span class="s2">if </span><span class="s0">isinstance(obj</span><span class="s2">, </span><span class="s0">N.ndarray):</span>
        <span class="s2">return </span><span class="s0">matrix(obj)</span>

<span class="s0">mat = asmatrix</span>
</pre>
</body>
</html>