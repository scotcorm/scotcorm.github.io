<html>
<head>
<title>hashtable_func_helper.pxi.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
hashtable_func_helper.pxi.in</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;</span>
<span class="s0">Template for each `dtype` helper function for hashtable</span>

<span class="s0">WARNING: DO NOT edit .pxi FILE directly, .pxi is generated from .pxi.in</span>
<span class="s0">&quot;&quot;&quot;</span>

<span class="s0">{{py:</span>

<span class="s0"># name, dtype, ttype, c_type, to_c_type</span>
<span class="s0">dtypes = [('Complex128', 'complex128', 'complex128',</span>
                         <span class="s0">'khcomplex128_t', 'to_khcomplex128_t'),</span>
          <span class="s0">('Complex64', 'complex64', 'complex64',</span>
                        <span class="s0">'khcomplex64_t', 'to_khcomplex64_t'),</span>
          <span class="s0">('Float64', 'float64', 'float64', 'float64_t', ''),</span>
          <span class="s0">('Float32', 'float32', 'float32', 'float32_t', ''),</span>
          <span class="s0">('UInt64', 'uint64', 'uint64', 'uint64_t', ''),</span>
          <span class="s0">('UInt32', 'uint32', 'uint32', 'uint32_t', ''),</span>
          <span class="s0">('UInt16', 'uint16', 'uint16', 'uint16_t', ''),</span>
          <span class="s0">('UInt8', 'uint8', 'uint8', 'uint8_t', ''),</span>
          <span class="s0">('Object', 'object', 'pymap', 'object', ''),</span>
          <span class="s0">('Int64', 'int64', 'int64', 'int64_t', ''),</span>
          <span class="s0">('Int32', 'int32', 'int32', 'int32_t', ''),</span>
          <span class="s0">('Int16', 'int16', 'int16', 'int16_t', ''),</span>
          <span class="s0">('Int8', 'int8', 'int8', 'int8_t', '')]</span>

<span class="s0">}}</span>

<span class="s0">{{for name, dtype, ttype, c_type, to_c_type in dtypes}}</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">{{if dtype == 'object'}}</span>
<span class="s0">cdef value_count_{{dtype}}(ndarray[{{dtype}}] values, bint dropna):</span>
<span class="s0">{{else}}</span>
<span class="s0">cdef value_count_{{dtype}}(const {{dtype}}_t[:] values, bint dropna):</span>
<span class="s0">{{endif}}</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i = 0</span>
        <span class="s0">Py_ssize_t n = len(values)</span>
        <span class="s0">kh_{{ttype}}_t *table</span>

        <span class="s0"># Don't use Py_ssize_t, since table.n_buckets is unsigned</span>
        <span class="s0">khiter_t k</span>

        <span class="s0">{{c_type}} val</span>

        <span class="s0">int ret = 0</span>

    <span class="s0"># we track the order in which keys are first seen (GH39009),</span>
    <span class="s0"># khash-map isn't insertion-ordered, thus:</span>
    <span class="s0">#    table maps keys to counts</span>
    <span class="s0">#    result_keys remembers the original order of keys</span>

    <span class="s0">result_keys = {{name}}Vector()</span>
    <span class="s0">table = kh_init_{{ttype}}()</span>

    <span class="s0">{{if dtype == 'object'}}</span>
    <span class="s0">kh_resize_{{ttype}}(table, n // 10)</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">val = values[i]</span>
        <span class="s0">if not dropna or not checknull(val):</span>
            <span class="s0">k = kh_get_{{ttype}}(table, &lt;PyObject*&gt;val)</span>
            <span class="s0">if k != table.n_buckets:</span>
                <span class="s0">table.vals[k] += 1</span>
            <span class="s0">else:</span>
                <span class="s0">k = kh_put_{{ttype}}(table, &lt;PyObject*&gt;val, &amp;ret)</span>
                <span class="s0">table.vals[k] = 1</span>
                <span class="s0">result_keys.append(val)</span>
    <span class="s0">{{else}}</span>
    <span class="s0">kh_resize_{{ttype}}(table, n)</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">val = {{to_c_type}}(values[i])</span>

        <span class="s0">if not is_nan_{{c_type}}(val) or not dropna:</span>
            <span class="s0">k = kh_get_{{ttype}}(table, val)</span>
            <span class="s0">if k != table.n_buckets:</span>
                <span class="s0">table.vals[k] += 1</span>
            <span class="s0">else:</span>
                <span class="s0">k = kh_put_{{ttype}}(table, val, &amp;ret)</span>
                <span class="s0">table.vals[k] = 1</span>
                <span class="s0">result_keys.append(val)</span>
    <span class="s0">{{endif}}</span>

    <span class="s0"># collect counts in the order corresponding to result_keys:</span>
    <span class="s0">cdef int64_t[:] result_counts = np.empty(table.size, dtype=np.int64)</span>
    <span class="s0">for i in range(table.size):</span>
        <span class="s0">{{if dtype == 'object'}}</span>
        <span class="s0">k = kh_get_{{ttype}}(table, result_keys.data[i])</span>
        <span class="s0">{{else}}</span>
        <span class="s0">k = kh_get_{{ttype}}(table, result_keys.data.data[i])</span>
        <span class="s0">{{endif}}</span>
        <span class="s0">result_counts[i] = table.vals[k]</span>

    <span class="s0">kh_destroy_{{ttype}}(table)</span>

    <span class="s0">return result_keys.to_array(), result_counts.base</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">{{if dtype == 'object'}}</span>
<span class="s0">cdef duplicated_{{dtype}}(ndarray[{{dtype}}] values, object keep='first'):</span>
<span class="s0">{{else}}</span>
<span class="s0">cdef duplicated_{{dtype}}(const {{dtype}}_t[:] values, object keep='first'):</span>
<span class="s0">{{endif}}</span>
    <span class="s0">cdef:</span>
        <span class="s0">int ret = 0</span>
        <span class="s0">{{if dtype != 'object'}}</span>
        <span class="s0">{{c_type}} value</span>
        <span class="s0">{{endif}}</span>
        <span class="s0">Py_ssize_t i, n = len(values)</span>
        <span class="s0">khiter_t k</span>
        <span class="s0">kh_{{ttype}}_t *table = kh_init_{{ttype}}()</span>
        <span class="s0">ndarray[uint8_t, ndim=1, cast=True] out = np.empty(n, dtype='bool')</span>

    <span class="s0">kh_resize_{{ttype}}(table, min(kh_needed_n_buckets(n), SIZE_HINT_LIMIT))</span>

    <span class="s0">if keep not in ('last', 'first', False):</span>
        <span class="s0">raise ValueError('keep must be either &quot;first&quot;, &quot;last&quot; or False')</span>

    <span class="s0">if keep == 'last':</span>
        <span class="s0">{{if dtype == 'object'}}</span>
        <span class="s0">for i in range(n - 1, -1, -1):</span>
            <span class="s0"># equivalent: range(n)[::-1], which cython doesn't like in nogil</span>
            <span class="s0">kh_put_{{ttype}}(table, &lt;PyObject*&gt;values[i], &amp;ret)</span>
            <span class="s0">out[i] = ret == 0</span>
        <span class="s0">{{else}}</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(n - 1, -1, -1):</span>
                <span class="s0"># equivalent: range(n)[::-1], which cython doesn't like in nogil</span>
                <span class="s0">value = {{to_c_type}}(values[i])</span>
                <span class="s0">kh_put_{{ttype}}(table, value, &amp;ret)</span>
                <span class="s0">out[i] = ret == 0</span>
        <span class="s0">{{endif}}</span>
    <span class="s0">elif keep == 'first':</span>
        <span class="s0">{{if dtype == 'object'}}</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">kh_put_{{ttype}}(table, &lt;PyObject*&gt;values[i], &amp;ret)</span>
            <span class="s0">out[i] = ret == 0</span>
        <span class="s0">{{else}}</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(n):</span>
                <span class="s0">value = {{to_c_type}}(values[i])</span>
                <span class="s0">kh_put_{{ttype}}(table, value, &amp;ret)</span>
                <span class="s0">out[i] = ret == 0</span>
        <span class="s0">{{endif}}</span>
    <span class="s0">else:</span>
        <span class="s0">{{if dtype == 'object'}}</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">value = values[i]</span>
            <span class="s0">k = kh_get_{{ttype}}(table, &lt;PyObject*&gt;value)</span>
            <span class="s0">if k != table.n_buckets:</span>
                <span class="s0">out[table.vals[k]] = 1</span>
                <span class="s0">out[i] = 1</span>
            <span class="s0">else:</span>
                <span class="s0">k = kh_put_{{ttype}}(table, &lt;PyObject*&gt;value, &amp;ret)</span>
                <span class="s0">table.vals[k] = i</span>
                <span class="s0">out[i] = 0</span>
        <span class="s0">{{else}}</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(n):</span>
                <span class="s0">value = {{to_c_type}}(values[i])</span>
                <span class="s0">k = kh_get_{{ttype}}(table, value)</span>
                <span class="s0">if k != table.n_buckets:</span>
                    <span class="s0">out[table.vals[k]] = 1</span>
                    <span class="s0">out[i] = 1</span>
                <span class="s0">else:</span>
                    <span class="s0">k = kh_put_{{ttype}}(table, value, &amp;ret)</span>
                    <span class="s0">table.vals[k] = i</span>
                    <span class="s0">out[i] = 0</span>
        <span class="s0">{{endif}}</span>
    <span class="s0">kh_destroy_{{ttype}}(table)</span>
    <span class="s0">return out</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Membership</span>
<span class="s0"># ----------------------------------------------------------------------</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">{{if dtype == 'object'}}</span>
<span class="s0">cdef ismember_{{dtype}}(ndarray[{{c_type}}] arr, ndarray[{{c_type}}] values):</span>
<span class="s0">{{else}}</span>
<span class="s0">cdef ismember_{{dtype}}(const {{dtype}}_t[:] arr, const {{dtype}}_t[:] values):</span>
<span class="s0">{{endif}}</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Return boolean of values in arr on an</span>
    <span class="s0">element by-element basis</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">arr : {{dtype}} ndarray</span>
    <span class="s0">values : {{dtype}} ndarray</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">boolean ndarry len of (arr)</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n</span>
        <span class="s0">khiter_t k</span>
        <span class="s0">int ret = 0</span>
        <span class="s0">ndarray[uint8_t] result</span>
        <span class="s0">{{c_type}} val</span>
        <span class="s0">kh_{{ttype}}_t *table = kh_init_{{ttype}}()</span>

    <span class="s0"># construct the table</span>
    <span class="s0">n = len(values)</span>
    <span class="s0">kh_resize_{{ttype}}(table, n)</span>

    <span class="s0">{{if dtype == 'object'}}</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">kh_put_{{ttype}}(table, &lt;PyObject*&gt;values[i], &amp;ret)</span>
    <span class="s0">{{else}}</span>
    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">val = {{to_c_type}}(values[i])</span>
            <span class="s0">kh_put_{{ttype}}(table, val, &amp;ret)</span>
    <span class="s0">{{endif}}</span>

    <span class="s0"># test membership</span>
    <span class="s0">n = len(arr)</span>
    <span class="s0">result = np.empty(n, dtype=np.uint8)</span>

    <span class="s0">{{if dtype == 'object'}}</span>
    <span class="s0">for i in range(n):</span>
        <span class="s0">val = arr[i]</span>
        <span class="s0">k = kh_get_{{ttype}}(table, &lt;PyObject*&gt;val)</span>
        <span class="s0">result[i] = (k != table.n_buckets)</span>
    <span class="s0">{{else}}</span>
    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">val = {{to_c_type}}(arr[i])</span>
            <span class="s0">k = kh_get_{{ttype}}(table, val)</span>
            <span class="s0">result[i] = (k != table.n_buckets)</span>
    <span class="s0">{{endif}}</span>

    <span class="s0">kh_destroy_{{ttype}}(table)</span>
    <span class="s0">return result.view(np.bool_)</span>

<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Mode Computations</span>
<span class="s0"># ----------------------------------------------------------------------</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">{{if dtype == 'object'}}</span>
<span class="s0">cdef mode_{{dtype}}(ndarray[{{dtype}}] values, bint dropna):</span>
<span class="s0">{{else}}</span>
<span class="s0">cdef mode_{{dtype}}(const {{dtype}}_t[:] values, bint dropna):</span>
<span class="s0">{{endif}}</span>
    <span class="s0">cdef:</span>
        <span class="s0">{{if dtype == 'object'}}</span>
        <span class="s0">ndarray[{{dtype}}] keys</span>
        <span class="s0">ndarray[{{dtype}}] modes</span>
        <span class="s0">{{else}}</span>
        <span class="s0">{{dtype}}_t[:] keys</span>
        <span class="s0">ndarray[{{dtype}}_t] modes</span>
        <span class="s0">{{endif}}</span>
        <span class="s0">int64_t[:] counts</span>
        <span class="s0">int64_t count, max_count = -1</span>
        <span class="s0">Py_ssize_t k, j = 0</span>

    <span class="s0">keys, counts = value_count_{{dtype}}(values, dropna)</span>

    <span class="s0">{{if dtype == 'object'}}</span>
    <span class="s0">modes = np.empty(len(keys), dtype=np.object_)</span>
    <span class="s0">{{else}}</span>
    <span class="s0">modes = np.empty(len(keys), dtype=np.{{dtype}})</span>
    <span class="s0">{{endif}}</span>

    <span class="s0">{{if dtype != 'object'}}</span>
    <span class="s0">with nogil:</span>
        <span class="s0">for k in range(len(keys)):</span>
            <span class="s0">count = counts[k]</span>
            <span class="s0">if count == max_count:</span>
                <span class="s0">j += 1</span>
            <span class="s0">elif count &gt; max_count:</span>
                <span class="s0">max_count = count</span>
                <span class="s0">j = 0</span>
            <span class="s0">else:</span>
                <span class="s0">continue</span>

            <span class="s0">modes[j] = keys[k]</span>
    <span class="s0">{{else}}</span>
    <span class="s0">for k in range(len(keys)):</span>
        <span class="s0">count = counts[k]</span>
        <span class="s0">if count == max_count:</span>
            <span class="s0">j += 1</span>
        <span class="s0">elif count &gt; max_count:</span>
            <span class="s0">max_count = count</span>
            <span class="s0">j = 0</span>
        <span class="s0">else:</span>
            <span class="s0">continue</span>

        <span class="s0">modes[j] = keys[k]</span>
    <span class="s0">{{endif}}</span>

    <span class="s0">return modes[:j + 1]</span>

<span class="s0">{{endfor}}</span>


<span class="s0">ctypedef fused htfunc_t:</span>
    <span class="s0">complex128_t</span>
    <span class="s0">complex64_t</span>
    <span class="s0">float64_t</span>
    <span class="s0">float32_t</span>
    <span class="s0">uint64_t</span>
    <span class="s0">uint32_t</span>
    <span class="s0">uint16_t</span>
    <span class="s0">uint8_t</span>
    <span class="s0">int64_t</span>
    <span class="s0">int32_t</span>
    <span class="s0">int16_t</span>
    <span class="s0">int8_t</span>
    <span class="s0">object</span>


<span class="s0">cpdef value_count(ndarray[htfunc_t] values, bint dropna):</span>
    <span class="s0">if htfunc_t is object:</span>
        <span class="s0">return value_count_object(values, dropna)</span>

    <span class="s0">elif htfunc_t is int8_t:</span>
        <span class="s0">return value_count_int8(values, dropna)</span>
    <span class="s0">elif htfunc_t is int16_t:</span>
        <span class="s0">return value_count_int16(values, dropna)</span>
    <span class="s0">elif htfunc_t is int32_t:</span>
        <span class="s0">return value_count_int32(values, dropna)</span>
    <span class="s0">elif htfunc_t is int64_t:</span>
        <span class="s0">return value_count_int64(values, dropna)</span>

    <span class="s0">elif htfunc_t is uint8_t:</span>
        <span class="s0">return value_count_uint8(values, dropna)</span>
    <span class="s0">elif htfunc_t is uint16_t:</span>
        <span class="s0">return value_count_uint16(values, dropna)</span>
    <span class="s0">elif htfunc_t is uint32_t:</span>
        <span class="s0">return value_count_uint32(values, dropna)</span>
    <span class="s0">elif htfunc_t is uint64_t:</span>
        <span class="s0">return value_count_uint64(values, dropna)</span>

    <span class="s0">elif htfunc_t is float64_t:</span>
        <span class="s0">return value_count_float64(values, dropna)</span>
    <span class="s0">elif htfunc_t is float32_t:</span>
        <span class="s0">return value_count_float32(values, dropna)</span>

    <span class="s0">elif htfunc_t is complex128_t:</span>
        <span class="s0">return value_count_complex128(values, dropna)</span>
    <span class="s0">elif htfunc_t is complex64_t:</span>
        <span class="s0">return value_count_complex64(values, dropna)</span>

    <span class="s0">else:</span>
        <span class="s0">raise TypeError(values.dtype)</span>


<span class="s0">cpdef duplicated(ndarray[htfunc_t] values, object keep=&quot;first&quot;):</span>
    <span class="s0">if htfunc_t is object:</span>
        <span class="s0">return duplicated_object(values, keep)</span>

    <span class="s0">elif htfunc_t is int8_t:</span>
        <span class="s0">return duplicated_int8(values, keep)</span>
    <span class="s0">elif htfunc_t is int16_t:</span>
        <span class="s0">return duplicated_int16(values, keep)</span>
    <span class="s0">elif htfunc_t is int32_t:</span>
        <span class="s0">return duplicated_int32(values, keep)</span>
    <span class="s0">elif htfunc_t is int64_t:</span>
        <span class="s0">return duplicated_int64(values, keep)</span>

    <span class="s0">elif htfunc_t is uint8_t:</span>
        <span class="s0">return duplicated_uint8(values, keep)</span>
    <span class="s0">elif htfunc_t is uint16_t:</span>
        <span class="s0">return duplicated_uint16(values, keep)</span>
    <span class="s0">elif htfunc_t is uint32_t:</span>
        <span class="s0">return duplicated_uint32(values, keep)</span>
    <span class="s0">elif htfunc_t is uint64_t:</span>
        <span class="s0">return duplicated_uint64(values, keep)</span>

    <span class="s0">elif htfunc_t is float64_t:</span>
        <span class="s0">return duplicated_float64(values, keep)</span>
    <span class="s0">elif htfunc_t is float32_t:</span>
        <span class="s0">return duplicated_float32(values, keep)</span>

    <span class="s0">elif htfunc_t is complex128_t:</span>
        <span class="s0">return duplicated_complex128(values, keep)</span>
    <span class="s0">elif htfunc_t is complex64_t:</span>
        <span class="s0">return duplicated_complex64(values, keep)</span>

    <span class="s0">else:</span>
        <span class="s0">raise TypeError(values.dtype)</span>


<span class="s0">cpdef ismember(ndarray[htfunc_t] arr, ndarray[htfunc_t] values):</span>
    <span class="s0">if htfunc_t is object:</span>
        <span class="s0">return ismember_object(arr, values)</span>

    <span class="s0">elif htfunc_t is int8_t:</span>
        <span class="s0">return ismember_int8(arr, values)</span>
    <span class="s0">elif htfunc_t is int16_t:</span>
        <span class="s0">return ismember_int16(arr, values)</span>
    <span class="s0">elif htfunc_t is int32_t:</span>
        <span class="s0">return ismember_int32(arr, values)</span>
    <span class="s0">elif htfunc_t is int64_t:</span>
        <span class="s0">return ismember_int64(arr, values)</span>

    <span class="s0">elif htfunc_t is uint8_t:</span>
        <span class="s0">return ismember_uint8(arr, values)</span>
    <span class="s0">elif htfunc_t is uint16_t:</span>
        <span class="s0">return ismember_uint16(arr, values)</span>
    <span class="s0">elif htfunc_t is uint32_t:</span>
        <span class="s0">return ismember_uint32(arr, values)</span>
    <span class="s0">elif htfunc_t is uint64_t:</span>
        <span class="s0">return ismember_uint64(arr, values)</span>

    <span class="s0">elif htfunc_t is float64_t:</span>
        <span class="s0">return ismember_float64(arr, values)</span>
    <span class="s0">elif htfunc_t is float32_t:</span>
        <span class="s0">return ismember_float32(arr, values)</span>

    <span class="s0">elif htfunc_t is complex128_t:</span>
        <span class="s0">return ismember_complex128(arr, values)</span>
    <span class="s0">elif htfunc_t is complex64_t:</span>
        <span class="s0">return ismember_complex64(arr, values)</span>

    <span class="s0">else:</span>
        <span class="s0">raise TypeError(values.dtype)</span>


<span class="s0">cpdef mode(ndarray[htfunc_t] values, bint dropna):</span>
    <span class="s0">if htfunc_t is object:</span>
        <span class="s0">return mode_object(values, dropna)</span>

    <span class="s0">elif htfunc_t is int8_t:</span>
        <span class="s0">return mode_int8(values, dropna)</span>
    <span class="s0">elif htfunc_t is int16_t:</span>
        <span class="s0">return mode_int16(values, dropna)</span>
    <span class="s0">elif htfunc_t is int32_t:</span>
        <span class="s0">return mode_int32(values, dropna)</span>
    <span class="s0">elif htfunc_t is int64_t:</span>
        <span class="s0">return mode_int64(values, dropna)</span>

    <span class="s0">elif htfunc_t is uint8_t:</span>
        <span class="s0">return mode_uint8(values, dropna)</span>
    <span class="s0">elif htfunc_t is uint16_t:</span>
        <span class="s0">return mode_uint16(values, dropna)</span>
    <span class="s0">elif htfunc_t is uint32_t:</span>
        <span class="s0">return mode_uint32(values, dropna)</span>
    <span class="s0">elif htfunc_t is uint64_t:</span>
        <span class="s0">return mode_uint64(values, dropna)</span>

    <span class="s0">elif htfunc_t is float64_t:</span>
        <span class="s0">return mode_float64(values, dropna)</span>
    <span class="s0">elif htfunc_t is float32_t:</span>
        <span class="s0">return mode_float32(values, dropna)</span>

    <span class="s0">elif htfunc_t is complex128_t:</span>
        <span class="s0">return mode_complex128(values, dropna)</span>
    <span class="s0">elif htfunc_t is complex64_t:</span>
        <span class="s0">return mode_complex64(values, dropna)</span>

    <span class="s0">else:</span>
        <span class="s0">raise TypeError(values.dtype)</span>


<span class="s0">{{py:</span>

<span class="s0"># name, dtype, ttype, c_type</span>
<span class="s0">dtypes = [('Int64', 'int64', 'int64', 'int64_t'),</span>
          <span class="s0">('Int32', 'int32', 'int32', 'int32_t'), ]</span>

<span class="s0">}}</span>

<span class="s0">{{for name, dtype, ttype, c_type in dtypes}}</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def _unique_label_indices_{{dtype}}(const {{c_type}}[:] labels) -&gt; ndarray:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Indices of the first occurrences of the unique labels</span>
    <span class="s0">*excluding* -1. equivalent to:</span>
        <span class="s0">np.unique(labels, return_index=True)[1]</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">int ret = 0</span>
        <span class="s0">Py_ssize_t i, n = len(labels)</span>
        <span class="s0">kh_{{ttype}}_t *table = kh_init_{{ttype}}()</span>
        <span class="s0">{{name}}Vector idx = {{name}}Vector()</span>
        <span class="s0">ndarray[{{c_type}}, ndim=1] arr</span>
        <span class="s0">{{name}}VectorData *ud = idx.data</span>

    <span class="s0">kh_resize_{{ttype}}(table, min(kh_needed_n_buckets(n), SIZE_HINT_LIMIT))</span>

    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">kh_put_{{ttype}}(table, labels[i], &amp;ret)</span>
            <span class="s0">if ret != 0:</span>
                <span class="s0">if needs_resize(ud):</span>
                    <span class="s0">with gil:</span>
                        <span class="s0">idx.resize()</span>
                <span class="s0">append_data_{{ttype}}(ud, i)</span>

    <span class="s0">kh_destroy_{{ttype}}(table)</span>

    <span class="s0">arr = idx.to_array()</span>
    <span class="s0">arr = arr[np.asarray(labels)[arr].argsort()]</span>

    <span class="s0">return arr[1:] if arr.size != 0 and labels[arr[0]] == -1 else arr</span>

<span class="s0">{{endfor}}</span>
</pre>
</body>
</html>