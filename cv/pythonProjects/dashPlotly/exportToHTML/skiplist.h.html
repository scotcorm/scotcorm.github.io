<html>
<head>
<title>skiplist.h</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #0f9795;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
skiplist.h</font>
</center></td></tr></table>
<pre><span class="s0">/* 
Copyright (c) 2016, PyData Development Team 
All rights reserved. 
 
Distributed under the terms of the BSD Simplified License. 
 
The full license is in the LICENSE file, distributed with this software. 
 
Flexibly-sized, index-able skiplist data structure for maintaining a sorted 
list of values 
 
Port of Wes McKinney's Cython version of Raymond Hettinger's original pure 
Python recipe (https://rhettinger.wordpress.com/2010/02/06/lost-knowledge/) 
*/</span>

<span class="s2">#ifndef </span><span class="s1">PANDAS__LIBS_SRC_SKIPLIST_H_</span>
<span class="s2">#define </span><span class="s1">PANDAS__LIBS_SRC_SKIPLIST_H_</span>

<span class="s2">#include </span><span class="s1">&lt;math.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;stdio.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;stdlib.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;string.h&gt;</span>
<span class="s2">#include </span><span class="s3">&quot;inline_helper.h&quot;</span>

<span class="s1">PANDAS_INLINE </span><span class="s2">float </span><span class="s1">__skiplist_nanf(</span><span class="s2">void</span><span class="s1">) {</span>
    <span class="s2">const union </span><span class="s1">{</span>
        <span class="s2">int </span><span class="s1">__i;</span>
        <span class="s2">float </span><span class="s1">__f;</span>
    <span class="s1">} __bint = {</span><span class="s4">0x7fc00000</span><span class="s1">UL};</span>
    <span class="s2">return </span><span class="s1">__bint.__f;</span>
<span class="s1">}</span>
<span class="s2">#define </span><span class="s1">PANDAS_NAN ((</span><span class="s2">double</span><span class="s1">)__skiplist_nanf())</span>

<span class="s1">PANDAS_INLINE </span><span class="s2">double </span><span class="s1">Log2(</span><span class="s2">double </span><span class="s1">val) { </span><span class="s2">return </span><span class="s1">log(val) / log(</span><span class="s4">2</span><span class="s1">.); }</span>

<span class="s2">typedef struct </span><span class="s1">node_t node_t;</span>

<span class="s2">struct </span><span class="s1">node_t {</span>
    <span class="s1">node_t **next;</span>
    <span class="s2">int </span><span class="s1">*width;</span>
    <span class="s2">double </span><span class="s1">value;</span>
    <span class="s2">int </span><span class="s1">is_nil;</span>
    <span class="s2">int </span><span class="s1">levels;</span>
    <span class="s2">int </span><span class="s1">ref_count;</span>
<span class="s1">};</span>

<span class="s2">typedef struct </span><span class="s1">{</span>
    <span class="s1">node_t *head;</span>
    <span class="s1">node_t **tmp_chain;</span>
    <span class="s2">int </span><span class="s1">*tmp_steps;</span>
    <span class="s2">int </span><span class="s1">size;</span>
    <span class="s2">int </span><span class="s1">maxlevels;</span>
<span class="s1">} skiplist_t;</span>

<span class="s1">PANDAS_INLINE </span><span class="s2">double </span><span class="s1">urand(</span><span class="s2">void</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">((</span><span class="s2">double</span><span class="s1">)rand() + </span><span class="s4">1</span><span class="s1">) / ((</span><span class="s2">double</span><span class="s1">)RAND_MAX + </span><span class="s4">2</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s1">PANDAS_INLINE </span><span class="s2">int </span><span class="s1">int_min(</span><span class="s2">int </span><span class="s1">a, </span><span class="s2">int </span><span class="s1">b) { </span><span class="s2">return </span><span class="s1">a &lt; b ? a : b; }</span>

<span class="s1">PANDAS_INLINE node_t *node_init(</span><span class="s2">double </span><span class="s1">value, </span><span class="s2">int </span><span class="s1">levels) {</span>
    <span class="s1">node_t *result;</span>
    <span class="s1">result = (node_t *)malloc(</span><span class="s2">sizeof</span><span class="s1">(node_t));</span>
    <span class="s2">if </span><span class="s1">(result) {</span>
        <span class="s1">result</span><span class="s5">-&gt;</span><span class="s1">value = value;</span>
        <span class="s1">result</span><span class="s5">-&gt;</span><span class="s1">levels = levels;</span>
        <span class="s1">result</span><span class="s5">-&gt;</span><span class="s1">is_nil = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">result</span><span class="s5">-&gt;</span><span class="s1">ref_count = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">result</span><span class="s5">-&gt;</span><span class="s1">next = (node_t **)malloc(levels * </span><span class="s2">sizeof</span><span class="s1">(node_t *));</span>
        <span class="s1">result</span><span class="s5">-&gt;</span><span class="s1">width = (</span><span class="s2">int </span><span class="s1">*)malloc(levels * </span><span class="s2">sizeof</span><span class="s1">(</span><span class="s2">int</span><span class="s1">));</span>
        <span class="s2">if </span><span class="s1">(!(result</span><span class="s5">-&gt;</span><span class="s1">next &amp;&amp; result</span><span class="s5">-&gt;</span><span class="s1">width) &amp;&amp; (levels != </span><span class="s4">0</span><span class="s1">)) {</span>
            <span class="s1">free(result</span><span class="s5">-&gt;</span><span class="s1">next);</span>
            <span class="s1">free(result</span><span class="s5">-&gt;</span><span class="s1">width);</span>
            <span class="s1">free(result);</span>
            <span class="s2">return </span><span class="s1">NULL;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s0">// do this ourselves</span>
<span class="s1">PANDAS_INLINE </span><span class="s2">void </span><span class="s1">node_incref(node_t *node) { ++(node</span><span class="s5">-&gt;</span><span class="s1">ref_count); }</span>

<span class="s1">PANDAS_INLINE </span><span class="s2">void </span><span class="s1">node_decref(node_t *node) { --(node</span><span class="s5">-&gt;</span><span class="s1">ref_count); }</span>

<span class="s2">static void </span><span class="s1">node_destroy(node_t *node) {</span>
    <span class="s2">int </span><span class="s1">i;</span>
    <span class="s2">if </span><span class="s1">(node) {</span>
        <span class="s2">if </span><span class="s1">(node</span><span class="s5">-&gt;</span><span class="s1">ref_count &lt;= </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; node</span><span class="s5">-&gt;</span><span class="s1">levels; ++i) {</span>
                <span class="s1">node_destroy(node</span><span class="s5">-&gt;</span><span class="s1">next[i]);</span>
            <span class="s1">}</span>
            <span class="s1">free(node</span><span class="s5">-&gt;</span><span class="s1">next);</span>
            <span class="s1">free(node</span><span class="s5">-&gt;</span><span class="s1">width);</span>
            <span class="s0">// printf(&quot;Reference count was 1, freeing\n&quot;);</span>
            <span class="s1">free(node);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">node_decref(node);</span>
        <span class="s1">}</span>
        <span class="s0">// pretty sure that freeing the struct above will be enough</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">PANDAS_INLINE </span><span class="s2">void </span><span class="s1">skiplist_destroy(skiplist_t *skp) {</span>
    <span class="s2">if </span><span class="s1">(skp) {</span>
        <span class="s1">node_destroy(skp</span><span class="s5">-&gt;</span><span class="s1">head);</span>
        <span class="s1">free(skp</span><span class="s5">-&gt;</span><span class="s1">tmp_steps);</span>
        <span class="s1">free(skp</span><span class="s5">-&gt;</span><span class="s1">tmp_chain);</span>
        <span class="s1">free(skp);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">PANDAS_INLINE skiplist_t *skiplist_init(</span><span class="s2">int </span><span class="s1">expected_size) {</span>
    <span class="s1">skiplist_t *result;</span>
    <span class="s1">node_t *NIL, *head;</span>
    <span class="s2">int </span><span class="s1">maxlevels, i;</span>

    <span class="s1">maxlevels = </span><span class="s4">1 </span><span class="s1">+ Log2((</span><span class="s2">double</span><span class="s1">)expected_size);</span>
    <span class="s1">result = (skiplist_t *)malloc(</span><span class="s2">sizeof</span><span class="s1">(skiplist_t));</span>
    <span class="s2">if </span><span class="s1">(!result) {</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>
    <span class="s1">result</span><span class="s5">-&gt;</span><span class="s1">tmp_chain = (node_t **)malloc(maxlevels * </span><span class="s2">sizeof</span><span class="s1">(node_t *));</span>
    <span class="s1">result</span><span class="s5">-&gt;</span><span class="s1">tmp_steps = (</span><span class="s2">int </span><span class="s1">*)malloc(maxlevels * </span><span class="s2">sizeof</span><span class="s1">(</span><span class="s2">int</span><span class="s1">));</span>
    <span class="s1">result</span><span class="s5">-&gt;</span><span class="s1">maxlevels = maxlevels;</span>
    <span class="s1">result</span><span class="s5">-&gt;</span><span class="s1">size = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s1">head = result</span><span class="s5">-&gt;</span><span class="s1">head = node_init(PANDAS_NAN, maxlevels);</span>
    <span class="s1">NIL = node_init(</span><span class="s4">0.0</span><span class="s1">, </span><span class="s4">0</span><span class="s1">);</span>

    <span class="s2">if </span><span class="s1">(!(result</span><span class="s5">-&gt;</span><span class="s1">tmp_chain &amp;&amp; result</span><span class="s5">-&gt;</span><span class="s1">tmp_steps &amp;&amp; result</span><span class="s5">-&gt;</span><span class="s1">head &amp;&amp; NIL)) {</span>
        <span class="s1">skiplist_destroy(result);</span>
        <span class="s1">node_destroy(NIL);</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>

    <span class="s1">node_incref(head);</span>

    <span class="s1">NIL</span><span class="s5">-&gt;</span><span class="s1">is_nil = </span><span class="s4">1</span><span class="s1">;</span>

    <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; maxlevels; ++i) {</span>
        <span class="s1">head</span><span class="s5">-&gt;</span><span class="s1">next[i] = NIL;</span>
        <span class="s1">head</span><span class="s5">-&gt;</span><span class="s1">width[i] = </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">node_incref(NIL);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s0">// 1 if left &lt; right, 0 if left == right, -1 if left &gt; right</span>
<span class="s1">PANDAS_INLINE </span><span class="s2">int </span><span class="s1">_node_cmp(node_t *node, </span><span class="s2">double </span><span class="s1">value) {</span>
    <span class="s2">if </span><span class="s1">(node</span><span class="s5">-&gt;</span><span class="s1">is_nil || node</span><span class="s5">-&gt;</span><span class="s1">value &gt; value) {</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(node</span><span class="s5">-&gt;</span><span class="s1">value &lt; value) {</span>
        <span class="s2">return </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">PANDAS_INLINE </span><span class="s2">double </span><span class="s1">skiplist_get(skiplist_t *skp, </span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">*ret) {</span>
    <span class="s1">node_t *node;</span>
    <span class="s2">int </span><span class="s1">level;</span>

    <span class="s2">if </span><span class="s1">(i &lt; </span><span class="s4">0 </span><span class="s1">|| i &gt;= skp</span><span class="s5">-&gt;</span><span class="s1">size) {</span>
        <span class="s1">*ret = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">node = skp</span><span class="s5">-&gt;</span><span class="s1">head;</span>
    <span class="s1">++i;</span>
    <span class="s2">for </span><span class="s1">(level = skp</span><span class="s5">-&gt;</span><span class="s1">maxlevels - </span><span class="s4">1</span><span class="s1">; level &gt;= </span><span class="s4">0</span><span class="s1">; --level) {</span>
        <span class="s2">while </span><span class="s1">(node</span><span class="s5">-&gt;</span><span class="s1">width[level] &lt;= i) {</span>
            <span class="s1">i -= node</span><span class="s5">-&gt;</span><span class="s1">width[level];</span>
            <span class="s1">node = node</span><span class="s5">-&gt;</span><span class="s1">next[level];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">*ret = </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">node</span><span class="s5">-&gt;</span><span class="s1">value;</span>
<span class="s1">}</span>

<span class="s0">// Returns the lowest rank of all elements with value `value`, as opposed to the</span>
<span class="s0">// highest rank returned by `skiplist_insert`.</span>
<span class="s1">PANDAS_INLINE </span><span class="s2">int </span><span class="s1">skiplist_min_rank(skiplist_t *skp, </span><span class="s2">double </span><span class="s1">value) {</span>
    <span class="s1">node_t *node;</span>
    <span class="s2">int </span><span class="s1">level, rank = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s1">node = skp</span><span class="s5">-&gt;</span><span class="s1">head;</span>
    <span class="s2">for </span><span class="s1">(level = skp</span><span class="s5">-&gt;</span><span class="s1">maxlevels - </span><span class="s4">1</span><span class="s1">; level &gt;= </span><span class="s4">0</span><span class="s1">; --level) {</span>
        <span class="s2">while </span><span class="s1">(_node_cmp(node</span><span class="s5">-&gt;</span><span class="s1">next[level], value) &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">rank += node</span><span class="s5">-&gt;</span><span class="s1">width[level];</span>
            <span class="s1">node = node</span><span class="s5">-&gt;</span><span class="s1">next[level];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">rank + </span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">// Returns the rank of the inserted element. When there are duplicates,</span>
<span class="s0">// `rank` is the highest of the group, i.e. the 'max' method of</span>
<span class="s0">// https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.rank.html</span>
<span class="s1">PANDAS_INLINE </span><span class="s2">int </span><span class="s1">skiplist_insert(skiplist_t *skp, </span><span class="s2">double </span><span class="s1">value) {</span>
    <span class="s1">node_t *node, *prevnode, *newnode, *next_at_level;</span>
    <span class="s2">int </span><span class="s1">*steps_at_level;</span>
    <span class="s2">int </span><span class="s1">size, steps, level, rank = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">node_t **chain;</span>

    <span class="s1">chain = skp</span><span class="s5">-&gt;</span><span class="s1">tmp_chain;</span>

    <span class="s1">steps_at_level = skp</span><span class="s5">-&gt;</span><span class="s1">tmp_steps;</span>
    <span class="s1">memset(steps_at_level, </span><span class="s4">0</span><span class="s1">, skp</span><span class="s5">-&gt;</span><span class="s1">maxlevels * </span><span class="s2">sizeof</span><span class="s1">(</span><span class="s2">int</span><span class="s1">));</span>

    <span class="s1">node = skp</span><span class="s5">-&gt;</span><span class="s1">head;</span>

    <span class="s2">for </span><span class="s1">(level = skp</span><span class="s5">-&gt;</span><span class="s1">maxlevels - </span><span class="s4">1</span><span class="s1">; level &gt;= </span><span class="s4">0</span><span class="s1">; --level) {</span>
        <span class="s1">next_at_level = node</span><span class="s5">-&gt;</span><span class="s1">next[level];</span>
        <span class="s2">while </span><span class="s1">(_node_cmp(next_at_level, value) &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">steps_at_level[level] += node</span><span class="s5">-&gt;</span><span class="s1">width[level];</span>
            <span class="s1">rank += node</span><span class="s5">-&gt;</span><span class="s1">width[level];</span>
            <span class="s1">node = next_at_level;</span>
            <span class="s1">next_at_level = node</span><span class="s5">-&gt;</span><span class="s1">next[level];</span>
        <span class="s1">}</span>
        <span class="s1">chain[level] = node;</span>
    <span class="s1">}</span>

    <span class="s1">size = int_min(skp</span><span class="s5">-&gt;</span><span class="s1">maxlevels, </span><span class="s4">1 </span><span class="s1">- ((</span><span class="s2">int</span><span class="s1">)Log2(urand())));</span>

    <span class="s1">newnode = node_init(value, size);</span>
    <span class="s2">if </span><span class="s1">(!newnode) {</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">steps = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s2">for </span><span class="s1">(level = </span><span class="s4">0</span><span class="s1">; level &lt; size; ++level) {</span>
        <span class="s1">prevnode = chain[level];</span>
        <span class="s1">newnode</span><span class="s5">-&gt;</span><span class="s1">next[level] = prevnode</span><span class="s5">-&gt;</span><span class="s1">next[level];</span>

        <span class="s1">prevnode</span><span class="s5">-&gt;</span><span class="s1">next[level] = newnode;</span>
        <span class="s1">node_incref(newnode);  </span><span class="s0">// increment the reference count</span>

        <span class="s1">newnode</span><span class="s5">-&gt;</span><span class="s1">width[level] = prevnode</span><span class="s5">-&gt;</span><span class="s1">width[level] - steps;</span>
        <span class="s1">prevnode</span><span class="s5">-&gt;</span><span class="s1">width[level] = steps + </span><span class="s4">1</span><span class="s1">;</span>

        <span class="s1">steps += steps_at_level[level];</span>
    <span class="s1">}</span>

    <span class="s2">for </span><span class="s1">(level = size; level &lt; skp</span><span class="s5">-&gt;</span><span class="s1">maxlevels; ++level) {</span>
        <span class="s1">chain[level]</span><span class="s5">-&gt;</span><span class="s1">width[level] += </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">++(skp</span><span class="s5">-&gt;</span><span class="s1">size);</span>

    <span class="s2">return </span><span class="s1">rank + </span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">PANDAS_INLINE </span><span class="s2">int </span><span class="s1">skiplist_remove(skiplist_t *skp, </span><span class="s2">double </span><span class="s1">value) {</span>
    <span class="s2">int </span><span class="s1">level, size;</span>
    <span class="s1">node_t *node, *prevnode, *tmpnode, *next_at_level;</span>
    <span class="s1">node_t **chain;</span>

    <span class="s1">chain = skp</span><span class="s5">-&gt;</span><span class="s1">tmp_chain;</span>
    <span class="s1">node = skp</span><span class="s5">-&gt;</span><span class="s1">head;</span>

    <span class="s2">for </span><span class="s1">(level = skp</span><span class="s5">-&gt;</span><span class="s1">maxlevels - </span><span class="s4">1</span><span class="s1">; level &gt;= </span><span class="s4">0</span><span class="s1">; --level) {</span>
        <span class="s1">next_at_level = node</span><span class="s5">-&gt;</span><span class="s1">next[level];</span>
        <span class="s2">while </span><span class="s1">(_node_cmp(next_at_level, value) &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">node = next_at_level;</span>
            <span class="s1">next_at_level = node</span><span class="s5">-&gt;</span><span class="s1">next[level];</span>
        <span class="s1">}</span>
        <span class="s1">chain[level] = node;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(value != chain[</span><span class="s4">0</span><span class="s1">]</span><span class="s5">-&gt;</span><span class="s1">next[</span><span class="s4">0</span><span class="s1">]</span><span class="s5">-&gt;</span><span class="s1">value) {</span>
        <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">size = chain[</span><span class="s4">0</span><span class="s1">]</span><span class="s5">-&gt;</span><span class="s1">next[</span><span class="s4">0</span><span class="s1">]</span><span class="s5">-&gt;</span><span class="s1">levels;</span>

    <span class="s2">for </span><span class="s1">(level = </span><span class="s4">0</span><span class="s1">; level &lt; size; ++level) {</span>
        <span class="s1">prevnode = chain[level];</span>

        <span class="s1">tmpnode = prevnode</span><span class="s5">-&gt;</span><span class="s1">next[level];</span>

        <span class="s1">prevnode</span><span class="s5">-&gt;</span><span class="s1">width[level] += tmpnode</span><span class="s5">-&gt;</span><span class="s1">width[level] - </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">prevnode</span><span class="s5">-&gt;</span><span class="s1">next[level] = tmpnode</span><span class="s5">-&gt;</span><span class="s1">next[level];</span>

        <span class="s1">tmpnode</span><span class="s5">-&gt;</span><span class="s1">next[level] = NULL;</span>
        <span class="s1">node_destroy(tmpnode);  </span><span class="s0">// decrement refcount or free</span>
    <span class="s1">}</span>

    <span class="s2">for </span><span class="s1">(level = size; level &lt; skp</span><span class="s5">-&gt;</span><span class="s1">maxlevels; ++level) {</span>
        <span class="s1">--(chain[level]</span><span class="s5">-&gt;</span><span class="s1">width[level]);</span>
    <span class="s1">}</span>

    <span class="s1">--(skp</span><span class="s5">-&gt;</span><span class="s1">size);</span>
    <span class="s2">return </span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">#endif  </span><span class="s0">// PANDAS__LIBS_SRC_SKIPLIST_H_</span>
</pre>
</body>
</html>