<html>
<head>
<title>symbolic.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
symbolic.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Fortran/C symbolic expressions 
 
References: 
- J3/21-007: Draft Fortran 202x. https://j3-fortran.org/doc/year/21/21-007.pdf 
&quot;&quot;&quot;</span>

<span class="s2"># To analyze Fortran expressions to solve dimensions specifications,</span>
<span class="s2"># for instances, we implement a minimal symbolic engine for parsing</span>
<span class="s2"># expressions into a tree of expression instances. As a first</span>
<span class="s2"># instance, we care only about arithmetic expressions involving</span>
<span class="s2"># integers and operations like addition (+), subtraction (-),</span>
<span class="s2"># multiplication (*), division (Fortran / is Python //, Fortran // is</span>
<span class="s2"># concatenate), and exponentiation (**).  In addition, .pyf files may</span>
<span class="s2"># contain C expressions that support here is implemented as well.</span>
<span class="s2">#</span>
<span class="s2"># TODO: support logical constants (Op.BOOLEAN)</span>
<span class="s2"># TODO: support logical operators (.AND., ...)</span>
<span class="s2"># TODO: support defined operators (.MYOP., ...)</span>
<span class="s2">#</span>
<span class="s1">__all__ = [</span><span class="s3">'Expr'</span><span class="s1">]</span>


<span class="s4">import </span><span class="s1">re</span>
<span class="s4">import </span><span class="s1">warnings</span>
<span class="s4">from </span><span class="s1">enum </span><span class="s4">import </span><span class="s1">Enum</span>
<span class="s4">from </span><span class="s1">math </span><span class="s4">import </span><span class="s1">gcd</span>


<span class="s4">class </span><span class="s1">Language(Enum):</span>
    <span class="s0">&quot;&quot;&quot; 
    Used as Expr.tostring language argument. 
    &quot;&quot;&quot;</span>
    <span class="s1">Python = </span><span class="s5">0</span>
    <span class="s1">Fortran = </span><span class="s5">1</span>
    <span class="s1">C = </span><span class="s5">2</span>


<span class="s4">class </span><span class="s1">Op(Enum):</span>
    <span class="s0">&quot;&quot;&quot; 
    Used as Expr op attribute. 
    &quot;&quot;&quot;</span>
    <span class="s1">INTEGER = </span><span class="s5">10</span>
    <span class="s1">REAL = </span><span class="s5">12</span>
    <span class="s1">COMPLEX = </span><span class="s5">15</span>
    <span class="s1">STRING = </span><span class="s5">20</span>
    <span class="s1">ARRAY = </span><span class="s5">30</span>
    <span class="s1">SYMBOL = </span><span class="s5">40</span>
    <span class="s1">TERNARY = </span><span class="s5">100</span>
    <span class="s1">APPLY = </span><span class="s5">200</span>
    <span class="s1">INDEXING = </span><span class="s5">210</span>
    <span class="s1">CONCAT = </span><span class="s5">220</span>
    <span class="s1">RELATIONAL = </span><span class="s5">300</span>
    <span class="s1">TERMS = </span><span class="s5">1000</span>
    <span class="s1">FACTORS = </span><span class="s5">2000</span>
    <span class="s1">REF = </span><span class="s5">3000</span>
    <span class="s1">DEREF = </span><span class="s5">3001</span>


<span class="s4">class </span><span class="s1">RelOp(Enum):</span>
    <span class="s0">&quot;&quot;&quot; 
    Used in Op.RELATIONAL expression to specify the function part. 
    &quot;&quot;&quot;</span>
    <span class="s1">EQ = </span><span class="s5">1</span>
    <span class="s1">NE = </span><span class="s5">2</span>
    <span class="s1">LT = </span><span class="s5">3</span>
    <span class="s1">LE = </span><span class="s5">4</span>
    <span class="s1">GT = </span><span class="s5">5</span>
    <span class="s1">GE = </span><span class="s5">6</span>

    <span class="s1">@classmethod</span>
    <span class="s4">def </span><span class="s1">fromstring(cls</span><span class="s4">, </span><span class="s1">s</span><span class="s4">, </span><span class="s1">language=Language.C):</span>
        <span class="s4">if </span><span class="s1">language </span><span class="s4">is </span><span class="s1">Language.Fortran:</span>
            <span class="s4">return </span><span class="s1">{</span><span class="s3">'.eq.'</span><span class="s1">: RelOp.EQ</span><span class="s4">, </span><span class="s3">'.ne.'</span><span class="s1">: RelOp.NE</span><span class="s4">,</span>
                    <span class="s3">'.lt.'</span><span class="s1">: RelOp.LT</span><span class="s4">, </span><span class="s3">'.le.'</span><span class="s1">: RelOp.LE</span><span class="s4">,</span>
                    <span class="s3">'.gt.'</span><span class="s1">: RelOp.GT</span><span class="s4">, </span><span class="s3">'.ge.'</span><span class="s1">: RelOp.GE}[s.lower()]</span>
        <span class="s4">return </span><span class="s1">{</span><span class="s3">'=='</span><span class="s1">: RelOp.EQ</span><span class="s4">, </span><span class="s3">'!='</span><span class="s1">: RelOp.NE</span><span class="s4">, </span><span class="s3">'&lt;'</span><span class="s1">: RelOp.LT</span><span class="s4">,</span>
                <span class="s3">'&lt;='</span><span class="s1">: RelOp.LE</span><span class="s4">, </span><span class="s3">'&gt;'</span><span class="s1">: RelOp.GT</span><span class="s4">, </span><span class="s3">'&gt;='</span><span class="s1">: RelOp.GE}[s]</span>

    <span class="s4">def </span><span class="s1">tostring(self</span><span class="s4">, </span><span class="s1">language=Language.C):</span>
        <span class="s4">if </span><span class="s1">language </span><span class="s4">is </span><span class="s1">Language.Fortran:</span>
            <span class="s4">return </span><span class="s1">{RelOp.EQ: </span><span class="s3">'.eq.'</span><span class="s4">, </span><span class="s1">RelOp.NE: </span><span class="s3">'.ne.'</span><span class="s4">,</span>
                    <span class="s1">RelOp.LT: </span><span class="s3">'.lt.'</span><span class="s4">, </span><span class="s1">RelOp.LE: </span><span class="s3">'.le.'</span><span class="s4">,</span>
                    <span class="s1">RelOp.GT: </span><span class="s3">'.gt.'</span><span class="s4">, </span><span class="s1">RelOp.GE: </span><span class="s3">'.ge.'</span><span class="s1">}[self]</span>
        <span class="s4">return </span><span class="s1">{RelOp.EQ: </span><span class="s3">'=='</span><span class="s4">, </span><span class="s1">RelOp.NE: </span><span class="s3">'!='</span><span class="s4">,</span>
                <span class="s1">RelOp.LT: </span><span class="s3">'&lt;'</span><span class="s4">, </span><span class="s1">RelOp.LE: </span><span class="s3">'&lt;='</span><span class="s4">,</span>
                <span class="s1">RelOp.GT: </span><span class="s3">'&gt;'</span><span class="s4">, </span><span class="s1">RelOp.GE: </span><span class="s3">'&gt;='</span><span class="s1">}[self]</span>


<span class="s4">class </span><span class="s1">ArithOp(Enum):</span>
    <span class="s0">&quot;&quot;&quot; 
    Used in Op.APPLY expression to specify the function part. 
    &quot;&quot;&quot;</span>
    <span class="s1">POS = </span><span class="s5">1</span>
    <span class="s1">NEG = </span><span class="s5">2</span>
    <span class="s1">ADD = </span><span class="s5">3</span>
    <span class="s1">SUB = </span><span class="s5">4</span>
    <span class="s1">MUL = </span><span class="s5">5</span>
    <span class="s1">DIV = </span><span class="s5">6</span>
    <span class="s1">POW = </span><span class="s5">7</span>


<span class="s4">class </span><span class="s1">OpError(Exception):</span>
    <span class="s4">pass</span>


<span class="s4">class </span><span class="s1">Precedence(Enum):</span>
    <span class="s0">&quot;&quot;&quot; 
    Used as Expr.tostring precedence argument. 
    &quot;&quot;&quot;</span>
    <span class="s1">ATOM = </span><span class="s5">0</span>
    <span class="s1">POWER = </span><span class="s5">1</span>
    <span class="s1">UNARY = </span><span class="s5">2</span>
    <span class="s1">PRODUCT = </span><span class="s5">3</span>
    <span class="s1">SUM = </span><span class="s5">4</span>
    <span class="s1">LT = </span><span class="s5">6</span>
    <span class="s1">EQ = </span><span class="s5">7</span>
    <span class="s1">LAND = </span><span class="s5">11</span>
    <span class="s1">LOR = </span><span class="s5">12</span>
    <span class="s1">TERNARY = </span><span class="s5">13</span>
    <span class="s1">ASSIGN = </span><span class="s5">14</span>
    <span class="s1">TUPLE = </span><span class="s5">15</span>
    <span class="s1">NONE = </span><span class="s5">100</span>


<span class="s1">integer_types = (int</span><span class="s4">,</span><span class="s1">)</span>
<span class="s1">number_types = (int</span><span class="s4">, </span><span class="s1">float)</span>


<span class="s4">def </span><span class="s1">_pairs_add(d</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v):</span>
    <span class="s2"># Internal utility method for updating terms and factors data.</span>
    <span class="s1">c = d.get(k)</span>
    <span class="s4">if </span><span class="s1">c </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">d[k] = v</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">c = c + v</span>
        <span class="s4">if </span><span class="s1">c:</span>
            <span class="s1">d[k] = c</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">del </span><span class="s1">d[k]</span>


<span class="s4">class </span><span class="s1">ExprWarning(UserWarning):</span>
    <span class="s4">pass</span>


<span class="s4">def </span><span class="s1">ewarn(message):</span>
    <span class="s1">warnings.warn(message</span><span class="s4">, </span><span class="s1">ExprWarning</span><span class="s4">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>


<span class="s4">class </span><span class="s1">Expr:</span>
    <span class="s0">&quot;&quot;&quot;Represents a Fortran expression as a op-data pair. 
 
    Expr instances are hashable and sortable. 
    &quot;&quot;&quot;</span>

    <span class="s1">@staticmethod</span>
    <span class="s4">def </span><span class="s1">parse(s</span><span class="s4">, </span><span class="s1">language=Language.C):</span>
        <span class="s0">&quot;&quot;&quot;Parse a Fortran expression to a Expr. 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">fromstring(s</span><span class="s4">, </span><span class="s1">language=language)</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">op</span><span class="s4">, </span><span class="s1">data):</span>
        <span class="s4">assert </span><span class="s1">isinstance(op</span><span class="s4">, </span><span class="s1">Op)</span>

        <span class="s2"># sanity checks</span>
        <span class="s4">if </span><span class="s1">op </span><span class="s4">is </span><span class="s1">Op.INTEGER:</span>
            <span class="s2"># data is a 2-tuple of numeric object and a kind value</span>
            <span class="s2"># (default is 4)</span>
            <span class="s4">assert </span><span class="s1">isinstance(data</span><span class="s4">, </span><span class="s1">tuple) </span><span class="s4">and </span><span class="s1">len(data) == </span><span class="s5">2</span>
            <span class="s4">assert </span><span class="s1">isinstance(data[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">int)</span>
            <span class="s4">assert </span><span class="s1">isinstance(data[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s1">(int</span><span class="s4">, </span><span class="s1">str))</span><span class="s4">, </span><span class="s1">data</span>
        <span class="s4">elif </span><span class="s1">op </span><span class="s4">is </span><span class="s1">Op.REAL:</span>
            <span class="s2"># data is a 2-tuple of numeric object and a kind value</span>
            <span class="s2"># (default is 4)</span>
            <span class="s4">assert </span><span class="s1">isinstance(data</span><span class="s4">, </span><span class="s1">tuple) </span><span class="s4">and </span><span class="s1">len(data) == </span><span class="s5">2</span>
            <span class="s4">assert </span><span class="s1">isinstance(data[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">float)</span>
            <span class="s4">assert </span><span class="s1">isinstance(data[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s1">(int</span><span class="s4">, </span><span class="s1">str))</span><span class="s4">, </span><span class="s1">data</span>
        <span class="s4">elif </span><span class="s1">op </span><span class="s4">is </span><span class="s1">Op.COMPLEX:</span>
            <span class="s2"># data is a 2-tuple of constant expressions</span>
            <span class="s4">assert </span><span class="s1">isinstance(data</span><span class="s4">, </span><span class="s1">tuple) </span><span class="s4">and </span><span class="s1">len(data) == </span><span class="s5">2</span>
        <span class="s4">elif </span><span class="s1">op </span><span class="s4">is </span><span class="s1">Op.STRING:</span>
            <span class="s2"># data is a 2-tuple of quoted string and a kind value</span>
            <span class="s2"># (default is 1)</span>
            <span class="s4">assert </span><span class="s1">isinstance(data</span><span class="s4">, </span><span class="s1">tuple) </span><span class="s4">and </span><span class="s1">len(data) == </span><span class="s5">2</span>
            <span class="s4">assert </span><span class="s1">(isinstance(data[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">str)</span>
                    <span class="s4">and </span><span class="s1">data[</span><span class="s5">0</span><span class="s1">][::len(data[</span><span class="s5">0</span><span class="s1">])-</span><span class="s5">1</span><span class="s1">] </span><span class="s4">in </span><span class="s1">(</span><span class="s3">'&quot;&quot;'</span><span class="s4">, </span><span class="s3">&quot;''&quot;</span><span class="s4">, </span><span class="s3">'@@'</span><span class="s1">))</span>
            <span class="s4">assert </span><span class="s1">isinstance(data[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s1">(int</span><span class="s4">, </span><span class="s1">str))</span><span class="s4">, </span><span class="s1">data</span>
        <span class="s4">elif </span><span class="s1">op </span><span class="s4">is </span><span class="s1">Op.SYMBOL:</span>
            <span class="s2"># data is any hashable object</span>
            <span class="s4">assert </span><span class="s1">hash(data) </span><span class="s4">is not None</span>
        <span class="s4">elif </span><span class="s1">op </span><span class="s4">in </span><span class="s1">(Op.ARRAY</span><span class="s4">, </span><span class="s1">Op.CONCAT):</span>
            <span class="s2"># data is a tuple of expressions</span>
            <span class="s4">assert </span><span class="s1">isinstance(data</span><span class="s4">, </span><span class="s1">tuple)</span>
            <span class="s4">assert </span><span class="s1">all(isinstance(item</span><span class="s4">, </span><span class="s1">Expr) </span><span class="s4">for </span><span class="s1">item </span><span class="s4">in </span><span class="s1">data)</span><span class="s4">, </span><span class="s1">data</span>
        <span class="s4">elif </span><span class="s1">op </span><span class="s4">in </span><span class="s1">(Op.TERMS</span><span class="s4">, </span><span class="s1">Op.FACTORS):</span>
            <span class="s2"># data is {&lt;term|base&gt;:&lt;coeff|exponent&gt;} where dict values</span>
            <span class="s2"># are nonzero Python integers</span>
            <span class="s4">assert </span><span class="s1">isinstance(data</span><span class="s4">, </span><span class="s1">dict)</span>
        <span class="s4">elif </span><span class="s1">op </span><span class="s4">is </span><span class="s1">Op.APPLY:</span>
            <span class="s2"># data is (&lt;function&gt;, &lt;operands&gt;, &lt;kwoperands&gt;) where</span>
            <span class="s2"># operands are Expr instances</span>
            <span class="s4">assert </span><span class="s1">isinstance(data</span><span class="s4">, </span><span class="s1">tuple) </span><span class="s4">and </span><span class="s1">len(data) == </span><span class="s5">3</span>
            <span class="s2"># function is any hashable object</span>
            <span class="s4">assert </span><span class="s1">hash(data[</span><span class="s5">0</span><span class="s1">]) </span><span class="s4">is not None</span>
            <span class="s4">assert </span><span class="s1">isinstance(data[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s1">tuple)</span>
            <span class="s4">assert </span><span class="s1">isinstance(data[</span><span class="s5">2</span><span class="s1">]</span><span class="s4">, </span><span class="s1">dict)</span>
        <span class="s4">elif </span><span class="s1">op </span><span class="s4">is </span><span class="s1">Op.INDEXING:</span>
            <span class="s2"># data is (&lt;object&gt;, &lt;indices&gt;)</span>
            <span class="s4">assert </span><span class="s1">isinstance(data</span><span class="s4">, </span><span class="s1">tuple) </span><span class="s4">and </span><span class="s1">len(data) == </span><span class="s5">2</span>
            <span class="s2"># function is any hashable object</span>
            <span class="s4">assert </span><span class="s1">hash(data[</span><span class="s5">0</span><span class="s1">]) </span><span class="s4">is not None</span>
        <span class="s4">elif </span><span class="s1">op </span><span class="s4">is </span><span class="s1">Op.TERNARY:</span>
            <span class="s2"># data is (&lt;cond&gt;, &lt;expr1&gt;, &lt;expr2&gt;)</span>
            <span class="s4">assert </span><span class="s1">isinstance(data</span><span class="s4">, </span><span class="s1">tuple) </span><span class="s4">and </span><span class="s1">len(data) == </span><span class="s5">3</span>
        <span class="s4">elif </span><span class="s1">op </span><span class="s4">in </span><span class="s1">(Op.REF</span><span class="s4">, </span><span class="s1">Op.DEREF):</span>
            <span class="s2"># data is Expr instance</span>
            <span class="s4">assert </span><span class="s1">isinstance(data</span><span class="s4">, </span><span class="s1">Expr)</span>
        <span class="s4">elif </span><span class="s1">op </span><span class="s4">is </span><span class="s1">Op.RELATIONAL:</span>
            <span class="s2"># data is (&lt;relop&gt;, &lt;left&gt;, &lt;right&gt;)</span>
            <span class="s4">assert </span><span class="s1">isinstance(data</span><span class="s4">, </span><span class="s1">tuple) </span><span class="s4">and </span><span class="s1">len(data) == </span><span class="s5">3</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s3">f'unknown op or missing sanity check: </span><span class="s4">{</span><span class="s1">op</span><span class="s4">}</span><span class="s3">'</span><span class="s1">)</span>

        <span class="s1">self.op = op</span>
        <span class="s1">self.data = data</span>

    <span class="s4">def </span><span class="s1">__eq__(self</span><span class="s4">, </span><span class="s1">other):</span>
        <span class="s4">return </span><span class="s1">(isinstance(other</span><span class="s4">, </span><span class="s1">Expr)</span>
                <span class="s4">and </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">other.op</span>
                <span class="s4">and </span><span class="s1">self.data == other.data)</span>

    <span class="s4">def </span><span class="s1">__hash__(self):</span>
        <span class="s4">if </span><span class="s1">self.op </span><span class="s4">in </span><span class="s1">(Op.TERMS</span><span class="s4">, </span><span class="s1">Op.FACTORS):</span>
            <span class="s1">data = tuple(sorted(self.data.items()))</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.APPLY:</span>
            <span class="s1">data = self.data[:</span><span class="s5">2</span><span class="s1">] + tuple(sorted(self.data[</span><span class="s5">2</span><span class="s1">].items()))</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">data = self.data</span>
        <span class="s4">return </span><span class="s1">hash((self.op</span><span class="s4">, </span><span class="s1">data))</span>

    <span class="s4">def </span><span class="s1">__lt__(self</span><span class="s4">, </span><span class="s1">other):</span>
        <span class="s4">if </span><span class="s1">isinstance(other</span><span class="s4">, </span><span class="s1">Expr):</span>
            <span class="s4">if </span><span class="s1">self.op </span><span class="s4">is not </span><span class="s1">other.op:</span>
                <span class="s4">return </span><span class="s1">self.op.value &lt; other.op.value</span>
            <span class="s4">if </span><span class="s1">self.op </span><span class="s4">in </span><span class="s1">(Op.TERMS</span><span class="s4">, </span><span class="s1">Op.FACTORS):</span>
                <span class="s4">return </span><span class="s1">(tuple(sorted(self.data.items()))</span>
                        <span class="s1">&lt; tuple(sorted(other.data.items())))</span>
            <span class="s4">if </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.APPLY:</span>
                <span class="s4">if </span><span class="s1">self.data[:</span><span class="s5">2</span><span class="s1">] != other.data[:</span><span class="s5">2</span><span class="s1">]:</span>
                    <span class="s4">return </span><span class="s1">self.data[:</span><span class="s5">2</span><span class="s1">] &lt; other.data[:</span><span class="s5">2</span><span class="s1">]</span>
                <span class="s4">return </span><span class="s1">tuple(sorted(self.data[</span><span class="s5">2</span><span class="s1">].items())) &lt; tuple(</span>
                    <span class="s1">sorted(other.data[</span><span class="s5">2</span><span class="s1">].items()))</span>
            <span class="s4">return </span><span class="s1">self.data &lt; other.data</span>
        <span class="s4">return </span><span class="s1">NotImplemented</span>

    <span class="s4">def </span><span class="s1">__le__(self</span><span class="s4">, </span><span class="s1">other): </span><span class="s4">return </span><span class="s1">self == other </span><span class="s4">or </span><span class="s1">self &lt; other</span>

    <span class="s4">def </span><span class="s1">__gt__(self</span><span class="s4">, </span><span class="s1">other): </span><span class="s4">return not </span><span class="s1">(self &lt;= other)</span>

    <span class="s4">def </span><span class="s1">__ge__(self</span><span class="s4">, </span><span class="s1">other): </span><span class="s4">return not </span><span class="s1">(self &lt; other)</span>

    <span class="s4">def </span><span class="s1">__repr__(self):</span>
        <span class="s4">return </span><span class="s3">f'</span><span class="s4">{</span><span class="s1">type(self).__name__</span><span class="s4">}</span><span class="s3">(</span><span class="s4">{</span><span class="s1">self.op</span><span class="s4">}</span><span class="s3">, </span><span class="s4">{</span><span class="s1">self.data</span><span class="s4">!r}</span><span class="s3">)'</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s4">return </span><span class="s1">self.tostring()</span>

    <span class="s4">def </span><span class="s1">tostring(self</span><span class="s4">, </span><span class="s1">parent_precedence=Precedence.NONE</span><span class="s4">,</span>
                 <span class="s1">language=Language.Fortran):</span>
        <span class="s0">&quot;&quot;&quot;Return a string representation of Expr. 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self.op </span><span class="s4">in </span><span class="s1">(Op.INTEGER</span><span class="s4">, </span><span class="s1">Op.REAL):</span>
            <span class="s1">precedence = (Precedence.SUM </span><span class="s4">if </span><span class="s1">self.data[</span><span class="s5">0</span><span class="s1">] &lt; </span><span class="s5">0</span>
                          <span class="s4">else </span><span class="s1">Precedence.ATOM)</span>
            <span class="s1">r = str(self.data[</span><span class="s5">0</span><span class="s1">]) + (</span><span class="s3">f'_</span><span class="s4">{</span><span class="s1">self.data[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">}</span><span class="s3">'</span>
                                     <span class="s4">if </span><span class="s1">self.data[</span><span class="s5">1</span><span class="s1">] != </span><span class="s5">4 </span><span class="s4">else </span><span class="s3">''</span><span class="s1">)</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.COMPLEX:</span>
            <span class="s1">r = </span><span class="s3">', '</span><span class="s1">.join(item.tostring(Precedence.TUPLE</span><span class="s4">, </span><span class="s1">language=language)</span>
                          <span class="s4">for </span><span class="s1">item </span><span class="s4">in </span><span class="s1">self.data)</span>
            <span class="s1">r = </span><span class="s3">'(' </span><span class="s1">+ r + </span><span class="s3">')'</span>
            <span class="s1">precedence = Precedence.ATOM</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.SYMBOL:</span>
            <span class="s1">precedence = Precedence.ATOM</span>
            <span class="s1">r = str(self.data)</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.STRING:</span>
            <span class="s1">r = self.data[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s4">if </span><span class="s1">self.data[</span><span class="s5">1</span><span class="s1">] != </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">r = self.data[</span><span class="s5">1</span><span class="s1">] + </span><span class="s3">'_' </span><span class="s1">+ r</span>
            <span class="s1">precedence = Precedence.ATOM</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.ARRAY:</span>
            <span class="s1">r = </span><span class="s3">', '</span><span class="s1">.join(item.tostring(Precedence.TUPLE</span><span class="s4">, </span><span class="s1">language=language)</span>
                          <span class="s4">for </span><span class="s1">item </span><span class="s4">in </span><span class="s1">self.data)</span>
            <span class="s1">r = </span><span class="s3">'[' </span><span class="s1">+ r + </span><span class="s3">']'</span>
            <span class="s1">precedence = Precedence.ATOM</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.TERMS:</span>
            <span class="s1">terms = []</span>
            <span class="s4">for </span><span class="s1">term</span><span class="s4">, </span><span class="s1">coeff </span><span class="s4">in </span><span class="s1">sorted(self.data.items()):</span>
                <span class="s4">if </span><span class="s1">coeff &lt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">op = </span><span class="s3">' - '</span>
                    <span class="s1">coeff = -coeff</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">op = </span><span class="s3">' + '</span>
                <span class="s4">if </span><span class="s1">coeff == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">term = term.tostring(Precedence.SUM</span><span class="s4">, </span><span class="s1">language=language)</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s4">if </span><span class="s1">term == as_number(</span><span class="s5">1</span><span class="s1">):</span>
                        <span class="s1">term = str(coeff)</span>
                    <span class="s4">else</span><span class="s1">:</span>
                        <span class="s1">term = </span><span class="s3">f'</span><span class="s4">{</span><span class="s1">coeff</span><span class="s4">} </span><span class="s3">* ' </span><span class="s1">+ term.tostring(</span>
                            <span class="s1">Precedence.PRODUCT</span><span class="s4">, </span><span class="s1">language=language)</span>
                <span class="s4">if </span><span class="s1">terms:</span>
                    <span class="s1">terms.append(op)</span>
                <span class="s4">elif </span><span class="s1">op == </span><span class="s3">' - '</span><span class="s1">:</span>
                    <span class="s1">terms.append(</span><span class="s3">'-'</span><span class="s1">)</span>
                <span class="s1">terms.append(term)</span>
            <span class="s1">r = </span><span class="s3">''</span><span class="s1">.join(terms) </span><span class="s4">or </span><span class="s3">'0'</span>
            <span class="s1">precedence = Precedence.SUM </span><span class="s4">if </span><span class="s1">terms </span><span class="s4">else </span><span class="s1">Precedence.ATOM</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.FACTORS:</span>
            <span class="s1">factors = []</span>
            <span class="s1">tail = []</span>
            <span class="s4">for </span><span class="s1">base</span><span class="s4">, </span><span class="s1">exp </span><span class="s4">in </span><span class="s1">sorted(self.data.items()):</span>
                <span class="s1">op = </span><span class="s3">' * '</span>
                <span class="s4">if </span><span class="s1">exp == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">factor = base.tostring(Precedence.PRODUCT</span><span class="s4">,</span>
                                           <span class="s1">language=language)</span>
                <span class="s4">elif </span><span class="s1">language </span><span class="s4">is </span><span class="s1">Language.C:</span>
                    <span class="s4">if </span><span class="s1">exp </span><span class="s4">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s4">, </span><span class="s5">10</span><span class="s1">):</span>
                        <span class="s1">factor = base.tostring(Precedence.PRODUCT</span><span class="s4">,</span>
                                               <span class="s1">language=language)</span>
                        <span class="s1">factor = </span><span class="s3">' * '</span><span class="s1">.join([factor] * exp)</span>
                    <span class="s4">elif </span><span class="s1">exp </span><span class="s4">in </span><span class="s1">range(-</span><span class="s5">10</span><span class="s4">, </span><span class="s5">0</span><span class="s1">):</span>
                        <span class="s1">factor = base.tostring(Precedence.PRODUCT</span><span class="s4">,</span>
                                               <span class="s1">language=language)</span>
                        <span class="s1">tail += [factor] * -exp</span>
                        <span class="s4">continue</span>
                    <span class="s4">else</span><span class="s1">:</span>
                        <span class="s1">factor = base.tostring(Precedence.TUPLE</span><span class="s4">,</span>
                                               <span class="s1">language=language)</span>
                        <span class="s1">factor = </span><span class="s3">f'pow(</span><span class="s4">{</span><span class="s1">factor</span><span class="s4">}</span><span class="s3">, </span><span class="s4">{</span><span class="s1">exp</span><span class="s4">}</span><span class="s3">)'</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">factor = base.tostring(Precedence.POWER</span><span class="s4">,</span>
                                           <span class="s1">language=language) + </span><span class="s3">f' ** </span><span class="s4">{</span><span class="s1">exp</span><span class="s4">}</span><span class="s3">'</span>
                <span class="s4">if </span><span class="s1">factors:</span>
                    <span class="s1">factors.append(op)</span>
                <span class="s1">factors.append(factor)</span>
            <span class="s4">if </span><span class="s1">tail:</span>
                <span class="s4">if not </span><span class="s1">factors:</span>
                    <span class="s1">factors += [</span><span class="s3">'1'</span><span class="s1">]</span>
                <span class="s1">factors += [</span><span class="s3">'/'</span><span class="s4">, </span><span class="s3">'('</span><span class="s4">, </span><span class="s3">' * '</span><span class="s1">.join(tail)</span><span class="s4">, </span><span class="s3">')'</span><span class="s1">]</span>
            <span class="s1">r = </span><span class="s3">''</span><span class="s1">.join(factors) </span><span class="s4">or </span><span class="s3">'1'</span>
            <span class="s1">precedence = Precedence.PRODUCT </span><span class="s4">if </span><span class="s1">factors </span><span class="s4">else </span><span class="s1">Precedence.ATOM</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.APPLY:</span>
            <span class="s1">name</span><span class="s4">, </span><span class="s1">args</span><span class="s4">, </span><span class="s1">kwargs = self.data</span>
            <span class="s4">if </span><span class="s1">name </span><span class="s4">is </span><span class="s1">ArithOp.DIV </span><span class="s4">and </span><span class="s1">language </span><span class="s4">is </span><span class="s1">Language.C:</span>
                <span class="s1">numer</span><span class="s4">, </span><span class="s1">denom = [arg.tostring(Precedence.PRODUCT</span><span class="s4">,</span>
                                             <span class="s1">language=language)</span>
                                <span class="s4">for </span><span class="s1">arg </span><span class="s4">in </span><span class="s1">args]</span>
                <span class="s1">r = </span><span class="s3">f'</span><span class="s4">{</span><span class="s1">numer</span><span class="s4">} </span><span class="s3">/ </span><span class="s4">{</span><span class="s1">denom</span><span class="s4">}</span><span class="s3">'</span>
                <span class="s1">precedence = Precedence.PRODUCT</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">args = [arg.tostring(Precedence.TUPLE</span><span class="s4">, </span><span class="s1">language=language)</span>
                        <span class="s4">for </span><span class="s1">arg </span><span class="s4">in </span><span class="s1">args]</span>
                <span class="s1">args += [k + </span><span class="s3">'=' </span><span class="s1">+ v.tostring(Precedence.NONE)</span>
                         <span class="s4">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s4">in </span><span class="s1">kwargs.items()]</span>
                <span class="s1">r = </span><span class="s3">f'</span><span class="s4">{</span><span class="s1">name</span><span class="s4">}</span><span class="s3">(</span><span class="s4">{</span><span class="s3">&quot;, &quot;</span><span class="s1">.join(args)</span><span class="s4">}</span><span class="s3">)'</span>
                <span class="s1">precedence = Precedence.ATOM</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.INDEXING:</span>
            <span class="s1">name = self.data[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">args = [arg.tostring(Precedence.TUPLE</span><span class="s4">, </span><span class="s1">language=language)</span>
                    <span class="s4">for </span><span class="s1">arg </span><span class="s4">in </span><span class="s1">self.data[</span><span class="s5">1</span><span class="s1">:]]</span>
            <span class="s1">r = </span><span class="s3">f'</span><span class="s4">{</span><span class="s1">name</span><span class="s4">}</span><span class="s3">[</span><span class="s4">{</span><span class="s3">&quot;, &quot;</span><span class="s1">.join(args)</span><span class="s4">}</span><span class="s3">]'</span>
            <span class="s1">precedence = Precedence.ATOM</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.CONCAT:</span>
            <span class="s1">args = [arg.tostring(Precedence.PRODUCT</span><span class="s4">, </span><span class="s1">language=language)</span>
                    <span class="s4">for </span><span class="s1">arg </span><span class="s4">in </span><span class="s1">self.data]</span>
            <span class="s1">r = </span><span class="s3">&quot; // &quot;</span><span class="s1">.join(args)</span>
            <span class="s1">precedence = Precedence.PRODUCT</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.TERNARY:</span>
            <span class="s1">cond</span><span class="s4">, </span><span class="s1">expr1</span><span class="s4">, </span><span class="s1">expr2 = [a.tostring(Precedence.TUPLE</span><span class="s4">,</span>
                                             <span class="s1">language=language)</span>
                                  <span class="s4">for </span><span class="s1">a </span><span class="s4">in </span><span class="s1">self.data]</span>
            <span class="s4">if </span><span class="s1">language </span><span class="s4">is </span><span class="s1">Language.C:</span>
                <span class="s1">r = </span><span class="s3">f'(</span><span class="s4">{</span><span class="s1">cond</span><span class="s4">}</span><span class="s3">?</span><span class="s4">{</span><span class="s1">expr1</span><span class="s4">}</span><span class="s3">:</span><span class="s4">{</span><span class="s1">expr2</span><span class="s4">}</span><span class="s3">)'</span>
            <span class="s4">elif </span><span class="s1">language </span><span class="s4">is </span><span class="s1">Language.Python:</span>
                <span class="s1">r = </span><span class="s3">f'(</span><span class="s4">{</span><span class="s1">expr1</span><span class="s4">} </span><span class="s3">if </span><span class="s4">{</span><span class="s1">cond</span><span class="s4">} </span><span class="s3">else </span><span class="s4">{</span><span class="s1">expr2</span><span class="s4">}</span><span class="s3">)'</span>
            <span class="s4">elif </span><span class="s1">language </span><span class="s4">is </span><span class="s1">Language.Fortran:</span>
                <span class="s1">r = </span><span class="s3">f'merge(</span><span class="s4">{</span><span class="s1">expr1</span><span class="s4">}</span><span class="s3">, </span><span class="s4">{</span><span class="s1">expr2</span><span class="s4">}</span><span class="s3">, </span><span class="s4">{</span><span class="s1">cond</span><span class="s4">}</span><span class="s3">)'</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">NotImplementedError(</span>
                    <span class="s3">f'tostring for </span><span class="s4">{</span><span class="s1">self.op</span><span class="s4">} </span><span class="s3">and </span><span class="s4">{</span><span class="s1">language</span><span class="s4">}</span><span class="s3">'</span><span class="s1">)</span>
            <span class="s1">precedence = Precedence.ATOM</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.REF:</span>
            <span class="s1">r = </span><span class="s3">'&amp;' </span><span class="s1">+ self.data.tostring(Precedence.UNARY</span><span class="s4">, </span><span class="s1">language=language)</span>
            <span class="s1">precedence = Precedence.UNARY</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.DEREF:</span>
            <span class="s1">r = </span><span class="s3">'*' </span><span class="s1">+ self.data.tostring(Precedence.UNARY</span><span class="s4">, </span><span class="s1">language=language)</span>
            <span class="s1">precedence = Precedence.UNARY</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.RELATIONAL:</span>
            <span class="s1">rop</span><span class="s4">, </span><span class="s1">left</span><span class="s4">, </span><span class="s1">right = self.data</span>
            <span class="s1">precedence = (Precedence.EQ </span><span class="s4">if </span><span class="s1">rop </span><span class="s4">in </span><span class="s1">(RelOp.EQ</span><span class="s4">, </span><span class="s1">RelOp.NE)</span>
                          <span class="s4">else </span><span class="s1">Precedence.LT)</span>
            <span class="s1">left = left.tostring(precedence</span><span class="s4">, </span><span class="s1">language=language)</span>
            <span class="s1">right = right.tostring(precedence</span><span class="s4">, </span><span class="s1">language=language)</span>
            <span class="s1">rop = rop.tostring(language=language)</span>
            <span class="s1">r = </span><span class="s3">f'</span><span class="s4">{</span><span class="s1">left</span><span class="s4">} {</span><span class="s1">rop</span><span class="s4">} {</span><span class="s1">right</span><span class="s4">}</span><span class="s3">'</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">NotImplementedError(</span><span class="s3">f'tostring for op </span><span class="s4">{</span><span class="s1">self.op</span><span class="s4">}</span><span class="s3">'</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">parent_precedence.value &lt; precedence.value:</span>
            <span class="s2"># If parent precedence is higher than operand precedence,</span>
            <span class="s2"># operand will be enclosed in parenthesis.</span>
            <span class="s4">return </span><span class="s3">'(' </span><span class="s1">+ r + </span><span class="s3">')'</span>
        <span class="s4">return </span><span class="s1">r</span>

    <span class="s4">def </span><span class="s1">__pos__(self):</span>
        <span class="s4">return </span><span class="s1">self</span>

    <span class="s4">def </span><span class="s1">__neg__(self):</span>
        <span class="s4">return </span><span class="s1">self * -</span><span class="s5">1</span>

    <span class="s4">def </span><span class="s1">__add__(self</span><span class="s4">, </span><span class="s1">other):</span>
        <span class="s1">other = as_expr(other)</span>
        <span class="s4">if </span><span class="s1">isinstance(other</span><span class="s4">, </span><span class="s1">Expr):</span>
            <span class="s4">if </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">other.op:</span>
                <span class="s4">if </span><span class="s1">self.op </span><span class="s4">in </span><span class="s1">(Op.INTEGER</span><span class="s4">, </span><span class="s1">Op.REAL):</span>
                    <span class="s4">return </span><span class="s1">as_number(</span>
                        <span class="s1">self.data[</span><span class="s5">0</span><span class="s1">] + other.data[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">,</span>
                        <span class="s1">max(self.data[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s1">other.data[</span><span class="s5">1</span><span class="s1">]))</span>
                <span class="s4">if </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.COMPLEX:</span>
                    <span class="s1">r1</span><span class="s4">, </span><span class="s1">i1 = self.data</span>
                    <span class="s1">r2</span><span class="s4">, </span><span class="s1">i2 = other.data</span>
                    <span class="s4">return </span><span class="s1">as_complex(r1 + r2</span><span class="s4">, </span><span class="s1">i1 + i2)</span>
                <span class="s4">if </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.TERMS:</span>
                    <span class="s1">r = Expr(self.op</span><span class="s4">, </span><span class="s1">dict(self.data))</span>
                    <span class="s4">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s4">in </span><span class="s1">other.data.items():</span>
                        <span class="s1">_pairs_add(r.data</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v)</span>
                    <span class="s4">return </span><span class="s1">normalize(r)</span>
            <span class="s4">if </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.COMPLEX </span><span class="s4">and </span><span class="s1">other.op </span><span class="s4">in </span><span class="s1">(Op.INTEGER</span><span class="s4">, </span><span class="s1">Op.REAL):</span>
                <span class="s4">return </span><span class="s1">self + as_complex(other)</span>
            <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">in </span><span class="s1">(Op.INTEGER</span><span class="s4">, </span><span class="s1">Op.REAL) </span><span class="s4">and </span><span class="s1">other.op </span><span class="s4">is </span><span class="s1">Op.COMPLEX:</span>
                <span class="s4">return </span><span class="s1">as_complex(self) + other</span>
            <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.REAL </span><span class="s4">and </span><span class="s1">other.op </span><span class="s4">is </span><span class="s1">Op.INTEGER:</span>
                <span class="s4">return </span><span class="s1">self + as_real(other</span><span class="s4">, </span><span class="s1">kind=self.data[</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.INTEGER </span><span class="s4">and </span><span class="s1">other.op </span><span class="s4">is </span><span class="s1">Op.REAL:</span>
                <span class="s4">return </span><span class="s1">as_real(self</span><span class="s4">, </span><span class="s1">kind=other.data[</span><span class="s5">1</span><span class="s1">]) + other</span>
            <span class="s4">return </span><span class="s1">as_terms(self) + as_terms(other)</span>
        <span class="s4">return </span><span class="s1">NotImplemented</span>

    <span class="s4">def </span><span class="s1">__radd__(self</span><span class="s4">, </span><span class="s1">other):</span>
        <span class="s4">if </span><span class="s1">isinstance(other</span><span class="s4">, </span><span class="s1">number_types):</span>
            <span class="s4">return </span><span class="s1">as_number(other) + self</span>
        <span class="s4">return </span><span class="s1">NotImplemented</span>

    <span class="s4">def </span><span class="s1">__sub__(self</span><span class="s4">, </span><span class="s1">other):</span>
        <span class="s4">return </span><span class="s1">self + (-other)</span>

    <span class="s4">def </span><span class="s1">__rsub__(self</span><span class="s4">, </span><span class="s1">other):</span>
        <span class="s4">if </span><span class="s1">isinstance(other</span><span class="s4">, </span><span class="s1">number_types):</span>
            <span class="s4">return </span><span class="s1">as_number(other) - self</span>
        <span class="s4">return </span><span class="s1">NotImplemented</span>

    <span class="s4">def </span><span class="s1">__mul__(self</span><span class="s4">, </span><span class="s1">other):</span>
        <span class="s1">other = as_expr(other)</span>
        <span class="s4">if </span><span class="s1">isinstance(other</span><span class="s4">, </span><span class="s1">Expr):</span>
            <span class="s4">if </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">other.op:</span>
                <span class="s4">if </span><span class="s1">self.op </span><span class="s4">in </span><span class="s1">(Op.INTEGER</span><span class="s4">, </span><span class="s1">Op.REAL):</span>
                    <span class="s4">return </span><span class="s1">as_number(self.data[</span><span class="s5">0</span><span class="s1">] * other.data[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">,</span>
                                     <span class="s1">max(self.data[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s1">other.data[</span><span class="s5">1</span><span class="s1">]))</span>
                <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.COMPLEX:</span>
                    <span class="s1">r1</span><span class="s4">, </span><span class="s1">i1 = self.data</span>
                    <span class="s1">r2</span><span class="s4">, </span><span class="s1">i2 = other.data</span>
                    <span class="s4">return </span><span class="s1">as_complex(r1 * r2 - i1 * i2</span><span class="s4">, </span><span class="s1">r1 * i2 + r2 * i1)</span>

                <span class="s4">if </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.FACTORS:</span>
                    <span class="s1">r = Expr(self.op</span><span class="s4">, </span><span class="s1">dict(self.data))</span>
                    <span class="s4">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s4">in </span><span class="s1">other.data.items():</span>
                        <span class="s1">_pairs_add(r.data</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v)</span>
                    <span class="s4">return </span><span class="s1">normalize(r)</span>
                <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.TERMS:</span>
                    <span class="s1">r = Expr(self.op</span><span class="s4">, </span><span class="s1">{})</span>
                    <span class="s4">for </span><span class="s1">t1</span><span class="s4">, </span><span class="s1">c1 </span><span class="s4">in </span><span class="s1">self.data.items():</span>
                        <span class="s4">for </span><span class="s1">t2</span><span class="s4">, </span><span class="s1">c2 </span><span class="s4">in </span><span class="s1">other.data.items():</span>
                            <span class="s1">_pairs_add(r.data</span><span class="s4">, </span><span class="s1">t1 * t2</span><span class="s4">, </span><span class="s1">c1 * c2)</span>
                    <span class="s4">return </span><span class="s1">normalize(r)</span>

            <span class="s4">if </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.COMPLEX </span><span class="s4">and </span><span class="s1">other.op </span><span class="s4">in </span><span class="s1">(Op.INTEGER</span><span class="s4">, </span><span class="s1">Op.REAL):</span>
                <span class="s4">return </span><span class="s1">self * as_complex(other)</span>
            <span class="s4">elif </span><span class="s1">other.op </span><span class="s4">is </span><span class="s1">Op.COMPLEX </span><span class="s4">and </span><span class="s1">self.op </span><span class="s4">in </span><span class="s1">(Op.INTEGER</span><span class="s4">, </span><span class="s1">Op.REAL):</span>
                <span class="s4">return </span><span class="s1">as_complex(self) * other</span>
            <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.REAL </span><span class="s4">and </span><span class="s1">other.op </span><span class="s4">is </span><span class="s1">Op.INTEGER:</span>
                <span class="s4">return </span><span class="s1">self * as_real(other</span><span class="s4">, </span><span class="s1">kind=self.data[</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.INTEGER </span><span class="s4">and </span><span class="s1">other.op </span><span class="s4">is </span><span class="s1">Op.REAL:</span>
                <span class="s4">return </span><span class="s1">as_real(self</span><span class="s4">, </span><span class="s1">kind=other.data[</span><span class="s5">1</span><span class="s1">]) * other</span>

            <span class="s4">if </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.TERMS:</span>
                <span class="s4">return </span><span class="s1">self * as_terms(other)</span>
            <span class="s4">elif </span><span class="s1">other.op </span><span class="s4">is </span><span class="s1">Op.TERMS:</span>
                <span class="s4">return </span><span class="s1">as_terms(self) * other</span>

            <span class="s4">return </span><span class="s1">as_factors(self) * as_factors(other)</span>
        <span class="s4">return </span><span class="s1">NotImplemented</span>

    <span class="s4">def </span><span class="s1">__rmul__(self</span><span class="s4">, </span><span class="s1">other):</span>
        <span class="s4">if </span><span class="s1">isinstance(other</span><span class="s4">, </span><span class="s1">number_types):</span>
            <span class="s4">return </span><span class="s1">as_number(other) * self</span>
        <span class="s4">return </span><span class="s1">NotImplemented</span>

    <span class="s4">def </span><span class="s1">__pow__(self</span><span class="s4">, </span><span class="s1">other):</span>
        <span class="s1">other = as_expr(other)</span>
        <span class="s4">if </span><span class="s1">isinstance(other</span><span class="s4">, </span><span class="s1">Expr):</span>
            <span class="s4">if </span><span class="s1">other.op </span><span class="s4">is </span><span class="s1">Op.INTEGER:</span>
                <span class="s1">exponent = other.data[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s2"># TODO: other kind not used</span>
                <span class="s4">if </span><span class="s1">exponent == </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s4">return </span><span class="s1">as_number(</span><span class="s5">1</span><span class="s1">)</span>
                <span class="s4">if </span><span class="s1">exponent == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s4">return </span><span class="s1">self</span>
                <span class="s4">if </span><span class="s1">exponent &gt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s4">if </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.FACTORS:</span>
                        <span class="s1">r = Expr(self.op</span><span class="s4">, </span><span class="s1">{})</span>
                        <span class="s4">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s4">in </span><span class="s1">self.data.items():</span>
                            <span class="s1">r.data[k] = v * exponent</span>
                        <span class="s4">return </span><span class="s1">normalize(r)</span>
                    <span class="s4">return </span><span class="s1">self * (self ** (exponent - </span><span class="s5">1</span><span class="s1">))</span>
                <span class="s4">elif </span><span class="s1">exponent != -</span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s4">return </span><span class="s1">(self ** (-exponent)) ** -</span><span class="s5">1</span>
                <span class="s4">return </span><span class="s1">Expr(Op.FACTORS</span><span class="s4">, </span><span class="s1">{self: exponent})</span>
            <span class="s4">return </span><span class="s1">as_apply(ArithOp.POW</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, </span><span class="s1">other)</span>
        <span class="s4">return </span><span class="s1">NotImplemented</span>

    <span class="s4">def </span><span class="s1">__truediv__(self</span><span class="s4">, </span><span class="s1">other):</span>
        <span class="s1">other = as_expr(other)</span>
        <span class="s4">if </span><span class="s1">isinstance(other</span><span class="s4">, </span><span class="s1">Expr):</span>
            <span class="s2"># Fortran / is different from Python /:</span>
            <span class="s2"># - `/` is a truncate operation for integer operands</span>
            <span class="s4">return </span><span class="s1">normalize(as_apply(ArithOp.DIV</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, </span><span class="s1">other))</span>
        <span class="s4">return </span><span class="s1">NotImplemented</span>

    <span class="s4">def </span><span class="s1">__rtruediv__(self</span><span class="s4">, </span><span class="s1">other):</span>
        <span class="s1">other = as_expr(other)</span>
        <span class="s4">if </span><span class="s1">isinstance(other</span><span class="s4">, </span><span class="s1">Expr):</span>
            <span class="s4">return </span><span class="s1">other / self</span>
        <span class="s4">return </span><span class="s1">NotImplemented</span>

    <span class="s4">def </span><span class="s1">__floordiv__(self</span><span class="s4">, </span><span class="s1">other):</span>
        <span class="s1">other = as_expr(other)</span>
        <span class="s4">if </span><span class="s1">isinstance(other</span><span class="s4">, </span><span class="s1">Expr):</span>
            <span class="s2"># Fortran // is different from Python //:</span>
            <span class="s2"># - `//` is a concatenate operation for string operands</span>
            <span class="s4">return </span><span class="s1">normalize(Expr(Op.CONCAT</span><span class="s4">, </span><span class="s1">(self</span><span class="s4">, </span><span class="s1">other)))</span>
        <span class="s4">return </span><span class="s1">NotImplemented</span>

    <span class="s4">def </span><span class="s1">__rfloordiv__(self</span><span class="s4">, </span><span class="s1">other):</span>
        <span class="s1">other = as_expr(other)</span>
        <span class="s4">if </span><span class="s1">isinstance(other</span><span class="s4">, </span><span class="s1">Expr):</span>
            <span class="s4">return </span><span class="s1">other // self</span>
        <span class="s4">return </span><span class="s1">NotImplemented</span>

    <span class="s4">def </span><span class="s1">__call__(self</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kwargs):</span>
        <span class="s2"># In Fortran, parenthesis () are use for both function call as</span>
        <span class="s2"># well as indexing operations.</span>
        <span class="s2">#</span>
        <span class="s2"># TODO: implement a method for deciding when __call__ should</span>
        <span class="s2"># return an INDEXING expression.</span>
        <span class="s4">return </span><span class="s1">as_apply(self</span><span class="s4">, </span><span class="s1">*map(as_expr</span><span class="s4">, </span><span class="s1">args)</span><span class="s4">,</span>
                        <span class="s1">**dict((k</span><span class="s4">, </span><span class="s1">as_expr(v)) </span><span class="s4">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s4">in </span><span class="s1">kwargs.items()))</span>

    <span class="s4">def </span><span class="s1">__getitem__(self</span><span class="s4">, </span><span class="s1">index):</span>
        <span class="s2"># Provided to support C indexing operations that .pyf files</span>
        <span class="s2"># may contain.</span>
        <span class="s1">index = as_expr(index)</span>
        <span class="s4">if not </span><span class="s1">isinstance(index</span><span class="s4">, </span><span class="s1">tuple):</span>
            <span class="s1">index = index</span><span class="s4">,</span>
        <span class="s4">if </span><span class="s1">len(index) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">ewarn(</span><span class="s3">f'C-index should be a single expression but got `</span><span class="s4">{</span><span class="s1">index</span><span class="s4">}</span><span class="s3">`'</span><span class="s1">)</span>
        <span class="s4">return </span><span class="s1">Expr(Op.INDEXING</span><span class="s4">, </span><span class="s1">(self</span><span class="s4">,</span><span class="s1">) + index)</span>

    <span class="s4">def </span><span class="s1">substitute(self</span><span class="s4">, </span><span class="s1">symbols_map):</span>
        <span class="s0">&quot;&quot;&quot;Recursively substitute symbols with values in symbols map. 
 
        Symbols map is a dictionary of symbol-expression pairs. 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.SYMBOL:</span>
            <span class="s1">value = symbols_map.get(self)</span>
            <span class="s4">if </span><span class="s1">value </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s4">return </span><span class="s1">self</span>
            <span class="s1">m = re.match(</span><span class="s3">r'\A(@__f2py_PARENTHESIS_(\w+)_\d+@)\Z'</span><span class="s4">, </span><span class="s1">self.data)</span>
            <span class="s4">if </span><span class="s1">m:</span>
                <span class="s2"># complement to fromstring method</span>
                <span class="s1">items</span><span class="s4">, </span><span class="s1">paren = m.groups()</span>
                <span class="s4">if </span><span class="s1">paren </span><span class="s4">in </span><span class="s1">[</span><span class="s3">'ROUNDDIV'</span><span class="s4">, </span><span class="s3">'SQUARE'</span><span class="s1">]:</span>
                    <span class="s4">return </span><span class="s1">as_array(value)</span>
                <span class="s4">assert </span><span class="s1">paren == </span><span class="s3">'ROUND'</span><span class="s4">, </span><span class="s1">(paren</span><span class="s4">, </span><span class="s1">value)</span>
            <span class="s4">return </span><span class="s1">value</span>
        <span class="s4">if </span><span class="s1">self.op </span><span class="s4">in </span><span class="s1">(Op.INTEGER</span><span class="s4">, </span><span class="s1">Op.REAL</span><span class="s4">, </span><span class="s1">Op.STRING):</span>
            <span class="s4">return </span><span class="s1">self</span>
        <span class="s4">if </span><span class="s1">self.op </span><span class="s4">in </span><span class="s1">(Op.ARRAY</span><span class="s4">, </span><span class="s1">Op.COMPLEX):</span>
            <span class="s4">return </span><span class="s1">Expr(self.op</span><span class="s4">, </span><span class="s1">tuple(item.substitute(symbols_map)</span>
                                       <span class="s4">for </span><span class="s1">item </span><span class="s4">in </span><span class="s1">self.data))</span>
        <span class="s4">if </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.CONCAT:</span>
            <span class="s4">return </span><span class="s1">normalize(Expr(self.op</span><span class="s4">, </span><span class="s1">tuple(item.substitute(symbols_map)</span>
                                                 <span class="s4">for </span><span class="s1">item </span><span class="s4">in </span><span class="s1">self.data)))</span>
        <span class="s4">if </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.TERMS:</span>
            <span class="s1">r = </span><span class="s4">None</span>
            <span class="s4">for </span><span class="s1">term</span><span class="s4">, </span><span class="s1">coeff </span><span class="s4">in </span><span class="s1">self.data.items():</span>
                <span class="s4">if </span><span class="s1">r </span><span class="s4">is None</span><span class="s1">:</span>
                    <span class="s1">r = term.substitute(symbols_map) * coeff</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">r += term.substitute(symbols_map) * coeff</span>
            <span class="s4">if </span><span class="s1">r </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s1">ewarn(</span><span class="s3">'substitute: empty TERMS expression interpreted as'</span>
                      <span class="s3">' int-literal 0'</span><span class="s1">)</span>
                <span class="s4">return </span><span class="s1">as_number(</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s4">return </span><span class="s1">r</span>
        <span class="s4">if </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.FACTORS:</span>
            <span class="s1">r = </span><span class="s4">None</span>
            <span class="s4">for </span><span class="s1">base</span><span class="s4">, </span><span class="s1">exponent </span><span class="s4">in </span><span class="s1">self.data.items():</span>
                <span class="s4">if </span><span class="s1">r </span><span class="s4">is None</span><span class="s1">:</span>
                    <span class="s1">r = base.substitute(symbols_map) ** exponent</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">r *= base.substitute(symbols_map) ** exponent</span>
            <span class="s4">if </span><span class="s1">r </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s1">ewarn(</span><span class="s3">'substitute: empty FACTORS expression interpreted'</span>
                      <span class="s3">' as int-literal 1'</span><span class="s1">)</span>
                <span class="s4">return </span><span class="s1">as_number(</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s4">return </span><span class="s1">r</span>
        <span class="s4">if </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.APPLY:</span>
            <span class="s1">target</span><span class="s4">, </span><span class="s1">args</span><span class="s4">, </span><span class="s1">kwargs = self.data</span>
            <span class="s4">if </span><span class="s1">isinstance(target</span><span class="s4">, </span><span class="s1">Expr):</span>
                <span class="s1">target = target.substitute(symbols_map)</span>
            <span class="s1">args = tuple(a.substitute(symbols_map) </span><span class="s4">for </span><span class="s1">a </span><span class="s4">in </span><span class="s1">args)</span>
            <span class="s1">kwargs = dict((k</span><span class="s4">, </span><span class="s1">v.substitute(symbols_map))</span>
                          <span class="s4">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s4">in </span><span class="s1">kwargs.items())</span>
            <span class="s4">return </span><span class="s1">normalize(Expr(self.op</span><span class="s4">, </span><span class="s1">(target</span><span class="s4">, </span><span class="s1">args</span><span class="s4">, </span><span class="s1">kwargs)))</span>
        <span class="s4">if </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.INDEXING:</span>
            <span class="s1">func = self.data[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s4">if </span><span class="s1">isinstance(func</span><span class="s4">, </span><span class="s1">Expr):</span>
                <span class="s1">func = func.substitute(symbols_map)</span>
            <span class="s1">args = tuple(a.substitute(symbols_map) </span><span class="s4">for </span><span class="s1">a </span><span class="s4">in </span><span class="s1">self.data[</span><span class="s5">1</span><span class="s1">:])</span>
            <span class="s4">return </span><span class="s1">normalize(Expr(self.op</span><span class="s4">, </span><span class="s1">(func</span><span class="s4">,</span><span class="s1">) + args))</span>
        <span class="s4">if </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.TERNARY:</span>
            <span class="s1">operands = tuple(a.substitute(symbols_map) </span><span class="s4">for </span><span class="s1">a </span><span class="s4">in </span><span class="s1">self.data)</span>
            <span class="s4">return </span><span class="s1">normalize(Expr(self.op</span><span class="s4">, </span><span class="s1">operands))</span>
        <span class="s4">if </span><span class="s1">self.op </span><span class="s4">in </span><span class="s1">(Op.REF</span><span class="s4">, </span><span class="s1">Op.DEREF):</span>
            <span class="s4">return </span><span class="s1">normalize(Expr(self.op</span><span class="s4">, </span><span class="s1">self.data.substitute(symbols_map)))</span>
        <span class="s4">if </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.RELATIONAL:</span>
            <span class="s1">rop</span><span class="s4">, </span><span class="s1">left</span><span class="s4">, </span><span class="s1">right = self.data</span>
            <span class="s1">left = left.substitute(symbols_map)</span>
            <span class="s1">right = right.substitute(symbols_map)</span>
            <span class="s4">return </span><span class="s1">normalize(Expr(self.op</span><span class="s4">, </span><span class="s1">(rop</span><span class="s4">, </span><span class="s1">left</span><span class="s4">, </span><span class="s1">right)))</span>
        <span class="s4">raise </span><span class="s1">NotImplementedError(</span><span class="s3">f'substitute method for </span><span class="s4">{</span><span class="s1">self.op</span><span class="s4">}</span><span class="s3">: </span><span class="s4">{</span><span class="s1">self</span><span class="s4">!r}</span><span class="s3">'</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">traverse(self</span><span class="s4">, </span><span class="s1">visit</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot;Traverse expression tree with visit function. 
 
        The visit function is applied to an expression with given args 
        and kwargs. 
 
        Traverse call returns an expression returned by visit when not 
        None, otherwise return a new normalized expression with 
        traverse-visit sub-expressions. 
        &quot;&quot;&quot;</span>
        <span class="s1">result = visit(self</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kwargs)</span>
        <span class="s4">if </span><span class="s1">result </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">result</span>

        <span class="s4">if </span><span class="s1">self.op </span><span class="s4">in </span><span class="s1">(Op.INTEGER</span><span class="s4">, </span><span class="s1">Op.REAL</span><span class="s4">, </span><span class="s1">Op.STRING</span><span class="s4">, </span><span class="s1">Op.SYMBOL):</span>
            <span class="s4">return </span><span class="s1">self</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">in </span><span class="s1">(Op.COMPLEX</span><span class="s4">, </span><span class="s1">Op.ARRAY</span><span class="s4">, </span><span class="s1">Op.CONCAT</span><span class="s4">, </span><span class="s1">Op.TERNARY):</span>
            <span class="s4">return </span><span class="s1">normalize(Expr(self.op</span><span class="s4">, </span><span class="s1">tuple(</span>
                <span class="s1">item.traverse(visit</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kwargs)</span>
                <span class="s4">for </span><span class="s1">item </span><span class="s4">in </span><span class="s1">self.data)))</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">in </span><span class="s1">(Op.TERMS</span><span class="s4">, </span><span class="s1">Op.FACTORS):</span>
            <span class="s1">data = {}</span>
            <span class="s4">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s4">in </span><span class="s1">self.data.items():</span>
                <span class="s1">k = k.traverse(visit</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kwargs)</span>
                <span class="s1">v = (v.traverse(visit</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kwargs)</span>
                     <span class="s4">if </span><span class="s1">isinstance(v</span><span class="s4">, </span><span class="s1">Expr) </span><span class="s4">else </span><span class="s1">v)</span>
                <span class="s4">if </span><span class="s1">k </span><span class="s4">in </span><span class="s1">data:</span>
                    <span class="s1">v = data[k] + v</span>
                <span class="s1">data[k] = v</span>
            <span class="s4">return </span><span class="s1">normalize(Expr(self.op</span><span class="s4">, </span><span class="s1">data))</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.APPLY:</span>
            <span class="s1">obj = self.data[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">func = (obj.traverse(visit</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kwargs)</span>
                    <span class="s4">if </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">Expr) </span><span class="s4">else </span><span class="s1">obj)</span>
            <span class="s1">operands = tuple(operand.traverse(visit</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kwargs)</span>
                             <span class="s4">for </span><span class="s1">operand </span><span class="s4">in </span><span class="s1">self.data[</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s1">kwoperands = dict((k</span><span class="s4">, </span><span class="s1">v.traverse(visit</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kwargs))</span>
                              <span class="s4">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s4">in </span><span class="s1">self.data[</span><span class="s5">2</span><span class="s1">].items())</span>
            <span class="s4">return </span><span class="s1">normalize(Expr(self.op</span><span class="s4">, </span><span class="s1">(func</span><span class="s4">, </span><span class="s1">operands</span><span class="s4">, </span><span class="s1">kwoperands)))</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.INDEXING:</span>
            <span class="s1">obj = self.data[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">obj = (obj.traverse(visit</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kwargs)</span>
                   <span class="s4">if </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">Expr) </span><span class="s4">else </span><span class="s1">obj)</span>
            <span class="s1">indices = tuple(index.traverse(visit</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kwargs)</span>
                            <span class="s4">for </span><span class="s1">index </span><span class="s4">in </span><span class="s1">self.data[</span><span class="s5">1</span><span class="s1">:])</span>
            <span class="s4">return </span><span class="s1">normalize(Expr(self.op</span><span class="s4">, </span><span class="s1">(obj</span><span class="s4">,</span><span class="s1">) + indices))</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">in </span><span class="s1">(Op.REF</span><span class="s4">, </span><span class="s1">Op.DEREF):</span>
            <span class="s4">return </span><span class="s1">normalize(Expr(self.op</span><span class="s4">,</span>
                                  <span class="s1">self.data.traverse(visit</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kwargs)))</span>
        <span class="s4">elif </span><span class="s1">self.op </span><span class="s4">is </span><span class="s1">Op.RELATIONAL:</span>
            <span class="s1">rop</span><span class="s4">, </span><span class="s1">left</span><span class="s4">, </span><span class="s1">right = self.data</span>
            <span class="s1">left = left.traverse(visit</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kwargs)</span>
            <span class="s1">right = right.traverse(visit</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kwargs)</span>
            <span class="s4">return </span><span class="s1">normalize(Expr(self.op</span><span class="s4">, </span><span class="s1">(rop</span><span class="s4">, </span><span class="s1">left</span><span class="s4">, </span><span class="s1">right)))</span>
        <span class="s4">raise </span><span class="s1">NotImplementedError(</span><span class="s3">f'traverse method for </span><span class="s4">{</span><span class="s1">self.op</span><span class="s4">}</span><span class="s3">'</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">contains(self</span><span class="s4">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot;Check if self contains other. 
        &quot;&quot;&quot;</span>
        <span class="s1">found = []</span>

        <span class="s4">def </span><span class="s1">visit(expr</span><span class="s4">, </span><span class="s1">found=found):</span>
            <span class="s4">if </span><span class="s1">found:</span>
                <span class="s4">return </span><span class="s1">expr</span>
            <span class="s4">elif </span><span class="s1">expr == other:</span>
                <span class="s1">found.append(</span><span class="s5">1</span><span class="s1">)</span>
                <span class="s4">return </span><span class="s1">expr</span>

        <span class="s1">self.traverse(visit)</span>

        <span class="s4">return </span><span class="s1">len(found) != </span><span class="s5">0</span>

    <span class="s4">def </span><span class="s1">symbols(self):</span>
        <span class="s0">&quot;&quot;&quot;Return a set of symbols contained in self. 
        &quot;&quot;&quot;</span>
        <span class="s1">found = set()</span>

        <span class="s4">def </span><span class="s1">visit(expr</span><span class="s4">, </span><span class="s1">found=found):</span>
            <span class="s4">if </span><span class="s1">expr.op </span><span class="s4">is </span><span class="s1">Op.SYMBOL:</span>
                <span class="s1">found.add(expr)</span>

        <span class="s1">self.traverse(visit)</span>

        <span class="s4">return </span><span class="s1">found</span>

    <span class="s4">def </span><span class="s1">polynomial_atoms(self):</span>
        <span class="s0">&quot;&quot;&quot;Return a set of expressions used as atoms in polynomial self. 
        &quot;&quot;&quot;</span>
        <span class="s1">found = set()</span>

        <span class="s4">def </span><span class="s1">visit(expr</span><span class="s4">, </span><span class="s1">found=found):</span>
            <span class="s4">if </span><span class="s1">expr.op </span><span class="s4">is </span><span class="s1">Op.FACTORS:</span>
                <span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">expr.data:</span>
                    <span class="s1">b.traverse(visit)</span>
                <span class="s4">return </span><span class="s1">expr</span>
            <span class="s4">if </span><span class="s1">expr.op </span><span class="s4">in </span><span class="s1">(Op.TERMS</span><span class="s4">, </span><span class="s1">Op.COMPLEX):</span>
                <span class="s4">return</span>
            <span class="s4">if </span><span class="s1">expr.op </span><span class="s4">is </span><span class="s1">Op.APPLY </span><span class="s4">and </span><span class="s1">isinstance(expr.data[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">ArithOp):</span>
                <span class="s4">if </span><span class="s1">expr.data[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">is </span><span class="s1">ArithOp.POW:</span>
                    <span class="s1">expr.data[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s1">].traverse(visit)</span>
                    <span class="s4">return </span><span class="s1">expr</span>
                <span class="s4">return</span>
            <span class="s4">if </span><span class="s1">expr.op </span><span class="s4">in </span><span class="s1">(Op.INTEGER</span><span class="s4">, </span><span class="s1">Op.REAL):</span>
                <span class="s4">return </span><span class="s1">expr</span>

            <span class="s1">found.add(expr)</span>

            <span class="s4">if </span><span class="s1">expr.op </span><span class="s4">in </span><span class="s1">(Op.INDEXING</span><span class="s4">, </span><span class="s1">Op.APPLY):</span>
                <span class="s4">return </span><span class="s1">expr</span>

        <span class="s1">self.traverse(visit)</span>

        <span class="s4">return </span><span class="s1">found</span>

    <span class="s4">def </span><span class="s1">linear_solve(self</span><span class="s4">, </span><span class="s1">symbol):</span>
        <span class="s0">&quot;&quot;&quot;Return a, b such that a * symbol + b == self. 
 
        If self is not linear with respect to symbol, raise RuntimeError. 
        &quot;&quot;&quot;</span>
        <span class="s1">b = self.substitute({symbol: as_number(</span><span class="s5">0</span><span class="s1">)})</span>
        <span class="s1">ax = self - b</span>
        <span class="s1">a = ax.substitute({symbol: as_number(</span><span class="s5">1</span><span class="s1">)})</span>

        <span class="s1">zero</span><span class="s4">, </span><span class="s1">_ = as_numer_denom(a * symbol - ax)</span>

        <span class="s4">if </span><span class="s1">zero != as_number(</span><span class="s5">0</span><span class="s1">):</span>
            <span class="s4">raise </span><span class="s1">RuntimeError(</span><span class="s3">f'not a </span><span class="s4">{</span><span class="s1">symbol</span><span class="s4">}</span><span class="s3">-linear equation:'</span>
                               <span class="s3">f' </span><span class="s4">{</span><span class="s1">a</span><span class="s4">} </span><span class="s3">* </span><span class="s4">{</span><span class="s1">symbol</span><span class="s4">} </span><span class="s3">+ </span><span class="s4">{</span><span class="s1">b</span><span class="s4">} </span><span class="s3">== </span><span class="s4">{</span><span class="s1">self</span><span class="s4">}</span><span class="s3">'</span><span class="s1">)</span>
        <span class="s4">return </span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span>


<span class="s4">def </span><span class="s1">normalize(obj):</span>
    <span class="s0">&quot;&quot;&quot;Normalize Expr and apply basic evaluation methods. 
    &quot;&quot;&quot;</span>
    <span class="s4">if not </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">Expr):</span>
        <span class="s4">return </span><span class="s1">obj</span>

    <span class="s4">if </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.TERMS:</span>
        <span class="s1">d = {}</span>
        <span class="s4">for </span><span class="s1">t</span><span class="s4">, </span><span class="s1">c </span><span class="s4">in </span><span class="s1">obj.data.items():</span>
            <span class="s4">if </span><span class="s1">c == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4">continue</span>
            <span class="s4">if </span><span class="s1">t.op </span><span class="s4">is </span><span class="s1">Op.COMPLEX </span><span class="s4">and </span><span class="s1">c != </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">t = t * c</span>
                <span class="s1">c = </span><span class="s5">1</span>
            <span class="s4">if </span><span class="s1">t.op </span><span class="s4">is </span><span class="s1">Op.TERMS:</span>
                <span class="s4">for </span><span class="s1">t1</span><span class="s4">, </span><span class="s1">c1 </span><span class="s4">in </span><span class="s1">t.data.items():</span>
                    <span class="s1">_pairs_add(d</span><span class="s4">, </span><span class="s1">t1</span><span class="s4">, </span><span class="s1">c1 * c)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">_pairs_add(d</span><span class="s4">, </span><span class="s1">t</span><span class="s4">, </span><span class="s1">c)</span>
        <span class="s4">if </span><span class="s1">len(d) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2"># TODO: deterimine correct kind</span>
            <span class="s4">return </span><span class="s1">as_number(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s4">elif </span><span class="s1">len(d) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">(t</span><span class="s4">, </span><span class="s1">c)</span><span class="s4">, </span><span class="s1">= d.items()</span>
            <span class="s4">if </span><span class="s1">c == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s4">return </span><span class="s1">t</span>
        <span class="s4">return </span><span class="s1">Expr(Op.TERMS</span><span class="s4">, </span><span class="s1">d)</span>

    <span class="s4">if </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.FACTORS:</span>
        <span class="s1">coeff = </span><span class="s5">1</span>
        <span class="s1">d = {}</span>
        <span class="s4">for </span><span class="s1">b</span><span class="s4">, </span><span class="s1">e </span><span class="s4">in </span><span class="s1">obj.data.items():</span>
            <span class="s4">if </span><span class="s1">e == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4">continue</span>
            <span class="s4">if </span><span class="s1">b.op </span><span class="s4">is </span><span class="s1">Op.TERMS </span><span class="s4">and </span><span class="s1">isinstance(e</span><span class="s4">, </span><span class="s1">integer_types) </span><span class="s4">and </span><span class="s1">e &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2"># expand integer powers of sums</span>
                <span class="s1">b = b * (b ** (e - </span><span class="s5">1</span><span class="s1">))</span>
                <span class="s1">e = </span><span class="s5">1</span>

            <span class="s4">if </span><span class="s1">b.op </span><span class="s4">in </span><span class="s1">(Op.INTEGER</span><span class="s4">, </span><span class="s1">Op.REAL):</span>
                <span class="s4">if </span><span class="s1">e == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">coeff *= b.data[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s4">elif </span><span class="s1">e &gt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">coeff *= b.data[</span><span class="s5">0</span><span class="s1">] ** e</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">_pairs_add(d</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">e)</span>
            <span class="s4">elif </span><span class="s1">b.op </span><span class="s4">is </span><span class="s1">Op.FACTORS:</span>
                <span class="s4">if </span><span class="s1">e &gt; </span><span class="s5">0 </span><span class="s4">and </span><span class="s1">isinstance(e</span><span class="s4">, </span><span class="s1">integer_types):</span>
                    <span class="s4">for </span><span class="s1">b1</span><span class="s4">, </span><span class="s1">e1 </span><span class="s4">in </span><span class="s1">b.data.items():</span>
                        <span class="s1">_pairs_add(d</span><span class="s4">, </span><span class="s1">b1</span><span class="s4">, </span><span class="s1">e1 * e)</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">_pairs_add(d</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">e)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">_pairs_add(d</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">e)</span>
        <span class="s4">if </span><span class="s1">len(d) == </span><span class="s5">0 </span><span class="s4">or </span><span class="s1">coeff == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2"># TODO: deterimine correct kind</span>
            <span class="s4">assert </span><span class="s1">isinstance(coeff</span><span class="s4">, </span><span class="s1">number_types)</span>
            <span class="s4">return </span><span class="s1">as_number(coeff)</span>
        <span class="s4">elif </span><span class="s1">len(d) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">(b</span><span class="s4">, </span><span class="s1">e)</span><span class="s4">, </span><span class="s1">= d.items()</span>
            <span class="s4">if </span><span class="s1">e == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">t = b</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">t = Expr(Op.FACTORS</span><span class="s4">, </span><span class="s1">d)</span>
            <span class="s4">if </span><span class="s1">coeff == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s4">return </span><span class="s1">t</span>
            <span class="s4">return </span><span class="s1">Expr(Op.TERMS</span><span class="s4">, </span><span class="s1">{t: coeff})</span>
        <span class="s4">elif </span><span class="s1">coeff == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">Expr(Op.FACTORS</span><span class="s4">, </span><span class="s1">d)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">Expr(Op.TERMS</span><span class="s4">, </span><span class="s1">{Expr(Op.FACTORS</span><span class="s4">, </span><span class="s1">d): coeff})</span>

    <span class="s4">if </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.APPLY </span><span class="s4">and </span><span class="s1">obj.data[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">is </span><span class="s1">ArithOp.DIV:</span>
        <span class="s1">dividend</span><span class="s4">, </span><span class="s1">divisor = obj.data[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">t1</span><span class="s4">, </span><span class="s1">c1 = as_term_coeff(dividend)</span>
        <span class="s1">t2</span><span class="s4">, </span><span class="s1">c2 = as_term_coeff(divisor)</span>
        <span class="s4">if </span><span class="s1">isinstance(c1</span><span class="s4">, </span><span class="s1">integer_types) </span><span class="s4">and </span><span class="s1">isinstance(c2</span><span class="s4">, </span><span class="s1">integer_types):</span>
            <span class="s1">g = gcd(c1</span><span class="s4">, </span><span class="s1">c2)</span>
            <span class="s1">c1</span><span class="s4">, </span><span class="s1">c2 = c1//g</span><span class="s4">, </span><span class="s1">c2//g</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">c1</span><span class="s4">, </span><span class="s1">c2 = c1/c2</span><span class="s4">, </span><span class="s5">1</span>

        <span class="s4">if </span><span class="s1">t1.op </span><span class="s4">is </span><span class="s1">Op.APPLY </span><span class="s4">and </span><span class="s1">t1.data[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">is </span><span class="s1">ArithOp.DIV:</span>
            <span class="s1">numer = t1.data[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] * c1</span>
            <span class="s1">denom = t1.data[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">] * t2 * c2</span>
            <span class="s4">return </span><span class="s1">as_apply(ArithOp.DIV</span><span class="s4">, </span><span class="s1">numer</span><span class="s4">, </span><span class="s1">denom)</span>

        <span class="s4">if </span><span class="s1">t2.op </span><span class="s4">is </span><span class="s1">Op.APPLY </span><span class="s4">and </span><span class="s1">t2.data[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">is </span><span class="s1">ArithOp.DIV:</span>
            <span class="s1">numer = t2.data[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">] * t1 * c1</span>
            <span class="s1">denom = t2.data[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] * c2</span>
            <span class="s4">return </span><span class="s1">as_apply(ArithOp.DIV</span><span class="s4">, </span><span class="s1">numer</span><span class="s4">, </span><span class="s1">denom)</span>

        <span class="s1">d = dict(as_factors(t1).data)</span>
        <span class="s4">for </span><span class="s1">b</span><span class="s4">, </span><span class="s1">e </span><span class="s4">in </span><span class="s1">as_factors(t2).data.items():</span>
            <span class="s1">_pairs_add(d</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">-e)</span>
        <span class="s1">numer</span><span class="s4">, </span><span class="s1">denom = {}</span><span class="s4">, </span><span class="s1">{}</span>
        <span class="s4">for </span><span class="s1">b</span><span class="s4">, </span><span class="s1">e </span><span class="s4">in </span><span class="s1">d.items():</span>
            <span class="s4">if </span><span class="s1">e &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">numer[b] = e</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">denom[b] = -e</span>
        <span class="s1">numer = normalize(Expr(Op.FACTORS</span><span class="s4">, </span><span class="s1">numer)) * c1</span>
        <span class="s1">denom = normalize(Expr(Op.FACTORS</span><span class="s4">, </span><span class="s1">denom)) * c2</span>

        <span class="s4">if </span><span class="s1">denom.op </span><span class="s4">in </span><span class="s1">(Op.INTEGER</span><span class="s4">, </span><span class="s1">Op.REAL) </span><span class="s4">and </span><span class="s1">denom.data[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2"># TODO: denom kind not used</span>
            <span class="s4">return </span><span class="s1">numer</span>
        <span class="s4">return </span><span class="s1">as_apply(ArithOp.DIV</span><span class="s4">, </span><span class="s1">numer</span><span class="s4">, </span><span class="s1">denom)</span>

    <span class="s4">if </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.CONCAT:</span>
        <span class="s1">lst = [obj.data[</span><span class="s5">0</span><span class="s1">]]</span>
        <span class="s4">for </span><span class="s1">s </span><span class="s4">in </span><span class="s1">obj.data[</span><span class="s5">1</span><span class="s1">:]:</span>
            <span class="s1">last = lst[-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">last.op </span><span class="s4">is </span><span class="s1">Op.STRING</span>
                    <span class="s4">and </span><span class="s1">s.op </span><span class="s4">is </span><span class="s1">Op.STRING</span>
                    <span class="s4">and </span><span class="s1">last.data[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] </span><span class="s4">in </span><span class="s3">'&quot;</span><span class="s4">\'</span><span class="s3">'</span>
                    <span class="s4">and </span><span class="s1">s.data[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] == last.data[</span><span class="s5">0</span><span class="s1">][-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">):</span>
                <span class="s1">new_last = as_string(last.data[</span><span class="s5">0</span><span class="s1">][:-</span><span class="s5">1</span><span class="s1">] + s.data[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">1</span><span class="s1">:]</span><span class="s4">,</span>
                                     <span class="s1">max(last.data[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s1">s.data[</span><span class="s5">1</span><span class="s1">]))</span>
                <span class="s1">lst[-</span><span class="s5">1</span><span class="s1">] = new_last</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">lst.append(s)</span>
        <span class="s4">if </span><span class="s1">len(lst) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">lst[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s4">return </span><span class="s1">Expr(Op.CONCAT</span><span class="s4">, </span><span class="s1">tuple(lst))</span>

    <span class="s4">if </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.TERNARY:</span>
        <span class="s1">cond</span><span class="s4">, </span><span class="s1">expr1</span><span class="s4">, </span><span class="s1">expr2 = map(normalize</span><span class="s4">, </span><span class="s1">obj.data)</span>
        <span class="s4">if </span><span class="s1">cond.op </span><span class="s4">is </span><span class="s1">Op.INTEGER:</span>
            <span class="s4">return </span><span class="s1">expr1 </span><span class="s4">if </span><span class="s1">cond.data[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">else </span><span class="s1">expr2</span>
        <span class="s4">return </span><span class="s1">Expr(Op.TERNARY</span><span class="s4">, </span><span class="s1">(cond</span><span class="s4">, </span><span class="s1">expr1</span><span class="s4">, </span><span class="s1">expr2))</span>

    <span class="s4">return </span><span class="s1">obj</span>


<span class="s4">def </span><span class="s1">as_expr(obj):</span>
    <span class="s0">&quot;&quot;&quot;Convert non-Expr objects to Expr objects. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">complex):</span>
        <span class="s4">return </span><span class="s1">as_complex(obj.real</span><span class="s4">, </span><span class="s1">obj.imag)</span>
    <span class="s4">if </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">number_types):</span>
        <span class="s4">return </span><span class="s1">as_number(obj)</span>
    <span class="s4">if </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">str):</span>
        <span class="s2"># STRING expression holds string with boundary quotes, hence</span>
        <span class="s2"># applying repr:</span>
        <span class="s4">return </span><span class="s1">as_string(repr(obj))</span>
    <span class="s4">if </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">tuple):</span>
        <span class="s4">return </span><span class="s1">tuple(map(as_expr</span><span class="s4">, </span><span class="s1">obj))</span>
    <span class="s4">return </span><span class="s1">obj</span>


<span class="s4">def </span><span class="s1">as_symbol(obj):</span>
    <span class="s0">&quot;&quot;&quot;Return object as SYMBOL expression (variable or unparsed expression). 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">Expr(Op.SYMBOL</span><span class="s4">, </span><span class="s1">obj)</span>


<span class="s4">def </span><span class="s1">as_number(obj</span><span class="s4">, </span><span class="s1">kind=</span><span class="s5">4</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Return object as INTEGER or REAL constant. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">int):</span>
        <span class="s4">return </span><span class="s1">Expr(Op.INTEGER</span><span class="s4">, </span><span class="s1">(obj</span><span class="s4">, </span><span class="s1">kind))</span>
    <span class="s4">if </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">float):</span>
        <span class="s4">return </span><span class="s1">Expr(Op.REAL</span><span class="s4">, </span><span class="s1">(obj</span><span class="s4">, </span><span class="s1">kind))</span>
    <span class="s4">if </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">Expr):</span>
        <span class="s4">if </span><span class="s1">obj.op </span><span class="s4">in </span><span class="s1">(Op.INTEGER</span><span class="s4">, </span><span class="s1">Op.REAL):</span>
            <span class="s4">return </span><span class="s1">obj</span>
    <span class="s4">raise </span><span class="s1">OpError(</span><span class="s3">f'cannot convert </span><span class="s4">{</span><span class="s1">obj</span><span class="s4">} </span><span class="s3">to INTEGER or REAL constant'</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">as_integer(obj</span><span class="s4">, </span><span class="s1">kind=</span><span class="s5">4</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Return object as INTEGER constant. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">int):</span>
        <span class="s4">return </span><span class="s1">Expr(Op.INTEGER</span><span class="s4">, </span><span class="s1">(obj</span><span class="s4">, </span><span class="s1">kind))</span>
    <span class="s4">if </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">Expr):</span>
        <span class="s4">if </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.INTEGER:</span>
            <span class="s4">return </span><span class="s1">obj</span>
    <span class="s4">raise </span><span class="s1">OpError(</span><span class="s3">f'cannot convert </span><span class="s4">{</span><span class="s1">obj</span><span class="s4">} </span><span class="s3">to INTEGER constant'</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">as_real(obj</span><span class="s4">, </span><span class="s1">kind=</span><span class="s5">4</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Return object as REAL constant. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">int):</span>
        <span class="s4">return </span><span class="s1">Expr(Op.REAL</span><span class="s4">, </span><span class="s1">(float(obj)</span><span class="s4">, </span><span class="s1">kind))</span>
    <span class="s4">if </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">float):</span>
        <span class="s4">return </span><span class="s1">Expr(Op.REAL</span><span class="s4">, </span><span class="s1">(obj</span><span class="s4">, </span><span class="s1">kind))</span>
    <span class="s4">if </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">Expr):</span>
        <span class="s4">if </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.REAL:</span>
            <span class="s4">return </span><span class="s1">obj</span>
        <span class="s4">elif </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.INTEGER:</span>
            <span class="s4">return </span><span class="s1">Expr(Op.REAL</span><span class="s4">, </span><span class="s1">(float(obj.data[</span><span class="s5">0</span><span class="s1">])</span><span class="s4">, </span><span class="s1">kind))</span>
    <span class="s4">raise </span><span class="s1">OpError(</span><span class="s3">f'cannot convert </span><span class="s4">{</span><span class="s1">obj</span><span class="s4">} </span><span class="s3">to REAL constant'</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">as_string(obj</span><span class="s4">, </span><span class="s1">kind=</span><span class="s5">1</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Return object as STRING expression (string literal constant). 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">Expr(Op.STRING</span><span class="s4">, </span><span class="s1">(obj</span><span class="s4">, </span><span class="s1">kind))</span>


<span class="s4">def </span><span class="s1">as_array(obj):</span>
    <span class="s0">&quot;&quot;&quot;Return object as ARRAY expression (array constant). 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">Expr):</span>
        <span class="s1">obj = obj</span><span class="s4">,</span>
    <span class="s4">return </span><span class="s1">Expr(Op.ARRAY</span><span class="s4">, </span><span class="s1">obj)</span>


<span class="s4">def </span><span class="s1">as_complex(real</span><span class="s4">, </span><span class="s1">imag=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Return object as COMPLEX expression (complex literal constant). 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">Expr(Op.COMPLEX</span><span class="s4">, </span><span class="s1">(as_expr(real)</span><span class="s4">, </span><span class="s1">as_expr(imag)))</span>


<span class="s4">def </span><span class="s1">as_apply(func</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot;Return object as APPLY expression (function call, constructor, etc.) 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">Expr(Op.APPLY</span><span class="s4">,</span>
                <span class="s1">(func</span><span class="s4">, </span><span class="s1">tuple(map(as_expr</span><span class="s4">, </span><span class="s1">args))</span><span class="s4">,</span>
                 <span class="s1">dict((k</span><span class="s4">, </span><span class="s1">as_expr(v)) </span><span class="s4">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s4">in </span><span class="s1">kwargs.items())))</span>


<span class="s4">def </span><span class="s1">as_ternary(cond</span><span class="s4">, </span><span class="s1">expr1</span><span class="s4">, </span><span class="s1">expr2):</span>
    <span class="s0">&quot;&quot;&quot;Return object as TERNARY expression (cond?expr1:expr2). 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">Expr(Op.TERNARY</span><span class="s4">, </span><span class="s1">(cond</span><span class="s4">, </span><span class="s1">expr1</span><span class="s4">, </span><span class="s1">expr2))</span>


<span class="s4">def </span><span class="s1">as_ref(expr):</span>
    <span class="s0">&quot;&quot;&quot;Return object as referencing expression. 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">Expr(Op.REF</span><span class="s4">, </span><span class="s1">expr)</span>


<span class="s4">def </span><span class="s1">as_deref(expr):</span>
    <span class="s0">&quot;&quot;&quot;Return object as dereferencing expression. 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">Expr(Op.DEREF</span><span class="s4">, </span><span class="s1">expr)</span>


<span class="s4">def </span><span class="s1">as_eq(left</span><span class="s4">, </span><span class="s1">right):</span>
    <span class="s4">return </span><span class="s1">Expr(Op.RELATIONAL</span><span class="s4">, </span><span class="s1">(RelOp.EQ</span><span class="s4">, </span><span class="s1">left</span><span class="s4">, </span><span class="s1">right))</span>


<span class="s4">def </span><span class="s1">as_ne(left</span><span class="s4">, </span><span class="s1">right):</span>
    <span class="s4">return </span><span class="s1">Expr(Op.RELATIONAL</span><span class="s4">, </span><span class="s1">(RelOp.NE</span><span class="s4">, </span><span class="s1">left</span><span class="s4">, </span><span class="s1">right))</span>


<span class="s4">def </span><span class="s1">as_lt(left</span><span class="s4">, </span><span class="s1">right):</span>
    <span class="s4">return </span><span class="s1">Expr(Op.RELATIONAL</span><span class="s4">, </span><span class="s1">(RelOp.LT</span><span class="s4">, </span><span class="s1">left</span><span class="s4">, </span><span class="s1">right))</span>


<span class="s4">def </span><span class="s1">as_le(left</span><span class="s4">, </span><span class="s1">right):</span>
    <span class="s4">return </span><span class="s1">Expr(Op.RELATIONAL</span><span class="s4">, </span><span class="s1">(RelOp.LE</span><span class="s4">, </span><span class="s1">left</span><span class="s4">, </span><span class="s1">right))</span>


<span class="s4">def </span><span class="s1">as_gt(left</span><span class="s4">, </span><span class="s1">right):</span>
    <span class="s4">return </span><span class="s1">Expr(Op.RELATIONAL</span><span class="s4">, </span><span class="s1">(RelOp.GT</span><span class="s4">, </span><span class="s1">left</span><span class="s4">, </span><span class="s1">right))</span>


<span class="s4">def </span><span class="s1">as_ge(left</span><span class="s4">, </span><span class="s1">right):</span>
    <span class="s4">return </span><span class="s1">Expr(Op.RELATIONAL</span><span class="s4">, </span><span class="s1">(RelOp.GE</span><span class="s4">, </span><span class="s1">left</span><span class="s4">, </span><span class="s1">right))</span>


<span class="s4">def </span><span class="s1">as_terms(obj):</span>
    <span class="s0">&quot;&quot;&quot;Return expression as TERMS expression. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">Expr):</span>
        <span class="s1">obj = normalize(obj)</span>
        <span class="s4">if </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.TERMS:</span>
            <span class="s4">return </span><span class="s1">obj</span>
        <span class="s4">if </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.INTEGER:</span>
            <span class="s4">return </span><span class="s1">Expr(Op.TERMS</span><span class="s4">, </span><span class="s1">{as_integer(</span><span class="s5">1</span><span class="s4">, </span><span class="s1">obj.data[</span><span class="s5">1</span><span class="s1">]): obj.data[</span><span class="s5">0</span><span class="s1">]})</span>
        <span class="s4">if </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.REAL:</span>
            <span class="s4">return </span><span class="s1">Expr(Op.TERMS</span><span class="s4">, </span><span class="s1">{as_real(</span><span class="s5">1</span><span class="s4">, </span><span class="s1">obj.data[</span><span class="s5">1</span><span class="s1">]): obj.data[</span><span class="s5">0</span><span class="s1">]})</span>
        <span class="s4">return </span><span class="s1">Expr(Op.TERMS</span><span class="s4">, </span><span class="s1">{obj: </span><span class="s5">1</span><span class="s1">})</span>
    <span class="s4">raise </span><span class="s1">OpError(</span><span class="s3">f'cannot convert </span><span class="s4">{</span><span class="s1">type(obj)</span><span class="s4">} </span><span class="s3">to terms Expr'</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">as_factors(obj):</span>
    <span class="s0">&quot;&quot;&quot;Return expression as FACTORS expression. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">Expr):</span>
        <span class="s1">obj = normalize(obj)</span>
        <span class="s4">if </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.FACTORS:</span>
            <span class="s4">return </span><span class="s1">obj</span>
        <span class="s4">if </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.TERMS:</span>
            <span class="s4">if </span><span class="s1">len(obj.data) == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">(term</span><span class="s4">, </span><span class="s1">coeff)</span><span class="s4">, </span><span class="s1">= obj.data.items()</span>
                <span class="s4">if </span><span class="s1">coeff == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s4">return </span><span class="s1">Expr(Op.FACTORS</span><span class="s4">, </span><span class="s1">{term: </span><span class="s5">1</span><span class="s1">})</span>
                <span class="s4">return </span><span class="s1">Expr(Op.FACTORS</span><span class="s4">, </span><span class="s1">{term: </span><span class="s5">1</span><span class="s4">, </span><span class="s1">Expr.number(coeff): </span><span class="s5">1</span><span class="s1">})</span>
        <span class="s4">if </span><span class="s1">((obj.op </span><span class="s4">is </span><span class="s1">Op.APPLY</span>
             <span class="s4">and </span><span class="s1">obj.data[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">is </span><span class="s1">ArithOp.DIV</span>
             <span class="s4">and not </span><span class="s1">obj.data[</span><span class="s5">2</span><span class="s1">])):</span>
            <span class="s4">return </span><span class="s1">Expr(Op.FACTORS</span><span class="s4">, </span><span class="s1">{obj.data[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]: </span><span class="s5">1</span><span class="s4">, </span><span class="s1">obj.data[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]: -</span><span class="s5">1</span><span class="s1">})</span>
        <span class="s4">return </span><span class="s1">Expr(Op.FACTORS</span><span class="s4">, </span><span class="s1">{obj: </span><span class="s5">1</span><span class="s1">})</span>
    <span class="s4">raise </span><span class="s1">OpError(</span><span class="s3">f'cannot convert </span><span class="s4">{</span><span class="s1">type(obj)</span><span class="s4">} </span><span class="s3">to terms Expr'</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">as_term_coeff(obj):</span>
    <span class="s0">&quot;&quot;&quot;Return expression as term-coefficient pair. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">Expr):</span>
        <span class="s1">obj = normalize(obj)</span>
        <span class="s4">if </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.INTEGER:</span>
            <span class="s4">return </span><span class="s1">as_integer(</span><span class="s5">1</span><span class="s4">, </span><span class="s1">obj.data[</span><span class="s5">1</span><span class="s1">])</span><span class="s4">, </span><span class="s1">obj.data[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s4">if </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.REAL:</span>
            <span class="s4">return </span><span class="s1">as_real(</span><span class="s5">1</span><span class="s4">, </span><span class="s1">obj.data[</span><span class="s5">1</span><span class="s1">])</span><span class="s4">, </span><span class="s1">obj.data[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s4">if </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.TERMS:</span>
            <span class="s4">if </span><span class="s1">len(obj.data) == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">(term</span><span class="s4">, </span><span class="s1">coeff)</span><span class="s4">, </span><span class="s1">= obj.data.items()</span>
                <span class="s4">return </span><span class="s1">term</span><span class="s4">, </span><span class="s1">coeff</span>
            <span class="s2"># TODO: find common divisor of coefficients</span>
        <span class="s4">if </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.APPLY </span><span class="s4">and </span><span class="s1">obj.data[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">is </span><span class="s1">ArithOp.DIV:</span>
            <span class="s1">t</span><span class="s4">, </span><span class="s1">c = as_term_coeff(obj.data[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s4">return </span><span class="s1">as_apply(ArithOp.DIV</span><span class="s4">, </span><span class="s1">t</span><span class="s4">, </span><span class="s1">obj.data[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">])</span><span class="s4">, </span><span class="s1">c</span>
        <span class="s4">return </span><span class="s1">obj</span><span class="s4">, </span><span class="s5">1</span>
    <span class="s4">raise </span><span class="s1">OpError(</span><span class="s3">f'cannot convert </span><span class="s4">{</span><span class="s1">type(obj)</span><span class="s4">} </span><span class="s3">to term and coeff'</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">as_numer_denom(obj):</span>
    <span class="s0">&quot;&quot;&quot;Return expression as numer-denom pair. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">isinstance(obj</span><span class="s4">, </span><span class="s1">Expr):</span>
        <span class="s1">obj = normalize(obj)</span>
        <span class="s4">if </span><span class="s1">obj.op </span><span class="s4">in </span><span class="s1">(Op.INTEGER</span><span class="s4">, </span><span class="s1">Op.REAL</span><span class="s4">, </span><span class="s1">Op.COMPLEX</span><span class="s4">, </span><span class="s1">Op.SYMBOL</span><span class="s4">,</span>
                      <span class="s1">Op.INDEXING</span><span class="s4">, </span><span class="s1">Op.TERNARY):</span>
            <span class="s4">return </span><span class="s1">obj</span><span class="s4">, </span><span class="s1">as_number(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s4">elif </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.APPLY:</span>
            <span class="s4">if </span><span class="s1">obj.data[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">is </span><span class="s1">ArithOp.DIV </span><span class="s4">and not </span><span class="s1">obj.data[</span><span class="s5">2</span><span class="s1">]:</span>
                <span class="s1">numers</span><span class="s4">, </span><span class="s1">denoms = map(as_numer_denom</span><span class="s4">, </span><span class="s1">obj.data[</span><span class="s5">1</span><span class="s1">])</span>
                <span class="s4">return </span><span class="s1">numers[</span><span class="s5">0</span><span class="s1">] * denoms[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s1">numers[</span><span class="s5">1</span><span class="s1">] * denoms[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s4">return </span><span class="s1">obj</span><span class="s4">, </span><span class="s1">as_number(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s4">elif </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.TERMS:</span>
            <span class="s1">numers</span><span class="s4">, </span><span class="s1">denoms = []</span><span class="s4">, </span><span class="s1">[]</span>
            <span class="s4">for </span><span class="s1">term</span><span class="s4">, </span><span class="s1">coeff </span><span class="s4">in </span><span class="s1">obj.data.items():</span>
                <span class="s1">n</span><span class="s4">, </span><span class="s1">d = as_numer_denom(term)</span>
                <span class="s1">n = n * coeff</span>
                <span class="s1">numers.append(n)</span>
                <span class="s1">denoms.append(d)</span>
            <span class="s1">numer</span><span class="s4">, </span><span class="s1">denom = as_number(</span><span class="s5">0</span><span class="s1">)</span><span class="s4">, </span><span class="s1">as_number(</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(len(numers)):</span>
                <span class="s1">n = numers[i]</span>
                <span class="s4">for </span><span class="s1">j </span><span class="s4">in </span><span class="s1">range(len(numers)):</span>
                    <span class="s4">if </span><span class="s1">i != j:</span>
                        <span class="s1">n *= denoms[j]</span>
                <span class="s1">numer += n</span>
                <span class="s1">denom *= denoms[i]</span>
            <span class="s4">if </span><span class="s1">denom.op </span><span class="s4">in </span><span class="s1">(Op.INTEGER</span><span class="s4">, </span><span class="s1">Op.REAL) </span><span class="s4">and </span><span class="s1">denom.data[</span><span class="s5">0</span><span class="s1">] &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">numer</span><span class="s4">, </span><span class="s1">denom = -numer</span><span class="s4">, </span><span class="s1">-denom</span>
            <span class="s4">return </span><span class="s1">numer</span><span class="s4">, </span><span class="s1">denom</span>
        <span class="s4">elif </span><span class="s1">obj.op </span><span class="s4">is </span><span class="s1">Op.FACTORS:</span>
            <span class="s1">numer</span><span class="s4">, </span><span class="s1">denom = as_number(</span><span class="s5">1</span><span class="s1">)</span><span class="s4">, </span><span class="s1">as_number(</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s4">for </span><span class="s1">b</span><span class="s4">, </span><span class="s1">e </span><span class="s4">in </span><span class="s1">obj.data.items():</span>
                <span class="s1">bnumer</span><span class="s4">, </span><span class="s1">bdenom = as_numer_denom(b)</span>
                <span class="s4">if </span><span class="s1">e &gt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">numer *= bnumer ** e</span>
                    <span class="s1">denom *= bdenom ** e</span>
                <span class="s4">elif </span><span class="s1">e &lt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">numer *= bdenom ** (-e)</span>
                    <span class="s1">denom *= bnumer ** (-e)</span>
            <span class="s4">return </span><span class="s1">numer</span><span class="s4">, </span><span class="s1">denom</span>
    <span class="s4">raise </span><span class="s1">OpError(</span><span class="s3">f'cannot convert </span><span class="s4">{</span><span class="s1">type(obj)</span><span class="s4">} </span><span class="s3">to numer and denom'</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">_counter():</span>
    <span class="s2"># Used internally to generate unique dummy symbols</span>
    <span class="s1">counter = </span><span class="s5">0</span>
    <span class="s4">while True</span><span class="s1">:</span>
        <span class="s1">counter += </span><span class="s5">1</span>
        <span class="s4">yield </span><span class="s1">counter</span>


<span class="s1">COUNTER = _counter()</span>


<span class="s4">def </span><span class="s1">eliminate_quotes(s):</span>
    <span class="s0">&quot;&quot;&quot;Replace quoted substrings of input string. 
 
    Return a new string and a mapping of replacements. 
    &quot;&quot;&quot;</span>
    <span class="s1">d = {}</span>

    <span class="s4">def </span><span class="s1">repl(m):</span>
        <span class="s1">kind</span><span class="s4">, </span><span class="s1">value = m.groups()[:</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s4">if </span><span class="s1">kind:</span>
            <span class="s2"># remove trailing underscore</span>
            <span class="s1">kind = kind[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">p = {</span><span class="s3">&quot;'&quot;</span><span class="s1">: </span><span class="s3">&quot;SINGLE&quot;</span><span class="s4">, </span><span class="s3">'&quot;'</span><span class="s1">: </span><span class="s3">&quot;DOUBLE&quot;</span><span class="s1">}[value[</span><span class="s5">0</span><span class="s1">]]</span>
        <span class="s1">k = </span><span class="s3">f'</span><span class="s4">{</span><span class="s1">kind</span><span class="s4">}</span><span class="s3">@__f2py_QUOTES_</span><span class="s4">{</span><span class="s1">p</span><span class="s4">}</span><span class="s3">_</span><span class="s4">{</span><span class="s1">COUNTER.__next__()</span><span class="s4">}</span><span class="s3">@'</span>
        <span class="s1">d[k] = value</span>
        <span class="s4">return </span><span class="s1">k</span>

    <span class="s1">new_s = re.sub(</span><span class="s3">r'({kind}_|)({single_quoted}|{double_quoted})'</span><span class="s1">.format(</span>
        <span class="s1">kind=</span><span class="s3">r'\w[\w\d_]*'</span><span class="s4">,</span>
        <span class="s1">single_quoted=</span><span class="s3">r&quot;('([^'\\]|(\\.))*')&quot;</span><span class="s4">,</span>
        <span class="s1">double_quoted=</span><span class="s3">r'(&quot;([^&quot;\\]|(\\.))*&quot;)'</span><span class="s1">)</span><span class="s4">,</span>
        <span class="s1">repl</span><span class="s4">, </span><span class="s1">s)</span>

    <span class="s4">assert </span><span class="s3">'&quot;' </span><span class="s4">not in </span><span class="s1">new_s</span>
    <span class="s4">assert </span><span class="s3">&quot;'&quot; </span><span class="s4">not in </span><span class="s1">new_s</span>

    <span class="s4">return </span><span class="s1">new_s</span><span class="s4">, </span><span class="s1">d</span>


<span class="s4">def </span><span class="s1">insert_quotes(s</span><span class="s4">, </span><span class="s1">d):</span>
    <span class="s0">&quot;&quot;&quot;Inverse of eliminate_quotes. 
    &quot;&quot;&quot;</span>
    <span class="s4">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s4">in </span><span class="s1">d.items():</span>
        <span class="s1">kind = k[:k.find(</span><span class="s3">'@'</span><span class="s1">)]</span>
        <span class="s4">if </span><span class="s1">kind:</span>
            <span class="s1">kind += </span><span class="s3">'_'</span>
        <span class="s1">s = s.replace(k</span><span class="s4">, </span><span class="s1">kind + v)</span>
    <span class="s4">return </span><span class="s1">s</span>


<span class="s4">def </span><span class="s1">replace_parenthesis(s):</span>
    <span class="s0">&quot;&quot;&quot;Replace substrings of input that are enclosed in parenthesis. 
 
    Return a new string and a mapping of replacements. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Find a parenthesis pair that appears first.</span>

    <span class="s2"># Fortran deliminator are `(`, `)`, `[`, `]`, `(/', '/)`, `/`.</span>
    <span class="s2"># We don't handle `/` deliminator because it is not a part of an</span>
    <span class="s2"># expression.</span>
    <span class="s1">left</span><span class="s4">, </span><span class="s1">right = </span><span class="s4">None, None</span>
    <span class="s1">mn_i = len(s)</span>
    <span class="s4">for </span><span class="s1">left_</span><span class="s4">, </span><span class="s1">right_ </span><span class="s4">in </span><span class="s1">((</span><span class="s3">'(/'</span><span class="s4">, </span><span class="s3">'/)'</span><span class="s1">)</span><span class="s4">,</span>
                          <span class="s3">'()'</span><span class="s4">,</span>
                          <span class="s3">'{}'</span><span class="s4">,  </span><span class="s2"># to support C literal structs</span>
                          <span class="s3">'[]'</span><span class="s1">):</span>
        <span class="s1">i = s.find(left_)</span>
        <span class="s4">if </span><span class="s1">i == -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">continue</span>
        <span class="s4">if </span><span class="s1">i &lt; mn_i:</span>
            <span class="s1">mn_i = i</span>
            <span class="s1">left</span><span class="s4">, </span><span class="s1">right = left_</span><span class="s4">, </span><span class="s1">right_</span>

    <span class="s4">if </span><span class="s1">left </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">s</span><span class="s4">, </span><span class="s1">{}</span>

    <span class="s1">i = mn_i</span>
    <span class="s1">j = s.find(right</span><span class="s4">, </span><span class="s1">i)</span>

    <span class="s4">while </span><span class="s1">s.count(left</span><span class="s4">, </span><span class="s1">i + </span><span class="s5">1</span><span class="s4">, </span><span class="s1">j) != s.count(right</span><span class="s4">, </span><span class="s1">i + </span><span class="s5">1</span><span class="s4">, </span><span class="s1">j):</span>
        <span class="s1">j = s.find(right</span><span class="s4">, </span><span class="s1">j + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">j == -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">f'Mismatch of </span><span class="s4">{</span><span class="s1">left+right</span><span class="s4">} </span><span class="s3">parenthesis in </span><span class="s4">{</span><span class="s1">s</span><span class="s4">!r}</span><span class="s3">'</span><span class="s1">)</span>

    <span class="s1">p = {</span><span class="s3">'('</span><span class="s1">: </span><span class="s3">'ROUND'</span><span class="s4">, </span><span class="s3">'['</span><span class="s1">: </span><span class="s3">'SQUARE'</span><span class="s4">, </span><span class="s3">'{'</span><span class="s1">: </span><span class="s3">'CURLY'</span><span class="s4">, </span><span class="s3">'(/'</span><span class="s1">: </span><span class="s3">'ROUNDDIV'</span><span class="s1">}[left]</span>

    <span class="s1">k = </span><span class="s3">f'@__f2py_PARENTHESIS_</span><span class="s4">{</span><span class="s1">p</span><span class="s4">}</span><span class="s3">_</span><span class="s4">{</span><span class="s1">COUNTER.__next__()</span><span class="s4">}</span><span class="s3">@'</span>
    <span class="s1">v = s[i+len(left):j]</span>
    <span class="s1">r</span><span class="s4">, </span><span class="s1">d = replace_parenthesis(s[j+len(right):])</span>
    <span class="s1">d[k] = v</span>
    <span class="s4">return </span><span class="s1">s[:i] + k + r</span><span class="s4">, </span><span class="s1">d</span>


<span class="s4">def </span><span class="s1">_get_parenthesis_kind(s):</span>
    <span class="s4">assert </span><span class="s1">s.startswith(</span><span class="s3">'@__f2py_PARENTHESIS_'</span><span class="s1">)</span><span class="s4">, </span><span class="s1">s</span>
    <span class="s4">return </span><span class="s1">s.split(</span><span class="s3">'_'</span><span class="s1">)[</span><span class="s5">4</span><span class="s1">]</span>


<span class="s4">def </span><span class="s1">unreplace_parenthesis(s</span><span class="s4">, </span><span class="s1">d):</span>
    <span class="s0">&quot;&quot;&quot;Inverse of replace_parenthesis. 
    &quot;&quot;&quot;</span>
    <span class="s4">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s4">in </span><span class="s1">d.items():</span>
        <span class="s1">p = _get_parenthesis_kind(k)</span>
        <span class="s1">left = dict(ROUND=</span><span class="s3">'('</span><span class="s4">, </span><span class="s1">SQUARE=</span><span class="s3">'['</span><span class="s4">, </span><span class="s1">CURLY=</span><span class="s3">'{'</span><span class="s4">, </span><span class="s1">ROUNDDIV=</span><span class="s3">'(/'</span><span class="s1">)[p]</span>
        <span class="s1">right = dict(ROUND=</span><span class="s3">')'</span><span class="s4">, </span><span class="s1">SQUARE=</span><span class="s3">']'</span><span class="s4">, </span><span class="s1">CURLY=</span><span class="s3">'}'</span><span class="s4">, </span><span class="s1">ROUNDDIV=</span><span class="s3">'/)'</span><span class="s1">)[p]</span>
        <span class="s1">s = s.replace(k</span><span class="s4">, </span><span class="s1">left + v + right)</span>
    <span class="s4">return </span><span class="s1">s</span>


<span class="s4">def </span><span class="s1">fromstring(s</span><span class="s4">, </span><span class="s1">language=Language.C):</span>
    <span class="s0">&quot;&quot;&quot;Create an expression from a string. 
 
    This is a &quot;lazy&quot; parser, that is, only arithmetic operations are 
    resolved, non-arithmetic operations are treated as symbols. 
    &quot;&quot;&quot;</span>
    <span class="s1">r = _FromStringWorker(language=language).parse(s)</span>
    <span class="s4">if </span><span class="s1">isinstance(r</span><span class="s4">, </span><span class="s1">Expr):</span>
        <span class="s4">return </span><span class="s1">r</span>
    <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">f'failed to parse `</span><span class="s4">{</span><span class="s1">s</span><span class="s4">}</span><span class="s3">` to Expr instance: got `</span><span class="s4">{</span><span class="s1">r</span><span class="s4">}</span><span class="s3">`'</span><span class="s1">)</span>


<span class="s4">class </span><span class="s1">_Pair:</span>
    <span class="s2"># Internal class to represent a pair of expressions</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">left</span><span class="s4">, </span><span class="s1">right):</span>
        <span class="s1">self.left = left</span>
        <span class="s1">self.right = right</span>

    <span class="s4">def </span><span class="s1">substitute(self</span><span class="s4">, </span><span class="s1">symbols_map):</span>
        <span class="s1">left</span><span class="s4">, </span><span class="s1">right = self.left</span><span class="s4">, </span><span class="s1">self.right</span>
        <span class="s4">if </span><span class="s1">isinstance(left</span><span class="s4">, </span><span class="s1">Expr):</span>
            <span class="s1">left = left.substitute(symbols_map)</span>
        <span class="s4">if </span><span class="s1">isinstance(right</span><span class="s4">, </span><span class="s1">Expr):</span>
            <span class="s1">right = right.substitute(symbols_map)</span>
        <span class="s4">return </span><span class="s1">_Pair(left</span><span class="s4">, </span><span class="s1">right)</span>

    <span class="s4">def </span><span class="s1">__repr__(self):</span>
        <span class="s4">return </span><span class="s3">f'</span><span class="s4">{</span><span class="s1">type(self).__name__</span><span class="s4">}</span><span class="s3">(</span><span class="s4">{</span><span class="s1">self.left</span><span class="s4">}</span><span class="s3">, </span><span class="s4">{</span><span class="s1">self.right</span><span class="s4">}</span><span class="s3">)'</span>


<span class="s4">class </span><span class="s1">_FromStringWorker:</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">language=Language.C):</span>
        <span class="s1">self.original = </span><span class="s4">None</span>
        <span class="s1">self.quotes_map = </span><span class="s4">None</span>
        <span class="s1">self.language = language</span>

    <span class="s4">def </span><span class="s1">finalize_string(self</span><span class="s4">, </span><span class="s1">s):</span>
        <span class="s4">return </span><span class="s1">insert_quotes(s</span><span class="s4">, </span><span class="s1">self.quotes_map)</span>

    <span class="s4">def </span><span class="s1">parse(self</span><span class="s4">, </span><span class="s1">inp):</span>
        <span class="s1">self.original = inp</span>
        <span class="s1">unquoted</span><span class="s4">, </span><span class="s1">self.quotes_map = eliminate_quotes(inp)</span>
        <span class="s4">return </span><span class="s1">self.process(unquoted)</span>

    <span class="s4">def </span><span class="s1">process(self</span><span class="s4">, </span><span class="s1">s</span><span class="s4">, </span><span class="s1">context=</span><span class="s3">'expr'</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Parse string within the given context. 
 
        The context may define the result in case of ambiguous 
        expressions. For instance, consider expressions `f(x, y)` and 
        `(x, y) + (a, b)` where `f` is a function and pair `(x, y)` 
        denotes complex number. Specifying context as &quot;args&quot; or 
        &quot;expr&quot;, the subexpression `(x, y)` will be parse to an 
        argument list or to a complex number, respectively. 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">isinstance(s</span><span class="s4">, </span><span class="s1">(list</span><span class="s4">, </span><span class="s1">tuple)):</span>
            <span class="s4">return </span><span class="s1">type(s)(self.process(s_</span><span class="s4">, </span><span class="s1">context) </span><span class="s4">for </span><span class="s1">s_ </span><span class="s4">in </span><span class="s1">s)</span>

        <span class="s4">assert </span><span class="s1">isinstance(s</span><span class="s4">, </span><span class="s1">str)</span><span class="s4">, </span><span class="s1">(type(s)</span><span class="s4">, </span><span class="s1">s)</span>

        <span class="s2"># replace subexpressions in parenthesis with f2py @-names</span>
        <span class="s1">r</span><span class="s4">, </span><span class="s1">raw_symbols_map = replace_parenthesis(s)</span>
        <span class="s1">r = r.strip()</span>

        <span class="s4">def </span><span class="s1">restore(r):</span>
            <span class="s2"># restores subexpressions marked with f2py @-names</span>
            <span class="s4">if </span><span class="s1">isinstance(r</span><span class="s4">, </span><span class="s1">(list</span><span class="s4">, </span><span class="s1">tuple)):</span>
                <span class="s4">return </span><span class="s1">type(r)(map(restore</span><span class="s4">, </span><span class="s1">r))</span>
            <span class="s4">return </span><span class="s1">unreplace_parenthesis(r</span><span class="s4">, </span><span class="s1">raw_symbols_map)</span>

        <span class="s2"># comma-separated tuple</span>
        <span class="s4">if </span><span class="s3">',' </span><span class="s4">in </span><span class="s1">r:</span>
            <span class="s1">operands = restore(r.split(</span><span class="s3">','</span><span class="s1">))</span>
            <span class="s4">if </span><span class="s1">context == </span><span class="s3">'args'</span><span class="s1">:</span>
                <span class="s4">return </span><span class="s1">tuple(self.process(operands))</span>
            <span class="s4">if </span><span class="s1">context == </span><span class="s3">'expr'</span><span class="s1">:</span>
                <span class="s4">if </span><span class="s1">len(operands) == </span><span class="s5">2</span><span class="s1">:</span>
                    <span class="s2"># complex number literal</span>
                    <span class="s4">return </span><span class="s1">as_complex(*self.process(operands))</span>
            <span class="s4">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s3">f'parsing comma-separated list (context=</span><span class="s4">{</span><span class="s1">context</span><span class="s4">}</span><span class="s3">): </span><span class="s4">{</span><span class="s1">r</span><span class="s4">}</span><span class="s3">'</span><span class="s1">)</span>

        <span class="s2"># ternary operation</span>
        <span class="s1">m = re.match(</span><span class="s3">r'\A([^?]+)[?]([^:]+)[:](.+)\Z'</span><span class="s4">, </span><span class="s1">r)</span>
        <span class="s4">if </span><span class="s1">m:</span>
            <span class="s4">assert </span><span class="s1">context == </span><span class="s3">'expr'</span><span class="s4">, </span><span class="s1">context</span>
            <span class="s1">oper</span><span class="s4">, </span><span class="s1">expr1</span><span class="s4">, </span><span class="s1">expr2 = restore(m.groups())</span>
            <span class="s1">oper = self.process(oper)</span>
            <span class="s1">expr1 = self.process(expr1)</span>
            <span class="s1">expr2 = self.process(expr2)</span>
            <span class="s4">return </span><span class="s1">as_ternary(oper</span><span class="s4">, </span><span class="s1">expr1</span><span class="s4">, </span><span class="s1">expr2)</span>

        <span class="s2"># relational expression</span>
        <span class="s4">if </span><span class="s1">self.language </span><span class="s4">is </span><span class="s1">Language.Fortran:</span>
            <span class="s1">m = re.match(</span>
                <span class="s3">r'\A(.+)\s*[.](eq|ne|lt|le|gt|ge)[.]\s*(.+)\Z'</span><span class="s4">, </span><span class="s1">r</span><span class="s4">, </span><span class="s1">re.I)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">m = re.match(</span>
                <span class="s3">r'\A(.+)\s*([=][=]|[!][=]|[&lt;][=]|[&lt;]|[&gt;][=]|[&gt;])\s*(.+)\Z'</span><span class="s4">, </span><span class="s1">r)</span>
        <span class="s4">if </span><span class="s1">m:</span>
            <span class="s1">left</span><span class="s4">, </span><span class="s1">rop</span><span class="s4">, </span><span class="s1">right = m.groups()</span>
            <span class="s4">if </span><span class="s1">self.language </span><span class="s4">is </span><span class="s1">Language.Fortran:</span>
                <span class="s1">rop = </span><span class="s3">'.' </span><span class="s1">+ rop + </span><span class="s3">'.'</span>
            <span class="s1">left</span><span class="s4">, </span><span class="s1">right = self.process(restore((left</span><span class="s4">, </span><span class="s1">right)))</span>
            <span class="s1">rop = RelOp.fromstring(rop</span><span class="s4">, </span><span class="s1">language=self.language)</span>
            <span class="s4">return </span><span class="s1">Expr(Op.RELATIONAL</span><span class="s4">, </span><span class="s1">(rop</span><span class="s4">, </span><span class="s1">left</span><span class="s4">, </span><span class="s1">right))</span>

        <span class="s2"># keyword argument</span>
        <span class="s1">m = re.match(</span><span class="s3">r'\A(\w[\w\d_]*)\s*[=](.*)\Z'</span><span class="s4">, </span><span class="s1">r)</span>
        <span class="s4">if </span><span class="s1">m:</span>
            <span class="s1">keyname</span><span class="s4">, </span><span class="s1">value = m.groups()</span>
            <span class="s1">value = restore(value)</span>
            <span class="s4">return </span><span class="s1">_Pair(keyname</span><span class="s4">, </span><span class="s1">self.process(value))</span>

        <span class="s2"># addition/subtraction operations</span>
        <span class="s1">operands = re.split(</span><span class="s3">r'((?&lt;!\d[edED])[+-])'</span><span class="s4">, </span><span class="s1">r)</span>
        <span class="s4">if </span><span class="s1">len(operands) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">result = self.process(restore(operands[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">or </span><span class="s3">'0'</span><span class="s1">))</span>
            <span class="s4">for </span><span class="s1">op</span><span class="s4">, </span><span class="s1">operand </span><span class="s4">in </span><span class="s1">zip(operands[</span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span><span class="s4">, </span><span class="s1">operands[</span><span class="s5">2</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]):</span>
                <span class="s1">operand = self.process(restore(operand))</span>
                <span class="s1">op = op.strip()</span>
                <span class="s4">if </span><span class="s1">op == </span><span class="s3">'+'</span><span class="s1">:</span>
                    <span class="s1">result += operand</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s4">assert </span><span class="s1">op == </span><span class="s3">'-'</span>
                    <span class="s1">result -= operand</span>
            <span class="s4">return </span><span class="s1">result</span>

        <span class="s2"># string concatenate operation</span>
        <span class="s4">if </span><span class="s1">self.language </span><span class="s4">is </span><span class="s1">Language.Fortran </span><span class="s4">and </span><span class="s3">'//' </span><span class="s4">in </span><span class="s1">r:</span>
            <span class="s1">operands = restore(r.split(</span><span class="s3">'//'</span><span class="s1">))</span>
            <span class="s4">return </span><span class="s1">Expr(Op.CONCAT</span><span class="s4">,</span>
                        <span class="s1">tuple(self.process(operands)))</span>

        <span class="s2"># multiplication/division operations</span>
        <span class="s1">operands = re.split(</span><span class="s3">r'(?&lt;=[@\w\d_])\s*([*]|/)'</span><span class="s4">,</span>
                            <span class="s1">(r </span><span class="s4">if </span><span class="s1">self.language </span><span class="s4">is </span><span class="s1">Language.C</span>
                             <span class="s4">else </span><span class="s1">r.replace(</span><span class="s3">'**'</span><span class="s4">, </span><span class="s3">'@__f2py_DOUBLE_STAR@'</span><span class="s1">)))</span>
        <span class="s4">if </span><span class="s1">len(operands) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">operands = restore(operands)</span>
            <span class="s4">if </span><span class="s1">self.language </span><span class="s4">is not </span><span class="s1">Language.C:</span>
                <span class="s1">operands = [operand.replace(</span><span class="s3">'@__f2py_DOUBLE_STAR@'</span><span class="s4">, </span><span class="s3">'**'</span><span class="s1">)</span>
                            <span class="s4">for </span><span class="s1">operand </span><span class="s4">in </span><span class="s1">operands]</span>
            <span class="s2"># Expression is an arithmetic product</span>
            <span class="s1">result = self.process(operands[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s4">for </span><span class="s1">op</span><span class="s4">, </span><span class="s1">operand </span><span class="s4">in </span><span class="s1">zip(operands[</span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span><span class="s4">, </span><span class="s1">operands[</span><span class="s5">2</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]):</span>
                <span class="s1">operand = self.process(operand)</span>
                <span class="s1">op = op.strip()</span>
                <span class="s4">if </span><span class="s1">op == </span><span class="s3">'*'</span><span class="s1">:</span>
                    <span class="s1">result *= operand</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s4">assert </span><span class="s1">op == </span><span class="s3">'/'</span>
                    <span class="s1">result /= operand</span>
            <span class="s4">return </span><span class="s1">result</span>

        <span class="s2"># referencing/dereferencing</span>
        <span class="s4">if </span><span class="s1">r.startswith(</span><span class="s3">'*'</span><span class="s1">) </span><span class="s4">or </span><span class="s1">r.startswith(</span><span class="s3">'&amp;'</span><span class="s1">):</span>
            <span class="s1">op = {</span><span class="s3">'*'</span><span class="s1">: Op.DEREF</span><span class="s4">, </span><span class="s3">'&amp;'</span><span class="s1">: Op.REF}[r[</span><span class="s5">0</span><span class="s1">]]</span>
            <span class="s1">operand = self.process(restore(r[</span><span class="s5">1</span><span class="s1">:]))</span>
            <span class="s4">return </span><span class="s1">Expr(op</span><span class="s4">, </span><span class="s1">operand)</span>

        <span class="s2"># exponentiation operations</span>
        <span class="s4">if </span><span class="s1">self.language </span><span class="s4">is not </span><span class="s1">Language.C </span><span class="s4">and </span><span class="s3">'**' </span><span class="s4">in </span><span class="s1">r:</span>
            <span class="s1">operands = list(reversed(restore(r.split(</span><span class="s3">'**'</span><span class="s1">))))</span>
            <span class="s1">result = self.process(operands[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s4">for </span><span class="s1">operand </span><span class="s4">in </span><span class="s1">operands[</span><span class="s5">1</span><span class="s1">:]:</span>
                <span class="s1">operand = self.process(operand)</span>
                <span class="s1">result = operand ** result</span>
            <span class="s4">return </span><span class="s1">result</span>

        <span class="s2"># int-literal-constant</span>
        <span class="s1">m = re.match(</span><span class="s3">r'\A({digit_string})({kind}|)\Z'</span><span class="s1">.format(</span>
            <span class="s1">digit_string=</span><span class="s3">r'\d+'</span><span class="s4">,</span>
            <span class="s1">kind=</span><span class="s3">r'_(\d+|\w[\w\d_]*)'</span><span class="s1">)</span><span class="s4">, </span><span class="s1">r)</span>
        <span class="s4">if </span><span class="s1">m:</span>
            <span class="s1">value</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">kind = m.groups()</span>
            <span class="s4">if </span><span class="s1">kind </span><span class="s4">and </span><span class="s1">kind.isdigit():</span>
                <span class="s1">kind = int(kind)</span>
            <span class="s4">return </span><span class="s1">as_integer(int(value)</span><span class="s4">, </span><span class="s1">kind </span><span class="s4">or </span><span class="s5">4</span><span class="s1">)</span>

        <span class="s2"># real-literal-constant</span>
        <span class="s1">m = re.match(</span><span class="s3">r'\A({significant}({exponent}|)|\d+{exponent})({kind}|)\Z'</span>
                     <span class="s1">.format(</span>
                         <span class="s1">significant=</span><span class="s3">r'[.]\d+|\d+[.]\d*'</span><span class="s4">,</span>
                         <span class="s1">exponent=</span><span class="s3">r'[edED][+-]?\d+'</span><span class="s4">,</span>
                         <span class="s1">kind=</span><span class="s3">r'_(\d+|\w[\w\d_]*)'</span><span class="s1">)</span><span class="s4">, </span><span class="s1">r)</span>
        <span class="s4">if </span><span class="s1">m:</span>
            <span class="s1">value</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">kind = m.groups()</span>
            <span class="s4">if </span><span class="s1">kind </span><span class="s4">and </span><span class="s1">kind.isdigit():</span>
                <span class="s1">kind = int(kind)</span>
            <span class="s1">value = value.lower()</span>
            <span class="s4">if </span><span class="s3">'d' </span><span class="s4">in </span><span class="s1">value:</span>
                <span class="s4">return </span><span class="s1">as_real(float(value.replace(</span><span class="s3">'d'</span><span class="s4">, </span><span class="s3">'e'</span><span class="s1">))</span><span class="s4">, </span><span class="s1">kind </span><span class="s4">or </span><span class="s5">8</span><span class="s1">)</span>
            <span class="s4">return </span><span class="s1">as_real(float(value)</span><span class="s4">, </span><span class="s1">kind </span><span class="s4">or </span><span class="s5">4</span><span class="s1">)</span>

        <span class="s2"># string-literal-constant with kind parameter specification</span>
        <span class="s4">if </span><span class="s1">r </span><span class="s4">in </span><span class="s1">self.quotes_map:</span>
            <span class="s1">kind = r[:r.find(</span><span class="s3">'@'</span><span class="s1">)]</span>
            <span class="s4">return </span><span class="s1">as_string(self.quotes_map[r]</span><span class="s4">, </span><span class="s1">kind </span><span class="s4">or </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s2"># array constructor or literal complex constant or</span>
        <span class="s2"># parenthesized expression</span>
        <span class="s4">if </span><span class="s1">r </span><span class="s4">in </span><span class="s1">raw_symbols_map:</span>
            <span class="s1">paren = _get_parenthesis_kind(r)</span>
            <span class="s1">items = self.process(restore(raw_symbols_map[r])</span><span class="s4">,</span>
                                 <span class="s3">'expr' </span><span class="s4">if </span><span class="s1">paren == </span><span class="s3">'ROUND' </span><span class="s4">else </span><span class="s3">'args'</span><span class="s1">)</span>
            <span class="s4">if </span><span class="s1">paren == </span><span class="s3">'ROUND'</span><span class="s1">:</span>
                <span class="s4">if </span><span class="s1">isinstance(items</span><span class="s4">, </span><span class="s1">Expr):</span>
                    <span class="s4">return </span><span class="s1">items</span>
            <span class="s4">if </span><span class="s1">paren </span><span class="s4">in </span><span class="s1">[</span><span class="s3">'ROUNDDIV'</span><span class="s4">, </span><span class="s3">'SQUARE'</span><span class="s1">]:</span>
                <span class="s2"># Expression is a array constructor</span>
                <span class="s4">if </span><span class="s1">isinstance(items</span><span class="s4">, </span><span class="s1">Expr):</span>
                    <span class="s1">items = (items</span><span class="s4">,</span><span class="s1">)</span>
                <span class="s4">return </span><span class="s1">as_array(items)</span>

        <span class="s2"># function call/indexing</span>
        <span class="s1">m = re.match(</span><span class="s3">r'\A(.+)\s*(@__f2py_PARENTHESIS_(ROUND|SQUARE)_\d+@)\Z'</span><span class="s4">,</span>
                     <span class="s1">r)</span>
        <span class="s4">if </span><span class="s1">m:</span>
            <span class="s1">target</span><span class="s4">, </span><span class="s1">args</span><span class="s4">, </span><span class="s1">paren = m.groups()</span>
            <span class="s1">target = self.process(restore(target))</span>
            <span class="s1">args = self.process(restore(args)[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s3">'args'</span><span class="s1">)</span>
            <span class="s4">if not </span><span class="s1">isinstance(args</span><span class="s4">, </span><span class="s1">tuple):</span>
                <span class="s1">args = args</span><span class="s4">,</span>
            <span class="s4">if </span><span class="s1">paren == </span><span class="s3">'ROUND'</span><span class="s1">:</span>
                <span class="s1">kwargs = dict((a.left</span><span class="s4">, </span><span class="s1">a.right) </span><span class="s4">for </span><span class="s1">a </span><span class="s4">in </span><span class="s1">args</span>
                              <span class="s4">if </span><span class="s1">isinstance(a</span><span class="s4">, </span><span class="s1">_Pair))</span>
                <span class="s1">args = tuple(a </span><span class="s4">for </span><span class="s1">a </span><span class="s4">in </span><span class="s1">args </span><span class="s4">if not </span><span class="s1">isinstance(a</span><span class="s4">, </span><span class="s1">_Pair))</span>
                <span class="s2"># Warning: this could also be Fortran indexing operation..</span>
                <span class="s4">return </span><span class="s1">as_apply(target</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kwargs)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s2"># Expression is a C/Python indexing operation</span>
                <span class="s2"># (e.g. used in .pyf files)</span>
                <span class="s4">assert </span><span class="s1">paren == </span><span class="s3">'SQUARE'</span>
                <span class="s4">return </span><span class="s1">target[args]</span>

        <span class="s2"># Fortran standard conforming identifier</span>
        <span class="s1">m = re.match(</span><span class="s3">r'\A\w[\w\d_]*\Z'</span><span class="s4">, </span><span class="s1">r)</span>
        <span class="s4">if </span><span class="s1">m:</span>
            <span class="s4">return </span><span class="s1">as_symbol(r)</span>

        <span class="s2"># fall-back to symbol</span>
        <span class="s1">r = self.finalize_string(restore(r))</span>
        <span class="s1">ewarn(</span>
            <span class="s3">f'fromstring: treating </span><span class="s4">{</span><span class="s1">r</span><span class="s4">!r} </span><span class="s3">as symbol (original=</span><span class="s4">{</span><span class="s1">self.original</span><span class="s4">}</span><span class="s3">)'</span><span class="s1">)</span>
        <span class="s4">return </span><span class="s1">as_symbol(r)</span>
</pre>
</body>
</html>