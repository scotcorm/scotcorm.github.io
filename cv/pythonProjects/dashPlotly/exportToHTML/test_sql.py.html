<html>
<head>
<title>test_sql.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_sql.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;SQL io tests 
 
The SQL tests are broken down in different classes: 
 
- `PandasSQLTest`: base class with common methods for all test classes 
- Tests for the public API (only tests with sqlite3) 
    - `_TestSQLApi` base class 
    - `TestSQLApi`: test the public API with sqlalchemy engine 
    - `TestSQLiteFallbackApi`: test the public API with a sqlite DBAPI 
      connection 
- Tests for the different SQL flavors (flavor specific type conversions) 
    - Tests for the sqlalchemy mode: `_TestSQLAlchemy` is the base class with 
      common methods, `_TestSQLAlchemyConn` tests the API with a SQLAlchemy 
      Connection object. The different tested flavors (sqlite3, MySQL, 
      PostgreSQL) derive from the base class 
    - Tests for the fallback mode (`TestSQLiteFallback`) 
 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">csv</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">date</span><span class="s2">,</span>
    <span class="s1">datetime</span><span class="s2">,</span>
    <span class="s1">time</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">StringIO</span>
<span class="s2">from </span><span class="s1">pathlib </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">import </span><span class="s1">sqlite3</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">import </span><span class="s1">pandas.util._test_decorators </span><span class="s2">as </span><span class="s1">td</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">is_datetime64_dtype</span><span class="s2">,</span>
    <span class="s1">is_datetime64tz_dtype</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s2">,</span>
    <span class="s1">Index</span><span class="s2">,</span>
    <span class="s1">MultiIndex</span><span class="s2">,</span>
    <span class="s1">Series</span><span class="s2">,</span>
    <span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">concat</span><span class="s2">,</span>
    <span class="s1">date_range</span><span class="s2">,</span>
    <span class="s1">isna</span><span class="s2">,</span>
    <span class="s1">to_datetime</span><span class="s2">,</span>
    <span class="s1">to_timedelta</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas._testing </span><span class="s2">as </span><span class="s1">tm</span>

<span class="s2">import </span><span class="s1">pandas.io.sql </span><span class="s2">as </span><span class="s1">sql</span>
<span class="s2">from </span><span class="s1">pandas.io.sql </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">SQLAlchemyEngine</span><span class="s2">,</span>
    <span class="s1">SQLDatabase</span><span class="s2">,</span>
    <span class="s1">SQLiteDatabase</span><span class="s2">,</span>
    <span class="s1">_gt14</span><span class="s2">,</span>
    <span class="s1">get_engine</span><span class="s2">,</span>
    <span class="s1">pandasSQL_builder</span><span class="s2">,</span>
    <span class="s1">read_sql_query</span><span class="s2">,</span>
    <span class="s1">read_sql_table</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">sqlalchemy</span>

    <span class="s1">SQLALCHEMY_INSTALLED = </span><span class="s2">True</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s1">SQLALCHEMY_INSTALLED = </span><span class="s2">False</span>

<span class="s1">SQL_STRINGS = {</span>
    <span class="s3">&quot;read_parameters&quot;</span><span class="s1">: {</span>
        <span class="s3">&quot;sqlite&quot;</span><span class="s1">: </span><span class="s3">&quot;SELECT * FROM iris WHERE Name=? AND SepalLength=?&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;mysql&quot;</span><span class="s1">: </span><span class="s3">&quot;SELECT * FROM iris WHERE `Name`=%s AND `SepalLength`=%s&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;postgresql&quot;</span><span class="s1">: </span><span class="s3">'SELECT * FROM iris WHERE &quot;Name&quot;=%s AND &quot;SepalLength&quot;=%s'</span><span class="s2">,</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s3">&quot;read_named_parameters&quot;</span><span class="s1">: {</span>
        <span class="s3">&quot;sqlite&quot;</span><span class="s1">: </span><span class="s3">&quot;&quot;&quot; 
                SELECT * FROM iris WHERE Name=:name AND SepalLength=:length 
                &quot;&quot;&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;mysql&quot;</span><span class="s1">: </span><span class="s3">&quot;&quot;&quot; 
                SELECT * FROM iris WHERE 
                `Name`=%(name)s AND `SepalLength`=%(length)s 
                &quot;&quot;&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;postgresql&quot;</span><span class="s1">: </span><span class="s3">&quot;&quot;&quot; 
                SELECT * FROM iris WHERE 
                &quot;Name&quot;=%(name)s AND &quot;SepalLength&quot;=%(length)s 
                &quot;&quot;&quot;</span><span class="s2">,</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s3">&quot;read_no_parameters_with_percent&quot;</span><span class="s1">: {</span>
        <span class="s3">&quot;sqlite&quot;</span><span class="s1">: </span><span class="s3">&quot;SELECT * FROM iris WHERE Name LIKE '%'&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;mysql&quot;</span><span class="s1">: </span><span class="s3">&quot;SELECT * FROM iris WHERE `Name` LIKE '%'&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;postgresql&quot;</span><span class="s1">: </span><span class="s3">&quot;SELECT * FROM iris WHERE </span><span class="s2">\&quot;</span><span class="s3">Name</span><span class="s2">\&quot; </span><span class="s3">LIKE '%'&quot;</span><span class="s2">,</span>
    <span class="s1">}</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s2">def </span><span class="s1">iris_table_metadata(dialect: str):</span>
    <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">(</span>
        <span class="s1">REAL</span><span class="s2">,</span>
        <span class="s1">Column</span><span class="s2">,</span>
        <span class="s1">Float</span><span class="s2">,</span>
        <span class="s1">MetaData</span><span class="s2">,</span>
        <span class="s1">String</span><span class="s2">,</span>
        <span class="s1">Table</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">dtype = Float </span><span class="s2">if </span><span class="s1">dialect == </span><span class="s3">&quot;postgresql&quot; </span><span class="s2">else </span><span class="s1">REAL</span>
    <span class="s1">metadata = MetaData()</span>
    <span class="s1">iris = Table(</span>
        <span class="s3">&quot;iris&quot;</span><span class="s2">,</span>
        <span class="s1">metadata</span><span class="s2">,</span>
        <span class="s1">Column(</span><span class="s3">&quot;SepalLength&quot;</span><span class="s2">, </span><span class="s1">dtype)</span><span class="s2">,</span>
        <span class="s1">Column(</span><span class="s3">&quot;SepalWidth&quot;</span><span class="s2">, </span><span class="s1">dtype)</span><span class="s2">,</span>
        <span class="s1">Column(</span><span class="s3">&quot;PetalLength&quot;</span><span class="s2">, </span><span class="s1">dtype)</span><span class="s2">,</span>
        <span class="s1">Column(</span><span class="s3">&quot;PetalWidth&quot;</span><span class="s2">, </span><span class="s1">dtype)</span><span class="s2">,</span>
        <span class="s1">Column(</span><span class="s3">&quot;Name&quot;</span><span class="s2">, </span><span class="s1">String(</span><span class="s4">200</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">iris</span>


<span class="s2">def </span><span class="s1">create_and_load_iris_sqlite3(conn: sqlite3.Connection</span><span class="s2">, </span><span class="s1">iris_file: Path):</span>
    <span class="s1">cur = conn.cursor()</span>
    <span class="s1">stmt = </span><span class="s3">&quot;&quot;&quot;CREATE TABLE iris ( 
            &quot;SepalLength&quot; REAL, 
            &quot;SepalWidth&quot; REAL, 
            &quot;PetalLength&quot; REAL, 
            &quot;PetalWidth&quot; REAL, 
            &quot;Name&quot; TEXT 
        )&quot;&quot;&quot;</span>
    <span class="s1">cur.execute(stmt)</span>
    <span class="s2">with </span><span class="s1">iris_file.open(newline=</span><span class="s2">None</span><span class="s1">) </span><span class="s2">as </span><span class="s1">csvfile:</span>
        <span class="s1">reader = csv.reader(csvfile)</span>
        <span class="s1">next(reader)</span>
        <span class="s1">stmt = </span><span class="s3">&quot;INSERT INTO iris VALUES(?, ?, ?, ?, ?)&quot;</span>
        <span class="s1">cur.executemany(stmt</span><span class="s2">, </span><span class="s1">reader)</span>


<span class="s2">def </span><span class="s1">create_and_load_iris(conn</span><span class="s2">, </span><span class="s1">iris_file: Path</span><span class="s2">, </span><span class="s1">dialect: str):</span>
    <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">insert</span>
    <span class="s2">from </span><span class="s1">sqlalchemy.engine </span><span class="s2">import </span><span class="s1">Engine</span>

    <span class="s1">iris = iris_table_metadata(dialect)</span>
    <span class="s1">iris.drop(conn</span><span class="s2">, </span><span class="s1">checkfirst=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">iris.create(bind=conn)</span>

    <span class="s2">with </span><span class="s1">iris_file.open(newline=</span><span class="s2">None</span><span class="s1">) </span><span class="s2">as </span><span class="s1">csvfile:</span>
        <span class="s1">reader = csv.reader(csvfile)</span>
        <span class="s1">header = next(reader)</span>
        <span class="s1">params = [{key: value </span><span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">zip(header</span><span class="s2">, </span><span class="s1">row)} </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">reader]</span>
        <span class="s1">stmt = insert(iris).values(params)</span>
        <span class="s2">if </span><span class="s1">isinstance(conn</span><span class="s2">, </span><span class="s1">Engine):</span>
            <span class="s2">with </span><span class="s1">conn.connect() </span><span class="s2">as </span><span class="s1">conn:</span>
                <span class="s2">with </span><span class="s1">conn.begin():</span>
                    <span class="s1">conn.execute(stmt)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">conn.execute(stmt)</span>


<span class="s2">def </span><span class="s1">create_and_load_iris_view(conn):</span>
    <span class="s1">stmt = </span><span class="s3">&quot;CREATE VIEW iris_view AS SELECT * FROM iris&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(conn</span><span class="s2">, </span><span class="s1">sqlite3.Connection):</span>
        <span class="s1">cur = conn.cursor()</span>
        <span class="s1">cur.execute(stmt)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">text</span>
        <span class="s2">from </span><span class="s1">sqlalchemy.engine </span><span class="s2">import </span><span class="s1">Engine</span>

        <span class="s1">stmt = text(stmt)</span>
        <span class="s2">if </span><span class="s1">isinstance(conn</span><span class="s2">, </span><span class="s1">Engine):</span>
            <span class="s2">with </span><span class="s1">conn.connect() </span><span class="s2">as </span><span class="s1">conn:</span>
                <span class="s2">with </span><span class="s1">conn.begin():</span>
                    <span class="s1">conn.execute(stmt)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">conn.execute(stmt)</span>


<span class="s2">def </span><span class="s1">types_table_metadata(dialect: str):</span>
    <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">(</span>
        <span class="s1">TEXT</span><span class="s2">,</span>
        <span class="s1">Boolean</span><span class="s2">,</span>
        <span class="s1">Column</span><span class="s2">,</span>
        <span class="s1">DateTime</span><span class="s2">,</span>
        <span class="s1">Float</span><span class="s2">,</span>
        <span class="s1">Integer</span><span class="s2">,</span>
        <span class="s1">MetaData</span><span class="s2">,</span>
        <span class="s1">Table</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">date_type = TEXT </span><span class="s2">if </span><span class="s1">dialect == </span><span class="s3">&quot;sqlite&quot; </span><span class="s2">else </span><span class="s1">DateTime</span>
    <span class="s1">bool_type = Integer </span><span class="s2">if </span><span class="s1">dialect == </span><span class="s3">&quot;sqlite&quot; </span><span class="s2">else </span><span class="s1">Boolean</span>
    <span class="s1">metadata = MetaData()</span>
    <span class="s1">types = Table(</span>
        <span class="s3">&quot;types&quot;</span><span class="s2">,</span>
        <span class="s1">metadata</span><span class="s2">,</span>
        <span class="s1">Column(</span><span class="s3">&quot;TextCol&quot;</span><span class="s2">, </span><span class="s1">TEXT)</span><span class="s2">,</span>
        <span class="s1">Column(</span><span class="s3">&quot;DateCol&quot;</span><span class="s2">, </span><span class="s1">date_type)</span><span class="s2">,</span>
        <span class="s1">Column(</span><span class="s3">&quot;IntDateCol&quot;</span><span class="s2">, </span><span class="s1">Integer)</span><span class="s2">,</span>
        <span class="s1">Column(</span><span class="s3">&quot;IntDateOnlyCol&quot;</span><span class="s2">, </span><span class="s1">Integer)</span><span class="s2">,</span>
        <span class="s1">Column(</span><span class="s3">&quot;FloatCol&quot;</span><span class="s2">, </span><span class="s1">Float)</span><span class="s2">,</span>
        <span class="s1">Column(</span><span class="s3">&quot;IntCol&quot;</span><span class="s2">, </span><span class="s1">Integer)</span><span class="s2">,</span>
        <span class="s1">Column(</span><span class="s3">&quot;BoolCol&quot;</span><span class="s2">, </span><span class="s1">bool_type)</span><span class="s2">,</span>
        <span class="s1">Column(</span><span class="s3">&quot;IntColWithNull&quot;</span><span class="s2">, </span><span class="s1">Integer)</span><span class="s2">,</span>
        <span class="s1">Column(</span><span class="s3">&quot;BoolColWithNull&quot;</span><span class="s2">, </span><span class="s1">bool_type)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">if </span><span class="s1">dialect == </span><span class="s3">&quot;postgresql&quot;</span><span class="s1">:</span>
        <span class="s1">types.append_column(Column(</span><span class="s3">&quot;DateColWithTz&quot;</span><span class="s2">, </span><span class="s1">DateTime(timezone=</span><span class="s2">True</span><span class="s1">)))</span>
    <span class="s2">return </span><span class="s1">types</span>


<span class="s2">def </span><span class="s1">create_and_load_types_sqlite3(conn: sqlite3.Connection</span><span class="s2">, </span><span class="s1">types_data: list[dict]):</span>
    <span class="s1">cur = conn.cursor()</span>
    <span class="s1">stmt = </span><span class="s3">&quot;&quot;&quot;CREATE TABLE types ( 
                    &quot;TextCol&quot; TEXT, 
                    &quot;DateCol&quot; TEXT, 
                    &quot;IntDateCol&quot; INTEGER, 
                    &quot;IntDateOnlyCol&quot; INTEGER, 
                    &quot;FloatCol&quot; REAL, 
                    &quot;IntCol&quot; INTEGER, 
                    &quot;BoolCol&quot; INTEGER, 
                    &quot;IntColWithNull&quot; INTEGER, 
                    &quot;BoolColWithNull&quot; INTEGER 
                )&quot;&quot;&quot;</span>
    <span class="s1">cur.execute(stmt)</span>

    <span class="s1">stmt = </span><span class="s3">&quot;&quot;&quot; 
            INSERT INTO types 
            VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?) 
            &quot;&quot;&quot;</span>
    <span class="s1">cur.executemany(stmt</span><span class="s2">, </span><span class="s1">types_data)</span>


<span class="s2">def </span><span class="s1">create_and_load_types(conn</span><span class="s2">, </span><span class="s1">types_data: list[dict]</span><span class="s2">, </span><span class="s1">dialect: str):</span>
    <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">insert</span>
    <span class="s2">from </span><span class="s1">sqlalchemy.engine </span><span class="s2">import </span><span class="s1">Engine</span>

    <span class="s1">types = types_table_metadata(dialect)</span>
    <span class="s1">types.drop(conn</span><span class="s2">, </span><span class="s1">checkfirst=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">types.create(bind=conn)</span>

    <span class="s1">stmt = insert(types).values(types_data)</span>
    <span class="s2">if </span><span class="s1">isinstance(conn</span><span class="s2">, </span><span class="s1">Engine):</span>
        <span class="s2">with </span><span class="s1">conn.connect() </span><span class="s2">as </span><span class="s1">conn:</span>
            <span class="s2">with </span><span class="s1">conn.begin():</span>
                <span class="s1">conn.execute(stmt)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">conn.execute(stmt)</span>


<span class="s2">def </span><span class="s1">check_iris_frame(frame: DataFrame):</span>
    <span class="s1">pytype = frame.dtypes[</span><span class="s4">0</span><span class="s1">].type</span>
    <span class="s1">row = frame.iloc[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">issubclass(pytype</span><span class="s2">, </span><span class="s1">np.floating)</span>
    <span class="s1">tm.equalContents(row.values</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5.1</span><span class="s2">, </span><span class="s4">3.5</span><span class="s2">, </span><span class="s4">1.4</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s3">&quot;Iris-setosa&quot;</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">count_rows(conn</span><span class="s2">, </span><span class="s1">table_name: str):</span>
    <span class="s1">stmt = </span><span class="s3">f&quot;SELECT count(*) AS count_1 FROM </span><span class="s2">{</span><span class="s1">table_name</span><span class="s2">}</span><span class="s3">&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(conn</span><span class="s2">, </span><span class="s1">sqlite3.Connection):</span>
        <span class="s1">cur = conn.cursor()</span>
        <span class="s1">result = cur.execute(stmt)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">text</span>
        <span class="s2">from </span><span class="s1">sqlalchemy.engine </span><span class="s2">import </span><span class="s1">Engine</span>

        <span class="s1">stmt = text(stmt)</span>
        <span class="s2">if </span><span class="s1">isinstance(conn</span><span class="s2">, </span><span class="s1">Engine):</span>
            <span class="s2">with </span><span class="s1">conn.connect() </span><span class="s2">as </span><span class="s1">conn:</span>
                <span class="s1">result = conn.execute(stmt)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">result = conn.execute(stmt)</span>
    <span class="s2">return </span><span class="s1">result.fetchone()[</span><span class="s4">0</span><span class="s1">]</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">iris_path(datapath):</span>
    <span class="s1">iris_path = datapath(</span><span class="s3">&quot;io&quot;</span><span class="s2">, </span><span class="s3">&quot;data&quot;</span><span class="s2">, </span><span class="s3">&quot;csv&quot;</span><span class="s2">, </span><span class="s3">&quot;iris.csv&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">Path(iris_path)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">types_data():</span>
    <span class="s2">return </span><span class="s1">[</span>
        <span class="s1">{</span>
            <span class="s3">&quot;TextCol&quot;</span><span class="s1">: </span><span class="s3">&quot;first&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;DateCol&quot;</span><span class="s1">: </span><span class="s3">&quot;2000-01-03 00:00:00&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;IntDateCol&quot;</span><span class="s1">: </span><span class="s4">535852800</span><span class="s2">,</span>
            <span class="s3">&quot;IntDateOnlyCol&quot;</span><span class="s1">: </span><span class="s4">20101010</span><span class="s2">,</span>
            <span class="s3">&quot;FloatCol&quot;</span><span class="s1">: </span><span class="s4">10.10</span><span class="s2">,</span>
            <span class="s3">&quot;IntCol&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s2">,</span>
            <span class="s3">&quot;BoolCol&quot;</span><span class="s1">: </span><span class="s2">False,</span>
            <span class="s3">&quot;IntColWithNull&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s2">,</span>
            <span class="s3">&quot;BoolColWithNull&quot;</span><span class="s1">: </span><span class="s2">False,</span>
            <span class="s3">&quot;DateColWithTz&quot;</span><span class="s1">: </span><span class="s3">&quot;2000-01-01 00:00:00-08:00&quot;</span><span class="s2">,</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">{</span>
            <span class="s3">&quot;TextCol&quot;</span><span class="s1">: </span><span class="s3">&quot;first&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;DateCol&quot;</span><span class="s1">: </span><span class="s3">&quot;2000-01-04 00:00:00&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;IntDateCol&quot;</span><span class="s1">: </span><span class="s4">1356998400</span><span class="s2">,</span>
            <span class="s3">&quot;IntDateOnlyCol&quot;</span><span class="s1">: </span><span class="s4">20101212</span><span class="s2">,</span>
            <span class="s3">&quot;FloatCol&quot;</span><span class="s1">: </span><span class="s4">10.10</span><span class="s2">,</span>
            <span class="s3">&quot;IntCol&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s2">,</span>
            <span class="s3">&quot;BoolCol&quot;</span><span class="s1">: </span><span class="s2">False,</span>
            <span class="s3">&quot;IntColWithNull&quot;</span><span class="s1">: </span><span class="s2">None,</span>
            <span class="s3">&quot;BoolColWithNull&quot;</span><span class="s1">: </span><span class="s2">None,</span>
            <span class="s3">&quot;DateColWithTz&quot;</span><span class="s1">: </span><span class="s3">&quot;2000-06-01 00:00:00-07:00&quot;</span><span class="s2">,</span>
        <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">]</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">types_data_frame(types_data):</span>
    <span class="s1">dtypes = {</span>
        <span class="s3">&quot;TextCol&quot;</span><span class="s1">: </span><span class="s3">&quot;str&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;DateCol&quot;</span><span class="s1">: </span><span class="s3">&quot;str&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;IntDateCol&quot;</span><span class="s1">: </span><span class="s3">&quot;int64&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;IntDateOnlyCol&quot;</span><span class="s1">: </span><span class="s3">&quot;int64&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;FloatCol&quot;</span><span class="s1">: </span><span class="s3">&quot;float&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;IntCol&quot;</span><span class="s1">: </span><span class="s3">&quot;int64&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;BoolCol&quot;</span><span class="s1">: </span><span class="s3">&quot;int64&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;IntColWithNull&quot;</span><span class="s1">: </span><span class="s3">&quot;float&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;BoolColWithNull&quot;</span><span class="s1">: </span><span class="s3">&quot;float&quot;</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">df = DataFrame(types_data)</span>
    <span class="s2">return </span><span class="s1">df[dtypes.keys()].astype(dtypes)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">test_frame1():</span>
    <span class="s1">columns = [</span><span class="s3">&quot;index&quot;</span><span class="s2">, </span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">]</span>
    <span class="s1">data = [</span>
        <span class="s1">(</span>
            <span class="s3">&quot;2000-01-03 00:00:00&quot;</span><span class="s2">,</span>
            <span class="s4">0.980268513777</span><span class="s2">,</span>
            <span class="s4">3.68573087906</span><span class="s2">,</span>
            <span class="s1">-</span><span class="s4">0.364216805298</span><span class="s2">,</span>
            <span class="s1">-</span><span class="s4">1.15973806169</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;2000-01-04 00:00:00&quot;</span><span class="s2">,</span>
            <span class="s4">1.04791624281</span><span class="s2">,</span>
            <span class="s1">-</span><span class="s4">0.0412318367011</span><span class="s2">,</span>
            <span class="s1">-</span><span class="s4">0.16181208307</span><span class="s2">,</span>
            <span class="s4">0.212549316967</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;2000-01-05 00:00:00&quot;</span><span class="s2">,</span>
            <span class="s4">0.498580885705</span><span class="s2">,</span>
            <span class="s4">0.731167677815</span><span class="s2">,</span>
            <span class="s1">-</span><span class="s4">0.537677223318</span><span class="s2">,</span>
            <span class="s4">1.34627041952</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;2000-01-06 00:00:00&quot;</span><span class="s2">,</span>
            <span class="s4">1.12020151869</span><span class="s2">,</span>
            <span class="s4">1.56762092543</span><span class="s2">,</span>
            <span class="s4">0.00364077397681</span><span class="s2">,</span>
            <span class="s4">0.67525259227</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span>
    <span class="s2">return </span><span class="s1">DataFrame(data</span><span class="s2">, </span><span class="s1">columns=columns)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">test_frame3():</span>
    <span class="s1">columns = [</span><span class="s3">&quot;index&quot;</span><span class="s2">, </span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">]</span>
    <span class="s1">data = [</span>
        <span class="s1">(</span><span class="s3">&quot;2000-01-03 00:00:00&quot;</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">** </span><span class="s4">31 </span><span class="s1">- </span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.987670</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;2000-01-04 00:00:00&quot;</span><span class="s2">, </span><span class="s1">-</span><span class="s4">29</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0412318367011</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;2000-01-05 00:00:00&quot;</span><span class="s2">, </span><span class="s4">20000</span><span class="s2">, </span><span class="s4">0.731167677815</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;2000-01-06 00:00:00&quot;</span><span class="s2">, </span><span class="s1">-</span><span class="s4">290867</span><span class="s2">, </span><span class="s4">1.56762092543</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span>
    <span class="s2">return </span><span class="s1">DataFrame(data</span><span class="s2">, </span><span class="s1">columns=columns)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">mysql_pymysql_engine(iris_path</span><span class="s2">, </span><span class="s1">types_data):</span>
    <span class="s1">sqlalchemy = pytest.importorskip(</span><span class="s3">&quot;sqlalchemy&quot;</span><span class="s1">)</span>
    <span class="s1">pymysql = pytest.importorskip(</span><span class="s3">&quot;pymysql&quot;</span><span class="s1">)</span>
    <span class="s1">engine = sqlalchemy.create_engine(</span>
        <span class="s3">&quot;mysql+pymysql://root@localhost:3306/pandas&quot;</span><span class="s2">,</span>
        <span class="s1">connect_args={</span><span class="s3">&quot;client_flag&quot;</span><span class="s1">: pymysql.constants.CLIENT.MULTI_STATEMENTS}</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">check_target = sqlalchemy.inspect(engine) </span><span class="s2">if </span><span class="s1">_gt14() </span><span class="s2">else </span><span class="s1">engine</span>
    <span class="s2">if not </span><span class="s1">check_target.has_table(</span><span class="s3">&quot;iris&quot;</span><span class="s1">):</span>
        <span class="s1">create_and_load_iris(engine</span><span class="s2">, </span><span class="s1">iris_path</span><span class="s2">, </span><span class="s3">&quot;mysql&quot;</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">check_target.has_table(</span><span class="s3">&quot;types&quot;</span><span class="s1">):</span>
        <span class="s2">for </span><span class="s1">entry </span><span class="s2">in </span><span class="s1">types_data:</span>
            <span class="s1">entry.pop(</span><span class="s3">&quot;DateColWithTz&quot;</span><span class="s1">)</span>
        <span class="s1">create_and_load_types(engine</span><span class="s2">, </span><span class="s1">types_data</span><span class="s2">, </span><span class="s3">&quot;mysql&quot;</span><span class="s1">)</span>
    <span class="s2">yield </span><span class="s1">engine</span>
    <span class="s2">with </span><span class="s1">engine.connect() </span><span class="s2">as </span><span class="s1">conn:</span>
        <span class="s2">with </span><span class="s1">conn.begin():</span>
            <span class="s1">stmt = sqlalchemy.text(</span><span class="s3">&quot;DROP TABLE IF EXISTS test_frame;&quot;</span><span class="s1">)</span>
            <span class="s1">conn.execute(stmt)</span>
    <span class="s1">engine.dispose()</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">mysql_pymysql_conn(mysql_pymysql_engine):</span>
    <span class="s2">yield </span><span class="s1">mysql_pymysql_engine.connect()</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">postgresql_psycopg2_engine(iris_path</span><span class="s2">, </span><span class="s1">types_data):</span>
    <span class="s1">sqlalchemy = pytest.importorskip(</span><span class="s3">&quot;sqlalchemy&quot;</span><span class="s1">)</span>
    <span class="s1">pytest.importorskip(</span><span class="s3">&quot;psycopg2&quot;</span><span class="s1">)</span>
    <span class="s1">engine = sqlalchemy.create_engine(</span>
        <span class="s3">&quot;postgresql+psycopg2://postgres:postgres@localhost:5432/pandas&quot;</span>
    <span class="s1">)</span>
    <span class="s1">check_target = sqlalchemy.inspect(engine) </span><span class="s2">if </span><span class="s1">_gt14() </span><span class="s2">else </span><span class="s1">engine</span>
    <span class="s2">if not </span><span class="s1">check_target.has_table(</span><span class="s3">&quot;iris&quot;</span><span class="s1">):</span>
        <span class="s1">create_and_load_iris(engine</span><span class="s2">, </span><span class="s1">iris_path</span><span class="s2">, </span><span class="s3">&quot;postgresql&quot;</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">check_target.has_table(</span><span class="s3">&quot;types&quot;</span><span class="s1">):</span>
        <span class="s1">create_and_load_types(engine</span><span class="s2">, </span><span class="s1">types_data</span><span class="s2">, </span><span class="s3">&quot;postgresql&quot;</span><span class="s1">)</span>
    <span class="s2">yield </span><span class="s1">engine</span>
    <span class="s2">with </span><span class="s1">engine.connect() </span><span class="s2">as </span><span class="s1">conn:</span>
        <span class="s2">with </span><span class="s1">conn.begin():</span>
            <span class="s1">stmt = sqlalchemy.text(</span><span class="s3">&quot;DROP TABLE IF EXISTS test_frame;&quot;</span><span class="s1">)</span>
            <span class="s1">conn.execute(stmt)</span>
    <span class="s1">engine.dispose()</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">postgresql_psycopg2_conn(postgresql_psycopg2_engine):</span>
    <span class="s2">yield </span><span class="s1">postgresql_psycopg2_engine.connect()</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">sqlite_engine():</span>
    <span class="s1">sqlalchemy = pytest.importorskip(</span><span class="s3">&quot;sqlalchemy&quot;</span><span class="s1">)</span>
    <span class="s1">engine = sqlalchemy.create_engine(</span><span class="s3">&quot;sqlite://&quot;</span><span class="s1">)</span>
    <span class="s2">yield </span><span class="s1">engine</span>
    <span class="s1">engine.dispose()</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">sqlite_conn(sqlite_engine):</span>
    <span class="s2">yield </span><span class="s1">sqlite_engine.connect()</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">sqlite_iris_engine(sqlite_engine</span><span class="s2">, </span><span class="s1">iris_path):</span>
    <span class="s1">create_and_load_iris(sqlite_engine</span><span class="s2">, </span><span class="s1">iris_path</span><span class="s2">, </span><span class="s3">&quot;sqlite&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">sqlite_engine</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">sqlite_iris_conn(sqlite_iris_engine):</span>
    <span class="s2">yield </span><span class="s1">sqlite_iris_engine.connect()</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">sqlite_buildin():</span>
    <span class="s1">conn = sqlite3.connect(</span><span class="s3">&quot;:memory:&quot;</span><span class="s1">)</span>
    <span class="s2">yield </span><span class="s1">conn</span>
    <span class="s1">conn.close()</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">sqlite_buildin_iris(sqlite_buildin</span><span class="s2">, </span><span class="s1">iris_path):</span>
    <span class="s1">create_and_load_iris_sqlite3(sqlite_buildin</span><span class="s2">, </span><span class="s1">iris_path)</span>
    <span class="s2">return </span><span class="s1">sqlite_buildin</span>


<span class="s1">mysql_connectable = [</span>
    <span class="s3">&quot;mysql_pymysql_engine&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;mysql_pymysql_conn&quot;</span><span class="s2">,</span>
<span class="s1">]</span>


<span class="s1">postgresql_connectable = [</span>
    <span class="s3">&quot;postgresql_psycopg2_engine&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;postgresql_psycopg2_conn&quot;</span><span class="s2">,</span>
<span class="s1">]</span>

<span class="s1">sqlite_connectable = [</span>
    <span class="s3">&quot;sqlite_engine&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;sqlite_conn&quot;</span><span class="s2">,</span>
<span class="s1">]</span>

<span class="s1">sqlite_iris_connectable = [</span>
    <span class="s3">&quot;sqlite_iris_engine&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;sqlite_iris_conn&quot;</span><span class="s2">,</span>
<span class="s1">]</span>

<span class="s1">sqlalchemy_connectable = mysql_connectable + postgresql_connectable + sqlite_connectable</span>

<span class="s1">sqlalchemy_connectable_iris = (</span>
    <span class="s1">mysql_connectable + postgresql_connectable + sqlite_iris_connectable</span>
<span class="s1">)</span>

<span class="s1">all_connectable = sqlalchemy_connectable + [</span><span class="s3">&quot;sqlite_buildin&quot;</span><span class="s1">]</span>

<span class="s1">all_connectable_iris = sqlalchemy_connectable_iris + [</span><span class="s3">&quot;sqlite_buildin_iris&quot;</span><span class="s1">]</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;conn&quot;</span><span class="s2">, </span><span class="s1">all_connectable)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;method&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;multi&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_to_sql(conn</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">test_frame1</span><span class="s2">, </span><span class="s1">request):</span>
    <span class="s1">conn = request.getfixturevalue(conn)</span>
    <span class="s1">pandasSQL = pandasSQL_builder(conn)</span>
    <span class="s1">pandasSQL.to_sql(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test_frame&quot;</span><span class="s2">, </span><span class="s1">method=method)</span>
    <span class="s2">assert </span><span class="s1">pandasSQL.has_table(</span><span class="s3">&quot;test_frame&quot;</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">count_rows(conn</span><span class="s2">, </span><span class="s3">&quot;test_frame&quot;</span><span class="s1">) == len(test_frame1)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;conn&quot;</span><span class="s2">, </span><span class="s1">all_connectable)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;mode, num_row_coef&quot;</span><span class="s2">, </span><span class="s1">[(</span><span class="s3">&quot;replace&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;append&quot;</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_to_sql_exist(conn</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">num_row_coef</span><span class="s2">, </span><span class="s1">test_frame1</span><span class="s2">, </span><span class="s1">request):</span>
    <span class="s1">conn = request.getfixturevalue(conn)</span>
    <span class="s1">pandasSQL = pandasSQL_builder(conn)</span>
    <span class="s1">pandasSQL.to_sql(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test_frame&quot;</span><span class="s2">, </span><span class="s1">if_exists=</span><span class="s3">&quot;fail&quot;</span><span class="s1">)</span>
    <span class="s1">pandasSQL.to_sql(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test_frame&quot;</span><span class="s2">, </span><span class="s1">if_exists=mode)</span>
    <span class="s2">assert </span><span class="s1">pandasSQL.has_table(</span><span class="s3">&quot;test_frame&quot;</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">count_rows(conn</span><span class="s2">, </span><span class="s3">&quot;test_frame&quot;</span><span class="s1">) == num_row_coef * len(test_frame1)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;conn&quot;</span><span class="s2">, </span><span class="s1">all_connectable)</span>
<span class="s2">def </span><span class="s1">test_to_sql_exist_fail(conn</span><span class="s2">, </span><span class="s1">test_frame1</span><span class="s2">, </span><span class="s1">request):</span>
    <span class="s1">conn = request.getfixturevalue(conn)</span>
    <span class="s1">pandasSQL = pandasSQL_builder(conn)</span>
    <span class="s1">pandasSQL.to_sql(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test_frame&quot;</span><span class="s2">, </span><span class="s1">if_exists=</span><span class="s3">&quot;fail&quot;</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">pandasSQL.has_table(</span><span class="s3">&quot;test_frame&quot;</span><span class="s1">)</span>

    <span class="s1">msg = </span><span class="s3">&quot;Table 'test_frame' already exists&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">pandasSQL.to_sql(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test_frame&quot;</span><span class="s2">, </span><span class="s1">if_exists=</span><span class="s3">&quot;fail&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;conn&quot;</span><span class="s2">, </span><span class="s1">all_connectable_iris)</span>
<span class="s2">def </span><span class="s1">test_read_iris(conn</span><span class="s2">, </span><span class="s1">request):</span>
    <span class="s1">conn = request.getfixturevalue(conn)</span>
    <span class="s1">pandasSQL = pandasSQL_builder(conn)</span>
    <span class="s1">iris_frame = pandasSQL.read_query(</span><span class="s3">&quot;SELECT * FROM iris&quot;</span><span class="s1">)</span>
    <span class="s1">check_iris_frame(iris_frame)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;conn&quot;</span><span class="s2">, </span><span class="s1">sqlalchemy_connectable)</span>
<span class="s2">def </span><span class="s1">test_to_sql_callable(conn</span><span class="s2">, </span><span class="s1">test_frame1</span><span class="s2">, </span><span class="s1">request):</span>
    <span class="s1">conn = request.getfixturevalue(conn)</span>
    <span class="s1">pandasSQL = pandasSQL_builder(conn)</span>

    <span class="s1">check = []  </span><span class="s5"># used to double check function below is really being used</span>

    <span class="s2">def </span><span class="s1">sample(pd_table</span><span class="s2">, </span><span class="s1">conn</span><span class="s2">, </span><span class="s1">keys</span><span class="s2">, </span><span class="s1">data_iter):</span>
        <span class="s1">check.append(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">data = [dict(zip(keys</span><span class="s2">, </span><span class="s1">row)) </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">data_iter]</span>
        <span class="s1">conn.execute(pd_table.table.insert()</span><span class="s2">, </span><span class="s1">data)</span>

    <span class="s1">pandasSQL.to_sql(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test_frame&quot;</span><span class="s2">, </span><span class="s1">method=sample)</span>
    <span class="s2">assert </span><span class="s1">pandasSQL.has_table(</span><span class="s3">&quot;test_frame&quot;</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">check == [</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">count_rows(conn</span><span class="s2">, </span><span class="s3">&quot;test_frame&quot;</span><span class="s1">) == len(test_frame1)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;conn&quot;</span><span class="s2">, </span><span class="s1">mysql_connectable)</span>
<span class="s2">def </span><span class="s1">test_default_type_conversion(conn</span><span class="s2">, </span><span class="s1">request):</span>
    <span class="s1">conn = request.getfixturevalue(conn)</span>
    <span class="s1">df = sql.read_sql_table(</span><span class="s3">&quot;types&quot;</span><span class="s2">, </span><span class="s1">conn)</span>

    <span class="s2">assert </span><span class="s1">issubclass(df.FloatCol.dtype.type</span><span class="s2">, </span><span class="s1">np.floating)</span>
    <span class="s2">assert </span><span class="s1">issubclass(df.IntCol.dtype.type</span><span class="s2">, </span><span class="s1">np.integer)</span>

    <span class="s5"># MySQL has no real BOOL type (it's an alias for TINYINT)</span>
    <span class="s2">assert </span><span class="s1">issubclass(df.BoolCol.dtype.type</span><span class="s2">, </span><span class="s1">np.integer)</span>

    <span class="s5"># Int column with NA values stays as float</span>
    <span class="s2">assert </span><span class="s1">issubclass(df.IntColWithNull.dtype.type</span><span class="s2">, </span><span class="s1">np.floating)</span>

    <span class="s5"># Bool column with NA = int column with NA values =&gt; becomes float</span>
    <span class="s2">assert </span><span class="s1">issubclass(df.BoolColWithNull.dtype.type</span><span class="s2">, </span><span class="s1">np.floating)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;conn&quot;</span><span class="s2">, </span><span class="s1">mysql_connectable)</span>
<span class="s2">def </span><span class="s1">test_read_procedure(conn</span><span class="s2">, </span><span class="s1">request):</span>
    <span class="s1">conn = request.getfixturevalue(conn)</span>

    <span class="s5"># GH 7324</span>
    <span class="s5"># Although it is more an api test, it is added to the</span>
    <span class="s5"># mysql tests as sqlite does not have stored procedures</span>
    <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">text</span>
    <span class="s2">from </span><span class="s1">sqlalchemy.engine </span><span class="s2">import </span><span class="s1">Engine</span>

    <span class="s1">df = DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">: [</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.3</span><span class="s1">]})</span>
    <span class="s1">df.to_sql(</span><span class="s3">&quot;test_frame&quot;</span><span class="s2">, </span><span class="s1">conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">proc = </span><span class="s3">&quot;&quot;&quot;DROP PROCEDURE IF EXISTS get_testdb; 
 
    CREATE PROCEDURE get_testdb () 
 
    BEGIN 
        SELECT * FROM test_frame; 
    END&quot;&quot;&quot;</span>
    <span class="s1">proc = text(proc)</span>
    <span class="s2">if </span><span class="s1">isinstance(conn</span><span class="s2">, </span><span class="s1">Engine):</span>
        <span class="s2">with </span><span class="s1">conn.connect() </span><span class="s2">as </span><span class="s1">engine_conn:</span>
            <span class="s2">with </span><span class="s1">engine_conn.begin():</span>
                <span class="s1">engine_conn.execute(proc)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">conn.execute(proc)</span>

    <span class="s1">res1 = sql.read_sql_query(</span><span class="s3">&quot;CALL get_testdb();&quot;</span><span class="s2">, </span><span class="s1">conn)</span>
    <span class="s1">tm.assert_frame_equal(df</span><span class="s2">, </span><span class="s1">res1)</span>

    <span class="s5"># test delegation to read_sql_query</span>
    <span class="s1">res2 = sql.read_sql(</span><span class="s3">&quot;CALL get_testdb();&quot;</span><span class="s2">, </span><span class="s1">conn)</span>
    <span class="s1">tm.assert_frame_equal(df</span><span class="s2">, </span><span class="s1">res2)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;conn&quot;</span><span class="s2">, </span><span class="s1">postgresql_connectable)</span>
<span class="s2">def </span><span class="s1">test_copy_from_callable_insertion_method(conn</span><span class="s2">, </span><span class="s1">request):</span>
    <span class="s5"># GH 8953</span>
    <span class="s5"># Example in io.rst found under _io.sql.method</span>
    <span class="s5"># not available in sqlite, mysql</span>
    <span class="s2">def </span><span class="s1">psql_insert_copy(table</span><span class="s2">, </span><span class="s1">conn</span><span class="s2">, </span><span class="s1">keys</span><span class="s2">, </span><span class="s1">data_iter):</span>
        <span class="s5"># gets a DBAPI connection that can provide a cursor</span>
        <span class="s1">dbapi_conn = conn.connection</span>
        <span class="s2">with </span><span class="s1">dbapi_conn.cursor() </span><span class="s2">as </span><span class="s1">cur:</span>
            <span class="s1">s_buf = StringIO()</span>
            <span class="s1">writer = csv.writer(s_buf)</span>
            <span class="s1">writer.writerows(data_iter)</span>
            <span class="s1">s_buf.seek(</span><span class="s4">0</span><span class="s1">)</span>

            <span class="s1">columns = </span><span class="s3">&quot;, &quot;</span><span class="s1">.join([</span><span class="s3">f'&quot;</span><span class="s2">{</span><span class="s1">k</span><span class="s2">}</span><span class="s3">&quot;' </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">keys])</span>
            <span class="s2">if </span><span class="s1">table.schema:</span>
                <span class="s1">table_name = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">table.schema</span><span class="s2">}</span><span class="s3">.</span><span class="s2">{</span><span class="s1">table.name</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">table_name = table.name</span>

            <span class="s1">sql_query = </span><span class="s3">f&quot;COPY </span><span class="s2">{</span><span class="s1">table_name</span><span class="s2">} </span><span class="s3">(</span><span class="s2">{</span><span class="s1">columns</span><span class="s2">}</span><span class="s3">) FROM STDIN WITH CSV&quot;</span>
            <span class="s1">cur.copy_expert(sql=sql_query</span><span class="s2">, </span><span class="s1">file=s_buf)</span>

    <span class="s1">conn = request.getfixturevalue(conn)</span>
    <span class="s1">expected = DataFrame({</span><span class="s3">&quot;col1&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;col2&quot;</span><span class="s1">: [</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;col3&quot;</span><span class="s1">: [</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;n&quot;</span><span class="s1">]})</span>
    <span class="s1">expected.to_sql(</span><span class="s3">&quot;test_frame&quot;</span><span class="s2">, </span><span class="s1">conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False, </span><span class="s1">method=psql_insert_copy)</span>
    <span class="s1">result = sql.read_sql_table(</span><span class="s3">&quot;test_frame&quot;</span><span class="s2">, </span><span class="s1">conn)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">MixInBase:</span>
    <span class="s2">def </span><span class="s1">teardown_method(self</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s5"># if setup fails, there may not be a connection to close.</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;conn&quot;</span><span class="s1">):</span>
            <span class="s2">for </span><span class="s1">tbl </span><span class="s2">in </span><span class="s1">self._get_all_tables():</span>
                <span class="s1">self.drop_table(tbl)</span>
            <span class="s1">self._close_conn()</span>


<span class="s2">class </span><span class="s1">SQLiteMixIn(MixInBase):</span>
    <span class="s2">def </span><span class="s1">drop_table(self</span><span class="s2">, </span><span class="s1">table_name):</span>
        <span class="s1">self.conn.execute(</span>
            <span class="s3">f&quot;DROP TABLE IF EXISTS </span><span class="s2">{</span><span class="s1">sql._get_valid_sqlite_name(table_name)</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s1">)</span>
        <span class="s1">self.conn.commit()</span>

    <span class="s2">def </span><span class="s1">_get_all_tables(self):</span>
        <span class="s1">c = self.conn.execute(</span><span class="s3">&quot;SELECT name FROM sqlite_master WHERE type='table'&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">[table[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">table </span><span class="s2">in </span><span class="s1">c.fetchall()]</span>

    <span class="s2">def </span><span class="s1">_close_conn(self):</span>
        <span class="s1">self.conn.close()</span>


<span class="s2">class </span><span class="s1">SQLAlchemyMixIn(MixInBase):</span>
    <span class="s2">def </span><span class="s1">drop_table(self</span><span class="s2">, </span><span class="s1">table_name):</span>
        <span class="s1">sql.SQLDatabase(self.conn).drop_table(table_name)</span>

    <span class="s2">def </span><span class="s1">_get_all_tables(self):</span>
        <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">inspect</span>

        <span class="s2">return </span><span class="s1">inspect(self.conn).get_table_names()</span>

    <span class="s2">def </span><span class="s1">_close_conn(self):</span>
        <span class="s5"># https://docs.sqlalchemy.org/en/13/core/connections.html#engine-disposal</span>
        <span class="s1">self.conn.dispose()</span>


<span class="s2">class </span><span class="s1">PandasSQLTest:</span>
    <span class="s0">&quot;&quot;&quot; 
    Base class with common private methods for SQLAlchemy and fallback cases. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">@pytest.fixture</span>
    <span class="s2">def </span><span class="s1">load_iris_data(self</span><span class="s2">, </span><span class="s1">iris_path):</span>
        <span class="s2">if not </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;conn&quot;</span><span class="s1">):</span>
            <span class="s1">self.setup_connect()</span>
        <span class="s1">self.drop_table(</span><span class="s3">&quot;iris&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">isinstance(self.conn</span><span class="s2">, </span><span class="s1">sqlite3.Connection):</span>
            <span class="s1">create_and_load_iris_sqlite3(self.conn</span><span class="s2">, </span><span class="s1">iris_path)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">create_and_load_iris(self.conn</span><span class="s2">, </span><span class="s1">iris_path</span><span class="s2">, </span><span class="s1">self.flavor)</span>

    <span class="s1">@pytest.fixture</span>
    <span class="s2">def </span><span class="s1">load_types_data(self</span><span class="s2">, </span><span class="s1">types_data):</span>
        <span class="s2">if not </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;conn&quot;</span><span class="s1">):</span>
            <span class="s1">self.setup_connect()</span>
        <span class="s2">if </span><span class="s1">self.flavor != </span><span class="s3">&quot;postgresql&quot;</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">entry </span><span class="s2">in </span><span class="s1">types_data:</span>
                <span class="s1">entry.pop(</span><span class="s3">&quot;DateColWithTz&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">isinstance(self.conn</span><span class="s2">, </span><span class="s1">sqlite3.Connection):</span>
            <span class="s1">types_data = [tuple(entry.values()) </span><span class="s2">for </span><span class="s1">entry </span><span class="s2">in </span><span class="s1">types_data]</span>
            <span class="s1">create_and_load_types_sqlite3(self.conn</span><span class="s2">, </span><span class="s1">types_data)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">create_and_load_types(self.conn</span><span class="s2">, </span><span class="s1">types_data</span><span class="s2">, </span><span class="s1">self.flavor)</span>

    <span class="s2">def </span><span class="s1">_read_sql_iris_parameter(self):</span>
        <span class="s1">query = SQL_STRINGS[</span><span class="s3">&quot;read_parameters&quot;</span><span class="s1">][self.flavor]</span>
        <span class="s1">params = [</span><span class="s3">&quot;Iris-setosa&quot;</span><span class="s2">, </span><span class="s4">5.1</span><span class="s1">]</span>
        <span class="s1">iris_frame = self.pandasSQL.read_query(query</span><span class="s2">, </span><span class="s1">params=params)</span>
        <span class="s1">check_iris_frame(iris_frame)</span>

    <span class="s2">def </span><span class="s1">_read_sql_iris_named_parameter(self):</span>
        <span class="s1">query = SQL_STRINGS[</span><span class="s3">&quot;read_named_parameters&quot;</span><span class="s1">][self.flavor]</span>
        <span class="s1">params = {</span><span class="s3">&quot;name&quot;</span><span class="s1">: </span><span class="s3">&quot;Iris-setosa&quot;</span><span class="s2">, </span><span class="s3">&quot;length&quot;</span><span class="s1">: </span><span class="s4">5.1</span><span class="s1">}</span>
        <span class="s1">iris_frame = self.pandasSQL.read_query(query</span><span class="s2">, </span><span class="s1">params=params)</span>
        <span class="s1">check_iris_frame(iris_frame)</span>

    <span class="s2">def </span><span class="s1">_read_sql_iris_no_parameter_with_percent(self):</span>
        <span class="s1">query = SQL_STRINGS[</span><span class="s3">&quot;read_no_parameters_with_percent&quot;</span><span class="s1">][self.flavor]</span>
        <span class="s1">iris_frame = self.pandasSQL.read_query(query</span><span class="s2">, </span><span class="s1">params=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">check_iris_frame(iris_frame)</span>

    <span class="s2">def </span><span class="s1">_to_sql_empty(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s1">self.drop_table(</span><span class="s3">&quot;test_frame1&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">self.pandasSQL.to_sql(test_frame1.iloc[:</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;test_frame1&quot;</span><span class="s1">) == </span><span class="s4">0</span>

    <span class="s2">def </span><span class="s1">_to_sql_with_sql_engine(self</span><span class="s2">, </span><span class="s1">test_frame1</span><span class="s2">, </span><span class="s1">engine=</span><span class="s3">&quot;auto&quot;</span><span class="s2">, </span><span class="s1">**engine_kwargs):</span>
        <span class="s0">&quot;&quot;&quot;`to_sql` with the `engine` param&quot;&quot;&quot;</span>
        <span class="s5"># mostly copied from this class's `_to_sql()` method</span>
        <span class="s1">self.drop_table(</span><span class="s3">&quot;test_frame1&quot;</span><span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">self.pandasSQL.to_sql(</span>
                <span class="s1">test_frame1</span><span class="s2">, </span><span class="s3">&quot;test_frame1&quot;</span><span class="s2">, </span><span class="s1">engine=engine</span><span class="s2">, </span><span class="s1">**engine_kwargs</span>
            <span class="s1">)</span>
            <span class="s1">== </span><span class="s4">4</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">self.pandasSQL.has_table(</span><span class="s3">&quot;test_frame1&quot;</span><span class="s1">)</span>

        <span class="s1">num_entries = len(test_frame1)</span>
        <span class="s1">num_rows = count_rows(self.conn</span><span class="s2">, </span><span class="s3">&quot;test_frame1&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">num_rows == num_entries</span>

        <span class="s5"># Nuke table</span>
        <span class="s1">self.drop_table(</span><span class="s3">&quot;test_frame1&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_roundtrip(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s1">self.drop_table(</span><span class="s3">&quot;test_frame_roundtrip&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">self.pandasSQL.to_sql(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test_frame_roundtrip&quot;</span><span class="s1">) == </span><span class="s4">4</span>
        <span class="s1">result = self.pandasSQL.read_query(</span><span class="s3">&quot;SELECT * FROM test_frame_roundtrip&quot;</span><span class="s1">)</span>

        <span class="s1">result.set_index(</span><span class="s3">&quot;level_0&quot;</span><span class="s2">, </span><span class="s1">inplace=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s5"># result.index.astype(int)</span>

        <span class="s1">result.index.name = </span><span class="s2">None</span>

        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">test_frame1)</span>

    <span class="s2">def </span><span class="s1">_execute_sql(self):</span>
        <span class="s5"># drop_sql = &quot;DROP TABLE IF EXISTS test&quot;  # should already be done</span>
        <span class="s1">iris_results = self.pandasSQL.execute(</span><span class="s3">&quot;SELECT * FROM iris&quot;</span><span class="s1">)</span>
        <span class="s1">row = iris_results.fetchone()</span>
        <span class="s1">tm.equalContents(row</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5.1</span><span class="s2">, </span><span class="s4">3.5</span><span class="s2">, </span><span class="s4">1.4</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s3">&quot;Iris-setosa&quot;</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">_to_sql_save_index(self):</span>
        <span class="s1">df = DataFrame.from_records(</span>
            <span class="s1">[(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.1</span><span class="s2">, </span><span class="s3">&quot;line1&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s3">&quot;line2&quot;</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=[</span><span class="s3">&quot;A&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">self.pandasSQL.to_sql(df</span><span class="s2">, </span><span class="s3">&quot;test_to_sql_saves_index&quot;</span><span class="s1">) == </span><span class="s4">2</span>
        <span class="s1">ix_cols = self._get_index_columns(</span><span class="s3">&quot;test_to_sql_saves_index&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">ix_cols == [[</span><span class="s3">&quot;A&quot;</span><span class="s1">]]</span>

    <span class="s2">def </span><span class="s1">_transaction_test(self):</span>
        <span class="s2">with </span><span class="s1">self.pandasSQL.run_transaction() </span><span class="s2">as </span><span class="s1">trans:</span>
            <span class="s1">stmt = </span><span class="s3">&quot;CREATE TABLE test_trans (A INT, B TEXT)&quot;</span>
            <span class="s2">if </span><span class="s1">isinstance(self.pandasSQL</span><span class="s2">, </span><span class="s1">SQLiteDatabase):</span>
                <span class="s1">trans.execute(stmt)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">text</span>

                <span class="s1">stmt = text(stmt)</span>
                <span class="s1">trans.execute(stmt)</span>

        <span class="s2">class </span><span class="s1">DummyException(Exception):</span>
            <span class="s2">pass</span>

        <span class="s5"># Make sure when transaction is rolled back, no rows get inserted</span>
        <span class="s1">ins_sql = </span><span class="s3">&quot;INSERT INTO test_trans (A,B) VALUES (1, 'blah')&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(self.pandasSQL</span><span class="s2">, </span><span class="s1">SQLDatabase):</span>
            <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">text</span>

            <span class="s1">ins_sql = text(ins_sql)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">with </span><span class="s1">self.pandasSQL.run_transaction() </span><span class="s2">as </span><span class="s1">trans:</span>
                <span class="s1">trans.execute(ins_sql)</span>
                <span class="s2">raise </span><span class="s1">DummyException(</span><span class="s3">&quot;error&quot;</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">DummyException:</span>
            <span class="s5"># ignore raised exception</span>
            <span class="s2">pass</span>
        <span class="s1">res = self.pandasSQL.read_query(</span><span class="s3">&quot;SELECT * FROM test_trans&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">len(res) == </span><span class="s4">0</span>

        <span class="s5"># Make sure when transaction is committed, rows do get inserted</span>
        <span class="s2">with </span><span class="s1">self.pandasSQL.run_transaction() </span><span class="s2">as </span><span class="s1">trans:</span>
            <span class="s1">trans.execute(ins_sql)</span>
        <span class="s1">res2 = self.pandasSQL.read_query(</span><span class="s3">&quot;SELECT * FROM test_trans&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">len(res2) == </span><span class="s4">1</span>


<span class="s5"># -----------------------------------------------------------------------------</span>
<span class="s5"># -- Testing the public API</span>


<span class="s2">class </span><span class="s1">_TestSQLApi(PandasSQLTest):</span>
    <span class="s0">&quot;&quot;&quot; 
    Base class to test the public API. 
 
    From this two classes are derived to run these tests for both the 
    sqlalchemy mode (`TestSQLApi`) and the fallback mode 
    (`TestSQLiteFallbackApi`).  These tests are run with sqlite3. Specific 
    tests for the different sql flavours are included in `_TestSQLAlchemy`. 
 
    Notes: 
    flavor can always be passed even in SQLAlchemy mode, 
    should be correctly ignored. 
 
    we don't use drop_table because that isn't part of the public api 
 
    &quot;&quot;&quot;</span>

    <span class="s1">flavor = </span><span class="s3">&quot;sqlite&quot;</span>
    <span class="s1">mode: str</span>

    <span class="s2">def </span><span class="s1">setup_connect(self):</span>
        <span class="s1">self.conn = self.connect()</span>

    <span class="s1">@pytest.fixture(autouse=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">setup_method(self</span><span class="s2">, </span><span class="s1">load_iris_data</span><span class="s2">, </span><span class="s1">load_types_data):</span>
        <span class="s1">self.load_test_data_and_sql()</span>

    <span class="s2">def </span><span class="s1">load_test_data_and_sql(self):</span>
        <span class="s1">create_and_load_iris_view(self.conn)</span>

    <span class="s2">def </span><span class="s1">test_read_sql_view(self):</span>
        <span class="s1">iris_frame = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM iris_view&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">check_iris_frame(iris_frame)</span>

    <span class="s2">def </span><span class="s1">test_read_sql_with_chunksize_no_result(self):</span>
        <span class="s1">query = </span><span class="s3">&quot;SELECT * FROM iris_view WHERE SepalLength &lt; 0.0&quot;</span>
        <span class="s1">with_batch = sql.read_sql_query(query</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">chunksize=</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">without_batch = sql.read_sql_query(query</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">tm.assert_frame_equal(concat(with_batch)</span><span class="s2">, </span><span class="s1">without_batch)</span>

    <span class="s2">def </span><span class="s1">test_to_sql(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s1">sql.to_sql(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test_frame1&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s2">assert </span><span class="s1">sql.has_table(</span><span class="s3">&quot;test_frame1&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

    <span class="s2">def </span><span class="s1">test_to_sql_fail(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s1">sql.to_sql(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test_frame2&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">if_exists=</span><span class="s3">&quot;fail&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">sql.has_table(</span><span class="s3">&quot;test_frame2&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s1">msg = </span><span class="s3">&quot;Table 'test_frame2' already exists&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">sql.to_sql(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test_frame2&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">if_exists=</span><span class="s3">&quot;fail&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_to_sql_replace(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s1">sql.to_sql(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test_frame3&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">if_exists=</span><span class="s3">&quot;fail&quot;</span><span class="s1">)</span>
        <span class="s5"># Add to table again</span>
        <span class="s1">sql.to_sql(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test_frame3&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">if_exists=</span><span class="s3">&quot;replace&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">sql.has_table(</span><span class="s3">&quot;test_frame3&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s1">num_entries = len(test_frame1)</span>
        <span class="s1">num_rows = count_rows(self.conn</span><span class="s2">, </span><span class="s3">&quot;test_frame3&quot;</span><span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">num_rows == num_entries</span>

    <span class="s2">def </span><span class="s1">test_to_sql_append(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s2">assert </span><span class="s1">sql.to_sql(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test_frame4&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">if_exists=</span><span class="s3">&quot;fail&quot;</span><span class="s1">) == </span><span class="s4">4</span>

        <span class="s5"># Add to table again</span>
        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">sql.to_sql(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test_frame4&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">if_exists=</span><span class="s3">&quot;append&quot;</span><span class="s1">) == </span><span class="s4">4</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">sql.has_table(</span><span class="s3">&quot;test_frame4&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s1">num_entries = </span><span class="s4">2 </span><span class="s1">* len(test_frame1)</span>
        <span class="s1">num_rows = count_rows(self.conn</span><span class="s2">, </span><span class="s3">&quot;test_frame4&quot;</span><span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">num_rows == num_entries</span>

    <span class="s2">def </span><span class="s1">test_to_sql_type_mapping(self</span><span class="s2">, </span><span class="s1">test_frame3):</span>
        <span class="s1">sql.to_sql(test_frame3</span><span class="s2">, </span><span class="s3">&quot;test_frame5&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">result = sql.read_sql(</span><span class="s3">&quot;SELECT * FROM test_frame5&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s1">tm.assert_frame_equal(test_frame3</span><span class="s2">, </span><span class="s1">result)</span>

    <span class="s2">def </span><span class="s1">test_to_sql_series(self):</span>
        <span class="s1">s = Series(np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;series&quot;</span><span class="s1">)</span>
        <span class="s1">sql.to_sql(s</span><span class="s2">, </span><span class="s3">&quot;test_series&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">s2 = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_series&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">tm.assert_frame_equal(s.to_frame()</span><span class="s2">, </span><span class="s1">s2)</span>

    <span class="s2">def </span><span class="s1">test_roundtrip(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s1">sql.to_sql(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test_frame_roundtrip&quot;</span><span class="s2">, </span><span class="s1">con=self.conn)</span>
        <span class="s1">result = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_frame_roundtrip&quot;</span><span class="s2">, </span><span class="s1">con=self.conn)</span>

        <span class="s5"># HACK!</span>
        <span class="s1">result.index = test_frame1.index</span>
        <span class="s1">result.set_index(</span><span class="s3">&quot;level_0&quot;</span><span class="s2">, </span><span class="s1">inplace=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">result.index.astype(int)</span>
        <span class="s1">result.index.name = </span><span class="s2">None</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">test_frame1)</span>

    <span class="s2">def </span><span class="s1">test_roundtrip_chunksize(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s1">sql.to_sql(</span>
            <span class="s1">test_frame1</span><span class="s2">,</span>
            <span class="s3">&quot;test_frame_roundtrip&quot;</span><span class="s2">,</span>
            <span class="s1">con=self.conn</span><span class="s2">,</span>
            <span class="s1">index=</span><span class="s2">False,</span>
            <span class="s1">chunksize=</span><span class="s4">2</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">result = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_frame_roundtrip&quot;</span><span class="s2">, </span><span class="s1">con=self.conn)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">test_frame1)</span>

    <span class="s2">def </span><span class="s1">test_execute_sql(self):</span>
        <span class="s5"># drop_sql = &quot;DROP TABLE IF EXISTS test&quot;  # should already be done</span>
        <span class="s1">iris_results = sql.execute(</span><span class="s3">&quot;SELECT * FROM iris&quot;</span><span class="s2">, </span><span class="s1">con=self.conn)</span>
        <span class="s1">row = iris_results.fetchone()</span>
        <span class="s1">tm.equalContents(row</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5.1</span><span class="s2">, </span><span class="s4">3.5</span><span class="s2">, </span><span class="s4">1.4</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s3">&quot;Iris-setosa&quot;</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_date_parsing(self):</span>
        <span class="s5"># Test date parsing in read_sql</span>
        <span class="s5"># No Parsing</span>
        <span class="s1">df = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM types&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s2">assert not </span><span class="s1">issubclass(df.DateCol.dtype.type</span><span class="s2">, </span><span class="s1">np.datetime64)</span>

        <span class="s1">df = sql.read_sql_query(</span>
            <span class="s3">&quot;SELECT * FROM types&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">parse_dates=[</span><span class="s3">&quot;DateCol&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.DateCol.dtype.type</span><span class="s2">, </span><span class="s1">np.datetime64)</span>
        <span class="s2">assert </span><span class="s1">df.DateCol.tolist() == [</span>
            <span class="s1">Timestamp(</span><span class="s4">2000</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s4">2000</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>

        <span class="s1">df = sql.read_sql_query(</span>
            <span class="s3">&quot;SELECT * FROM types&quot;</span><span class="s2">,</span>
            <span class="s1">self.conn</span><span class="s2">,</span>
            <span class="s1">parse_dates={</span><span class="s3">&quot;DateCol&quot;</span><span class="s1">: </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S&quot;</span><span class="s1">}</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.DateCol.dtype.type</span><span class="s2">, </span><span class="s1">np.datetime64)</span>
        <span class="s2">assert </span><span class="s1">df.DateCol.tolist() == [</span>
            <span class="s1">Timestamp(</span><span class="s4">2000</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s4">2000</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>

        <span class="s1">df = sql.read_sql_query(</span>
            <span class="s3">&quot;SELECT * FROM types&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">parse_dates=[</span><span class="s3">&quot;IntDateCol&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.IntDateCol.dtype.type</span><span class="s2">, </span><span class="s1">np.datetime64)</span>
        <span class="s2">assert </span><span class="s1">df.IntDateCol.tolist() == [</span>
            <span class="s1">Timestamp(</span><span class="s4">1986</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">25</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s4">2013</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>

        <span class="s1">df = sql.read_sql_query(</span>
            <span class="s3">&quot;SELECT * FROM types&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">parse_dates={</span><span class="s3">&quot;IntDateCol&quot;</span><span class="s1">: </span><span class="s3">&quot;s&quot;</span><span class="s1">}</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.IntDateCol.dtype.type</span><span class="s2">, </span><span class="s1">np.datetime64)</span>
        <span class="s2">assert </span><span class="s1">df.IntDateCol.tolist() == [</span>
            <span class="s1">Timestamp(</span><span class="s4">1986</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">25</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s4">2013</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>

        <span class="s1">df = sql.read_sql_query(</span>
            <span class="s3">&quot;SELECT * FROM types&quot;</span><span class="s2">,</span>
            <span class="s1">self.conn</span><span class="s2">,</span>
            <span class="s1">parse_dates={</span><span class="s3">&quot;IntDateOnlyCol&quot;</span><span class="s1">: </span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s1">}</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.IntDateOnlyCol.dtype.type</span><span class="s2">, </span><span class="s1">np.datetime64)</span>
        <span class="s2">assert </span><span class="s1">df.IntDateOnlyCol.tolist() == [</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2010-10-10&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2010-12-12&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;error&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s3">&quot;coerce&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;read_sql, text, mode&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(sql.read_sql</span><span class="s2">, </span><span class="s3">&quot;SELECT * FROM types&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;sqlalchemy&quot;</span><span class="s2">, </span><span class="s3">&quot;fallback&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(sql.read_sql</span><span class="s2">, </span><span class="s3">&quot;types&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;sqlalchemy&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">sql.read_sql_query</span><span class="s2">,</span>
                <span class="s3">&quot;SELECT * FROM types&quot;</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s3">&quot;sqlalchemy&quot;</span><span class="s2">, </span><span class="s3">&quot;fallback&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(sql.read_sql_table</span><span class="s2">, </span><span class="s3">&quot;types&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;sqlalchemy&quot;</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_custom_dateparsing_error(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">read_sql</span><span class="s2">, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">error</span><span class="s2">, </span><span class="s1">types_data_frame</span>
    <span class="s1">):</span>
        <span class="s2">if </span><span class="s1">self.mode </span><span class="s2">in </span><span class="s1">mode:</span>
            <span class="s1">expected = types_data_frame.astype({</span><span class="s3">&quot;DateCol&quot;</span><span class="s1">: </span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">})</span>

            <span class="s1">result = read_sql(</span>
                <span class="s1">text</span><span class="s2">,</span>
                <span class="s1">con=self.conn</span><span class="s2">,</span>
                <span class="s1">parse_dates={</span>
                    <span class="s3">&quot;DateCol&quot;</span><span class="s1">: {</span><span class="s3">&quot;errors&quot;</span><span class="s1">: error}</span><span class="s2">,</span>
                <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">)</span>

            <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_date_and_index(self):</span>
        <span class="s5"># Test case where same column appears in parse_date and index_col</span>

        <span class="s1">df = sql.read_sql_query(</span>
            <span class="s3">&quot;SELECT * FROM types&quot;</span><span class="s2">,</span>
            <span class="s1">self.conn</span><span class="s2">,</span>
            <span class="s1">index_col=</span><span class="s3">&quot;DateCol&quot;</span><span class="s2">,</span>
            <span class="s1">parse_dates=[</span><span class="s3">&quot;DateCol&quot;</span><span class="s2">, </span><span class="s3">&quot;IntDateCol&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">issubclass(df.index.dtype.type</span><span class="s2">, </span><span class="s1">np.datetime64)</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.IntDateCol.dtype.type</span><span class="s2">, </span><span class="s1">np.datetime64)</span>

    <span class="s2">def </span><span class="s1">test_timedelta(self):</span>

        <span class="s5"># see #6921</span>
        <span class="s1">df = to_timedelta(Series([</span><span class="s3">&quot;00:00:01&quot;</span><span class="s2">, </span><span class="s3">&quot;00:00:03&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;foo&quot;</span><span class="s1">)).to_frame()</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(UserWarning):</span>
            <span class="s1">result_count = df.to_sql(</span><span class="s3">&quot;test_timedelta&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s2">assert </span><span class="s1">result_count == </span><span class="s4">2</span>
        <span class="s1">result = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_timedelta&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">tm.assert_series_equal(result[</span><span class="s3">&quot;foo&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">df[</span><span class="s3">&quot;foo&quot;</span><span class="s1">].view(</span><span class="s3">&quot;int64&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_complex_raises(self):</span>
        <span class="s1">df = DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1j</span><span class="s2">, </span><span class="s4">2j</span><span class="s1">]})</span>
        <span class="s1">msg = </span><span class="s3">&quot;Complex datatypes not supported&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;test_complex&quot;</span><span class="s2">, </span><span class="s1">self.conn) </span><span class="s2">is None</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;index_name,index_label,expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s5"># no index name, defaults to 'index'</span>
            <span class="s1">(</span><span class="s2">None, None, </span><span class="s3">&quot;index&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5"># specifying index_label</span>
            <span class="s1">(</span><span class="s2">None, </span><span class="s3">&quot;other_label&quot;</span><span class="s2">, </span><span class="s3">&quot;other_label&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5"># using the index name</span>
            <span class="s1">(</span><span class="s3">&quot;index_name&quot;</span><span class="s2">, None, </span><span class="s3">&quot;index_name&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5"># has index name, but specifying index_label</span>
            <span class="s1">(</span><span class="s3">&quot;index_name&quot;</span><span class="s2">, </span><span class="s3">&quot;other_label&quot;</span><span class="s2">, </span><span class="s3">&quot;other_label&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5"># index name is integer</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s2">, None, </span><span class="s3">&quot;0&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5"># index name is None but index label is integer</span>
            <span class="s1">(</span><span class="s2">None, </span><span class="s4">0</span><span class="s2">, </span><span class="s3">&quot;0&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_sql_index_label(self</span><span class="s2">, </span><span class="s1">index_name</span><span class="s2">, </span><span class="s1">index_label</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">temp_frame = DataFrame({</span><span class="s3">&quot;col1&quot;</span><span class="s1">: range(</span><span class="s4">4</span><span class="s1">)})</span>
        <span class="s1">temp_frame.index.name = index_name</span>
        <span class="s1">query = </span><span class="s3">&quot;SELECT * FROM test_index_label&quot;</span>
        <span class="s1">sql.to_sql(temp_frame</span><span class="s2">, </span><span class="s3">&quot;test_index_label&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index_label=index_label)</span>
        <span class="s1">frame = sql.read_sql_query(query</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s2">assert </span><span class="s1">frame.columns[</span><span class="s4">0</span><span class="s1">] == expected</span>

    <span class="s2">def </span><span class="s1">test_to_sql_index_label_multiindex(self):</span>
        <span class="s1">expected_row_count = </span><span class="s4">4</span>
        <span class="s1">temp_frame = DataFrame(</span>
            <span class="s1">{</span><span class="s3">&quot;col1&quot;</span><span class="s1">: range(</span><span class="s4">4</span><span class="s1">)}</span><span class="s2">,</span>
            <span class="s1">index=MultiIndex.from_product([(</span><span class="s3">&quot;A0&quot;</span><span class="s2">, </span><span class="s3">&quot;A1&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;B0&quot;</span><span class="s2">, </span><span class="s3">&quot;B1&quot;</span><span class="s1">)])</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s5"># no index name, defaults to 'level_0' and 'level_1'</span>
        <span class="s1">result = sql.to_sql(temp_frame</span><span class="s2">, </span><span class="s3">&quot;test_index_label&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s2">assert </span><span class="s1">result == expected_row_count</span>
        <span class="s1">frame = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_index_label&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s2">assert </span><span class="s1">frame.columns[</span><span class="s4">0</span><span class="s1">] == </span><span class="s3">&quot;level_0&quot;</span>
        <span class="s2">assert </span><span class="s1">frame.columns[</span><span class="s4">1</span><span class="s1">] == </span><span class="s3">&quot;level_1&quot;</span>

        <span class="s5"># specifying index_label</span>
        <span class="s1">result = sql.to_sql(</span>
            <span class="s1">temp_frame</span><span class="s2">,</span>
            <span class="s3">&quot;test_index_label&quot;</span><span class="s2">,</span>
            <span class="s1">self.conn</span><span class="s2">,</span>
            <span class="s1">if_exists=</span><span class="s3">&quot;replace&quot;</span><span class="s2">,</span>
            <span class="s1">index_label=[</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected_row_count</span>
        <span class="s1">frame = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_index_label&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s2">assert </span><span class="s1">frame.columns[:</span><span class="s4">2</span><span class="s1">].tolist() == [</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">]</span>

        <span class="s5"># using the index name</span>
        <span class="s1">temp_frame.index.names = [</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">]</span>
        <span class="s1">result = sql.to_sql(</span>
            <span class="s1">temp_frame</span><span class="s2">, </span><span class="s3">&quot;test_index_label&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">if_exists=</span><span class="s3">&quot;replace&quot;</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected_row_count</span>
        <span class="s1">frame = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_index_label&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s2">assert </span><span class="s1">frame.columns[:</span><span class="s4">2</span><span class="s1">].tolist() == [</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">]</span>

        <span class="s5"># has index name, but specifying index_label</span>
        <span class="s1">result = sql.to_sql(</span>
            <span class="s1">temp_frame</span><span class="s2">,</span>
            <span class="s3">&quot;test_index_label&quot;</span><span class="s2">,</span>
            <span class="s1">self.conn</span><span class="s2">,</span>
            <span class="s1">if_exists=</span><span class="s3">&quot;replace&quot;</span><span class="s2">,</span>
            <span class="s1">index_label=[</span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected_row_count</span>
        <span class="s1">frame = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_index_label&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s2">assert </span><span class="s1">frame.columns[:</span><span class="s4">2</span><span class="s1">].tolist() == [</span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">]</span>

        <span class="s1">msg = </span><span class="s3">&quot;Length of 'index_label' should match number of levels, which is 2&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">sql.to_sql(</span>
                <span class="s1">temp_frame</span><span class="s2">,</span>
                <span class="s3">&quot;test_index_label&quot;</span><span class="s2">,</span>
                <span class="s1">self.conn</span><span class="s2">,</span>
                <span class="s1">if_exists=</span><span class="s3">&quot;replace&quot;</span><span class="s2">,</span>
                <span class="s1">index_label=</span><span class="s3">&quot;C&quot;</span><span class="s2">,</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_multiindex_roundtrip(self):</span>
        <span class="s1">df = DataFrame.from_records(</span>
            <span class="s1">[(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.1</span><span class="s2">, </span><span class="s3">&quot;line1&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s3">&quot;line2&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">columns=[</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">index=[</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">df.to_sql(</span><span class="s3">&quot;test_multiindex_roundtrip&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">result = sql.read_sql_query(</span>
            <span class="s3">&quot;SELECT * FROM test_multiindex_roundtrip&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index_col=[</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">check_index_type=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;dtype&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s2">None,</span>
            <span class="s1">int</span><span class="s2">,</span>
            <span class="s1">float</span><span class="s2">,</span>
            <span class="s1">{</span><span class="s3">&quot;A&quot;</span><span class="s1">: int</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: float}</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dtype_argument(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s5"># GH10285 Add dtype argument to read_sql_query</span>
        <span class="s1">df = DataFrame([[</span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">3.4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5.6</span><span class="s2">, </span><span class="s4">7.8</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;test_dtype_argument&quot;</span><span class="s2">, </span><span class="s1">self.conn) == </span><span class="s4">2</span>

        <span class="s1">expected = df.astype(dtype)</span>
        <span class="s1">result = sql.read_sql_query(</span>
            <span class="s3">&quot;SELECT A, B FROM test_dtype_argument&quot;</span><span class="s2">, </span><span class="s1">con=self.conn</span><span class="s2">, </span><span class="s1">dtype=dtype</span>
        <span class="s1">)</span>

        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_integer_col_names(self):</span>
        <span class="s1">df = DataFrame([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">sql.to_sql(df</span><span class="s2">, </span><span class="s3">&quot;test_frame_integer_col_names&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">if_exists=</span><span class="s3">&quot;replace&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_get_schema(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s1">create_sql = sql.get_schema(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test&quot;</span><span class="s2">, </span><span class="s1">con=self.conn)</span>
        <span class="s2">assert </span><span class="s3">&quot;CREATE&quot; </span><span class="s2">in </span><span class="s1">create_sql</span>

    <span class="s2">def </span><span class="s1">test_get_schema_with_schema(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s5"># GH28486</span>
        <span class="s1">create_sql = sql.get_schema(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test&quot;</span><span class="s2">, </span><span class="s1">con=self.conn</span><span class="s2">, </span><span class="s1">schema=</span><span class="s3">&quot;pypi&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s3">&quot;CREATE TABLE pypi.&quot; </span><span class="s2">in </span><span class="s1">create_sql</span>

    <span class="s2">def </span><span class="s1">test_get_schema_dtypes(self):</span>
        <span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;sqlalchemy&quot;</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">Integer</span>

            <span class="s1">dtype = Integer</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dtype = </span><span class="s3">&quot;INTEGER&quot;</span>

        <span class="s1">float_frame = DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s4">1.1</span><span class="s2">, </span><span class="s4">1.2</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">: [</span><span class="s4">2.1</span><span class="s2">, </span><span class="s4">2.2</span><span class="s1">]})</span>
        <span class="s1">create_sql = sql.get_schema(</span>
            <span class="s1">float_frame</span><span class="s2">, </span><span class="s3">&quot;test&quot;</span><span class="s2">, </span><span class="s1">con=self.conn</span><span class="s2">, </span><span class="s1">dtype={</span><span class="s3">&quot;b&quot;</span><span class="s1">: dtype}</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s3">&quot;CREATE&quot; </span><span class="s2">in </span><span class="s1">create_sql</span>
        <span class="s2">assert </span><span class="s3">&quot;INTEGER&quot; </span><span class="s2">in </span><span class="s1">create_sql</span>

    <span class="s2">def </span><span class="s1">test_get_schema_keys(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s1">frame = DataFrame({</span><span class="s3">&quot;Col1&quot;</span><span class="s1">: [</span><span class="s4">1.1</span><span class="s2">, </span><span class="s4">1.2</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;Col2&quot;</span><span class="s1">: [</span><span class="s4">2.1</span><span class="s2">, </span><span class="s4">2.2</span><span class="s1">]})</span>
        <span class="s1">create_sql = sql.get_schema(frame</span><span class="s2">, </span><span class="s3">&quot;test&quot;</span><span class="s2">, </span><span class="s1">con=self.conn</span><span class="s2">, </span><span class="s1">keys=</span><span class="s3">&quot;Col1&quot;</span><span class="s1">)</span>
        <span class="s1">constraint_sentence = </span><span class="s3">'CONSTRAINT test_pk PRIMARY KEY (&quot;Col1&quot;)'</span>
        <span class="s2">assert </span><span class="s1">constraint_sentence </span><span class="s2">in </span><span class="s1">create_sql</span>

        <span class="s5"># multiple columns as key (GH10385)</span>
        <span class="s1">create_sql = sql.get_schema(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test&quot;</span><span class="s2">, </span><span class="s1">con=self.conn</span><span class="s2">, </span><span class="s1">keys=[</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">])</span>
        <span class="s1">constraint_sentence = </span><span class="s3">'CONSTRAINT test_pk PRIMARY KEY (&quot;A&quot;, &quot;B&quot;)'</span>
        <span class="s2">assert </span><span class="s1">constraint_sentence </span><span class="s2">in </span><span class="s1">create_sql</span>

    <span class="s2">def </span><span class="s1">test_chunksize_read(self):</span>
        <span class="s1">df = DataFrame(np.random.randn(</span><span class="s4">22</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">columns=list(</span><span class="s3">&quot;abcde&quot;</span><span class="s1">))</span>
        <span class="s1">df.to_sql(</span><span class="s3">&quot;test_chunksize&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s5"># reading the query in one time</span>
        <span class="s1">res1 = sql.read_sql_query(</span><span class="s3">&quot;select * from test_chunksize&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s5"># reading the query in chunks with read_sql_query</span>
        <span class="s1">res2 = DataFrame()</span>
        <span class="s1">i = </span><span class="s4">0</span>
        <span class="s1">sizes = [</span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>

        <span class="s2">for </span><span class="s1">chunk </span><span class="s2">in </span><span class="s1">sql.read_sql_query(</span>
            <span class="s3">&quot;select * from test_chunksize&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">chunksize=</span><span class="s4">5</span>
        <span class="s1">):</span>
            <span class="s1">res2 = concat([res2</span><span class="s2">, </span><span class="s1">chunk]</span><span class="s2">, </span><span class="s1">ignore_index=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">len(chunk) == sizes[i]</span>
            <span class="s1">i += </span><span class="s4">1</span>

        <span class="s1">tm.assert_frame_equal(res1</span><span class="s2">, </span><span class="s1">res2)</span>

        <span class="s5"># reading the query in chunks with read_sql_query</span>
        <span class="s2">if </span><span class="s1">self.mode == </span><span class="s3">&quot;sqlalchemy&quot;</span><span class="s1">:</span>
            <span class="s1">res3 = DataFrame()</span>
            <span class="s1">i = </span><span class="s4">0</span>
            <span class="s1">sizes = [</span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>

            <span class="s2">for </span><span class="s1">chunk </span><span class="s2">in </span><span class="s1">sql.read_sql_table(</span><span class="s3">&quot;test_chunksize&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">chunksize=</span><span class="s4">5</span><span class="s1">):</span>
                <span class="s1">res3 = concat([res3</span><span class="s2">, </span><span class="s1">chunk]</span><span class="s2">, </span><span class="s1">ignore_index=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s2">assert </span><span class="s1">len(chunk) == sizes[i]</span>
                <span class="s1">i += </span><span class="s4">1</span>

            <span class="s1">tm.assert_frame_equal(res1</span><span class="s2">, </span><span class="s1">res3)</span>

    <span class="s2">def </span><span class="s1">test_categorical(self):</span>
        <span class="s5"># GH8624</span>
        <span class="s5"># test that categorical gets written correctly as dense column</span>
        <span class="s1">df = DataFrame(</span>
            <span class="s1">{</span>
                <span class="s3">&quot;person_id&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;person_name&quot;</span><span class="s1">: [</span><span class="s3">&quot;John P. Doe&quot;</span><span class="s2">, </span><span class="s3">&quot;Jane Dove&quot;</span><span class="s2">, </span><span class="s3">&quot;John P. Doe&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>
        <span class="s1">df2 = df.copy()</span>
        <span class="s1">df2[</span><span class="s3">&quot;person_name&quot;</span><span class="s1">] = df2[</span><span class="s3">&quot;person_name&quot;</span><span class="s1">].astype(</span><span class="s3">&quot;category&quot;</span><span class="s1">)</span>

        <span class="s1">df2.to_sql(</span><span class="s3">&quot;test_categorical&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">res = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_categorical&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s1">tm.assert_frame_equal(res</span><span class="s2">, </span><span class="s1">df)</span>

    <span class="s2">def </span><span class="s1">test_unicode_column_name(self):</span>
        <span class="s5"># GH 11431</span>
        <span class="s1">df = DataFrame([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;</span><span class="s2">\xe9</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span>
        <span class="s1">df.to_sql(</span><span class="s3">&quot;test_unicode&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_escaped_table_name(self):</span>
        <span class="s5"># GH 13206</span>
        <span class="s1">df = DataFrame({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: [</span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">5.6</span><span class="s1">]})</span>
        <span class="s1">df.to_sql(</span><span class="s3">&quot;d1187b08-4943-4c8d-a7f6&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">res = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM `d1187b08-4943-4c8d-a7f6`&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s1">tm.assert_frame_equal(res</span><span class="s2">, </span><span class="s1">df)</span>


<span class="s1">@pytest.mark.single</span>
<span class="s1">@pytest.mark.skipif(</span><span class="s2">not </span><span class="s1">SQLALCHEMY_INSTALLED</span><span class="s2">, </span><span class="s1">reason=</span><span class="s3">&quot;SQLAlchemy not installed&quot;</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">TestSQLApi(SQLAlchemyMixIn</span><span class="s2">, </span><span class="s1">_TestSQLApi):</span>
    <span class="s0">&quot;&quot;&quot; 
    Test the public API as it would be used directly 
 
    Tests for `read_sql_table` are included here, as this is specific for the 
    sqlalchemy mode. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">flavor = </span><span class="s3">&quot;sqlite&quot;</span>
    <span class="s1">mode = </span><span class="s3">&quot;sqlalchemy&quot;</span>

    <span class="s2">def </span><span class="s1">connect(self):</span>
        <span class="s2">return </span><span class="s1">sqlalchemy.create_engine(</span><span class="s3">&quot;sqlite:///:memory:&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_read_table_columns(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s5"># test columns argument in read_table</span>
        <span class="s1">sql.to_sql(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test_frame&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s1">cols = [</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">]</span>
        <span class="s1">result = sql.read_sql_table(</span><span class="s3">&quot;test_frame&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">columns=cols)</span>
        <span class="s2">assert </span><span class="s1">result.columns.tolist() == cols</span>

    <span class="s2">def </span><span class="s1">test_read_table_index_col(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s5"># test columns argument in read_table</span>
        <span class="s1">sql.to_sql(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test_frame&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s1">result = sql.read_sql_table(</span><span class="s3">&quot;test_frame&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index_col=</span><span class="s3">&quot;index&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result.index.names == [</span><span class="s3">&quot;index&quot;</span><span class="s1">]</span>

        <span class="s1">result = sql.read_sql_table(</span><span class="s3">&quot;test_frame&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index_col=[</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">result.index.names == [</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">]</span>

        <span class="s1">result = sql.read_sql_table(</span>
            <span class="s3">&quot;test_frame&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index_col=[</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result.index.names == [</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">result.columns.tolist() == [</span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">test_read_sql_delegate(self):</span>
        <span class="s1">iris_frame1 = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM iris&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">iris_frame2 = sql.read_sql(</span><span class="s3">&quot;SELECT * FROM iris&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">tm.assert_frame_equal(iris_frame1</span><span class="s2">, </span><span class="s1">iris_frame2)</span>

        <span class="s1">iris_frame1 = sql.read_sql_table(</span><span class="s3">&quot;iris&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">iris_frame2 = sql.read_sql(</span><span class="s3">&quot;iris&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">tm.assert_frame_equal(iris_frame1</span><span class="s2">, </span><span class="s1">iris_frame2)</span>

    <span class="s2">def </span><span class="s1">test_not_reflect_all_tables(self):</span>
        <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">text</span>
        <span class="s2">from </span><span class="s1">sqlalchemy.engine </span><span class="s2">import </span><span class="s1">Engine</span>

        <span class="s5"># create invalid table</span>
        <span class="s1">query_list = [</span>
            <span class="s1">text(</span><span class="s3">&quot;CREATE TABLE invalid (x INTEGER, y UNKNOWN);&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">text(</span><span class="s3">&quot;CREATE TABLE other_table (x INTEGER, y INTEGER);&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s2">for </span><span class="s1">query </span><span class="s2">in </span><span class="s1">query_list:</span>
            <span class="s2">if </span><span class="s1">isinstance(self.conn</span><span class="s2">, </span><span class="s1">Engine):</span>
                <span class="s2">with </span><span class="s1">self.conn.connect() </span><span class="s2">as </span><span class="s1">conn:</span>
                    <span class="s2">with </span><span class="s1">conn.begin():</span>
                        <span class="s1">conn.execute(query)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.conn.execute(query)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s1">sql.read_sql_table(</span><span class="s3">&quot;other_table&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
            <span class="s1">sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM other_table&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

    <span class="s2">def </span><span class="s1">test_warning_case_insensitive_table_name(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s5"># see gh-7815</span>
        <span class="s5">#</span>
        <span class="s5"># We can't test that this warning is triggered, a the database</span>
        <span class="s5"># configuration would have to be altered. But here we test that</span>
        <span class="s5"># the warning is certainly NOT triggered in a normal case.</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s1">test_frame1.to_sql(</span><span class="s3">&quot;CaseSensitive&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

    <span class="s2">def </span><span class="s1">_get_index_columns(self</span><span class="s2">, </span><span class="s1">tbl_name):</span>
        <span class="s2">from </span><span class="s1">sqlalchemy.engine </span><span class="s2">import </span><span class="s1">reflection</span>

        <span class="s1">insp = reflection.Inspector.from_engine(self.conn)</span>
        <span class="s1">ixs = insp.get_indexes(</span><span class="s3">&quot;test_index_saved&quot;</span><span class="s1">)</span>
        <span class="s1">ixs = [i[</span><span class="s3">&quot;column_names&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">ixs]</span>
        <span class="s2">return </span><span class="s1">ixs</span>

    <span class="s2">def </span><span class="s1">test_sqlalchemy_type_mapping(self):</span>
        <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">TIMESTAMP</span>

        <span class="s5"># Test Timestamp objects (no datetime64 because of timezone) (GH9085)</span>
        <span class="s1">df = DataFrame(</span>
            <span class="s1">{</span><span class="s3">&quot;time&quot;</span><span class="s1">: to_datetime([</span><span class="s3">&quot;201412120154&quot;</span><span class="s2">, </span><span class="s3">&quot;201412110254&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)}</span>
        <span class="s1">)</span>
        <span class="s1">db = sql.SQLDatabase(self.conn)</span>
        <span class="s1">table = sql.SQLTable(</span><span class="s3">&quot;test_type&quot;</span><span class="s2">, </span><span class="s1">db</span><span class="s2">, </span><span class="s1">frame=df)</span>
        <span class="s5"># GH 9086: TIMESTAMP is the suggested type for datetimes with timezones</span>
        <span class="s2">assert </span><span class="s1">isinstance(table.table.c[</span><span class="s3">&quot;time&quot;</span><span class="s1">].type</span><span class="s2">, </span><span class="s1">TIMESTAMP)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;integer, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;int8&quot;</span><span class="s2">, </span><span class="s3">&quot;SMALLINT&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;Int8&quot;</span><span class="s2">, </span><span class="s3">&quot;SMALLINT&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;uint8&quot;</span><span class="s2">, </span><span class="s3">&quot;SMALLINT&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;UInt8&quot;</span><span class="s2">, </span><span class="s3">&quot;SMALLINT&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;int16&quot;</span><span class="s2">, </span><span class="s3">&quot;SMALLINT&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;Int16&quot;</span><span class="s2">, </span><span class="s3">&quot;SMALLINT&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;uint16&quot;</span><span class="s2">, </span><span class="s3">&quot;INTEGER&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;UInt16&quot;</span><span class="s2">, </span><span class="s3">&quot;INTEGER&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;int32&quot;</span><span class="s2">, </span><span class="s3">&quot;INTEGER&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;Int32&quot;</span><span class="s2">, </span><span class="s3">&quot;INTEGER&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;uint32&quot;</span><span class="s2">, </span><span class="s3">&quot;BIGINT&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;UInt32&quot;</span><span class="s2">, </span><span class="s3">&quot;BIGINT&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;int64&quot;</span><span class="s2">, </span><span class="s3">&quot;BIGINT&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;Int64&quot;</span><span class="s2">, </span><span class="s3">&quot;BIGINT&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(int</span><span class="s2">, </span><span class="s3">&quot;BIGINT&quot; </span><span class="s2">if </span><span class="s1">np.dtype(int).name == </span><span class="s3">&quot;int64&quot; </span><span class="s2">else </span><span class="s3">&quot;INTEGER&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_sqlalchemy_integer_mapping(self</span><span class="s2">, </span><span class="s1">integer</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s5"># GH35076 Map pandas integer to optimal SQLAlchemy integer type</span>
        <span class="s1">df = DataFrame([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;a&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=integer)</span>
        <span class="s1">db = sql.SQLDatabase(self.conn)</span>
        <span class="s1">table = sql.SQLTable(</span><span class="s3">&quot;test_type&quot;</span><span class="s2">, </span><span class="s1">db</span><span class="s2">, </span><span class="s1">frame=df)</span>

        <span class="s1">result = str(table.table.c.a.type)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;integer&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;uint64&quot;</span><span class="s2">, </span><span class="s3">&quot;UInt64&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_sqlalchemy_integer_overload_mapping(self</span><span class="s2">, </span><span class="s1">integer):</span>
        <span class="s5"># GH35076 Map pandas integer to optimal SQLAlchemy integer type</span>
        <span class="s1">df = DataFrame([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;a&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=integer)</span>
        <span class="s1">db = sql.SQLDatabase(self.conn)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Unsigned 64 bit integer datatype is not supported&quot;</span>
        <span class="s1">):</span>
            <span class="s1">sql.SQLTable(</span><span class="s3">&quot;test_type&quot;</span><span class="s2">, </span><span class="s1">db</span><span class="s2">, </span><span class="s1">frame=df)</span>

    <span class="s2">def </span><span class="s1">test_database_uri_string(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s5"># Test read_sql and .to_sql method with a database URI (GH10654)</span>
        <span class="s5"># db_uri = 'sqlite:///:memory:' # raises</span>
        <span class="s5"># sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) near</span>
        <span class="s5"># &quot;iris&quot;: syntax error [SQL: 'iris']</span>
        <span class="s2">with </span><span class="s1">tm.ensure_clean() </span><span class="s2">as </span><span class="s1">name:</span>
            <span class="s1">db_uri = </span><span class="s3">&quot;sqlite:///&quot; </span><span class="s1">+ name</span>
            <span class="s1">table = </span><span class="s3">&quot;iris&quot;</span>
            <span class="s1">test_frame1.to_sql(table</span><span class="s2">, </span><span class="s1">db_uri</span><span class="s2">, </span><span class="s1">if_exists=</span><span class="s3">&quot;replace&quot;</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">test_frame2 = sql.read_sql(table</span><span class="s2">, </span><span class="s1">db_uri)</span>
            <span class="s1">test_frame3 = sql.read_sql_table(table</span><span class="s2">, </span><span class="s1">db_uri)</span>
            <span class="s1">query = </span><span class="s3">&quot;SELECT * FROM iris&quot;</span>
            <span class="s1">test_frame4 = sql.read_sql_query(query</span><span class="s2">, </span><span class="s1">db_uri)</span>
        <span class="s1">tm.assert_frame_equal(test_frame1</span><span class="s2">, </span><span class="s1">test_frame2)</span>
        <span class="s1">tm.assert_frame_equal(test_frame1</span><span class="s2">, </span><span class="s1">test_frame3)</span>
        <span class="s1">tm.assert_frame_equal(test_frame1</span><span class="s2">, </span><span class="s1">test_frame4)</span>

    <span class="s1">@td.skip_if_installed(</span><span class="s3">&quot;pg8000&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_pg8000_sqlalchemy_passthrough_error(self):</span>
        <span class="s5"># using driver that will not be installed on CI to trigger error</span>
        <span class="s5"># in sqlalchemy.create_engine -&gt; test passing of this error to user</span>
        <span class="s1">db_uri = </span><span class="s3">&quot;postgresql+pg8000://user:pass@host/dbname&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ImportError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;pg8000&quot;</span><span class="s1">):</span>
            <span class="s1">sql.read_sql(</span><span class="s3">&quot;select * from table&quot;</span><span class="s2">, </span><span class="s1">db_uri)</span>

    <span class="s2">def </span><span class="s1">test_query_by_text_obj(self):</span>
        <span class="s5"># WIP : GH10846</span>
        <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">text</span>

        <span class="s1">name_text = text(</span><span class="s3">&quot;select * from iris where name=:name&quot;</span><span class="s1">)</span>
        <span class="s1">iris_df = sql.read_sql(name_text</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">params={</span><span class="s3">&quot;name&quot;</span><span class="s1">: </span><span class="s3">&quot;Iris-versicolor&quot;</span><span class="s1">})</span>
        <span class="s1">all_names = set(iris_df[</span><span class="s3">&quot;Name&quot;</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">all_names == {</span><span class="s3">&quot;Iris-versicolor&quot;</span><span class="s1">}</span>

    <span class="s2">def </span><span class="s1">test_query_by_select_obj(self):</span>
        <span class="s5"># WIP : GH10846</span>
        <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">(</span>
            <span class="s1">bindparam</span><span class="s2">,</span>
            <span class="s1">select</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">iris = iris_table_metadata(self.flavor)</span>
        <span class="s1">iris_select = iris </span><span class="s2">if </span><span class="s1">_gt14() </span><span class="s2">else </span><span class="s1">[iris]</span>
        <span class="s1">name_select = select(iris_select).where(iris.c.Name == bindparam(</span><span class="s3">&quot;name&quot;</span><span class="s1">))</span>
        <span class="s1">iris_df = sql.read_sql(name_select</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">params={</span><span class="s3">&quot;name&quot;</span><span class="s1">: </span><span class="s3">&quot;Iris-setosa&quot;</span><span class="s1">})</span>
        <span class="s1">all_names = set(iris_df[</span><span class="s3">&quot;Name&quot;</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">all_names == {</span><span class="s3">&quot;Iris-setosa&quot;</span><span class="s1">}</span>

    <span class="s2">def </span><span class="s1">test_column_with_percentage(self):</span>
        <span class="s5"># GH 37157</span>
        <span class="s1">df = DataFrame({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;%_variation&quot;</span><span class="s1">: [</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]})</span>
        <span class="s1">df.to_sql(</span><span class="s3">&quot;test_column_percentage&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">res = sql.read_sql_table(</span><span class="s3">&quot;test_column_percentage&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s1">tm.assert_frame_equal(res</span><span class="s2">, </span><span class="s1">df)</span>


<span class="s2">class </span><span class="s1">_EngineToConnMixin:</span>
    <span class="s0">&quot;&quot;&quot; 
    A mixin that causes setup_connect to create a conn rather than an engine. 
    &quot;&quot;&quot;</span>

    <span class="s1">@pytest.fixture(autouse=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">setup_method(self</span><span class="s2">, </span><span class="s1">load_iris_data</span><span class="s2">, </span><span class="s1">load_types_data):</span>
        <span class="s1">super().load_test_data_and_sql()</span>
        <span class="s1">engine = self.conn</span>
        <span class="s1">conn = engine.connect()</span>
        <span class="s1">self.__tx = conn.begin()</span>
        <span class="s1">self.pandasSQL = sql.SQLDatabase(conn)</span>
        <span class="s1">self.__engine = engine</span>
        <span class="s1">self.conn = conn</span>

        <span class="s2">yield</span>

        <span class="s1">self.__tx.rollback()</span>
        <span class="s1">self.conn.close()</span>
        <span class="s1">self.conn = self.__engine</span>
        <span class="s1">self.pandasSQL = sql.SQLDatabase(self.__engine)</span>


<span class="s1">@pytest.mark.single</span>
<span class="s2">class </span><span class="s1">TestSQLApiConn(_EngineToConnMixin</span><span class="s2">, </span><span class="s1">TestSQLApi):</span>
    <span class="s2">pass</span>


<span class="s1">@pytest.mark.single</span>
<span class="s2">class </span><span class="s1">TestSQLiteFallbackApi(SQLiteMixIn</span><span class="s2">, </span><span class="s1">_TestSQLApi):</span>
    <span class="s0">&quot;&quot;&quot; 
    Test the public sqlite connection fallback API 
 
    &quot;&quot;&quot;</span>

    <span class="s1">flavor = </span><span class="s3">&quot;sqlite&quot;</span>
    <span class="s1">mode = </span><span class="s3">&quot;fallback&quot;</span>

    <span class="s2">def </span><span class="s1">connect(self</span><span class="s2">, </span><span class="s1">database=</span><span class="s3">&quot;:memory:&quot;</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">sqlite3.connect(database)</span>

    <span class="s2">def </span><span class="s1">test_sql_open_close(self</span><span class="s2">, </span><span class="s1">test_frame3):</span>
        <span class="s5"># Test if the IO in the database still work if the connection closed</span>
        <span class="s5"># between the writing and reading (as in many real situations).</span>

        <span class="s2">with </span><span class="s1">tm.ensure_clean() </span><span class="s2">as </span><span class="s1">name:</span>

            <span class="s1">conn = self.connect(name)</span>
            <span class="s2">assert </span><span class="s1">sql.to_sql(test_frame3</span><span class="s2">, </span><span class="s3">&quot;test_frame3_legacy&quot;</span><span class="s2">, </span><span class="s1">conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">4</span>
            <span class="s1">conn.close()</span>

            <span class="s1">conn = self.connect(name)</span>
            <span class="s1">result = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_frame3_legacy;&quot;</span><span class="s2">, </span><span class="s1">conn)</span>
            <span class="s1">conn.close()</span>

        <span class="s1">tm.assert_frame_equal(test_frame3</span><span class="s2">, </span><span class="s1">result)</span>

    <span class="s1">@pytest.mark.skipif(SQLALCHEMY_INSTALLED</span><span class="s2">, </span><span class="s1">reason=</span><span class="s3">&quot;SQLAlchemy is installed&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_con_string_import_error(self):</span>
        <span class="s1">conn = </span><span class="s3">&quot;mysql://root@localhost/pandas&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ImportError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;SQLAlchemy&quot;</span><span class="s1">):</span>
            <span class="s1">sql.read_sql(</span><span class="s3">&quot;SELECT * FROM iris&quot;</span><span class="s2">, </span><span class="s1">conn)</span>

    <span class="s2">def </span><span class="s1">test_read_sql_delegate(self):</span>
        <span class="s1">iris_frame1 = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM iris&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">iris_frame2 = sql.read_sql(</span><span class="s3">&quot;SELECT * FROM iris&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">tm.assert_frame_equal(iris_frame1</span><span class="s2">, </span><span class="s1">iris_frame2)</span>

        <span class="s1">msg = </span><span class="s3">&quot;Execution failed on sql 'iris': near </span><span class="s2">\&quot;</span><span class="s3">iris</span><span class="s2">\&quot;</span><span class="s3">: syntax error&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(sql.DatabaseError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">sql.read_sql(</span><span class="s3">&quot;iris&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

    <span class="s2">def </span><span class="s1">test_get_schema2(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s5"># without providing a connection object (available for backwards comp)</span>
        <span class="s1">create_sql = sql.get_schema(test_frame1</span><span class="s2">, </span><span class="s3">&quot;test&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s3">&quot;CREATE&quot; </span><span class="s2">in </span><span class="s1">create_sql</span>

    <span class="s2">def </span><span class="s1">_get_sqlite_column_type(self</span><span class="s2">, </span><span class="s1">schema</span><span class="s2">, </span><span class="s1">column):</span>

        <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">schema.split(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">col.split()[</span><span class="s4">0</span><span class="s1">].strip(</span><span class="s3">'&quot;&quot;'</span><span class="s1">) == column:</span>
                <span class="s2">return </span><span class="s1">col.split()[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Column </span><span class="s2">{</span><span class="s1">column</span><span class="s2">} </span><span class="s3">not found&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_sqlite_type_mapping(self):</span>

        <span class="s5"># Test Timestamp objects (no datetime64 because of timezone) (GH9085)</span>
        <span class="s1">df = DataFrame(</span>
            <span class="s1">{</span><span class="s3">&quot;time&quot;</span><span class="s1">: to_datetime([</span><span class="s3">&quot;201412120154&quot;</span><span class="s2">, </span><span class="s3">&quot;201412110254&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)}</span>
        <span class="s1">)</span>
        <span class="s1">db = sql.SQLiteDatabase(self.conn)</span>
        <span class="s1">table = sql.SQLiteTable(</span><span class="s3">&quot;test_type&quot;</span><span class="s2">, </span><span class="s1">db</span><span class="s2">, </span><span class="s1">frame=df)</span>
        <span class="s1">schema = table.sql_schema()</span>
        <span class="s2">assert </span><span class="s1">self._get_sqlite_column_type(schema</span><span class="s2">, </span><span class="s3">&quot;time&quot;</span><span class="s1">) == </span><span class="s3">&quot;TIMESTAMP&quot;</span>


<span class="s5"># -----------------------------------------------------------------------------</span>
<span class="s5"># -- Database flavor specific tests</span>


<span class="s2">class </span><span class="s1">_TestSQLAlchemy(SQLAlchemyMixIn</span><span class="s2">, </span><span class="s1">PandasSQLTest):</span>
    <span class="s0">&quot;&quot;&quot; 
    Base class for testing the sqlalchemy backend. 
 
    Subclasses for specific database types are created below. Tests that 
    deviate for each flavor are overwritten there. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">flavor: str</span>

    <span class="s1">@pytest.fixture(autouse=</span><span class="s2">True, </span><span class="s1">scope=</span><span class="s3">&quot;class&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">cls.setup_import()</span>
        <span class="s1">cls.setup_driver()</span>
        <span class="s1">conn = cls.conn = cls.connect()</span>
        <span class="s1">conn.connect()</span>

    <span class="s2">def </span><span class="s1">load_test_data_and_sql(self):</span>
        <span class="s2">pass</span>

    <span class="s1">@pytest.fixture(autouse=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">setup_method(self</span><span class="s2">, </span><span class="s1">load_iris_data</span><span class="s2">, </span><span class="s1">load_types_data):</span>
        <span class="s2">pass</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_import(cls):</span>
        <span class="s5"># Skip this test if SQLAlchemy not available</span>
        <span class="s2">if not </span><span class="s1">SQLALCHEMY_INSTALLED:</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;SQLAlchemy not installed&quot;</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_driver(cls):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">connect(cls):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">setup_connect(self):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.conn = self.connect()</span>
            <span class="s1">self.pandasSQL = sql.SQLDatabase(self.conn)</span>
            <span class="s5"># to test if connection can be made:</span>
            <span class="s1">self.conn.connect()</span>
        <span class="s2">except </span><span class="s1">sqlalchemy.exc.OperationalError:</span>
            <span class="s1">pytest.skip(</span><span class="s3">f&quot;Can't connect to </span><span class="s2">{</span><span class="s1">self.flavor</span><span class="s2">} </span><span class="s3">server&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_read_sql_parameter(self):</span>
        <span class="s1">self._read_sql_iris_parameter()</span>

    <span class="s2">def </span><span class="s1">test_read_sql_named_parameter(self):</span>
        <span class="s1">self._read_sql_iris_named_parameter()</span>

    <span class="s2">def </span><span class="s1">test_to_sql_empty(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s1">self._to_sql_empty(test_frame1)</span>

    <span class="s2">def </span><span class="s1">test_create_table(self):</span>
        <span class="s1">temp_conn = self.connect()</span>
        <span class="s1">temp_frame = DataFrame(</span>
            <span class="s1">{</span><span class="s3">&quot;one&quot;</span><span class="s1">: [</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">4.0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;two&quot;</span><span class="s1">: [</span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]}</span>
        <span class="s1">)</span>

        <span class="s1">pandasSQL = sql.SQLDatabase(temp_conn)</span>
        <span class="s2">assert </span><span class="s1">pandasSQL.to_sql(temp_frame</span><span class="s2">, </span><span class="s3">&quot;temp_frame&quot;</span><span class="s1">) == </span><span class="s4">4</span>

        <span class="s2">if </span><span class="s1">_gt14():</span>
            <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">inspect</span>

            <span class="s1">insp = inspect(temp_conn)</span>
            <span class="s2">assert </span><span class="s1">insp.has_table(</span><span class="s3">&quot;temp_frame&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">temp_conn.has_table(</span><span class="s3">&quot;temp_frame&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_drop_table(self):</span>
        <span class="s1">temp_conn = self.connect()</span>

        <span class="s1">temp_frame = DataFrame(</span>
            <span class="s1">{</span><span class="s3">&quot;one&quot;</span><span class="s1">: [</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">4.0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;two&quot;</span><span class="s1">: [</span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]}</span>
        <span class="s1">)</span>

        <span class="s1">pandasSQL = sql.SQLDatabase(temp_conn)</span>
        <span class="s2">assert </span><span class="s1">pandasSQL.to_sql(temp_frame</span><span class="s2">, </span><span class="s3">&quot;temp_frame&quot;</span><span class="s1">) == </span><span class="s4">4</span>

        <span class="s2">if </span><span class="s1">_gt14():</span>
            <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">inspect</span>

            <span class="s1">insp = inspect(temp_conn)</span>
            <span class="s2">assert </span><span class="s1">insp.has_table(</span><span class="s3">&quot;temp_frame&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">temp_conn.has_table(</span><span class="s3">&quot;temp_frame&quot;</span><span class="s1">)</span>

        <span class="s1">pandasSQL.drop_table(</span><span class="s3">&quot;temp_frame&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">_gt14():</span>
            <span class="s2">assert not </span><span class="s1">insp.has_table(</span><span class="s3">&quot;temp_frame&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert not </span><span class="s1">temp_conn.has_table(</span><span class="s3">&quot;temp_frame&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_roundtrip(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s1">self._roundtrip(test_frame1)</span>

    <span class="s2">def </span><span class="s1">test_execute_sql(self):</span>
        <span class="s1">self._execute_sql()</span>

    <span class="s2">def </span><span class="s1">test_read_table(self):</span>
        <span class="s1">iris_frame = sql.read_sql_table(</span><span class="s3">&quot;iris&quot;</span><span class="s2">, </span><span class="s1">con=self.conn)</span>
        <span class="s1">check_iris_frame(iris_frame)</span>

    <span class="s2">def </span><span class="s1">test_read_table_columns(self):</span>
        <span class="s1">iris_frame = sql.read_sql_table(</span>
            <span class="s3">&quot;iris&quot;</span><span class="s2">, </span><span class="s1">con=self.conn</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;SepalLength&quot;</span><span class="s2">, </span><span class="s3">&quot;SepalLength&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.equalContents(iris_frame.columns.values</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;SepalLength&quot;</span><span class="s2">, </span><span class="s3">&quot;SepalLength&quot;</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_read_table_absent_raises(self):</span>
        <span class="s1">msg = </span><span class="s3">&quot;Table this_doesnt_exist not found&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">sql.read_sql_table(</span><span class="s3">&quot;this_doesnt_exist&quot;</span><span class="s2">, </span><span class="s1">con=self.conn)</span>

    <span class="s2">def </span><span class="s1">test_default_type_conversion(self):</span>
        <span class="s1">df = sql.read_sql_table(</span><span class="s3">&quot;types&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s2">assert </span><span class="s1">issubclass(df.FloatCol.dtype.type</span><span class="s2">, </span><span class="s1">np.floating)</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.IntCol.dtype.type</span><span class="s2">, </span><span class="s1">np.integer)</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.BoolCol.dtype.type</span><span class="s2">, </span><span class="s1">np.bool_)</span>

        <span class="s5"># Int column with NA values stays as float</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.IntColWithNull.dtype.type</span><span class="s2">, </span><span class="s1">np.floating)</span>
        <span class="s5"># Bool column with NA values becomes object</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.BoolColWithNull.dtype.type</span><span class="s2">, </span><span class="s1">object)</span>

    <span class="s2">def </span><span class="s1">test_bigint(self):</span>
        <span class="s5"># int64 should be converted to BigInteger, GH7433</span>
        <span class="s1">df = DataFrame(data={</span><span class="s3">&quot;i64&quot;</span><span class="s1">: [</span><span class="s4">2 </span><span class="s1">** </span><span class="s4">62</span><span class="s1">]})</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;test_bigint&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">1</span>
        <span class="s1">result = sql.read_sql_table(</span><span class="s3">&quot;test_bigint&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s1">tm.assert_frame_equal(df</span><span class="s2">, </span><span class="s1">result)</span>

    <span class="s2">def </span><span class="s1">test_default_date_load(self):</span>
        <span class="s1">df = sql.read_sql_table(</span><span class="s3">&quot;types&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s5"># IMPORTANT - sqlite has no native date type, so shouldn't parse, but</span>
        <span class="s5"># MySQL SHOULD be converted.</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.DateCol.dtype.type</span><span class="s2">, </span><span class="s1">np.datetime64)</span>

    <span class="s2">def </span><span class="s1">test_datetime_with_timezone(self):</span>
        <span class="s5"># edge case that converts postgresql datetime with time zone types</span>
        <span class="s5"># to datetime64[ns,psycopg2.tz.FixedOffsetTimezone..], which is ok</span>
        <span class="s5"># but should be more natural, so coerce to datetime64[ns] for now</span>

        <span class="s2">def </span><span class="s1">check(col):</span>
            <span class="s5"># check that a column is either datetime64[ns]</span>
            <span class="s5"># or datetime64[ns, UTC]</span>
            <span class="s2">if </span><span class="s1">is_datetime64_dtype(col.dtype):</span>

                <span class="s5"># &quot;2000-01-01 00:00:00-08:00&quot; should convert to</span>
                <span class="s5"># &quot;2000-01-01 08:00:00&quot;</span>
                <span class="s2">assert </span><span class="s1">col[</span><span class="s4">0</span><span class="s1">] == Timestamp(</span><span class="s3">&quot;2000-01-01 08:00:00&quot;</span><span class="s1">)</span>

                <span class="s5"># &quot;2000-06-01 00:00:00-07:00&quot; should convert to</span>
                <span class="s5"># &quot;2000-06-01 07:00:00&quot;</span>
                <span class="s2">assert </span><span class="s1">col[</span><span class="s4">1</span><span class="s1">] == Timestamp(</span><span class="s3">&quot;2000-06-01 07:00:00&quot;</span><span class="s1">)</span>

            <span class="s2">elif </span><span class="s1">is_datetime64tz_dtype(col.dtype):</span>
                <span class="s2">assert </span><span class="s1">str(col.dt.tz) == </span><span class="s3">&quot;UTC&quot;</span>

                <span class="s5"># &quot;2000-01-01 00:00:00-08:00&quot; should convert to</span>
                <span class="s5"># &quot;2000-01-01 08:00:00&quot;</span>
                <span class="s5"># &quot;2000-06-01 00:00:00-07:00&quot; should convert to</span>
                <span class="s5"># &quot;2000-06-01 07:00:00&quot;</span>
                <span class="s5"># GH 6415</span>
                <span class="s1">expected_data = [</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-01 08:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2000-06-01 07:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">]</span>
                <span class="s1">expected = Series(expected_data</span><span class="s2">, </span><span class="s1">name=col.name)</span>
                <span class="s1">tm.assert_series_equal(col</span><span class="s2">, </span><span class="s1">expected)</span>

            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">AssertionError(</span>
                    <span class="s3">f&quot;DateCol loaded with incorrect type -&gt; </span><span class="s2">{</span><span class="s1">col.dtype</span><span class="s2">}</span><span class="s3">&quot;</span>
                <span class="s1">)</span>

        <span class="s5"># GH11216</span>
        <span class="s1">df = read_sql_query(</span><span class="s3">&quot;select * from types&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s2">if not </span><span class="s1">hasattr(df</span><span class="s2">, </span><span class="s3">&quot;DateColWithTz&quot;</span><span class="s1">):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;no column with datetime with time zone&quot;</span><span class="s1">)</span>

        <span class="s5"># this is parsed on Travis (linux), but not on macosx for some reason</span>
        <span class="s5"># even with the same versions of psycopg2 &amp; sqlalchemy, possibly a</span>
        <span class="s5"># Postgresql server version difference</span>
        <span class="s1">col = df.DateColWithTz</span>
        <span class="s2">assert </span><span class="s1">is_datetime64tz_dtype(col.dtype)</span>

        <span class="s1">df = read_sql_query(</span>
            <span class="s3">&quot;select * from types&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">parse_dates=[</span><span class="s3">&quot;DateColWithTz&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">hasattr(df</span><span class="s2">, </span><span class="s3">&quot;DateColWithTz&quot;</span><span class="s1">):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;no column with datetime with time zone&quot;</span><span class="s1">)</span>
        <span class="s1">col = df.DateColWithTz</span>
        <span class="s2">assert </span><span class="s1">is_datetime64tz_dtype(col.dtype)</span>
        <span class="s2">assert </span><span class="s1">str(col.dt.tz) == </span><span class="s3">&quot;UTC&quot;</span>
        <span class="s1">check(df.DateColWithTz)</span>

        <span class="s1">df = concat(</span>
            <span class="s1">list(read_sql_query(</span><span class="s3">&quot;select * from types&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">chunksize=</span><span class="s4">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">ignore_index=</span><span class="s2">True,</span>
        <span class="s1">)</span>
        <span class="s1">col = df.DateColWithTz</span>
        <span class="s2">assert </span><span class="s1">is_datetime64tz_dtype(col.dtype)</span>
        <span class="s2">assert </span><span class="s1">str(col.dt.tz) == </span><span class="s3">&quot;UTC&quot;</span>
        <span class="s1">expected = sql.read_sql_table(</span><span class="s3">&quot;types&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">col = expected.DateColWithTz</span>
        <span class="s2">assert </span><span class="s1">is_datetime64tz_dtype(col.dtype)</span>
        <span class="s1">tm.assert_series_equal(df.DateColWithTz</span><span class="s2">, </span><span class="s1">expected.DateColWithTz)</span>

        <span class="s5"># xref #7139</span>
        <span class="s5"># this might or might not be converted depending on the postgres driver</span>
        <span class="s1">df = sql.read_sql_table(</span><span class="s3">&quot;types&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">check(df.DateColWithTz)</span>

    <span class="s2">def </span><span class="s1">test_datetime_with_timezone_roundtrip(self):</span>
        <span class="s5"># GH 9086</span>
        <span class="s5"># Write datetimetz data to a db and read it back</span>
        <span class="s5"># For dbs that support timestamps with timezones, should get back UTC</span>
        <span class="s5"># otherwise naive data should be returned</span>
        <span class="s1">expected = DataFrame(</span>
            <span class="s1">{</span><span class="s3">&quot;A&quot;</span><span class="s1">: date_range(</span><span class="s3">&quot;2013-01-01 09:00:00&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)}</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">expected.to_sql(</span><span class="s3">&quot;test_datetime_tz&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">3</span>

        <span class="s2">if </span><span class="s1">self.flavor == </span><span class="s3">&quot;postgresql&quot;</span><span class="s1">:</span>
            <span class="s5"># SQLAlchemy &quot;timezones&quot; (i.e. offsets) are coerced to UTC</span>
            <span class="s1">expected[</span><span class="s3">&quot;A&quot;</span><span class="s1">] = expected[</span><span class="s3">&quot;A&quot;</span><span class="s1">].dt.tz_convert(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># Otherwise, timestamps are returned as local, naive</span>
            <span class="s1">expected[</span><span class="s3">&quot;A&quot;</span><span class="s1">] = expected[</span><span class="s3">&quot;A&quot;</span><span class="s1">].dt.tz_localize(</span><span class="s2">None</span><span class="s1">)</span>

        <span class="s1">result = sql.read_sql_table(</span><span class="s3">&quot;test_datetime_tz&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_datetime_tz&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s2">if </span><span class="s1">self.flavor == </span><span class="s3">&quot;sqlite&quot;</span><span class="s1">:</span>
            <span class="s5"># read_sql_query does not return datetime type like read_sql_table</span>
            <span class="s2">assert </span><span class="s1">isinstance(result.loc[</span><span class="s4">0</span><span class="s2">, </span><span class="s3">&quot;A&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">str)</span>
            <span class="s1">result[</span><span class="s3">&quot;A&quot;</span><span class="s1">] = to_datetime(result[</span><span class="s3">&quot;A&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_out_of_bounds_datetime(self):</span>
        <span class="s5"># GH 26761</span>
        <span class="s1">data = DataFrame({</span><span class="s3">&quot;date&quot;</span><span class="s1">: datetime(</span><span class="s4">9999</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)}</span><span class="s2">, </span><span class="s1">index=[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">data.to_sql(</span><span class="s3">&quot;test_datetime_obb&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">1</span>
        <span class="s1">result = sql.read_sql_table(</span><span class="s3">&quot;test_datetime_obb&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">expected = DataFrame([pd.NaT]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;date&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_naive_datetimeindex_roundtrip(self):</span>
        <span class="s5"># GH 23510</span>
        <span class="s5"># Ensure that a naive DatetimeIndex isn't converted to UTC</span>
        <span class="s1">dates = date_range(</span><span class="s3">&quot;2018-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;6H&quot;</span><span class="s1">)._with_freq(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">expected = DataFrame({</span><span class="s3">&quot;nums&quot;</span><span class="s1">: range(</span><span class="s4">5</span><span class="s1">)}</span><span class="s2">, </span><span class="s1">index=dates)</span>
        <span class="s2">assert </span><span class="s1">expected.to_sql(</span><span class="s3">&quot;foo_table&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index_label=</span><span class="s3">&quot;info_date&quot;</span><span class="s1">) == </span><span class="s4">5</span>
        <span class="s1">result = sql.read_sql_table(</span><span class="s3">&quot;foo_table&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index_col=</span><span class="s3">&quot;info_date&quot;</span><span class="s1">)</span>
        <span class="s5"># result index with gain a name from a set_index operation; expected</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">check_names=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_date_parsing(self):</span>
        <span class="s5"># No Parsing</span>
        <span class="s1">df = sql.read_sql_table(</span><span class="s3">&quot;types&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">expected_type = object </span><span class="s2">if </span><span class="s1">self.flavor == </span><span class="s3">&quot;sqlite&quot; </span><span class="s2">else </span><span class="s1">np.datetime64</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.DateCol.dtype.type</span><span class="s2">, </span><span class="s1">expected_type)</span>

        <span class="s1">df = sql.read_sql_table(</span><span class="s3">&quot;types&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">parse_dates=[</span><span class="s3">&quot;DateCol&quot;</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.DateCol.dtype.type</span><span class="s2">, </span><span class="s1">np.datetime64)</span>

        <span class="s1">df = sql.read_sql_table(</span>
            <span class="s3">&quot;types&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">parse_dates={</span><span class="s3">&quot;DateCol&quot;</span><span class="s1">: </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S&quot;</span><span class="s1">}</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.DateCol.dtype.type</span><span class="s2">, </span><span class="s1">np.datetime64)</span>

        <span class="s1">df = sql.read_sql_table(</span>
            <span class="s3">&quot;types&quot;</span><span class="s2">,</span>
            <span class="s1">self.conn</span><span class="s2">,</span>
            <span class="s1">parse_dates={</span><span class="s3">&quot;DateCol&quot;</span><span class="s1">: {</span><span class="s3">&quot;format&quot;</span><span class="s1">: </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S&quot;</span><span class="s1">}}</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.DateCol.dtype.type</span><span class="s2">, </span><span class="s1">np.datetime64)</span>

        <span class="s1">df = sql.read_sql_table(</span><span class="s3">&quot;types&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">parse_dates=[</span><span class="s3">&quot;IntDateCol&quot;</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.IntDateCol.dtype.type</span><span class="s2">, </span><span class="s1">np.datetime64)</span>

        <span class="s1">df = sql.read_sql_table(</span><span class="s3">&quot;types&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">parse_dates={</span><span class="s3">&quot;IntDateCol&quot;</span><span class="s1">: </span><span class="s3">&quot;s&quot;</span><span class="s1">})</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.IntDateCol.dtype.type</span><span class="s2">, </span><span class="s1">np.datetime64)</span>

        <span class="s1">df = sql.read_sql_table(</span>
            <span class="s3">&quot;types&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">parse_dates={</span><span class="s3">&quot;IntDateCol&quot;</span><span class="s1">: {</span><span class="s3">&quot;unit&quot;</span><span class="s1">: </span><span class="s3">&quot;s&quot;</span><span class="s1">}}</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.IntDateCol.dtype.type</span><span class="s2">, </span><span class="s1">np.datetime64)</span>

    <span class="s2">def </span><span class="s1">test_datetime(self):</span>
        <span class="s1">df = DataFrame(</span>
            <span class="s1">{</span><span class="s3">&quot;A&quot;</span><span class="s1">: date_range(</span><span class="s3">&quot;2013-01-01 09:00:00&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: np.arange(</span><span class="s4">3.0</span><span class="s1">)}</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;test_datetime&quot;</span><span class="s2">, </span><span class="s1">self.conn) == </span><span class="s4">3</span>

        <span class="s5"># with read_table -&gt; type information from schema used</span>
        <span class="s1">result = sql.read_sql_table(</span><span class="s3">&quot;test_datetime&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">result = result.drop(</span><span class="s3">&quot;index&quot;</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">df)</span>

        <span class="s5"># with read_sql -&gt; no type information -&gt; sqlite has no native</span>
        <span class="s1">result = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_datetime&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">result = result.drop(</span><span class="s3">&quot;index&quot;</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.flavor == </span><span class="s3">&quot;sqlite&quot;</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">isinstance(result.loc[</span><span class="s4">0</span><span class="s2">, </span><span class="s3">&quot;A&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">str)</span>
            <span class="s1">result[</span><span class="s3">&quot;A&quot;</span><span class="s1">] = to_datetime(result[</span><span class="s3">&quot;A&quot;</span><span class="s1">])</span>
            <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">df)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">df)</span>

    <span class="s2">def </span><span class="s1">test_datetime_NaT(self):</span>
        <span class="s1">df = DataFrame(</span>
            <span class="s1">{</span><span class="s3">&quot;A&quot;</span><span class="s1">: date_range(</span><span class="s3">&quot;2013-01-01 09:00:00&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: np.arange(</span><span class="s4">3.0</span><span class="s1">)}</span>
        <span class="s1">)</span>
        <span class="s1">df.loc[</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;A&quot;</span><span class="s1">] = np.nan</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;test_datetime&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">3</span>

        <span class="s5"># with read_table -&gt; type information from schema used</span>
        <span class="s1">result = sql.read_sql_table(</span><span class="s3">&quot;test_datetime&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">df)</span>

        <span class="s5"># with read_sql -&gt; no type information -&gt; sqlite has no native</span>
        <span class="s1">result = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_datetime&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s2">if </span><span class="s1">self.flavor == </span><span class="s3">&quot;sqlite&quot;</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">isinstance(result.loc[</span><span class="s4">0</span><span class="s2">, </span><span class="s3">&quot;A&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">str)</span>
            <span class="s1">result[</span><span class="s3">&quot;A&quot;</span><span class="s1">] = to_datetime(result[</span><span class="s3">&quot;A&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">df)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">df)</span>

    <span class="s2">def </span><span class="s1">test_datetime_date(self):</span>
        <span class="s5"># test support for datetime.date</span>
        <span class="s1">df = DataFrame([date(</span><span class="s4">2014</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">date(</span><span class="s4">2014</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;a&quot;</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;test_date&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">2</span>
        <span class="s1">res = read_sql_table(</span><span class="s3">&quot;test_date&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">result = res[</span><span class="s3">&quot;a&quot;</span><span class="s1">]</span>
        <span class="s1">expected = to_datetime(df[</span><span class="s3">&quot;a&quot;</span><span class="s1">])</span>
        <span class="s5"># comes back as datetime64</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_datetime_time(self):</span>
        <span class="s5"># test support for datetime.time</span>
        <span class="s1">df = DataFrame([time(</span><span class="s4">9</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">time(</span><span class="s4">9</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">30</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;a&quot;</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;test_time&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">2</span>
        <span class="s1">res = read_sql_table(</span><span class="s3">&quot;test_time&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">tm.assert_frame_equal(res</span><span class="s2">, </span><span class="s1">df)</span>

        <span class="s5"># GH8341</span>
        <span class="s5"># first, use the fallback to have the sqlite adapter put in place</span>
        <span class="s1">sqlite_conn = TestSQLiteFallback.connect()</span>
        <span class="s2">assert </span><span class="s1">sql.to_sql(df</span><span class="s2">, </span><span class="s3">&quot;test_time2&quot;</span><span class="s2">, </span><span class="s1">sqlite_conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">2</span>
        <span class="s1">res = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_time2&quot;</span><span class="s2">, </span><span class="s1">sqlite_conn)</span>
        <span class="s1">ref = df.applymap(</span><span class="s2">lambda </span><span class="s1">_: _.strftime(</span><span class="s3">&quot;%H:%M:%S.%f&quot;</span><span class="s1">))</span>
        <span class="s1">tm.assert_frame_equal(ref</span><span class="s2">, </span><span class="s1">res)  </span><span class="s5"># check if adapter is in place</span>
        <span class="s5"># then test if sqlalchemy is unaffected by the sqlite adapter</span>
        <span class="s2">assert </span><span class="s1">sql.to_sql(df</span><span class="s2">, </span><span class="s3">&quot;test_time3&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">2</span>
        <span class="s2">if </span><span class="s1">self.flavor == </span><span class="s3">&quot;sqlite&quot;</span><span class="s1">:</span>
            <span class="s1">res = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_time3&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
            <span class="s1">ref = df.applymap(</span><span class="s2">lambda </span><span class="s1">_: _.strftime(</span><span class="s3">&quot;%H:%M:%S.%f&quot;</span><span class="s1">))</span>
            <span class="s1">tm.assert_frame_equal(ref</span><span class="s2">, </span><span class="s1">res)</span>
        <span class="s1">res = sql.read_sql_table(</span><span class="s3">&quot;test_time3&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s2">, </span><span class="s1">res)</span>

    <span class="s2">def </span><span class="s1">test_mixed_dtype_insert(self):</span>
        <span class="s5"># see GH6509</span>
        <span class="s1">s1 = Series(</span><span class="s4">2 </span><span class="s1">** </span><span class="s4">25 </span><span class="s1">+ </span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype=np.int32)</span>
        <span class="s1">s2 = Series(</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">dtype=np.float32)</span>
        <span class="s1">df = DataFrame({</span><span class="s3">&quot;s1&quot;</span><span class="s1">: s1</span><span class="s2">, </span><span class="s3">&quot;s2&quot;</span><span class="s1">: s2})</span>

        <span class="s5"># write and read again</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;test_read_write&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">1</span>
        <span class="s1">df2 = sql.read_sql_table(</span><span class="s3">&quot;test_read_write&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s1">tm.assert_frame_equal(df</span><span class="s2">, </span><span class="s1">df2</span><span class="s2">, </span><span class="s1">check_dtype=</span><span class="s2">False, </span><span class="s1">check_exact=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_nan_numeric(self):</span>
        <span class="s5"># NaNs in numeric float column</span>
        <span class="s1">df = DataFrame({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: [</span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">5.6</span><span class="s1">]})</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;test_nan&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">3</span>

        <span class="s5"># with read_table</span>
        <span class="s1">result = sql.read_sql_table(</span><span class="s3">&quot;test_nan&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">df)</span>

        <span class="s5"># with read_sql</span>
        <span class="s1">result = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_nan&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">df)</span>

    <span class="s2">def </span><span class="s1">test_nan_fullcolumn(self):</span>
        <span class="s5"># full NaN column (numeric float column)</span>
        <span class="s1">df = DataFrame({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: [np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan]})</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;test_nan&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">3</span>

        <span class="s5"># with read_table</span>
        <span class="s1">result = sql.read_sql_table(</span><span class="s3">&quot;test_nan&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">df)</span>

        <span class="s5"># with read_sql -&gt; not type info from table -&gt; stays None</span>
        <span class="s1">df[</span><span class="s3">&quot;B&quot;</span><span class="s1">] = df[</span><span class="s3">&quot;B&quot;</span><span class="s1">].astype(</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span>
        <span class="s1">df[</span><span class="s3">&quot;B&quot;</span><span class="s1">] = </span><span class="s2">None</span>
        <span class="s1">result = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_nan&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">df)</span>

    <span class="s2">def </span><span class="s1">test_nan_string(self):</span>
        <span class="s5"># NaNs in string column</span>
        <span class="s1">df = DataFrame({</span><span class="s3">&quot;A&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">: [</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">np.nan]})</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;test_nan&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">3</span>

        <span class="s5"># NaNs are coming back as None</span>
        <span class="s1">df.loc[</span><span class="s4">2</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">] = </span><span class="s2">None</span>

        <span class="s5"># with read_table</span>
        <span class="s1">result = sql.read_sql_table(</span><span class="s3">&quot;test_nan&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">df)</span>

        <span class="s5"># with read_sql</span>
        <span class="s1">result = sql.read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_nan&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">df)</span>

    <span class="s2">def </span><span class="s1">_get_index_columns(self</span><span class="s2">, </span><span class="s1">tbl_name):</span>
        <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">inspect</span>

        <span class="s1">insp = inspect(self.conn)</span>

        <span class="s1">ixs = insp.get_indexes(tbl_name)</span>
        <span class="s1">ixs = [i[</span><span class="s3">&quot;column_names&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">ixs]</span>
        <span class="s2">return </span><span class="s1">ixs</span>

    <span class="s2">def </span><span class="s1">test_to_sql_save_index(self):</span>
        <span class="s1">self._to_sql_save_index()</span>

    <span class="s2">def </span><span class="s1">test_transactions(self):</span>
        <span class="s1">self._transaction_test()</span>

    <span class="s2">def </span><span class="s1">test_get_schema_create_table(self</span><span class="s2">, </span><span class="s1">test_frame3):</span>
        <span class="s5"># Use a dataframe without a bool column, since MySQL converts bool to</span>
        <span class="s5"># TINYINT (which read_sql_table returns as an int and causes a dtype</span>
        <span class="s5"># mismatch)</span>
        <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">text</span>
        <span class="s2">from </span><span class="s1">sqlalchemy.engine </span><span class="s2">import </span><span class="s1">Engine</span>

        <span class="s1">tbl = </span><span class="s3">&quot;test_get_schema_create_table&quot;</span>
        <span class="s1">create_sql = sql.get_schema(test_frame3</span><span class="s2">, </span><span class="s1">tbl</span><span class="s2">, </span><span class="s1">con=self.conn)</span>
        <span class="s1">blank_test_df = test_frame3.iloc[:</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s1">self.drop_table(tbl)</span>
        <span class="s1">create_sql = text(create_sql)</span>
        <span class="s2">if </span><span class="s1">isinstance(self.conn</span><span class="s2">, </span><span class="s1">Engine):</span>
            <span class="s2">with </span><span class="s1">self.conn.connect() </span><span class="s2">as </span><span class="s1">conn:</span>
                <span class="s2">with </span><span class="s1">conn.begin():</span>
                    <span class="s1">conn.execute(create_sql)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.conn.execute(create_sql)</span>
        <span class="s1">returned_df = sql.read_sql_table(tbl</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">tm.assert_frame_equal(returned_df</span><span class="s2">, </span><span class="s1">blank_test_df</span><span class="s2">, </span><span class="s1">check_index_type=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self.drop_table(tbl)</span>

    <span class="s2">def </span><span class="s1">test_dtype(self):</span>
        <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">(</span>
            <span class="s1">TEXT</span><span class="s2">,</span>
            <span class="s1">String</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">from </span><span class="s1">sqlalchemy.schema </span><span class="s2">import </span><span class="s1">MetaData</span>

        <span class="s1">cols = [</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">]</span>
        <span class="s1">data = [(</span><span class="s4">0.8</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.9</span><span class="s2">, None</span><span class="s1">)]</span>
        <span class="s1">df = DataFrame(data</span><span class="s2">, </span><span class="s1">columns=cols)</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;dtype_test&quot;</span><span class="s2">, </span><span class="s1">self.conn) == </span><span class="s4">2</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;dtype_test2&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">dtype={</span><span class="s3">&quot;B&quot;</span><span class="s1">: TEXT}) == </span><span class="s4">2</span>
        <span class="s1">meta = MetaData()</span>
        <span class="s1">meta.reflect(bind=self.conn)</span>
        <span class="s1">sqltype = meta.tables[</span><span class="s3">&quot;dtype_test2&quot;</span><span class="s1">].columns[</span><span class="s3">&quot;B&quot;</span><span class="s1">].type</span>
        <span class="s2">assert </span><span class="s1">isinstance(sqltype</span><span class="s2">, </span><span class="s1">TEXT)</span>
        <span class="s1">msg = </span><span class="s3">&quot;The type of B is not a SQLAlchemy type&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">df.to_sql(</span><span class="s3">&quot;error&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">dtype={</span><span class="s3">&quot;B&quot;</span><span class="s1">: str})</span>

        <span class="s5"># GH9083</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;dtype_test3&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">dtype={</span><span class="s3">&quot;B&quot;</span><span class="s1">: String(</span><span class="s4">10</span><span class="s1">)}) == </span><span class="s4">2</span>
        <span class="s1">meta.reflect(bind=self.conn)</span>
        <span class="s1">sqltype = meta.tables[</span><span class="s3">&quot;dtype_test3&quot;</span><span class="s1">].columns[</span><span class="s3">&quot;B&quot;</span><span class="s1">].type</span>
        <span class="s2">assert </span><span class="s1">isinstance(sqltype</span><span class="s2">, </span><span class="s1">String)</span>
        <span class="s2">assert </span><span class="s1">sqltype.length == </span><span class="s4">10</span>

        <span class="s5"># single dtype</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;single_dtype_test&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">dtype=TEXT) == </span><span class="s4">2</span>
        <span class="s1">meta.reflect(bind=self.conn)</span>
        <span class="s1">sqltypea = meta.tables[</span><span class="s3">&quot;single_dtype_test&quot;</span><span class="s1">].columns[</span><span class="s3">&quot;A&quot;</span><span class="s1">].type</span>
        <span class="s1">sqltypeb = meta.tables[</span><span class="s3">&quot;single_dtype_test&quot;</span><span class="s1">].columns[</span><span class="s3">&quot;B&quot;</span><span class="s1">].type</span>
        <span class="s2">assert </span><span class="s1">isinstance(sqltypea</span><span class="s2">, </span><span class="s1">TEXT)</span>
        <span class="s2">assert </span><span class="s1">isinstance(sqltypeb</span><span class="s2">, </span><span class="s1">TEXT)</span>

    <span class="s2">def </span><span class="s1">test_notna_dtype(self):</span>
        <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">(</span>
            <span class="s1">Boolean</span><span class="s2">,</span>
            <span class="s1">DateTime</span><span class="s2">,</span>
            <span class="s1">Float</span><span class="s2">,</span>
            <span class="s1">Integer</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">from </span><span class="s1">sqlalchemy.schema </span><span class="s2">import </span><span class="s1">MetaData</span>

        <span class="s1">cols = {</span>
            <span class="s3">&quot;Bool&quot;</span><span class="s1">: Series([</span><span class="s2">True, None</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s3">&quot;Date&quot;</span><span class="s1">: Series([datetime(</span><span class="s4">2012</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s3">&quot;Int&quot;</span><span class="s1">: Series([</span><span class="s4">1</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;Float&quot;</span><span class="s1">: Series([</span><span class="s4">1.1</span><span class="s2">, None</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s1">df = DataFrame(cols)</span>

        <span class="s1">tbl = </span><span class="s3">&quot;notna_dtype_test&quot;</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(tbl</span><span class="s2">, </span><span class="s1">self.conn) == </span><span class="s4">2</span>
        <span class="s1">_ = sql.read_sql_table(tbl</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">meta = MetaData()</span>
        <span class="s1">meta.reflect(bind=self.conn)</span>
        <span class="s1">my_type = Integer </span><span class="s2">if </span><span class="s1">self.flavor == </span><span class="s3">&quot;mysql&quot; </span><span class="s2">else </span><span class="s1">Boolean</span>
        <span class="s1">col_dict = meta.tables[tbl].columns</span>
        <span class="s2">assert </span><span class="s1">isinstance(col_dict[</span><span class="s3">&quot;Bool&quot;</span><span class="s1">].type</span><span class="s2">, </span><span class="s1">my_type)</span>
        <span class="s2">assert </span><span class="s1">isinstance(col_dict[</span><span class="s3">&quot;Date&quot;</span><span class="s1">].type</span><span class="s2">, </span><span class="s1">DateTime)</span>
        <span class="s2">assert </span><span class="s1">isinstance(col_dict[</span><span class="s3">&quot;Int&quot;</span><span class="s1">].type</span><span class="s2">, </span><span class="s1">Integer)</span>
        <span class="s2">assert </span><span class="s1">isinstance(col_dict[</span><span class="s3">&quot;Float&quot;</span><span class="s1">].type</span><span class="s2">, </span><span class="s1">Float)</span>

    <span class="s2">def </span><span class="s1">test_double_precision(self):</span>
        <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">(</span>
            <span class="s1">BigInteger</span><span class="s2">,</span>
            <span class="s1">Float</span><span class="s2">,</span>
            <span class="s1">Integer</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">from </span><span class="s1">sqlalchemy.schema </span><span class="s2">import </span><span class="s1">MetaData</span>

        <span class="s1">V = </span><span class="s4">1.23456789101112131415</span>

        <span class="s1">df = DataFrame(</span>
            <span class="s1">{</span>
                <span class="s3">&quot;f32&quot;</span><span class="s1">: Series([V]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;float32&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;f64&quot;</span><span class="s1">: Series([V]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;float64&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;f64_as_f32&quot;</span><span class="s1">: Series([V]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;float64&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;i32&quot;</span><span class="s1">: Series([</span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;int32&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s3">&quot;i64&quot;</span><span class="s1">: Series([</span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">df.to_sql(</span>
                <span class="s3">&quot;test_dtypes&quot;</span><span class="s2">,</span>
                <span class="s1">self.conn</span><span class="s2">,</span>
                <span class="s1">index=</span><span class="s2">False,</span>
                <span class="s1">if_exists=</span><span class="s3">&quot;replace&quot;</span><span class="s2">,</span>
                <span class="s1">dtype={</span><span class="s3">&quot;f64_as_f32&quot;</span><span class="s1">: Float(precision=</span><span class="s4">23</span><span class="s1">)}</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">== </span><span class="s4">1</span>
        <span class="s1">)</span>
        <span class="s1">res = sql.read_sql_table(</span><span class="s3">&quot;test_dtypes&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s5"># check precision of float64</span>
        <span class="s2">assert </span><span class="s1">np.round(df[</span><span class="s3">&quot;f64&quot;</span><span class="s1">].iloc[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">14</span><span class="s1">) == np.round(res[</span><span class="s3">&quot;f64&quot;</span><span class="s1">].iloc[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">14</span><span class="s1">)</span>

        <span class="s5"># check sql types</span>
        <span class="s1">meta = MetaData()</span>
        <span class="s1">meta.reflect(bind=self.conn)</span>
        <span class="s1">col_dict = meta.tables[</span><span class="s3">&quot;test_dtypes&quot;</span><span class="s1">].columns</span>
        <span class="s2">assert </span><span class="s1">str(col_dict[</span><span class="s3">&quot;f32&quot;</span><span class="s1">].type) == str(col_dict[</span><span class="s3">&quot;f64_as_f32&quot;</span><span class="s1">].type)</span>
        <span class="s2">assert </span><span class="s1">isinstance(col_dict[</span><span class="s3">&quot;f32&quot;</span><span class="s1">].type</span><span class="s2">, </span><span class="s1">Float)</span>
        <span class="s2">assert </span><span class="s1">isinstance(col_dict[</span><span class="s3">&quot;f64&quot;</span><span class="s1">].type</span><span class="s2">, </span><span class="s1">Float)</span>
        <span class="s2">assert </span><span class="s1">isinstance(col_dict[</span><span class="s3">&quot;i32&quot;</span><span class="s1">].type</span><span class="s2">, </span><span class="s1">Integer)</span>
        <span class="s2">assert </span><span class="s1">isinstance(col_dict[</span><span class="s3">&quot;i64&quot;</span><span class="s1">].type</span><span class="s2">, </span><span class="s1">BigInteger)</span>

    <span class="s2">def </span><span class="s1">test_connectable_issue_example(self):</span>
        <span class="s5"># This tests the example raised in issue</span>
        <span class="s5"># https://github.com/pandas-dev/pandas/issues/10104</span>
        <span class="s2">from </span><span class="s1">sqlalchemy.engine </span><span class="s2">import </span><span class="s1">Engine</span>

        <span class="s2">def </span><span class="s1">foo(connection):</span>
            <span class="s1">query = </span><span class="s3">&quot;SELECT test_foo_data FROM test_foo_data&quot;</span>
            <span class="s2">return </span><span class="s1">sql.read_sql_query(query</span><span class="s2">, </span><span class="s1">con=connection)</span>

        <span class="s2">def </span><span class="s1">bar(connection</span><span class="s2">, </span><span class="s1">data):</span>
            <span class="s1">data.to_sql(name=</span><span class="s3">&quot;test_foo_data&quot;</span><span class="s2">, </span><span class="s1">con=connection</span><span class="s2">, </span><span class="s1">if_exists=</span><span class="s3">&quot;append&quot;</span><span class="s1">)</span>

        <span class="s2">def </span><span class="s1">baz(conn):</span>
            <span class="s2">if </span><span class="s1">_gt14():</span>
                <span class="s5"># https://github.com/sqlalchemy/sqlalchemy/commit/</span>
                <span class="s5">#  00b5c10846e800304caa86549ab9da373b42fa5d#r48323973</span>
                <span class="s1">foo_data = foo(conn)</span>
                <span class="s1">bar(conn</span><span class="s2">, </span><span class="s1">foo_data)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">foo_data = conn.run_callable(foo)</span>
                <span class="s1">conn.run_callable(bar</span><span class="s2">, </span><span class="s1">foo_data)</span>

        <span class="s2">def </span><span class="s1">main(connectable):</span>
            <span class="s2">if </span><span class="s1">isinstance(connectable</span><span class="s2">, </span><span class="s1">Engine):</span>
                <span class="s2">with </span><span class="s1">connectable.connect() </span><span class="s2">as </span><span class="s1">conn:</span>
                    <span class="s2">with </span><span class="s1">conn.begin():</span>
                        <span class="s1">baz(conn)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">baz(connectable)</span>

        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">DataFrame({</span><span class="s3">&quot;test_foo_data&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]}).to_sql(</span><span class="s3">&quot;test_foo_data&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
            <span class="s1">== </span><span class="s4">3</span>
        <span class="s1">)</span>
        <span class="s1">main(self.conn)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;input&quot;</span><span class="s2">,</span>
        <span class="s1">[{</span><span class="s3">&quot;foo&quot;</span><span class="s1">: [np.inf]}</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;foo&quot;</span><span class="s1">: [-np.inf]}</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;foo&quot;</span><span class="s1">: [-np.inf]</span><span class="s2">, </span><span class="s3">&quot;infe0&quot;</span><span class="s1">: [</span><span class="s3">&quot;bar&quot;</span><span class="s1">]}]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_sql_with_negative_npinf(self</span><span class="s2">, </span><span class="s1">input</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s5"># GH 34431</span>

        <span class="s1">df = DataFrame(input)</span>

        <span class="s2">if </span><span class="s1">self.flavor == </span><span class="s3">&quot;mysql&quot;</span><span class="s1">:</span>
            <span class="s5"># GH 36465</span>
            <span class="s5"># The input {&quot;foo&quot;: [-np.inf], &quot;infe0&quot;: [&quot;bar&quot;]} does not raise any error</span>
            <span class="s5"># for pymysql version &gt;= 0.10</span>
            <span class="s5"># TODO(GH#36465): remove this version check after GH 36465 is fixed</span>
            <span class="s2">import </span><span class="s1">pymysql</span>

            <span class="s2">if </span><span class="s1">pymysql.VERSION[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">3</span><span class="s1">] &gt;= (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) </span><span class="s2">and </span><span class="s3">&quot;infe0&quot; </span><span class="s2">in </span><span class="s1">df.columns:</span>
                <span class="s1">mark = pytest.mark.xfail(reason=</span><span class="s3">&quot;GH 36465&quot;</span><span class="s1">)</span>
                <span class="s1">request.node.add_marker(mark)</span>

            <span class="s1">msg = </span><span class="s3">&quot;inf cannot be used with MySQL&quot;</span>
            <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">df.to_sql(</span><span class="s3">&quot;foobar&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;foobar&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">1</span>
            <span class="s1">res = sql.read_sql_table(</span><span class="s3">&quot;foobar&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
            <span class="s1">tm.assert_equal(df</span><span class="s2">, </span><span class="s1">res)</span>

    <span class="s2">def </span><span class="s1">test_temporary_table(self):</span>
        <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">(</span>
            <span class="s1">Column</span><span class="s2">,</span>
            <span class="s1">Integer</span><span class="s2">,</span>
            <span class="s1">Unicode</span><span class="s2">,</span>
            <span class="s1">select</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">from </span><span class="s1">sqlalchemy.orm </span><span class="s2">import </span><span class="s1">(</span>
            <span class="s1">Session</span><span class="s2">,</span>
            <span class="s1">sessionmaker</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">_gt14():</span>
            <span class="s2">from </span><span class="s1">sqlalchemy.orm </span><span class="s2">import </span><span class="s1">declarative_base</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">sqlalchemy.ext.declarative </span><span class="s2">import </span><span class="s1">declarative_base</span>

        <span class="s1">test_data = </span><span class="s3">&quot;Hello, World!&quot;</span>
        <span class="s1">expected = DataFrame({</span><span class="s3">&quot;spam&quot;</span><span class="s1">: [test_data]})</span>
        <span class="s1">Base = declarative_base()</span>

        <span class="s2">class </span><span class="s1">Temporary(Base):</span>
            <span class="s1">__tablename__ = </span><span class="s3">&quot;temp_test&quot;</span>
            <span class="s1">__table_args__ = {</span><span class="s3">&quot;prefixes&quot;</span><span class="s1">: [</span><span class="s3">&quot;TEMPORARY&quot;</span><span class="s1">]}</span>
            <span class="s1">id = Column(Integer</span><span class="s2">, </span><span class="s1">primary_key=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">spam = Column(Unicode(</span><span class="s4">30</span><span class="s1">)</span><span class="s2">, </span><span class="s1">nullable=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">_gt14():</span>
            <span class="s2">with </span><span class="s1">Session(self.conn) </span><span class="s2">as </span><span class="s1">session:</span>
                <span class="s2">with </span><span class="s1">session.begin():</span>
                    <span class="s1">conn = session.connection()</span>
                    <span class="s1">Temporary.__table__.create(conn)</span>
                    <span class="s1">session.add(Temporary(spam=test_data))</span>
                    <span class="s1">session.flush()</span>
                    <span class="s1">df = sql.read_sql_query(sql=select(Temporary.spam)</span><span class="s2">, </span><span class="s1">con=conn)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">Session = sessionmaker()</span>
            <span class="s1">session = Session(bind=self.conn)</span>
            <span class="s2">with </span><span class="s1">session.transaction:</span>
                <span class="s1">conn = session.connection()</span>
                <span class="s1">Temporary.__table__.create(conn)</span>
                <span class="s1">session.add(Temporary(spam=test_data))</span>
                <span class="s1">session.flush()</span>
                <span class="s1">df = sql.read_sql_query(sql=select([Temporary.spam])</span><span class="s2">, </span><span class="s1">con=conn)</span>

        <span class="s1">tm.assert_frame_equal(df</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s5"># -- SQL Engine tests (in the base class for now)</span>
    <span class="s2">def </span><span class="s1">test_invalid_engine(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s1">msg = </span><span class="s3">&quot;engine must be one of 'auto', 'sqlalchemy'&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">self._to_sql_with_sql_engine(test_frame1</span><span class="s2">, </span><span class="s3">&quot;bad_engine&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_options_sqlalchemy(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s5"># use the set option</span>
        <span class="s2">with </span><span class="s1">pd.option_context(</span><span class="s3">&quot;io.sql.engine&quot;</span><span class="s2">, </span><span class="s3">&quot;sqlalchemy&quot;</span><span class="s1">):</span>
            <span class="s1">self._to_sql_with_sql_engine(test_frame1)</span>

    <span class="s2">def </span><span class="s1">test_options_auto(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s5"># use the set option</span>
        <span class="s2">with </span><span class="s1">pd.option_context(</span><span class="s3">&quot;io.sql.engine&quot;</span><span class="s2">, </span><span class="s3">&quot;auto&quot;</span><span class="s1">):</span>
            <span class="s1">self._to_sql_with_sql_engine(test_frame1)</span>

    <span class="s2">def </span><span class="s1">test_options_get_engine(self):</span>
        <span class="s2">assert </span><span class="s1">isinstance(get_engine(</span><span class="s3">&quot;sqlalchemy&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">SQLAlchemyEngine)</span>

        <span class="s2">with </span><span class="s1">pd.option_context(</span><span class="s3">&quot;io.sql.engine&quot;</span><span class="s2">, </span><span class="s3">&quot;sqlalchemy&quot;</span><span class="s1">):</span>
            <span class="s2">assert </span><span class="s1">isinstance(get_engine(</span><span class="s3">&quot;auto&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">SQLAlchemyEngine)</span>
            <span class="s2">assert </span><span class="s1">isinstance(get_engine(</span><span class="s3">&quot;sqlalchemy&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">SQLAlchemyEngine)</span>

        <span class="s2">with </span><span class="s1">pd.option_context(</span><span class="s3">&quot;io.sql.engine&quot;</span><span class="s2">, </span><span class="s3">&quot;auto&quot;</span><span class="s1">):</span>
            <span class="s2">assert </span><span class="s1">isinstance(get_engine(</span><span class="s3">&quot;auto&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">SQLAlchemyEngine)</span>
            <span class="s2">assert </span><span class="s1">isinstance(get_engine(</span><span class="s3">&quot;sqlalchemy&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">SQLAlchemyEngine)</span>

    <span class="s2">def </span><span class="s1">test_get_engine_auto_error_message(self):</span>
        <span class="s5"># Expect different error messages from get_engine(engine=&quot;auto&quot;)</span>
        <span class="s5"># if engines aren't installed vs. are installed but bad version</span>
        <span class="s2">pass</span>
        <span class="s5"># TODO(GH#36893) fill this in when we add more engines</span>


<span class="s2">class </span><span class="s1">_TestSQLAlchemyConn(_EngineToConnMixin</span><span class="s2">, </span><span class="s1">_TestSQLAlchemy):</span>
    <span class="s2">def </span><span class="s1">test_transactions(self):</span>
        <span class="s1">pytest.skip(</span><span class="s3">&quot;Nested transactions rollbacks don't work with Pandas&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">_TestSQLiteAlchemy:</span>
    <span class="s0">&quot;&quot;&quot; 
    Test the sqlalchemy backend against an in-memory sqlite database. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">flavor = </span><span class="s3">&quot;sqlite&quot;</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">connect(cls):</span>
        <span class="s2">return </span><span class="s1">sqlalchemy.create_engine(</span><span class="s3">&quot;sqlite:///:memory:&quot;</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_driver(cls):</span>
        <span class="s5"># sqlite3 is built-in</span>
        <span class="s1">cls.driver = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">test_default_type_conversion(self):</span>
        <span class="s1">df = sql.read_sql_table(</span><span class="s3">&quot;types&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s2">assert </span><span class="s1">issubclass(df.FloatCol.dtype.type</span><span class="s2">, </span><span class="s1">np.floating)</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.IntCol.dtype.type</span><span class="s2">, </span><span class="s1">np.integer)</span>

        <span class="s5"># sqlite has no boolean type, so integer type is returned</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.BoolCol.dtype.type</span><span class="s2">, </span><span class="s1">np.integer)</span>

        <span class="s5"># Int column with NA values stays as float</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.IntColWithNull.dtype.type</span><span class="s2">, </span><span class="s1">np.floating)</span>

        <span class="s5"># Non-native Bool column with NA values stays as float</span>
        <span class="s2">assert </span><span class="s1">issubclass(df.BoolColWithNull.dtype.type</span><span class="s2">, </span><span class="s1">np.floating)</span>

    <span class="s2">def </span><span class="s1">test_default_date_load(self):</span>
        <span class="s1">df = sql.read_sql_table(</span><span class="s3">&quot;types&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s5"># IMPORTANT - sqlite has no native date type, so shouldn't parse, but</span>
        <span class="s2">assert not </span><span class="s1">issubclass(df.DateCol.dtype.type</span><span class="s2">, </span><span class="s1">np.datetime64)</span>

    <span class="s2">def </span><span class="s1">test_bigint_warning(self):</span>
        <span class="s5"># test no warning for BIGINT (to support int64) is raised (GH7433)</span>
        <span class="s1">df = DataFrame({</span><span class="s3">&quot;a&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]}</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;test_bigintwarning&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">2</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s1">sql.read_sql_table(</span><span class="s3">&quot;test_bigintwarning&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

    <span class="s2">def </span><span class="s1">test_row_object_is_named_tuple(self):</span>
        <span class="s5"># GH 40682</span>
        <span class="s5"># Test for the is_named_tuple() function</span>
        <span class="s5"># Placed here due to its usage of sqlalchemy</span>

        <span class="s2">from </span><span class="s1">sqlalchemy </span><span class="s2">import </span><span class="s1">(</span>
            <span class="s1">Column</span><span class="s2">,</span>
            <span class="s1">Integer</span><span class="s2">,</span>
            <span class="s1">String</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">from </span><span class="s1">sqlalchemy.orm </span><span class="s2">import </span><span class="s1">sessionmaker</span>

        <span class="s2">if </span><span class="s1">_gt14():</span>
            <span class="s2">from </span><span class="s1">sqlalchemy.orm </span><span class="s2">import </span><span class="s1">declarative_base</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">sqlalchemy.ext.declarative </span><span class="s2">import </span><span class="s1">declarative_base</span>

        <span class="s1">BaseModel = declarative_base()</span>

        <span class="s2">class </span><span class="s1">Test(BaseModel):</span>
            <span class="s1">__tablename__ = </span><span class="s3">&quot;test_frame&quot;</span>
            <span class="s1">id = Column(Integer</span><span class="s2">, </span><span class="s1">primary_key=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">foo = Column(String(</span><span class="s4">50</span><span class="s1">))</span>

        <span class="s1">BaseModel.metadata.create_all(self.conn)</span>
        <span class="s1">Session = sessionmaker(bind=self.conn)</span>
        <span class="s1">session = Session()</span>

        <span class="s1">df = DataFrame({</span><span class="s3">&quot;id&quot;</span><span class="s1">: [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;foo&quot;</span><span class="s1">: [</span><span class="s3">&quot;hello&quot;</span><span class="s2">, </span><span class="s3">&quot;world&quot;</span><span class="s1">]})</span>
        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">df.to_sql(</span><span class="s3">&quot;test_frame&quot;</span><span class="s2">, </span><span class="s1">con=self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False, </span><span class="s1">if_exists=</span><span class="s3">&quot;replace&quot;</span><span class="s1">)</span>
            <span class="s1">== </span><span class="s4">2</span>
        <span class="s1">)</span>

        <span class="s1">session.commit()</span>
        <span class="s1">foo = session.query(Test.id</span><span class="s2">, </span><span class="s1">Test.foo)</span>
        <span class="s1">df = DataFrame(foo)</span>
        <span class="s1">session.close()</span>

        <span class="s2">assert </span><span class="s1">list(df.columns) == [</span><span class="s3">&quot;id&quot;</span><span class="s2">, </span><span class="s3">&quot;foo&quot;</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">_TestMySQLAlchemy:</span>
    <span class="s0">&quot;&quot;&quot; 
    Test the sqlalchemy backend against an MySQL database. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">flavor = </span><span class="s3">&quot;mysql&quot;</span>
    <span class="s1">port = </span><span class="s4">3306</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">connect(cls):</span>
        <span class="s2">return </span><span class="s1">sqlalchemy.create_engine(</span>
            <span class="s3">f&quot;mysql+</span><span class="s2">{</span><span class="s1">cls.driver</span><span class="s2">}</span><span class="s3">://root@localhost:</span><span class="s2">{</span><span class="s1">cls.port</span><span class="s2">}</span><span class="s3">/pandas&quot;</span><span class="s2">,</span>
            <span class="s1">connect_args=cls.connect_args</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_driver(cls):</span>
        <span class="s1">pymysql = pytest.importorskip(</span><span class="s3">&quot;pymysql&quot;</span><span class="s1">)</span>
        <span class="s1">cls.driver = </span><span class="s3">&quot;pymysql&quot;</span>
        <span class="s1">cls.connect_args = {</span><span class="s3">&quot;client_flag&quot;</span><span class="s1">: pymysql.constants.CLIENT.MULTI_STATEMENTS}</span>

    <span class="s2">def </span><span class="s1">test_default_type_conversion(self):</span>
        <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">_TestPostgreSQLAlchemy:</span>
    <span class="s0">&quot;&quot;&quot; 
    Test the sqlalchemy backend against an PostgreSQL database. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">flavor = </span><span class="s3">&quot;postgresql&quot;</span>
    <span class="s1">port = </span><span class="s4">5432</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">connect(cls):</span>
        <span class="s2">return </span><span class="s1">sqlalchemy.create_engine(</span>
            <span class="s3">f&quot;postgresql+</span><span class="s2">{</span><span class="s1">cls.driver</span><span class="s2">}</span><span class="s3">://postgres:postgres@localhost:</span><span class="s2">{</span><span class="s1">cls.port</span><span class="s2">}</span><span class="s3">/pandas&quot;</span>
        <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_driver(cls):</span>
        <span class="s1">pytest.importorskip(</span><span class="s3">&quot;psycopg2&quot;</span><span class="s1">)</span>
        <span class="s1">cls.driver = </span><span class="s3">&quot;psycopg2&quot;</span>

    <span class="s2">def </span><span class="s1">test_schema_support(self):</span>
        <span class="s2">from </span><span class="s1">sqlalchemy.engine </span><span class="s2">import </span><span class="s1">Engine</span>

        <span class="s5"># only test this for postgresql (schema's not supported in</span>
        <span class="s5"># mysql/sqlite)</span>
        <span class="s1">df = DataFrame({</span><span class="s3">&quot;col1&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;col2&quot;</span><span class="s1">: [</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;col3&quot;</span><span class="s1">: [</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;n&quot;</span><span class="s1">]})</span>

        <span class="s5"># create a schema</span>
        <span class="s1">self.conn.execute(</span><span class="s3">&quot;DROP SCHEMA IF EXISTS other CASCADE;&quot;</span><span class="s1">)</span>
        <span class="s1">self.conn.execute(</span><span class="s3">&quot;CREATE SCHEMA other;&quot;</span><span class="s1">)</span>

        <span class="s5"># write dataframe to different schema's</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;test_schema_public&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">2</span>
        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">df.to_sql(</span>
                <span class="s3">&quot;test_schema_public_explicit&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False, </span><span class="s1">schema=</span><span class="s3">&quot;public&quot;</span>
            <span class="s1">)</span>
            <span class="s1">== </span><span class="s4">2</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">df.to_sql(</span><span class="s3">&quot;test_schema_other&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False, </span><span class="s1">schema=</span><span class="s3">&quot;other&quot;</span><span class="s1">) == </span><span class="s4">2</span>
        <span class="s1">)</span>

        <span class="s5"># read dataframes back in</span>
        <span class="s1">res1 = sql.read_sql_table(</span><span class="s3">&quot;test_schema_public&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s2">, </span><span class="s1">res1)</span>
        <span class="s1">res2 = sql.read_sql_table(</span><span class="s3">&quot;test_schema_public_explicit&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s2">, </span><span class="s1">res2)</span>
        <span class="s1">res3 = sql.read_sql_table(</span>
            <span class="s3">&quot;test_schema_public_explicit&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">schema=</span><span class="s3">&quot;public&quot;</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s2">, </span><span class="s1">res3)</span>
        <span class="s1">res4 = sql.read_sql_table(</span><span class="s3">&quot;test_schema_other&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">schema=</span><span class="s3">&quot;other&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(df</span><span class="s2">, </span><span class="s1">res4)</span>
        <span class="s1">msg = </span><span class="s3">&quot;Table test_schema_other not found&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">sql.read_sql_table(</span><span class="s3">&quot;test_schema_other&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">schema=</span><span class="s3">&quot;public&quot;</span><span class="s1">)</span>

        <span class="s5"># different if_exists options</span>

        <span class="s5"># create a schema</span>
        <span class="s1">self.conn.execute(</span><span class="s3">&quot;DROP SCHEMA IF EXISTS other CASCADE;&quot;</span><span class="s1">)</span>
        <span class="s1">self.conn.execute(</span><span class="s3">&quot;CREATE SCHEMA other;&quot;</span><span class="s1">)</span>

        <span class="s5"># write dataframe with different if_exists options</span>
        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">df.to_sql(</span><span class="s3">&quot;test_schema_other&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">schema=</span><span class="s3">&quot;other&quot;</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">2</span>
        <span class="s1">)</span>
        <span class="s1">df.to_sql(</span>
            <span class="s3">&quot;test_schema_other&quot;</span><span class="s2">,</span>
            <span class="s1">self.conn</span><span class="s2">,</span>
            <span class="s1">schema=</span><span class="s3">&quot;other&quot;</span><span class="s2">,</span>
            <span class="s1">index=</span><span class="s2">False,</span>
            <span class="s1">if_exists=</span><span class="s3">&quot;replace&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">df.to_sql(</span>
                <span class="s3">&quot;test_schema_other&quot;</span><span class="s2">,</span>
                <span class="s1">self.conn</span><span class="s2">,</span>
                <span class="s1">schema=</span><span class="s3">&quot;other&quot;</span><span class="s2">,</span>
                <span class="s1">index=</span><span class="s2">False,</span>
                <span class="s1">if_exists=</span><span class="s3">&quot;append&quot;</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">== </span><span class="s4">2</span>
        <span class="s1">)</span>
        <span class="s1">res = sql.read_sql_table(</span><span class="s3">&quot;test_schema_other&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">schema=</span><span class="s3">&quot;other&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_frame_equal(concat([df</span><span class="s2">, </span><span class="s1">df]</span><span class="s2">, </span><span class="s1">ignore_index=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">, </span><span class="s1">res)</span>

        <span class="s5"># specifying schema in user-provided meta</span>

        <span class="s5"># The schema won't be applied on another Connection</span>
        <span class="s5"># because of transactional schemas</span>
        <span class="s2">if </span><span class="s1">isinstance(self.conn</span><span class="s2">, </span><span class="s1">Engine):</span>
            <span class="s1">engine2 = self.connect()</span>
            <span class="s1">pdsql = sql.SQLDatabase(engine2</span><span class="s2">, </span><span class="s1">schema=</span><span class="s3">&quot;other&quot;</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">pdsql.to_sql(df</span><span class="s2">, </span><span class="s3">&quot;test_schema_other2&quot;</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">2</span>
            <span class="s2">assert </span><span class="s1">(</span>
                <span class="s1">pdsql.to_sql(df</span><span class="s2">, </span><span class="s3">&quot;test_schema_other2&quot;</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False, </span><span class="s1">if_exists=</span><span class="s3">&quot;replace&quot;</span><span class="s1">)</span>
                <span class="s1">== </span><span class="s4">2</span>
            <span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">(</span>
                <span class="s1">pdsql.to_sql(df</span><span class="s2">, </span><span class="s3">&quot;test_schema_other2&quot;</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False, </span><span class="s1">if_exists=</span><span class="s3">&quot;append&quot;</span><span class="s1">)</span>
                <span class="s1">== </span><span class="s4">2</span>
            <span class="s1">)</span>
            <span class="s1">res1 = sql.read_sql_table(</span><span class="s3">&quot;test_schema_other2&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">schema=</span><span class="s3">&quot;other&quot;</span><span class="s1">)</span>
            <span class="s1">res2 = pdsql.read_table(</span><span class="s3">&quot;test_schema_other2&quot;</span><span class="s1">)</span>
            <span class="s1">tm.assert_frame_equal(res1</span><span class="s2">, </span><span class="s1">res2)</span>


<span class="s1">@pytest.mark.single</span>
<span class="s1">@pytest.mark.db</span>
<span class="s2">class </span><span class="s1">TestMySQLAlchemy(_TestMySQLAlchemy</span><span class="s2">, </span><span class="s1">_TestSQLAlchemy):</span>
    <span class="s2">pass</span>


<span class="s1">@pytest.mark.single</span>
<span class="s1">@pytest.mark.db</span>
<span class="s2">class </span><span class="s1">TestMySQLAlchemyConn(_TestMySQLAlchemy</span><span class="s2">, </span><span class="s1">_TestSQLAlchemyConn):</span>
    <span class="s2">pass</span>


<span class="s1">@pytest.mark.single</span>
<span class="s1">@pytest.mark.db</span>
<span class="s2">class </span><span class="s1">TestPostgreSQLAlchemy(_TestPostgreSQLAlchemy</span><span class="s2">, </span><span class="s1">_TestSQLAlchemy):</span>
    <span class="s2">pass</span>


<span class="s1">@pytest.mark.single</span>
<span class="s1">@pytest.mark.db</span>
<span class="s2">class </span><span class="s1">TestPostgreSQLAlchemyConn(_TestPostgreSQLAlchemy</span><span class="s2">, </span><span class="s1">_TestSQLAlchemyConn):</span>
    <span class="s2">pass</span>


<span class="s1">@pytest.mark.single</span>
<span class="s2">class </span><span class="s1">TestSQLiteAlchemy(_TestSQLiteAlchemy</span><span class="s2">, </span><span class="s1">_TestSQLAlchemy):</span>
    <span class="s2">pass</span>


<span class="s1">@pytest.mark.single</span>
<span class="s2">class </span><span class="s1">TestSQLiteAlchemyConn(_TestSQLiteAlchemy</span><span class="s2">, </span><span class="s1">_TestSQLAlchemyConn):</span>
    <span class="s2">pass</span>


<span class="s5"># -----------------------------------------------------------------------------</span>
<span class="s5"># -- Test Sqlite / MySQL fallback</span>


<span class="s1">@pytest.mark.single</span>
<span class="s2">class </span><span class="s1">TestSQLiteFallback(SQLiteMixIn</span><span class="s2">, </span><span class="s1">PandasSQLTest):</span>
    <span class="s0">&quot;&quot;&quot; 
    Test the fallback mode against an in-memory sqlite database. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">flavor = </span><span class="s3">&quot;sqlite&quot;</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">connect(cls):</span>
        <span class="s2">return </span><span class="s1">sqlite3.connect(</span><span class="s3">&quot;:memory:&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">setup_connect(self):</span>
        <span class="s1">self.conn = self.connect()</span>

    <span class="s1">@pytest.fixture(autouse=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">setup_method(self</span><span class="s2">, </span><span class="s1">load_iris_data</span><span class="s2">, </span><span class="s1">load_types_data):</span>
        <span class="s1">self.pandasSQL = sql.SQLiteDatabase(self.conn)</span>

    <span class="s2">def </span><span class="s1">test_read_sql_parameter(self):</span>
        <span class="s1">self._read_sql_iris_parameter()</span>

    <span class="s2">def </span><span class="s1">test_read_sql_named_parameter(self):</span>
        <span class="s1">self._read_sql_iris_named_parameter()</span>

    <span class="s2">def </span><span class="s1">test_to_sql_empty(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s1">self._to_sql_empty(test_frame1)</span>

    <span class="s2">def </span><span class="s1">test_create_and_drop_table(self):</span>
        <span class="s1">temp_frame = DataFrame(</span>
            <span class="s1">{</span><span class="s3">&quot;one&quot;</span><span class="s1">: [</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">4.0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;two&quot;</span><span class="s1">: [</span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]}</span>
        <span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">self.pandasSQL.to_sql(temp_frame</span><span class="s2">, </span><span class="s3">&quot;drop_test_frame&quot;</span><span class="s1">) == </span><span class="s4">4</span>

        <span class="s2">assert </span><span class="s1">self.pandasSQL.has_table(</span><span class="s3">&quot;drop_test_frame&quot;</span><span class="s1">)</span>

        <span class="s1">self.pandasSQL.drop_table(</span><span class="s3">&quot;drop_test_frame&quot;</span><span class="s1">)</span>

        <span class="s2">assert not </span><span class="s1">self.pandasSQL.has_table(</span><span class="s3">&quot;drop_test_frame&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_roundtrip(self</span><span class="s2">, </span><span class="s1">test_frame1):</span>
        <span class="s1">self._roundtrip(test_frame1)</span>

    <span class="s2">def </span><span class="s1">test_execute_sql(self):</span>
        <span class="s1">self._execute_sql()</span>

    <span class="s2">def </span><span class="s1">test_datetime_date(self):</span>
        <span class="s5"># test support for datetime.date</span>
        <span class="s1">df = DataFrame([date(</span><span class="s4">2014</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">date(</span><span class="s4">2014</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;a&quot;</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;test_date&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">2</span>
        <span class="s1">res = read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_date&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s2">if </span><span class="s1">self.flavor == </span><span class="s3">&quot;sqlite&quot;</span><span class="s1">:</span>
            <span class="s5"># comes back as strings</span>
            <span class="s1">tm.assert_frame_equal(res</span><span class="s2">, </span><span class="s1">df.astype(str))</span>
        <span class="s2">elif </span><span class="s1">self.flavor == </span><span class="s3">&quot;mysql&quot;</span><span class="s1">:</span>
            <span class="s1">tm.assert_frame_equal(res</span><span class="s2">, </span><span class="s1">df)</span>

    <span class="s2">def </span><span class="s1">test_datetime_time(self):</span>
        <span class="s5"># test support for datetime.time, GH #8341</span>
        <span class="s1">df = DataFrame([time(</span><span class="s4">9</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">time(</span><span class="s4">9</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">30</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;a&quot;</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;test_time&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">2</span>
        <span class="s1">res = read_sql_query(</span><span class="s3">&quot;SELECT * FROM test_time&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s2">if </span><span class="s1">self.flavor == </span><span class="s3">&quot;sqlite&quot;</span><span class="s1">:</span>
            <span class="s5"># comes back as strings</span>
            <span class="s1">expected = df.applymap(</span><span class="s2">lambda </span><span class="s1">_: _.strftime(</span><span class="s3">&quot;%H:%M:%S.%f&quot;</span><span class="s1">))</span>
            <span class="s1">tm.assert_frame_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">_get_index_columns(self</span><span class="s2">, </span><span class="s1">tbl_name):</span>
        <span class="s1">ixs = sql.read_sql_query(</span>
            <span class="s3">&quot;SELECT * FROM sqlite_master WHERE type = 'index' &quot;</span>
            <span class="s1">+ </span><span class="s3">f&quot;AND tbl_name = '</span><span class="s2">{</span><span class="s1">tbl_name</span><span class="s2">}</span><span class="s3">'&quot;</span><span class="s2">,</span>
            <span class="s1">self.conn</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">ix_cols = []</span>
        <span class="s2">for </span><span class="s1">ix_name </span><span class="s2">in </span><span class="s1">ixs.name:</span>
            <span class="s1">ix_info = sql.read_sql_query(</span><span class="s3">f&quot;PRAGMA index_info(</span><span class="s2">{</span><span class="s1">ix_name</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
            <span class="s1">ix_cols.append(ix_info.name.tolist())</span>
        <span class="s2">return </span><span class="s1">ix_cols</span>

    <span class="s2">def </span><span class="s1">test_to_sql_save_index(self):</span>
        <span class="s1">self._to_sql_save_index()</span>

    <span class="s2">def </span><span class="s1">test_transactions(self):</span>
        <span class="s1">self._transaction_test()</span>

    <span class="s2">def </span><span class="s1">_get_sqlite_column_type(self</span><span class="s2">, </span><span class="s1">table</span><span class="s2">, </span><span class="s1">column):</span>
        <span class="s1">recs = self.conn.execute(</span><span class="s3">f&quot;PRAGMA table_info(</span><span class="s2">{</span><span class="s1">table</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">ctype</span><span class="s2">, </span><span class="s1">not_null</span><span class="s2">, </span><span class="s1">default</span><span class="s2">, </span><span class="s1">pk </span><span class="s2">in </span><span class="s1">recs:</span>
            <span class="s2">if </span><span class="s1">name == column:</span>
                <span class="s2">return </span><span class="s1">ctype</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Table </span><span class="s2">{</span><span class="s1">table</span><span class="s2">}</span><span class="s3">, column </span><span class="s2">{</span><span class="s1">column</span><span class="s2">} </span><span class="s3">not found&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_dtype(self):</span>
        <span class="s2">if </span><span class="s1">self.flavor == </span><span class="s3">&quot;mysql&quot;</span><span class="s1">:</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Not applicable to MySQL legacy&quot;</span><span class="s1">)</span>
        <span class="s1">cols = [</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">]</span>
        <span class="s1">data = [(</span><span class="s4">0.8</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.9</span><span class="s2">, None</span><span class="s1">)]</span>
        <span class="s1">df = DataFrame(data</span><span class="s2">, </span><span class="s1">columns=cols)</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;dtype_test&quot;</span><span class="s2">, </span><span class="s1">self.conn) == </span><span class="s4">2</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;dtype_test2&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">dtype={</span><span class="s3">&quot;B&quot;</span><span class="s1">: </span><span class="s3">&quot;STRING&quot;</span><span class="s1">}) == </span><span class="s4">2</span>

        <span class="s5"># sqlite stores Boolean values as INTEGER</span>
        <span class="s2">assert </span><span class="s1">self._get_sqlite_column_type(</span><span class="s3">&quot;dtype_test&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">) == </span><span class="s3">&quot;INTEGER&quot;</span>

        <span class="s2">assert </span><span class="s1">self._get_sqlite_column_type(</span><span class="s3">&quot;dtype_test2&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">) == </span><span class="s3">&quot;STRING&quot;</span>
        <span class="s1">msg = </span><span class="s3">r&quot;B \(&lt;class 'bool'&gt;\) not a string&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">df.to_sql(</span><span class="s3">&quot;error&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">dtype={</span><span class="s3">&quot;B&quot;</span><span class="s1">: bool})</span>

        <span class="s5"># single dtype</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(</span><span class="s3">&quot;single_dtype_test&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;STRING&quot;</span><span class="s1">) == </span><span class="s4">2</span>
        <span class="s2">assert </span><span class="s1">self._get_sqlite_column_type(</span><span class="s3">&quot;single_dtype_test&quot;</span><span class="s2">, </span><span class="s3">&quot;A&quot;</span><span class="s1">) == </span><span class="s3">&quot;STRING&quot;</span>
        <span class="s2">assert </span><span class="s1">self._get_sqlite_column_type(</span><span class="s3">&quot;single_dtype_test&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">) == </span><span class="s3">&quot;STRING&quot;</span>

    <span class="s2">def </span><span class="s1">test_notna_dtype(self):</span>
        <span class="s2">if </span><span class="s1">self.flavor == </span><span class="s3">&quot;mysql&quot;</span><span class="s1">:</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Not applicable to MySQL legacy&quot;</span><span class="s1">)</span>

        <span class="s1">cols = {</span>
            <span class="s3">&quot;Bool&quot;</span><span class="s1">: Series([</span><span class="s2">True, None</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s3">&quot;Date&quot;</span><span class="s1">: Series([datetime(</span><span class="s4">2012</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s3">&quot;Int&quot;</span><span class="s1">: Series([</span><span class="s4">1</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;Float&quot;</span><span class="s1">: Series([</span><span class="s4">1.1</span><span class="s2">, None</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s1">df = DataFrame(cols)</span>

        <span class="s1">tbl = </span><span class="s3">&quot;notna_dtype_test&quot;</span>
        <span class="s2">assert </span><span class="s1">df.to_sql(tbl</span><span class="s2">, </span><span class="s1">self.conn) == </span><span class="s4">2</span>

        <span class="s2">assert </span><span class="s1">self._get_sqlite_column_type(tbl</span><span class="s2">, </span><span class="s3">&quot;Bool&quot;</span><span class="s1">) == </span><span class="s3">&quot;INTEGER&quot;</span>
        <span class="s2">assert </span><span class="s1">self._get_sqlite_column_type(tbl</span><span class="s2">, </span><span class="s3">&quot;Date&quot;</span><span class="s1">) == </span><span class="s3">&quot;TIMESTAMP&quot;</span>
        <span class="s2">assert </span><span class="s1">self._get_sqlite_column_type(tbl</span><span class="s2">, </span><span class="s3">&quot;Int&quot;</span><span class="s1">) == </span><span class="s3">&quot;INTEGER&quot;</span>
        <span class="s2">assert </span><span class="s1">self._get_sqlite_column_type(tbl</span><span class="s2">, </span><span class="s3">&quot;Float&quot;</span><span class="s1">) == </span><span class="s3">&quot;REAL&quot;</span>

    <span class="s2">def </span><span class="s1">test_illegal_names(self):</span>
        <span class="s5"># For sqlite, these should work fine</span>
        <span class="s1">df = DataFrame([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">])</span>

        <span class="s1">msg = </span><span class="s3">&quot;Empty table or column name specified&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">df.to_sql(</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s2">for </span><span class="s1">ndx</span><span class="s2">, </span><span class="s1">weird_name </span><span class="s2">in </span><span class="s1">enumerate(</span>
            <span class="s1">[</span>
                <span class="s3">&quot;test_weird_name]&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;test_weird_name[&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;test_weird_name`&quot;</span><span class="s2">,</span>
                <span class="s3">'test_weird_name&quot;'</span><span class="s2">,</span>
                <span class="s3">&quot;test_weird_name'&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;_b.test_weird_name_01-30&quot;</span><span class="s2">,</span>
                <span class="s3">'&quot;_b.test_weird_name_01-30&quot;'</span><span class="s2">,</span>
                <span class="s3">&quot;99beginswithnumber&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;12345&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;</span><span class="s2">\xe9</span><span class="s3">&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">):</span>
            <span class="s2">assert </span><span class="s1">df.to_sql(weird_name</span><span class="s2">, </span><span class="s1">self.conn) == </span><span class="s4">2</span>
            <span class="s1">sql.table_exists(weird_name</span><span class="s2">, </span><span class="s1">self.conn)</span>

            <span class="s1">df2 = DataFrame([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s1">weird_name])</span>
            <span class="s1">c_tbl = </span><span class="s3">f&quot;test_weird_col_name</span><span class="s2">{</span><span class="s1">ndx</span><span class="s2">:</span><span class="s3">d</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s2">assert </span><span class="s1">df2.to_sql(c_tbl</span><span class="s2">, </span><span class="s1">self.conn) == </span><span class="s4">2</span>
            <span class="s1">sql.table_exists(c_tbl</span><span class="s2">, </span><span class="s1">self.conn)</span>


<span class="s5"># -----------------------------------------------------------------------------</span>
<span class="s5"># -- Old tests from 0.13.1 (before refactor using sqlalchemy)</span>


<span class="s1">_formatters = {</span>
    <span class="s1">datetime: </span><span class="s3">&quot;'{}'&quot;</span><span class="s1">.format</span><span class="s2">,</span>
    <span class="s1">str: </span><span class="s3">&quot;'{}'&quot;</span><span class="s1">.format</span><span class="s2">,</span>
    <span class="s1">np.str_: </span><span class="s3">&quot;'{}'&quot;</span><span class="s1">.format</span><span class="s2">,</span>
    <span class="s1">bytes: </span><span class="s3">&quot;'{}'&quot;</span><span class="s1">.format</span><span class="s2">,</span>
    <span class="s1">float: </span><span class="s3">&quot;{:.8f}&quot;</span><span class="s1">.format</span><span class="s2">,</span>
    <span class="s1">int: </span><span class="s3">&quot;{:d}&quot;</span><span class="s1">.format</span><span class="s2">,</span>
    <span class="s1">type(</span><span class="s2">None</span><span class="s1">): </span><span class="s2">lambda </span><span class="s1">x: </span><span class="s3">&quot;NULL&quot;</span><span class="s2">,</span>
    <span class="s1">np.float64: </span><span class="s3">&quot;{:.10f}&quot;</span><span class="s1">.format</span><span class="s2">,</span>
    <span class="s1">bool: </span><span class="s3">&quot;'{!s}'&quot;</span><span class="s1">.format</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s2">def </span><span class="s1">format_query(sql</span><span class="s2">, </span><span class="s1">*args):</span>
    <span class="s1">processed_args = []</span>
    <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args:</span>
        <span class="s2">if </span><span class="s1">isinstance(arg</span><span class="s2">, </span><span class="s1">float) </span><span class="s2">and </span><span class="s1">isna(arg):</span>
            <span class="s1">arg = </span><span class="s2">None</span>

        <span class="s1">formatter = _formatters[type(arg)]</span>
        <span class="s1">processed_args.append(formatter(arg))</span>

    <span class="s2">return </span><span class="s1">sql % tuple(processed_args)</span>


<span class="s2">def </span><span class="s1">tquery(query</span><span class="s2">, </span><span class="s1">con=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Replace removed sql.tquery function&quot;&quot;&quot;</span>
    <span class="s1">res = sql.execute(query</span><span class="s2">, </span><span class="s1">con=con).fetchall()</span>
    <span class="s2">return None if </span><span class="s1">res </span><span class="s2">is None else </span><span class="s1">list(res)</span>


<span class="s2">class </span><span class="s1">TestXSQLite:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.conn = sqlite3.connect(</span><span class="s3">&quot;:memory:&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">teardown_method(self):</span>
        <span class="s1">self.conn.close()</span>

    <span class="s2">def </span><span class="s1">drop_table(self</span><span class="s2">, </span><span class="s1">table_name):</span>
        <span class="s1">cur = self.conn.cursor()</span>
        <span class="s1">cur.execute(</span><span class="s3">f&quot;DROP TABLE IF EXISTS </span><span class="s2">{</span><span class="s1">sql._get_valid_sqlite_name(table_name)</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">self.conn.commit()</span>

    <span class="s2">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">frame = tm.makeTimeDataFrame()</span>
        <span class="s2">assert </span><span class="s1">sql.to_sql(frame</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;test_table&quot;</span><span class="s2">, </span><span class="s1">con=self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">30</span>
        <span class="s1">result = sql.read_sql(</span><span class="s3">&quot;select * from test_table&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s5"># HACK! Change this once indexes are handled properly.</span>
        <span class="s1">result.index = frame.index</span>

        <span class="s1">expected = frame</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">frame)</span>

        <span class="s1">frame[</span><span class="s3">&quot;txt&quot;</span><span class="s1">] = [</span><span class="s3">&quot;a&quot;</span><span class="s1">] * len(frame)</span>
        <span class="s1">frame2 = frame.copy()</span>
        <span class="s1">new_idx = Index(np.arange(len(frame2))) + </span><span class="s4">10</span>
        <span class="s1">frame2[</span><span class="s3">&quot;Idx&quot;</span><span class="s1">] = new_idx.copy()</span>
        <span class="s2">assert </span><span class="s1">sql.to_sql(frame2</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;test_table2&quot;</span><span class="s2">, </span><span class="s1">con=self.conn</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">30</span>
        <span class="s1">result = sql.read_sql(</span><span class="s3">&quot;select * from test_table2&quot;</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">index_col=</span><span class="s3">&quot;Idx&quot;</span><span class="s1">)</span>
        <span class="s1">expected = frame.copy()</span>
        <span class="s1">expected.index = new_idx</span>
        <span class="s1">expected.index.name = </span><span class="s3">&quot;Idx&quot;</span>
        <span class="s1">tm.assert_frame_equal(expected</span><span class="s2">, </span><span class="s1">result)</span>

    <span class="s2">def </span><span class="s1">test_write_row_by_row(self):</span>
        <span class="s1">frame = tm.makeTimeDataFrame()</span>
        <span class="s1">frame.iloc[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = np.nan</span>
        <span class="s1">create_sql = sql.get_schema(frame</span><span class="s2">, </span><span class="s3">&quot;test&quot;</span><span class="s1">)</span>
        <span class="s1">cur = self.conn.cursor()</span>
        <span class="s1">cur.execute(create_sql)</span>

        <span class="s1">ins = </span><span class="s3">&quot;INSERT INTO test VALUES (%s, %s, %s, %s)&quot;</span>
        <span class="s2">for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">row </span><span class="s2">in </span><span class="s1">frame.iterrows():</span>
            <span class="s1">fmt_sql = format_query(ins</span><span class="s2">, </span><span class="s1">*row)</span>
            <span class="s1">tquery(fmt_sql</span><span class="s2">, </span><span class="s1">con=self.conn)</span>

        <span class="s1">self.conn.commit()</span>

        <span class="s1">result = sql.read_sql(</span><span class="s3">&quot;select * from test&quot;</span><span class="s2">, </span><span class="s1">con=self.conn)</span>
        <span class="s1">result.index = frame.index</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">frame</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_execute(self):</span>
        <span class="s1">frame = tm.makeTimeDataFrame()</span>
        <span class="s1">create_sql = sql.get_schema(frame</span><span class="s2">, </span><span class="s3">&quot;test&quot;</span><span class="s1">)</span>
        <span class="s1">cur = self.conn.cursor()</span>
        <span class="s1">cur.execute(create_sql)</span>
        <span class="s1">ins = </span><span class="s3">&quot;INSERT INTO test VALUES (?, ?, ?, ?)&quot;</span>

        <span class="s1">row = frame.iloc[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">sql.execute(ins</span><span class="s2">, </span><span class="s1">self.conn</span><span class="s2">, </span><span class="s1">params=tuple(row))</span>
        <span class="s1">self.conn.commit()</span>

        <span class="s1">result = sql.read_sql(</span><span class="s3">&quot;select * from test&quot;</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">result.index = frame.index[:</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">frame[:</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_schema(self):</span>
        <span class="s1">frame = tm.makeTimeDataFrame()</span>
        <span class="s1">create_sql = sql.get_schema(frame</span><span class="s2">, </span><span class="s3">&quot;test&quot;</span><span class="s1">)</span>
        <span class="s1">lines = create_sql.splitlines()</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines:</span>
            <span class="s1">tokens = line.split(</span><span class="s3">&quot; &quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">len(tokens) == </span><span class="s4">2 </span><span class="s2">and </span><span class="s1">tokens[</span><span class="s4">0</span><span class="s1">] == </span><span class="s3">&quot;A&quot;</span><span class="s1">:</span>
                <span class="s2">assert </span><span class="s1">tokens[</span><span class="s4">1</span><span class="s1">] == </span><span class="s3">&quot;DATETIME&quot;</span>

        <span class="s1">create_sql = sql.get_schema(frame</span><span class="s2">, </span><span class="s3">&quot;test&quot;</span><span class="s2">, </span><span class="s1">keys=[</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">])</span>
        <span class="s1">lines = create_sql.splitlines()</span>
        <span class="s2">assert </span><span class="s3">'PRIMARY KEY (&quot;A&quot;, &quot;B&quot;)' </span><span class="s2">in </span><span class="s1">create_sql</span>
        <span class="s1">cur = self.conn.cursor()</span>
        <span class="s1">cur.execute(create_sql)</span>

    <span class="s2">def </span><span class="s1">test_execute_fail(self):</span>
        <span class="s1">create_sql = </span><span class="s3">&quot;&quot;&quot; 
        CREATE TABLE test 
        ( 
        a TEXT, 
        b TEXT, 
        c REAL, 
        PRIMARY KEY (a, b) 
        ); 
        &quot;&quot;&quot;</span>
        <span class="s1">cur = self.conn.cursor()</span>
        <span class="s1">cur.execute(create_sql)</span>

        <span class="s1">sql.execute(</span><span class="s3">'INSERT INTO test VALUES(&quot;foo&quot;, &quot;bar&quot;, 1.234)'</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">sql.execute(</span><span class="s3">'INSERT INTO test VALUES(&quot;foo&quot;, &quot;baz&quot;, 2.567)'</span><span class="s2">, </span><span class="s1">self.conn)</span>

        <span class="s2">with </span><span class="s1">pytest.raises(sql.DatabaseError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Execution failed on sql&quot;</span><span class="s1">):</span>
            <span class="s1">sql.execute(</span><span class="s3">'INSERT INTO test VALUES(&quot;foo&quot;, &quot;bar&quot;, 7)'</span><span class="s2">, </span><span class="s1">self.conn)</span>

    <span class="s2">def </span><span class="s1">test_execute_closed_connection(self):</span>
        <span class="s1">create_sql = </span><span class="s3">&quot;&quot;&quot; 
        CREATE TABLE test 
        ( 
        a TEXT, 
        b TEXT, 
        c REAL, 
        PRIMARY KEY (a, b) 
        ); 
        &quot;&quot;&quot;</span>
        <span class="s1">cur = self.conn.cursor()</span>
        <span class="s1">cur.execute(create_sql)</span>

        <span class="s1">sql.execute(</span><span class="s3">'INSERT INTO test VALUES(&quot;foo&quot;, &quot;bar&quot;, 1.234)'</span><span class="s2">, </span><span class="s1">self.conn)</span>
        <span class="s1">self.conn.close()</span>

        <span class="s1">msg = </span><span class="s3">&quot;Cannot operate on a closed database.&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(sqlite3.ProgrammingError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">tquery(</span><span class="s3">&quot;select * from test&quot;</span><span class="s2">, </span><span class="s1">con=self.conn)</span>

    <span class="s2">def </span><span class="s1">test_keyword_as_column_names(self):</span>
        <span class="s1">df = DataFrame({</span><span class="s3">&quot;From&quot;</span><span class="s1">: np.ones(</span><span class="s4">5</span><span class="s1">)})</span>
        <span class="s2">assert </span><span class="s1">sql.to_sql(df</span><span class="s2">, </span><span class="s1">con=self.conn</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;testkeywords&quot;</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">5</span>

    <span class="s2">def </span><span class="s1">test_onecolumn_of_integer(self):</span>
        <span class="s5"># GH 3628</span>
        <span class="s5"># a column_of_integers dataframe should transfer well to sql</span>

        <span class="s1">mono_df = DataFrame([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">&quot;c0&quot;</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">sql.to_sql(mono_df</span><span class="s2">, </span><span class="s1">con=self.conn</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;mono_df&quot;</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">False</span><span class="s1">) == </span><span class="s4">2</span>
        <span class="s5"># computing the sum via sql</span>
        <span class="s1">con_x = self.conn</span>
        <span class="s1">the_sum = sum(my_c0[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">my_c0 </span><span class="s2">in </span><span class="s1">con_x.execute(</span><span class="s3">&quot;select * from mono_df&quot;</span><span class="s1">))</span>
        <span class="s5"># it should not fail, and gives 3 ( Issue #3628 )</span>
        <span class="s2">assert </span><span class="s1">the_sum == </span><span class="s4">3</span>

        <span class="s1">result = sql.read_sql(</span><span class="s3">&quot;select * from mono_df&quot;</span><span class="s2">, </span><span class="s1">con_x)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s2">, </span><span class="s1">mono_df)</span>

    <span class="s2">def </span><span class="s1">test_if_exists(self):</span>
        <span class="s1">df_if_exists_1 = DataFrame({</span><span class="s3">&quot;col1&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;col2&quot;</span><span class="s1">: [</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">]})</span>
        <span class="s1">df_if_exists_2 = DataFrame({</span><span class="s3">&quot;col1&quot;</span><span class="s1">: [</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;col2&quot;</span><span class="s1">: [</span><span class="s3">&quot;C&quot;</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s3">&quot;E&quot;</span><span class="s1">]})</span>
        <span class="s1">table_name = </span><span class="s3">&quot;table_if_exists&quot;</span>
        <span class="s1">sql_select = </span><span class="s3">f&quot;SELECT * FROM </span><span class="s2">{</span><span class="s1">table_name</span><span class="s2">}</span><span class="s3">&quot;</span>

        <span class="s1">msg = </span><span class="s3">&quot;'notvalidvalue' is not valid for if_exists&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">sql.to_sql(</span>
                <span class="s1">frame=df_if_exists_1</span><span class="s2">,</span>
                <span class="s1">con=self.conn</span><span class="s2">,</span>
                <span class="s1">name=table_name</span><span class="s2">,</span>
                <span class="s1">if_exists=</span><span class="s3">&quot;notvalidvalue&quot;</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">self.drop_table(table_name)</span>

        <span class="s5"># test if_exists='fail'</span>
        <span class="s1">sql.to_sql(</span>
            <span class="s1">frame=df_if_exists_1</span><span class="s2">, </span><span class="s1">con=self.conn</span><span class="s2">, </span><span class="s1">name=table_name</span><span class="s2">, </span><span class="s1">if_exists=</span><span class="s3">&quot;fail&quot;</span>
        <span class="s1">)</span>
        <span class="s1">msg = </span><span class="s3">&quot;Table 'table_if_exists' already exists&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">sql.to_sql(</span>
                <span class="s1">frame=df_if_exists_1</span><span class="s2">, </span><span class="s1">con=self.conn</span><span class="s2">, </span><span class="s1">name=table_name</span><span class="s2">, </span><span class="s1">if_exists=</span><span class="s3">&quot;fail&quot;</span>
            <span class="s1">)</span>
        <span class="s5"># test if_exists='replace'</span>
        <span class="s1">sql.to_sql(</span>
            <span class="s1">frame=df_if_exists_1</span><span class="s2">,</span>
            <span class="s1">con=self.conn</span><span class="s2">,</span>
            <span class="s1">name=table_name</span><span class="s2">,</span>
            <span class="s1">if_exists=</span><span class="s3">&quot;replace&quot;</span><span class="s2">,</span>
            <span class="s1">index=</span><span class="s2">False,</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">tquery(sql_select</span><span class="s2">, </span><span class="s1">con=self.conn) == [(</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;A&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">)]</span>
        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">sql.to_sql(</span>
                <span class="s1">frame=df_if_exists_2</span><span class="s2">,</span>
                <span class="s1">con=self.conn</span><span class="s2">,</span>
                <span class="s1">name=table_name</span><span class="s2">,</span>
                <span class="s1">if_exists=</span><span class="s3">&quot;replace&quot;</span><span class="s2">,</span>
                <span class="s1">index=</span><span class="s2">False,</span>
            <span class="s1">)</span>
            <span class="s1">== </span><span class="s4">3</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">tquery(sql_select</span><span class="s2">, </span><span class="s1">con=self.conn) == [(</span><span class="s4">3</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">4</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">5</span><span class="s2">, </span><span class="s3">&quot;E&quot;</span><span class="s1">)]</span>
        <span class="s1">self.drop_table(table_name)</span>

        <span class="s5"># test if_exists='append'</span>
        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">sql.to_sql(</span>
                <span class="s1">frame=df_if_exists_1</span><span class="s2">,</span>
                <span class="s1">con=self.conn</span><span class="s2">,</span>
                <span class="s1">name=table_name</span><span class="s2">,</span>
                <span class="s1">if_exists=</span><span class="s3">&quot;fail&quot;</span><span class="s2">,</span>
                <span class="s1">index=</span><span class="s2">False,</span>
            <span class="s1">)</span>
            <span class="s1">== </span><span class="s4">2</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">tquery(sql_select</span><span class="s2">, </span><span class="s1">con=self.conn) == [(</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;A&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">)]</span>
        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">sql.to_sql(</span>
                <span class="s1">frame=df_if_exists_2</span><span class="s2">,</span>
                <span class="s1">con=self.conn</span><span class="s2">,</span>
                <span class="s1">name=table_name</span><span class="s2">,</span>
                <span class="s1">if_exists=</span><span class="s3">&quot;append&quot;</span><span class="s2">,</span>
                <span class="s1">index=</span><span class="s2">False,</span>
            <span class="s1">)</span>
            <span class="s1">== </span><span class="s4">3</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">tquery(sql_select</span><span class="s2">, </span><span class="s1">con=self.conn) == [</span>
            <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;A&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">3</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">4</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">5</span><span class="s2">, </span><span class="s3">&quot;E&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">self.drop_table(table_name)</span>
</pre>
</body>
</html>