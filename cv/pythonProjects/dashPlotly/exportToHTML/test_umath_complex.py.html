<html>
<head>
<title>test_umath_complex.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_umath_complex.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">platform</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s2"># import the c-extension module directly since _arg is not exported via umath</span>
<span class="s0">import </span><span class="s1">numpy.core._multiarray_umath </span><span class="s0">as </span><span class="s1">ncu</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">assert_raises</span><span class="s0">, </span><span class="s1">assert_equal</span><span class="s0">, </span><span class="s1">assert_array_equal</span><span class="s0">, </span><span class="s1">assert_almost_equal</span><span class="s0">, </span><span class="s1">assert_array_max_ulp</span>
    <span class="s1">)</span>

<span class="s2"># TODO: branch cuts (use Pauli code)</span>
<span class="s2"># TODO: conj 'symmetry'</span>
<span class="s2"># TODO: FPU exceptions</span>

<span class="s2"># At least on Windows the results of many complex functions are not conforming</span>
<span class="s2"># to the C99 standard. See ticket 1574.</span>
<span class="s2"># Ditto for Solaris (ticket 1642) and OS X on PowerPC.</span>
<span class="s2">#FIXME: this will probably change when we require full C99 campatibility</span>
<span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s3">'ignore'</span><span class="s1">):</span>
    <span class="s1">functions_seem_flaky = ((np.exp(complex(np.inf</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)).imag != </span><span class="s4">0</span><span class="s1">)</span>
                            <span class="s0">or </span><span class="s1">(np.log(complex(np.NZERO</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)).imag != np.pi))</span>
<span class="s2"># TODO: replace with a check on whether platform-provided C99 funcs are used</span>
<span class="s1">xfail_complex_tests = (</span><span class="s0">not </span><span class="s1">sys.platform.startswith(</span><span class="s3">'linux'</span><span class="s1">) </span><span class="s0">or </span><span class="s1">functions_seem_flaky)</span>

<span class="s2"># TODO This can be xfail when the generator functions are got rid of.</span>
<span class="s1">platform_skip = pytest.mark.skipif(xfail_complex_tests</span><span class="s0">,</span>
                                   <span class="s1">reason=</span><span class="s3">&quot;Inadequate C99 complex support&quot;</span><span class="s1">)</span>



<span class="s0">class </span><span class="s1">TestCexp:</span>
    <span class="s0">def </span><span class="s1">test_simple(self):</span>
        <span class="s1">check = check_complex_value</span>
        <span class="s1">f = np.exp</span>

        <span class="s1">check(f</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">np.exp(</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.cos(</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.sin(</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s1">ref = np.exp(</span><span class="s4">1</span><span class="s1">) * complex(np.cos(</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.sin(</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">ref.real</span><span class="s0">, </span><span class="s1">ref.imag</span><span class="s0">, False</span><span class="s1">)</span>

    <span class="s1">@platform_skip</span>
    <span class="s0">def </span><span class="s1">test_special_values(self):</span>
        <span class="s2"># C99: Section G 6.3.1</span>

        <span class="s1">check = check_complex_value</span>
        <span class="s1">f = np.exp</span>

        <span class="s2"># cexp(+-0 + 0i) is 1 + 0i</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">np.PZERO</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">np.NZERO</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s2"># cexp(x + infi) is nan + nani for finite x and raises 'invalid' FPU</span>
        <span class="s2"># exception</span>
        <span class="s1">check(f</span><span class="s0">,  </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">check(f</span><span class="s0">,  </span><span class="s4">0</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>

        <span class="s2"># cexp(inf + 0i) is inf + 0i</span>
        <span class="s1">check(f</span><span class="s0">,  </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s2"># cexp(-inf + yi) is +0 * (cos(y) + i sin(y)) for finite y</span>
        <span class="s1">check(f</span><span class="s0">,  </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.PZERO</span><span class="s0">, </span><span class="s1">np.PZERO)</span>
        <span class="s1">check(f</span><span class="s0">,  </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s4">0.75 </span><span class="s1">* np.pi</span><span class="s0">, </span><span class="s1">np.NZERO</span><span class="s0">, </span><span class="s1">np.PZERO)</span>

        <span class="s2"># cexp(inf + yi) is +inf * (cos(y) + i sin(y)) for finite y</span>
        <span class="s1">check(f</span><span class="s0">,  </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s1">check(f</span><span class="s0">,  </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s4">0.75 </span><span class="s1">* np.pi</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span>

        <span class="s2"># cexp(-inf + inf i) is +-0 +- 0i (signs unspecified)</span>
        <span class="s0">def </span><span class="s1">_check_ninf_inf(dummy):</span>
            <span class="s1">msgform = </span><span class="s3">&quot;cexp(-inf, inf) is (%f, %f), expected (+-0, +-0)&quot;</span>
            <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
                <span class="s1">z = f(np.array(complex(-np.inf</span><span class="s0">, </span><span class="s1">np.inf)))</span>
                <span class="s0">if </span><span class="s1">z.real != </span><span class="s4">0 </span><span class="s0">or </span><span class="s1">z.imag != </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s0">raise </span><span class="s1">AssertionError(msgform % (z.real</span><span class="s0">, </span><span class="s1">z.imag))</span>

        <span class="s1">_check_ninf_inf(</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s2"># cexp(inf + inf i) is +-inf + NaNi and raised invalid FPU ex.</span>
        <span class="s0">def </span><span class="s1">_check_inf_inf(dummy):</span>
            <span class="s1">msgform = </span><span class="s3">&quot;cexp(inf, inf) is (%f, %f), expected (+-inf, nan)&quot;</span>
            <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
                <span class="s1">z = f(np.array(complex(np.inf</span><span class="s0">, </span><span class="s1">np.inf)))</span>
                <span class="s0">if not </span><span class="s1">np.isinf(z.real) </span><span class="s0">or not </span><span class="s1">np.isnan(z.imag):</span>
                    <span class="s0">raise </span><span class="s1">AssertionError(msgform % (z.real</span><span class="s0">, </span><span class="s1">z.imag))</span>

        <span class="s1">_check_inf_inf(</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s2"># cexp(-inf + nan i) is +-0 +- 0i</span>
        <span class="s0">def </span><span class="s1">_check_ninf_nan(dummy):</span>
            <span class="s1">msgform = </span><span class="s3">&quot;cexp(-inf, nan) is (%f, %f), expected (+-0, +-0)&quot;</span>
            <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
                <span class="s1">z = f(np.array(complex(-np.inf</span><span class="s0">, </span><span class="s1">np.nan)))</span>
                <span class="s0">if </span><span class="s1">z.real != </span><span class="s4">0 </span><span class="s0">or </span><span class="s1">z.imag != </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s0">raise </span><span class="s1">AssertionError(msgform % (z.real</span><span class="s0">, </span><span class="s1">z.imag))</span>

        <span class="s1">_check_ninf_nan(</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s2"># cexp(inf + nan i) is +-inf + nan</span>
        <span class="s0">def </span><span class="s1">_check_inf_nan(dummy):</span>
            <span class="s1">msgform = </span><span class="s3">&quot;cexp(-inf, nan) is (%f, %f), expected (+-inf, nan)&quot;</span>
            <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
                <span class="s1">z = f(np.array(complex(np.inf</span><span class="s0">, </span><span class="s1">np.nan)))</span>
                <span class="s0">if not </span><span class="s1">np.isinf(z.real) </span><span class="s0">or not </span><span class="s1">np.isnan(z.imag):</span>
                    <span class="s0">raise </span><span class="s1">AssertionError(msgform % (z.real</span><span class="s0">, </span><span class="s1">z.imag))</span>

        <span class="s1">_check_inf_nan(</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s2"># cexp(nan + yi) is nan + nani for y != 0 (optional: raises invalid FPU</span>
        <span class="s2"># ex)</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>

        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">,  </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>

        <span class="s2"># cexp(nan + nani) is nan + nani</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>

    <span class="s2"># TODO This can be xfail when the generator functions are got rid of.</span>
    <span class="s1">@pytest.mark.skip(reason=</span><span class="s3">&quot;cexp(nan + 0I) is wrong on most platforms&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_special_values2(self):</span>
        <span class="s2"># XXX: most implementations get it wrong here (including glibc &lt;= 2.10)</span>
        <span class="s2"># cexp(nan + 0i) is nan + 0i</span>
        <span class="s1">check = check_complex_value</span>
        <span class="s1">f = np.exp</span>

        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>

<span class="s0">class </span><span class="s1">TestClog:</span>
    <span class="s0">def </span><span class="s1">test_simple(self):</span>
        <span class="s1">x = np.array([</span><span class="s4">1</span><span class="s1">+</span><span class="s4">0j</span><span class="s0">, </span><span class="s4">1</span><span class="s1">+</span><span class="s4">2j</span><span class="s1">])</span>
        <span class="s1">y_r = np.log(np.abs(x)) + </span><span class="s4">1j </span><span class="s1">* np.angle(x)</span>
        <span class="s1">y = np.log(x)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r)</span>

    <span class="s1">@platform_skip</span>
    <span class="s1">@pytest.mark.skipif(platform.machine() == </span><span class="s3">&quot;armv5tel&quot;</span><span class="s0">, </span><span class="s1">reason=</span><span class="s3">&quot;See gh-413.&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_special_values(self):</span>
        <span class="s1">xl = []</span>
        <span class="s1">yl = []</span>

        <span class="s2"># From C99 std (Sec 6.3.2)</span>
        <span class="s2"># XXX: check exceptions raised</span>
        <span class="s2"># --- raise for invalid fails.</span>

        <span class="s2"># clog(-0 + i0) returns -inf + i pi and raises the 'divide-by-zero'</span>
        <span class="s2"># floating-point exception.</span>
        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s3">'raise'</span><span class="s1">):</span>
            <span class="s1">x = np.array([np.NZERO]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
            <span class="s1">y = complex(-np.inf</span><span class="s0">, </span><span class="s1">np.pi)</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.log</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s3">'ignore'</span><span class="s1">):</span>
            <span class="s1">assert_almost_equal(np.log(x)</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s1">xl.append(x)</span>
        <span class="s1">yl.append(y)</span>

        <span class="s2"># clog(+0 + i0) returns -inf + i0 and raises the 'divide-by-zero'</span>
        <span class="s2"># floating-point exception.</span>
        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s3">'raise'</span><span class="s1">):</span>
            <span class="s1">x = np.array([</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
            <span class="s1">y = complex(-np.inf</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.log</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s3">'ignore'</span><span class="s1">):</span>
            <span class="s1">assert_almost_equal(np.log(x)</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s1">xl.append(x)</span>
        <span class="s1">yl.append(y)</span>

        <span class="s2"># clog(x + i inf returns +inf + i pi /2, for finite x.</span>
        <span class="s1">x = np.array([complex(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.inf)]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">y = complex(np.inf</span><span class="s0">, </span><span class="s4">0.5 </span><span class="s1">* np.pi)</span>
        <span class="s1">assert_almost_equal(np.log(x)</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">xl.append(x)</span>
        <span class="s1">yl.append(y)</span>

        <span class="s1">x = np.array([complex(-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.inf)]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">assert_almost_equal(np.log(x)</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">xl.append(x)</span>
        <span class="s1">yl.append(y)</span>

        <span class="s2"># clog(x + iNaN) returns NaN + iNaN and optionally raises the</span>
        <span class="s2"># 'invalid' floating- point exception, for finite x.</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'raise'</span><span class="s1">):</span>
            <span class="s1">x = np.array([complex(</span><span class="s4">1.</span><span class="s0">, </span><span class="s1">np.nan)]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
            <span class="s1">y = complex(np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>
            <span class="s2">#assert_raises(FloatingPointError, np.log, x)</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
            <span class="s1">assert_almost_equal(np.log(x)</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s1">xl.append(x)</span>
        <span class="s1">yl.append(y)</span>

        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'raise'</span><span class="s1">):</span>
            <span class="s1">x = np.array([np.inf + </span><span class="s4">1j </span><span class="s1">* np.nan]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
            <span class="s2">#assert_raises(FloatingPointError, np.log, x)</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
            <span class="s1">assert_almost_equal(np.log(x)</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s1">xl.append(x)</span>
        <span class="s1">yl.append(y)</span>

        <span class="s2"># clog(- inf + iy) returns +inf + ipi , for finite positive-signed y.</span>
        <span class="s1">x = np.array([-np.inf + </span><span class="s4">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">y = complex(np.inf</span><span class="s0">, </span><span class="s1">np.pi)</span>
        <span class="s1">assert_almost_equal(np.log(x)</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">xl.append(x)</span>
        <span class="s1">yl.append(y)</span>

        <span class="s2"># clog(+ inf + iy) returns +inf + i0, for finite positive-signed y.</span>
        <span class="s1">x = np.array([np.inf + </span><span class="s4">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">y = complex(np.inf</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(np.log(x)</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">xl.append(x)</span>
        <span class="s1">yl.append(y)</span>

        <span class="s2"># clog(- inf + i inf) returns +inf + i3pi /4.</span>
        <span class="s1">x = np.array([complex(-np.inf</span><span class="s0">, </span><span class="s1">np.inf)]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">y = complex(np.inf</span><span class="s0">, </span><span class="s4">0.75 </span><span class="s1">* np.pi)</span>
        <span class="s1">assert_almost_equal(np.log(x)</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">xl.append(x)</span>
        <span class="s1">yl.append(y)</span>

        <span class="s2"># clog(+ inf + i inf) returns +inf + ipi /4.</span>
        <span class="s1">x = np.array([complex(np.inf</span><span class="s0">, </span><span class="s1">np.inf)]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">y = complex(np.inf</span><span class="s0">, </span><span class="s4">0.25 </span><span class="s1">* np.pi)</span>
        <span class="s1">assert_almost_equal(np.log(x)</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">xl.append(x)</span>
        <span class="s1">yl.append(y)</span>

        <span class="s2"># clog(+/- inf + iNaN) returns +inf + iNaN.</span>
        <span class="s1">x = np.array([complex(np.inf</span><span class="s0">, </span><span class="s1">np.nan)]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">y = complex(np.inf</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">assert_almost_equal(np.log(x)</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">xl.append(x)</span>
        <span class="s1">yl.append(y)</span>

        <span class="s1">x = np.array([complex(-np.inf</span><span class="s0">, </span><span class="s1">np.nan)]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">assert_almost_equal(np.log(x)</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">xl.append(x)</span>
        <span class="s1">yl.append(y)</span>

        <span class="s2"># clog(NaN + iy) returns NaN + iNaN and optionally raises the</span>
        <span class="s2"># 'invalid' floating-point exception, for finite y.</span>
        <span class="s1">x = np.array([complex(np.nan</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">y = complex(np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">assert_almost_equal(np.log(x)</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">xl.append(x)</span>
        <span class="s1">yl.append(y)</span>

        <span class="s2"># clog(NaN + i inf) returns +inf + iNaN.</span>
        <span class="s1">x = np.array([complex(np.nan</span><span class="s0">, </span><span class="s1">np.inf)]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">y = complex(np.inf</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">assert_almost_equal(np.log(x)</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">xl.append(x)</span>
        <span class="s1">yl.append(y)</span>

        <span class="s2"># clog(NaN + iNaN) returns NaN + iNaN.</span>
        <span class="s1">x = np.array([complex(np.nan</span><span class="s0">, </span><span class="s1">np.nan)]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">y = complex(np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">assert_almost_equal(np.log(x)</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">xl.append(x)</span>
        <span class="s1">yl.append(y)</span>

        <span class="s2"># clog(conj(z)) = conj(clog(z)).</span>
        <span class="s1">xa = np.array(xl</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">ya = np.array(yl</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s3">'ignore'</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(xa)):</span>
                <span class="s1">assert_almost_equal(np.log(xa[i].conj())</span><span class="s0">, </span><span class="s1">ya[i].conj())</span>


<span class="s0">class </span><span class="s1">TestCsqrt:</span>

    <span class="s0">def </span><span class="s1">test_simple(self):</span>
        <span class="s2"># sqrt(1)</span>
        <span class="s1">check_complex_value(np.sqrt</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s2"># sqrt(1i)</span>
        <span class="s1">rres = </span><span class="s4">0.5</span><span class="s1">*np.sqrt(</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">ires = rres</span>
        <span class="s1">check_complex_value(np.sqrt</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">rres</span><span class="s0">, </span><span class="s1">ires</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s2"># sqrt(-1)</span>
        <span class="s1">check_complex_value(np.sqrt</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_simple_conjugate(self):</span>
        <span class="s1">ref = np.conj(np.sqrt(complex(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)))</span>

        <span class="s0">def </span><span class="s1">f(z):</span>
            <span class="s0">return </span><span class="s1">np.sqrt(np.conj(z))</span>

        <span class="s1">check_complex_value(f</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">ref.real</span><span class="s0">, </span><span class="s1">ref.imag</span><span class="s0">, False</span><span class="s1">)</span>

    <span class="s2">#def test_branch_cut(self):</span>
    <span class="s2">#    _check_branch_cut(f, -1, 0, 1, -1)</span>

    <span class="s1">@platform_skip</span>
    <span class="s0">def </span><span class="s1">test_special_values(self):</span>
        <span class="s2"># C99: Sec G 6.4.2</span>

        <span class="s1">check = check_complex_value</span>
        <span class="s1">f = np.sqrt</span>

        <span class="s2"># csqrt(+-0 + 0i) is 0 + 0i</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">np.PZERO</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">np.NZERO</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s2"># csqrt(x + infi) is inf + infi for any x (including NaN)</span>
        <span class="s1">check(f</span><span class="s0">,  </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span>

        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">np.PZERO</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">np.NZERO</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s1">check(f</span><span class="s0">,   </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s1">check(f</span><span class="s0">,  </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s1">check(f</span><span class="s0">,  </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span>

        <span class="s2"># csqrt(x + nani) is nan + nani for any finite x</span>
        <span class="s1">check(f</span><span class="s0">,  </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">check(f</span><span class="s0">,  </span><span class="s4">0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>

        <span class="s2"># csqrt(-inf + yi) is +0 + infi for any finite y &gt; 0</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.PZERO</span><span class="s0">, </span><span class="s1">np.inf)</span>

        <span class="s2"># csqrt(inf + yi) is +inf + 0i for any finite y &gt; 0</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.PZERO)</span>

        <span class="s2"># csqrt(-inf + nani) is nan +- infi (both +i infi are valid)</span>
        <span class="s0">def </span><span class="s1">_check_ninf_nan(dummy):</span>
            <span class="s1">msgform = </span><span class="s3">&quot;csqrt(-inf, nan) is (%f, %f), expected (nan, +-inf)&quot;</span>
            <span class="s1">z = np.sqrt(np.array(complex(-np.inf</span><span class="s0">, </span><span class="s1">np.nan)))</span>
            <span class="s2">#Fixme: ugly workaround for isinf bug.</span>
            <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
                <span class="s0">if not </span><span class="s1">(np.isnan(z.real) </span><span class="s0">and </span><span class="s1">np.isinf(z.imag)):</span>
                    <span class="s0">raise </span><span class="s1">AssertionError(msgform % (z.real</span><span class="s0">, </span><span class="s1">z.imag))</span>

        <span class="s1">_check_ninf_nan(</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s2"># csqrt(+inf + nani) is inf + nani</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan)</span>

        <span class="s2"># csqrt(nan + yi) is nan + nani for any finite y (infinite handled in x</span>
        <span class="s2"># + nani)</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">,       </span><span class="s4">0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">,       </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">check(f</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">,  </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>

        <span class="s2"># XXX: check for conj(csqrt(z)) == csqrt(conj(z)) (need to fix branch</span>
        <span class="s2"># cuts first)</span>

<span class="s0">class </span><span class="s1">TestCpow:</span>
    <span class="s0">def </span><span class="s1">setup(self):</span>
        <span class="s1">self.olderr = np.seterr(invalid=</span><span class="s3">'ignore'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">teardown(self):</span>
        <span class="s1">np.seterr(**self.olderr)</span>

    <span class="s0">def </span><span class="s1">test_simple(self):</span>
        <span class="s1">x = np.array([</span><span class="s4">1</span><span class="s1">+</span><span class="s4">1j</span><span class="s0">, </span><span class="s4">0</span><span class="s1">+</span><span class="s4">2j</span><span class="s0">, </span><span class="s4">1</span><span class="s1">+</span><span class="s4">2j</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s1">y_r = x ** </span><span class="s4">2</span>
        <span class="s1">y = np.power(x</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r)</span>

    <span class="s0">def </span><span class="s1">test_scalar(self):</span>
        <span class="s1">x = np.array([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1j</span><span class="s0">,         </span><span class="s4">2</span><span class="s0">,  </span><span class="s4">2.5</span><span class="s1">+</span><span class="s4">.37j</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s1">y = np.array([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1j</span><span class="s0">, </span><span class="s1">-</span><span class="s4">0.5</span><span class="s1">+</span><span class="s4">1.5j</span><span class="s0">, </span><span class="s1">-</span><span class="s4">0.5</span><span class="s1">+</span><span class="s4">1.5j</span><span class="s0">,      </span><span class="s4">2</span><span class="s0">,      </span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">lx = list(range(len(x)))</span>

        <span class="s2"># Hardcode the expected `builtins.complex` values,</span>
        <span class="s2"># as complex exponentiation is broken as of bpo-44698</span>
        <span class="s1">p_r = [</span>
            <span class="s4">1</span><span class="s1">+</span><span class="s4">0j</span><span class="s0">,</span>
            <span class="s4">0.20787957635076193</span><span class="s1">+</span><span class="s4">0j</span><span class="s0">,</span>
            <span class="s4">0.35812203996480685</span><span class="s1">+</span><span class="s4">0.6097119028618724j</span><span class="s0">,</span>
            <span class="s4">0.12659112128185032</span><span class="s1">+</span><span class="s4">0.48847676699581527j</span><span class="s0">,</span>
            <span class="s1">complex(np.inf</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">,</span>
            <span class="s1">complex(np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s1">n_r = [x[i] ** y[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">lx]</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">lx:</span>
            <span class="s1">assert_almost_equal(n_r[i]</span><span class="s0">, </span><span class="s1">p_r[i]</span><span class="s0">, </span><span class="s1">err_msg=</span><span class="s3">'Loop %d</span><span class="s0">\n</span><span class="s3">' </span><span class="s1">% i)</span>

    <span class="s0">def </span><span class="s1">test_array(self):</span>
        <span class="s1">x = np.array([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1j</span><span class="s0">,         </span><span class="s4">2</span><span class="s0">,  </span><span class="s4">2.5</span><span class="s1">+</span><span class="s4">.37j</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s1">y = np.array([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1j</span><span class="s0">, </span><span class="s1">-</span><span class="s4">0.5</span><span class="s1">+</span><span class="s4">1.5j</span><span class="s0">, </span><span class="s1">-</span><span class="s4">0.5</span><span class="s1">+</span><span class="s4">1.5j</span><span class="s0">,      </span><span class="s4">2</span><span class="s0">,      </span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">lx = list(range(len(x)))</span>

        <span class="s2"># Hardcode the expected `builtins.complex` values,</span>
        <span class="s2"># as complex exponentiation is broken as of bpo-44698</span>
        <span class="s1">p_r = [</span>
            <span class="s4">1</span><span class="s1">+</span><span class="s4">0j</span><span class="s0">,</span>
            <span class="s4">0.20787957635076193</span><span class="s1">+</span><span class="s4">0j</span><span class="s0">,</span>
            <span class="s4">0.35812203996480685</span><span class="s1">+</span><span class="s4">0.6097119028618724j</span><span class="s0">,</span>
            <span class="s4">0.12659112128185032</span><span class="s1">+</span><span class="s4">0.48847676699581527j</span><span class="s0">,</span>
            <span class="s1">complex(np.inf</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">,</span>
            <span class="s1">complex(np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s1">n_r = x ** y</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">lx:</span>
            <span class="s1">assert_almost_equal(n_r[i]</span><span class="s0">, </span><span class="s1">p_r[i]</span><span class="s0">, </span><span class="s1">err_msg=</span><span class="s3">'Loop %d</span><span class="s0">\n</span><span class="s3">' </span><span class="s1">% i)</span>

<span class="s0">class </span><span class="s1">TestCabs:</span>
    <span class="s0">def </span><span class="s1">setup(self):</span>
        <span class="s1">self.olderr = np.seterr(invalid=</span><span class="s3">'ignore'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">teardown(self):</span>
        <span class="s1">np.seterr(**self.olderr)</span>

    <span class="s0">def </span><span class="s1">test_simple(self):</span>
        <span class="s1">x = np.array([</span><span class="s4">1</span><span class="s1">+</span><span class="s4">1j</span><span class="s0">, </span><span class="s4">0</span><span class="s1">+</span><span class="s4">2j</span><span class="s0">, </span><span class="s4">1</span><span class="s1">+</span><span class="s4">2j</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s1">y_r = np.array([np.sqrt(</span><span class="s4">2.</span><span class="s1">)</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">np.sqrt(</span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s1">y = np.abs(x)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">y_r)</span>

    <span class="s0">def </span><span class="s1">test_fabs(self):</span>
        <span class="s2"># Test that np.abs(x +- 0j) == np.abs(x) (as mandated by C99 for cabs)</span>
        <span class="s1">x = np.array([</span><span class="s4">1</span><span class="s1">+</span><span class="s4">0j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">assert_array_equal(np.abs(x)</span><span class="s0">, </span><span class="s1">np.real(x))</span>

        <span class="s1">x = np.array([complex(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.NZERO)]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">assert_array_equal(np.abs(x)</span><span class="s0">, </span><span class="s1">np.real(x))</span>

        <span class="s1">x = np.array([complex(np.inf</span><span class="s0">, </span><span class="s1">np.NZERO)]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">assert_array_equal(np.abs(x)</span><span class="s0">, </span><span class="s1">np.real(x))</span>

        <span class="s1">x = np.array([complex(np.nan</span><span class="s0">, </span><span class="s1">np.NZERO)]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
        <span class="s1">assert_array_equal(np.abs(x)</span><span class="s0">, </span><span class="s1">np.real(x))</span>

    <span class="s0">def </span><span class="s1">test_cabs_inf_nan(self):</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y = []</span><span class="s0">, </span><span class="s1">[]</span>

        <span class="s2"># cabs(+-nan + nani) returns nan</span>
        <span class="s1">x.append(np.nan)</span>
        <span class="s1">y.append(np.nan)</span>
        <span class="s1">check_real_value(np.abs</span><span class="s0">,  </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>

        <span class="s1">x.append(np.nan)</span>
        <span class="s1">y.append(-np.nan)</span>
        <span class="s1">check_real_value(np.abs</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>

        <span class="s2"># According to C99 standard, if exactly one of the real/part is inf and</span>
        <span class="s2"># the other nan, then cabs should return inf</span>
        <span class="s1">x.append(np.inf)</span>
        <span class="s1">y.append(np.nan)</span>
        <span class="s1">check_real_value(np.abs</span><span class="s0">,  </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf)</span>

        <span class="s1">x.append(-np.inf)</span>
        <span class="s1">y.append(np.nan)</span>
        <span class="s1">check_real_value(np.abs</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf)</span>

        <span class="s2"># cabs(conj(z)) == conj(cabs(z)) (= cabs(z))</span>
        <span class="s0">def </span><span class="s1">f(a):</span>
            <span class="s0">return </span><span class="s1">np.abs(np.conj(a))</span>

        <span class="s0">def </span><span class="s1">g(a</span><span class="s0">, </span><span class="s1">b):</span>
            <span class="s0">return </span><span class="s1">np.abs(complex(a</span><span class="s0">, </span><span class="s1">b))</span>

        <span class="s1">xa = np.array(x</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
        <span class="s0">assert </span><span class="s1">len(xa) == len(x) == len(y)</span>
        <span class="s0">for </span><span class="s1">xi</span><span class="s0">, </span><span class="s1">yi </span><span class="s0">in </span><span class="s1">zip(x</span><span class="s0">, </span><span class="s1">y):</span>
            <span class="s1">ref = g(xi</span><span class="s0">, </span><span class="s1">yi)</span>
            <span class="s1">check_real_value(f</span><span class="s0">, </span><span class="s1">xi</span><span class="s0">, </span><span class="s1">yi</span><span class="s0">, </span><span class="s1">ref)</span>

<span class="s0">class </span><span class="s1">TestCarg:</span>
    <span class="s0">def </span><span class="s1">test_simple(self):</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0.5</span><span class="s1">*np.pi</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0.25</span><span class="s1">*np.pi</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">np.PZERO</span><span class="s0">, </span><span class="s1">np.PZERO</span><span class="s0">, </span><span class="s1">np.PZERO)</span>

    <span class="s2"># TODO This can be xfail when the generator functions are got rid of.</span>
    <span class="s1">@pytest.mark.skip(</span>
        <span class="s1">reason=</span><span class="s3">&quot;Complex arithmetic with signed zero fails on most platforms&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_zero(self):</span>
        <span class="s2"># carg(-0 +- 0i) returns +- pi</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">np.NZERO</span><span class="s0">, </span><span class="s1">np.PZERO</span><span class="s0">,  </span><span class="s1">np.pi</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">np.NZERO</span><span class="s0">, </span><span class="s1">np.NZERO</span><span class="s0">, </span><span class="s1">-np.pi</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s2"># carg(+0 +- 0i) returns +- 0</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">np.PZERO</span><span class="s0">, </span><span class="s1">np.PZERO</span><span class="s0">, </span><span class="s1">np.PZERO)</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">np.PZERO</span><span class="s0">, </span><span class="s1">np.NZERO</span><span class="s0">, </span><span class="s1">np.NZERO)</span>

        <span class="s2"># carg(x +- 0i) returns +- 0 for x &gt; 0</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.PZERO</span><span class="s0">, </span><span class="s1">np.PZERO</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.NZERO</span><span class="s0">, </span><span class="s1">np.NZERO</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s2"># carg(x +- 0i) returns +- pi for x &lt; 0</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.PZERO</span><span class="s0">,  </span><span class="s1">np.pi</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.NZERO</span><span class="s0">, </span><span class="s1">-np.pi</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s2"># carg(+- 0 + yi) returns pi/2 for y &gt; 0</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">np.PZERO</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0.5 </span><span class="s1">* np.pi</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">np.NZERO</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0.5 </span><span class="s1">* np.pi</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s2"># carg(+- 0 + yi) returns -pi/2 for y &lt; 0</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">np.PZERO</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0.5 </span><span class="s1">* np.pi</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">np.NZERO</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">0.5 </span><span class="s1">* np.pi</span><span class="s0">, False</span><span class="s1">)</span>

    <span class="s2">#def test_branch_cuts(self):</span>
    <span class="s2">#    _check_branch_cut(ncu._arg, -1, 1j, -1, 1)</span>

    <span class="s0">def </span><span class="s1">test_special_values(self):</span>
        <span class="s2"># carg(-np.inf +- yi) returns +-pi for finite y &gt; 0</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">,  </span><span class="s4">1</span><span class="s0">,  </span><span class="s1">np.pi</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-np.pi</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s2"># carg(np.inf +- yi) returns +-0 for finite y &gt; 0</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">,  </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.PZERO</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.NZERO</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s2"># carg(x +- np.infi) returns +-pi/2 for finite x</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s4">1</span><span class="s0">,  </span><span class="s1">np.inf</span><span class="s0">,  </span><span class="s4">0.5 </span><span class="s1">* np.pi</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">-</span><span class="s4">0.5 </span><span class="s1">* np.pi</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s2"># carg(-np.inf +- np.infi) returns +-3pi/4</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">,  </span><span class="s1">np.inf</span><span class="s0">,  </span><span class="s4">0.75 </span><span class="s1">* np.pi</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">-</span><span class="s4">0.75 </span><span class="s1">* np.pi</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s2"># carg(np.inf +- np.infi) returns +-pi/4</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">,  </span><span class="s1">np.inf</span><span class="s0">,  </span><span class="s4">0.25 </span><span class="s1">* np.pi</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">-</span><span class="s4">0.25 </span><span class="s1">* np.pi</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s2"># carg(x + yi) returns np.nan if x or y is nan</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">,      </span><span class="s4">0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">,      </span><span class="s4">0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">check_real_value(ncu._arg</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">check_real_value(f</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">y1</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">exact=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s1">z1 = np.array([complex(x1</span><span class="s0">, </span><span class="s1">y1)])</span>
    <span class="s0">if </span><span class="s1">exact:</span>
        <span class="s1">assert_equal(f(z1)</span><span class="s0">, </span><span class="s1">x)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">assert_almost_equal(f(z1)</span><span class="s0">, </span><span class="s1">x)</span>


<span class="s0">def </span><span class="s1">check_complex_value(f</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">y1</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s1">y2</span><span class="s0">, </span><span class="s1">exact=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s1">z1 = np.array([complex(x1</span><span class="s0">, </span><span class="s1">y1)])</span>
    <span class="s1">z2 = complex(x2</span><span class="s0">, </span><span class="s1">y2)</span>
    <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">exact:</span>
            <span class="s1">assert_equal(f(z1)</span><span class="s0">, </span><span class="s1">z2)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">assert_almost_equal(f(z1)</span><span class="s0">, </span><span class="s1">z2)</span>

<span class="s0">class </span><span class="s1">TestSpecialComplexAVX:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;stride&quot;</span><span class="s0">, </span><span class="s1">[-</span><span class="s4">4</span><span class="s0">,</span><span class="s1">-</span><span class="s4">2</span><span class="s0">,</span><span class="s1">-</span><span class="s4">1</span><span class="s0">,</span><span class="s4">1</span><span class="s0">,</span><span class="s4">2</span><span class="s0">,</span><span class="s4">4</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;astype&quot;</span><span class="s0">, </span><span class="s1">[np.complex64</span><span class="s0">, </span><span class="s1">np.complex128])</span>
    <span class="s0">def </span><span class="s1">test_array(self</span><span class="s0">, </span><span class="s1">stride</span><span class="s0">, </span><span class="s1">astype):</span>
        <span class="s1">arr = np.array([complex(np.nan </span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">,</span>
                        <span class="s1">complex(np.nan </span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">,</span>
                        <span class="s1">complex(np.inf </span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">,</span>
                        <span class="s1">complex(np.inf </span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">,</span>
                        <span class="s1">complex(</span><span class="s4">0.     </span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">,</span>
                        <span class="s1">complex(np.inf </span><span class="s0">, </span><span class="s4">0.</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">complex(</span><span class="s4">0.     </span><span class="s0">, </span><span class="s4">0.</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">complex(</span><span class="s4">0.     </span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">,</span>
                        <span class="s1">complex(np.nan </span><span class="s0">, </span><span class="s4">0.</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=astype)</span>
        <span class="s1">abs_true = np.array([np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">dtype=arr.real.dtype)</span>
        <span class="s1">sq_true = np.array([complex(np.nan</span><span class="s0">,  </span><span class="s1">np.nan)</span><span class="s0">,</span>
                            <span class="s1">complex(np.nan</span><span class="s0">,  </span><span class="s1">np.nan)</span><span class="s0">,</span>
                            <span class="s1">complex(np.nan</span><span class="s0">,  </span><span class="s1">np.nan)</span><span class="s0">,</span>
                            <span class="s1">complex(np.nan</span><span class="s0">,  </span><span class="s1">np.inf)</span><span class="s0">,</span>
                            <span class="s1">complex(-np.inf</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">,</span>
                            <span class="s1">complex(np.inf</span><span class="s0">,  </span><span class="s1">np.nan)</span><span class="s0">,</span>
                            <span class="s1">complex(</span><span class="s4">0.</span><span class="s0">,     </span><span class="s4">0.</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">complex(np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">,</span>
                            <span class="s1">complex(np.nan</span><span class="s0">, </span><span class="s1">np.nan)]</span><span class="s0">, </span><span class="s1">dtype=astype)</span>
        <span class="s1">assert_equal(np.abs(arr[::stride])</span><span class="s0">, </span><span class="s1">abs_true[::stride])</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">'ignore'</span><span class="s1">):</span>
            <span class="s1">assert_equal(np.square(arr[::stride])</span><span class="s0">, </span><span class="s1">sq_true[::stride])</span>

<span class="s0">class </span><span class="s1">TestComplexAbsoluteAVX:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;arraysize&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">,</span><span class="s4">2</span><span class="s0">,</span><span class="s4">3</span><span class="s0">,</span><span class="s4">4</span><span class="s0">,</span><span class="s4">5</span><span class="s0">,</span><span class="s4">6</span><span class="s0">,</span><span class="s4">7</span><span class="s0">,</span><span class="s4">8</span><span class="s0">,</span><span class="s4">9</span><span class="s0">,</span><span class="s4">10</span><span class="s0">,</span><span class="s4">11</span><span class="s0">,</span><span class="s4">13</span><span class="s0">,</span><span class="s4">15</span><span class="s0">,</span><span class="s4">17</span><span class="s0">,</span><span class="s4">18</span><span class="s0">,</span><span class="s4">19</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;stride&quot;</span><span class="s0">, </span><span class="s1">[-</span><span class="s4">4</span><span class="s0">,</span><span class="s1">-</span><span class="s4">3</span><span class="s0">,</span><span class="s1">-</span><span class="s4">2</span><span class="s0">,</span><span class="s1">-</span><span class="s4">1</span><span class="s0">,</span><span class="s4">1</span><span class="s0">,</span><span class="s4">2</span><span class="s0">,</span><span class="s4">3</span><span class="s0">,</span><span class="s4">4</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;astype&quot;</span><span class="s0">, </span><span class="s1">[np.complex64</span><span class="s0">, </span><span class="s1">np.complex128])</span>
    <span class="s2"># test to ensure masking and strides work as intended in the AVX implementation</span>
    <span class="s0">def </span><span class="s1">test_array(self</span><span class="s0">, </span><span class="s1">arraysize</span><span class="s0">, </span><span class="s1">stride</span><span class="s0">, </span><span class="s1">astype):</span>
        <span class="s1">arr = np.ones(arraysize</span><span class="s0">, </span><span class="s1">dtype=astype)</span>
        <span class="s1">abs_true = np.ones(arraysize</span><span class="s0">, </span><span class="s1">dtype=arr.real.dtype)</span>
        <span class="s1">assert_equal(np.abs(arr[::stride])</span><span class="s0">, </span><span class="s1">abs_true[::stride])</span>

<span class="s2"># Testcase taken as is from https://github.com/numpy/numpy/issues/16660</span>
<span class="s0">class </span><span class="s1">TestComplexAbsoluteMixedDTypes:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;stride&quot;</span><span class="s0">, </span><span class="s1">[-</span><span class="s4">4</span><span class="s0">,</span><span class="s1">-</span><span class="s4">3</span><span class="s0">,</span><span class="s1">-</span><span class="s4">2</span><span class="s0">,</span><span class="s1">-</span><span class="s4">1</span><span class="s0">,</span><span class="s4">1</span><span class="s0">,</span><span class="s4">2</span><span class="s0">,</span><span class="s4">3</span><span class="s0">,</span><span class="s4">4</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;astype&quot;</span><span class="s0">, </span><span class="s1">[np.complex64</span><span class="s0">, </span><span class="s1">np.complex128])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;func&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">'abs'</span><span class="s0">, </span><span class="s3">'square'</span><span class="s0">, </span><span class="s3">'conjugate'</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_array(self</span><span class="s0">, </span><span class="s1">stride</span><span class="s0">, </span><span class="s1">astype</span><span class="s0">, </span><span class="s1">func):</span>
        <span class="s1">dtype = [(</span><span class="s3">'template_id'</span><span class="s0">, </span><span class="s3">'&lt;i8'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">'bank_chisq'</span><span class="s0">,</span><span class="s3">'&lt;f4'</span><span class="s1">)</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s3">'bank_chisq_dof'</span><span class="s0">,</span><span class="s3">'&lt;i8'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">'chisq'</span><span class="s0">, </span><span class="s3">'&lt;f4'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">'chisq_dof'</span><span class="s0">,</span><span class="s3">'&lt;i8'</span><span class="s1">)</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s3">'cont_chisq'</span><span class="s0">, </span><span class="s3">'&lt;f4'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">'psd_var_val'</span><span class="s0">, </span><span class="s3">'&lt;f4'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">'sg_chisq'</span><span class="s0">,</span><span class="s3">'&lt;f4'</span><span class="s1">)</span><span class="s0">,</span>
                 <span class="s1">(</span><span class="s3">'mycomplex'</span><span class="s0">, </span><span class="s1">astype)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">'time_index'</span><span class="s0">, </span><span class="s3">'&lt;i8'</span><span class="s1">)]</span>
        <span class="s1">vec = np.array([</span>
               <span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">-</span><span class="s4">31.666483</span><span class="s0">, </span><span class="s4">200</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">,  </span><span class="s4">1.      </span><span class="s0">,  </span><span class="s4">3.0</span><span class="s1">+</span><span class="s4">4.0j   </span><span class="s0">,  </span><span class="s4">613090</span><span class="s1">)</span><span class="s0">,</span>
               <span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">260.91525 </span><span class="s0">,  </span><span class="s4">42</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">,  </span><span class="s4">1.      </span><span class="s0">,  </span><span class="s4">5.0</span><span class="s1">+</span><span class="s4">12.0j  </span><span class="s0">,  </span><span class="s4">787315</span><span class="s1">)</span><span class="s0">,</span>
               <span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">0</span><span class="s0">,  </span><span class="s4">52.15155 </span><span class="s0">,  </span><span class="s4">42</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">,  </span><span class="s4">1.      </span><span class="s0">,  </span><span class="s4">8.0</span><span class="s1">+</span><span class="s4">15.0j  </span><span class="s0">,  </span><span class="s4">806641</span><span class="s1">)</span><span class="s0">,</span>
               <span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">0</span><span class="s0">,  </span><span class="s4">52.430195</span><span class="s0">,  </span><span class="s4">42</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">,  </span><span class="s4">1.      </span><span class="s0">,  </span><span class="s4">7.0</span><span class="s1">+</span><span class="s4">24.0j  </span><span class="s0">, </span><span class="s4">1363540</span><span class="s1">)</span><span class="s0">,</span>
               <span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">304.43646 </span><span class="s0">,  </span><span class="s4">58</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">,  </span><span class="s4">1.      </span><span class="s0">,  </span><span class="s4">20.0</span><span class="s1">+</span><span class="s4">21.0j </span><span class="s0">,  </span><span class="s4">787323</span><span class="s1">)</span><span class="s0">,</span>
               <span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">299.42108 </span><span class="s0">,  </span><span class="s4">52</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">,  </span><span class="s4">1.      </span><span class="s0">,  </span><span class="s4">12.0</span><span class="s1">+</span><span class="s4">35.0j </span><span class="s0">,  </span><span class="s4">787332</span><span class="s1">)</span><span class="s0">,</span>
               <span class="s1">(</span><span class="s4">4</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">0</span><span class="s0">,  </span><span class="s4">39.4836  </span><span class="s0">,  </span><span class="s4">28</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">,  </span><span class="s4">9.182192</span><span class="s0">,  </span><span class="s4">9.0</span><span class="s1">+</span><span class="s4">40.0j  </span><span class="s0">,  </span><span class="s4">787304</span><span class="s1">)</span><span class="s0">,</span>
               <span class="s1">(</span><span class="s4">4</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">0</span><span class="s0">,  </span><span class="s4">76.83787 </span><span class="s0">,  </span><span class="s4">28</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">,  </span><span class="s4">1.      </span><span class="s0">,  </span><span class="s4">28.0</span><span class="s1">+</span><span class="s4">45.0j</span><span class="s0">, </span><span class="s4">1321869</span><span class="s1">)</span><span class="s0">,</span>
               <span class="s1">(</span><span class="s4">5</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">143.26366 </span><span class="s0">,  </span><span class="s4">24</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">10.996129</span><span class="s0">,  </span><span class="s4">11.0</span><span class="s1">+</span><span class="s4">60.0j </span><span class="s0">,  </span><span class="s4">787299</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">myfunc = getattr(np</span><span class="s0">, </span><span class="s1">func)</span>
        <span class="s1">a = vec[</span><span class="s3">'mycomplex'</span><span class="s1">]</span>
        <span class="s1">g = myfunc(a[::stride])</span>

        <span class="s1">b = vec[</span><span class="s3">'mycomplex'</span><span class="s1">].copy()</span>
        <span class="s1">h = myfunc(b[::stride])</span>

        <span class="s1">assert_array_max_ulp(h.real</span><span class="s0">, </span><span class="s1">g.real</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_array_max_ulp(h.imag</span><span class="s0">, </span><span class="s1">g.imag</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
</pre>
</body>
</html>