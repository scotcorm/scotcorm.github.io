<html>
<head>
<title>extras.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
extras.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Masked arrays add-ons. 
 
A collection of utilities for `numpy.ma`. 
 
:author: Pierre Gerard-Marchant 
:contact: pierregm_at_uga_dot_edu 
:version: $Id: extras.py 3473 2007-10-29 15:18:13Z jarrod.millman $ 
 
&quot;&quot;&quot;</span>
<span class="s1">__all__ = [</span>
    <span class="s2">'apply_along_axis'</span><span class="s3">, </span><span class="s2">'apply_over_axes'</span><span class="s3">, </span><span class="s2">'atleast_1d'</span><span class="s3">, </span><span class="s2">'atleast_2d'</span><span class="s3">,</span>
    <span class="s2">'atleast_3d'</span><span class="s3">, </span><span class="s2">'average'</span><span class="s3">, </span><span class="s2">'clump_masked'</span><span class="s3">, </span><span class="s2">'clump_unmasked'</span><span class="s3">,</span>
    <span class="s2">'column_stack'</span><span class="s3">, </span><span class="s2">'compress_cols'</span><span class="s3">, </span><span class="s2">'compress_nd'</span><span class="s3">, </span><span class="s2">'compress_rowcols'</span><span class="s3">,</span>
    <span class="s2">'compress_rows'</span><span class="s3">, </span><span class="s2">'count_masked'</span><span class="s3">, </span><span class="s2">'corrcoef'</span><span class="s3">, </span><span class="s2">'cov'</span><span class="s3">, </span><span class="s2">'diagflat'</span><span class="s3">, </span><span class="s2">'dot'</span><span class="s3">,</span>
    <span class="s2">'dstack'</span><span class="s3">, </span><span class="s2">'ediff1d'</span><span class="s3">, </span><span class="s2">'flatnotmasked_contiguous'</span><span class="s3">, </span><span class="s2">'flatnotmasked_edges'</span><span class="s3">,</span>
    <span class="s2">'hsplit'</span><span class="s3">, </span><span class="s2">'hstack'</span><span class="s3">, </span><span class="s2">'isin'</span><span class="s3">, </span><span class="s2">'in1d'</span><span class="s3">, </span><span class="s2">'intersect1d'</span><span class="s3">, </span><span class="s2">'mask_cols'</span><span class="s3">, </span><span class="s2">'mask_rowcols'</span><span class="s3">,</span>
    <span class="s2">'mask_rows'</span><span class="s3">, </span><span class="s2">'masked_all'</span><span class="s3">, </span><span class="s2">'masked_all_like'</span><span class="s3">, </span><span class="s2">'median'</span><span class="s3">, </span><span class="s2">'mr_'</span><span class="s3">,</span>
    <span class="s2">'notmasked_contiguous'</span><span class="s3">, </span><span class="s2">'notmasked_edges'</span><span class="s3">, </span><span class="s2">'polyfit'</span><span class="s3">, </span><span class="s2">'row_stack'</span><span class="s3">,</span>
    <span class="s2">'setdiff1d'</span><span class="s3">, </span><span class="s2">'setxor1d'</span><span class="s3">, </span><span class="s2">'stack'</span><span class="s3">, </span><span class="s2">'unique'</span><span class="s3">, </span><span class="s2">'union1d'</span><span class="s3">, </span><span class="s2">'vander'</span><span class="s3">, </span><span class="s2">'vstack'</span><span class="s3">,</span>
    <span class="s1">]</span>

<span class="s3">import </span><span class="s1">itertools</span>
<span class="s3">import </span><span class="s1">warnings</span>

<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">core </span><span class="s3">as </span><span class="s1">ma</span>
<span class="s3">from </span><span class="s1">.core </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">MaskedArray</span><span class="s3">, </span><span class="s1">MAError</span><span class="s3">, </span><span class="s1">add</span><span class="s3">, </span><span class="s1">array</span><span class="s3">, </span><span class="s1">asarray</span><span class="s3">, </span><span class="s1">concatenate</span><span class="s3">, </span><span class="s1">filled</span><span class="s3">, </span><span class="s1">count</span><span class="s3">,</span>
    <span class="s1">getmask</span><span class="s3">, </span><span class="s1">getmaskarray</span><span class="s3">, </span><span class="s1">make_mask_descr</span><span class="s3">, </span><span class="s1">masked</span><span class="s3">, </span><span class="s1">masked_array</span><span class="s3">, </span><span class="s1">mask_or</span><span class="s3">,</span>
    <span class="s1">nomask</span><span class="s3">, </span><span class="s1">ones</span><span class="s3">, </span><span class="s1">sort</span><span class="s3">, </span><span class="s1">zeros</span><span class="s3">, </span><span class="s1">getdata</span><span class="s3">, </span><span class="s1">get_masked_subclass</span><span class="s3">, </span><span class="s1">dot</span><span class="s3">,</span>
    <span class="s1">mask_rowcols</span>
    <span class="s1">)</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">numpy </span><span class="s3">import </span><span class="s1">ndarray</span><span class="s3">, </span><span class="s1">array </span><span class="s3">as </span><span class="s1">nxarray</span>
<span class="s3">from </span><span class="s1">numpy.core.multiarray </span><span class="s3">import </span><span class="s1">normalize_axis_index</span>
<span class="s3">from </span><span class="s1">numpy.core.numeric </span><span class="s3">import </span><span class="s1">normalize_axis_tuple</span>
<span class="s3">from </span><span class="s1">numpy.lib.function_base </span><span class="s3">import </span><span class="s1">_ureduce</span>
<span class="s3">from </span><span class="s1">numpy.lib.index_tricks </span><span class="s3">import </span><span class="s1">AxisConcatenator</span>


<span class="s3">def </span><span class="s1">issequence(seq):</span>
    <span class="s0">&quot;&quot;&quot; 
    Is seq a sequence (ndarray, list or tuple)? 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">isinstance(seq</span><span class="s3">, </span><span class="s1">(ndarray</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">list))</span>


<span class="s3">def </span><span class="s1">count_masked(arr</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Count the number of masked elements along the given axis. 
 
    Parameters 
    ---------- 
    arr : array_like 
        An array with (possibly) masked elements. 
    axis : int, optional 
        Axis along which to count. If None (default), a flattened 
        version of the array is used. 
 
    Returns 
    ------- 
    count : int, ndarray 
        The total number of masked elements (axis=None) or the number 
        of masked elements along each slice of the given axis. 
 
    See Also 
    -------- 
    MaskedArray.count : Count non-masked elements. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy.ma as ma 
    &gt;&gt;&gt; a = np.arange(9).reshape((3,3)) 
    &gt;&gt;&gt; a = ma.array(a) 
    &gt;&gt;&gt; a[1, 0] = ma.masked 
    &gt;&gt;&gt; a[1, 2] = ma.masked 
    &gt;&gt;&gt; a[2, 1] = ma.masked 
    &gt;&gt;&gt; a 
    masked_array( 
      data=[[0, 1, 2], 
            [--, 4, --], 
            [6, --, 8]], 
      mask=[[False, False, False], 
            [ True, False,  True], 
            [False,  True, False]], 
      fill_value=999999) 
    &gt;&gt;&gt; ma.count_masked(a) 
    3 
 
    When the `axis` keyword is used an array is returned. 
 
    &gt;&gt;&gt; ma.count_masked(a, axis=0) 
    array([1, 1, 1]) 
    &gt;&gt;&gt; ma.count_masked(a, axis=1) 
    array([0, 2, 1]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = getmaskarray(arr)</span>
    <span class="s3">return </span><span class="s1">m.sum(axis)</span>


<span class="s3">def </span><span class="s1">masked_all(shape</span><span class="s3">, </span><span class="s1">dtype=float):</span>
    <span class="s0">&quot;&quot;&quot; 
    Empty masked array with all elements masked. 
 
    Return an empty masked array of the given shape and dtype, where all the 
    data are masked. 
 
    Parameters 
    ---------- 
    shape : tuple 
        Shape of the required MaskedArray. 
    dtype : dtype, optional 
        Data type of the output. 
 
    Returns 
    ------- 
    a : MaskedArray 
        A masked array with all data masked. 
 
    See Also 
    -------- 
    masked_all_like : Empty masked array modelled on an existing array. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy.ma as ma 
    &gt;&gt;&gt; ma.masked_all((3, 3)) 
    masked_array( 
      data=[[--, --, --], 
            [--, --, --], 
            [--, --, --]], 
      mask=[[ True,  True,  True], 
            [ True,  True,  True], 
            [ True,  True,  True]], 
      fill_value=1e+20, 
      dtype=float64) 
 
    The `dtype` parameter defines the underlying data type. 
 
    &gt;&gt;&gt; a = ma.masked_all((3, 3)) 
    &gt;&gt;&gt; a.dtype 
    dtype('float64') 
    &gt;&gt;&gt; a = ma.masked_all((3, 3), dtype=np.int32) 
    &gt;&gt;&gt; a.dtype 
    dtype('int32') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = masked_array(np.empty(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
                     <span class="s1">mask=np.ones(shape</span><span class="s3">, </span><span class="s1">make_mask_descr(dtype)))</span>
    <span class="s3">return </span><span class="s1">a</span>


<span class="s3">def </span><span class="s1">masked_all_like(arr):</span>
    <span class="s0">&quot;&quot;&quot; 
    Empty masked array with the properties of an existing array. 
 
    Return an empty masked array of the same shape and dtype as 
    the array `arr`, where all the data are masked. 
 
    Parameters 
    ---------- 
    arr : ndarray 
        An array describing the shape and dtype of the required MaskedArray. 
 
    Returns 
    ------- 
    a : MaskedArray 
        A masked array with all data masked. 
 
    Raises 
    ------ 
    AttributeError 
        If `arr` doesn't have a shape attribute (i.e. not an ndarray) 
 
    See Also 
    -------- 
    masked_all : Empty masked array with all elements masked. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy.ma as ma 
    &gt;&gt;&gt; arr = np.zeros((2, 3), dtype=np.float32) 
    &gt;&gt;&gt; arr 
    array([[0., 0., 0.], 
           [0., 0., 0.]], dtype=float32) 
    &gt;&gt;&gt; ma.masked_all_like(arr) 
    masked_array( 
      data=[[--, --, --], 
            [--, --, --]], 
      mask=[[ True,  True,  True], 
            [ True,  True,  True]], 
      fill_value=1e+20, 
      dtype=float32) 
 
    The dtype of the masked array matches the dtype of `arr`. 
 
    &gt;&gt;&gt; arr.dtype 
    dtype('float32') 
    &gt;&gt;&gt; ma.masked_all_like(arr).dtype 
    dtype('float32') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = np.empty_like(arr).view(MaskedArray)</span>
    <span class="s1">a._mask = np.ones(a.shape</span><span class="s3">, </span><span class="s1">dtype=make_mask_descr(a.dtype))</span>
    <span class="s3">return </span><span class="s1">a</span>


<span class="s4">#####--------------------------------------------------------------------------</span>
<span class="s4">#---- --- Standard functions ---</span>
<span class="s4">#####--------------------------------------------------------------------------</span>
<span class="s3">class </span><span class="s1">_fromnxfunction:</span>
    <span class="s0">&quot;&quot;&quot; 
    Defines a wrapper to adapt NumPy functions to masked arrays. 
 
 
    An instance of `_fromnxfunction` can be called with the same parameters 
    as the wrapped NumPy function. The docstring of `newfunc` is adapted from 
    the wrapped function as well, see `getdoc`. 
 
    This class should not be used directly. Instead, one of its extensions that 
    provides support for a specific type of input should be used. 
 
    Parameters 
    ---------- 
    funcname : str 
        The name of the function to be adapted. The function should be 
        in the NumPy namespace (i.e. ``np.funcname``). 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">funcname):</span>
        <span class="s1">self.__name__ = funcname</span>
        <span class="s1">self.__doc__ = self.getdoc()</span>

    <span class="s3">def </span><span class="s1">getdoc(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Retrieve the docstring and signature from the function. 
 
        The ``__doc__`` attribute of the function is used as the docstring for 
        the new masked array version of the function. A note on application 
        of the function to the mask is appended. 
 
        Parameters 
        ---------- 
        None 
 
        &quot;&quot;&quot;</span>
        <span class="s1">npfunc = getattr(np</span><span class="s3">, </span><span class="s1">self.__name__</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">doc = getattr(npfunc</span><span class="s3">, </span><span class="s2">'__doc__'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">doc:</span>
            <span class="s1">sig = self.__name__ + ma.get_object_signature(npfunc)</span>
            <span class="s1">doc = ma.doc_note(doc</span><span class="s3">, </span><span class="s2">&quot;The function is applied to both the _data &quot;</span>
                                   <span class="s2">&quot;and the _mask, if any.&quot;</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s2">'</span><span class="s3">\n\n</span><span class="s2">'</span><span class="s1">.join((sig</span><span class="s3">, </span><span class="s1">doc))</span>
        <span class="s3">return</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**params):</span>
        <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">_fromnxfunction_single(_fromnxfunction):</span>
    <span class="s0">&quot;&quot;&quot; 
    A version of `_fromnxfunction` that is called with a single array 
    argument followed by auxiliary args that are passed verbatim for 
    both the data and mask calls. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**params):</span>
        <span class="s1">func = getattr(np</span><span class="s3">, </span><span class="s1">self.__name__)</span>
        <span class="s3">if </span><span class="s1">isinstance(x</span><span class="s3">, </span><span class="s1">ndarray):</span>
            <span class="s1">_d = func(x.__array__()</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**params)</span>
            <span class="s1">_m = func(getmaskarray(x)</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**params)</span>
            <span class="s3">return </span><span class="s1">masked_array(_d</span><span class="s3">, </span><span class="s1">mask=_m)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">_d = func(np.asarray(x)</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**params)</span>
            <span class="s1">_m = func(getmaskarray(x)</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**params)</span>
            <span class="s3">return </span><span class="s1">masked_array(_d</span><span class="s3">, </span><span class="s1">mask=_m)</span>


<span class="s3">class </span><span class="s1">_fromnxfunction_seq(_fromnxfunction):</span>
    <span class="s0">&quot;&quot;&quot; 
    A version of `_fromnxfunction` that is called with a single sequence 
    of arrays followed by auxiliary args that are passed verbatim for 
    both the data and mask calls. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**params):</span>
        <span class="s1">func = getattr(np</span><span class="s3">, </span><span class="s1">self.__name__)</span>
        <span class="s1">_d = func(tuple([np.asarray(a) </span><span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">x])</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**params)</span>
        <span class="s1">_m = func(tuple([getmaskarray(a) </span><span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">x])</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**params)</span>
        <span class="s3">return </span><span class="s1">masked_array(_d</span><span class="s3">, </span><span class="s1">mask=_m)</span>


<span class="s3">class </span><span class="s1">_fromnxfunction_args(_fromnxfunction):</span>
    <span class="s0">&quot;&quot;&quot; 
    A version of `_fromnxfunction` that is called with multiple array 
    arguments. The first non-array-like input marks the beginning of the 
    arguments that are passed verbatim for both the data and mask calls. 
    Array arguments are processed independently and the results are 
    returned in a list. If only one array is found, the return value is 
    just the processed array instead of a list. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**params):</span>
        <span class="s1">func = getattr(np</span><span class="s3">, </span><span class="s1">self.__name__)</span>
        <span class="s1">arrays = []</span>
        <span class="s1">args = list(args)</span>
        <span class="s3">while </span><span class="s1">len(args) &gt; </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">issequence(args[</span><span class="s5">0</span><span class="s1">]):</span>
            <span class="s1">arrays.append(args.pop(</span><span class="s5">0</span><span class="s1">))</span>
        <span class="s1">res = []</span>
        <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">arrays:</span>
            <span class="s1">_d = func(np.asarray(x)</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**params)</span>
            <span class="s1">_m = func(getmaskarray(x)</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**params)</span>
            <span class="s1">res.append(masked_array(_d</span><span class="s3">, </span><span class="s1">mask=_m))</span>
        <span class="s3">if </span><span class="s1">len(arrays) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">res[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">return </span><span class="s1">res</span>


<span class="s3">class </span><span class="s1">_fromnxfunction_allargs(_fromnxfunction):</span>
    <span class="s0">&quot;&quot;&quot; 
    A version of `_fromnxfunction` that is called with multiple array 
    arguments. Similar to `_fromnxfunction_args` except that all args 
    are converted to arrays even if they are not so already. This makes 
    it possible to process scalars as 1-D arrays. Only keyword arguments 
    are passed through verbatim for the data and mask calls. Arrays 
    arguments are processed independently and the results are returned 
    in a list. If only one arg is present, the return value is just the 
    processed array instead of a list. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**params):</span>
        <span class="s1">func = getattr(np</span><span class="s3">, </span><span class="s1">self.__name__)</span>
        <span class="s1">res = []</span>
        <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">args:</span>
            <span class="s1">_d = func(np.asarray(x)</span><span class="s3">, </span><span class="s1">**params)</span>
            <span class="s1">_m = func(getmaskarray(x)</span><span class="s3">, </span><span class="s1">**params)</span>
            <span class="s1">res.append(masked_array(_d</span><span class="s3">, </span><span class="s1">mask=_m))</span>
        <span class="s3">if </span><span class="s1">len(args) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">res[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">return </span><span class="s1">res</span>


<span class="s1">atleast_1d = _fromnxfunction_allargs(</span><span class="s2">'atleast_1d'</span><span class="s1">)</span>
<span class="s1">atleast_2d = _fromnxfunction_allargs(</span><span class="s2">'atleast_2d'</span><span class="s1">)</span>
<span class="s1">atleast_3d = _fromnxfunction_allargs(</span><span class="s2">'atleast_3d'</span><span class="s1">)</span>

<span class="s1">vstack = row_stack = _fromnxfunction_seq(</span><span class="s2">'vstack'</span><span class="s1">)</span>
<span class="s1">hstack = _fromnxfunction_seq(</span><span class="s2">'hstack'</span><span class="s1">)</span>
<span class="s1">column_stack = _fromnxfunction_seq(</span><span class="s2">'column_stack'</span><span class="s1">)</span>
<span class="s1">dstack = _fromnxfunction_seq(</span><span class="s2">'dstack'</span><span class="s1">)</span>
<span class="s1">stack = _fromnxfunction_seq(</span><span class="s2">'stack'</span><span class="s1">)</span>

<span class="s1">hsplit = _fromnxfunction_single(</span><span class="s2">'hsplit'</span><span class="s1">)</span>

<span class="s1">diagflat = _fromnxfunction_single(</span><span class="s2">'diagflat'</span><span class="s1">)</span>


<span class="s4">#####--------------------------------------------------------------------------</span>
<span class="s4">#----</span>
<span class="s4">#####--------------------------------------------------------------------------</span>
<span class="s3">def </span><span class="s1">flatten_inplace(seq):</span>
    <span class="s0">&quot;&quot;&quot;Flatten a sequence in place.&quot;&quot;&quot;</span>
    <span class="s1">k = </span><span class="s5">0</span>
    <span class="s3">while </span><span class="s1">(k != len(seq)):</span>
        <span class="s3">while </span><span class="s1">hasattr(seq[k]</span><span class="s3">, </span><span class="s2">'__iter__'</span><span class="s1">):</span>
            <span class="s1">seq[k:(k + </span><span class="s5">1</span><span class="s1">)] = seq[k]</span>
        <span class="s1">k += </span><span class="s5">1</span>
    <span class="s3">return </span><span class="s1">seq</span>


<span class="s3">def </span><span class="s1">apply_along_axis(func1d</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    (This docstring should be overwritten) 
    &quot;&quot;&quot;</span>
    <span class="s1">arr = array(arr</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False, </span><span class="s1">subok=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">nd = arr.ndim</span>
    <span class="s1">axis = normalize_axis_index(axis</span><span class="s3">, </span><span class="s1">nd)</span>
    <span class="s1">ind = [</span><span class="s5">0</span><span class="s1">] * (nd - </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">i = np.zeros(nd</span><span class="s3">, </span><span class="s2">'O'</span><span class="s1">)</span>
    <span class="s1">indlist = list(range(nd))</span>
    <span class="s1">indlist.remove(axis)</span>
    <span class="s1">i[axis] = slice(</span><span class="s3">None, None</span><span class="s1">)</span>
    <span class="s1">outshape = np.asarray(arr.shape).take(indlist)</span>
    <span class="s1">i.put(indlist</span><span class="s3">, </span><span class="s1">ind)</span>
    <span class="s1">res = func1d(arr[tuple(i.tolist())]</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
    <span class="s4">#  if res is a number, then we have a smaller output array</span>
    <span class="s1">asscalar = np.isscalar(res)</span>
    <span class="s3">if not </span><span class="s1">asscalar:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">len(res)</span>
        <span class="s3">except </span><span class="s1">TypeError:</span>
            <span class="s1">asscalar = </span><span class="s3">True</span>
    <span class="s4"># Note: we shouldn't set the dtype of the output from the first result</span>
    <span class="s4"># so we force the type to object, and build a list of dtypes.  We'll</span>
    <span class="s4"># just take the largest, to avoid some downcasting</span>
    <span class="s1">dtypes = []</span>
    <span class="s3">if </span><span class="s1">asscalar:</span>
        <span class="s1">dtypes.append(np.asarray(res).dtype)</span>
        <span class="s1">outarr = zeros(outshape</span><span class="s3">, </span><span class="s1">object)</span>
        <span class="s1">outarr[tuple(ind)] = res</span>
        <span class="s1">Ntot = np.product(outshape)</span>
        <span class="s1">k = </span><span class="s5">1</span>
        <span class="s3">while </span><span class="s1">k &lt; Ntot:</span>
            <span class="s4"># increment the index</span>
            <span class="s1">ind[-</span><span class="s5">1</span><span class="s1">] += </span><span class="s5">1</span>
            <span class="s1">n = -</span><span class="s5">1</span>
            <span class="s3">while </span><span class="s1">(ind[n] &gt;= outshape[n]) </span><span class="s3">and </span><span class="s1">(n &gt; (</span><span class="s5">1 </span><span class="s1">- nd)):</span>
                <span class="s1">ind[n - </span><span class="s5">1</span><span class="s1">] += </span><span class="s5">1</span>
                <span class="s1">ind[n] = </span><span class="s5">0</span>
                <span class="s1">n -= </span><span class="s5">1</span>
            <span class="s1">i.put(indlist</span><span class="s3">, </span><span class="s1">ind)</span>
            <span class="s1">res = func1d(arr[tuple(i.tolist())]</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
            <span class="s1">outarr[tuple(ind)] = res</span>
            <span class="s1">dtypes.append(asarray(res).dtype)</span>
            <span class="s1">k += </span><span class="s5">1</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">res = array(res</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False, </span><span class="s1">subok=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">j = i.copy()</span>
        <span class="s1">j[axis] = ([slice(</span><span class="s3">None, None</span><span class="s1">)] * res.ndim)</span>
        <span class="s1">j.put(indlist</span><span class="s3">, </span><span class="s1">ind)</span>
        <span class="s1">Ntot = np.product(outshape)</span>
        <span class="s1">holdshape = outshape</span>
        <span class="s1">outshape = list(arr.shape)</span>
        <span class="s1">outshape[axis] = res.shape</span>
        <span class="s1">dtypes.append(asarray(res).dtype)</span>
        <span class="s1">outshape = flatten_inplace(outshape)</span>
        <span class="s1">outarr = zeros(outshape</span><span class="s3">, </span><span class="s1">object)</span>
        <span class="s1">outarr[tuple(flatten_inplace(j.tolist()))] = res</span>
        <span class="s1">k = </span><span class="s5">1</span>
        <span class="s3">while </span><span class="s1">k &lt; Ntot:</span>
            <span class="s4"># increment the index</span>
            <span class="s1">ind[-</span><span class="s5">1</span><span class="s1">] += </span><span class="s5">1</span>
            <span class="s1">n = -</span><span class="s5">1</span>
            <span class="s3">while </span><span class="s1">(ind[n] &gt;= holdshape[n]) </span><span class="s3">and </span><span class="s1">(n &gt; (</span><span class="s5">1 </span><span class="s1">- nd)):</span>
                <span class="s1">ind[n - </span><span class="s5">1</span><span class="s1">] += </span><span class="s5">1</span>
                <span class="s1">ind[n] = </span><span class="s5">0</span>
                <span class="s1">n -= </span><span class="s5">1</span>
            <span class="s1">i.put(indlist</span><span class="s3">, </span><span class="s1">ind)</span>
            <span class="s1">j.put(indlist</span><span class="s3">, </span><span class="s1">ind)</span>
            <span class="s1">res = func1d(arr[tuple(i.tolist())]</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
            <span class="s1">outarr[tuple(flatten_inplace(j.tolist()))] = res</span>
            <span class="s1">dtypes.append(asarray(res).dtype)</span>
            <span class="s1">k += </span><span class="s5">1</span>
    <span class="s1">max_dtypes = np.dtype(np.asarray(dtypes).max())</span>
    <span class="s3">if not </span><span class="s1">hasattr(arr</span><span class="s3">, </span><span class="s2">'_mask'</span><span class="s1">):</span>
        <span class="s1">result = np.asarray(outarr</span><span class="s3">, </span><span class="s1">dtype=max_dtypes)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">result = asarray(outarr</span><span class="s3">, </span><span class="s1">dtype=max_dtypes)</span>
        <span class="s1">result.fill_value = ma.default_fill_value(result)</span>
    <span class="s3">return </span><span class="s1">result</span>
<span class="s1">apply_along_axis.__doc__ = np.apply_along_axis.__doc__</span>


<span class="s3">def </span><span class="s1">apply_over_axes(func</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">axes):</span>
    <span class="s0">&quot;&quot;&quot; 
    (This docstring will be overwritten) 
    &quot;&quot;&quot;</span>
    <span class="s1">val = asarray(a)</span>
    <span class="s1">N = a.ndim</span>
    <span class="s3">if </span><span class="s1">array(axes).ndim == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">axes = (axes</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s3">for </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">axes:</span>
        <span class="s3">if </span><span class="s1">axis &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">axis = N + axis</span>
        <span class="s1">args = (val</span><span class="s3">, </span><span class="s1">axis)</span>
        <span class="s1">res = func(*args)</span>
        <span class="s3">if </span><span class="s1">res.ndim == val.ndim:</span>
            <span class="s1">val = res</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">res = ma.expand_dims(res</span><span class="s3">, </span><span class="s1">axis)</span>
            <span class="s3">if </span><span class="s1">res.ndim == val.ndim:</span>
                <span class="s1">val = res</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;function is not returning &quot;</span>
                        <span class="s2">&quot;an array of the correct shape&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">val</span>

<span class="s3">if </span><span class="s1">apply_over_axes.__doc__ </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">apply_over_axes.__doc__ = np.apply_over_axes.__doc__[</span>
        <span class="s1">:np.apply_over_axes.__doc__.find(</span><span class="s2">'Notes'</span><span class="s1">)].rstrip() + \</span>
    <span class="s2">&quot;&quot;&quot; 
 
    Examples 
    -------- 
    &gt;&gt;&gt; a = np.ma.arange(24).reshape(2,3,4) 
    &gt;&gt;&gt; a[:,0,1] = np.ma.masked 
    &gt;&gt;&gt; a[:,1,:] = np.ma.masked 
    &gt;&gt;&gt; a 
    masked_array( 
      data=[[[0, --, 2, 3], 
             [--, --, --, --], 
             [8, 9, 10, 11]], 
            [[12, --, 14, 15], 
             [--, --, --, --], 
             [20, 21, 22, 23]]], 
      mask=[[[False,  True, False, False], 
             [ True,  True,  True,  True], 
             [False, False, False, False]], 
            [[False,  True, False, False], 
             [ True,  True,  True,  True], 
             [False, False, False, False]]], 
      fill_value=999999) 
    &gt;&gt;&gt; np.ma.apply_over_axes(np.ma.sum, a, [0,2]) 
    masked_array( 
      data=[[[46], 
             [--], 
             [124]]], 
      mask=[[[False], 
             [ True], 
             [False]]], 
      fill_value=999999) 
 
    Tuple axis arguments to ufuncs are equivalent: 
 
    &gt;&gt;&gt; np.ma.sum(a, axis=(0,2)).reshape((1,-1,1)) 
    masked_array( 
      data=[[[46], 
             [--], 
             [124]]], 
      mask=[[[False], 
             [ True], 
             [False]]], 
      fill_value=999999) 
    &quot;&quot;&quot;</span>


<span class="s3">def </span><span class="s1">average(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None, </span><span class="s1">weights=</span><span class="s3">None, </span><span class="s1">returned=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the weighted average of array over the given axis. 
 
    Parameters 
    ---------- 
    a : array_like 
        Data to be averaged. 
        Masked entries are not taken into account in the computation. 
    axis : int, optional 
        Axis along which to average `a`. If None, averaging is done over 
        the flattened array. 
    weights : array_like, optional 
        The importance that each element has in the computation of the average. 
        The weights array can either be 1-D (in which case its length must be 
        the size of `a` along the given axis) or of the same shape as `a`. 
        If ``weights=None``, then all data in `a` are assumed to have a 
        weight equal to one.  The 1-D calculation is:: 
 
            avg = sum(a * weights) / sum(weights) 
 
        The only constraint on `weights` is that `sum(weights)` must not be 0. 
    returned : bool, optional 
        Flag indicating whether a tuple ``(result, sum of weights)`` 
        should be returned as output (True), or just the result (False). 
        Default is False. 
 
    Returns 
    ------- 
    average, [sum_of_weights] : (tuple of) scalar or MaskedArray 
        The average along the specified axis. When returned is `True`, 
        return a tuple with the average as the first element and the sum 
        of the weights as the second element. The return type is `np.float64` 
        if `a` is of integer type and floats smaller than `float64`, or the 
        input data-type, otherwise. If returned, `sum_of_weights` is always 
        `float64`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True]) 
    &gt;&gt;&gt; np.ma.average(a, weights=[3, 1, 0, 0]) 
    1.25 
 
    &gt;&gt;&gt; x = np.ma.arange(6.).reshape(3, 2) 
    &gt;&gt;&gt; x 
    masked_array( 
      data=[[0., 1.], 
            [2., 3.], 
            [4., 5.]], 
      mask=False, 
      fill_value=1e+20) 
    &gt;&gt;&gt; avg, sumweights = np.ma.average(x, axis=0, weights=[1, 2, 3], 
    ...                                 returned=True) 
    &gt;&gt;&gt; avg 
    masked_array(data=[2.6666666666666665, 3.6666666666666665], 
                 mask=[False, False], 
           fill_value=1e+20) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = asarray(a)</span>
    <span class="s1">m = getmask(a)</span>

    <span class="s4"># inspired by 'average' in numpy/lib/function_base.py</span>

    <span class="s3">if </span><span class="s1">weights </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">avg = a.mean(axis)</span>
        <span class="s1">scl = avg.dtype.type(a.count(axis))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">wgt = np.asanyarray(weights)</span>

        <span class="s3">if </span><span class="s1">issubclass(a.dtype.type</span><span class="s3">, </span><span class="s1">(np.integer</span><span class="s3">, </span><span class="s1">np.bool_)):</span>
            <span class="s1">result_dtype = np.result_type(a.dtype</span><span class="s3">, </span><span class="s1">wgt.dtype</span><span class="s3">, </span><span class="s2">'f8'</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">result_dtype = np.result_type(a.dtype</span><span class="s3">, </span><span class="s1">wgt.dtype)</span>

        <span class="s4"># Sanity checks</span>
        <span class="s3">if </span><span class="s1">a.shape != wgt.shape:</span>
            <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span>
                    <span class="s2">&quot;Axis must be specified when shapes of a and weights &quot;</span>
                    <span class="s2">&quot;differ.&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">wgt.ndim != </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span>
                    <span class="s2">&quot;1D weights expected when shapes of a and weights differ.&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">wgt.shape[</span><span class="s5">0</span><span class="s1">] != a.shape[axis]:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">&quot;Length of weights not compatible with specified axis.&quot;</span><span class="s1">)</span>

            <span class="s4"># setup wgt to broadcast along axis</span>
            <span class="s1">wgt = np.broadcast_to(wgt</span><span class="s3">, </span><span class="s1">(a.ndim-</span><span class="s5">1</span><span class="s1">)*(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">) + wgt.shape</span><span class="s3">, </span><span class="s1">subok=</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s1">wgt = wgt.swapaxes(-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis)</span>

        <span class="s3">if </span><span class="s1">m </span><span class="s3">is not </span><span class="s1">nomask:</span>
            <span class="s1">wgt = wgt*(~a.mask)</span>

        <span class="s1">scl = wgt.sum(axis=axis</span><span class="s3">, </span><span class="s1">dtype=result_dtype)</span>
        <span class="s1">avg = np.multiply(a</span><span class="s3">, </span><span class="s1">wgt</span><span class="s3">, </span><span class="s1">dtype=result_dtype).sum(axis)/scl</span>

    <span class="s3">if </span><span class="s1">returned:</span>
        <span class="s3">if </span><span class="s1">scl.shape != avg.shape:</span>
            <span class="s1">scl = np.broadcast_to(scl</span><span class="s3">, </span><span class="s1">avg.shape).copy()</span>
        <span class="s3">return </span><span class="s1">avg</span><span class="s3">, </span><span class="s1">scl</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">avg</span>


<span class="s3">def </span><span class="s1">median(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None, </span><span class="s1">out=</span><span class="s3">None, </span><span class="s1">overwrite_input=</span><span class="s3">False, </span><span class="s1">keepdims=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the median along the specified axis. 
 
    Returns the median of the array elements. 
 
    Parameters 
    ---------- 
    a : array_like 
        Input array or object that can be converted to an array. 
    axis : int, optional 
        Axis along which the medians are computed. The default (None) is 
        to compute the median along a flattened version of the array. 
    out : ndarray, optional 
        Alternative output array in which to place the result. It must 
        have the same shape and buffer length as the expected output 
        but the type will be cast if necessary. 
    overwrite_input : bool, optional 
        If True, then allow use of memory of input array (a) for 
        calculations. The input array will be modified by the call to 
        median. This will save memory when you do not need to preserve 
        the contents of the input array. Treat the input as undefined, 
        but it will probably be fully or partially sorted. Default is 
        False. Note that, if `overwrite_input` is True, and the input 
        is not already an `ndarray`, an error will be raised. 
    keepdims : bool, optional 
        If this is set to True, the axes which are reduced are left 
        in the result as dimensions with size one. With this option, 
        the result will broadcast correctly against the input array. 
 
        .. versionadded:: 1.10.0 
 
    Returns 
    ------- 
    median : ndarray 
        A new array holding the result is returned unless out is 
        specified, in which case a reference to out is returned. 
        Return data-type is `float64` for integers and floats smaller than 
        `float64`, or the input data-type, otherwise. 
 
    See Also 
    -------- 
    mean 
 
    Notes 
    ----- 
    Given a vector ``V`` with ``N`` non masked values, the median of ``V`` 
    is the middle value of a sorted copy of ``V`` (``Vs``) - i.e. 
    ``Vs[(N-1)/2]``, when ``N`` is odd, or ``{Vs[N/2 - 1] + Vs[N/2]}/2`` 
    when ``N`` is even. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4) 
    &gt;&gt;&gt; np.ma.median(x) 
    1.5 
 
    &gt;&gt;&gt; x = np.ma.array(np.arange(10).reshape(2, 5), mask=[0]*6 + [1]*4) 
    &gt;&gt;&gt; np.ma.median(x) 
    2.5 
    &gt;&gt;&gt; np.ma.median(x, axis=-1, overwrite_input=True) 
    masked_array(data=[2.0, 5.0], 
                 mask=[False, False], 
           fill_value=1e+20) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">hasattr(a</span><span class="s3">, </span><span class="s2">'mask'</span><span class="s1">):</span>
        <span class="s1">m = np.median(getdata(a</span><span class="s3">, </span><span class="s1">subok=</span><span class="s3">True</span><span class="s1">)</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">,</span>
                      <span class="s1">out=out</span><span class="s3">, </span><span class="s1">overwrite_input=overwrite_input</span><span class="s3">,</span>
                      <span class="s1">keepdims=keepdims)</span>
        <span class="s3">if </span><span class="s1">isinstance(m</span><span class="s3">, </span><span class="s1">np.ndarray) </span><span class="s3">and </span><span class="s5">1 </span><span class="s1">&lt;= m.ndim:</span>
            <span class="s3">return </span><span class="s1">masked_array(m</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">m</span>

    <span class="s1">r</span><span class="s3">, </span><span class="s1">k = _ureduce(a</span><span class="s3">, </span><span class="s1">func=_median</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">out=out</span><span class="s3">,</span>
                    <span class="s1">overwrite_input=overwrite_input)</span>
    <span class="s3">if </span><span class="s1">keepdims:</span>
        <span class="s3">return </span><span class="s1">r.reshape(k)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">r</span>

<span class="s3">def </span><span class="s1">_median(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None, </span><span class="s1">out=</span><span class="s3">None, </span><span class="s1">overwrite_input=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s4"># when an unmasked NaN is present return it, so we need to sort the NaN</span>
    <span class="s4"># values behind the mask</span>
    <span class="s3">if </span><span class="s1">np.issubdtype(a.dtype</span><span class="s3">, </span><span class="s1">np.inexact):</span>
        <span class="s1">fill_value = np.inf</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">fill_value = </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">overwrite_input:</span>
        <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">asorted = a.ravel()</span>
            <span class="s1">asorted.sort(fill_value=fill_value)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">a.sort(axis=axis</span><span class="s3">, </span><span class="s1">fill_value=fill_value)</span>
            <span class="s1">asorted = a</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">asorted = sort(a</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">fill_value=fill_value)</span>

    <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">axis = </span><span class="s5">0</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">axis = normalize_axis_index(axis</span><span class="s3">, </span><span class="s1">asorted.ndim)</span>

    <span class="s3">if </span><span class="s1">asorted.shape[axis] == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s4"># for empty axis integer indices fail so use slicing to get same result</span>
        <span class="s4"># as median (which is mean of empty slice = nan)</span>
        <span class="s1">indexer = [slice(</span><span class="s3">None</span><span class="s1">)] * asorted.ndim</span>
        <span class="s1">indexer[axis] = slice(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">indexer = tuple(indexer)</span>
        <span class="s3">return </span><span class="s1">np.ma.mean(asorted[indexer]</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">out=out)</span>

    <span class="s3">if </span><span class="s1">asorted.ndim == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">idx</span><span class="s3">, </span><span class="s1">odd = divmod(count(asorted)</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">mid = asorted[idx + odd - </span><span class="s5">1</span><span class="s1">:idx + </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">np.issubdtype(asorted.dtype</span><span class="s3">, </span><span class="s1">np.inexact) </span><span class="s3">and </span><span class="s1">asorted.size &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4"># avoid inf / x = masked</span>
            <span class="s1">s = mid.sum(out=out)</span>
            <span class="s3">if not </span><span class="s1">odd:</span>
                <span class="s1">s = np.true_divide(s</span><span class="s3">, </span><span class="s5">2.</span><span class="s3">, </span><span class="s1">casting=</span><span class="s2">'safe'</span><span class="s3">, </span><span class="s1">out=out)</span>
            <span class="s1">s = np.lib.utils._median_nancheck(asorted</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">axis)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">s = mid.mean(out=out)</span>

        <span class="s4"># if result is masked either the input contained enough</span>
        <span class="s4"># minimum_fill_value so that it would be the median or all values</span>
        <span class="s4"># masked</span>
        <span class="s3">if </span><span class="s1">np.ma.is_masked(s) </span><span class="s3">and not </span><span class="s1">np.all(asorted.mask):</span>
            <span class="s3">return </span><span class="s1">np.ma.minimum_fill_value(asorted)</span>
        <span class="s3">return </span><span class="s1">s</span>

    <span class="s1">counts = count(asorted</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">h = counts // </span><span class="s5">2</span>

    <span class="s4"># duplicate high if odd number of elements so mean does nothing</span>
    <span class="s1">odd = counts % </span><span class="s5">2 </span><span class="s1">== </span><span class="s5">1</span>
    <span class="s1">l = np.where(odd</span><span class="s3">, </span><span class="s1">h</span><span class="s3">, </span><span class="s1">h-</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">lh = np.concatenate([l</span><span class="s3">,</span><span class="s1">h]</span><span class="s3">, </span><span class="s1">axis=axis)</span>

    <span class="s4"># get low and high median</span>
    <span class="s1">low_high = np.take_along_axis(asorted</span><span class="s3">, </span><span class="s1">lh</span><span class="s3">, </span><span class="s1">axis=axis)</span>

    <span class="s3">def </span><span class="s1">replace_masked(s):</span>
        <span class="s4"># Replace masked entries with minimum_full_value unless it all values</span>
        <span class="s4"># are masked. This is required as the sort order of values equal or</span>
        <span class="s4"># larger than the fill value is undefined and a valid value placed</span>
        <span class="s4"># elsewhere, e.g. [4, --, inf].</span>
        <span class="s3">if </span><span class="s1">np.ma.is_masked(s):</span>
            <span class="s1">rep = (~np.all(asorted.mask</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">True</span><span class="s1">)) &amp; s.mask</span>
            <span class="s1">s.data[rep] = np.ma.minimum_fill_value(asorted)</span>
            <span class="s1">s.mask[rep] = </span><span class="s3">False</span>

    <span class="s1">replace_masked(low_high)</span>

    <span class="s3">if </span><span class="s1">np.issubdtype(asorted.dtype</span><span class="s3">, </span><span class="s1">np.inexact):</span>
        <span class="s4"># avoid inf / x = masked</span>
        <span class="s1">s = np.ma.sum(low_high</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">out=out)</span>
        <span class="s1">np.true_divide(s.data</span><span class="s3">, </span><span class="s5">2.</span><span class="s3">, </span><span class="s1">casting=</span><span class="s2">'unsafe'</span><span class="s3">, </span><span class="s1">out=s.data)</span>

        <span class="s1">s = np.lib.utils._median_nancheck(asorted</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">axis)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">s = np.ma.mean(low_high</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">out=out)</span>

    <span class="s3">return </span><span class="s1">s</span>


<span class="s3">def </span><span class="s1">compress_nd(x</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Suppress slices from multiple dimensions which contain masked values. 
 
    Parameters 
    ---------- 
    x : array_like, MaskedArray 
        The array to operate on. If not a MaskedArray instance (or if no array 
        elements are masked), `x` is interpreted as a MaskedArray with `mask` 
        set to `nomask`. 
    axis : tuple of ints or int, optional 
        Which dimensions to suppress slices from can be configured with this 
        parameter. 
        - If axis is a tuple of ints, those are the axes to suppress slices from. 
        - If axis is an int, then that is the only axis to suppress slices from. 
        - If axis is None, all axis are selected. 
 
    Returns 
    ------- 
    compress_array : ndarray 
        The compressed array. 
    &quot;&quot;&quot;</span>
    <span class="s1">x = asarray(x)</span>
    <span class="s1">m = getmask(x)</span>
    <span class="s4"># Set axis to tuple of ints</span>
    <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">axis = tuple(range(x.ndim))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">axis = normalize_axis_tuple(axis</span><span class="s3">, </span><span class="s1">x.ndim)</span>

    <span class="s4"># Nothing is masked: return x</span>
    <span class="s3">if </span><span class="s1">m </span><span class="s3">is </span><span class="s1">nomask </span><span class="s3">or not </span><span class="s1">m.any():</span>
        <span class="s3">return </span><span class="s1">x._data</span>
    <span class="s4"># All is masked: return empty</span>
    <span class="s3">if </span><span class="s1">m.all():</span>
        <span class="s3">return </span><span class="s1">nxarray([])</span>
    <span class="s4"># Filter elements through boolean indexing</span>
    <span class="s1">data = x._data</span>
    <span class="s3">for </span><span class="s1">ax </span><span class="s3">in </span><span class="s1">axis:</span>
        <span class="s1">axes = tuple(list(range(ax)) + list(range(ax + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">x.ndim)))</span>
        <span class="s1">data = data[(slice(</span><span class="s3">None</span><span class="s1">)</span><span class="s3">,</span><span class="s1">)*ax + (~m.any(axis=axes)</span><span class="s3">,</span><span class="s1">)]</span>
    <span class="s3">return </span><span class="s1">data</span>

<span class="s3">def </span><span class="s1">compress_rowcols(x</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Suppress the rows and/or columns of a 2-D array that contain 
    masked values. 
 
    The suppression behavior is selected with the `axis` parameter. 
 
    - If axis is None, both rows and columns are suppressed. 
    - If axis is 0, only rows are suppressed. 
    - If axis is 1 or -1, only columns are suppressed. 
 
    Parameters 
    ---------- 
    x : array_like, MaskedArray 
        The array to operate on.  If not a MaskedArray instance (or if no array 
        elements are masked), `x` is interpreted as a MaskedArray with 
        `mask` set to `nomask`. Must be a 2D array. 
    axis : int, optional 
        Axis along which to perform the operation. Default is None. 
 
    Returns 
    ------- 
    compressed_array : ndarray 
        The compressed array. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0], 
    ...                                                   [1, 0, 0], 
    ...                                                   [0, 0, 0]]) 
    &gt;&gt;&gt; x 
    masked_array( 
      data=[[--, 1, 2], 
            [--, 4, 5], 
            [6, 7, 8]], 
      mask=[[ True, False, False], 
            [ True, False, False], 
            [False, False, False]], 
      fill_value=999999) 
 
    &gt;&gt;&gt; np.ma.compress_rowcols(x) 
    array([[7, 8]]) 
    &gt;&gt;&gt; np.ma.compress_rowcols(x, 0) 
    array([[6, 7, 8]]) 
    &gt;&gt;&gt; np.ma.compress_rowcols(x, 1) 
    array([[1, 2], 
           [4, 5], 
           [7, 8]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">asarray(x).ndim != </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;compress_rowcols works for 2D arrays only.&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">compress_nd(x</span><span class="s3">, </span><span class="s1">axis=axis)</span>


<span class="s3">def </span><span class="s1">compress_rows(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Suppress whole rows of a 2-D array that contain masked values. 
 
    This is equivalent to ``np.ma.compress_rowcols(a, 0)``, see 
    `compress_rowcols` for details. 
 
    See Also 
    -------- 
    compress_rowcols 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = asarray(a)</span>
    <span class="s3">if </span><span class="s1">a.ndim != </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;compress_rows works for 2D arrays only.&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">compress_rowcols(a</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">compress_cols(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Suppress whole columns of a 2-D array that contain masked values. 
 
    This is equivalent to ``np.ma.compress_rowcols(a, 1)``, see 
    `compress_rowcols` for details. 
 
    See Also 
    -------- 
    compress_rowcols 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = asarray(a)</span>
    <span class="s3">if </span><span class="s1">a.ndim != </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;compress_cols works for 2D arrays only.&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">compress_rowcols(a</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">mask_rows(a</span><span class="s3">, </span><span class="s1">axis=np._NoValue):</span>
    <span class="s0">&quot;&quot;&quot; 
    Mask rows of a 2D array that contain masked values. 
 
    This function is a shortcut to ``mask_rowcols`` with `axis` equal to 0. 
 
    See Also 
    -------- 
    mask_rowcols : Mask rows and/or columns of a 2D array. 
    masked_where : Mask where a condition is met. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy.ma as ma 
    &gt;&gt;&gt; a = np.zeros((3, 3), dtype=int) 
    &gt;&gt;&gt; a[1, 1] = 1 
    &gt;&gt;&gt; a 
    array([[0, 0, 0], 
           [0, 1, 0], 
           [0, 0, 0]]) 
    &gt;&gt;&gt; a = ma.masked_equal(a, 1) 
    &gt;&gt;&gt; a 
    masked_array( 
      data=[[0, 0, 0], 
            [0, --, 0], 
            [0, 0, 0]], 
      mask=[[False, False, False], 
            [False,  True, False], 
            [False, False, False]], 
      fill_value=1) 
 
    &gt;&gt;&gt; ma.mask_rows(a) 
    masked_array( 
      data=[[0, 0, 0], 
            [--, --, --], 
            [0, 0, 0]], 
      mask=[[False, False, False], 
            [ True,  True,  True], 
            [False, False, False]], 
      fill_value=1) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">axis </span><span class="s3">is not </span><span class="s1">np._NoValue:</span>
        <span class="s4"># remove the axis argument when this deprecation expires</span>
        <span class="s4"># NumPy 1.18.0, 2019-11-28</span>
        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;The axis argument has always been ignored, in future passing it &quot;</span>
            <span class="s2">&quot;will raise TypeError&quot;</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">mask_rowcols(a</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">mask_cols(a</span><span class="s3">, </span><span class="s1">axis=np._NoValue):</span>
    <span class="s0">&quot;&quot;&quot; 
    Mask columns of a 2D array that contain masked values. 
 
    This function is a shortcut to ``mask_rowcols`` with `axis` equal to 1. 
 
    See Also 
    -------- 
    mask_rowcols : Mask rows and/or columns of a 2D array. 
    masked_where : Mask where a condition is met. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy.ma as ma 
    &gt;&gt;&gt; a = np.zeros((3, 3), dtype=int) 
    &gt;&gt;&gt; a[1, 1] = 1 
    &gt;&gt;&gt; a 
    array([[0, 0, 0], 
           [0, 1, 0], 
           [0, 0, 0]]) 
    &gt;&gt;&gt; a = ma.masked_equal(a, 1) 
    &gt;&gt;&gt; a 
    masked_array( 
      data=[[0, 0, 0], 
            [0, --, 0], 
            [0, 0, 0]], 
      mask=[[False, False, False], 
            [False,  True, False], 
            [False, False, False]], 
      fill_value=1) 
    &gt;&gt;&gt; ma.mask_cols(a) 
    masked_array( 
      data=[[0, --, 0], 
            [0, --, 0], 
            [0, --, 0]], 
      mask=[[False,  True, False], 
            [False,  True, False], 
            [False,  True, False]], 
      fill_value=1) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">axis </span><span class="s3">is not </span><span class="s1">np._NoValue:</span>
        <span class="s4"># remove the axis argument when this deprecation expires</span>
        <span class="s4"># NumPy 1.18.0, 2019-11-28</span>
        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;The axis argument has always been ignored, in future passing it &quot;</span>
            <span class="s2">&quot;will raise TypeError&quot;</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">mask_rowcols(a</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>


<span class="s4">#####--------------------------------------------------------------------------</span>
<span class="s4">#---- --- arraysetops ---</span>
<span class="s4">#####--------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">ediff1d(arr</span><span class="s3">, </span><span class="s1">to_end=</span><span class="s3">None, </span><span class="s1">to_begin=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the differences between consecutive elements of an array. 
 
    This function is the equivalent of `numpy.ediff1d` that takes masked 
    values into account, see `numpy.ediff1d` for details. 
 
    See Also 
    -------- 
    numpy.ediff1d : Equivalent function for ndarrays. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">arr = ma.asanyarray(arr).flat</span>
    <span class="s1">ed = arr[</span><span class="s5">1</span><span class="s1">:] - arr[:-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">arrays = [ed]</span>
    <span class="s4">#</span>
    <span class="s3">if </span><span class="s1">to_begin </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">arrays.insert(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">to_begin)</span>
    <span class="s3">if </span><span class="s1">to_end </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">arrays.append(to_end)</span>
    <span class="s4">#</span>
    <span class="s3">if </span><span class="s1">len(arrays) != </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s4"># We'll save ourselves a copy of a potentially large array in the common</span>
        <span class="s4"># case where neither to_begin or to_end was given.</span>
        <span class="s1">ed = hstack(arrays)</span>
    <span class="s4">#</span>
    <span class="s3">return </span><span class="s1">ed</span>


<span class="s3">def </span><span class="s1">unique(ar1</span><span class="s3">, </span><span class="s1">return_index=</span><span class="s3">False, </span><span class="s1">return_inverse=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Finds the unique elements of an array. 
 
    Masked values are considered the same element (masked). The output array 
    is always a masked array. See `numpy.unique` for more details. 
 
    See Also 
    -------- 
    numpy.unique : Equivalent function for ndarrays. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">output = np.unique(ar1</span><span class="s3">,</span>
                       <span class="s1">return_index=return_index</span><span class="s3">,</span>
                       <span class="s1">return_inverse=return_inverse)</span>
    <span class="s3">if </span><span class="s1">isinstance(output</span><span class="s3">, </span><span class="s1">tuple):</span>
        <span class="s1">output = list(output)</span>
        <span class="s1">output[</span><span class="s5">0</span><span class="s1">] = output[</span><span class="s5">0</span><span class="s1">].view(MaskedArray)</span>
        <span class="s1">output = tuple(output)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">output = output.view(MaskedArray)</span>
    <span class="s3">return </span><span class="s1">output</span>


<span class="s3">def </span><span class="s1">intersect1d(ar1</span><span class="s3">, </span><span class="s1">ar2</span><span class="s3">, </span><span class="s1">assume_unique=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns the unique elements common to both arrays. 
 
    Masked values are considered equal one to the other. 
    The output is always a masked array. 
 
    See `numpy.intersect1d` for more details. 
 
    See Also 
    -------- 
    numpy.intersect1d : Equivalent function for ndarrays. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; x = np.ma.array([1, 3, 3, 3], mask=[0, 0, 0, 1]) 
    &gt;&gt;&gt; y = np.ma.array([3, 1, 1, 1], mask=[0, 0, 0, 1]) 
    &gt;&gt;&gt; np.ma.intersect1d(x, y) 
    masked_array(data=[1, 3, --], 
                 mask=[False, False,  True], 
           fill_value=999999) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">assume_unique:</span>
        <span class="s1">aux = ma.concatenate((ar1</span><span class="s3">, </span><span class="s1">ar2))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s4"># Might be faster than unique( intersect1d( ar1, ar2 ) )?</span>
        <span class="s1">aux = ma.concatenate((unique(ar1)</span><span class="s3">, </span><span class="s1">unique(ar2)))</span>
    <span class="s1">aux.sort()</span>
    <span class="s3">return </span><span class="s1">aux[:-</span><span class="s5">1</span><span class="s1">][aux[</span><span class="s5">1</span><span class="s1">:] == aux[:-</span><span class="s5">1</span><span class="s1">]]</span>


<span class="s3">def </span><span class="s1">setxor1d(ar1</span><span class="s3">, </span><span class="s1">ar2</span><span class="s3">, </span><span class="s1">assume_unique=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Set exclusive-or of 1-D arrays with unique elements. 
 
    The output is always a masked array. See `numpy.setxor1d` for more details. 
 
    See Also 
    -------- 
    numpy.setxor1d : Equivalent function for ndarrays. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">assume_unique:</span>
        <span class="s1">ar1 = unique(ar1)</span>
        <span class="s1">ar2 = unique(ar2)</span>

    <span class="s1">aux = ma.concatenate((ar1</span><span class="s3">, </span><span class="s1">ar2))</span>
    <span class="s3">if </span><span class="s1">aux.size == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">aux</span>
    <span class="s1">aux.sort()</span>
    <span class="s1">auxf = aux.filled()</span>
<span class="s4">#    flag = ediff1d( aux, to_end = 1, to_begin = 1 ) == 0</span>
    <span class="s1">flag = ma.concatenate(([</span><span class="s3">True</span><span class="s1">]</span><span class="s3">, </span><span class="s1">(auxf[</span><span class="s5">1</span><span class="s1">:] != auxf[:-</span><span class="s5">1</span><span class="s1">])</span><span class="s3">, </span><span class="s1">[</span><span class="s3">True</span><span class="s1">]))</span>
<span class="s4">#    flag2 = ediff1d( flag ) == 0</span>
    <span class="s1">flag2 = (flag[</span><span class="s5">1</span><span class="s1">:] == flag[:-</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s3">return </span><span class="s1">aux[flag2]</span>


<span class="s3">def </span><span class="s1">in1d(ar1</span><span class="s3">, </span><span class="s1">ar2</span><span class="s3">, </span><span class="s1">assume_unique=</span><span class="s3">False, </span><span class="s1">invert=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Test whether each element of an array is also present in a second 
    array. 
 
    The output is always a masked array. See `numpy.in1d` for more details. 
 
    We recommend using :func:`isin` instead of `in1d` for new code. 
 
    See Also 
    -------- 
    isin       : Version of this function that preserves the shape of ar1. 
    numpy.in1d : Equivalent function for ndarrays. 
 
    Notes 
    ----- 
    .. versionadded:: 1.4.0 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">assume_unique:</span>
        <span class="s1">ar1</span><span class="s3">, </span><span class="s1">rev_idx = unique(ar1</span><span class="s3">, </span><span class="s1">return_inverse=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">ar2 = unique(ar2)</span>

    <span class="s1">ar = ma.concatenate((ar1</span><span class="s3">, </span><span class="s1">ar2))</span>
    <span class="s4"># We need this to be a stable sort, so always use 'mergesort'</span>
    <span class="s4"># here. The values from the first array should always come before</span>
    <span class="s4"># the values from the second array.</span>
    <span class="s1">order = ar.argsort(kind=</span><span class="s2">'mergesort'</span><span class="s1">)</span>
    <span class="s1">sar = ar[order]</span>
    <span class="s3">if </span><span class="s1">invert:</span>
        <span class="s1">bool_ar = (sar[</span><span class="s5">1</span><span class="s1">:] != sar[:-</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">bool_ar = (sar[</span><span class="s5">1</span><span class="s1">:] == sar[:-</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">flag = ma.concatenate((bool_ar</span><span class="s3">, </span><span class="s1">[invert]))</span>
    <span class="s1">indx = order.argsort(kind=</span><span class="s2">'mergesort'</span><span class="s1">)[:len(ar1)]</span>

    <span class="s3">if </span><span class="s1">assume_unique:</span>
        <span class="s3">return </span><span class="s1">flag[indx]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">flag[indx][rev_idx]</span>


<span class="s3">def </span><span class="s1">isin(element</span><span class="s3">, </span><span class="s1">test_elements</span><span class="s3">, </span><span class="s1">assume_unique=</span><span class="s3">False, </span><span class="s1">invert=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculates `element in test_elements`, broadcasting over 
    `element` only. 
 
    The output is always a masked array of the same shape as `element`. 
    See `numpy.isin` for more details. 
 
    See Also 
    -------- 
    in1d       : Flattened version of this function. 
    numpy.isin : Equivalent function for ndarrays. 
 
    Notes 
    ----- 
    .. versionadded:: 1.13.0 
 
    &quot;&quot;&quot;</span>
    <span class="s1">element = ma.asarray(element)</span>
    <span class="s3">return </span><span class="s1">in1d(element</span><span class="s3">, </span><span class="s1">test_elements</span><span class="s3">, </span><span class="s1">assume_unique=assume_unique</span><span class="s3">,</span>
                <span class="s1">invert=invert).reshape(element.shape)</span>


<span class="s3">def </span><span class="s1">union1d(ar1</span><span class="s3">, </span><span class="s1">ar2):</span>
    <span class="s0">&quot;&quot;&quot; 
    Union of two arrays. 
 
    The output is always a masked array. See `numpy.union1d` for more details. 
 
    See Also 
    -------- 
    numpy.union1d : Equivalent function for ndarrays. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">unique(ma.concatenate((ar1</span><span class="s3">, </span><span class="s1">ar2)</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">setdiff1d(ar1</span><span class="s3">, </span><span class="s1">ar2</span><span class="s3">, </span><span class="s1">assume_unique=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Set difference of 1D arrays with unique elements. 
 
    The output is always a masked array. See `numpy.setdiff1d` for more 
    details. 
 
    See Also 
    -------- 
    numpy.setdiff1d : Equivalent function for ndarrays. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; x = np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1]) 
    &gt;&gt;&gt; np.ma.setdiff1d(x, [1, 2]) 
    masked_array(data=[3, --], 
                 mask=[False,  True], 
           fill_value=999999) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">assume_unique:</span>
        <span class="s1">ar1 = ma.asarray(ar1).ravel()</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">ar1 = unique(ar1)</span>
        <span class="s1">ar2 = unique(ar2)</span>
    <span class="s3">return </span><span class="s1">ar1[in1d(ar1</span><span class="s3">, </span><span class="s1">ar2</span><span class="s3">, </span><span class="s1">assume_unique=</span><span class="s3">True, </span><span class="s1">invert=</span><span class="s3">True</span><span class="s1">)]</span>


<span class="s4">###############################################################################</span>
<span class="s4">#                                Covariance                                   #</span>
<span class="s4">###############################################################################</span>


<span class="s3">def </span><span class="s1">_covhelper(x</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">rowvar=</span><span class="s3">True, </span><span class="s1">allow_masked=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Private function for the computation of covariance and correlation 
    coefficients. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x = ma.array(x</span><span class="s3">, </span><span class="s1">ndmin=</span><span class="s5">2</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">True, </span><span class="s1">dtype=float)</span>
    <span class="s1">xmask = ma.getmaskarray(x)</span>
    <span class="s4"># Quick exit if we can't process masked data</span>
    <span class="s3">if not </span><span class="s1">allow_masked </span><span class="s3">and </span><span class="s1">xmask.any():</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Cannot process masked data.&quot;</span><span class="s1">)</span>
    <span class="s4">#</span>
    <span class="s3">if </span><span class="s1">x.shape[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">rowvar = </span><span class="s3">True</span>
    <span class="s4"># Make sure that rowvar is either 0 or 1</span>
    <span class="s1">rowvar = int(bool(rowvar))</span>
    <span class="s1">axis = </span><span class="s5">1 </span><span class="s1">- rowvar</span>
    <span class="s3">if </span><span class="s1">rowvar:</span>
        <span class="s1">tup = (slice(</span><span class="s3">None</span><span class="s1">)</span><span class="s3">, None</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">tup = (</span><span class="s3">None, </span><span class="s1">slice(</span><span class="s3">None</span><span class="s1">))</span>
    <span class="s4">#</span>
    <span class="s3">if </span><span class="s1">y </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">xnotmask = np.logical_not(xmask).astype(int)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">y = array(y</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False, </span><span class="s1">ndmin=</span><span class="s5">2</span><span class="s3">, </span><span class="s1">dtype=float)</span>
        <span class="s1">ymask = ma.getmaskarray(y)</span>
        <span class="s3">if not </span><span class="s1">allow_masked </span><span class="s3">and </span><span class="s1">ymask.any():</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Cannot process masked data.&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">xmask.any() </span><span class="s3">or </span><span class="s1">ymask.any():</span>
            <span class="s3">if </span><span class="s1">y.shape == x.shape:</span>
                <span class="s4"># Define some common mask</span>
                <span class="s1">common_mask = np.logical_or(xmask</span><span class="s3">, </span><span class="s1">ymask)</span>
                <span class="s3">if </span><span class="s1">common_mask </span><span class="s3">is not </span><span class="s1">nomask:</span>
                    <span class="s1">xmask = x._mask = y._mask = ymask = common_mask</span>
                    <span class="s1">x._sharedmask = </span><span class="s3">False</span>
                    <span class="s1">y._sharedmask = </span><span class="s3">False</span>
        <span class="s1">x = ma.concatenate((x</span><span class="s3">, </span><span class="s1">y)</span><span class="s3">, </span><span class="s1">axis)</span>
        <span class="s1">xnotmask = np.logical_not(np.concatenate((xmask</span><span class="s3">, </span><span class="s1">ymask)</span><span class="s3">, </span><span class="s1">axis)).astype(int)</span>
    <span class="s1">x -= x.mean(axis=rowvar)[tup]</span>
    <span class="s3">return </span><span class="s1">(x</span><span class="s3">, </span><span class="s1">xnotmask</span><span class="s3">, </span><span class="s1">rowvar)</span>


<span class="s3">def </span><span class="s1">cov(x</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">rowvar=</span><span class="s3">True, </span><span class="s1">bias=</span><span class="s3">False, </span><span class="s1">allow_masked=</span><span class="s3">True, </span><span class="s1">ddof=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Estimate the covariance matrix. 
 
    Except for the handling of missing data this function does the same as 
    `numpy.cov`. For more details and examples, see `numpy.cov`. 
 
    By default, masked values are recognized as such. If `x` and `y` have the 
    same shape, a common mask is allocated: if ``x[i,j]`` is masked, then 
    ``y[i,j]`` will also be masked. 
    Setting `allow_masked` to False will raise an exception if values are 
    missing in either of the input arrays. 
 
    Parameters 
    ---------- 
    x : array_like 
        A 1-D or 2-D array containing multiple variables and observations. 
        Each row of `x` represents a variable, and each column a single 
        observation of all those variables. Also see `rowvar` below. 
    y : array_like, optional 
        An additional set of variables and observations. `y` has the same 
        shape as `x`. 
    rowvar : bool, optional 
        If `rowvar` is True (default), then each row represents a 
        variable, with observations in the columns. Otherwise, the relationship 
        is transposed: each column represents a variable, while the rows 
        contain observations. 
    bias : bool, optional 
        Default normalization (False) is by ``(N-1)``, where ``N`` is the 
        number of observations given (unbiased estimate). If `bias` is True, 
        then normalization is by ``N``. This keyword can be overridden by 
        the keyword ``ddof`` in numpy versions &gt;= 1.5. 
    allow_masked : bool, optional 
        If True, masked values are propagated pair-wise: if a value is masked 
        in `x`, the corresponding value is masked in `y`. 
        If False, raises a `ValueError` exception when some values are missing. 
    ddof : {None, int}, optional 
        If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is 
        the number of observations; this overrides the value implied by 
        ``bias``. The default value is ``None``. 
 
        .. versionadded:: 1.5 
 
    Raises 
    ------ 
    ValueError 
        Raised if some values are missing and `allow_masked` is False. 
 
    See Also 
    -------- 
    numpy.cov 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># Check inputs</span>
    <span class="s3">if </span><span class="s1">ddof </span><span class="s3">is not None and </span><span class="s1">ddof != int(ddof):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;ddof must be an integer&quot;</span><span class="s1">)</span>
    <span class="s4"># Set up ddof</span>
    <span class="s3">if </span><span class="s1">ddof </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">bias:</span>
            <span class="s1">ddof = </span><span class="s5">0</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">ddof = </span><span class="s5">1</span>

    <span class="s1">(x</span><span class="s3">, </span><span class="s1">xnotmask</span><span class="s3">, </span><span class="s1">rowvar) = _covhelper(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">, </span><span class="s1">allow_masked)</span>
    <span class="s3">if not </span><span class="s1">rowvar:</span>
        <span class="s1">fact = np.dot(xnotmask.T</span><span class="s3">, </span><span class="s1">xnotmask) * </span><span class="s5">1. </span><span class="s1">- ddof</span>
        <span class="s1">result = (dot(x.T</span><span class="s3">, </span><span class="s1">x.conj()</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">False</span><span class="s1">) / fact).squeeze()</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">fact = np.dot(xnotmask</span><span class="s3">, </span><span class="s1">xnotmask.T) * </span><span class="s5">1. </span><span class="s1">- ddof</span>
        <span class="s1">result = (dot(x</span><span class="s3">, </span><span class="s1">x.T.conj()</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">False</span><span class="s1">) / fact).squeeze()</span>
    <span class="s3">return </span><span class="s1">result</span>


<span class="s3">def </span><span class="s1">corrcoef(x</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">rowvar=</span><span class="s3">True, </span><span class="s1">bias=np._NoValue</span><span class="s3">, </span><span class="s1">allow_masked=</span><span class="s3">True,</span>
             <span class="s1">ddof=np._NoValue):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return Pearson product-moment correlation coefficients. 
 
    Except for the handling of missing data this function does the same as 
    `numpy.corrcoef`. For more details and examples, see `numpy.corrcoef`. 
 
    Parameters 
    ---------- 
    x : array_like 
        A 1-D or 2-D array containing multiple variables and observations. 
        Each row of `x` represents a variable, and each column a single 
        observation of all those variables. Also see `rowvar` below. 
    y : array_like, optional 
        An additional set of variables and observations. `y` has the same 
        shape as `x`. 
    rowvar : bool, optional 
        If `rowvar` is True (default), then each row represents a 
        variable, with observations in the columns. Otherwise, the relationship 
        is transposed: each column represents a variable, while the rows 
        contain observations. 
    bias : _NoValue, optional 
        Has no effect, do not use. 
 
        .. deprecated:: 1.10.0 
    allow_masked : bool, optional 
        If True, masked values are propagated pair-wise: if a value is masked 
        in `x`, the corresponding value is masked in `y`. 
        If False, raises an exception.  Because `bias` is deprecated, this 
        argument needs to be treated as keyword only to avoid a warning. 
    ddof : _NoValue, optional 
        Has no effect, do not use. 
 
        .. deprecated:: 1.10.0 
 
    See Also 
    -------- 
    numpy.corrcoef : Equivalent function in top-level NumPy module. 
    cov : Estimate the covariance matrix. 
 
    Notes 
    ----- 
    This function accepts but discards arguments `bias` and `ddof`.  This is 
    for backwards compatibility with previous versions of this function.  These 
    arguments had no effect on the return values of the function and can be 
    safely ignored in this and previous versions of numpy. 
    &quot;&quot;&quot;</span>
    <span class="s1">msg = </span><span class="s2">'bias and ddof have no effect and are deprecated'</span>
    <span class="s3">if </span><span class="s1">bias </span><span class="s3">is not </span><span class="s1">np._NoValue </span><span class="s3">or </span><span class="s1">ddof </span><span class="s3">is not </span><span class="s1">np._NoValue:</span>
        <span class="s4"># 2015-03-15, 1.10</span>
        <span class="s1">warnings.warn(msg</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s4"># Get the data</span>
    <span class="s1">(x</span><span class="s3">, </span><span class="s1">xnotmask</span><span class="s3">, </span><span class="s1">rowvar) = _covhelper(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">, </span><span class="s1">allow_masked)</span>
    <span class="s4"># Compute the covariance matrix</span>
    <span class="s3">if not </span><span class="s1">rowvar:</span>
        <span class="s1">fact = np.dot(xnotmask.T</span><span class="s3">, </span><span class="s1">xnotmask) * </span><span class="s5">1.</span>
        <span class="s1">c = (dot(x.T</span><span class="s3">, </span><span class="s1">x.conj()</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">False</span><span class="s1">) / fact).squeeze()</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">fact = np.dot(xnotmask</span><span class="s3">, </span><span class="s1">xnotmask.T) * </span><span class="s5">1.</span>
        <span class="s1">c = (dot(x</span><span class="s3">, </span><span class="s1">x.T.conj()</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">False</span><span class="s1">) / fact).squeeze()</span>
    <span class="s4"># Check whether we have a scalar</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">diag = ma.diagonal(c)</span>
    <span class="s3">except </span><span class="s1">ValueError:</span>
        <span class="s3">return </span><span class="s5">1</span>
    <span class="s4">#</span>
    <span class="s3">if </span><span class="s1">xnotmask.all():</span>
        <span class="s1">_denom = ma.sqrt(ma.multiply.outer(diag</span><span class="s3">, </span><span class="s1">diag))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">_denom = diagflat(diag)</span>
        <span class="s1">_denom._sharedmask = </span><span class="s3">False  </span><span class="s4"># We know return is always a copy</span>
        <span class="s1">n = x.shape[</span><span class="s5">1 </span><span class="s1">- rowvar]</span>
        <span class="s3">if </span><span class="s1">rowvar:</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(n - </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(i + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">n):</span>
                    <span class="s1">_x = mask_cols(vstack((x[i]</span><span class="s3">, </span><span class="s1">x[j]))).var(axis=</span><span class="s5">1</span><span class="s1">)</span>
                    <span class="s1">_denom[i</span><span class="s3">, </span><span class="s1">j] = _denom[j</span><span class="s3">, </span><span class="s1">i] = ma.sqrt(ma.multiply.reduce(_x))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(n - </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(i + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">n):</span>
                    <span class="s1">_x = mask_cols(</span>
                            <span class="s1">vstack((x[:</span><span class="s3">, </span><span class="s1">i]</span><span class="s3">, </span><span class="s1">x[:</span><span class="s3">, </span><span class="s1">j]))).var(axis=</span><span class="s5">1</span><span class="s1">)</span>
                    <span class="s1">_denom[i</span><span class="s3">, </span><span class="s1">j] = _denom[j</span><span class="s3">, </span><span class="s1">i] = ma.sqrt(ma.multiply.reduce(_x))</span>
    <span class="s3">return </span><span class="s1">c / _denom</span>

<span class="s4">#####--------------------------------------------------------------------------</span>
<span class="s4">#---- --- Concatenation helpers ---</span>
<span class="s4">#####--------------------------------------------------------------------------</span>

<span class="s3">class </span><span class="s1">MAxisConcatenator(AxisConcatenator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Translate slice objects to concatenation along an axis. 
 
    For documentation on usage, see `mr_class`. 
 
    See Also 
    -------- 
    mr_class 
 
    &quot;&quot;&quot;</span>
    <span class="s1">concatenate = staticmethod(concatenate)</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">makemat(cls</span><span class="s3">, </span><span class="s1">arr):</span>
        <span class="s4"># There used to be a view as np.matrix here, but we may eventually</span>
        <span class="s4"># deprecate that class. In preparation, we use the unmasked version</span>
        <span class="s4"># to construct the matrix (with copy=False for backwards compatibility</span>
        <span class="s4"># with the .view)</span>
        <span class="s1">data = super().makemat(arr.data</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">array(data</span><span class="s3">, </span><span class="s1">mask=arr.mask)</span>

    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s4"># matrix builder syntax, like 'a, b; c, d'</span>
        <span class="s3">if </span><span class="s1">isinstance(key</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s3">raise </span><span class="s1">MAError(</span><span class="s2">&quot;Unavailable for masked array.&quot;</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">super().__getitem__(key)</span>


<span class="s3">class </span><span class="s1">mr_class(MAxisConcatenator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Translate slice objects to concatenation along the first axis. 
 
    This is the masked array version of `lib.index_tricks.RClass`. 
 
    See Also 
    -------- 
    lib.index_tricks.RClass 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.ma.mr_[np.ma.array([1,2,3]), 0, 0, np.ma.array([4,5,6])] 
    masked_array(data=[1, 2, 3, ..., 4, 5, 6], 
                 mask=False, 
           fill_value=999999) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">MAxisConcatenator.__init__(self</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>

<span class="s1">mr_ = mr_class()</span>

<span class="s4">#####--------------------------------------------------------------------------</span>
<span class="s4">#---- Find unmasked data ---</span>
<span class="s4">#####--------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">flatnotmasked_edges(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find the indices of the first and last unmasked values. 
 
    Expects a 1-D `MaskedArray`, returns None if all values are masked. 
 
    Parameters 
    ---------- 
    a : array_like 
        Input 1-D `MaskedArray` 
 
    Returns 
    ------- 
    edges : ndarray or None 
        The indices of first and last non-masked value in the array. 
        Returns None if all values are masked. 
 
    See Also 
    -------- 
    flatnotmasked_contiguous, notmasked_contiguous, notmasked_edges 
    clump_masked, clump_unmasked 
 
    Notes 
    ----- 
    Only accepts 1-D arrays. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; a = np.ma.arange(10) 
    &gt;&gt;&gt; np.ma.flatnotmasked_edges(a) 
    array([0, 9]) 
 
    &gt;&gt;&gt; mask = (a &lt; 3) | (a &gt; 8) | (a == 5) 
    &gt;&gt;&gt; a[mask] = np.ma.masked 
    &gt;&gt;&gt; np.array(a[~a.mask]) 
    array([3, 4, 6, 7, 8]) 
 
    &gt;&gt;&gt; np.ma.flatnotmasked_edges(a) 
    array([3, 8]) 
 
    &gt;&gt;&gt; a[:] = np.ma.masked 
    &gt;&gt;&gt; print(np.ma.flatnotmasked_edges(a)) 
    None 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = getmask(a)</span>
    <span class="s3">if </span><span class="s1">m </span><span class="s3">is </span><span class="s1">nomask </span><span class="s3">or not </span><span class="s1">np.any(m):</span>
        <span class="s3">return </span><span class="s1">np.array([</span><span class="s5">0</span><span class="s3">, </span><span class="s1">a.size - </span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">unmasked = np.flatnonzero(~m)</span>
    <span class="s3">if </span><span class="s1">len(unmasked) &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">unmasked[[</span><span class="s5">0</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return None</span>


<span class="s3">def </span><span class="s1">notmasked_edges(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find the indices of the first and last unmasked values along an axis. 
 
    If all values are masked, return None.  Otherwise, return a list 
    of two tuples, corresponding to the indices of the first and last 
    unmasked values respectively. 
 
    Parameters 
    ---------- 
    a : array_like 
        The input array. 
    axis : int, optional 
        Axis along which to perform the operation. 
        If None (default), applies to a flattened version of the array. 
 
    Returns 
    ------- 
    edges : ndarray or list 
        An array of start and end indexes if there are any masked data in 
        the array. If there are no masked data in the array, `edges` is a 
        list of the first and last index. 
 
    See Also 
    -------- 
    flatnotmasked_contiguous, flatnotmasked_edges, notmasked_contiguous 
    clump_masked, clump_unmasked 
 
    Examples 
    -------- 
    &gt;&gt;&gt; a = np.arange(9).reshape((3, 3)) 
    &gt;&gt;&gt; m = np.zeros_like(a) 
    &gt;&gt;&gt; m[1:, 1:] = 1 
 
    &gt;&gt;&gt; am = np.ma.array(a, mask=m) 
    &gt;&gt;&gt; np.array(am[~am.mask]) 
    array([0, 1, 2, 3, 6]) 
 
    &gt;&gt;&gt; np.ma.notmasked_edges(am) 
    array([0, 6]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = asarray(a)</span>
    <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None or </span><span class="s1">a.ndim == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">flatnotmasked_edges(a)</span>
    <span class="s1">m = getmaskarray(a)</span>
    <span class="s1">idx = array(np.indices(a.shape)</span><span class="s3">, </span><span class="s1">mask=np.asarray([m] * a.ndim))</span>
    <span class="s3">return </span><span class="s1">[tuple([idx[i].min(axis).compressed() </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(a.ndim)])</span><span class="s3">,</span>
            <span class="s1">tuple([idx[i].max(axis).compressed() </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(a.ndim)])</span><span class="s3">, </span><span class="s1">]</span>


<span class="s3">def </span><span class="s1">flatnotmasked_contiguous(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find contiguous unmasked data in a masked array along the given axis. 
 
    Parameters 
    ---------- 
    a : narray 
        The input array. 
 
    Returns 
    ------- 
    slice_list : list 
        A sorted sequence of `slice` objects (start index, end index). 
 
        .. versionchanged:: 1.15.0 
            Now returns an empty list instead of None for a fully masked array 
 
    See Also 
    -------- 
    flatnotmasked_edges, notmasked_contiguous, notmasked_edges 
    clump_masked, clump_unmasked 
 
    Notes 
    ----- 
    Only accepts 2-D arrays at most. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; a = np.ma.arange(10) 
    &gt;&gt;&gt; np.ma.flatnotmasked_contiguous(a) 
    [slice(0, 10, None)] 
 
    &gt;&gt;&gt; mask = (a &lt; 3) | (a &gt; 8) | (a == 5) 
    &gt;&gt;&gt; a[mask] = np.ma.masked 
    &gt;&gt;&gt; np.array(a[~a.mask]) 
    array([3, 4, 6, 7, 8]) 
 
    &gt;&gt;&gt; np.ma.flatnotmasked_contiguous(a) 
    [slice(3, 5, None), slice(6, 9, None)] 
    &gt;&gt;&gt; a[:] = np.ma.masked 
    &gt;&gt;&gt; np.ma.flatnotmasked_contiguous(a) 
    [] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = getmask(a)</span>
    <span class="s3">if </span><span class="s1">m </span><span class="s3">is </span><span class="s1">nomask:</span>
        <span class="s3">return </span><span class="s1">[slice(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">a.size)]</span>
    <span class="s1">i = </span><span class="s5">0</span>
    <span class="s1">result = []</span>
    <span class="s3">for </span><span class="s1">(k</span><span class="s3">, </span><span class="s1">g) </span><span class="s3">in </span><span class="s1">itertools.groupby(m.ravel()):</span>
        <span class="s1">n = len(list(g))</span>
        <span class="s3">if not </span><span class="s1">k:</span>
            <span class="s1">result.append(slice(i</span><span class="s3">, </span><span class="s1">i + n))</span>
        <span class="s1">i += n</span>
    <span class="s3">return </span><span class="s1">result</span>

<span class="s3">def </span><span class="s1">notmasked_contiguous(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find contiguous unmasked data in a masked array along the given axis. 
 
    Parameters 
    ---------- 
    a : array_like 
        The input array. 
    axis : int, optional 
        Axis along which to perform the operation. 
        If None (default), applies to a flattened version of the array, and this 
        is the same as `flatnotmasked_contiguous`. 
 
    Returns 
    ------- 
    endpoints : list 
        A list of slices (start and end indexes) of unmasked indexes 
        in the array. 
 
        If the input is 2d and axis is specified, the result is a list of lists. 
 
    See Also 
    -------- 
    flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges 
    clump_masked, clump_unmasked 
 
    Notes 
    ----- 
    Only accepts 2-D arrays at most. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; a = np.arange(12).reshape((3, 4)) 
    &gt;&gt;&gt; mask = np.zeros_like(a) 
    &gt;&gt;&gt; mask[1:, :-1] = 1; mask[0, 1] = 1; mask[-1, 0] = 0 
    &gt;&gt;&gt; ma = np.ma.array(a, mask=mask) 
    &gt;&gt;&gt; ma 
    masked_array( 
      data=[[0, --, 2, 3], 
            [--, --, --, 7], 
            [8, --, --, 11]], 
      mask=[[False,  True, False, False], 
            [ True,  True,  True, False], 
            [False,  True,  True, False]], 
      fill_value=999999) 
    &gt;&gt;&gt; np.array(ma[~ma.mask]) 
    array([ 0,  2,  3,  7, 8, 11]) 
 
    &gt;&gt;&gt; np.ma.notmasked_contiguous(ma) 
    [slice(0, 1, None), slice(2, 4, None), slice(7, 9, None), slice(11, 12, None)] 
 
    &gt;&gt;&gt; np.ma.notmasked_contiguous(ma, axis=0) 
    [[slice(0, 1, None), slice(2, 3, None)], [], [slice(0, 1, None)], [slice(0, 3, None)]] 
 
    &gt;&gt;&gt; np.ma.notmasked_contiguous(ma, axis=1) 
    [[slice(0, 1, None), slice(2, 4, None)], [slice(3, 4, None)], [slice(0, 1, None), slice(3, 4, None)]] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = asarray(a)</span>
    <span class="s1">nd = a.ndim</span>
    <span class="s3">if </span><span class="s1">nd &gt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;Currently limited to atmost 2D array.&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None or </span><span class="s1">nd == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">flatnotmasked_contiguous(a)</span>
    <span class="s4">#</span>
    <span class="s1">result = []</span>
    <span class="s4">#</span>
    <span class="s1">other = (axis + </span><span class="s5">1</span><span class="s1">) % </span><span class="s5">2</span>
    <span class="s1">idx = [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">idx[axis] = slice(</span><span class="s3">None, None</span><span class="s1">)</span>
    <span class="s4">#</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(a.shape[other]):</span>
        <span class="s1">idx[other] = i</span>
        <span class="s1">result.append(flatnotmasked_contiguous(a[tuple(idx)]))</span>
    <span class="s3">return </span><span class="s1">result</span>


<span class="s3">def </span><span class="s1">_ezclump(mask):</span>
    <span class="s0">&quot;&quot;&quot; 
    Finds the clumps (groups of data with the same values) for a 1D bool array. 
 
    Returns a series of slices. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">mask.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">mask = mask.ravel()</span>
    <span class="s1">idx = (mask[</span><span class="s5">1</span><span class="s1">:] ^ mask[:-</span><span class="s5">1</span><span class="s1">]).nonzero()</span>
    <span class="s1">idx = idx[</span><span class="s5">0</span><span class="s1">] + </span><span class="s5">1</span>

    <span class="s3">if </span><span class="s1">mask[</span><span class="s5">0</span><span class="s1">]:</span>
        <span class="s3">if </span><span class="s1">len(idx) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">[slice(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">mask.size)]</span>

        <span class="s1">r = [slice(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">idx[</span><span class="s5">0</span><span class="s1">])]</span>
        <span class="s1">r.extend((slice(left</span><span class="s3">, </span><span class="s1">right)</span>
                  <span class="s3">for </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right </span><span class="s3">in </span><span class="s1">zip(idx[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">:</span><span class="s5">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">idx[</span><span class="s5">2</span><span class="s1">::</span><span class="s5">2</span><span class="s1">])))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">len(idx) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">[]</span>

        <span class="s1">r = [slice(left</span><span class="s3">, </span><span class="s1">right) </span><span class="s3">for </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right </span><span class="s3">in </span><span class="s1">zip(idx[:-</span><span class="s5">1</span><span class="s1">:</span><span class="s5">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">idx[</span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">])]</span>

    <span class="s3">if </span><span class="s1">mask[-</span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s1">r.append(slice(idx[-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">mask.size))</span>
    <span class="s3">return </span><span class="s1">r</span>


<span class="s3">def </span><span class="s1">clump_unmasked(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return list of slices corresponding to the unmasked clumps of a 1-D array. 
    (A &quot;clump&quot; is defined as a contiguous region of the array). 
 
    Parameters 
    ---------- 
    a : ndarray 
        A one-dimensional masked array. 
 
    Returns 
    ------- 
    slices : list of slice 
        The list of slices, one for each continuous region of unmasked 
        elements in `a`. 
 
    Notes 
    ----- 
    .. versionadded:: 1.4.0 
 
    See Also 
    -------- 
    flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges 
    notmasked_contiguous, clump_masked 
 
    Examples 
    -------- 
    &gt;&gt;&gt; a = np.ma.masked_array(np.arange(10)) 
    &gt;&gt;&gt; a[[0, 1, 2, 6, 8, 9]] = np.ma.masked 
    &gt;&gt;&gt; np.ma.clump_unmasked(a) 
    [slice(3, 6, None), slice(7, 8, None)] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">mask = getattr(a</span><span class="s3">, </span><span class="s2">'_mask'</span><span class="s3">, </span><span class="s1">nomask)</span>
    <span class="s3">if </span><span class="s1">mask </span><span class="s3">is </span><span class="s1">nomask:</span>
        <span class="s3">return </span><span class="s1">[slice(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">a.size)]</span>
    <span class="s3">return </span><span class="s1">_ezclump(~mask)</span>


<span class="s3">def </span><span class="s1">clump_masked(a):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a list of slices corresponding to the masked clumps of a 1-D array. 
    (A &quot;clump&quot; is defined as a contiguous region of the array). 
 
    Parameters 
    ---------- 
    a : ndarray 
        A one-dimensional masked array. 
 
    Returns 
    ------- 
    slices : list of slice 
        The list of slices, one for each continuous region of masked elements 
        in `a`. 
 
    Notes 
    ----- 
    .. versionadded:: 1.4.0 
 
    See Also 
    -------- 
    flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges 
    notmasked_contiguous, clump_unmasked 
 
    Examples 
    -------- 
    &gt;&gt;&gt; a = np.ma.masked_array(np.arange(10)) 
    &gt;&gt;&gt; a[[0, 1, 2, 6, 8, 9]] = np.ma.masked 
    &gt;&gt;&gt; np.ma.clump_masked(a) 
    [slice(0, 3, None), slice(6, 7, None), slice(8, 10, None)] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">mask = ma.getmask(a)</span>
    <span class="s3">if </span><span class="s1">mask </span><span class="s3">is </span><span class="s1">nomask:</span>
        <span class="s3">return </span><span class="s1">[]</span>
    <span class="s3">return </span><span class="s1">_ezclump(mask)</span>


<span class="s4">###############################################################################</span>
<span class="s4">#                              Polynomial fit                                 #</span>
<span class="s4">###############################################################################</span>


<span class="s3">def </span><span class="s1">vander(x</span><span class="s3">, </span><span class="s1">n=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Masked values in the input array result in rows of zeros. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_vander = np.vander(x</span><span class="s3">, </span><span class="s1">n)</span>
    <span class="s1">m = getmask(x)</span>
    <span class="s3">if </span><span class="s1">m </span><span class="s3">is not </span><span class="s1">nomask:</span>
        <span class="s1">_vander[m] = </span><span class="s5">0</span>
    <span class="s3">return </span><span class="s1">_vander</span>

<span class="s1">vander.__doc__ = ma.doc_note(np.vander.__doc__</span><span class="s3">, </span><span class="s1">vander.__doc__)</span>


<span class="s3">def </span><span class="s1">polyfit(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">deg</span><span class="s3">, </span><span class="s1">rcond=</span><span class="s3">None, </span><span class="s1">full=</span><span class="s3">False, </span><span class="s1">w=</span><span class="s3">None, </span><span class="s1">cov=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Any masked values in x is propagated in y, and vice-versa. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x = asarray(x)</span>
    <span class="s1">y = asarray(y)</span>

    <span class="s1">m = getmask(x)</span>
    <span class="s3">if </span><span class="s1">y.ndim == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">m = mask_or(m</span><span class="s3">, </span><span class="s1">getmask(y))</span>
    <span class="s3">elif </span><span class="s1">y.ndim == </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s1">my = getmask(mask_rows(y))</span>
        <span class="s3">if </span><span class="s1">my </span><span class="s3">is not </span><span class="s1">nomask:</span>
            <span class="s1">m = mask_or(m</span><span class="s3">, </span><span class="s1">my[:</span><span class="s3">, </span><span class="s5">0</span><span class="s1">])</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Expected a 1D or 2D array for y!&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">w </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">w = asarray(w)</span>
        <span class="s3">if </span><span class="s1">w.ndim != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;expected a 1-d array for weights&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">w.shape[</span><span class="s5">0</span><span class="s1">] != y.shape[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;expected w and y to have the same length&quot;</span><span class="s1">)</span>
        <span class="s1">m = mask_or(m</span><span class="s3">, </span><span class="s1">getmask(w))</span>

    <span class="s3">if </span><span class="s1">m </span><span class="s3">is not </span><span class="s1">nomask:</span>
        <span class="s1">not_m = ~m</span>
        <span class="s3">if </span><span class="s1">w </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">w = w[not_m]</span>
        <span class="s3">return </span><span class="s1">np.polyfit(x[not_m]</span><span class="s3">, </span><span class="s1">y[not_m]</span><span class="s3">, </span><span class="s1">deg</span><span class="s3">, </span><span class="s1">rcond</span><span class="s3">, </span><span class="s1">full</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">cov)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.polyfit(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">deg</span><span class="s3">, </span><span class="s1">rcond</span><span class="s3">, </span><span class="s1">full</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">cov)</span>

<span class="s1">polyfit.__doc__ = ma.doc_note(np.polyfit.__doc__</span><span class="s3">, </span><span class="s1">polyfit.__doc__)</span>
</pre>
</body>
</html>