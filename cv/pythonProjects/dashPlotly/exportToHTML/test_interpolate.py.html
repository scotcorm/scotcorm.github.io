<html>
<head>
<title>test_interpolate.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_interpolate.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">pandas.util._test_decorators </span><span class="s0">as </span><span class="s1">td</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">MultiIndex</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">date_range</span><span class="s0">,</span>
    <span class="s1">isna</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>


<span class="s1">@pytest.fixture(</span>
    <span class="s1">params=[</span>
        <span class="s2">&quot;linear&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;index&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;values&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;nearest&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;slinear&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;zero&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;quadratic&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;cubic&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;barycentric&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;krogh&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;polynomial&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;spline&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;piecewise_polynomial&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;from_derivatives&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;pchip&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;akima&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;cubicspline&quot;</span><span class="s0">,</span>
    <span class="s1">]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">nontemporal_method(request):</span>
    <span class="s3">&quot;&quot;&quot;Fixture that returns an (method name, required kwargs) pair. 
 
    This fixture does not include method 'time' as a parameterization; that 
    method requires a Series with a DatetimeIndex, and is generally tested 
    separately from these non-temporal methods. 
    &quot;&quot;&quot;</span>
    <span class="s1">method = request.param</span>
    <span class="s1">kwargs = {</span><span class="s2">&quot;order&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">} </span><span class="s0">if </span><span class="s1">method </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;spline&quot;</span><span class="s0">, </span><span class="s2">&quot;polynomial&quot;</span><span class="s1">) </span><span class="s0">else </span><span class="s1">{}</span>
    <span class="s0">return </span><span class="s1">method</span><span class="s0">, </span><span class="s1">kwargs</span>


<span class="s1">@pytest.fixture(</span>
    <span class="s1">params=[</span>
        <span class="s2">&quot;linear&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;slinear&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;zero&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;quadratic&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;cubic&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;barycentric&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;krogh&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;polynomial&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;spline&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;piecewise_polynomial&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;from_derivatives&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;pchip&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;akima&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;cubicspline&quot;</span><span class="s0">,</span>
    <span class="s1">]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">interp_methods_ind(request):</span>
    <span class="s3">&quot;&quot;&quot;Fixture that returns a (method name, required kwargs) pair to 
    be tested for various Index types. 
 
    This fixture does not include methods - 'time', 'index', 'nearest', 
    'values' as a parameterization 
    &quot;&quot;&quot;</span>
    <span class="s1">method = request.param</span>
    <span class="s1">kwargs = {</span><span class="s2">&quot;order&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">} </span><span class="s0">if </span><span class="s1">method </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;spline&quot;</span><span class="s0">, </span><span class="s2">&quot;polynomial&quot;</span><span class="s1">) </span><span class="s0">else </span><span class="s1">{}</span>
    <span class="s0">return </span><span class="s1">method</span><span class="s0">, </span><span class="s1">kwargs</span>


<span class="s0">class </span><span class="s1">TestSeriesInterpolateData:</span>
    <span class="s0">def </span><span class="s1">test_interpolate(self</span><span class="s0">, </span><span class="s1">datetime_series</span><span class="s0">, </span><span class="s1">string_series):</span>
        <span class="s1">ts = Series(np.arange(len(datetime_series)</span><span class="s0">, </span><span class="s1">dtype=float)</span><span class="s0">, </span><span class="s1">datetime_series.index)</span>

        <span class="s1">ts_copy = ts.copy()</span>
        <span class="s1">ts_copy[</span><span class="s4">5</span><span class="s1">:</span><span class="s4">10</span><span class="s1">] = np.NaN</span>

        <span class="s1">linear_interp = ts_copy.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(linear_interp</span><span class="s0">, </span><span class="s1">ts)</span>

        <span class="s1">ord_ts = Series(</span>
            <span class="s1">[d.toordinal() </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">datetime_series.index]</span><span class="s0">, </span><span class="s1">index=datetime_series.index</span>
        <span class="s1">).astype(float)</span>

        <span class="s1">ord_ts_copy = ord_ts.copy()</span>
        <span class="s1">ord_ts_copy[</span><span class="s4">5</span><span class="s1">:</span><span class="s4">10</span><span class="s1">] = np.NaN</span>

        <span class="s1">time_interp = ord_ts_copy.interpolate(method=</span><span class="s2">&quot;time&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(time_interp</span><span class="s0">, </span><span class="s1">ord_ts)</span>

    <span class="s0">def </span><span class="s1">test_interpolate_time_raises_for_non_timeseries(self):</span>
        <span class="s5"># When method='time' is used on a non-TimeSeries that contains a null</span>
        <span class="s5"># value, a ValueError should be raised.</span>
        <span class="s1">non_ts = Series([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">np.NaN])</span>
        <span class="s1">msg = </span><span class="s2">&quot;time-weighted interpolation only works on Series.* with a DatetimeIndex&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">non_ts.interpolate(method=</span><span class="s2">&quot;time&quot;</span><span class="s1">)</span>

    <span class="s1">@td.skip_if_no_scipy</span>
    <span class="s0">def </span><span class="s1">test_interpolate_cubicspline(self):</span>

        <span class="s1">ser = Series([</span><span class="s4">10</span><span class="s0">, </span><span class="s4">11</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">13</span><span class="s1">])</span>

        <span class="s1">expected = Series(</span>
            <span class="s1">[</span><span class="s4">11.00</span><span class="s0">, </span><span class="s4">11.25</span><span class="s0">, </span><span class="s4">11.50</span><span class="s0">, </span><span class="s4">11.75</span><span class="s0">, </span><span class="s4">12.00</span><span class="s0">, </span><span class="s4">12.25</span><span class="s0">, </span><span class="s4">12.50</span><span class="s0">, </span><span class="s4">12.75</span><span class="s0">, </span><span class="s4">13.00</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">index=Index([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">1.25</span><span class="s0">, </span><span class="s4">1.5</span><span class="s0">, </span><span class="s4">1.75</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">2.25</span><span class="s0">, </span><span class="s4">2.5</span><span class="s0">, </span><span class="s4">2.75</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s5"># interpolate at new_index</span>
        <span class="s1">new_index = ser.index.union(Index([</span><span class="s4">1.25</span><span class="s0">, </span><span class="s4">1.5</span><span class="s0">, </span><span class="s4">1.75</span><span class="s0">, </span><span class="s4">2.25</span><span class="s0">, </span><span class="s4">2.5</span><span class="s0">, </span><span class="s4">2.75</span><span class="s1">])).astype(</span>
            <span class="s1">float</span>
        <span class="s1">)</span>
        <span class="s1">result = ser.reindex(new_index).interpolate(method=</span><span class="s2">&quot;cubicspline&quot;</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">:</span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@td.skip_if_no_scipy</span>
    <span class="s0">def </span><span class="s1">test_interpolate_pchip(self):</span>

        <span class="s1">ser = Series(np.sort(np.random.uniform(size=</span><span class="s4">100</span><span class="s1">)))</span>

        <span class="s5"># interpolate at new_index</span>
        <span class="s1">new_index = ser.index.union(</span>
            <span class="s1">Index([</span><span class="s4">49.25</span><span class="s0">, </span><span class="s4">49.5</span><span class="s0">, </span><span class="s4">49.75</span><span class="s0">, </span><span class="s4">50.25</span><span class="s0">, </span><span class="s4">50.5</span><span class="s0">, </span><span class="s4">50.75</span><span class="s1">])</span>
        <span class="s1">).astype(float)</span>
        <span class="s1">interp_s = ser.reindex(new_index).interpolate(method=</span><span class="s2">&quot;pchip&quot;</span><span class="s1">)</span>
        <span class="s5"># does not blow up, GH5977</span>
        <span class="s1">interp_s[</span><span class="s4">49</span><span class="s1">:</span><span class="s4">51</span><span class="s1">]</span>

    <span class="s1">@td.skip_if_no_scipy</span>
    <span class="s0">def </span><span class="s1">test_interpolate_akima(self):</span>

        <span class="s1">ser = Series([</span><span class="s4">10</span><span class="s0">, </span><span class="s4">11</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">13</span><span class="s1">])</span>

        <span class="s5"># interpolate at new_index where `der` is zero</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[</span><span class="s4">11.00</span><span class="s0">, </span><span class="s4">11.25</span><span class="s0">, </span><span class="s4">11.50</span><span class="s0">, </span><span class="s4">11.75</span><span class="s0">, </span><span class="s4">12.00</span><span class="s0">, </span><span class="s4">12.25</span><span class="s0">, </span><span class="s4">12.50</span><span class="s0">, </span><span class="s4">12.75</span><span class="s0">, </span><span class="s4">13.00</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">index=Index([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">1.25</span><span class="s0">, </span><span class="s4">1.5</span><span class="s0">, </span><span class="s4">1.75</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">2.25</span><span class="s0">, </span><span class="s4">2.5</span><span class="s0">, </span><span class="s4">2.75</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">new_index = ser.index.union(Index([</span><span class="s4">1.25</span><span class="s0">, </span><span class="s4">1.5</span><span class="s0">, </span><span class="s4">1.75</span><span class="s0">, </span><span class="s4">2.25</span><span class="s0">, </span><span class="s4">2.5</span><span class="s0">, </span><span class="s4">2.75</span><span class="s1">])).astype(</span>
            <span class="s1">float</span>
        <span class="s1">)</span>
        <span class="s1">interp_s = ser.reindex(new_index).interpolate(method=</span><span class="s2">&quot;akima&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(interp_s[</span><span class="s4">1</span><span class="s1">:</span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s5"># interpolate at new_index where `der` is a non-zero int</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[</span><span class="s4">11.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">12.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">13.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">index=Index([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">1.25</span><span class="s0">, </span><span class="s4">1.5</span><span class="s0">, </span><span class="s4">1.75</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">2.25</span><span class="s0">, </span><span class="s4">2.5</span><span class="s0">, </span><span class="s4">2.75</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">new_index = ser.index.union(Index([</span><span class="s4">1.25</span><span class="s0">, </span><span class="s4">1.5</span><span class="s0">, </span><span class="s4">1.75</span><span class="s0">, </span><span class="s4">2.25</span><span class="s0">, </span><span class="s4">2.5</span><span class="s0">, </span><span class="s4">2.75</span><span class="s1">])).astype(</span>
            <span class="s1">float</span>
        <span class="s1">)</span>
        <span class="s1">interp_s = ser.reindex(new_index).interpolate(method=</span><span class="s2">&quot;akima&quot;</span><span class="s0">, </span><span class="s1">der=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(interp_s[</span><span class="s4">1</span><span class="s1">:</span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@td.skip_if_no_scipy</span>
    <span class="s0">def </span><span class="s1">test_interpolate_piecewise_polynomial(self):</span>
        <span class="s1">ser = Series([</span><span class="s4">10</span><span class="s0">, </span><span class="s4">11</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">13</span><span class="s1">])</span>

        <span class="s1">expected = Series(</span>
            <span class="s1">[</span><span class="s4">11.00</span><span class="s0">, </span><span class="s4">11.25</span><span class="s0">, </span><span class="s4">11.50</span><span class="s0">, </span><span class="s4">11.75</span><span class="s0">, </span><span class="s4">12.00</span><span class="s0">, </span><span class="s4">12.25</span><span class="s0">, </span><span class="s4">12.50</span><span class="s0">, </span><span class="s4">12.75</span><span class="s0">, </span><span class="s4">13.00</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">index=Index([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">1.25</span><span class="s0">, </span><span class="s4">1.5</span><span class="s0">, </span><span class="s4">1.75</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">2.25</span><span class="s0">, </span><span class="s4">2.5</span><span class="s0">, </span><span class="s4">2.75</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s5"># interpolate at new_index</span>
        <span class="s1">new_index = ser.index.union(Index([</span><span class="s4">1.25</span><span class="s0">, </span><span class="s4">1.5</span><span class="s0">, </span><span class="s4">1.75</span><span class="s0">, </span><span class="s4">2.25</span><span class="s0">, </span><span class="s4">2.5</span><span class="s0">, </span><span class="s4">2.75</span><span class="s1">])).astype(</span>
            <span class="s1">float</span>
        <span class="s1">)</span>
        <span class="s1">interp_s = ser.reindex(new_index).interpolate(method=</span><span class="s2">&quot;piecewise_polynomial&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(interp_s[</span><span class="s4">1</span><span class="s1">:</span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@td.skip_if_no_scipy</span>
    <span class="s0">def </span><span class="s1">test_interpolate_from_derivatives(self):</span>
        <span class="s1">ser = Series([</span><span class="s4">10</span><span class="s0">, </span><span class="s4">11</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">13</span><span class="s1">])</span>

        <span class="s1">expected = Series(</span>
            <span class="s1">[</span><span class="s4">11.00</span><span class="s0">, </span><span class="s4">11.25</span><span class="s0">, </span><span class="s4">11.50</span><span class="s0">, </span><span class="s4">11.75</span><span class="s0">, </span><span class="s4">12.00</span><span class="s0">, </span><span class="s4">12.25</span><span class="s0">, </span><span class="s4">12.50</span><span class="s0">, </span><span class="s4">12.75</span><span class="s0">, </span><span class="s4">13.00</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">index=Index([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">1.25</span><span class="s0">, </span><span class="s4">1.5</span><span class="s0">, </span><span class="s4">1.75</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">2.25</span><span class="s0">, </span><span class="s4">2.5</span><span class="s0">, </span><span class="s4">2.75</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s5"># interpolate at new_index</span>
        <span class="s1">new_index = ser.index.union(Index([</span><span class="s4">1.25</span><span class="s0">, </span><span class="s4">1.5</span><span class="s0">, </span><span class="s4">1.75</span><span class="s0">, </span><span class="s4">2.25</span><span class="s0">, </span><span class="s4">2.5</span><span class="s0">, </span><span class="s4">2.75</span><span class="s1">])).astype(</span>
            <span class="s1">float</span>
        <span class="s1">)</span>
        <span class="s1">interp_s = ser.reindex(new_index).interpolate(method=</span><span class="s2">&quot;from_derivatives&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(interp_s[</span><span class="s4">1</span><span class="s1">:</span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;kwargs&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">{}</span><span class="s0">,</span>
            <span class="s1">pytest.param(</span>
                <span class="s1">{</span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;polynomial&quot;</span><span class="s0">, </span><span class="s2">&quot;order&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s0">, </span><span class="s1">marks=td.skip_if_no_scipy</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_interpolate_corners(self</span><span class="s0">, </span><span class="s1">kwargs):</span>
        <span class="s1">s = Series([np.nan</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s1">tm.assert_series_equal(s.interpolate(**kwargs)</span><span class="s0">, </span><span class="s1">s)</span>

        <span class="s1">s = Series([]</span><span class="s0">, </span><span class="s1">dtype=object).interpolate()</span>
        <span class="s1">tm.assert_series_equal(s.interpolate(**kwargs)</span><span class="s0">, </span><span class="s1">s)</span>

    <span class="s0">def </span><span class="s1">test_interpolate_index_values(self):</span>
        <span class="s1">s = Series(np.nan</span><span class="s0">, </span><span class="s1">index=np.sort(np.random.rand(</span><span class="s4">30</span><span class="s1">)))</span>
        <span class="s1">s[::</span><span class="s4">3</span><span class="s1">] = np.random.randn(</span><span class="s4">10</span><span class="s1">)</span>

        <span class="s1">vals = s.index.values.astype(float)</span>

        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>

        <span class="s1">expected = s.copy()</span>
        <span class="s1">bad = isna(expected.values)</span>
        <span class="s1">good = ~bad</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">np.interp(vals[bad]</span><span class="s0">, </span><span class="s1">vals[good]</span><span class="s0">, </span><span class="s1">s.values[good])</span><span class="s0">, </span><span class="s1">index=s.index[bad]</span>
        <span class="s1">)</span>

        <span class="s1">tm.assert_series_equal(result[bad]</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s5"># 'values' is synonymous with 'index' for the method kwarg</span>
        <span class="s1">other_result = s.interpolate(method=</span><span class="s2">&quot;values&quot;</span><span class="s1">)</span>

        <span class="s1">tm.assert_series_equal(other_result</span><span class="s0">, </span><span class="s1">result)</span>
        <span class="s1">tm.assert_series_equal(other_result[bad]</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_interpolate_non_ts(self):</span>
        <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">11</span><span class="s1">])</span>
        <span class="s1">msg = (</span>
            <span class="s2">&quot;time-weighted interpolation only works on Series or DataFrames &quot;</span>
            <span class="s2">&quot;with a DatetimeIndex&quot;</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s.interpolate(method=</span><span class="s2">&quot;time&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;kwargs&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">{}</span><span class="s0">,</span>
            <span class="s1">pytest.param(</span>
                <span class="s1">{</span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;polynomial&quot;</span><span class="s0">, </span><span class="s2">&quot;order&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s0">, </span><span class="s1">marks=td.skip_if_no_scipy</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_nan_interpolate(self</span><span class="s0">, </span><span class="s1">kwargs):</span>
        <span class="s1">s = Series([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">result = s.interpolate(**kwargs)</span>
        <span class="s1">expected = Series([</span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_nan_irregular_index(self):</span>
        <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">9</span><span class="s1">])</span>
        <span class="s1">result = s.interpolate()</span>
        <span class="s1">expected = Series([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">9</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_nan_str_index(self):</span>
        <span class="s1">s = Series([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;abcd&quot;</span><span class="s1">))</span>
        <span class="s1">result = s.interpolate()</span>
        <span class="s1">expected = Series([</span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;abcd&quot;</span><span class="s1">))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@td.skip_if_no_scipy</span>
    <span class="s0">def </span><span class="s1">test_interp_quad(self):</span>
        <span class="s1">sq = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">16</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">])</span>
        <span class="s1">result = sq.interpolate(method=</span><span class="s2">&quot;quadratic&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s0">, </span><span class="s4">9.0</span><span class="s0">, </span><span class="s4">16.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@td.skip_if_no_scipy</span>
    <span class="s0">def </span><span class="s1">test_interp_scipy_basic(self):</span>
        <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">25</span><span class="s1">])</span>
        <span class="s5"># slinear</span>
        <span class="s1">expected = Series([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">7.5</span><span class="s0">, </span><span class="s4">12.0</span><span class="s0">, </span><span class="s4">18.5</span><span class="s0">, </span><span class="s4">25.0</span><span class="s1">])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;slinear&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;slinear&quot;</span><span class="s0">, </span><span class="s1">downcast=</span><span class="s2">&quot;infer&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s5"># nearest</span>
        <span class="s1">expected = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">25</span><span class="s1">])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;nearest&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected.astype(</span><span class="s2">&quot;float&quot;</span><span class="s1">))</span>

        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;nearest&quot;</span><span class="s0">, </span><span class="s1">downcast=</span><span class="s2">&quot;infer&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s5"># zero</span>
        <span class="s1">expected = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">25</span><span class="s1">])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;zero&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected.astype(</span><span class="s2">&quot;float&quot;</span><span class="s1">))</span>

        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;zero&quot;</span><span class="s0">, </span><span class="s1">downcast=</span><span class="s2">&quot;infer&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s5"># quadratic</span>
        <span class="s5"># GH #15662.</span>
        <span class="s1">expected = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">6.823529</span><span class="s0">, </span><span class="s4">12.0</span><span class="s0">, </span><span class="s4">18.058824</span><span class="s0">, </span><span class="s4">25.0</span><span class="s1">])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;quadratic&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;quadratic&quot;</span><span class="s0">, </span><span class="s1">downcast=</span><span class="s2">&quot;infer&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s5"># cubic</span>
        <span class="s1">expected = Series([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">6.8</span><span class="s0">, </span><span class="s4">12.0</span><span class="s0">, </span><span class="s4">18.2</span><span class="s0">, </span><span class="s4">25.0</span><span class="s1">])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;cubic&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_interp_limit(self):</span>
        <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">11</span><span class="s1">])</span>

        <span class="s1">expected = Series([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">11.0</span><span class="s1">])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;limit&quot;</span><span class="s0">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_interpolate_invalid_nonpositive_limit(self</span><span class="s0">, </span><span class="s1">nontemporal_method</span><span class="s0">, </span><span class="s1">limit):</span>
        <span class="s5"># GH 9217: make sure limit is greater than zero.</span>
        <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">4</span><span class="s1">])</span>
        <span class="s1">method</span><span class="s0">, </span><span class="s1">kwargs = nontemporal_method</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Limit must be greater than 0&quot;</span><span class="s1">):</span>
            <span class="s1">s.interpolate(limit=limit</span><span class="s0">, </span><span class="s1">method=method</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_interpolate_invalid_float_limit(self</span><span class="s0">, </span><span class="s1">nontemporal_method):</span>
        <span class="s5"># GH 9217: make sure limit is an integer.</span>
        <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">4</span><span class="s1">])</span>
        <span class="s1">method</span><span class="s0">, </span><span class="s1">kwargs = nontemporal_method</span>
        <span class="s1">limit = </span><span class="s4">2.0</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Limit must be an integer&quot;</span><span class="s1">):</span>
            <span class="s1">s.interpolate(limit=limit</span><span class="s0">, </span><span class="s1">method=method</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;invalid_method&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s2">&quot;nonexistent_method&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_interp_invalid_method(self</span><span class="s0">, </span><span class="s1">invalid_method):</span>
        <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">25</span><span class="s1">])</span>

        <span class="s1">msg = </span><span class="s2">f&quot;method must be one of.* Got '</span><span class="s0">{</span><span class="s1">invalid_method</span><span class="s0">}</span><span class="s2">' instead&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s.interpolate(method=invalid_method)</span>

        <span class="s5"># When an invalid method and invalid limit (such as -1) are</span>
        <span class="s5"># provided, the error message reflects the invalid method.</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s.interpolate(method=invalid_method</span><span class="s0">, </span><span class="s1">limit=-</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_interp_invalid_method_and_value(self):</span>
        <span class="s5"># GH#36624</span>
        <span class="s1">ser = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">25</span><span class="s1">])</span>

        <span class="s1">msg = </span><span class="s2">&quot;Cannot pass both fill_value and method&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">ser.interpolate(fill_value=</span><span class="s4">3</span><span class="s0">, </span><span class="s1">method=</span><span class="s2">&quot;pad&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_interp_limit_forward(self):</span>
        <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">11</span><span class="s1">])</span>

        <span class="s5"># Provide 'forward' (the default) explicitly here.</span>
        <span class="s1">expected = Series([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">11.0</span><span class="s1">])</span>

        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">limit_direction=</span><span class="s2">&quot;forward&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">limit_direction=</span><span class="s2">&quot;FORWARD&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_interp_unlimited(self):</span>
        <span class="s5"># these test are for issue #16282 default Limit=None is unlimited</span>
        <span class="s1">s = Series([np.nan</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">11.0</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s1">expected = Series([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">9.0</span><span class="s0">, </span><span class="s4">11.0</span><span class="s0">, </span><span class="s4">11.0</span><span class="s1">])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit_direction=</span><span class="s2">&quot;both&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series([np.nan</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">9.0</span><span class="s0">, </span><span class="s4">11.0</span><span class="s0">, </span><span class="s4">11.0</span><span class="s1">])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit_direction=</span><span class="s2">&quot;forward&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">9.0</span><span class="s0">, </span><span class="s4">11.0</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit_direction=</span><span class="s2">&quot;backward&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_interp_limit_bad_direction(self):</span>
        <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">11</span><span class="s1">])</span>

        <span class="s1">msg = (</span>
            <span class="s2">r&quot;Invalid limit_direction: expecting one of \['forward', &quot;</span>
            <span class="s2">r&quot;'backward', 'both'\], got 'abc'&quot;</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">limit_direction=</span><span class="s2">&quot;abc&quot;</span><span class="s1">)</span>

        <span class="s5"># raises an error even if no limit is specified.</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit_direction=</span><span class="s2">&quot;abc&quot;</span><span class="s1">)</span>

    <span class="s5"># limit_area introduced GH #16284</span>
    <span class="s0">def </span><span class="s1">test_interp_limit_area(self):</span>
        <span class="s5"># These tests are for issue #9218 -- fill NaNs in both directions.</span>
        <span class="s1">s = Series([np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan])</span>

        <span class="s1">expected = Series([np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">6.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit_area=</span><span class="s2">&quot;inside&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series(</span>
            <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span>
        <span class="s1">)</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit_area=</span><span class="s2">&quot;inside&quot;</span><span class="s0">, </span><span class="s1">limit=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series([np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">6.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s1">result = s.interpolate(</span>
            <span class="s1">method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit_area=</span><span class="s2">&quot;inside&quot;</span><span class="s0">, </span><span class="s1">limit_direction=</span><span class="s2">&quot;both&quot;</span><span class="s0">, </span><span class="s1">limit=</span><span class="s4">1</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series([np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s1">])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit_area=</span><span class="s2">&quot;outside&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series(</span>
            <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s1">np.nan]</span>
        <span class="s1">)</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit_area=</span><span class="s2">&quot;outside&quot;</span><span class="s0">, </span><span class="s1">limit=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series([np.nan</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s1">result = s.interpolate(</span>
            <span class="s1">method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit_area=</span><span class="s2">&quot;outside&quot;</span><span class="s0">, </span><span class="s1">limit_direction=</span><span class="s2">&quot;both&quot;</span><span class="s0">, </span><span class="s1">limit=</span><span class="s4">1</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series([</span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s1">result = s.interpolate(</span>
            <span class="s1">method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit_area=</span><span class="s2">&quot;outside&quot;</span><span class="s0">, </span><span class="s1">limit_direction=</span><span class="s2">&quot;backward&quot;</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s5"># raises an error even if limit type is wrong.</span>
        <span class="s1">msg = </span><span class="s2">r&quot;Invalid limit_area: expecting one of \['inside', 'outside'\], got abc&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit_area=</span><span class="s2">&quot;abc&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;method, limit_direction, expected&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s2">&quot;pad&quot;</span><span class="s0">, </span><span class="s2">&quot;backward&quot;</span><span class="s0">, </span><span class="s2">&quot;forward&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;ffill&quot;</span><span class="s0">, </span><span class="s2">&quot;backward&quot;</span><span class="s0">, </span><span class="s2">&quot;forward&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;backfill&quot;</span><span class="s0">, </span><span class="s2">&quot;forward&quot;</span><span class="s0">, </span><span class="s2">&quot;backward&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;bfill&quot;</span><span class="s0">, </span><span class="s2">&quot;forward&quot;</span><span class="s0">, </span><span class="s2">&quot;backward&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;pad&quot;</span><span class="s0">, </span><span class="s2">&quot;both&quot;</span><span class="s0">, </span><span class="s2">&quot;forward&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;ffill&quot;</span><span class="s0">, </span><span class="s2">&quot;both&quot;</span><span class="s0">, </span><span class="s2">&quot;forward&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;backfill&quot;</span><span class="s0">, </span><span class="s2">&quot;both&quot;</span><span class="s0">, </span><span class="s2">&quot;backward&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;bfill&quot;</span><span class="s0">, </span><span class="s2">&quot;both&quot;</span><span class="s0">, </span><span class="s2">&quot;backward&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_interp_limit_direction_raises(self</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">limit_direction</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s5"># https://github.com/pandas-dev/pandas/pull/34746</span>
        <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>

        <span class="s1">msg = </span><span class="s2">f&quot;`limit_direction` must be '</span><span class="s0">{</span><span class="s1">expected</span><span class="s0">}</span><span class="s2">' for method `</span><span class="s0">{</span><span class="s1">method</span><span class="s0">}</span><span class="s2">`&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s.interpolate(method=method</span><span class="s0">, </span><span class="s1">limit_direction=limit_direction)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;data, expected_data, kwargs&quot;</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">(</span>
                <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
                <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;pad&quot;</span><span class="s0">, </span><span class="s2">&quot;limit_area&quot;</span><span class="s1">: </span><span class="s2">&quot;inside&quot;</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
                <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;pad&quot;</span><span class="s0">, </span><span class="s2">&quot;limit_area&quot;</span><span class="s1">: </span><span class="s2">&quot;inside&quot;</span><span class="s0">, </span><span class="s2">&quot;limit&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
                <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;pad&quot;</span><span class="s0">, </span><span class="s2">&quot;limit_area&quot;</span><span class="s1">: </span><span class="s2">&quot;outside&quot;</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
                <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;pad&quot;</span><span class="s0">, </span><span class="s2">&quot;limit_area&quot;</span><span class="s1">: </span><span class="s2">&quot;outside&quot;</span><span class="s0">, </span><span class="s2">&quot;limit&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
                <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;pad&quot;</span><span class="s0">, </span><span class="s2">&quot;limit_area&quot;</span><span class="s1">: </span><span class="s2">&quot;outside&quot;</span><span class="s0">, </span><span class="s2">&quot;limit&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">range(</span><span class="s4">5</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">range(</span><span class="s4">5</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;pad&quot;</span><span class="s0">, </span><span class="s2">&quot;limit_area&quot;</span><span class="s1">: </span><span class="s2">&quot;outside&quot;</span><span class="s0">, </span><span class="s2">&quot;limit&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_interp_limit_area_with_pad(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">expected_data</span><span class="s0">, </span><span class="s1">kwargs):</span>
        <span class="s5"># GH26796</span>

        <span class="s1">s = Series(data)</span>
        <span class="s1">expected = Series(expected_data)</span>
        <span class="s1">result = s.interpolate(**kwargs)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;data, expected_data, kwargs&quot;</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">(</span>
                <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
                <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;bfill&quot;</span><span class="s0">, </span><span class="s2">&quot;limit_area&quot;</span><span class="s1">: </span><span class="s2">&quot;inside&quot;</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
                <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;bfill&quot;</span><span class="s0">, </span><span class="s2">&quot;limit_area&quot;</span><span class="s1">: </span><span class="s2">&quot;inside&quot;</span><span class="s0">, </span><span class="s2">&quot;limit&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;bfill&quot;</span><span class="s0">, </span><span class="s2">&quot;limit_area&quot;</span><span class="s1">: </span><span class="s2">&quot;outside&quot;</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
                <span class="s1">[np.nan</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
                <span class="s1">{</span><span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;bfill&quot;</span><span class="s0">, </span><span class="s2">&quot;limit_area&quot;</span><span class="s1">: </span><span class="s2">&quot;outside&quot;</span><span class="s0">, </span><span class="s2">&quot;limit&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_interp_limit_area_with_backfill(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">expected_data</span><span class="s0">, </span><span class="s1">kwargs):</span>
        <span class="s5"># GH26796</span>

        <span class="s1">s = Series(data)</span>
        <span class="s1">expected = Series(expected_data)</span>
        <span class="s1">result = s.interpolate(**kwargs)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_interp_limit_direction(self):</span>
        <span class="s5"># These tests are for issue #9218 -- fill NaNs in both directions.</span>
        <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">11</span><span class="s1">])</span>

        <span class="s1">expected = Series([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">9.0</span><span class="s0">, </span><span class="s4">11.0</span><span class="s1">])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">limit_direction=</span><span class="s2">&quot;backward&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">9.0</span><span class="s0">, </span><span class="s4">11.0</span><span class="s1">])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">limit_direction=</span><span class="s2">&quot;both&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s5"># Check that this works on a longer series of nans.</span>
        <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s4">9</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s1">np.nan])</span>

        <span class="s1">expected = Series([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">6.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">9.0</span><span class="s0">, </span><span class="s4">10.0</span><span class="s0">, </span><span class="s4">11.0</span><span class="s0">, </span><span class="s4">12.0</span><span class="s0">, </span><span class="s4">12.0</span><span class="s1">])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">limit_direction=</span><span class="s2">&quot;both&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series(</span>
            <span class="s1">[</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">6.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">9.0</span><span class="s0">, </span><span class="s4">10.0</span><span class="s0">, </span><span class="s4">11.0</span><span class="s0">, </span><span class="s4">12.0</span><span class="s0">, </span><span class="s4">12.0</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">limit_direction=</span><span class="s2">&quot;both&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_interp_limit_to_ends(self):</span>
        <span class="s5"># These test are for issue #10420 -- flow back to beginning.</span>
        <span class="s1">s = Series([np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s4">9</span><span class="s0">, </span><span class="s1">np.nan])</span>

        <span class="s1">expected = Series([</span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">9.0</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">limit_direction=</span><span class="s2">&quot;backward&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series([</span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">9.0</span><span class="s0">, </span><span class="s4">9.0</span><span class="s1">])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">limit_direction=</span><span class="s2">&quot;both&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_interp_limit_before_ends(self):</span>
        <span class="s5"># These test are for issue #11115 -- limit ends properly.</span>
        <span class="s1">s = Series([np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan])</span>

        <span class="s1">expected = Series([np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">limit_direction=</span><span class="s2">&quot;forward&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series([np.nan</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">limit_direction=</span><span class="s2">&quot;backward&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Series([np.nan</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">limit=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">limit_direction=</span><span class="s2">&quot;both&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@td.skip_if_no_scipy</span>
    <span class="s0">def </span><span class="s1">test_interp_all_good(self):</span>
        <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;polynomial&quot;</span><span class="s0">, </span><span class="s1">order=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">s)</span>

        <span class="s5"># non-scipy</span>
        <span class="s1">result = s.interpolate()</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">s)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;check_scipy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, </span><span class="s1">pytest.param(</span><span class="s0">True, </span><span class="s1">marks=td.skip_if_no_scipy)]</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_interp_multiIndex(self</span><span class="s0">, </span><span class="s1">check_scipy):</span>
        <span class="s1">idx = MultiIndex.from_tuples([(</span><span class="s4">0</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">)])</span>
        <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">index=idx)</span>

        <span class="s1">expected = s.copy()</span>
        <span class="s1">expected.loc[</span><span class="s4">2</span><span class="s1">] = </span><span class="s4">2</span>
        <span class="s1">result = s.interpolate()</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">msg = </span><span class="s2">&quot;Only `method=linear` interpolation is supported on MultiIndexes&quot;</span>
        <span class="s0">if </span><span class="s1">check_scipy:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">s.interpolate(method=</span><span class="s2">&quot;polynomial&quot;</span><span class="s0">, </span><span class="s1">order=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">@td.skip_if_no_scipy</span>
    <span class="s0">def </span><span class="s1">test_interp_nonmono_raise(self):</span>
        <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">msg = </span><span class="s2">&quot;krogh interpolation requires that the index be monotonic&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s.interpolate(method=</span><span class="s2">&quot;krogh&quot;</span><span class="s1">)</span>

    <span class="s1">@td.skip_if_no_scipy</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;method&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;nearest&quot;</span><span class="s0">, </span><span class="s2">&quot;pad&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_interp_datetime64(self</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">tz_naive_fixture):</span>
        <span class="s1">df = Series(</span>
            <span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=date_range(</span><span class="s2">&quot;1/1/2000&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s0">, </span><span class="s1">tz=tz_naive_fixture)</span>
        <span class="s1">)</span>
        <span class="s1">result = df.interpolate(method=method)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">index=date_range(</span><span class="s2">&quot;1/1/2000&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s0">, </span><span class="s1">tz=tz_naive_fixture)</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_interp_pad_datetime64tz_values(self):</span>
        <span class="s5"># GH#27628 missing.interpolate_2d should handle datetimetz values</span>
        <span class="s1">dti = date_range(</span><span class="s2">&quot;2015-04-05&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Central&quot;</span><span class="s1">)</span>
        <span class="s1">ser = Series(dti)</span>
        <span class="s1">ser[</span><span class="s4">1</span><span class="s1">] = pd.NaT</span>
        <span class="s1">result = ser.interpolate(method=</span><span class="s2">&quot;pad&quot;</span><span class="s1">)</span>

        <span class="s1">expected = Series(dti)</span>
        <span class="s1">expected[</span><span class="s4">1</span><span class="s1">] = expected[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_interp_limit_no_nans(self):</span>
        <span class="s5"># GH 7173</span>
        <span class="s1">s = Series([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">])</span>
        <span class="s1">result = s.interpolate(limit=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">expected = s</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@td.skip_if_no_scipy</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;method&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;polynomial&quot;</span><span class="s0">, </span><span class="s2">&quot;spline&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_no_order(self</span><span class="s0">, </span><span class="s1">method):</span>
        <span class="s5"># see GH-10633, GH-24014</span>
        <span class="s1">s = Series([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">msg = </span><span class="s2">&quot;You must specify the order of the spline or polynomial&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s.interpolate(method=method)</span>

    <span class="s1">@td.skip_if_no_scipy</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;order&quot;</span><span class="s0">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0.0</span><span class="s0">, </span><span class="s1">np.nan])</span>
    <span class="s0">def </span><span class="s1">test_interpolate_spline_invalid_order(self</span><span class="s0">, </span><span class="s1">order):</span>
        <span class="s1">s = Series([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">msg = </span><span class="s2">&quot;order needs to be specified and greater than 0&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s.interpolate(method=</span><span class="s2">&quot;spline&quot;</span><span class="s0">, </span><span class="s1">order=order)</span>

    <span class="s1">@td.skip_if_no_scipy</span>
    <span class="s0">def </span><span class="s1">test_spline(self):</span>
        <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7</span><span class="s1">])</span>
        <span class="s1">result = s.interpolate(method=</span><span class="s2">&quot;spline&quot;</span><span class="s0">, </span><span class="s1">order=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">6.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@td.skip_if_no_scipy</span>
    <span class="s0">def </span><span class="s1">test_spline_extrapolate(self):</span>
        <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s1">np.nan])</span>
        <span class="s1">result3 = s.interpolate(method=</span><span class="s2">&quot;spline&quot;</span><span class="s0">, </span><span class="s1">order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">ext=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">expected3 = Series([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">6.0</span><span class="s0">, </span><span class="s4">6.0</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result3</span><span class="s0">, </span><span class="s1">expected3)</span>

        <span class="s1">result1 = s.interpolate(method=</span><span class="s2">&quot;spline&quot;</span><span class="s0">, </span><span class="s1">order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">ext=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">expected1 = Series([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s0">, </span><span class="s4">6.0</span><span class="s0">, </span><span class="s4">7.0</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result1</span><span class="s0">, </span><span class="s1">expected1)</span>

    <span class="s1">@td.skip_if_no_scipy</span>
    <span class="s0">def </span><span class="s1">test_spline_smooth(self):</span>
        <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5.1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">7</span><span class="s1">])</span>
        <span class="s0">assert </span><span class="s1">(</span>
            <span class="s1">s.interpolate(method=</span><span class="s2">&quot;spline&quot;</span><span class="s0">, </span><span class="s1">order=</span><span class="s4">3</span><span class="s0">, </span><span class="s1">s=</span><span class="s4">0</span><span class="s1">)[</span><span class="s4">5</span><span class="s1">]</span>
            <span class="s1">!= s.interpolate(method=</span><span class="s2">&quot;spline&quot;</span><span class="s0">, </span><span class="s1">order=</span><span class="s4">3</span><span class="s1">)[</span><span class="s4">5</span><span class="s1">]</span>
        <span class="s1">)</span>

    <span class="s1">@td.skip_if_no_scipy</span>
    <span class="s0">def </span><span class="s1">test_spline_interpolation(self):</span>
        <span class="s1">s = Series(np.arange(</span><span class="s4">10</span><span class="s1">) ** </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">s[np.random.randint(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">9</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)] = np.nan</span>
        <span class="s1">result1 = s.interpolate(method=</span><span class="s2">&quot;spline&quot;</span><span class="s0">, </span><span class="s1">order=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">expected1 = s.interpolate(method=</span><span class="s2">&quot;spline&quot;</span><span class="s0">, </span><span class="s1">order=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result1</span><span class="s0">, </span><span class="s1">expected1)</span>

    <span class="s0">def </span><span class="s1">test_interp_timedelta64(self):</span>
        <span class="s5"># GH 6424</span>
        <span class="s1">df = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=pd.to_timedelta([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]))</span>
        <span class="s1">result = df.interpolate(method=</span><span class="s2">&quot;time&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=pd.to_timedelta([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s5"># test for non uniform spacing</span>
        <span class="s1">df = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=pd.to_timedelta([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">4</span><span class="s1">]))</span>
        <span class="s1">result = df.interpolate(method=</span><span class="s2">&quot;time&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">1.666667</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=pd.to_timedelta([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">4</span><span class="s1">]))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_series_interpolate_method_values(self):</span>
        <span class="s5"># GH#1646</span>
        <span class="s1">rng = date_range(</span><span class="s2">&quot;1/1/2000&quot;</span><span class="s0">, </span><span class="s2">&quot;1/20/2000&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;D&quot;</span><span class="s1">)</span>
        <span class="s1">ts = Series(np.random.randn(len(rng))</span><span class="s0">, </span><span class="s1">index=rng)</span>

        <span class="s1">ts[::</span><span class="s4">2</span><span class="s1">] = np.nan</span>

        <span class="s1">result = ts.interpolate(method=</span><span class="s2">&quot;values&quot;</span><span class="s1">)</span>
        <span class="s1">exp = ts.interpolate()</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s0">def </span><span class="s1">test_series_interpolate_intraday(self):</span>
        <span class="s5"># #1698</span>
        <span class="s1">index = date_range(</span><span class="s2">&quot;1/1/2012&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s4">4</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;12D&quot;</span><span class="s1">)</span>
        <span class="s1">ts = Series([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">24</span><span class="s0">, </span><span class="s4">36</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index)</span>
        <span class="s1">new_index = index.append(index + pd.DateOffset(days=</span><span class="s4">1</span><span class="s1">)).sort_values()</span>

        <span class="s1">exp = ts.reindex(new_index).interpolate(method=</span><span class="s2">&quot;time&quot;</span><span class="s1">)</span>

        <span class="s1">index = date_range(</span><span class="s2">&quot;1/1/2012&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s4">4</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;12H&quot;</span><span class="s1">)</span>
        <span class="s1">ts = Series([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">24</span><span class="s0">, </span><span class="s4">36</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index)</span>
        <span class="s1">new_index = index.append(index + pd.DateOffset(hours=</span><span class="s4">1</span><span class="s1">)).sort_values()</span>
        <span class="s1">result = ts.reindex(new_index).interpolate(method=</span><span class="s2">&quot;time&quot;</span><span class="s1">)</span>

        <span class="s1">tm.assert_numpy_array_equal(result.values</span><span class="s0">, </span><span class="s1">exp.values)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;ind&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">pd.period_range(start=</span><span class="s2">&quot;2019-01-01&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s4">4</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">pd.interval_range(start=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">end=</span><span class="s4">4</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_interp_non_timedelta_index(self</span><span class="s0">, </span><span class="s1">interp_methods_ind</span><span class="s0">, </span><span class="s1">ind):</span>
        <span class="s5"># gh 21662</span>
        <span class="s1">df = pd.DataFrame([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=ind)</span>

        <span class="s1">method</span><span class="s0">, </span><span class="s1">kwargs = interp_methods_ind</span>
        <span class="s0">if </span><span class="s1">method == </span><span class="s2">&quot;pchip&quot;</span><span class="s1">:</span>
            <span class="s1">pytest.importorskip(</span><span class="s2">&quot;scipy&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">method == </span><span class="s2">&quot;linear&quot;</span><span class="s1">:</span>
            <span class="s1">result = df[</span><span class="s4">0</span><span class="s1">].interpolate(**kwargs)</span>
            <span class="s1">expected = Series([</span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">index=ind)</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expected_error = (</span>
                <span class="s2">&quot;Index column must be numeric or datetime type when &quot;</span>
                <span class="s2">f&quot;using </span><span class="s0">{</span><span class="s1">method</span><span class="s0">} </span><span class="s2">method other than linear. &quot;</span>
                <span class="s2">&quot;Try setting a numeric or datetime index column before &quot;</span>
                <span class="s2">&quot;interpolating.&quot;</span>
            <span class="s1">)</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=expected_error):</span>
                <span class="s1">df[</span><span class="s4">0</span><span class="s1">].interpolate(method=method</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_interpolate_timedelta_index(self</span><span class="s0">, </span><span class="s1">interp_methods_ind):</span>
        <span class="s3">&quot;&quot;&quot; 
        Tests for non numerical index types  - object, period, timedelta 
        Note that all methods except time, index, nearest and values 
        are tested here. 
        &quot;&quot;&quot;</span>
        <span class="s5"># gh 21662</span>
        <span class="s1">ind = pd.timedelta_range(start=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">periods=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">df = pd.DataFrame([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=ind)</span>

        <span class="s1">method</span><span class="s0">, </span><span class="s1">kwargs = interp_methods_ind</span>
        <span class="s0">if </span><span class="s1">method == </span><span class="s2">&quot;pchip&quot;</span><span class="s1">:</span>
            <span class="s1">pytest.importorskip(</span><span class="s2">&quot;scipy&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">method </span><span class="s0">in </span><span class="s1">{</span><span class="s2">&quot;linear&quot;</span><span class="s0">, </span><span class="s2">&quot;pchip&quot;</span><span class="s1">}:</span>
            <span class="s1">result = df[</span><span class="s4">0</span><span class="s1">].interpolate(method=method</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s1">expected = Series([</span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">3.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">index=ind)</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">pytest.skip(</span>
                <span class="s2">&quot;This interpolation method is not supported for Timedelta Index yet.&quot;</span>
            <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s2">&quot;ascending, expected_values&quot;</span><span class="s0">,</span>
        <span class="s1">[(</span><span class="s0">True, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">9</span><span class="s0">, </span><span class="s4">10</span><span class="s1">])</span><span class="s0">, </span><span class="s1">(</span><span class="s0">False, </span><span class="s1">[</span><span class="s4">10</span><span class="s0">, </span><span class="s4">9</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_interpolate_unsorted_index(self</span><span class="s0">, </span><span class="s1">ascending</span><span class="s0">, </span><span class="s1">expected_values):</span>
        <span class="s5"># GH 21037</span>
        <span class="s1">ts = Series(data=[</span><span class="s4">10</span><span class="s0">, </span><span class="s4">9</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s4">10</span><span class="s0">, </span><span class="s4">9</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">result = ts.sort_index(ascending=ascending).interpolate(method=</span><span class="s2">&quot;index&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series(data=expected_values</span><span class="s0">, </span><span class="s1">index=expected_values</span><span class="s0">, </span><span class="s1">dtype=float)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_interpolate_pos_args_deprecation(self):</span>
        <span class="s5"># https://github.com/pandas-dev/pandas/issues/41485</span>
        <span class="s1">ser = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">msg = (</span>
            <span class="s2">r&quot;In a future version of pandas all arguments of Series.interpolate except &quot;</span>
            <span class="s2">r&quot;for the argument 'method' will be keyword-only&quot;</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">result = ser.interpolate(</span><span class="s2">&quot;pad&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">expected = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
</pre>
</body>
</html>