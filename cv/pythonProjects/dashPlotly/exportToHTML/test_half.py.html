<html>
<head>
<title>test_half.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_half.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">platform</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy </span><span class="s0">import </span><span class="s1">uint16</span><span class="s0">, </span><span class="s1">float16</span><span class="s0">, </span><span class="s1">float32</span><span class="s0">, </span><span class="s1">float64</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_</span><span class="s0">, </span><span class="s1">assert_equal</span>


<span class="s0">def </span><span class="s1">assert_raises_fpe(strmatch</span><span class="s0">, </span><span class="s1">callable</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">callable(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">except </span><span class="s1">FloatingPointError </span><span class="s0">as </span><span class="s1">exc:</span>
        <span class="s1">assert_(str(exc).find(strmatch) &gt;= </span><span class="s2">0</span><span class="s0">,</span>
                <span class="s3">&quot;Did not raise floating point %s error&quot; </span><span class="s1">% strmatch)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">assert_(</span><span class="s0">False,</span>
                <span class="s3">&quot;Did not raise floating point %s error&quot; </span><span class="s1">% strmatch)</span>

<span class="s0">class </span><span class="s1">TestHalf:</span>
    <span class="s0">def </span><span class="s1">setup(self):</span>
        <span class="s4"># An array of all possible float16 values</span>
        <span class="s1">self.all_f16 = np.arange(</span><span class="s2">0x10000</span><span class="s0">, </span><span class="s1">dtype=uint16)</span>
        <span class="s1">self.all_f16.dtype = float16</span>
        <span class="s1">self.all_f32 = np.array(self.all_f16</span><span class="s0">, </span><span class="s1">dtype=float32)</span>
        <span class="s1">self.all_f64 = np.array(self.all_f16</span><span class="s0">, </span><span class="s1">dtype=float64)</span>

        <span class="s4"># An array of all non-NaN float16 values, in sorted order</span>
        <span class="s1">self.nonan_f16 = np.concatenate(</span>
                                <span class="s1">(np.arange(</span><span class="s2">0xfc00</span><span class="s0">, </span><span class="s2">0x7fff</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">dtype=uint16)</span><span class="s0">,</span>
                                 <span class="s1">np.arange(</span><span class="s2">0x0000</span><span class="s0">, </span><span class="s2">0x7c01</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">dtype=uint16)))</span>
        <span class="s1">self.nonan_f16.dtype = float16</span>
        <span class="s1">self.nonan_f32 = np.array(self.nonan_f16</span><span class="s0">, </span><span class="s1">dtype=float32)</span>
        <span class="s1">self.nonan_f64 = np.array(self.nonan_f16</span><span class="s0">, </span><span class="s1">dtype=float64)</span>

        <span class="s4"># An array of all finite float16 values, in sorted order</span>
        <span class="s1">self.finite_f16 = self.nonan_f16[</span><span class="s2">1</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">self.finite_f32 = self.nonan_f32[</span><span class="s2">1</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">self.finite_f64 = self.nonan_f64[</span><span class="s2">1</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_half_conversions(self):</span>
        <span class="s5">&quot;&quot;&quot;Checks that all 16-bit values survive conversion 
           to/from 32-bit and 64-bit float&quot;&quot;&quot;</span>
        <span class="s4"># Because the underlying routines preserve the NaN bits, every</span>
        <span class="s4"># value is preserved when converting to/from other floats.</span>

        <span class="s4"># Convert from float32 back to float16</span>
        <span class="s1">b = np.array(self.all_f32</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
        <span class="s1">assert_equal(self.all_f16.view(dtype=uint16)</span><span class="s0">,</span>
                     <span class="s1">b.view(dtype=uint16))</span>

        <span class="s4"># Convert from float64 back to float16</span>
        <span class="s1">b = np.array(self.all_f64</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
        <span class="s1">assert_equal(self.all_f16.view(dtype=uint16)</span><span class="s0">,</span>
                     <span class="s1">b.view(dtype=uint16))</span>

        <span class="s4"># Convert float16 to longdouble and back</span>
        <span class="s4"># This doesn't necessarily preserve the extra NaN bits,</span>
        <span class="s4"># so exclude NaNs.</span>
        <span class="s1">a_ld = np.array(self.nonan_f16</span><span class="s0">, </span><span class="s1">dtype=np.longdouble)</span>
        <span class="s1">b = np.array(a_ld</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
        <span class="s1">assert_equal(self.nonan_f16.view(dtype=uint16)</span><span class="s0">,</span>
                     <span class="s1">b.view(dtype=uint16))</span>

        <span class="s4"># Check the range for which all integers can be represented</span>
        <span class="s1">i_int = np.arange(-</span><span class="s2">2048</span><span class="s0">, </span><span class="s2">2049</span><span class="s1">)</span>
        <span class="s1">i_f16 = np.array(i_int</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
        <span class="s1">j = np.array(i_f16</span><span class="s0">, </span><span class="s1">dtype=int)</span>
        <span class="s1">assert_equal(i_int</span><span class="s0">, </span><span class="s1">j)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;string_dt&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;S&quot;</span><span class="s0">, </span><span class="s3">&quot;U&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_half_conversion_to_string(self</span><span class="s0">, </span><span class="s1">string_dt):</span>
        <span class="s4"># Currently uses S/U32 (which is sufficient for float32)</span>
        <span class="s1">expected_dt = np.dtype(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">string_dt</span><span class="s0">}</span><span class="s3">32&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">np.promote_types(np.float16</span><span class="s0">, </span><span class="s1">string_dt) == expected_dt</span>
        <span class="s0">assert </span><span class="s1">np.promote_types(string_dt</span><span class="s0">, </span><span class="s1">np.float16) == expected_dt</span>

        <span class="s1">arr = np.ones(</span><span class="s2">3</span><span class="s0">, </span><span class="s1">dtype=np.float16).astype(string_dt)</span>
        <span class="s0">assert </span><span class="s1">arr.dtype == expected_dt</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;string_dt&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;S&quot;</span><span class="s0">, </span><span class="s3">&quot;U&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_half_conversion_from_string(self</span><span class="s0">, </span><span class="s1">string_dt):</span>
        <span class="s1">string = np.array(</span><span class="s3">&quot;3.1416&quot;</span><span class="s0">, </span><span class="s1">dtype=string_dt)</span>
        <span class="s0">assert </span><span class="s1">string.astype(np.float16) == np.array(</span><span class="s2">3.1416</span><span class="s0">, </span><span class="s1">dtype=np.float16)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;offset&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s3">&quot;up&quot;</span><span class="s0">, </span><span class="s3">&quot;down&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;shift&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s3">&quot;up&quot;</span><span class="s0">, </span><span class="s3">&quot;down&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;float_t&quot;</span><span class="s0">, </span><span class="s1">[np.float32</span><span class="s0">, </span><span class="s1">np.float64])</span>
    <span class="s0">def </span><span class="s1">test_half_conversion_rounding(self</span><span class="s0">, </span><span class="s1">float_t</span><span class="s0">, </span><span class="s1">shift</span><span class="s0">, </span><span class="s1">offset):</span>
        <span class="s4"># Assumes that round to even is used during casting.</span>
        <span class="s1">max_pattern = np.float16(np.finfo(np.float16).max).view(np.uint16)</span>

        <span class="s4"># Test all (positive) finite numbers, denormals are most interesting</span>
        <span class="s4"># however:</span>
        <span class="s1">f16s_patterns = np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">max_pattern+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">dtype=np.uint16)</span>
        <span class="s1">f16s_float = f16s_patterns.view(np.float16).astype(float_t)</span>

        <span class="s4"># Shift the values by half a bit up or a down (or do not shift),</span>
        <span class="s0">if </span><span class="s1">shift == </span><span class="s3">&quot;up&quot;</span><span class="s1">:</span>
            <span class="s1">f16s_float = </span><span class="s2">0.5 </span><span class="s1">* (f16s_float[:-</span><span class="s2">1</span><span class="s1">] + f16s_float[</span><span class="s2">1</span><span class="s1">:])[</span><span class="s2">1</span><span class="s1">:]</span>
        <span class="s0">elif </span><span class="s1">shift == </span><span class="s3">&quot;down&quot;</span><span class="s1">:</span>
            <span class="s1">f16s_float = </span><span class="s2">0.5 </span><span class="s1">* (f16s_float[:-</span><span class="s2">1</span><span class="s1">] + f16s_float[</span><span class="s2">1</span><span class="s1">:])[:-</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">f16s_float = f16s_float[</span><span class="s2">1</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">]</span>

        <span class="s4"># Increase the float by a minimal value:</span>
        <span class="s0">if </span><span class="s1">offset == </span><span class="s3">&quot;up&quot;</span><span class="s1">:</span>
            <span class="s1">f16s_float = np.nextafter(f16s_float</span><span class="s0">, </span><span class="s1">float_t(</span><span class="s2">1e50</span><span class="s1">))</span>
        <span class="s0">elif </span><span class="s1">offset == </span><span class="s3">&quot;down&quot;</span><span class="s1">:</span>
            <span class="s1">f16s_float = np.nextafter(f16s_float</span><span class="s0">, </span><span class="s1">float_t(-</span><span class="s2">1e50</span><span class="s1">))</span>

        <span class="s4"># Convert back to float16 and its bit pattern:</span>
        <span class="s1">res_patterns = f16s_float.astype(np.float16).view(np.uint16)</span>

        <span class="s4"># The above calculations tries the original values, or the exact</span>
        <span class="s4"># mid points between the float16 values. It then further offsets them</span>
        <span class="s4"># by as little as possible. If no offset occurs, &quot;round to even&quot;</span>
        <span class="s4"># logic will be necessary, an arbitrarily small offset should cause</span>
        <span class="s4"># normal up/down rounding always.</span>

        <span class="s4"># Calculate the expected pattern:</span>
        <span class="s1">cmp_patterns = f16s_patterns[</span><span class="s2">1</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">].copy()</span>

        <span class="s0">if </span><span class="s1">shift == </span><span class="s3">&quot;down&quot; </span><span class="s0">and </span><span class="s1">offset != </span><span class="s3">&quot;up&quot;</span><span class="s1">:</span>
            <span class="s1">shift_pattern = -</span><span class="s2">1</span>
        <span class="s0">elif </span><span class="s1">shift == </span><span class="s3">&quot;up&quot; </span><span class="s0">and </span><span class="s1">offset != </span><span class="s3">&quot;down&quot;</span><span class="s1">:</span>
            <span class="s1">shift_pattern = </span><span class="s2">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># There cannot be a shift, either shift is None, so all rounding</span>
            <span class="s4"># will go back to original, or shift is reduced by offset too much.</span>
            <span class="s1">shift_pattern = </span><span class="s2">0</span>

        <span class="s4"># If rounding occurs, is it normal rounding or round to even?</span>
        <span class="s0">if </span><span class="s1">offset </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s4"># Round to even occurs, modify only non-even, cast to allow + (-1)</span>
            <span class="s1">cmp_patterns[</span><span class="s2">0</span><span class="s1">::</span><span class="s2">2</span><span class="s1">].view(np.int16)[...] += shift_pattern</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">cmp_patterns.view(np.int16)[...] += shift_pattern</span>

        <span class="s1">assert_equal(res_patterns</span><span class="s0">, </span><span class="s1">cmp_patterns)</span>

    <span class="s1">@pytest.mark.parametrize([</span><span class="s3">&quot;float_t&quot;</span><span class="s0">, </span><span class="s3">&quot;uint_t&quot;</span><span class="s0">, </span><span class="s3">&quot;bits&quot;</span><span class="s1">]</span><span class="s0">,</span>
                             <span class="s1">[(np.float32</span><span class="s0">, </span><span class="s1">np.uint32</span><span class="s0">, </span><span class="s2">23</span><span class="s1">)</span><span class="s0">,</span>
                              <span class="s1">(np.float64</span><span class="s0">, </span><span class="s1">np.uint64</span><span class="s0">, </span><span class="s2">52</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test_half_conversion_denormal_round_even(self</span><span class="s0">, </span><span class="s1">float_t</span><span class="s0">, </span><span class="s1">uint_t</span><span class="s0">, </span><span class="s1">bits):</span>
        <span class="s4"># Test specifically that all bits are considered when deciding</span>
        <span class="s4"># whether round to even should occur (i.e. no bits are lost at the</span>
        <span class="s4"># end. Compare also gh-12721. The most bits can get lost for the</span>
        <span class="s4"># smallest denormal:</span>
        <span class="s1">smallest_value = np.uint16(</span><span class="s2">1</span><span class="s1">).view(np.float16).astype(float_t)</span>
        <span class="s0">assert </span><span class="s1">smallest_value == </span><span class="s2">2</span><span class="s1">**-</span><span class="s2">24</span>

        <span class="s4"># Will be rounded to zero based on round to even rule:</span>
        <span class="s1">rounded_to_zero = smallest_value / float_t(</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">rounded_to_zero.astype(np.float16) == </span><span class="s2">0</span>

        <span class="s4"># The significand will be all 0 for the float_t, test that we do not</span>
        <span class="s4"># lose the lower ones of these:</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(bits):</span>
            <span class="s4"># slightly increasing the value should make it round up:</span>
            <span class="s1">larger_pattern = rounded_to_zero.view(uint_t) | uint_t(</span><span class="s2">1 </span><span class="s1">&lt;&lt; i)</span>
            <span class="s1">larger_value = larger_pattern.view(float_t)</span>
            <span class="s0">assert </span><span class="s1">larger_value.astype(np.float16) == smallest_value</span>

    <span class="s0">def </span><span class="s1">test_nans_infs(self):</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s3">'ignore'</span><span class="s1">):</span>
            <span class="s4"># Check some of the ufuncs</span>
            <span class="s1">assert_equal(np.isnan(self.all_f16)</span><span class="s0">, </span><span class="s1">np.isnan(self.all_f32))</span>
            <span class="s1">assert_equal(np.isinf(self.all_f16)</span><span class="s0">, </span><span class="s1">np.isinf(self.all_f32))</span>
            <span class="s1">assert_equal(np.isfinite(self.all_f16)</span><span class="s0">, </span><span class="s1">np.isfinite(self.all_f32))</span>
            <span class="s1">assert_equal(np.signbit(self.all_f16)</span><span class="s0">, </span><span class="s1">np.signbit(self.all_f32))</span>
            <span class="s1">assert_equal(np.spacing(float16(</span><span class="s2">65504</span><span class="s1">))</span><span class="s0">, </span><span class="s1">np.inf)</span>

            <span class="s4"># Check comparisons of all values with NaN</span>
            <span class="s1">nan = float16(np.nan)</span>

            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">(self.all_f16 == nan).any())</span>
            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">(nan == self.all_f16).any())</span>

            <span class="s1">assert_((self.all_f16 != nan).all())</span>
            <span class="s1">assert_((nan != self.all_f16).all())</span>

            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">(self.all_f16 &lt; nan).any())</span>
            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">(nan &lt; self.all_f16).any())</span>

            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">(self.all_f16 &lt;= nan).any())</span>
            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">(nan &lt;= self.all_f16).any())</span>

            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">(self.all_f16 &gt; nan).any())</span>
            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">(nan &gt; self.all_f16).any())</span>

            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">(self.all_f16 &gt;= nan).any())</span>
            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">(nan &gt;= self.all_f16).any())</span>

    <span class="s0">def </span><span class="s1">test_half_values(self):</span>
        <span class="s5">&quot;&quot;&quot;Confirms a small number of known half values&quot;&quot;&quot;</span>
        <span class="s1">a = np.array([</span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.0</span><span class="s0">,</span>
                      <span class="s2">2.0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2.0</span><span class="s0">,</span>
                      <span class="s2">0.0999755859375</span><span class="s0">, </span><span class="s2">0.333251953125</span><span class="s0">,  </span><span class="s4"># 1/10, 1/3</span>
                      <span class="s2">65504</span><span class="s0">, </span><span class="s1">-</span><span class="s2">65504</span><span class="s0">,           </span><span class="s4"># Maximum magnitude</span>
                      <span class="s2">2.0</span><span class="s1">**(-</span><span class="s2">14</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2.0</span><span class="s1">**(-</span><span class="s2">14</span><span class="s1">)</span><span class="s0">,  </span><span class="s4"># Minimum normal</span>
                      <span class="s2">2.0</span><span class="s1">**(-</span><span class="s2">24</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2.0</span><span class="s1">**(-</span><span class="s2">24</span><span class="s1">)</span><span class="s0">,  </span><span class="s4"># Minimum subnormal</span>
                      <span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">/</span><span class="s2">1e1000</span><span class="s0">,            </span><span class="s4"># Signed zeros</span>
                      <span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf])</span>
        <span class="s1">b = np.array([</span><span class="s2">0x3c00</span><span class="s0">, </span><span class="s2">0xbc00</span><span class="s0">,</span>
                      <span class="s2">0x4000</span><span class="s0">, </span><span class="s2">0xc000</span><span class="s0">,</span>
                      <span class="s2">0x2e66</span><span class="s0">, </span><span class="s2">0x3555</span><span class="s0">,</span>
                      <span class="s2">0x7bff</span><span class="s0">, </span><span class="s2">0xfbff</span><span class="s0">,</span>
                      <span class="s2">0x0400</span><span class="s0">, </span><span class="s2">0x8400</span><span class="s0">,</span>
                      <span class="s2">0x0001</span><span class="s0">, </span><span class="s2">0x8001</span><span class="s0">,</span>
                      <span class="s2">0x0000</span><span class="s0">, </span><span class="s2">0x8000</span><span class="s0">,</span>
                      <span class="s2">0x7c00</span><span class="s0">, </span><span class="s2">0xfc00</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=uint16)</span>
        <span class="s1">b.dtype = float16</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s0">def </span><span class="s1">test_half_rounding(self):</span>
        <span class="s5">&quot;&quot;&quot;Checks that rounding when converting to half is correct&quot;&quot;&quot;</span>
        <span class="s1">a = np.array([</span><span class="s2">2.0</span><span class="s1">**-</span><span class="s2">25 </span><span class="s1">+ </span><span class="s2">2.0</span><span class="s1">**-</span><span class="s2">35</span><span class="s0">,  </span><span class="s4"># Rounds to minimum subnormal</span>
                      <span class="s2">2.0</span><span class="s1">**-</span><span class="s2">25</span><span class="s0">,       </span><span class="s4"># Underflows to zero (nearest even mode)</span>
                      <span class="s2">2.0</span><span class="s1">**-</span><span class="s2">26</span><span class="s0">,       </span><span class="s4"># Underflows to zero</span>
                      <span class="s2">1.0</span><span class="s1">+</span><span class="s2">2.0</span><span class="s1">**-</span><span class="s2">11 </span><span class="s1">+ </span><span class="s2">2.0</span><span class="s1">**-</span><span class="s2">16</span><span class="s0">,  </span><span class="s4"># rounds to 1.0+2**(-10)</span>
                      <span class="s2">1.0</span><span class="s1">+</span><span class="s2">2.0</span><span class="s1">**-</span><span class="s2">11</span><span class="s0">,   </span><span class="s4"># rounds to 1.0 (nearest even mode)</span>
                      <span class="s2">1.0</span><span class="s1">+</span><span class="s2">2.0</span><span class="s1">**-</span><span class="s2">12</span><span class="s0">,   </span><span class="s4"># rounds to 1.0</span>
                      <span class="s2">65519</span><span class="s0">,          </span><span class="s4"># rounds to 65504</span>
                      <span class="s2">65520</span><span class="s1">]</span><span class="s0">,         </span><span class="s4"># rounds to inf</span>
                      <span class="s1">dtype=float64)</span>
        <span class="s1">rounded = [</span><span class="s2">2.0</span><span class="s1">**-</span><span class="s2">24</span><span class="s0">,</span>
                   <span class="s2">0.0</span><span class="s0">,</span>
                   <span class="s2">0.0</span><span class="s0">,</span>
                   <span class="s2">1.0</span><span class="s1">+</span><span class="s2">2.0</span><span class="s1">**(-</span><span class="s2">10</span><span class="s1">)</span><span class="s0">,</span>
                   <span class="s2">1.0</span><span class="s0">,</span>
                   <span class="s2">1.0</span><span class="s0">,</span>
                   <span class="s2">65504</span><span class="s0">,</span>
                   <span class="s1">np.inf]</span>

        <span class="s4"># Check float64-&gt;float16 rounding</span>
        <span class="s1">b = np.array(a</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
        <span class="s1">assert_equal(b</span><span class="s0">, </span><span class="s1">rounded)</span>

        <span class="s4"># Check float32-&gt;float16 rounding</span>
        <span class="s1">a = np.array(a</span><span class="s0">, </span><span class="s1">dtype=float32)</span>
        <span class="s1">b = np.array(a</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
        <span class="s1">assert_equal(b</span><span class="s0">, </span><span class="s1">rounded)</span>

    <span class="s0">def </span><span class="s1">test_half_correctness(self):</span>
        <span class="s5">&quot;&quot;&quot;Take every finite float16, and check the casting functions with 
           a manual conversion.&quot;&quot;&quot;</span>

        <span class="s4"># Create an array of all finite float16s</span>
        <span class="s1">a_bits = self.finite_f16.view(dtype=uint16)</span>

        <span class="s4"># Convert to 64-bit float manually</span>
        <span class="s1">a_sgn = (-</span><span class="s2">1.0</span><span class="s1">)**((a_bits &amp; </span><span class="s2">0x8000</span><span class="s1">) &gt;&gt; </span><span class="s2">15</span><span class="s1">)</span>
        <span class="s1">a_exp = np.array((a_bits &amp; </span><span class="s2">0x7c00</span><span class="s1">) &gt;&gt; </span><span class="s2">10</span><span class="s0">, </span><span class="s1">dtype=np.int32) - </span><span class="s2">15</span>
        <span class="s1">a_man = (a_bits &amp; </span><span class="s2">0x03ff</span><span class="s1">) * </span><span class="s2">2.0</span><span class="s1">**(-</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s4"># Implicit bit of normalized floats</span>
        <span class="s1">a_man[a_exp != -</span><span class="s2">15</span><span class="s1">] += </span><span class="s2">1</span>
        <span class="s4"># Denormalized exponent is -14</span>
        <span class="s1">a_exp[a_exp == -</span><span class="s2">15</span><span class="s1">] = -</span><span class="s2">14</span>

        <span class="s1">a_manual = a_sgn * a_man * </span><span class="s2">2.0</span><span class="s1">**a_exp</span>

        <span class="s1">a32_fail = np.nonzero(self.finite_f32 != a_manual)[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">len(a32_fail) != </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">bad_index = a32_fail[</span><span class="s2">0</span><span class="s1">]</span>
            <span class="s1">assert_equal(self.finite_f32</span><span class="s0">, </span><span class="s1">a_manual</span><span class="s0">,</span>
                 <span class="s3">&quot;First non-equal is half value %x -&gt; %g != %g&quot; </span><span class="s1">%</span>
                            <span class="s1">(self.finite_f16[bad_index]</span><span class="s0">,</span>
                             <span class="s1">self.finite_f32[bad_index]</span><span class="s0">,</span>
                             <span class="s1">a_manual[bad_index]))</span>

        <span class="s1">a64_fail = np.nonzero(self.finite_f64 != a_manual)[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">len(a64_fail) != </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">bad_index = a64_fail[</span><span class="s2">0</span><span class="s1">]</span>
            <span class="s1">assert_equal(self.finite_f64</span><span class="s0">, </span><span class="s1">a_manual</span><span class="s0">,</span>
                 <span class="s3">&quot;First non-equal is half value %x -&gt; %g != %g&quot; </span><span class="s1">%</span>
                            <span class="s1">(self.finite_f16[bad_index]</span><span class="s0">,</span>
                             <span class="s1">self.finite_f64[bad_index]</span><span class="s0">,</span>
                             <span class="s1">a_manual[bad_index]))</span>

    <span class="s0">def </span><span class="s1">test_half_ordering(self):</span>
        <span class="s5">&quot;&quot;&quot;Make sure comparisons are working right&quot;&quot;&quot;</span>

        <span class="s4"># All non-NaN float16 values in reverse order</span>
        <span class="s1">a = self.nonan_f16[::-</span><span class="s2">1</span><span class="s1">].copy()</span>

        <span class="s4"># 32-bit float copy</span>
        <span class="s1">b = np.array(a</span><span class="s0">, </span><span class="s1">dtype=float32)</span>

        <span class="s4"># Should sort the same</span>
        <span class="s1">a.sort()</span>
        <span class="s1">b.sort()</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">b)</span>

        <span class="s4"># Comparisons should work</span>
        <span class="s1">assert_((a[:-</span><span class="s2">1</span><span class="s1">] &lt;= a[</span><span class="s2">1</span><span class="s1">:]).all())</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">(a[:-</span><span class="s2">1</span><span class="s1">] &gt; a[</span><span class="s2">1</span><span class="s1">:]).any())</span>
        <span class="s1">assert_((a[</span><span class="s2">1</span><span class="s1">:] &gt;= a[:-</span><span class="s2">1</span><span class="s1">]).all())</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">(a[</span><span class="s2">1</span><span class="s1">:] &lt; a[:-</span><span class="s2">1</span><span class="s1">]).any())</span>
        <span class="s4"># All != except for +/-0</span>
        <span class="s1">assert_equal(np.nonzero(a[:-</span><span class="s2">1</span><span class="s1">] &lt; a[</span><span class="s2">1</span><span class="s1">:])[</span><span class="s2">0</span><span class="s1">].size</span><span class="s0">, </span><span class="s1">a.size-</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.nonzero(a[</span><span class="s2">1</span><span class="s1">:] &gt; a[:-</span><span class="s2">1</span><span class="s1">])[</span><span class="s2">0</span><span class="s1">].size</span><span class="s0">, </span><span class="s1">a.size-</span><span class="s2">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_half_funcs(self):</span>
        <span class="s5">&quot;&quot;&quot;Test the various ArrFuncs&quot;&quot;&quot;</span>

        <span class="s4"># fill</span>
        <span class="s1">assert_equal(np.arange(</span><span class="s2">10</span><span class="s0">, </span><span class="s1">dtype=float16)</span><span class="s0">,</span>
                     <span class="s1">np.arange(</span><span class="s2">10</span><span class="s0">, </span><span class="s1">dtype=float32))</span>

        <span class="s4"># fillwithscalar</span>
        <span class="s1">a = np.zeros((</span><span class="s2">5</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
        <span class="s1">a.fill(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">np.ones((</span><span class="s2">5</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=float16))</span>

        <span class="s4"># nonzero and copyswap</span>
        <span class="s1">a = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">/</span><span class="s2">1e20</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">**-</span><span class="s2">24</span><span class="s0">, </span><span class="s2">7.629e-6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
        <span class="s1">assert_equal(a.nonzero()[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                     <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">])</span>
        <span class="s1">a = a.byteswap().newbyteorder()</span>
        <span class="s1">assert_equal(a.nonzero()[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                     <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">])</span>

        <span class="s4"># dot</span>
        <span class="s1">a = np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
        <span class="s1">b = np.ones((</span><span class="s2">20</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
        <span class="s1">assert_equal(np.dot(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">,</span>
                     <span class="s2">95</span><span class="s1">)</span>

        <span class="s4"># argmax</span>
        <span class="s1">a = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">12.55</span><span class="s0">, </span><span class="s2">7.3</span><span class="s0">, </span><span class="s2">2.1</span><span class="s0">, </span><span class="s2">12.4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
        <span class="s1">assert_equal(a.argmax()</span><span class="s0">,</span>
                     <span class="s2">4</span><span class="s1">)</span>
        <span class="s1">a = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s2">12.55</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">2.1</span><span class="s0">, </span><span class="s2">12.4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
        <span class="s1">assert_equal(a.argmax()</span><span class="s0">,</span>
                     <span class="s2">5</span><span class="s1">)</span>

        <span class="s4"># getitem</span>
        <span class="s1">a = np.arange(</span><span class="s2">10</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">10</span><span class="s1">):</span>
            <span class="s1">assert_equal(a.item(i)</span><span class="s0">, </span><span class="s1">i)</span>

    <span class="s0">def </span><span class="s1">test_spacing_nextafter(self):</span>
        <span class="s5">&quot;&quot;&quot;Test np.spacing and np.nextafter&quot;&quot;&quot;</span>
        <span class="s4"># All non-negative finite #'s</span>
        <span class="s1">a = np.arange(</span><span class="s2">0x7c00</span><span class="s0">, </span><span class="s1">dtype=uint16)</span>
        <span class="s1">hinf = np.array((np.inf</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
        <span class="s1">hnan = np.array((np.nan</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
        <span class="s1">a_f16 = a.view(dtype=float16)</span>

        <span class="s1">assert_equal(np.spacing(a_f16[:-</span><span class="s2">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">a_f16[</span><span class="s2">1</span><span class="s1">:]-a_f16[:-</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">assert_equal(np.nextafter(a_f16[:-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">hinf)</span><span class="s0">, </span><span class="s1">a_f16[</span><span class="s2">1</span><span class="s1">:])</span>
        <span class="s1">assert_equal(np.nextafter(a_f16[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-hinf)</span><span class="s0">, </span><span class="s1">-a_f16[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.nextafter(a_f16[</span><span class="s2">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">-hinf)</span><span class="s0">, </span><span class="s1">a_f16[:-</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">assert_equal(np.nextafter(hinf</span><span class="s0">, </span><span class="s1">a_f16)</span><span class="s0">, </span><span class="s1">a_f16[-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.nextafter(-hinf</span><span class="s0">, </span><span class="s1">a_f16)</span><span class="s0">, </span><span class="s1">-a_f16[-</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">assert_equal(np.nextafter(hinf</span><span class="s0">, </span><span class="s1">hinf)</span><span class="s0">, </span><span class="s1">hinf)</span>
        <span class="s1">assert_equal(np.nextafter(hinf</span><span class="s0">, </span><span class="s1">-hinf)</span><span class="s0">, </span><span class="s1">a_f16[-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.nextafter(-hinf</span><span class="s0">, </span><span class="s1">hinf)</span><span class="s0">, </span><span class="s1">-a_f16[-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.nextafter(-hinf</span><span class="s0">, </span><span class="s1">-hinf)</span><span class="s0">, </span><span class="s1">-hinf)</span>

        <span class="s1">assert_equal(np.nextafter(a_f16</span><span class="s0">, </span><span class="s1">hnan)</span><span class="s0">, </span><span class="s1">hnan[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.nextafter(hnan</span><span class="s0">, </span><span class="s1">a_f16)</span><span class="s0">, </span><span class="s1">hnan[</span><span class="s2">0</span><span class="s1">])</span>

        <span class="s1">assert_equal(np.nextafter(hnan</span><span class="s0">, </span><span class="s1">hnan)</span><span class="s0">, </span><span class="s1">hnan)</span>
        <span class="s1">assert_equal(np.nextafter(hinf</span><span class="s0">, </span><span class="s1">hnan)</span><span class="s0">, </span><span class="s1">hnan)</span>
        <span class="s1">assert_equal(np.nextafter(hnan</span><span class="s0">, </span><span class="s1">hinf)</span><span class="s0">, </span><span class="s1">hnan)</span>

        <span class="s4"># switch to negatives</span>
        <span class="s1">a |= </span><span class="s2">0x8000</span>

        <span class="s1">assert_equal(np.spacing(a_f16[</span><span class="s2">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.spacing(a_f16[</span><span class="s2">1</span><span class="s1">]))</span>
        <span class="s1">assert_equal(np.spacing(a_f16[</span><span class="s2">1</span><span class="s1">:])</span><span class="s0">, </span><span class="s1">a_f16[:-</span><span class="s2">1</span><span class="s1">]-a_f16[</span><span class="s2">1</span><span class="s1">:])</span>

        <span class="s1">assert_equal(np.nextafter(a_f16[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">hinf)</span><span class="s0">, </span><span class="s1">-a_f16[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.nextafter(a_f16[</span><span class="s2">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">hinf)</span><span class="s0">, </span><span class="s1">a_f16[:-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.nextafter(a_f16[:-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-hinf)</span><span class="s0">, </span><span class="s1">a_f16[</span><span class="s2">1</span><span class="s1">:])</span>

        <span class="s1">assert_equal(np.nextafter(hinf</span><span class="s0">, </span><span class="s1">a_f16)</span><span class="s0">, </span><span class="s1">-a_f16[-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.nextafter(-hinf</span><span class="s0">, </span><span class="s1">a_f16)</span><span class="s0">, </span><span class="s1">a_f16[-</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">assert_equal(np.nextafter(a_f16</span><span class="s0">, </span><span class="s1">hnan)</span><span class="s0">, </span><span class="s1">hnan[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.nextafter(hnan</span><span class="s0">, </span><span class="s1">a_f16)</span><span class="s0">, </span><span class="s1">hnan[</span><span class="s2">0</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_half_ufuncs(self):</span>
        <span class="s5">&quot;&quot;&quot;Test the various ufuncs&quot;&quot;&quot;</span>

        <span class="s1">a = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
        <span class="s1">b = np.array([-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
        <span class="s1">c = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=float16)</span>

        <span class="s1">assert_equal(np.add(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">5</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.subtract(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.multiply(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">16</span><span class="s0">, </span><span class="s2">6</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.divide(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.199951171875</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0.66650390625</span><span class="s1">])</span>

        <span class="s1">assert_equal(np.equal(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, False, False, True, False</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.not_equal(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, True, True, False, True</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.less(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True, False, False, True</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.less_equal(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True, False, True, True</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.greater(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False, True, False, False</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.greater_equal(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False, True, True, False</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.logical_and(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True, True, True, True</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.logical_or(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, True, True, True, True</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.logical_xor(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False, False, False, False</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.logical_not(a)</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False, False, False, False</span><span class="s1">])</span>

        <span class="s1">assert_equal(np.isnan(c)</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, False, False, True, False</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.isinf(c)</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, False, True, False, False</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.isfinite(c)</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, True, False, False, True</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.signbit(b)</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False, False, False, False</span><span class="s1">])</span>

        <span class="s1">assert_equal(np.copysign(b</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>

        <span class="s1">assert_equal(np.maximum(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>

        <span class="s1">x = np.maximum(b</span><span class="s0">, </span><span class="s1">c)</span>
        <span class="s1">assert_(np.isnan(x[</span><span class="s2">3</span><span class="s1">]))</span>
        <span class="s1">x[</span><span class="s2">3</span><span class="s1">] = </span><span class="s2">0</span>
        <span class="s1">assert_equal(x</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">6</span><span class="s1">])</span>

        <span class="s1">assert_equal(np.minimum(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>

        <span class="s1">x = np.minimum(b</span><span class="s0">, </span><span class="s1">c)</span>
        <span class="s1">assert_(np.isnan(x[</span><span class="s2">3</span><span class="s1">]))</span>
        <span class="s1">x[</span><span class="s2">3</span><span class="s1">] = </span><span class="s2">0</span>
        <span class="s1">assert_equal(x</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>

        <span class="s1">assert_equal(np.fmax(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.fmax(b</span><span class="s0">, </span><span class="s1">c)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.fmin(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.fmin(b</span><span class="s0">, </span><span class="s1">c)</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>

        <span class="s1">assert_equal(np.floor_divide(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.remainder(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.divmod(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]))</span>
        <span class="s1">assert_equal(np.square(b)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">25</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">16</span><span class="s0">, </span><span class="s2">9</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.reciprocal(b)</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.199951171875</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">0.333251953125</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.ones_like(b)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.conjugate(b)</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(np.absolute(b)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.negative(b)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.positive(b)</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(np.sign(b)</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.modf(b)</span><span class="s0">, </span><span class="s1">([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">b))</span>
        <span class="s1">assert_equal(np.frexp(b)</span><span class="s0">, </span><span class="s1">([-</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.625</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.75</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]))</span>
        <span class="s1">assert_equal(np.ldexp(b</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">64</span><span class="s0">, </span><span class="s2">12</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_half_coercion(self):</span>
        <span class="s5">&quot;&quot;&quot;Test that half gets coerced properly with the other types&quot;&quot;&quot;</span>
        <span class="s1">a16 = np.array((</span><span class="s2">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
        <span class="s1">a32 = np.array((</span><span class="s2">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=float32)</span>
        <span class="s1">b16 = float16(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">b32 = float32(</span><span class="s2">1</span><span class="s1">)</span>

        <span class="s1">assert_equal(np.power(a16</span><span class="s0">, </span><span class="s2">2</span><span class="s1">).dtype</span><span class="s0">, </span><span class="s1">float16)</span>
        <span class="s1">assert_equal(np.power(a16</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">).dtype</span><span class="s0">, </span><span class="s1">float16)</span>
        <span class="s1">assert_equal(np.power(a16</span><span class="s0">, </span><span class="s1">b16).dtype</span><span class="s0">, </span><span class="s1">float16)</span>
        <span class="s1">assert_equal(np.power(a16</span><span class="s0">, </span><span class="s1">b32).dtype</span><span class="s0">, </span><span class="s1">float16)</span>
        <span class="s1">assert_equal(np.power(a16</span><span class="s0">, </span><span class="s1">a16).dtype</span><span class="s0">, </span><span class="s1">float16)</span>
        <span class="s1">assert_equal(np.power(a16</span><span class="s0">, </span><span class="s1">a32).dtype</span><span class="s0">, </span><span class="s1">float32)</span>

        <span class="s1">assert_equal(np.power(b16</span><span class="s0">, </span><span class="s2">2</span><span class="s1">).dtype</span><span class="s0">, </span><span class="s1">float64)</span>
        <span class="s1">assert_equal(np.power(b16</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">).dtype</span><span class="s0">, </span><span class="s1">float64)</span>
        <span class="s1">assert_equal(np.power(b16</span><span class="s0">, </span><span class="s1">b16).dtype</span><span class="s0">, </span><span class="s1">float16)</span>
        <span class="s1">assert_equal(np.power(b16</span><span class="s0">, </span><span class="s1">b32).dtype</span><span class="s0">, </span><span class="s1">float32)</span>
        <span class="s1">assert_equal(np.power(b16</span><span class="s0">, </span><span class="s1">a16).dtype</span><span class="s0">, </span><span class="s1">float16)</span>
        <span class="s1">assert_equal(np.power(b16</span><span class="s0">, </span><span class="s1">a32).dtype</span><span class="s0">, </span><span class="s1">float32)</span>

        <span class="s1">assert_equal(np.power(a32</span><span class="s0">, </span><span class="s1">a16).dtype</span><span class="s0">, </span><span class="s1">float32)</span>
        <span class="s1">assert_equal(np.power(a32</span><span class="s0">, </span><span class="s1">b16).dtype</span><span class="s0">, </span><span class="s1">float32)</span>
        <span class="s1">assert_equal(np.power(b32</span><span class="s0">, </span><span class="s1">a16).dtype</span><span class="s0">, </span><span class="s1">float16)</span>
        <span class="s1">assert_equal(np.power(b32</span><span class="s0">, </span><span class="s1">b16).dtype</span><span class="s0">, </span><span class="s1">float32)</span>

    <span class="s1">@pytest.mark.skipif(platform.machine() == </span><span class="s3">&quot;armv5tel&quot;</span><span class="s0">,</span>
                        <span class="s1">reason=</span><span class="s3">&quot;See gh-413.&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_half_fpe(self):</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s3">'raise'</span><span class="s1">):</span>
            <span class="s1">sx16 = np.array((</span><span class="s2">1e-4</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
            <span class="s1">bx16 = np.array((</span><span class="s2">1e4</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
            <span class="s1">sy16 = float16(</span><span class="s2">1e-4</span><span class="s1">)</span>
            <span class="s1">by16 = float16(</span><span class="s2">1e4</span><span class="s1">)</span>

            <span class="s4"># Underflow errors</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'underflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a*b</span><span class="s0">, </span><span class="s1">sx16</span><span class="s0">, </span><span class="s1">sx16)</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'underflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a*b</span><span class="s0">, </span><span class="s1">sx16</span><span class="s0">, </span><span class="s1">sy16)</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'underflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a*b</span><span class="s0">, </span><span class="s1">sy16</span><span class="s0">, </span><span class="s1">sx16)</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'underflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a*b</span><span class="s0">, </span><span class="s1">sy16</span><span class="s0">, </span><span class="s1">sy16)</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'underflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a/b</span><span class="s0">, </span><span class="s1">sx16</span><span class="s0">, </span><span class="s1">bx16)</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'underflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a/b</span><span class="s0">, </span><span class="s1">sx16</span><span class="s0">, </span><span class="s1">by16)</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'underflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a/b</span><span class="s0">, </span><span class="s1">sy16</span><span class="s0">, </span><span class="s1">bx16)</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'underflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a/b</span><span class="s0">, </span><span class="s1">sy16</span><span class="s0">, </span><span class="s1">by16)</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'underflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a/b</span><span class="s0">,</span>
                                             <span class="s1">float16(</span><span class="s2">2.</span><span class="s1">**-</span><span class="s2">14</span><span class="s1">)</span><span class="s0">, </span><span class="s1">float16(</span><span class="s2">2</span><span class="s1">**</span><span class="s2">11</span><span class="s1">))</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'underflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a/b</span><span class="s0">,</span>
                                             <span class="s1">float16(-</span><span class="s2">2.</span><span class="s1">**-</span><span class="s2">14</span><span class="s1">)</span><span class="s0">, </span><span class="s1">float16(</span><span class="s2">2</span><span class="s1">**</span><span class="s2">11</span><span class="s1">))</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'underflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a/b</span><span class="s0">,</span>
                                             <span class="s1">float16(</span><span class="s2">2.</span><span class="s1">**-</span><span class="s2">14</span><span class="s1">+</span><span class="s2">2</span><span class="s1">**-</span><span class="s2">24</span><span class="s1">)</span><span class="s0">, </span><span class="s1">float16(</span><span class="s2">2</span><span class="s1">))</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'underflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a/b</span><span class="s0">,</span>
                                             <span class="s1">float16(-</span><span class="s2">2.</span><span class="s1">**-</span><span class="s2">14</span><span class="s1">-</span><span class="s2">2</span><span class="s1">**-</span><span class="s2">24</span><span class="s1">)</span><span class="s0">, </span><span class="s1">float16(</span><span class="s2">2</span><span class="s1">))</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'underflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a/b</span><span class="s0">,</span>
                                             <span class="s1">float16(</span><span class="s2">2.</span><span class="s1">**-</span><span class="s2">14</span><span class="s1">+</span><span class="s2">2</span><span class="s1">**-</span><span class="s2">23</span><span class="s1">)</span><span class="s0">, </span><span class="s1">float16(</span><span class="s2">4</span><span class="s1">))</span>

            <span class="s4"># Overflow errors</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'overflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a*b</span><span class="s0">, </span><span class="s1">bx16</span><span class="s0">, </span><span class="s1">bx16)</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'overflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a*b</span><span class="s0">, </span><span class="s1">bx16</span><span class="s0">, </span><span class="s1">by16)</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'overflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a*b</span><span class="s0">, </span><span class="s1">by16</span><span class="s0">, </span><span class="s1">bx16)</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'overflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a*b</span><span class="s0">, </span><span class="s1">by16</span><span class="s0">, </span><span class="s1">by16)</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'overflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a/b</span><span class="s0">, </span><span class="s1">bx16</span><span class="s0">, </span><span class="s1">sx16)</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'overflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a/b</span><span class="s0">, </span><span class="s1">bx16</span><span class="s0">, </span><span class="s1">sy16)</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'overflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a/b</span><span class="s0">, </span><span class="s1">by16</span><span class="s0">, </span><span class="s1">sx16)</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'overflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a/b</span><span class="s0">, </span><span class="s1">by16</span><span class="s0">, </span><span class="s1">sy16)</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'overflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a+b</span><span class="s0">,</span>
                                             <span class="s1">float16(</span><span class="s2">65504</span><span class="s1">)</span><span class="s0">, </span><span class="s1">float16(</span><span class="s2">17</span><span class="s1">))</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'overflow'</span><span class="s0">, lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:a-b</span><span class="s0">,</span>
                                             <span class="s1">float16(-</span><span class="s2">65504</span><span class="s1">)</span><span class="s0">, </span><span class="s1">float16(</span><span class="s2">17</span><span class="s1">))</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'overflow'</span><span class="s0">, </span><span class="s1">np.nextafter</span><span class="s0">, </span><span class="s1">float16(</span><span class="s2">65504</span><span class="s1">)</span><span class="s0">, </span><span class="s1">float16(np.inf))</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'overflow'</span><span class="s0">, </span><span class="s1">np.nextafter</span><span class="s0">, </span><span class="s1">float16(-</span><span class="s2">65504</span><span class="s1">)</span><span class="s0">, </span><span class="s1">float16(-np.inf))</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'overflow'</span><span class="s0">, </span><span class="s1">np.spacing</span><span class="s0">, </span><span class="s1">float16(</span><span class="s2">65504</span><span class="s1">))</span>

            <span class="s4"># Invalid value errors</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'invalid'</span><span class="s0">, </span><span class="s1">np.divide</span><span class="s0">, </span><span class="s1">float16(np.inf)</span><span class="s0">, </span><span class="s1">float16(np.inf))</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'invalid'</span><span class="s0">, </span><span class="s1">np.spacing</span><span class="s0">, </span><span class="s1">float16(np.inf))</span>
            <span class="s1">assert_raises_fpe(</span><span class="s3">'invalid'</span><span class="s0">, </span><span class="s1">np.spacing</span><span class="s0">, </span><span class="s1">float16(np.nan))</span>

            <span class="s4"># These should not raise</span>
            <span class="s1">float16(</span><span class="s2">65472</span><span class="s1">)+float16(</span><span class="s2">32</span><span class="s1">)</span>
            <span class="s1">float16(</span><span class="s2">2</span><span class="s1">**-</span><span class="s2">13</span><span class="s1">)/float16(</span><span class="s2">2</span><span class="s1">)</span>
            <span class="s1">float16(</span><span class="s2">2</span><span class="s1">**-</span><span class="s2">14</span><span class="s1">)/float16(</span><span class="s2">2</span><span class="s1">**</span><span class="s2">10</span><span class="s1">)</span>
            <span class="s1">np.spacing(float16(-</span><span class="s2">65504</span><span class="s1">))</span>
            <span class="s1">np.nextafter(float16(</span><span class="s2">65504</span><span class="s1">)</span><span class="s0">, </span><span class="s1">float16(-np.inf))</span>
            <span class="s1">np.nextafter(float16(-</span><span class="s2">65504</span><span class="s1">)</span><span class="s0">, </span><span class="s1">float16(np.inf))</span>
            <span class="s1">np.nextafter(float16(np.inf)</span><span class="s0">, </span><span class="s1">float16(</span><span class="s2">0</span><span class="s1">))</span>
            <span class="s1">np.nextafter(float16(-np.inf)</span><span class="s0">, </span><span class="s1">float16(</span><span class="s2">0</span><span class="s1">))</span>
            <span class="s1">np.nextafter(float16(</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">float16(np.nan))</span>
            <span class="s1">np.nextafter(float16(np.nan)</span><span class="s0">, </span><span class="s1">float16(</span><span class="s2">0</span><span class="s1">))</span>
            <span class="s1">float16(</span><span class="s2">2</span><span class="s1">**-</span><span class="s2">14</span><span class="s1">)/float16(</span><span class="s2">2</span><span class="s1">**</span><span class="s2">10</span><span class="s1">)</span>
            <span class="s1">float16(-</span><span class="s2">2</span><span class="s1">**-</span><span class="s2">14</span><span class="s1">)/float16(</span><span class="s2">2</span><span class="s1">**</span><span class="s2">10</span><span class="s1">)</span>
            <span class="s1">float16(</span><span class="s2">2</span><span class="s1">**-</span><span class="s2">14</span><span class="s1">+</span><span class="s2">2</span><span class="s1">**-</span><span class="s2">23</span><span class="s1">)/float16(</span><span class="s2">2</span><span class="s1">)</span>
            <span class="s1">float16(-</span><span class="s2">2</span><span class="s1">**-</span><span class="s2">14</span><span class="s1">-</span><span class="s2">2</span><span class="s1">**-</span><span class="s2">23</span><span class="s1">)/float16(</span><span class="s2">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_half_array_interface(self):</span>
        <span class="s5">&quot;&quot;&quot;Test that half is compatible with __array_interface__&quot;&quot;&quot;</span>
        <span class="s0">class </span><span class="s1">Dummy:</span>
            <span class="s0">pass</span>

        <span class="s1">a = np.ones((</span><span class="s2">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=float16)</span>
        <span class="s1">b = Dummy()</span>
        <span class="s1">b.__array_interface__ = a.__array_interface__</span>
        <span class="s1">c = np.array(b)</span>
        <span class="s1">assert_(c.dtype == float16)</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">c)</span>
</pre>
</body>
</html>