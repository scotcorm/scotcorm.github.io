<html>
<head>
<title>rolling.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
rolling.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Provide a generic structure to support window functions, 
similar to how we have a Groupby object. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">timedelta</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">from </span><span class="s1">textwrap </span><span class="s2">import </span><span class="s1">dedent</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">Hashable</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">pandas._libs.tslibs </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">BaseOffset</span><span class="s2">,</span>
    <span class="s1">to_offset</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas._libs.window.aggregations </span><span class="s2">as </span><span class="s1">window_aggregations</span>
<span class="s2">from </span><span class="s1">pandas._typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ArrayLike</span><span class="s2">,</span>
    <span class="s1">Axis</span><span class="s2">,</span>
    <span class="s1">NDFrameT</span><span class="s2">,</span>
    <span class="s1">WindowingRankType</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.compat._optional </span><span class="s2">import </span><span class="s1">import_optional_dependency</span>
<span class="s2">from </span><span class="s1">pandas.compat.numpy </span><span class="s2">import </span><span class="s1">function </span><span class="s2">as </span><span class="s1">nv</span>
<span class="s2">from </span><span class="s1">pandas.util._decorators </span><span class="s2">import </span><span class="s1">doc</span>
<span class="s2">from </span><span class="s1">pandas.util._exceptions </span><span class="s2">import </span><span class="s1">find_stack_level</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ensure_float64</span><span class="s2">,</span>
    <span class="s1">is_bool</span><span class="s2">,</span>
    <span class="s1">is_integer</span><span class="s2">,</span>
    <span class="s1">is_list_like</span><span class="s2">,</span>
    <span class="s1">is_scalar</span><span class="s2">,</span>
    <span class="s1">needs_i8_conversion</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.generic </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ABCDataFrame</span><span class="s2">,</span>
    <span class="s1">ABCSeries</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s2">import </span><span class="s1">notna</span>

<span class="s2">from </span><span class="s1">pandas.core._numba </span><span class="s2">import </span><span class="s1">executor</span>
<span class="s2">from </span><span class="s1">pandas.core.algorithms </span><span class="s2">import </span><span class="s1">factorize</span>
<span class="s2">from </span><span class="s1">pandas.core.apply </span><span class="s2">import </span><span class="s1">ResamplerWindowApply</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">ExtensionArray</span>
<span class="s2">from </span><span class="s1">pandas.core.base </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DataError</span><span class="s2">,</span>
    <span class="s1">SelectionMixin</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas.core.common </span><span class="s2">as </span><span class="s1">com</span>
<span class="s2">from </span><span class="s1">pandas.core.indexers.objects </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">BaseIndexer</span><span class="s2">,</span>
    <span class="s1">FixedWindowIndexer</span><span class="s2">,</span>
    <span class="s1">GroupbyIndexer</span><span class="s2">,</span>
    <span class="s1">VariableWindowIndexer</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.indexes.api </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DatetimeIndex</span><span class="s2">,</span>
    <span class="s1">Index</span><span class="s2">,</span>
    <span class="s1">MultiIndex</span><span class="s2">,</span>
    <span class="s1">PeriodIndex</span><span class="s2">,</span>
    <span class="s1">TimedeltaIndex</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.reshape.concat </span><span class="s2">import </span><span class="s1">concat</span>
<span class="s2">from </span><span class="s1">pandas.core.util.numba_ </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">NUMBA_FUNC_CACHE</span><span class="s2">,</span>
    <span class="s1">maybe_use_numba</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.window.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">flex_binary_moment</span><span class="s2">,</span>
    <span class="s1">zsqrt</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.window.doc </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_shared_docs</span><span class="s2">,</span>
    <span class="s1">args_compat</span><span class="s2">,</span>
    <span class="s1">create_section_header</span><span class="s2">,</span>
    <span class="s1">kwargs_compat</span><span class="s2">,</span>
    <span class="s1">kwargs_scipy</span><span class="s2">,</span>
    <span class="s1">numba_notes</span><span class="s2">,</span>
    <span class="s1">template_header</span><span class="s2">,</span>
    <span class="s1">template_returns</span><span class="s2">,</span>
    <span class="s1">template_see_also</span><span class="s2">,</span>
    <span class="s1">window_agg_numba_parameters</span><span class="s2">,</span>
    <span class="s1">window_apply_parameters</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.window.numba_ </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">generate_manual_numpy_nan_agg_with_axis</span><span class="s2">,</span>
    <span class="s1">generate_numba_apply_func</span><span class="s2">,</span>
    <span class="s1">generate_numba_table_func</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">(</span>
        <span class="s1">DataFrame</span><span class="s2">,</span>
        <span class="s1">Series</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">from </span><span class="s1">pandas.core.generic </span><span class="s2">import </span><span class="s1">NDFrame</span>
    <span class="s2">from </span><span class="s1">pandas.core.groupby.ops </span><span class="s2">import </span><span class="s1">BaseGrouper</span>
    <span class="s2">from </span><span class="s1">pandas.core.internals </span><span class="s2">import </span><span class="s1">Block  </span><span class="s3"># noqa:F401</span>


<span class="s2">class </span><span class="s1">BaseWindow(SelectionMixin):</span>
    <span class="s0">&quot;&quot;&quot;Provides utilities for performing windowing operations.&quot;&quot;&quot;</span>

    <span class="s1">_attributes: list[str] = []</span>
    <span class="s1">exclusions: frozenset[Hashable] = frozenset()</span>
    <span class="s1">_on: Index</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">obj: NDFrame</span><span class="s2">,</span>
        <span class="s1">window=</span><span class="s2">None,</span>
        <span class="s1">min_periods: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">center: bool = </span><span class="s2">False,</span>
        <span class="s1">win_type: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">axis: Axis = </span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">on: str | Index | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">closed: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">method: str = </span><span class="s5">&quot;single&quot;</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">selection=</span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">self.obj = obj</span>
        <span class="s1">self.on = on</span>
        <span class="s1">self.closed = closed</span>
        <span class="s1">self.window = window</span>
        <span class="s1">self.min_periods = min_periods</span>
        <span class="s1">self.center = center</span>
        <span class="s3"># TODO(2.0): Change this back to self.win_type once deprecation is enforced</span>
        <span class="s1">self._win_type = win_type</span>
        <span class="s1">self.axis = obj._get_axis_number(axis) </span><span class="s2">if </span><span class="s1">axis </span><span class="s2">is not None else None</span>
        <span class="s1">self.method = method</span>
        <span class="s1">self._win_freq_i8 = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">self.on </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.axis == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">self._on = self.obj.index</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s3"># i.e. self.axis == 1</span>
                <span class="s1">self._on = self.obj.columns</span>
        <span class="s2">elif </span><span class="s1">isinstance(self.on</span><span class="s2">, </span><span class="s1">Index):</span>
            <span class="s1">self._on = self.on</span>
        <span class="s2">elif </span><span class="s1">isinstance(self.obj</span><span class="s2">, </span><span class="s1">ABCDataFrame) </span><span class="s2">and </span><span class="s1">self.on </span><span class="s2">in </span><span class="s1">self.obj.columns:</span>
            <span class="s1">self._on = Index(self.obj[self.on])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s5">f&quot;invalid on specified as </span><span class="s2">{</span><span class="s1">self.on</span><span class="s2">}</span><span class="s5">, &quot;</span>
                <span class="s5">&quot;must be a column (of DataFrame), an Index or None&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self._selection = selection</span>
        <span class="s1">self._validate()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">win_type(self):</span>
        <span class="s2">if </span><span class="s1">self._win_freq_i8 </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s5">&quot;win_type will no longer return 'freq' in a future version. &quot;</span>
                <span class="s5">&quot;Check the type of self.window instead.&quot;</span><span class="s2">,</span>
                <span class="s1">FutureWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s2">return </span><span class="s5">&quot;freq&quot;</span>
        <span class="s2">return </span><span class="s1">self._win_type</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_datetimelike(self) -&gt; bool:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s5">&quot;is_datetimelike is deprecated and will be removed in a future version.&quot;</span><span class="s2">,</span>
            <span class="s1">FutureWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._win_freq_i8 </span><span class="s2">is not None</span>

    <span class="s2">def </span><span class="s1">validate(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s5">&quot;validate is deprecated and will be removed in a future version.&quot;</span><span class="s2">,</span>
            <span class="s1">FutureWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._validate()</span>

    <span class="s2">def </span><span class="s1">_validate(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self.center </span><span class="s2">is not None and not </span><span class="s1">is_bool(self.center):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;center must be a boolean&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.min_periods </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">is_integer(self.min_periods):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;min_periods must be an integer&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">self.min_periods &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;min_periods must be &gt;= 0&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">is_integer(self.window) </span><span class="s2">and </span><span class="s1">self.min_periods &gt; self.window:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s5">f&quot;min_periods </span><span class="s2">{</span><span class="s1">self.min_periods</span><span class="s2">} </span><span class="s5">must be &lt;= window </span><span class="s2">{</span><span class="s1">self.window</span><span class="s2">}</span><span class="s5">&quot;</span>
                <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.closed </span><span class="s2">is not None and </span><span class="s1">self.closed </span><span class="s2">not in </span><span class="s1">[</span>
            <span class="s5">&quot;right&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;both&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;left&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;neither&quot;</span><span class="s2">,</span>
        <span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;closed must be 'right', 'left', 'both' or 'neither'&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">isinstance(self.obj</span><span class="s2">, </span><span class="s1">(ABCSeries</span><span class="s2">, </span><span class="s1">ABCDataFrame)):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">f&quot;invalid type: </span><span class="s2">{</span><span class="s1">type(self)</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">isinstance(self.window</span><span class="s2">, </span><span class="s1">BaseIndexer):</span>
            <span class="s3"># Validate that the passed BaseIndexer subclass has</span>
            <span class="s3"># a get_window_bounds with the correct signature.</span>
            <span class="s1">get_window_bounds_signature = inspect.signature(</span>
                <span class="s1">self.window.get_window_bounds</span>
            <span class="s1">).parameters.keys()</span>
            <span class="s1">expected_signature = inspect.signature(</span>
                <span class="s1">BaseIndexer().get_window_bounds</span>
            <span class="s1">).parameters.keys()</span>
            <span class="s2">if </span><span class="s1">get_window_bounds_signature != expected_signature:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">type(self.window).__name__</span><span class="s2">} </span><span class="s5">does not implement &quot;</span>
                    <span class="s5">f&quot;the correct signature for get_window_bounds&quot;</span>
                <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.method </span><span class="s2">not in </span><span class="s1">[</span><span class="s5">&quot;table&quot;</span><span class="s2">, </span><span class="s5">&quot;single&quot;</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;method must be 'table' or 'single&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_check_window_bounds(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">start: np.ndarray</span><span class="s2">, </span><span class="s1">end: np.ndarray</span><span class="s2">, </span><span class="s1">num_vals: int</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">len(start) != len(end):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s5">f&quot;start (</span><span class="s2">{</span><span class="s1">len(start)</span><span class="s2">}</span><span class="s5">) and end (</span><span class="s2">{</span><span class="s1">len(end)</span><span class="s2">}</span><span class="s5">) bounds must be the &quot;</span>
                <span class="s5">f&quot;same length&quot;</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">len(start) != num_vals:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s5">f&quot;start and end bounds (</span><span class="s2">{</span><span class="s1">len(start)</span><span class="s2">}</span><span class="s5">) must be the same length &quot;</span>
                <span class="s5">f&quot;as the object (</span><span class="s2">{</span><span class="s1">num_vals</span><span class="s2">}</span><span class="s5">)&quot;</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_create_data(self</span><span class="s2">, </span><span class="s1">obj: NDFrameT) -&gt; NDFrameT:</span>
        <span class="s0">&quot;&quot;&quot; 
        Split data into blocks &amp; return conformed data. 
        &quot;&quot;&quot;</span>
        <span class="s3"># filter out the on from the object</span>
        <span class="s2">if </span><span class="s1">self.on </span><span class="s2">is not None and not </span><span class="s1">isinstance(self.on</span><span class="s2">, </span><span class="s1">Index) </span><span class="s2">and </span><span class="s1">obj.ndim == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">obj = obj.reindex(columns=obj.columns.difference([self.on])</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.axis == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3"># GH: 20649 in case of mixed dtype and axis=1 we have to convert everything</span>
            <span class="s3"># to float to calculate the complete row at once. We exclude all non-numeric</span>
            <span class="s3"># dtypes.</span>
            <span class="s1">obj = obj.select_dtypes(include=[</span><span class="s5">&quot;number&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exclude=[</span><span class="s5">&quot;timedelta&quot;</span><span class="s1">])</span>
            <span class="s1">obj = obj.astype(</span><span class="s5">&quot;float64&quot;</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">obj._mgr = obj._mgr.consolidate()</span>
        <span class="s2">return </span><span class="s1">obj</span>

    <span class="s2">def </span><span class="s1">_gotitem(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">subset=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Sub-classes to define. Return a sliced object. 
 
        Parameters 
        ---------- 
        key : str / list of selections 
        ndim : {1, 2} 
            requested ndim of result 
        subset : object, default None 
            subset to act on 
        &quot;&quot;&quot;</span>
        <span class="s3"># create a new object to prevent aliasing</span>
        <span class="s2">if </span><span class="s1">subset </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">subset = self.obj</span>

        <span class="s3"># we need to make a shallow copy of ourselves</span>
        <span class="s3"># with the same groupby</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s3"># TODO(2.0): Remove once win_type deprecation is enforced</span>
            <span class="s1">warnings.filterwarnings(</span><span class="s5">&quot;ignore&quot;</span><span class="s2">, </span><span class="s5">&quot;win_type&quot;</span><span class="s2">, </span><span class="s1">FutureWarning)</span>
            <span class="s1">kwargs = {attr: getattr(self</span><span class="s2">, </span><span class="s1">attr) </span><span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">self._attributes}</span>

        <span class="s1">selection = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">subset.ndim == </span><span class="s4">2 </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">(is_scalar(key) </span><span class="s2">and </span><span class="s1">key </span><span class="s2">in </span><span class="s1">subset) </span><span class="s2">or </span><span class="s1">is_list_like(key)</span>
        <span class="s1">):</span>
            <span class="s1">selection = key</span>

        <span class="s1">new_win = type(self)(subset</span><span class="s2">, </span><span class="s1">selection=selection</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">return </span><span class="s1">new_win</span>

    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">attr: str):</span>
        <span class="s2">if </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">self._internal_names_set:</span>
            <span class="s2">return </span><span class="s1">object.__getattribute__(self</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s2">if </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">self.obj:</span>
            <span class="s2">return </span><span class="s1">self[attr]</span>

        <span class="s2">raise </span><span class="s1">AttributeError(</span>
            <span class="s5">f&quot;'</span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">}</span><span class="s5">' object has no attribute '</span><span class="s2">{</span><span class="s1">attr</span><span class="s2">}</span><span class="s5">'&quot;</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_dir_additions(self):</span>
        <span class="s2">return </span><span class="s1">self.obj._dir_additions()</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        Provide a nice str repr of our rolling object. 
        &quot;&quot;&quot;</span>
        <span class="s1">attrs_list = (</span>
            <span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s5">=</span><span class="s2">{</span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">attr_name)</span><span class="s2">}</span><span class="s5">&quot;</span>
            <span class="s2">for </span><span class="s1">attr_name </span><span class="s2">in </span><span class="s1">self._attributes</span>
            <span class="s2">if </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">attr_name</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is not None and </span><span class="s1">attr_name[</span><span class="s4">0</span><span class="s1">] != </span><span class="s5">&quot;_&quot;</span>
        <span class="s1">)</span>
        <span class="s1">attrs = </span><span class="s5">&quot;,&quot;</span><span class="s1">.join(attrs_list)</span>
        <span class="s2">return </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">} </span><span class="s5">[</span><span class="s2">{</span><span class="s1">attrs</span><span class="s2">}</span><span class="s5">]&quot;</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s1">obj = self._selected_obj.set_axis(self._on)</span>
        <span class="s1">obj = self._create_data(obj)</span>
        <span class="s1">indexer = self._get_window_indexer()</span>

        <span class="s1">start</span><span class="s2">, </span><span class="s1">end = indexer.get_window_bounds(</span>
            <span class="s1">num_values=len(obj)</span><span class="s2">,</span>
            <span class="s1">min_periods=self.min_periods</span><span class="s2">,</span>
            <span class="s1">center=self.center</span><span class="s2">,</span>
            <span class="s1">closed=self.closed</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self._check_window_bounds(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">len(obj))</span>

        <span class="s2">for </span><span class="s1">s</span><span class="s2">, </span><span class="s1">e </span><span class="s2">in </span><span class="s1">zip(start</span><span class="s2">, </span><span class="s1">end):</span>
            <span class="s1">result = obj.iloc[slice(s</span><span class="s2">, </span><span class="s1">e)]</span>
            <span class="s2">yield </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_prep_values(self</span><span class="s2">, </span><span class="s1">values: ArrayLike) -&gt; np.ndarray:</span>
        <span class="s0">&quot;&quot;&quot;Convert input to numpy arrays for Cython routines&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">needs_i8_conversion(values.dtype):</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s5">f&quot;ops for </span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">} </span><span class="s5">for this &quot;</span>
                <span class="s5">f&quot;dtype </span><span class="s2">{</span><span class="s1">values.dtype</span><span class="s2">} </span><span class="s5">are not implemented&quot;</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># GH #12373 : rolling functions error on float32 data</span>
            <span class="s3"># make sure the data is coerced to float64</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">isinstance(values</span><span class="s2">, </span><span class="s1">ExtensionArray):</span>
                    <span class="s1">values = values.to_numpy(np.float64</span><span class="s2">, </span><span class="s1">na_value=np.nan)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">values = ensure_float64(values)</span>
            <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">TypeError) </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">f&quot;cannot handle this type -&gt; </span><span class="s2">{</span><span class="s1">values.dtype</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

        <span class="s3"># Convert inf to nan for C funcs</span>
        <span class="s1">inf = np.isinf(values)</span>
        <span class="s2">if </span><span class="s1">inf.any():</span>
            <span class="s1">values = np.where(inf</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">values)</span>

        <span class="s2">return </span><span class="s1">values</span>

    <span class="s2">def </span><span class="s1">_insert_on_column(self</span><span class="s2">, </span><span class="s1">result: DataFrame</span><span class="s2">, </span><span class="s1">obj: DataFrame) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3"># if we have an 'on' column we want to put it back into</span>
        <span class="s3"># the results in the same location</span>
        <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">Series</span>

        <span class="s2">if </span><span class="s1">self.on </span><span class="s2">is not None and not </span><span class="s1">self._on.equals(obj.index):</span>
            <span class="s1">name = self._on.name</span>
            <span class="s1">extra_col = Series(self._on</span><span class="s2">, </span><span class="s1">index=self.obj.index</span><span class="s2">, </span><span class="s1">name=name)</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">result.columns:</span>
                <span class="s3"># TODO: sure we want to overwrite results?</span>
                <span class="s1">result[name] = extra_col</span>
            <span class="s2">elif </span><span class="s1">name </span><span class="s2">in </span><span class="s1">result.index.names:</span>
                <span class="s2">pass</span>
            <span class="s2">elif </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._selected_obj.columns:</span>
                <span class="s3"># insert in the same location as we had in _selected_obj</span>
                <span class="s1">old_cols = self._selected_obj.columns</span>
                <span class="s1">new_cols = result.columns</span>
                <span class="s1">old_loc = old_cols.get_loc(name)</span>
                <span class="s1">overlap = new_cols.intersection(old_cols[:old_loc])</span>
                <span class="s1">new_loc = len(overlap)</span>
                <span class="s1">result.insert(new_loc</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">extra_col)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s3"># insert at the end</span>
                <span class="s1">result[name] = extra_col</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_index_array(self):</span>
        <span class="s3"># TODO: why do we get here with e.g. MultiIndex?</span>
        <span class="s2">if </span><span class="s1">needs_i8_conversion(self._on.dtype):</span>
            <span class="s2">return </span><span class="s1">self._on.asi8</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_resolve_output(self</span><span class="s2">, </span><span class="s1">out: DataFrame</span><span class="s2">, </span><span class="s1">obj: DataFrame) -&gt; DataFrame:</span>
        <span class="s0">&quot;&quot;&quot;Validate and finalize result.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">out.shape[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">obj.shape[</span><span class="s4">1</span><span class="s1">] &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">DataError(</span><span class="s5">&quot;No numeric types to aggregate&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">out.shape[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">obj.astype(</span><span class="s5">&quot;float64&quot;</span><span class="s1">)</span>

        <span class="s1">self._insert_on_column(out</span><span class="s2">, </span><span class="s1">obj)</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">_get_window_indexer(self) -&gt; BaseIndexer:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return an indexer class that will compute the window start and end bounds 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(self.window</span><span class="s2">, </span><span class="s1">BaseIndexer):</span>
            <span class="s2">return </span><span class="s1">self.window</span>
        <span class="s2">if </span><span class="s1">self._win_freq_i8 </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">VariableWindowIndexer(</span>
                <span class="s1">index_array=self._index_array</span><span class="s2">,</span>
                <span class="s1">window_size=self._win_freq_i8</span><span class="s2">,</span>
                <span class="s1">center=self.center</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">FixedWindowIndexer(window_size=self.window)</span>

    <span class="s2">def </span><span class="s1">_apply_series(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">homogeneous_func: Callable[...</span><span class="s2">, </span><span class="s1">ArrayLike]</span><span class="s2">, </span><span class="s1">name: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span>
    <span class="s1">) -&gt; Series:</span>
        <span class="s0">&quot;&quot;&quot; 
        Series version of _apply_blockwise 
        &quot;&quot;&quot;</span>
        <span class="s1">obj = self._create_data(self._selected_obj)</span>

        <span class="s2">if </span><span class="s1">name == </span><span class="s5">&quot;count&quot;</span><span class="s1">:</span>
            <span class="s3"># GH 12541: Special case for count where we support date-like types</span>
            <span class="s1">obj = notna(obj).astype(int)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">values = self._prep_values(obj._values)</span>
        <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">NotImplementedError) </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s2">raise </span><span class="s1">DataError(</span><span class="s5">&quot;No numeric types to aggregate&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

        <span class="s1">result = homogeneous_func(values)</span>
        <span class="s2">return </span><span class="s1">obj._constructor(result</span><span class="s2">, </span><span class="s1">index=obj.index</span><span class="s2">, </span><span class="s1">name=obj.name)</span>

    <span class="s2">def </span><span class="s1">_apply_blockwise(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">homogeneous_func: Callable[...</span><span class="s2">, </span><span class="s1">ArrayLike]</span><span class="s2">, </span><span class="s1">name: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span>
    <span class="s1">) -&gt; DataFrame | Series:</span>
        <span class="s0">&quot;&quot;&quot; 
        Apply the given function to the DataFrame broken down into homogeneous 
        sub-frames. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._selected_obj.ndim == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._apply_series(homogeneous_func</span><span class="s2">, </span><span class="s1">name)</span>

        <span class="s1">obj = self._create_data(self._selected_obj)</span>
        <span class="s2">if </span><span class="s1">name == </span><span class="s5">&quot;count&quot;</span><span class="s1">:</span>
            <span class="s3"># GH 12541: Special case for count where we support date-like types</span>
            <span class="s1">obj = notna(obj).astype(int)</span>
            <span class="s1">obj._mgr = obj._mgr.consolidate()</span>

        <span class="s2">def </span><span class="s1">hfunc(values: ArrayLike) -&gt; ArrayLike:</span>
            <span class="s1">values = self._prep_values(values)</span>
            <span class="s2">return </span><span class="s1">homogeneous_func(values)</span>

        <span class="s2">if </span><span class="s1">self.axis == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">obj = obj.T</span>

        <span class="s1">taker = []</span>
        <span class="s1">res_values = []</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">enumerate(obj._iter_column_arrays()):</span>
            <span class="s3"># GH#42736 operate column-wise instead of block-wise</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">res = hfunc(arr)</span>
            <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">NotImplementedError):</span>
                <span class="s2">pass</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">res_values.append(res)</span>
                <span class="s1">taker.append(i)</span>

        <span class="s1">df = type(obj)._from_arrays(</span>
            <span class="s1">res_values</span><span class="s2">,</span>
            <span class="s1">index=obj.index</span><span class="s2">,</span>
            <span class="s1">columns=obj.columns.take(taker)</span><span class="s2">,</span>
            <span class="s1">verify_integrity=</span><span class="s2">False,</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.axis == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">df = df.T</span>

        <span class="s2">if </span><span class="s4">0 </span><span class="s1">!= len(res_values) != len(obj.columns):</span>
            <span class="s3"># GH#42738 ignore_failures dropped nuisance columns</span>
            <span class="s1">dropped = obj.columns.difference(obj.columns.take(taker))</span>
            <span class="s1">warnings.warn(</span>
                <span class="s5">&quot;Dropping of nuisance columns in rolling operations &quot;</span>
                <span class="s5">&quot;is deprecated; in a future version this will raise TypeError. &quot;</span>
                <span class="s5">&quot;Select only valid columns before calling the operation. &quot;</span>
                <span class="s5">f&quot;Dropped columns were </span><span class="s2">{</span><span class="s1">dropped</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s2">,</span>
                <span class="s1">FutureWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">self._resolve_output(df</span><span class="s2">, </span><span class="s1">obj)</span>

    <span class="s2">def </span><span class="s1">_apply_tablewise(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">homogeneous_func: Callable[...</span><span class="s2">, </span><span class="s1">ArrayLike]</span><span class="s2">, </span><span class="s1">name: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span>
    <span class="s1">) -&gt; DataFrame | Series:</span>
        <span class="s0">&quot;&quot;&quot; 
        Apply the given function to the DataFrame across the entire object 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._selected_obj.ndim == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;method='table' not applicable for Series objects.&quot;</span><span class="s1">)</span>
        <span class="s1">obj = self._create_data(self._selected_obj)</span>
        <span class="s1">values = self._prep_values(obj.to_numpy())</span>
        <span class="s1">values = values.T </span><span class="s2">if </span><span class="s1">self.axis == </span><span class="s4">1 </span><span class="s2">else </span><span class="s1">values</span>
        <span class="s1">result = homogeneous_func(values)</span>
        <span class="s1">result = result.T </span><span class="s2">if </span><span class="s1">self.axis == </span><span class="s4">1 </span><span class="s2">else </span><span class="s1">result</span>
        <span class="s1">out = obj._constructor(result</span><span class="s2">, </span><span class="s1">index=obj.index</span><span class="s2">, </span><span class="s1">columns=obj.columns)</span>

        <span class="s2">return </span><span class="s1">self._resolve_output(out</span><span class="s2">, </span><span class="s1">obj)</span>

    <span class="s2">def </span><span class="s1">_apply_pairwise(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">target: DataFrame | Series</span><span class="s2">,</span>
        <span class="s1">other: DataFrame | Series | </span><span class="s2">None,</span>
        <span class="s1">pairwise: bool | </span><span class="s2">None,</span>
        <span class="s1">func: Callable[[DataFrame | Series</span><span class="s2">, </span><span class="s1">DataFrame | Series]</span><span class="s2">, </span><span class="s1">DataFrame | Series]</span><span class="s2">,</span>
    <span class="s1">) -&gt; DataFrame | Series:</span>
        <span class="s0">&quot;&quot;&quot; 
        Apply the given pairwise function given 2 pandas objects (DataFrame/Series) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">other = target</span>
            <span class="s3"># only default unset</span>
            <span class="s1">pairwise = </span><span class="s2">True if </span><span class="s1">pairwise </span><span class="s2">is None else </span><span class="s1">pairwise</span>
        <span class="s2">elif not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">(ABCDataFrame</span><span class="s2">, </span><span class="s1">ABCSeries)):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;other must be a DataFrame or Series&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">flex_binary_moment(target</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">pairwise=bool(pairwise))</span>

    <span class="s2">def </span><span class="s1">_apply(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">func: Callable[...</span><span class="s2">, </span><span class="s1">Any]</span><span class="s2">,</span>
        <span class="s1">name: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">numba_cache_key: tuple[Callable</span><span class="s2">, </span><span class="s1">str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">numba_args: tuple[Any</span><span class="s2">, </span><span class="s1">...] = ()</span><span class="s2">,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Rolling statistical measure using supplied function. 
 
        Designed to be used with passed-in Cython array-based functions. 
 
        Parameters 
        ---------- 
        func : callable function to apply 
        name : str, 
        numba_cache_key : tuple 
            caching key to be used to store a compiled numba func 
        numba_args : tuple 
            args to be passed when func is a numba func 
        **kwargs 
            additional arguments for rolling function and window function 
 
        Returns 
        ------- 
        y : type of input 
        &quot;&quot;&quot;</span>
        <span class="s1">window_indexer = self._get_window_indexer()</span>
        <span class="s1">min_periods = (</span>
            <span class="s1">self.min_periods</span>
            <span class="s2">if </span><span class="s1">self.min_periods </span><span class="s2">is not None</span>
            <span class="s2">else </span><span class="s1">window_indexer.window_size</span>
        <span class="s1">)</span>

        <span class="s2">def </span><span class="s1">homogeneous_func(values: np.ndarray):</span>
            <span class="s3"># calculation function</span>

            <span class="s2">if </span><span class="s1">values.size == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">values.copy()</span>

            <span class="s2">def </span><span class="s1">calc(x):</span>
                <span class="s1">start</span><span class="s2">, </span><span class="s1">end = window_indexer.get_window_bounds(</span>
                    <span class="s1">num_values=len(x)</span><span class="s2">,</span>
                    <span class="s1">min_periods=min_periods</span><span class="s2">,</span>
                    <span class="s1">center=self.center</span><span class="s2">,</span>
                    <span class="s1">closed=self.closed</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s1">self._check_window_bounds(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">len(x))</span>

                <span class="s2">return </span><span class="s1">func(x</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">min_periods</span><span class="s2">, </span><span class="s1">*numba_args)</span>

            <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
                <span class="s1">result = calc(values)</span>

            <span class="s2">if </span><span class="s1">numba_cache_key </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">NUMBA_FUNC_CACHE[numba_cache_key] = func</span>

            <span class="s2">return </span><span class="s1">result</span>

        <span class="s2">if </span><span class="s1">self.method == </span><span class="s5">&quot;single&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._apply_blockwise(homogeneous_func</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._apply_tablewise(homogeneous_func</span><span class="s2">, </span><span class="s1">name)</span>

    <span class="s2">def </span><span class="s1">_numba_apply(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">func: Callable[...</span><span class="s2">, </span><span class="s1">Any]</span><span class="s2">,</span>
        <span class="s1">numba_cache_key_str: str</span><span class="s2">,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s2">, </span><span class="s1">bool] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">*func_args</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">window_indexer = self._get_window_indexer()</span>
        <span class="s1">min_periods = (</span>
            <span class="s1">self.min_periods</span>
            <span class="s2">if </span><span class="s1">self.min_periods </span><span class="s2">is not None</span>
            <span class="s2">else </span><span class="s1">window_indexer.window_size</span>
        <span class="s1">)</span>
        <span class="s1">obj = self._create_data(self._selected_obj)</span>
        <span class="s2">if </span><span class="s1">self.axis == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">obj = obj.T</span>
        <span class="s1">values = self._prep_values(obj.to_numpy())</span>
        <span class="s2">if </span><span class="s1">values.ndim == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">values = values.reshape(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">start</span><span class="s2">, </span><span class="s1">end = window_indexer.get_window_bounds(</span>
            <span class="s1">num_values=len(values)</span><span class="s2">,</span>
            <span class="s1">min_periods=min_periods</span><span class="s2">,</span>
            <span class="s1">center=self.center</span><span class="s2">,</span>
            <span class="s1">closed=self.closed</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self._check_window_bounds(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">len(values))</span>
        <span class="s1">aggregator = executor.generate_shared_aggregator(</span>
            <span class="s1">func</span><span class="s2">, </span><span class="s1">engine_kwargs</span><span class="s2">, </span><span class="s1">numba_cache_key_str</span>
        <span class="s1">)</span>
        <span class="s1">result = aggregator(values</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">min_periods</span><span class="s2">, </span><span class="s1">*func_args)</span>
        <span class="s1">NUMBA_FUNC_CACHE[(func</span><span class="s2">, </span><span class="s1">numba_cache_key_str)] = aggregator</span>
        <span class="s1">result = result.T </span><span class="s2">if </span><span class="s1">self.axis == </span><span class="s4">1 </span><span class="s2">else </span><span class="s1">result</span>
        <span class="s2">if </span><span class="s1">obj.ndim == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">result = result.squeeze()</span>
            <span class="s1">out = obj._constructor(result</span><span class="s2">, </span><span class="s1">index=obj.index</span><span class="s2">, </span><span class="s1">name=obj.name)</span>
            <span class="s2">return </span><span class="s1">out</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">out = obj._constructor(result</span><span class="s2">, </span><span class="s1">index=obj.index</span><span class="s2">, </span><span class="s1">columns=obj.columns)</span>
            <span class="s2">return </span><span class="s1">self._resolve_output(out</span><span class="s2">, </span><span class="s1">obj)</span>

    <span class="s2">def </span><span class="s1">aggregate(self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">result = ResamplerWindowApply(self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">args=args</span><span class="s2">, </span><span class="s1">kwargs=kwargs).agg()</span>
        <span class="s2">if </span><span class="s1">result </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.apply(func</span><span class="s2">, </span><span class="s1">raw=</span><span class="s2">False, </span><span class="s1">args=args</span><span class="s2">, </span><span class="s1">kwargs=kwargs)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s1">agg = aggregate</span>


<span class="s2">class </span><span class="s1">BaseWindowGroupby(BaseWindow):</span>
    <span class="s0">&quot;&quot;&quot; 
    Provide the groupby windowing facilities. 
    &quot;&quot;&quot;</span>

    <span class="s1">_grouper: BaseGrouper</span>
    <span class="s1">_as_index: bool</span>
    <span class="s1">_attributes: list[str] = [</span><span class="s5">&quot;_grouper&quot;</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">obj: DataFrame | Series</span><span class="s2">,</span>
        <span class="s1">*args</span><span class="s2">,</span>
        <span class="s1">_grouper: BaseGrouper</span><span class="s2">,</span>
        <span class="s1">_as_index: bool = </span><span class="s2">True,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s2">from </span><span class="s1">pandas.core.groupby.ops </span><span class="s2">import </span><span class="s1">BaseGrouper</span>

        <span class="s2">if not </span><span class="s1">isinstance(_grouper</span><span class="s2">, </span><span class="s1">BaseGrouper):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Must pass a BaseGrouper object.&quot;</span><span class="s1">)</span>
        <span class="s1">self._grouper = _grouper</span>
        <span class="s1">self._as_index = _as_index</span>
        <span class="s3"># GH 32262: It's convention to keep the grouping column in</span>
        <span class="s3"># groupby.&lt;agg_func&gt;, but unexpected to users in</span>
        <span class="s3"># groupby.rolling.&lt;agg_func&gt;</span>
        <span class="s1">obj = obj.drop(columns=self._grouper.names</span><span class="s2">, </span><span class="s1">errors=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">super().__init__(obj</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">_apply(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">func: Callable[...</span><span class="s2">, </span><span class="s1">Any]</span><span class="s2">,</span>
        <span class="s1">name: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">numba_cache_key: tuple[Callable</span><span class="s2">, </span><span class="s1">str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">numba_args: tuple[Any</span><span class="s2">, </span><span class="s1">...] = ()</span><span class="s2">,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">) -&gt; DataFrame | Series:</span>
        <span class="s1">result = super()._apply(</span>
            <span class="s1">func</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">,</span>
            <span class="s1">numba_cache_key</span><span class="s2">,</span>
            <span class="s1">numba_args</span><span class="s2">,</span>
            <span class="s1">**kwargs</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s3"># Reconstruct the resulting MultiIndex</span>
        <span class="s3"># 1st set of levels = group by labels</span>
        <span class="s3"># 2nd set of levels = original DataFrame/Series index</span>
        <span class="s1">grouped_object_index = self.obj.index</span>
        <span class="s1">grouped_index_name = [*grouped_object_index.names]</span>
        <span class="s1">groupby_keys = copy.copy(self._grouper.names)</span>
        <span class="s1">result_index_names = groupby_keys + grouped_index_name</span>

        <span class="s1">drop_columns = [</span>
            <span class="s1">key</span>
            <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self._grouper.names</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">self.obj.index.names </span><span class="s2">or </span><span class="s1">key </span><span class="s2">is None</span>
        <span class="s1">]</span>

        <span class="s2">if </span><span class="s1">len(drop_columns) != len(groupby_keys):</span>
            <span class="s3"># Our result will have still kept the column in the result</span>
            <span class="s1">result = result.drop(columns=drop_columns</span><span class="s2">, </span><span class="s1">errors=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">)</span>

        <span class="s1">codes = self._grouper.codes</span>
        <span class="s1">levels = copy.copy(self._grouper.levels)</span>

        <span class="s1">group_indices = self._grouper.indices.values()</span>
        <span class="s2">if </span><span class="s1">group_indices:</span>
            <span class="s1">indexer = np.concatenate(list(group_indices))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">indexer = np.array([]</span><span class="s2">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s1">codes = [c.take(indexer) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">codes]</span>

        <span class="s3"># if the index of the original dataframe needs to be preserved, append</span>
        <span class="s3"># this index (but reordered) to the codes/levels from the groupby</span>
        <span class="s2">if </span><span class="s1">grouped_object_index </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">idx = grouped_object_index.take(indexer)</span>
            <span class="s2">if not </span><span class="s1">isinstance(idx</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
                <span class="s1">idx = MultiIndex.from_arrays([idx])</span>
            <span class="s1">codes.extend(list(idx.codes))</span>
            <span class="s1">levels.extend(list(idx.levels))</span>

        <span class="s1">result_index = MultiIndex(</span>
            <span class="s1">levels</span><span class="s2">, </span><span class="s1">codes</span><span class="s2">, </span><span class="s1">names=result_index_names</span><span class="s2">, </span><span class="s1">verify_integrity=</span><span class="s2">False</span>
        <span class="s1">)</span>

        <span class="s1">result.index = result_index</span>
        <span class="s2">if not </span><span class="s1">self._as_index:</span>
            <span class="s1">result = result.reset_index(level=list(range(len(groupby_keys))))</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_apply_pairwise(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">target: DataFrame | Series</span><span class="s2">,</span>
        <span class="s1">other: DataFrame | Series | </span><span class="s2">None,</span>
        <span class="s1">pairwise: bool | </span><span class="s2">None,</span>
        <span class="s1">func: Callable[[DataFrame | Series</span><span class="s2">, </span><span class="s1">DataFrame | Series]</span><span class="s2">, </span><span class="s1">DataFrame | Series]</span><span class="s2">,</span>
    <span class="s1">) -&gt; DataFrame | Series:</span>
        <span class="s0">&quot;&quot;&quot; 
        Apply the given pairwise function given 2 pandas objects (DataFrame/Series) 
        &quot;&quot;&quot;</span>
        <span class="s3"># Manually drop the grouping column first</span>
        <span class="s1">target = target.drop(columns=self._grouper.names</span><span class="s2">, </span><span class="s1">errors=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">target = self._create_data(target)</span>
        <span class="s1">result = super()._apply_pairwise(target</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">pairwise</span><span class="s2">, </span><span class="s1">func)</span>
        <span class="s3"># 1) Determine the levels + codes of the groupby levels</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is not None and not </span><span class="s1">all(</span>
            <span class="s1">len(group) == len(other) </span><span class="s2">for </span><span class="s1">group </span><span class="s2">in </span><span class="s1">self._grouper.indices.values()</span>
        <span class="s1">):</span>
            <span class="s3"># GH 42915</span>
            <span class="s3"># len(other) != len(any group), so must reindex (expand) the result</span>
            <span class="s3"># from flex_binary_moment to a &quot;transform&quot;-like result</span>
            <span class="s3"># per groupby combination</span>
            <span class="s1">old_result_len = len(result)</span>
            <span class="s1">result = concat(</span>
                <span class="s1">[</span>
                    <span class="s1">result.take(gb_indices).reindex(result.index)</span>
                    <span class="s2">for </span><span class="s1">gb_indices </span><span class="s2">in </span><span class="s1">self._grouper.indices.values()</span>
                <span class="s1">]</span>
            <span class="s1">)</span>

            <span class="s1">gb_pairs = (</span>
                <span class="s1">com.maybe_make_list(pair) </span><span class="s2">for </span><span class="s1">pair </span><span class="s2">in </span><span class="s1">self._grouper.indices.keys()</span>
            <span class="s1">)</span>
            <span class="s1">groupby_codes = []</span>
            <span class="s1">groupby_levels = []</span>
            <span class="s3"># e.g. [[1, 2], [4, 5]] as [[1, 4], [2, 5]]</span>
            <span class="s2">for </span><span class="s1">gb_level_pair </span><span class="s2">in </span><span class="s1">map(list</span><span class="s2">, </span><span class="s1">zip(*gb_pairs)):</span>
                <span class="s1">labels = np.repeat(np.array(gb_level_pair)</span><span class="s2">, </span><span class="s1">old_result_len)</span>
                <span class="s1">codes</span><span class="s2">, </span><span class="s1">levels = factorize(labels)</span>
                <span class="s1">groupby_codes.append(codes)</span>
                <span class="s1">groupby_levels.append(levels)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># pairwise=True or len(other) == len(each group), so repeat</span>
            <span class="s3"># the groupby labels by the number of columns in the original object</span>
            <span class="s1">groupby_codes = self._grouper.codes</span>
            <span class="s3"># error: Incompatible types in assignment (expression has type</span>
            <span class="s3"># &quot;List[Index]&quot;, variable has type &quot;List[Union[ndarray, Index]]&quot;)</span>
            <span class="s1">groupby_levels = self._grouper.levels  </span><span class="s3"># type: ignore[assignment]</span>

            <span class="s1">group_indices = self._grouper.indices.values()</span>
            <span class="s2">if </span><span class="s1">group_indices:</span>
                <span class="s1">indexer = np.concatenate(list(group_indices))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">indexer = np.array([]</span><span class="s2">, </span><span class="s1">dtype=np.intp)</span>

            <span class="s2">if </span><span class="s1">target.ndim == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">repeat_by = </span><span class="s4">1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">repeat_by = len(target.columns)</span>
            <span class="s1">groupby_codes = [</span>
                <span class="s1">np.repeat(c.take(indexer)</span><span class="s2">, </span><span class="s1">repeat_by) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">groupby_codes</span>
            <span class="s1">]</span>
        <span class="s3"># 2) Determine the levels + codes of the result from super()._apply_pairwise</span>
        <span class="s2">if </span><span class="s1">isinstance(result.index</span><span class="s2">, </span><span class="s1">MultiIndex):</span>
            <span class="s1">result_codes = list(result.index.codes)</span>
            <span class="s1">result_levels = list(result.index.levels)</span>
            <span class="s1">result_names = list(result.index.names)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">idx_codes</span><span class="s2">, </span><span class="s1">idx_levels = factorize(result.index)</span>
            <span class="s1">result_codes = [idx_codes]</span>
            <span class="s1">result_levels = [idx_levels]</span>
            <span class="s1">result_names = [result.index.name]</span>

        <span class="s3"># 3) Create the resulting index by combining 1) + 2)</span>
        <span class="s1">result_codes = groupby_codes + result_codes</span>
        <span class="s1">result_levels = groupby_levels + result_levels</span>
        <span class="s1">result_names = self._grouper.names + result_names</span>

        <span class="s1">result_index = MultiIndex(</span>
            <span class="s1">result_levels</span><span class="s2">, </span><span class="s1">result_codes</span><span class="s2">, </span><span class="s1">names=result_names</span><span class="s2">, </span><span class="s1">verify_integrity=</span><span class="s2">False</span>
        <span class="s1">)</span>
        <span class="s1">result.index = result_index</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_create_data(self</span><span class="s2">, </span><span class="s1">obj: NDFrameT) -&gt; NDFrameT:</span>
        <span class="s0">&quot;&quot;&quot; 
        Split data into blocks &amp; return conformed data. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Ensure the object we're rolling over is monotonically sorted relative</span>
        <span class="s3"># to the groups</span>
        <span class="s3"># GH 36197</span>
        <span class="s2">if not </span><span class="s1">obj.empty:</span>
            <span class="s1">groupby_order = np.concatenate(list(self._grouper.indices.values())).astype(</span>
                <span class="s1">np.int64</span>
            <span class="s1">)</span>
            <span class="s1">obj = obj.take(groupby_order)</span>
        <span class="s2">return </span><span class="s1">super()._create_data(obj)</span>

    <span class="s2">def </span><span class="s1">_gotitem(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">subset=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s3"># we are setting the index on the actual object</span>
        <span class="s3"># here so our index is carried through to the selected obj</span>
        <span class="s3"># when we do the splitting for the groupby</span>
        <span class="s2">if </span><span class="s1">self.on </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s3"># GH 43355</span>
            <span class="s1">subset = self.obj.set_index(self._on)</span>
        <span class="s2">return </span><span class="s1">super()._gotitem(key</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">subset=subset)</span>

    <span class="s2">def </span><span class="s1">_validate_monotonic(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Validate that &quot;on&quot; is monotonic; already validated at a higher level. 
        &quot;&quot;&quot;</span>
        <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">Window(BaseWindow):</span>
    <span class="s0">&quot;&quot;&quot; 
    Provide rolling window calculations. 
 
    Parameters 
    ---------- 
    window : int, offset, or BaseIndexer subclass 
        Size of the moving window. 
 
        If an integer, the fixed number of observations used for 
        each window. 
 
        If an offset, the time period of each window. Each 
        window will be a variable sized based on the observations included in 
        the time-period. This is only valid for datetimelike indexes. 
        To learn more about the offsets &amp; frequency strings, please see `this link 
        &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`__. 
 
        If a BaseIndexer subclass, the window boundaries 
        based on the defined ``get_window_bounds`` method. Additional rolling 
        keyword arguments, namely ``min_periods``, ``center``, and 
        ``closed`` will be passed to ``get_window_bounds``. 
 
    min_periods : int, default None 
        Minimum number of observations in window required to have a value; 
        otherwise, result is ``np.nan``. 
 
        For a window that is specified by an offset, ``min_periods`` will default to 1. 
 
        For a window that is specified by an integer, ``min_periods`` will default 
        to the size of the window. 
 
    center : bool, default False 
        If False, set the window labels as the right edge of the window index. 
 
        If True, set the window labels as the center of the window index. 
 
    win_type : str, default None 
        If ``None``, all points are evenly weighted. 
 
        If a string, it must be a valid `scipy.signal window function 
        &lt;https://docs.scipy.org/doc/scipy/reference/signal.windows.html#module-scipy.signal.windows&gt;`__. 
 
        Certain Scipy window types require additional parameters to be passed 
        in the aggregation function. The additional parameters must match 
        the keywords specified in the Scipy window type method signature. 
 
    on : str, optional 
        For a DataFrame, a column label or Index level on which 
        to calculate the rolling window, rather than the DataFrame's index. 
 
        Provided integer column is ignored and excluded from result since 
        an integer index is not used to calculate the rolling window. 
 
    axis : int or str, default 0 
        If ``0`` or ``'index'``, roll across the rows. 
 
        If ``1`` or ``'columns'``, roll across the columns. 
 
    closed : str, default None 
        If ``'right'``, the first point in the window is excluded from calculations. 
 
        If ``'left'``, the last point in the window is excluded from calculations. 
 
        If ``'both'``, the no points in the window are excluded from calculations. 
 
        If ``'neither'``, the first and last points in the window are excluded 
        from calculations. 
 
        Default ``None`` (``'right'``). 
 
        .. versionchanged:: 1.2.0 
 
            The closed parameter with fixed windows is now supported. 
 
    method : str {'single', 'table'}, default 'single' 
 
        .. versionadded:: 1.3.0 
 
        Execute the rolling operation per single column or row (``'single'``) 
        or over the entire object (``'table'``). 
 
        This argument is only implemented when specifying ``engine='numba'`` 
        in the method call. 
 
    Returns 
    ------- 
    ``Window`` subclass if a ``win_type`` is passed 
 
    ``Rolling`` subclass if ``win_type`` is not passed 
 
    See Also 
    -------- 
    expanding : Provides expanding transformations. 
    ewm : Provides exponential weighted functions. 
 
    Notes 
    ----- 
    See :ref:`Windowing Operations &lt;window.generic&gt;` for further usage details 
    and examples. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; df = pd.DataFrame({'B': [0, 1, 2, np.nan, 4]}) 
    &gt;&gt;&gt; df 
         B 
    0  0.0 
    1  1.0 
    2  2.0 
    3  NaN 
    4  4.0 
 
    **window** 
 
    Rolling sum with a window length of 2 observations. 
 
    &gt;&gt;&gt; df.rolling(2).sum() 
         B 
    0  NaN 
    1  1.0 
    2  3.0 
    3  NaN 
    4  NaN 
 
    Rolling sum with a window span of 2 seconds. 
 
    &gt;&gt;&gt; df_time = pd.DataFrame({'B': [0, 1, 2, np.nan, 4]}, 
    ...                        index = [pd.Timestamp('20130101 09:00:00'), 
    ...                                 pd.Timestamp('20130101 09:00:02'), 
    ...                                 pd.Timestamp('20130101 09:00:03'), 
    ...                                 pd.Timestamp('20130101 09:00:05'), 
    ...                                 pd.Timestamp('20130101 09:00:06')]) 
 
    &gt;&gt;&gt; df_time 
                           B 
    2013-01-01 09:00:00  0.0 
    2013-01-01 09:00:02  1.0 
    2013-01-01 09:00:03  2.0 
    2013-01-01 09:00:05  NaN 
    2013-01-01 09:00:06  4.0 
 
    &gt;&gt;&gt; df_time.rolling('2s').sum() 
                           B 
    2013-01-01 09:00:00  0.0 
    2013-01-01 09:00:02  1.0 
    2013-01-01 09:00:03  3.0 
    2013-01-01 09:00:05  NaN 
    2013-01-01 09:00:06  4.0 
 
    Rolling sum with forward looking windows with 2 observations. 
 
    &gt;&gt;&gt; indexer = pd.api.indexers.FixedForwardWindowIndexer(window_size=2) 
    &gt;&gt;&gt; df.rolling(window=indexer, min_periods=1).sum() 
         B 
    0  1.0 
    1  3.0 
    2  2.0 
    3  4.0 
    4  4.0 
 
    **min_periods** 
 
    Rolling sum with a window length of 2 observations, but only needs a minimum of 1 
    observation to calculate a value. 
 
    &gt;&gt;&gt; df.rolling(2, min_periods=1).sum() 
         B 
    0  0.0 
    1  1.0 
    2  3.0 
    3  2.0 
    4  4.0 
 
    **center** 
 
    Rolling sum with the result assigned to the center of the window index. 
 
    &gt;&gt;&gt; df.rolling(3, min_periods=1, center=True).sum() 
         B 
    0  1.0 
    1  3.0 
    2  3.0 
    3  6.0 
    4  4.0 
 
    &gt;&gt;&gt; df.rolling(3, min_periods=1, center=False).sum() 
         B 
    0  0.0 
    1  1.0 
    2  3.0 
    3  3.0 
    4  6.0 
 
    **win_type** 
 
    Rolling sum with a window length of 2, using the Scipy ``'gaussian'`` 
    window type. ``std`` is required in the aggregation function. 
 
    &gt;&gt;&gt; df.rolling(2, win_type='gaussian').sum(std=3) 
              B 
    0       NaN 
    1  0.986207 
    2  2.958621 
    3       NaN 
    4       NaN 
    &quot;&quot;&quot;</span>

    <span class="s1">_attributes = [</span>
        <span class="s5">&quot;window&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;min_periods&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;center&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;win_type&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;axis&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;on&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;closed&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;method&quot;</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s2">def </span><span class="s1">_validate(self):</span>
        <span class="s1">super()._validate()</span>

        <span class="s2">if not </span><span class="s1">isinstance(self.win_type</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;Invalid win_type </span><span class="s2">{</span><span class="s1">self.win_type</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s1">)</span>
        <span class="s1">signal = import_optional_dependency(</span>
            <span class="s5">&quot;scipy.signal&quot;</span><span class="s2">, </span><span class="s1">extra=</span><span class="s5">&quot;Scipy is required to generate window weight.&quot;</span>
        <span class="s1">)</span>
        <span class="s1">self._scipy_weight_generator = getattr(signal</span><span class="s2">, </span><span class="s1">self.win_type</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self._scipy_weight_generator </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;Invalid win_type </span><span class="s2">{</span><span class="s1">self.win_type</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(self.window</span><span class="s2">, </span><span class="s1">BaseIndexer):</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s5">&quot;BaseIndexer subclasses not implemented with win_types.&quot;</span>
            <span class="s1">)</span>
        <span class="s2">elif not </span><span class="s1">is_integer(self.window) </span><span class="s2">or </span><span class="s1">self.window &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;window must be an integer 0 or greater&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.method != </span><span class="s5">&quot;single&quot;</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s5">&quot;'single' is the only supported method type.&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_center_window(self</span><span class="s2">, </span><span class="s1">result: np.ndarray</span><span class="s2">, </span><span class="s1">offset: int) -&gt; np.ndarray:</span>
        <span class="s0">&quot;&quot;&quot; 
        Center the result in the window for weighted rolling aggregations. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.axis &gt; result.ndim - </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Requested axis is larger then no. of argument dimensions&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">offset &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">lead_indexer = [slice(</span><span class="s2">None</span><span class="s1">)] * result.ndim</span>
            <span class="s1">lead_indexer[self.axis] = slice(offset</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">result = np.copy(result[tuple(lead_indexer)])</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_apply(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">func: Callable[[np.ndarray</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">int]</span><span class="s2">, </span><span class="s1">np.ndarray]</span><span class="s2">,</span>
        <span class="s1">name: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">numba_cache_key: tuple[Callable</span><span class="s2">, </span><span class="s1">str] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">numba_args: tuple[Any</span><span class="s2">, </span><span class="s1">...] = ()</span><span class="s2">,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Rolling with weights statistical measure using supplied function. 
 
        Designed to be used with passed-in Cython array-based functions. 
 
        Parameters 
        ---------- 
        func : callable function to apply 
        name : str, 
        use_numba_cache : tuple 
            unused 
        numba_args : tuple 
            unused 
        **kwargs 
            additional arguments for scipy windows if necessary 
 
        Returns 
        ------- 
        y : type of input 
        &quot;&quot;&quot;</span>
        <span class="s3"># &quot;None&quot; not callable  [misc]</span>
        <span class="s1">window = self._scipy_weight_generator(  </span><span class="s3"># type: ignore[misc]</span>
            <span class="s1">self.window</span><span class="s2">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>
        <span class="s1">offset = (len(window) - </span><span class="s4">1</span><span class="s1">) // </span><span class="s4">2 </span><span class="s2">if </span><span class="s1">self.center </span><span class="s2">else </span><span class="s4">0</span>

        <span class="s2">def </span><span class="s1">homogeneous_func(values: np.ndarray):</span>
            <span class="s3"># calculation function</span>

            <span class="s2">if </span><span class="s1">values.size == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">values.copy()</span>

            <span class="s2">def </span><span class="s1">calc(x):</span>
                <span class="s1">additional_nans = np.array([np.nan] * offset)</span>
                <span class="s1">x = np.concatenate((x</span><span class="s2">, </span><span class="s1">additional_nans))</span>
                <span class="s2">return </span><span class="s1">func(x</span><span class="s2">, </span><span class="s1">window</span><span class="s2">, </span><span class="s1">self.min_periods </span><span class="s2">or </span><span class="s1">len(window))</span>

            <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
                <span class="s3"># Our weighted aggregations return memoryviews</span>
                <span class="s1">result = np.asarray(calc(values))</span>

            <span class="s2">if </span><span class="s1">self.center:</span>
                <span class="s1">result = self._center_window(result</span><span class="s2">, </span><span class="s1">offset)</span>

            <span class="s2">return </span><span class="s1">result</span>

        <span class="s2">return </span><span class="s1">self._apply_blockwise(homogeneous_func</span><span class="s2">, </span><span class="s1">name)</span>

    <span class="s1">@doc(</span>
        <span class="s1">_shared_docs[</span><span class="s5">&quot;aggregate&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">see_also=dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        See Also 
        -------- 
        pandas.DataFrame.aggregate : Similar DataFrame method. 
        pandas.Series.aggregate : Similar Series method. 
        &quot;&quot;&quot;</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">examples=dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        Examples 
        -------- 
        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, 2, 3], &quot;B&quot;: [4, 5, 6], &quot;C&quot;: [7, 8, 9]}) 
        &gt;&gt;&gt; df 
           A  B  C 
        0  1  4  7 
        1  2  5  8 
        2  3  6  9 
 
        &gt;&gt;&gt; df.rolling(2, win_type=&quot;boxcar&quot;).agg(&quot;mean&quot;) 
             A    B    C 
        0  NaN  NaN  NaN 
        1  1.5  4.5  7.5 
        2  2.5  5.5  8.5 
        &quot;&quot;&quot;</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">klass=</span><span class="s5">&quot;Series/DataFrame&quot;</span><span class="s2">,</span>
        <span class="s1">axis=</span><span class="s5">&quot;&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">aggregate(self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">result = ResamplerWindowApply(self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">args=args</span><span class="s2">, </span><span class="s1">kwargs=kwargs).agg()</span>
        <span class="s2">if </span><span class="s1">result </span><span class="s2">is None</span><span class="s1">:</span>

            <span class="s3"># these must apply directly</span>
            <span class="s1">result = func(self)</span>

        <span class="s2">return </span><span class="s1">result</span>

    <span class="s1">agg = aggregate</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">kwargs_scipy</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_see_also[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;weighted window sum&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;sum&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">sum(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">nv.validate_window_func(</span><span class="s5">&quot;sum&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>
        <span class="s1">window_func = window_aggregations.roll_weighted_sum</span>
        <span class="s3"># error: Argument 1 to &quot;_apply&quot; of &quot;Window&quot; has incompatible type</span>
        <span class="s3"># &quot;Callable[[ndarray, ndarray, int], ndarray]&quot;; expected</span>
        <span class="s3"># &quot;Callable[[ndarray, int, int], ndarray]&quot;</span>
        <span class="s2">return </span><span class="s1">self._apply(window_func</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;sum&quot;</span><span class="s2">, </span><span class="s1">**kwargs)  </span><span class="s3"># type: ignore[arg-type]</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">kwargs_scipy</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_see_also[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;weighted window mean&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;mean&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">mean(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">nv.validate_window_func(</span><span class="s5">&quot;mean&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>
        <span class="s1">window_func = window_aggregations.roll_weighted_mean</span>
        <span class="s3"># error: Argument 1 to &quot;_apply&quot; of &quot;Window&quot; has incompatible type</span>
        <span class="s3"># &quot;Callable[[ndarray, ndarray, int], ndarray]&quot;; expected</span>
        <span class="s3"># &quot;Callable[[ndarray, int, int], ndarray]&quot;</span>
        <span class="s2">return </span><span class="s1">self._apply(window_func</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;mean&quot;</span><span class="s2">, </span><span class="s1">**kwargs)  </span><span class="s3"># type: ignore[arg-type]</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s5">&quot;.. versionadded:: 1.0.0 </span><span class="s2">\n\n</span><span class="s5">&quot;</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">kwargs_scipy</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_see_also[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;weighted window variance&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;var&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">var(self</span><span class="s2">, </span><span class="s1">ddof: int = </span><span class="s4">1</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">nv.validate_window_func(</span><span class="s5">&quot;var&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>
        <span class="s1">window_func = partial(window_aggregations.roll_weighted_var</span><span class="s2">, </span><span class="s1">ddof=ddof)</span>
        <span class="s1">kwargs.pop(</span><span class="s5">&quot;name&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._apply(window_func</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;var&quot;</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s5">&quot;.. versionadded:: 1.0.0 </span><span class="s2">\n\n</span><span class="s5">&quot;</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">kwargs_scipy</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_see_also[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;weighted window standard deviation&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;std&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">std(self</span><span class="s2">, </span><span class="s1">ddof: int = </span><span class="s4">1</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">nv.validate_window_func(</span><span class="s5">&quot;std&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>
        <span class="s2">return </span><span class="s1">zsqrt(self.var(ddof=ddof</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;std&quot;</span><span class="s2">, </span><span class="s1">**kwargs))</span>


<span class="s2">class </span><span class="s1">RollingAndExpandingMixin(BaseWindow):</span>
    <span class="s2">def </span><span class="s1">count(self):</span>
        <span class="s1">window_func = window_aggregations.roll_sum</span>
        <span class="s2">return </span><span class="s1">self._apply(window_func</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;count&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">apply(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">func: Callable[...</span><span class="s2">, </span><span class="s1">Any]</span><span class="s2">,</span>
        <span class="s1">raw: bool = </span><span class="s2">False,</span>
        <span class="s1">engine: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s2">, </span><span class="s1">bool] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">args: tuple[Any</span><span class="s2">, </span><span class="s1">...] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">kwargs: dict[str</span><span class="s2">, </span><span class="s1">Any] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s2">if </span><span class="s1">args </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">args = ()</span>
        <span class="s2">if </span><span class="s1">kwargs </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">kwargs = {}</span>

        <span class="s2">if not </span><span class="s1">is_bool(raw):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;raw parameter must be `True` or `False`&quot;</span><span class="s1">)</span>

        <span class="s1">numba_cache_key = </span><span class="s2">None</span>
        <span class="s1">numba_args: tuple[Any</span><span class="s2">, </span><span class="s1">...] = ()</span>
        <span class="s2">if </span><span class="s1">maybe_use_numba(engine):</span>
            <span class="s2">if </span><span class="s1">raw </span><span class="s2">is False</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;raw must be `True` when using the numba engine&quot;</span><span class="s1">)</span>
            <span class="s1">caller_name = type(self).__name__</span>
            <span class="s1">numba_args = args</span>
            <span class="s2">if </span><span class="s1">self.method == </span><span class="s5">&quot;single&quot;</span><span class="s1">:</span>
                <span class="s1">apply_func = generate_numba_apply_func(</span>
                    <span class="s1">kwargs</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">engine_kwargs</span><span class="s2">, </span><span class="s1">caller_name</span>
                <span class="s1">)</span>
                <span class="s1">numba_cache_key = (func</span><span class="s2">, </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">caller_name</span><span class="s2">}</span><span class="s5">_apply_single&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">apply_func = generate_numba_table_func(</span>
                    <span class="s1">kwargs</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">engine_kwargs</span><span class="s2">, </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">caller_name</span><span class="s2">}</span><span class="s5">_apply&quot;</span>
                <span class="s1">)</span>
                <span class="s1">numba_cache_key = (func</span><span class="s2">, </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">caller_name</span><span class="s2">}</span><span class="s5">_apply_table&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">engine </span><span class="s2">in </span><span class="s1">(</span><span class="s5">&quot;cython&quot;</span><span class="s2">, None</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">engine_kwargs </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;cython engine does not accept engine_kwargs&quot;</span><span class="s1">)</span>
            <span class="s1">apply_func = self._generate_cython_apply_func(args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">raw</span><span class="s2">, </span><span class="s1">func)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;engine must be either 'numba' or 'cython'&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">self._apply(</span>
            <span class="s1">apply_func</span><span class="s2">,</span>
            <span class="s1">numba_cache_key=numba_cache_key</span><span class="s2">,</span>
            <span class="s1">numba_args=numba_args</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_generate_cython_apply_func(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">args: tuple[Any</span><span class="s2">, </span><span class="s1">...]</span><span class="s2">,</span>
        <span class="s1">kwargs: dict[str</span><span class="s2">, </span><span class="s1">Any]</span><span class="s2">,</span>
        <span class="s1">raw: bool</span><span class="s2">,</span>
        <span class="s1">function: Callable[...</span><span class="s2">, </span><span class="s1">Any]</span><span class="s2">,</span>
    <span class="s1">) -&gt; Callable[[np.ndarray</span><span class="s2">, </span><span class="s1">np.ndarray</span><span class="s2">, </span><span class="s1">np.ndarray</span><span class="s2">, </span><span class="s1">int]</span><span class="s2">, </span><span class="s1">np.ndarray]:</span>
        <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">Series</span>

        <span class="s1">window_func = partial(</span>
            <span class="s1">window_aggregations.roll_apply</span><span class="s2">,</span>
            <span class="s1">args=args</span><span class="s2">,</span>
            <span class="s1">kwargs=kwargs</span><span class="s2">,</span>
            <span class="s1">raw=raw</span><span class="s2">,</span>
            <span class="s1">function=function</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s2">def </span><span class="s1">apply_func(values</span><span class="s2">, </span><span class="s1">begin</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">min_periods</span><span class="s2">, </span><span class="s1">raw=raw):</span>
            <span class="s2">if not </span><span class="s1">raw:</span>
                <span class="s1">values = Series(values</span><span class="s2">, </span><span class="s1">index=self.obj.index)</span>
            <span class="s2">return </span><span class="s1">window_func(values</span><span class="s2">, </span><span class="s1">begin</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">min_periods)</span>

        <span class="s2">return </span><span class="s1">apply_func</span>

    <span class="s2">def </span><span class="s1">sum(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">*args</span><span class="s2">,</span>
        <span class="s1">engine: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s2">, </span><span class="s1">bool] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_window_func(</span><span class="s5">&quot;sum&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>
        <span class="s2">if </span><span class="s1">maybe_use_numba(engine):</span>
            <span class="s2">if </span><span class="s1">self.method == </span><span class="s5">&quot;table&quot;</span><span class="s1">:</span>
                <span class="s1">func = generate_manual_numpy_nan_agg_with_axis(np.nansum)</span>
                <span class="s2">return </span><span class="s1">self.apply(</span>
                    <span class="s1">func</span><span class="s2">,</span>
                    <span class="s1">raw=</span><span class="s2">True,</span>
                    <span class="s1">engine=engine</span><span class="s2">,</span>
                    <span class="s1">engine_kwargs=engine_kwargs</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">from </span><span class="s1">pandas.core._numba.kernels </span><span class="s2">import </span><span class="s1">sliding_sum</span>

                <span class="s2">return </span><span class="s1">self._numba_apply(sliding_sum</span><span class="s2">, </span><span class="s5">&quot;rolling_sum&quot;</span><span class="s2">, </span><span class="s1">engine_kwargs)</span>
        <span class="s1">window_func = window_aggregations.roll_sum</span>
        <span class="s2">return </span><span class="s1">self._apply(window_func</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;sum&quot;</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">max(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">*args</span><span class="s2">,</span>
        <span class="s1">engine: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s2">, </span><span class="s1">bool] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_window_func(</span><span class="s5">&quot;max&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>
        <span class="s2">if </span><span class="s1">maybe_use_numba(engine):</span>
            <span class="s2">if </span><span class="s1">self.method == </span><span class="s5">&quot;table&quot;</span><span class="s1">:</span>
                <span class="s1">func = generate_manual_numpy_nan_agg_with_axis(np.nanmax)</span>
                <span class="s2">return </span><span class="s1">self.apply(</span>
                    <span class="s1">func</span><span class="s2">,</span>
                    <span class="s1">raw=</span><span class="s2">True,</span>
                    <span class="s1">engine=engine</span><span class="s2">,</span>
                    <span class="s1">engine_kwargs=engine_kwargs</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">from </span><span class="s1">pandas.core._numba.kernels </span><span class="s2">import </span><span class="s1">sliding_min_max</span>

                <span class="s2">return </span><span class="s1">self._numba_apply(</span>
                    <span class="s1">sliding_min_max</span><span class="s2">, </span><span class="s5">&quot;rolling_max&quot;</span><span class="s2">, </span><span class="s1">engine_kwargs</span><span class="s2">, True</span>
                <span class="s1">)</span>
        <span class="s1">window_func = window_aggregations.roll_max</span>
        <span class="s2">return </span><span class="s1">self._apply(window_func</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;max&quot;</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">min(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">*args</span><span class="s2">,</span>
        <span class="s1">engine: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s2">, </span><span class="s1">bool] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_window_func(</span><span class="s5">&quot;min&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>
        <span class="s2">if </span><span class="s1">maybe_use_numba(engine):</span>
            <span class="s2">if </span><span class="s1">self.method == </span><span class="s5">&quot;table&quot;</span><span class="s1">:</span>
                <span class="s1">func = generate_manual_numpy_nan_agg_with_axis(np.nanmin)</span>
                <span class="s2">return </span><span class="s1">self.apply(</span>
                    <span class="s1">func</span><span class="s2">,</span>
                    <span class="s1">raw=</span><span class="s2">True,</span>
                    <span class="s1">engine=engine</span><span class="s2">,</span>
                    <span class="s1">engine_kwargs=engine_kwargs</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">from </span><span class="s1">pandas.core._numba.kernels </span><span class="s2">import </span><span class="s1">sliding_min_max</span>

                <span class="s2">return </span><span class="s1">self._numba_apply(</span>
                    <span class="s1">sliding_min_max</span><span class="s2">, </span><span class="s5">&quot;rolling_min&quot;</span><span class="s2">, </span><span class="s1">engine_kwargs</span><span class="s2">, False</span>
                <span class="s1">)</span>
        <span class="s1">window_func = window_aggregations.roll_min</span>
        <span class="s2">return </span><span class="s1">self._apply(window_func</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;min&quot;</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">mean(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">*args</span><span class="s2">,</span>
        <span class="s1">engine: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s2">, </span><span class="s1">bool] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_window_func(</span><span class="s5">&quot;mean&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>
        <span class="s2">if </span><span class="s1">maybe_use_numba(engine):</span>
            <span class="s2">if </span><span class="s1">self.method == </span><span class="s5">&quot;table&quot;</span><span class="s1">:</span>
                <span class="s1">func = generate_manual_numpy_nan_agg_with_axis(np.nanmean)</span>
                <span class="s2">return </span><span class="s1">self.apply(</span>
                    <span class="s1">func</span><span class="s2">,</span>
                    <span class="s1">raw=</span><span class="s2">True,</span>
                    <span class="s1">engine=engine</span><span class="s2">,</span>
                    <span class="s1">engine_kwargs=engine_kwargs</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">from </span><span class="s1">pandas.core._numba.kernels </span><span class="s2">import </span><span class="s1">sliding_mean</span>

                <span class="s2">return </span><span class="s1">self._numba_apply(sliding_mean</span><span class="s2">, </span><span class="s5">&quot;rolling_mean&quot;</span><span class="s2">, </span><span class="s1">engine_kwargs)</span>
        <span class="s1">window_func = window_aggregations.roll_mean</span>
        <span class="s2">return </span><span class="s1">self._apply(window_func</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;mean&quot;</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">median(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">engine: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s2">, </span><span class="s1">bool] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s2">if </span><span class="s1">maybe_use_numba(engine):</span>
            <span class="s2">if </span><span class="s1">self.method == </span><span class="s5">&quot;table&quot;</span><span class="s1">:</span>
                <span class="s1">func = generate_manual_numpy_nan_agg_with_axis(np.nanmedian)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">func = np.nanmedian</span>

            <span class="s2">return </span><span class="s1">self.apply(</span>
                <span class="s1">func</span><span class="s2">,</span>
                <span class="s1">raw=</span><span class="s2">True,</span>
                <span class="s1">engine=engine</span><span class="s2">,</span>
                <span class="s1">engine_kwargs=engine_kwargs</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">window_func = window_aggregations.roll_median_c</span>
        <span class="s2">return </span><span class="s1">self._apply(window_func</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;median&quot;</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">std(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">ddof: int = </span><span class="s4">1</span><span class="s2">,</span>
        <span class="s1">*args</span><span class="s2">,</span>
        <span class="s1">engine: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s2">, </span><span class="s1">bool] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_window_func(</span><span class="s5">&quot;std&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>
        <span class="s2">if </span><span class="s1">maybe_use_numba(engine):</span>
            <span class="s2">if </span><span class="s1">self.method == </span><span class="s5">&quot;table&quot;</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s5">&quot;std not supported with method='table'&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">from </span><span class="s1">pandas.core._numba.kernels </span><span class="s2">import </span><span class="s1">sliding_var</span>

                <span class="s2">return </span><span class="s1">zsqrt(</span>
                    <span class="s1">self._numba_apply(sliding_var</span><span class="s2">, </span><span class="s5">&quot;rolling_std&quot;</span><span class="s2">, </span><span class="s1">engine_kwargs</span><span class="s2">, </span><span class="s1">ddof)</span>
                <span class="s1">)</span>
        <span class="s1">window_func = window_aggregations.roll_var</span>

        <span class="s2">def </span><span class="s1">zsqrt_func(values</span><span class="s2">, </span><span class="s1">begin</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">min_periods):</span>
            <span class="s2">return </span><span class="s1">zsqrt(window_func(values</span><span class="s2">, </span><span class="s1">begin</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">min_periods</span><span class="s2">, </span><span class="s1">ddof=ddof))</span>

        <span class="s2">return </span><span class="s1">self._apply(</span>
            <span class="s1">zsqrt_func</span><span class="s2">,</span>
            <span class="s1">name=</span><span class="s5">&quot;std&quot;</span><span class="s2">,</span>
            <span class="s1">**kwargs</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">var(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">ddof: int = </span><span class="s4">1</span><span class="s2">,</span>
        <span class="s1">*args</span><span class="s2">,</span>
        <span class="s1">engine: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s2">, </span><span class="s1">bool] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_window_func(</span><span class="s5">&quot;var&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>
        <span class="s2">if </span><span class="s1">maybe_use_numba(engine):</span>
            <span class="s2">if </span><span class="s1">self.method == </span><span class="s5">&quot;table&quot;</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s5">&quot;var not supported with method='table'&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">from </span><span class="s1">pandas.core._numba.kernels </span><span class="s2">import </span><span class="s1">sliding_var</span>

                <span class="s2">return </span><span class="s1">self._numba_apply(</span>
                    <span class="s1">sliding_var</span><span class="s2">, </span><span class="s5">&quot;rolling_var&quot;</span><span class="s2">, </span><span class="s1">engine_kwargs</span><span class="s2">, </span><span class="s1">ddof</span>
                <span class="s1">)</span>
        <span class="s1">window_func = partial(window_aggregations.roll_var</span><span class="s2">, </span><span class="s1">ddof=ddof)</span>
        <span class="s2">return </span><span class="s1">self._apply(</span>
            <span class="s1">window_func</span><span class="s2">,</span>
            <span class="s1">name=</span><span class="s5">&quot;var&quot;</span><span class="s2">,</span>
            <span class="s1">**kwargs</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">skew(self</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">window_func = window_aggregations.roll_skew</span>
        <span class="s2">return </span><span class="s1">self._apply(</span>
            <span class="s1">window_func</span><span class="s2">,</span>
            <span class="s1">name=</span><span class="s5">&quot;skew&quot;</span><span class="s2">,</span>
            <span class="s1">**kwargs</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">sem(self</span><span class="s2">, </span><span class="s1">ddof: int = </span><span class="s4">1</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">self.std(*args</span><span class="s2">, </span><span class="s1">**kwargs) / (self.count() - ddof).pow(</span><span class="s4">0.5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">kurt(self</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">window_func = window_aggregations.roll_kurt</span>
        <span class="s2">return </span><span class="s1">self._apply(</span>
            <span class="s1">window_func</span><span class="s2">,</span>
            <span class="s1">name=</span><span class="s5">&quot;kurt&quot;</span><span class="s2">,</span>
            <span class="s1">**kwargs</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">quantile(self</span><span class="s2">, </span><span class="s1">quantile: float</span><span class="s2">, </span><span class="s1">interpolation: str = </span><span class="s5">&quot;linear&quot;</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">if </span><span class="s1">quantile == </span><span class="s4">1.0</span><span class="s1">:</span>
            <span class="s1">window_func = window_aggregations.roll_max</span>
        <span class="s2">elif </span><span class="s1">quantile == </span><span class="s4">0.0</span><span class="s1">:</span>
            <span class="s1">window_func = window_aggregations.roll_min</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">window_func = partial(</span>
                <span class="s1">window_aggregations.roll_quantile</span><span class="s2">,</span>
                <span class="s1">quantile=quantile</span><span class="s2">,</span>
                <span class="s1">interpolation=interpolation</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">self._apply(window_func</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;quantile&quot;</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">rank(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">method: WindowingRankType = </span><span class="s5">&quot;average&quot;</span><span class="s2">,</span>
        <span class="s1">ascending: bool = </span><span class="s2">True,</span>
        <span class="s1">pct: bool = </span><span class="s2">False,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">window_func = partial(</span>
            <span class="s1">window_aggregations.roll_rank</span><span class="s2">,</span>
            <span class="s1">method=method</span><span class="s2">,</span>
            <span class="s1">ascending=ascending</span><span class="s2">,</span>
            <span class="s1">percentile=pct</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">self._apply(window_func</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;rank&quot;</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">cov(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">other: DataFrame | Series | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">pairwise: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">ddof: int = </span><span class="s4">1</span><span class="s2">,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">Series</span>

        <span class="s2">def </span><span class="s1">cov_func(x</span><span class="s2">, </span><span class="s1">y):</span>
            <span class="s1">x_array = self._prep_values(x)</span>
            <span class="s1">y_array = self._prep_values(y)</span>
            <span class="s1">window_indexer = self._get_window_indexer()</span>
            <span class="s1">min_periods = (</span>
                <span class="s1">self.min_periods</span>
                <span class="s2">if </span><span class="s1">self.min_periods </span><span class="s2">is not None</span>
                <span class="s2">else </span><span class="s1">window_indexer.window_size</span>
            <span class="s1">)</span>
            <span class="s1">start</span><span class="s2">, </span><span class="s1">end = window_indexer.get_window_bounds(</span>
                <span class="s1">num_values=len(x_array)</span><span class="s2">,</span>
                <span class="s1">min_periods=min_periods</span><span class="s2">,</span>
                <span class="s1">center=self.center</span><span class="s2">,</span>
                <span class="s1">closed=self.closed</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">self._check_window_bounds(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">len(x_array))</span>

            <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
                <span class="s1">mean_x_y = window_aggregations.roll_mean(</span>
                    <span class="s1">x_array * y_array</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">min_periods</span>
                <span class="s1">)</span>
                <span class="s1">mean_x = window_aggregations.roll_mean(x_array</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">min_periods)</span>
                <span class="s1">mean_y = window_aggregations.roll_mean(y_array</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">min_periods)</span>
                <span class="s1">count_x_y = window_aggregations.roll_sum(</span>
                    <span class="s1">notna(x_array + y_array).astype(np.float64)</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s4">0</span>
                <span class="s1">)</span>
                <span class="s1">result = (mean_x_y - mean_x * mean_y) * (count_x_y / (count_x_y - ddof))</span>
            <span class="s2">return </span><span class="s1">Series(result</span><span class="s2">, </span><span class="s1">index=x.index</span><span class="s2">, </span><span class="s1">name=x.name)</span>

        <span class="s2">return </span><span class="s1">self._apply_pairwise(self._selected_obj</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">pairwise</span><span class="s2">, </span><span class="s1">cov_func)</span>

    <span class="s2">def </span><span class="s1">corr(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">other: DataFrame | Series | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">pairwise: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">ddof: int = </span><span class="s4">1</span><span class="s2">,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>

        <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">Series</span>

        <span class="s2">def </span><span class="s1">corr_func(x</span><span class="s2">, </span><span class="s1">y):</span>
            <span class="s1">x_array = self._prep_values(x)</span>
            <span class="s1">y_array = self._prep_values(y)</span>
            <span class="s1">window_indexer = self._get_window_indexer()</span>
            <span class="s1">min_periods = (</span>
                <span class="s1">self.min_periods</span>
                <span class="s2">if </span><span class="s1">self.min_periods </span><span class="s2">is not None</span>
                <span class="s2">else </span><span class="s1">window_indexer.window_size</span>
            <span class="s1">)</span>
            <span class="s1">start</span><span class="s2">, </span><span class="s1">end = window_indexer.get_window_bounds(</span>
                <span class="s1">num_values=len(x_array)</span><span class="s2">,</span>
                <span class="s1">min_periods=min_periods</span><span class="s2">,</span>
                <span class="s1">center=self.center</span><span class="s2">,</span>
                <span class="s1">closed=self.closed</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">self._check_window_bounds(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">len(x_array))</span>

            <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
                <span class="s1">mean_x_y = window_aggregations.roll_mean(</span>
                    <span class="s1">x_array * y_array</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">min_periods</span>
                <span class="s1">)</span>
                <span class="s1">mean_x = window_aggregations.roll_mean(x_array</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">min_periods)</span>
                <span class="s1">mean_y = window_aggregations.roll_mean(y_array</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">min_periods)</span>
                <span class="s1">count_x_y = window_aggregations.roll_sum(</span>
                    <span class="s1">notna(x_array + y_array).astype(np.float64)</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s4">0</span>
                <span class="s1">)</span>
                <span class="s1">x_var = window_aggregations.roll_var(</span>
                    <span class="s1">x_array</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">min_periods</span><span class="s2">, </span><span class="s1">ddof</span>
                <span class="s1">)</span>
                <span class="s1">y_var = window_aggregations.roll_var(</span>
                    <span class="s1">y_array</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">min_periods</span><span class="s2">, </span><span class="s1">ddof</span>
                <span class="s1">)</span>
                <span class="s1">numerator = (mean_x_y - mean_x * mean_y) * (</span>
                    <span class="s1">count_x_y / (count_x_y - ddof)</span>
                <span class="s1">)</span>
                <span class="s1">denominator = (x_var * y_var) ** </span><span class="s4">0.5</span>
                <span class="s1">result = numerator / denominator</span>
            <span class="s2">return </span><span class="s1">Series(result</span><span class="s2">, </span><span class="s1">index=x.index</span><span class="s2">, </span><span class="s1">name=x.name)</span>

        <span class="s2">return </span><span class="s1">self._apply_pairwise(self._selected_obj</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">pairwise</span><span class="s2">, </span><span class="s1">corr_func)</span>


<span class="s2">class </span><span class="s1">Rolling(RollingAndExpandingMixin):</span>

    <span class="s1">_attributes: list[str] = [</span>
        <span class="s5">&quot;window&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;min_periods&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;center&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;win_type&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;axis&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;on&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;closed&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;method&quot;</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s2">def </span><span class="s1">_validate(self):</span>
        <span class="s1">super()._validate()</span>

        <span class="s3"># we allow rolling on a datetimelike index</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">self.obj.empty</span>
            <span class="s2">or </span><span class="s1">isinstance(self._on</span><span class="s2">, </span><span class="s1">(DatetimeIndex</span><span class="s2">, </span><span class="s1">TimedeltaIndex</span><span class="s2">, </span><span class="s1">PeriodIndex))</span>
        <span class="s1">) </span><span class="s2">and </span><span class="s1">isinstance(self.window</span><span class="s2">, </span><span class="s1">(str</span><span class="s2">, </span><span class="s1">BaseOffset</span><span class="s2">, </span><span class="s1">timedelta)):</span>

            <span class="s1">self._validate_monotonic()</span>

            <span class="s3"># this will raise ValueError on non-fixed freqs</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">freq = to_offset(self.window)</span>
            <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError) </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s5">f&quot;passed window </span><span class="s2">{</span><span class="s1">self.window</span><span class="s2">} </span><span class="s5">is not &quot;</span>
                    <span class="s5">&quot;compatible with a datetimelike index&quot;</span>
                <span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>
            <span class="s2">if </span><span class="s1">isinstance(self._on</span><span class="s2">, </span><span class="s1">PeriodIndex):</span>
                <span class="s1">self._win_freq_i8 = freq.nanos / (self._on.freq.nanos / self._on.freq.n)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._win_freq_i8 = freq.nanos</span>

            <span class="s3"># min_periods must be an integer</span>
            <span class="s2">if </span><span class="s1">self.min_periods </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self.min_periods = </span><span class="s4">1</span>

        <span class="s2">elif </span><span class="s1">isinstance(self.window</span><span class="s2">, </span><span class="s1">BaseIndexer):</span>
            <span class="s3"># Passed BaseIndexer subclass should handle all other rolling kwargs</span>
            <span class="s2">return</span>
        <span class="s2">elif not </span><span class="s1">is_integer(self.window) </span><span class="s2">or </span><span class="s1">self.window &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;window must be an integer 0 or greater&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_validate_monotonic(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Validate monotonic (increasing or decreasing). 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">(self._on.is_monotonic_increasing </span><span class="s2">or </span><span class="s1">self._on.is_monotonic_decreasing):</span>
            <span class="s1">self._raise_monotonic_error()</span>

    <span class="s2">def </span><span class="s1">_raise_monotonic_error(self):</span>
        <span class="s1">formatted = self.on</span>
        <span class="s2">if </span><span class="s1">self.on </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">formatted = </span><span class="s5">&quot;index&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">formatted</span><span class="s2">} </span><span class="s5">must be monotonic&quot;</span><span class="s1">)</span>

    <span class="s1">@doc(</span>
        <span class="s1">_shared_docs[</span><span class="s5">&quot;aggregate&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">see_also=dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        See Also 
        -------- 
        pandas.Series.rolling : Calling object with Series data. 
        pandas.DataFrame.rolling : Calling object with DataFrame data. 
        &quot;&quot;&quot;</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">examples=dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        Examples 
        -------- 
        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, 2, 3], &quot;B&quot;: [4, 5, 6], &quot;C&quot;: [7, 8, 9]}) 
        &gt;&gt;&gt; df 
           A  B  C 
        0  1  4  7 
        1  2  5  8 
        2  3  6  9 
 
        &gt;&gt;&gt; df.rolling(2).sum() 
             A     B     C 
        0  NaN   NaN   NaN 
        1  3.0   9.0  15.0 
        2  5.0  11.0  17.0 
 
        &gt;&gt;&gt; df.rolling(2).agg({&quot;A&quot;: &quot;sum&quot;, &quot;B&quot;: &quot;min&quot;}) 
             A    B 
        0  NaN  NaN 
        1  3.0  4.0 
        2  5.0  5.0 
        &quot;&quot;&quot;</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">klass=</span><span class="s5">&quot;Series/Dataframe&quot;</span><span class="s2">,</span>
        <span class="s1">axis=</span><span class="s5">&quot;&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">aggregate(self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">super().aggregate(func</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s1">agg = aggregate</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_see_also</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Examples&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        &gt;&gt;&gt; s = pd.Series([2, 3, np.nan, 10]) 
        &gt;&gt;&gt; s.rolling(2).count() 
        0    1.0 
        1    2.0 
        2    1.0 
        3    1.0 
        dtype: float64 
        &gt;&gt;&gt; s.rolling(3).count() 
        0    1.0 
        1    2.0 
        2    2.0 
        3    2.0 
        dtype: float64 
        &gt;&gt;&gt; s.rolling(4).count() 
        0    1.0 
        1    2.0 
        2    2.0 
        3    3.0 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;count of non NaN observations&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;count&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">count(self):</span>
        <span class="s2">if </span><span class="s1">self.min_periods </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s1">(</span>
                    <span class="s5">&quot;min_periods=None will default to the size of window &quot;</span>
                    <span class="s5">&quot;consistent with other methods in a future version. &quot;</span>
                    <span class="s5">&quot;Specify min_periods=0 instead.&quot;</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">FutureWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">self.min_periods = </span><span class="s4">0</span>
            <span class="s1">result = super().count()</span>
            <span class="s1">self.min_periods = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">result = super().count()</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">window_apply_parameters</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_see_also[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;custom aggregation function&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;apply&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">apply(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">func: Callable[...</span><span class="s2">, </span><span class="s1">Any]</span><span class="s2">,</span>
        <span class="s1">raw: bool = </span><span class="s2">False,</span>
        <span class="s1">engine: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s2">, </span><span class="s1">bool] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">args: tuple[Any</span><span class="s2">, </span><span class="s1">...] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">kwargs: dict[str</span><span class="s2">, </span><span class="s1">Any] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s2">return </span><span class="s1">super().apply(</span>
            <span class="s1">func</span><span class="s2">,</span>
            <span class="s1">raw=raw</span><span class="s2">,</span>
            <span class="s1">engine=engine</span><span class="s2">,</span>
            <span class="s1">engine_kwargs=engine_kwargs</span><span class="s2">,</span>
            <span class="s1">args=args</span><span class="s2">,</span>
            <span class="s1">kwargs=kwargs</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">args_compat</span><span class="s2">,</span>
        <span class="s1">window_agg_numba_parameters()</span><span class="s2">,</span>
        <span class="s1">kwargs_compat</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_see_also</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Notes&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">numba_notes</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Examples&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4, 5]) 
        &gt;&gt;&gt; s 
        0    1 
        1    2 
        2    3 
        3    4 
        4    5 
        dtype: int64 
 
        &gt;&gt;&gt; s.rolling(3).sum() 
        0     NaN 
        1     NaN 
        2     6.0 
        3     9.0 
        4    12.0 
        dtype: float64 
 
        &gt;&gt;&gt; s.rolling(3, center=True).sum() 
        0     NaN 
        1     6.0 
        2     9.0 
        3    12.0 
        4     NaN 
        dtype: float64 
 
        For DataFrame, each sum is computed column-wise. 
 
        &gt;&gt;&gt; df = pd.DataFrame({{&quot;A&quot;: s, &quot;B&quot;: s ** 2}}) 
        &gt;&gt;&gt; df 
           A   B 
        0  1   1 
        1  2   4 
        2  3   9 
        3  4  16 
        4  5  25 
 
        &gt;&gt;&gt; df.rolling(3).sum() 
              A     B 
        0   NaN   NaN 
        1   NaN   NaN 
        2   6.0  14.0 
        3   9.0  29.0 
        4  12.0  50.0 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;sum&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;sum&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">sum(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">*args</span><span class="s2">,</span>
        <span class="s1">engine: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s2">, </span><span class="s1">bool] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_rolling_func(</span><span class="s5">&quot;sum&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>
        <span class="s2">return </span><span class="s1">super().sum(*args</span><span class="s2">, </span><span class="s1">engine=engine</span><span class="s2">, </span><span class="s1">engine_kwargs=engine_kwargs</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">args_compat</span><span class="s2">,</span>
        <span class="s1">window_agg_numba_parameters()</span><span class="s2">,</span>
        <span class="s1">kwargs_compat</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_see_also</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Notes&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">numba_notes[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;maximum&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;max&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">max(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">*args</span><span class="s2">,</span>
        <span class="s1">engine: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s2">, </span><span class="s1">bool] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_rolling_func(</span><span class="s5">&quot;max&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>
        <span class="s2">return </span><span class="s1">super().max(*args</span><span class="s2">, </span><span class="s1">engine=engine</span><span class="s2">, </span><span class="s1">engine_kwargs=engine_kwargs</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">args_compat</span><span class="s2">,</span>
        <span class="s1">window_agg_numba_parameters()</span><span class="s2">,</span>
        <span class="s1">kwargs_compat</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_see_also</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Notes&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">numba_notes</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Examples&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        Performing a rolling minimum with a window size of 3. 
 
        &gt;&gt;&gt; s = pd.Series([4, 3, 5, 2, 6]) 
        &gt;&gt;&gt; s.rolling(3).min() 
        0    NaN 
        1    NaN 
        2    3.0 
        3    2.0 
        4    2.0 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;minimum&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;min&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">min(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">*args</span><span class="s2">,</span>
        <span class="s1">engine: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s2">, </span><span class="s1">bool] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_rolling_func(</span><span class="s5">&quot;min&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>
        <span class="s2">return </span><span class="s1">super().min(*args</span><span class="s2">, </span><span class="s1">engine=engine</span><span class="s2">, </span><span class="s1">engine_kwargs=engine_kwargs</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">args_compat</span><span class="s2">,</span>
        <span class="s1">window_agg_numba_parameters()</span><span class="s2">,</span>
        <span class="s1">kwargs_compat</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_see_also</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Notes&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">numba_notes</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Examples&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        The below examples will show rolling mean calculations with window sizes of 
        two and three, respectively. 
 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4]) 
        &gt;&gt;&gt; s.rolling(2).mean() 
        0    NaN 
        1    1.5 
        2    2.5 
        3    3.5 
        dtype: float64 
 
        &gt;&gt;&gt; s.rolling(3).mean() 
        0    NaN 
        1    NaN 
        2    2.0 
        3    3.0 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;mean&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;mean&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">mean(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">*args</span><span class="s2">,</span>
        <span class="s1">engine: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s2">, </span><span class="s1">bool] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_rolling_func(</span><span class="s5">&quot;mean&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>
        <span class="s2">return </span><span class="s1">super().mean(*args</span><span class="s2">, </span><span class="s1">engine=engine</span><span class="s2">, </span><span class="s1">engine_kwargs=engine_kwargs</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">window_agg_numba_parameters()</span><span class="s2">,</span>
        <span class="s1">kwargs_compat</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_see_also</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Notes&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">numba_notes</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Examples&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        Compute the rolling median of a series with a window size of 3. 
 
        &gt;&gt;&gt; s = pd.Series([0, 1, 2, 3, 4]) 
        &gt;&gt;&gt; s.rolling(3).median() 
        0    NaN 
        1    NaN 
        2    1.0 
        3    2.0 
        4    3.0 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;median&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;median&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">median(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">engine: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s2">, </span><span class="s1">bool] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s2">return </span><span class="s1">super().median(engine=engine</span><span class="s2">, </span><span class="s1">engine_kwargs=engine_kwargs</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        ddof : int, default 1 
            Delta Degrees of Freedom.  The divisor used in calculations 
            is ``N - ddof``, where ``N`` represents the number of elements. 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">args_compat</span><span class="s2">,</span>
        <span class="s1">window_agg_numba_parameters(</span><span class="s5">&quot;1.4&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">kwargs_compat</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s5">&quot;numpy.std : Equivalent method for NumPy array.</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">,</span>
        <span class="s1">template_see_also</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Notes&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        The default ``ddof`` of 1 used in :meth:`Series.std` is different 
        than the default ``ddof`` of 0 in :func:`numpy.std`. 
 
        A minimum of one period is required for the rolling calculation. 
 
        The implementation is susceptible to floating point imprecision as 
        shown in the example below.</span><span class="s2">\n</span>
        <span class="s5">&quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Examples&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        &gt;&gt;&gt; s = pd.Series([5, 5, 6, 7, 5, 5, 5]) 
        &gt;&gt;&gt; s.rolling(3).std() 
        0             NaN 
        1             NaN 
        2    5.773503e-01 
        3    1.000000e+00 
        4    1.000000e+00 
        5    1.154701e+00 
        6    2.580957e-08 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;standard deviation&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;std&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">std(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">ddof: int = </span><span class="s4">1</span><span class="s2">,</span>
        <span class="s1">*args</span><span class="s2">,</span>
        <span class="s1">engine: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s2">, </span><span class="s1">bool] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_rolling_func(</span><span class="s5">&quot;std&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>
        <span class="s2">return </span><span class="s1">super().std(</span>
            <span class="s1">ddof=ddof</span><span class="s2">, </span><span class="s1">engine=engine</span><span class="s2">, </span><span class="s1">engine_kwargs=engine_kwargs</span><span class="s2">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        ddof : int, default 1 
            Delta Degrees of Freedom.  The divisor used in calculations 
            is ``N - ddof``, where ``N`` represents the number of elements. 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">args_compat</span><span class="s2">,</span>
        <span class="s1">window_agg_numba_parameters(</span><span class="s5">&quot;1.4&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">kwargs_compat</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s5">&quot;numpy.var : Equivalent method for NumPy array.</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">,</span>
        <span class="s1">template_see_also</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Notes&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        The default ``ddof`` of 1 used in :meth:`Series.var` is different 
        than the default ``ddof`` of 0 in :func:`numpy.var`. 
 
        A minimum of one period is required for the rolling calculation. 
 
        The implementation is susceptible to floating point imprecision as 
        shown in the example below.</span><span class="s2">\n</span>
        <span class="s5">&quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Examples&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        &gt;&gt;&gt; s = pd.Series([5, 5, 6, 7, 5, 5, 5]) 
        &gt;&gt;&gt; s.rolling(3).var() 
        0             NaN 
        1             NaN 
        2    3.333333e-01 
        3    1.000000e+00 
        4    1.000000e+00 
        5    1.333333e+00 
        6    6.661338e-16 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;variance&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;var&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">var(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">ddof: int = </span><span class="s4">1</span><span class="s2">,</span>
        <span class="s1">*args</span><span class="s2">,</span>
        <span class="s1">engine: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">engine_kwargs: dict[str</span><span class="s2">, </span><span class="s1">bool] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_rolling_func(</span><span class="s5">&quot;var&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>
        <span class="s2">return </span><span class="s1">super().var(</span>
            <span class="s1">ddof=ddof</span><span class="s2">, </span><span class="s1">engine=engine</span><span class="s2">, </span><span class="s1">engine_kwargs=engine_kwargs</span><span class="s2">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">kwargs_compat</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s5">&quot;scipy.stats.skew : Third moment of a probability density.</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">,</span>
        <span class="s1">template_see_also</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Notes&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s5">&quot;A minimum of three periods is required for the rolling calculation.</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;unbiased skewness&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;skew&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">skew(self</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">super().skew(**kwargs)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        ddof : int, default 1 
            Delta Degrees of Freedom.  The divisor used in calculations 
            is ``N - ddof``, where ``N`` represents the number of elements. 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">args_compat</span><span class="s2">,</span>
        <span class="s1">kwargs_compat</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_see_also</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Notes&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s5">&quot;A minimum of one period is required for the calculation.</span><span class="s2">\n\n</span><span class="s5">&quot;</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Examples&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        &gt;&gt;&gt; s = pd.Series([0, 1, 2, 3]) 
        &gt;&gt;&gt; s.rolling(2, min_periods=1).sem() 
        0         NaN 
        1    0.707107 
        2    0.707107 
        3    0.707107 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;standard error of mean&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;sem&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">sem(self</span><span class="s2">, </span><span class="s1">ddof: int = </span><span class="s4">1</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">self.std(*args</span><span class="s2">, </span><span class="s1">**kwargs) / (self.count() - ddof).pow(</span><span class="s4">0.5</span><span class="s1">)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">kwargs_compat</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s5">&quot;scipy.stats.kurtosis : Reference SciPy method.</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">,</span>
        <span class="s1">template_see_also</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Notes&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s5">&quot;A minimum of four periods is required for the calculation.</span><span class="s2">\n\n</span><span class="s5">&quot;</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Examples&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        The example below will show a rolling calculation with a window size of 
        four matching the equivalent function call using `scipy.stats`. 
 
        &gt;&gt;&gt; arr = [1, 2, 3, 4, 999] 
        &gt;&gt;&gt; import scipy.stats 
        &gt;&gt;&gt; print(f&quot;{{scipy.stats.kurtosis(arr[:-1], bias=False):.6f}}&quot;) 
        -1.200000 
        &gt;&gt;&gt; print(f&quot;{{scipy.stats.kurtosis(arr[1:], bias=False):.6f}}&quot;) 
        3.999946 
        &gt;&gt;&gt; s = pd.Series(arr) 
        &gt;&gt;&gt; s.rolling(4).kurt() 
        0         NaN 
        1         NaN 
        2         NaN 
        3   -1.200000 
        4    3.999946 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;Fisher's definition of kurtosis without bias&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;kurt&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">kurt(self</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">super().kurt(**kwargs)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        quantile : float 
            Quantile to compute. 0 &lt;= quantile &lt;= 1. 
        interpolation : {{'linear', 'lower', 'higher', 'midpoint', 'nearest'}} 
            This optional parameter specifies the interpolation method to use, 
            when the desired quantile lies between two data points `i` and `j`: 
 
                * linear: `i + (j - i) * fraction`, where `fraction` is the 
                  fractional part of the index surrounded by `i` and `j`. 
                * lower: `i`. 
                * higher: `j`. 
                * nearest: `i` or `j` whichever is nearest. 
                * midpoint: (`i` + `j`) / 2. 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">kwargs_compat</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_see_also</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Examples&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4]) 
        &gt;&gt;&gt; s.rolling(2).quantile(.4, interpolation='lower') 
        0    NaN 
        1    1.0 
        2    2.0 
        3    3.0 
        dtype: float64 
 
        &gt;&gt;&gt; s.rolling(2).quantile(.4, interpolation='midpoint') 
        0    NaN 
        1    1.5 
        2    2.5 
        3    3.5 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;quantile&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;quantile&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">quantile(self</span><span class="s2">, </span><span class="s1">quantile: float</span><span class="s2">, </span><span class="s1">interpolation: str = </span><span class="s5">&quot;linear&quot;</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">super().quantile(</span>
            <span class="s1">quantile=quantile</span><span class="s2">,</span>
            <span class="s1">interpolation=interpolation</span><span class="s2">,</span>
            <span class="s1">**kwargs</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s5">&quot;.. versionadded:: 1.4.0 </span><span class="s2">\n\n</span><span class="s5">&quot;</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        method : {{'average', 'min', 'max'}}, default 'average' 
            How to rank the group of records that have the same value (i.e. ties): 
 
            * average: average rank of the group 
            * min: lowest rank in the group 
            * max: highest rank in the group 
 
        ascending : bool, default True 
            Whether or not the elements should be ranked in ascending order. 
        pct : bool, default False 
            Whether or not to display the returned rankings in percentile 
            form. 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">kwargs_compat</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_see_also</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Examples&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        &gt;&gt;&gt; s = pd.Series([1, 4, 2, 3, 5, 3]) 
        &gt;&gt;&gt; s.rolling(3).rank() 
        0    NaN 
        1    NaN 
        2    2.0 
        3    2.0 
        4    3.0 
        5    1.5 
        dtype: float64 
 
        &gt;&gt;&gt; s.rolling(3).rank(method=&quot;max&quot;) 
        0    NaN 
        1    NaN 
        2    2.0 
        3    2.0 
        4    3.0 
        5    2.0 
        dtype: float64 
 
        &gt;&gt;&gt; s.rolling(3).rank(method=&quot;min&quot;) 
        0    NaN 
        1    NaN 
        2    2.0 
        3    2.0 
        4    3.0 
        5    1.0 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;rank&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;rank&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">rank(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">method: WindowingRankType = </span><span class="s5">&quot;average&quot;</span><span class="s2">,</span>
        <span class="s1">ascending: bool = </span><span class="s2">True,</span>
        <span class="s1">pct: bool = </span><span class="s2">False,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s2">return </span><span class="s1">super().rank(</span>
            <span class="s1">method=method</span><span class="s2">,</span>
            <span class="s1">ascending=ascending</span><span class="s2">,</span>
            <span class="s1">pct=pct</span><span class="s2">,</span>
            <span class="s1">**kwargs</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        other : Series or DataFrame, optional 
            If not supplied then will default to self and produce pairwise 
            output. 
        pairwise : bool, default None 
            If False then only matching columns between self and other will be 
            used and the output will be a DataFrame. 
            If True then all pairwise combinations will be calculated and the 
            output will be a MultiIndexed DataFrame in the case of DataFrame 
            inputs. In the case of missing elements, only complete pairwise 
            observations will be used. 
        ddof : int, default 1 
            Delta Degrees of Freedom.  The divisor used in calculations 
            is ``N - ddof``, where ``N`` represents the number of elements. 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">kwargs_compat</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_see_also[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;sample covariance&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;cov&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">cov(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">other: DataFrame | Series | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">pairwise: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">ddof: int = </span><span class="s4">1</span><span class="s2">,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s2">return </span><span class="s1">super().cov(other=other</span><span class="s2">, </span><span class="s1">pairwise=pairwise</span><span class="s2">, </span><span class="s1">ddof=ddof</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@doc(</span>
        <span class="s1">template_header</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Parameters&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        other : Series or DataFrame, optional 
            If not supplied then will default to self and produce pairwise 
            output. 
        pairwise : bool, default None 
            If False then only matching columns between self and other will be 
            used and the output will be a DataFrame. 
            If True then all pairwise combinations will be calculated and the 
            output will be a MultiIndexed DataFrame in the case of DataFrame 
            inputs. In the case of missing elements, only complete pairwise 
            observations will be used. 
        ddof : int, default 1 
            Delta Degrees of Freedom.  The divisor used in calculations 
            is ``N - ddof``, where ``N`` represents the number of elements. 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">kwargs_compat</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Returns&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_returns</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;See Also&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        cov : Similar method to calculate covariance. 
        numpy.corrcoef : NumPy Pearson's correlation calculation. 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">template_see_also</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Notes&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        This function uses Pearson's definition of correlation 
        (https://en.wikipedia.org/wiki/Pearson_correlation_coefficient). 
 
        When `other` is not specified, the output will be self correlation (e.g. 
        all 1's), except for :class:`~pandas.DataFrame` inputs with `pairwise` 
        set to `True`. 
 
        Function will return ``NaN`` for correlations of equal valued sequences; 
        this is the result of a 0/0 division error. 
 
        When `pairwise` is set to `False`, only matching columns between `self` and 
        `other` will be used. 
 
        When `pairwise` is set to `True`, the output will be a MultiIndex DataFrame 
        with the original index on the first level, and the `other` DataFrame 
        columns on the second level. 
 
        In the case of missing elements, only complete pairwise observations 
        will be used.</span><span class="s2">\n</span>
        <span class="s5">&quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">create_section_header(</span><span class="s5">&quot;Examples&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dedent(</span>
            <span class="s5">&quot;&quot;&quot; 
        The below example shows a rolling calculation with a window size of 
        four matching the equivalent function call using :meth:`numpy.corrcoef`. 
 
        &gt;&gt;&gt; v1 = [3, 3, 3, 5, 8] 
        &gt;&gt;&gt; v2 = [3, 4, 4, 4, 8] 
        &gt;&gt;&gt; # numpy returns a 2X2 array, the correlation coefficient 
        &gt;&gt;&gt; # is the number at entry [0][1] 
        &gt;&gt;&gt; print(f&quot;{{np.corrcoef(v1[:-1], v2[:-1])[0][1]:.6f}}&quot;) 
        0.333333 
        &gt;&gt;&gt; print(f&quot;{{np.corrcoef(v1[1:], v2[1:])[0][1]:.6f}}&quot;) 
        0.916949 
        &gt;&gt;&gt; s1 = pd.Series(v1) 
        &gt;&gt;&gt; s2 = pd.Series(v2) 
        &gt;&gt;&gt; s1.rolling(4).corr(s2) 
        0         NaN 
        1         NaN 
        2         NaN 
        3    0.333333 
        4    0.916949 
        dtype: float64 
 
        The below example shows a similar rolling calculation on a 
        DataFrame using the pairwise option. 
 
        &gt;&gt;&gt; matrix = np.array([[51., 35.], [49., 30.], [47., 32.],</span><span class="s2">\ 
        </span><span class="s5">[46., 31.], [50., 36.]]) 
        &gt;&gt;&gt; print(np.corrcoef(matrix[:-1,0], matrix[:-1,1]).round(7)) 
        [[1.         0.6263001] 
         [0.6263001  1.       ]] 
        &gt;&gt;&gt; print(np.corrcoef(matrix[1:,0], matrix[1:,1]).round(7)) 
        [[1.         0.5553681] 
         [0.5553681  1.        ]] 
        &gt;&gt;&gt; df = pd.DataFrame(matrix, columns=['X','Y']) 
        &gt;&gt;&gt; df 
              X     Y 
        0  51.0  35.0 
        1  49.0  30.0 
        2  47.0  32.0 
        3  46.0  31.0 
        4  50.0  36.0 
        &gt;&gt;&gt; df.rolling(4).corr(pairwise=True) 
                    X         Y 
        0 X       NaN       NaN 
          Y       NaN       NaN 
        1 X       NaN       NaN 
          Y       NaN       NaN 
        2 X       NaN       NaN 
          Y       NaN       NaN 
        3 X  1.000000  0.626300 
          Y  0.626300  1.000000 
        4 X  1.000000  0.555368 
          Y  0.555368  1.000000 
        &quot;&quot;&quot;</span>
        <span class="s1">).replace(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">window_method=</span><span class="s5">&quot;rolling&quot;</span><span class="s2">,</span>
        <span class="s1">aggregation_description=</span><span class="s5">&quot;correlation&quot;</span><span class="s2">,</span>
        <span class="s1">agg_method=</span><span class="s5">&quot;corr&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">corr(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">other: DataFrame | Series | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">pairwise: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">ddof: int = </span><span class="s4">1</span><span class="s2">,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s2">return </span><span class="s1">super().corr(other=other</span><span class="s2">, </span><span class="s1">pairwise=pairwise</span><span class="s2">, </span><span class="s1">ddof=ddof</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s1">Rolling.__doc__ = Window.__doc__</span>


<span class="s2">class </span><span class="s1">RollingGroupby(BaseWindowGroupby</span><span class="s2">, </span><span class="s1">Rolling):</span>
    <span class="s0">&quot;&quot;&quot; 
    Provide a rolling groupby implementation. 
    &quot;&quot;&quot;</span>

    <span class="s1">_attributes = Rolling._attributes + BaseWindowGroupby._attributes</span>

    <span class="s2">def </span><span class="s1">_get_window_indexer(self) -&gt; GroupbyIndexer:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return an indexer class that will compute the window start and end bounds 
 
        Returns 
        ------- 
        GroupbyIndexer 
        &quot;&quot;&quot;</span>
        <span class="s1">rolling_indexer: type[BaseIndexer]</span>
        <span class="s1">indexer_kwargs: dict[str</span><span class="s2">, </span><span class="s1">Any] | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span>
        <span class="s1">index_array = self._index_array</span>
        <span class="s2">if </span><span class="s1">isinstance(self.window</span><span class="s2">, </span><span class="s1">BaseIndexer):</span>
            <span class="s1">rolling_indexer = type(self.window)</span>
            <span class="s1">indexer_kwargs = self.window.__dict__.copy()</span>
            <span class="s2">assert </span><span class="s1">isinstance(indexer_kwargs</span><span class="s2">, </span><span class="s1">dict)  </span><span class="s3"># for mypy</span>
            <span class="s3"># We'll be using the index of each group later</span>
            <span class="s1">indexer_kwargs.pop(</span><span class="s5">&quot;index_array&quot;</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">window = self.window</span>
        <span class="s2">elif </span><span class="s1">self._win_freq_i8 </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">rolling_indexer = VariableWindowIndexer</span>
            <span class="s1">window = self._win_freq_i8</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rolling_indexer = FixedWindowIndexer</span>
            <span class="s1">window = self.window</span>
        <span class="s1">window_indexer = GroupbyIndexer(</span>
            <span class="s1">index_array=index_array</span><span class="s2">,</span>
            <span class="s1">window_size=window</span><span class="s2">,</span>
            <span class="s1">groupby_indices=self._grouper.indices</span><span class="s2">,</span>
            <span class="s1">window_indexer=rolling_indexer</span><span class="s2">,</span>
            <span class="s1">indexer_kwargs=indexer_kwargs</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">window_indexer</span>

    <span class="s2">def </span><span class="s1">_validate_monotonic(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Validate that on is monotonic; 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s2">not </span><span class="s1">(self._on.is_monotonic_increasing </span><span class="s2">or </span><span class="s1">self._on.is_monotonic_decreasing)</span>
            <span class="s2">or </span><span class="s1">self._on.hasnans</span>
        <span class="s1">):</span>
            <span class="s1">self._raise_monotonic_error()</span>
</pre>
</body>
</html>