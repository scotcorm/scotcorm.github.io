<html>
<head>
<title>algos.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
algos.pyx</font>
</center></td></tr></table>
<pre><span class="s0">import cython</span>
<span class="s0">from cython import Py_ssize_t</span>

<span class="s0">from libc.math cimport (</span>
    <span class="s0">fabs,</span>
    <span class="s0">sqrt,</span>
<span class="s0">)</span>
<span class="s0">from libc.stdlib cimport (</span>
    <span class="s0">free,</span>
    <span class="s0">malloc,</span>
<span class="s0">)</span>
<span class="s0">from libc.string cimport memmove</span>

<span class="s0">import numpy as np</span>

<span class="s0">cimport numpy as cnp</span>
<span class="s0">from numpy cimport (</span>
    <span class="s0">NPY_COMPLEX64,</span>
    <span class="s0">NPY_COMPLEX128,</span>
    <span class="s0">NPY_FLOAT32,</span>
    <span class="s0">NPY_FLOAT64,</span>
    <span class="s0">NPY_INT8,</span>
    <span class="s0">NPY_INT16,</span>
    <span class="s0">NPY_INT32,</span>
    <span class="s0">NPY_INT64,</span>
    <span class="s0">NPY_OBJECT,</span>
    <span class="s0">NPY_UINT8,</span>
    <span class="s0">NPY_UINT16,</span>
    <span class="s0">NPY_UINT32,</span>
    <span class="s0">NPY_UINT64,</span>
    <span class="s0">float32_t,</span>
    <span class="s0">float64_t,</span>
    <span class="s0">int8_t,</span>
    <span class="s0">int16_t,</span>
    <span class="s0">int32_t,</span>
    <span class="s0">int64_t,</span>
    <span class="s0">intp_t,</span>
    <span class="s0">ndarray,</span>
    <span class="s0">uint8_t,</span>
    <span class="s0">uint16_t,</span>
    <span class="s0">uint32_t,</span>
    <span class="s0">uint64_t,</span>
<span class="s0">)</span>

<span class="s0">cnp.import_array()</span>

<span class="s0">cimport pandas._libs.util as util</span>
<span class="s0">from pandas._libs.dtypes cimport (</span>
    <span class="s0">iu_64_floating_obj_t,</span>
    <span class="s0">numeric_object_t,</span>
    <span class="s0">numeric_t,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.khash cimport (</span>
    <span class="s0">kh_destroy_int64,</span>
    <span class="s0">kh_get_int64,</span>
    <span class="s0">kh_init_int64,</span>
    <span class="s0">kh_int64_t,</span>
    <span class="s0">kh_put_int64,</span>
    <span class="s0">kh_resize_int64,</span>
    <span class="s0">khiter_t,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.util cimport get_nat</span>

<span class="s0">import pandas._libs.missing as missing</span>

<span class="s0">cdef:</span>
    <span class="s0">float64_t FP_ERR = 1e-13</span>
    <span class="s0">float64_t NaN = &lt;float64_t&gt;np.NaN</span>
    <span class="s0">int64_t NPY_NAT = get_nat()</span>


<span class="s0">tiebreakers = {</span>
    <span class="s0">&quot;average&quot;: TIEBREAK_AVERAGE,</span>
    <span class="s0">&quot;min&quot;: TIEBREAK_MIN,</span>
    <span class="s0">&quot;max&quot;: TIEBREAK_MAX,</span>
    <span class="s0">&quot;first&quot;: TIEBREAK_FIRST,</span>
    <span class="s0">&quot;dense&quot;: TIEBREAK_DENSE,</span>
<span class="s0">}</span>


<span class="s0">cdef inline bint are_diff(object left, object right):</span>
    <span class="s0">try:</span>
        <span class="s0">return fabs(left - right) &gt; FP_ERR</span>
    <span class="s0">except TypeError:</span>
        <span class="s0">return left != right</span>


<span class="s0">class Infinity:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Provide a positive Infinity comparison method for ranking.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">__lt__ = lambda self, other: False</span>
    <span class="s0">__le__ = lambda self, other: isinstance(other, Infinity)</span>
    <span class="s0">__eq__ = lambda self, other: isinstance(other, Infinity)</span>
    <span class="s0">__ne__ = lambda self, other: not isinstance(other, Infinity)</span>
    <span class="s0">__gt__ = lambda self, other: (not isinstance(other, Infinity) and</span>
                                  <span class="s0">not missing.checknull(other))</span>
    <span class="s0">__ge__ = lambda self, other: not missing.checknull(other)</span>


<span class="s0">class NegInfinity:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Provide a negative Infinity comparison method for ranking.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">__lt__ = lambda self, other: (not isinstance(other, NegInfinity) and</span>
                                  <span class="s0">not missing.checknull(other))</span>
    <span class="s0">__le__ = lambda self, other: not missing.checknull(other)</span>
    <span class="s0">__eq__ = lambda self, other: isinstance(other, NegInfinity)</span>
    <span class="s0">__ne__ = lambda self, other: not isinstance(other, NegInfinity)</span>
    <span class="s0">__gt__ = lambda self, other: False</span>
    <span class="s0">__ge__ = lambda self, other: isinstance(other, NegInfinity)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">cpdef ndarray[int64_t, ndim=1] unique_deltas(const int64_t[:] arr):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Efficiently find the unique first-differences of the given array.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">arr : ndarray[int64_t]</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">ndarray[int64_t]</span>
        <span class="s0">An ordered ndarray[int64_t]</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(arr)</span>
        <span class="s0">int64_t val</span>
        <span class="s0">khiter_t k</span>
        <span class="s0">kh_int64_t *table</span>
        <span class="s0">int ret = 0</span>
        <span class="s0">list uniques = []</span>
        <span class="s0">ndarray[int64_t, ndim=1] result</span>

    <span class="s0">table = kh_init_int64()</span>
    <span class="s0">kh_resize_int64(table, 10)</span>
    <span class="s0">for i in range(n - 1):</span>
        <span class="s0">val = arr[i + 1] - arr[i]</span>
        <span class="s0">k = kh_get_int64(table, val)</span>
        <span class="s0">if k == table.n_buckets:</span>
            <span class="s0">kh_put_int64(table, val, &amp;ret)</span>
            <span class="s0">uniques.append(val)</span>
    <span class="s0">kh_destroy_int64(table)</span>

    <span class="s0">result = np.array(uniques, dtype=np.int64)</span>
    <span class="s0">result.sort()</span>
    <span class="s0">return result</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def is_lexsorted(list_of_arrays: list) -&gt; bint:</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i</span>
        <span class="s0">Py_ssize_t n, nlevels</span>
        <span class="s0">int64_t k, cur, pre</span>
        <span class="s0">ndarray arr</span>
        <span class="s0">bint result = True</span>

    <span class="s0">nlevels = len(list_of_arrays)</span>
    <span class="s0">n = len(list_of_arrays[0])</span>

    <span class="s0">cdef int64_t **vecs = &lt;int64_t**&gt;malloc(nlevels * sizeof(int64_t*))</span>
    <span class="s0">for i in range(nlevels):</span>
        <span class="s0">arr = list_of_arrays[i]</span>
        <span class="s0">assert arr.dtype.name == 'int64'</span>
        <span class="s0">vecs[i] = &lt;int64_t*&gt;cnp.PyArray_DATA(arr)</span>

    <span class="s0"># Assume uniqueness??</span>
    <span class="s0">with nogil:</span>
        <span class="s0">for i in range(1, n):</span>
            <span class="s0">for k in range(nlevels):</span>
                <span class="s0">cur = vecs[k][i]</span>
                <span class="s0">pre = vecs[k][i -1]</span>
                <span class="s0">if cur == pre:</span>
                    <span class="s0">continue</span>
                <span class="s0">elif cur &gt; pre:</span>
                    <span class="s0">break</span>
                <span class="s0">else:</span>
                    <span class="s0">result = False</span>
                    <span class="s0">break</span>
    <span class="s0">free(vecs)</span>
    <span class="s0">return result</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def groupsort_indexer(const intp_t[:] index, Py_ssize_t ngroups):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Compute a 1-d indexer.</span>

    <span class="s0">The indexer is an ordering of the passed index,</span>
    <span class="s0">ordered by the groups.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">index: np.ndarray[np.intp]</span>
        <span class="s0">Mappings from group -&gt; position.</span>
    <span class="s0">ngroups: int64</span>
        <span class="s0">Number of groups.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">ndarray[intp_t, ndim=1]</span>
        <span class="s0">Indexer</span>
    <span class="s0">ndarray[intp_t, ndim=1]</span>
        <span class="s0">Group Counts</span>

    <span class="s0">Notes</span>
    <span class="s0">-----</span>
    <span class="s0">This is a reverse of the label factorization process.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, label, n</span>
        <span class="s0">intp_t[::1] indexer, where, counts</span>

    <span class="s0">counts = np.zeros(ngroups + 1, dtype=np.intp)</span>
    <span class="s0">n = len(index)</span>
    <span class="s0">indexer = np.zeros(n, dtype=np.intp)</span>
    <span class="s0">where = np.zeros(ngroups + 1, dtype=np.intp)</span>

    <span class="s0">with nogil:</span>

        <span class="s0"># count group sizes, location 0 for NA</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">counts[index[i] + 1] += 1</span>

        <span class="s0"># mark the start of each contiguous group of like-indexed data</span>
        <span class="s0">for i in range(1, ngroups + 1):</span>
            <span class="s0">where[i] = where[i - 1] + counts[i - 1]</span>

        <span class="s0"># this is our indexer</span>
        <span class="s0">for i in range(n):</span>
            <span class="s0">label = index[i] + 1</span>
            <span class="s0">indexer[where[label]] = i</span>
            <span class="s0">where[label] += 1</span>

    <span class="s0">return indexer.base, counts.base</span>


<span class="s0">cdef inline Py_ssize_t swap(numeric_t *a, numeric_t *b) nogil:</span>
    <span class="s0">cdef:</span>
        <span class="s0">numeric_t t</span>

    <span class="s0"># cython doesn't allow pointer dereference so use array syntax</span>
    <span class="s0">t = a[0]</span>
    <span class="s0">a[0] = b[0]</span>
    <span class="s0">b[0] = t</span>
    <span class="s0">return 0</span>


<span class="s0">cdef inline numeric_t kth_smallest_c(numeric_t* arr, Py_ssize_t k, Py_ssize_t n) nogil:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">See kth_smallest.__doc__. The additional parameter n specifies the maximum</span>
    <span class="s0">number of elements considered in arr, needed for compatibility with usage</span>
    <span class="s0">in groupby.pyx</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, left, m</span>
        <span class="s0">numeric_t x</span>

    <span class="s0">left = 0</span>
    <span class="s0">m = n - 1</span>

    <span class="s0">while left &lt; m:</span>
        <span class="s0">x = arr[k]</span>
        <span class="s0">i = left</span>
        <span class="s0">j = m</span>

        <span class="s0">while 1:</span>
            <span class="s0">while arr[i] &lt; x:</span>
                <span class="s0">i += 1</span>
            <span class="s0">while x &lt; arr[j]:</span>
                <span class="s0">j -= 1</span>
            <span class="s0">if i &lt;= j:</span>
                <span class="s0">swap(&amp;arr[i], &amp;arr[j])</span>
                <span class="s0">i += 1</span>
                <span class="s0">j -= 1</span>

            <span class="s0">if i &gt; j:</span>
                <span class="s0">break</span>

        <span class="s0">if j &lt; k:</span>
            <span class="s0">left = i</span>
        <span class="s0">if k &lt; i:</span>
            <span class="s0">m = j</span>
    <span class="s0">return arr[k]</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def kth_smallest(numeric_t[::1] arr, Py_ssize_t k) -&gt; numeric_t:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Compute the kth smallest value in arr. Note that the input</span>
    <span class="s0">array will be modified.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">arr : numeric[::1]</span>
        <span class="s0">Array to compute the kth smallest value for, must be</span>
        <span class="s0">contiguous</span>
    <span class="s0">k : Py_ssize_t</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">numeric</span>
        <span class="s0">The kth smallest value in arr</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">numeric_t result</span>

    <span class="s0">with nogil:</span>
        <span class="s0">result = kth_smallest_c(&amp;arr[0], k, arr.shape[0])</span>

    <span class="s0">return result</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Pairwise correlation/covariance</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def nancorr(const float64_t[:, :] mat, bint cov=False, minp=None):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, xi, yi, N, K</span>
        <span class="s0">bint minpv</span>
        <span class="s0">float64_t[:, ::1] result</span>
        <span class="s0"># Initialize to None since we only use in the no missing value case</span>
        <span class="s0">float64_t[::1] means=None, ssqds=None</span>
        <span class="s0">ndarray[uint8_t, ndim=2] mask</span>
        <span class="s0">bint no_nans</span>
        <span class="s0">int64_t nobs = 0</span>
        <span class="s0">float64_t mean, ssqd, val</span>
        <span class="s0">float64_t vx, vy, dx, dy, meanx, meany, divisor, ssqdmx, ssqdmy, covxy</span>

    <span class="s0">N, K = (&lt;object&gt;mat).shape</span>

    <span class="s0">if minp is None:</span>
        <span class="s0">minpv = 1</span>
    <span class="s0">else:</span>
        <span class="s0">minpv = &lt;int&gt;minp</span>

    <span class="s0">result = np.empty((K, K), dtype=np.float64)</span>
    <span class="s0">mask = np.isfinite(mat).view(np.uint8)</span>
    <span class="s0">no_nans = mask.all()</span>

    <span class="s0"># Computing the online means and variances is expensive - so if possible we can</span>
    <span class="s0"># precompute these and avoid repeating the computations each time we handle</span>
    <span class="s0"># an (xi, yi) pair</span>
    <span class="s0">if no_nans:</span>
        <span class="s0">means = np.empty(K, dtype=np.float64)</span>
        <span class="s0">ssqds = np.empty(K, dtype=np.float64)</span>

        <span class="s0">with nogil:</span>
            <span class="s0">for j in range(K):</span>
                <span class="s0">ssqd = mean = 0</span>
                <span class="s0">for i in range(N):</span>
                    <span class="s0">val = mat[i, j]</span>
                    <span class="s0">dx = val - mean</span>
                    <span class="s0">mean += 1 / (i + 1) * dx</span>
                    <span class="s0">ssqd += (val - mean) * dx</span>

                <span class="s0">means[j] = mean</span>
                <span class="s0">ssqds[j] = ssqd</span>

    <span class="s0">with nogil:</span>
        <span class="s0">for xi in range(K):</span>
            <span class="s0">for yi in range(xi + 1):</span>
                <span class="s0">covxy = 0</span>
                <span class="s0">if no_nans:</span>
                    <span class="s0">for i in range(N):</span>
                        <span class="s0">vx = mat[i, xi]</span>
                        <span class="s0">vy = mat[i, yi]</span>
                        <span class="s0">covxy += (vx - means[xi]) * (vy - means[yi])</span>

                    <span class="s0">ssqdmx = ssqds[xi]</span>
                    <span class="s0">ssqdmy = ssqds[yi]</span>
                    <span class="s0">nobs = N</span>

                <span class="s0">else:</span>
                    <span class="s0">nobs = ssqdmx = ssqdmy = covxy = meanx = meany = 0</span>
                    <span class="s0">for i in range(N):</span>
                        <span class="s0"># Welford's method for the variance-calculation</span>
                        <span class="s0"># https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance</span>
                        <span class="s0">if mask[i, xi] and mask[i, yi]:</span>
                            <span class="s0">vx = mat[i, xi]</span>
                            <span class="s0">vy = mat[i, yi]</span>
                            <span class="s0">nobs += 1</span>
                            <span class="s0">dx = vx - meanx</span>
                            <span class="s0">dy = vy - meany</span>
                            <span class="s0">meanx += 1 / nobs * dx</span>
                            <span class="s0">meany += 1 / nobs * dy</span>
                            <span class="s0">ssqdmx += (vx - meanx) * dx</span>
                            <span class="s0">ssqdmy += (vy - meany) * dy</span>
                            <span class="s0">covxy += (vx - meanx) * dy</span>

                <span class="s0">if nobs &lt; minpv:</span>
                    <span class="s0">result[xi, yi] = result[yi, xi] = NaN</span>
                <span class="s0">else:</span>
                    <span class="s0">divisor = (nobs - 1.0) if cov else sqrt(ssqdmx * ssqdmy)</span>

                    <span class="s0">if divisor != 0:</span>
                        <span class="s0">result[xi, yi] = result[yi, xi] = covxy / divisor</span>
                    <span class="s0">else:</span>
                        <span class="s0">result[xi, yi] = result[yi, xi] = NaN</span>

    <span class="s0">return result.base</span>

<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Pairwise Spearman correlation</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def nancorr_spearman(ndarray[float64_t, ndim=2] mat, Py_ssize_t minp=1) -&gt; ndarray:</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, xi, yi, N, K</span>
        <span class="s0">ndarray[float64_t, ndim=2] result</span>
        <span class="s0">ndarray[float64_t, ndim=2] ranked_mat</span>
        <span class="s0">ndarray[float64_t, ndim=1] rankedx, rankedy</span>
        <span class="s0">float64_t[::1] maskedx, maskedy</span>
        <span class="s0">ndarray[uint8_t, ndim=2] mask</span>
        <span class="s0">int64_t nobs = 0</span>
        <span class="s0">bint no_nans</span>
        <span class="s0">float64_t vx, vy, sumx, sumxx, sumyy, mean, divisor</span>

    <span class="s0">N, K = (&lt;object&gt;mat).shape</span>

    <span class="s0"># Handle the edge case where we know all results will be nan</span>
    <span class="s0"># to keep conditional logic inside loop simpler</span>
    <span class="s0">if N &lt; minp:</span>
        <span class="s0">result = np.full((K, K), np.nan, dtype=np.float64)</span>
        <span class="s0">return result</span>

    <span class="s0">result = np.empty((K, K), dtype=np.float64)</span>
    <span class="s0">mask = np.isfinite(mat).view(np.uint8)</span>
    <span class="s0">no_nans = mask.all()</span>

    <span class="s0">ranked_mat = np.empty((N, K), dtype=np.float64)</span>

    <span class="s0"># Note: we index into maskedx, maskedy in loops up to nobs, but using N is safe</span>
    <span class="s0"># here since N &gt;= nobs and values are stored contiguously</span>
    <span class="s0">maskedx = np.empty(N, dtype=np.float64)</span>
    <span class="s0">maskedy = np.empty(N, dtype=np.float64)</span>
    <span class="s0">for i in range(K):</span>
        <span class="s0">ranked_mat[:, i] = rank_1d(mat[:, i])</span>

    <span class="s0">with nogil:</span>
        <span class="s0">for xi in range(K):</span>
            <span class="s0">for yi in range(xi + 1):</span>
                <span class="s0">sumx = sumxx = sumyy = 0</span>

                <span class="s0"># Fastpath for data with no nans/infs, allows avoiding mask checks</span>
                <span class="s0"># and array reassignments</span>
                <span class="s0">if no_nans:</span>
                    <span class="s0">mean = (N + 1) / 2.</span>

                    <span class="s0"># now the cov numerator</span>
                    <span class="s0">for i in range(N):</span>
                        <span class="s0">vx = ranked_mat[i, xi] - mean</span>
                        <span class="s0">vy = ranked_mat[i, yi] - mean</span>

                        <span class="s0">sumx += vx * vy</span>
                        <span class="s0">sumxx += vx * vx</span>
                        <span class="s0">sumyy += vy * vy</span>
                <span class="s0">else:</span>
                    <span class="s0">nobs = 0</span>
                    <span class="s0"># Keep track of whether we need to recompute ranks</span>
                    <span class="s0">all_ranks = True</span>
                    <span class="s0">for i in range(N):</span>
                        <span class="s0">all_ranks &amp;= not (mask[i, xi] ^ mask[i, yi])</span>
                        <span class="s0">if mask[i, xi] and mask[i, yi]:</span>
                            <span class="s0">maskedx[nobs] = ranked_mat[i, xi]</span>
                            <span class="s0">maskedy[nobs] = ranked_mat[i, yi]</span>
                            <span class="s0">nobs += 1</span>

                    <span class="s0">if nobs &lt; minp:</span>
                        <span class="s0">result[xi, yi] = result[yi, xi] = NaN</span>
                        <span class="s0">continue</span>
                    <span class="s0">else:</span>
                        <span class="s0">if not all_ranks:</span>
                            <span class="s0">with gil:</span>
                                <span class="s0"># We need to slice back to nobs because rank_1d will</span>
                                <span class="s0"># require arrays of nobs length</span>
                                <span class="s0">rankedx = rank_1d(np.asarray(maskedx)[:nobs])</span>
                                <span class="s0">rankedy = rank_1d(np.asarray(maskedy)[:nobs])</span>
                            <span class="s0">for i in range(nobs):</span>
                                <span class="s0">maskedx[i] = rankedx[i]</span>
                                <span class="s0">maskedy[i] = rankedy[i]</span>

                        <span class="s0">mean = (nobs + 1) / 2.</span>

                        <span class="s0"># now the cov numerator</span>
                        <span class="s0">for i in range(nobs):</span>
                            <span class="s0">vx = maskedx[i] - mean</span>
                            <span class="s0">vy = maskedy[i] - mean</span>

                            <span class="s0">sumx += vx * vy</span>
                            <span class="s0">sumxx += vx * vx</span>
                            <span class="s0">sumyy += vy * vy</span>

                <span class="s0">divisor = sqrt(sumxx * sumyy)</span>

                <span class="s0">if divisor != 0:</span>
                    <span class="s0">result[xi, yi] = result[yi, xi] = sumx / divisor</span>
                <span class="s0">else:</span>
                    <span class="s0">result[xi, yi] = result[yi, xi] = NaN</span>

    <span class="s0">return result</span>


<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0">def validate_limit(nobs: int | None, limit=None) -&gt; int:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Check that the `limit` argument is a positive integer.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">nobs : int</span>
    <span class="s0">limit : object</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">int</span>
        <span class="s0">The limit.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if limit is None:</span>
        <span class="s0">lim = nobs</span>
    <span class="s0">else:</span>
        <span class="s0">if not util.is_integer_object(limit):</span>
            <span class="s0">raise ValueError('Limit must be an integer')</span>
        <span class="s0">if limit &lt; 1:</span>
            <span class="s0">raise ValueError('Limit must be greater than 0')</span>
        <span class="s0">lim = limit</span>

    <span class="s0">return lim</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def pad(</span>
    <span class="s0">ndarray[numeric_object_t] old,</span>
    <span class="s0">ndarray[numeric_object_t] new,</span>
    <span class="s0">limit=None</span>
<span class="s0">) -&gt; ndarray:</span>
    <span class="s0"># -&gt; ndarray[intp_t, ndim=1]</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, nleft, nright</span>
        <span class="s0">ndarray[intp_t, ndim=1] indexer</span>
        <span class="s0">numeric_object_t cur, next_val</span>
        <span class="s0">int lim, fill_count = 0</span>

    <span class="s0">nleft = len(old)</span>
    <span class="s0">nright = len(new)</span>
    <span class="s0">indexer = np.empty(nright, dtype=np.intp)</span>
    <span class="s0">indexer[:] = -1</span>

    <span class="s0">lim = validate_limit(nright, limit)</span>

    <span class="s0">if nleft == 0 or nright == 0 or new[nright - 1] &lt; old[0]:</span>
        <span class="s0">return indexer</span>

    <span class="s0">i = j = 0</span>

    <span class="s0">cur = old[0]</span>

    <span class="s0">while j &lt;= nright - 1 and new[j] &lt; cur:</span>
        <span class="s0">j += 1</span>

    <span class="s0">while True:</span>
        <span class="s0">if j == nright:</span>
            <span class="s0">break</span>

        <span class="s0">if i == nleft - 1:</span>
            <span class="s0">while j &lt; nright:</span>
                <span class="s0">if new[j] == cur:</span>
                    <span class="s0">indexer[j] = i</span>
                <span class="s0">elif new[j] &gt; cur and fill_count &lt; lim:</span>
                    <span class="s0">indexer[j] = i</span>
                    <span class="s0">fill_count += 1</span>
                <span class="s0">j += 1</span>
            <span class="s0">break</span>

        <span class="s0">next_val = old[i + 1]</span>

        <span class="s0">while j &lt; nright and cur &lt;= new[j] &lt; next_val:</span>
            <span class="s0">if new[j] == cur:</span>
                <span class="s0">indexer[j] = i</span>
            <span class="s0">elif fill_count &lt; lim:</span>
                <span class="s0">indexer[j] = i</span>
                <span class="s0">fill_count += 1</span>
            <span class="s0">j += 1</span>

        <span class="s0">fill_count = 0</span>
        <span class="s0">i += 1</span>
        <span class="s0">cur = next_val</span>

    <span class="s0">return indexer</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def pad_inplace(numeric_object_t[:] values, uint8_t[:] mask, limit=None):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, N</span>
        <span class="s0">numeric_object_t val</span>
        <span class="s0">uint8_t prev_mask</span>
        <span class="s0">int lim, fill_count = 0</span>

    <span class="s0">N = len(values)</span>

    <span class="s0"># GH#2778</span>
    <span class="s0">if N == 0:</span>
        <span class="s0">return</span>

    <span class="s0">lim = validate_limit(N, limit)</span>

    <span class="s0">val = values[0]</span>
    <span class="s0">prev_mask = mask[0]</span>
    <span class="s0">for i in range(N):</span>
        <span class="s0">if mask[i]:</span>
            <span class="s0">if fill_count &gt;= lim:</span>
                <span class="s0">continue</span>
            <span class="s0">fill_count += 1</span>
            <span class="s0">values[i] = val</span>
            <span class="s0">mask[i] = prev_mask</span>
        <span class="s0">else:</span>
            <span class="s0">fill_count = 0</span>
            <span class="s0">val = values[i]</span>
            <span class="s0">prev_mask = mask[i]</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def pad_2d_inplace(numeric_object_t[:, :] values, uint8_t[:, :] mask, limit=None):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, N, K</span>
        <span class="s0">numeric_object_t val</span>
        <span class="s0">int lim, fill_count = 0</span>

    <span class="s0">K, N = (&lt;object&gt;values).shape</span>

    <span class="s0"># GH#2778</span>
    <span class="s0">if N == 0:</span>
        <span class="s0">return</span>

    <span class="s0">lim = validate_limit(N, limit)</span>

    <span class="s0">for j in range(K):</span>
        <span class="s0">fill_count = 0</span>
        <span class="s0">val = values[j, 0]</span>
        <span class="s0">for i in range(N):</span>
            <span class="s0">if mask[j, i]:</span>
                <span class="s0">if fill_count &gt;= lim or i == 0:</span>
                    <span class="s0">continue</span>
                <span class="s0">fill_count += 1</span>
                <span class="s0">values[j, i] = val</span>
                <span class="s0">mask[j, i] = False</span>
            <span class="s0">else:</span>
                <span class="s0">fill_count = 0</span>
                <span class="s0">val = values[j, i]</span>


<span class="s0">&quot;&quot;&quot;</span>
<span class="s0">Backfilling logic for generating fill vector</span>

<span class="s0">Diagram of what's going on</span>

<span class="s0">Old      New    Fill vector    Mask</span>
         <span class="s0">.        0               1</span>
         <span class="s0">.        0               1</span>
         <span class="s0">.        0               1</span>
<span class="s0">A        A        0               1</span>
         <span class="s0">.        1               1</span>
         <span class="s0">.        1               1</span>
         <span class="s0">.        1               1</span>
         <span class="s0">.        1               1</span>
         <span class="s0">.        1               1</span>
<span class="s0">B        B        1               1</span>
         <span class="s0">.        2               1</span>
         <span class="s0">.        2               1</span>
         <span class="s0">.        2               1</span>
<span class="s0">C        C        2               1</span>
         <span class="s0">.                        0</span>
         <span class="s0">.                        0</span>
<span class="s0">D</span>
<span class="s0">&quot;&quot;&quot;</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def backfill(</span>
    <span class="s0">ndarray[numeric_object_t] old,</span>
    <span class="s0">ndarray[numeric_object_t] new,</span>
    <span class="s0">limit=None</span>
<span class="s0">) -&gt; ndarray:</span>
    <span class="s0"># -&gt; ndarray[intp_t, ndim=1]</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, nleft, nright</span>
        <span class="s0">ndarray[intp_t, ndim=1] indexer</span>
        <span class="s0">numeric_object_t cur, prev</span>
        <span class="s0">int lim, fill_count = 0</span>

    <span class="s0">nleft = len(old)</span>
    <span class="s0">nright = len(new)</span>
    <span class="s0">indexer = np.empty(nright, dtype=np.intp)</span>
    <span class="s0">indexer[:] = -1</span>

    <span class="s0">lim = validate_limit(nright, limit)</span>

    <span class="s0">if nleft == 0 or nright == 0 or new[0] &gt; old[nleft - 1]:</span>
        <span class="s0">return indexer</span>

    <span class="s0">i = nleft - 1</span>
    <span class="s0">j = nright - 1</span>

    <span class="s0">cur = old[nleft - 1]</span>

    <span class="s0">while j &gt;= 0 and new[j] &gt; cur:</span>
        <span class="s0">j -= 1</span>

    <span class="s0">while True:</span>
        <span class="s0">if j &lt; 0:</span>
            <span class="s0">break</span>

        <span class="s0">if i == 0:</span>
            <span class="s0">while j &gt;= 0:</span>
                <span class="s0">if new[j] == cur:</span>
                    <span class="s0">indexer[j] = i</span>
                <span class="s0">elif new[j] &lt; cur and fill_count &lt; lim:</span>
                    <span class="s0">indexer[j] = i</span>
                    <span class="s0">fill_count += 1</span>
                <span class="s0">j -= 1</span>
            <span class="s0">break</span>

        <span class="s0">prev = old[i - 1]</span>

        <span class="s0">while j &gt;= 0 and prev &lt; new[j] &lt;= cur:</span>
            <span class="s0">if new[j] == cur:</span>
                <span class="s0">indexer[j] = i</span>
            <span class="s0">elif new[j] &lt; cur and fill_count &lt; lim:</span>
                <span class="s0">indexer[j] = i</span>
                <span class="s0">fill_count += 1</span>
            <span class="s0">j -= 1</span>

        <span class="s0">fill_count = 0</span>
        <span class="s0">i -= 1</span>
        <span class="s0">cur = prev</span>

    <span class="s0">return indexer</span>


<span class="s0">def backfill_inplace(numeric_object_t[:] values, uint8_t[:] mask, limit=None):</span>
    <span class="s0">pad_inplace(values[::-1], mask[::-1], limit=limit)</span>


<span class="s0">def backfill_2d_inplace(numeric_object_t[:, :] values,</span>
                        <span class="s0">uint8_t[:, :] mask,</span>
                        <span class="s0">limit=None):</span>
    <span class="s0">pad_2d_inplace(values[:, ::-1], mask[:, ::-1], limit)</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def is_monotonic(ndarray[numeric_object_t, ndim=1] arr, bint timelike):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">tuple</span>
        <span class="s0">is_monotonic_inc : bool</span>
        <span class="s0">is_monotonic_dec : bool</span>
        <span class="s0">is_unique : bool</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n</span>
        <span class="s0">numeric_object_t prev, cur</span>
        <span class="s0">bint is_monotonic_inc = 1</span>
        <span class="s0">bint is_monotonic_dec = 1</span>
        <span class="s0">bint is_unique = 1</span>
        <span class="s0">bint is_strict_monotonic = 1</span>

    <span class="s0">n = len(arr)</span>

    <span class="s0">if n == 1:</span>
        <span class="s0">if arr[0] != arr[0] or (timelike and &lt;int64_t&gt;arr[0] == NPY_NAT):</span>
            <span class="s0"># single value is NaN</span>
            <span class="s0">return False, False, True</span>
        <span class="s0">else:</span>
            <span class="s0">return True, True, True</span>
    <span class="s0">elif n &lt; 2:</span>
        <span class="s0">return True, True, True</span>

    <span class="s0">if timelike and &lt;int64_t&gt;arr[0] == NPY_NAT:</span>
        <span class="s0">return False, False, True</span>

    <span class="s0">if numeric_object_t is not object:</span>
        <span class="s0">with nogil:</span>
            <span class="s0">prev = arr[0]</span>
            <span class="s0">for i in range(1, n):</span>
                <span class="s0">cur = arr[i]</span>
                <span class="s0">if timelike and &lt;int64_t&gt;cur == NPY_NAT:</span>
                    <span class="s0">is_monotonic_inc = 0</span>
                    <span class="s0">is_monotonic_dec = 0</span>
                    <span class="s0">break</span>
                <span class="s0">if cur &lt; prev:</span>
                    <span class="s0">is_monotonic_inc = 0</span>
                <span class="s0">elif cur &gt; prev:</span>
                    <span class="s0">is_monotonic_dec = 0</span>
                <span class="s0">elif cur == prev:</span>
                    <span class="s0">is_unique = 0</span>
                <span class="s0">else:</span>
                    <span class="s0"># cur or prev is NaN</span>
                    <span class="s0">is_monotonic_inc = 0</span>
                    <span class="s0">is_monotonic_dec = 0</span>
                    <span class="s0">break</span>
                <span class="s0">if not is_monotonic_inc and not is_monotonic_dec:</span>
                    <span class="s0">is_monotonic_inc = 0</span>
                    <span class="s0">is_monotonic_dec = 0</span>
                    <span class="s0">break</span>
                <span class="s0">prev = cur</span>
    <span class="s0">else:</span>
        <span class="s0"># object-dtype, identical to above except we cannot use `with nogil`</span>
        <span class="s0">prev = arr[0]</span>
        <span class="s0">for i in range(1, n):</span>
            <span class="s0">cur = arr[i]</span>
            <span class="s0">if timelike and &lt;int64_t&gt;cur == NPY_NAT:</span>
                <span class="s0">is_monotonic_inc = 0</span>
                <span class="s0">is_monotonic_dec = 0</span>
                <span class="s0">break</span>
            <span class="s0">if cur &lt; prev:</span>
                <span class="s0">is_monotonic_inc = 0</span>
            <span class="s0">elif cur &gt; prev:</span>
                <span class="s0">is_monotonic_dec = 0</span>
            <span class="s0">elif cur == prev:</span>
                <span class="s0">is_unique = 0</span>
            <span class="s0">else:</span>
                <span class="s0"># cur or prev is NaN</span>
                <span class="s0">is_monotonic_inc = 0</span>
                <span class="s0">is_monotonic_dec = 0</span>
                <span class="s0">break</span>
            <span class="s0">if not is_monotonic_inc and not is_monotonic_dec:</span>
                <span class="s0">is_monotonic_inc = 0</span>
                <span class="s0">is_monotonic_dec = 0</span>
                <span class="s0">break</span>
            <span class="s0">prev = cur</span>

    <span class="s0">is_strict_monotonic = is_unique and (is_monotonic_inc or is_monotonic_dec)</span>
    <span class="s0">return is_monotonic_inc, is_monotonic_dec, is_strict_monotonic</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># rank_1d, rank_2d</span>
<span class="s0"># ----------------------------------------------------------------------</span>

<span class="s0">cdef iu_64_floating_obj_t get_rank_nan_fill_val(</span>
        <span class="s0">bint rank_nans_highest,</span>
        <span class="s0">iu_64_floating_obj_t[:] _=None</span>
<span class="s0">):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Return the value we'll use to represent missing values when sorting depending</span>
    <span class="s0">on if we'd like missing values to end up at the top/bottom. (The second parameter</span>
    <span class="s0">is unused, but needed for fused type specialization)</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if rank_nans_highest:</span>
        <span class="s0">if iu_64_floating_obj_t is object:</span>
            <span class="s0">return Infinity()</span>
        <span class="s0">elif iu_64_floating_obj_t is int64_t:</span>
            <span class="s0">return util.INT64_MAX</span>
        <span class="s0">elif iu_64_floating_obj_t is uint64_t:</span>
            <span class="s0">return util.UINT64_MAX</span>
        <span class="s0">else:</span>
            <span class="s0">return np.inf</span>
    <span class="s0">else:</span>
        <span class="s0">if iu_64_floating_obj_t is object:</span>
            <span class="s0">return NegInfinity()</span>
        <span class="s0">elif iu_64_floating_obj_t is int64_t:</span>
            <span class="s0">return NPY_NAT</span>
        <span class="s0">elif iu_64_floating_obj_t is uint64_t:</span>
            <span class="s0">return 0</span>
        <span class="s0">else:</span>
            <span class="s0">return -np.inf</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def rank_1d(</span>
    <span class="s0">ndarray[iu_64_floating_obj_t, ndim=1] values,</span>
    <span class="s0">const intp_t[:] labels=None,</span>
    <span class="s0">bint is_datetimelike=False,</span>
    <span class="s0">ties_method=&quot;average&quot;,</span>
    <span class="s0">bint ascending=True,</span>
    <span class="s0">bint pct=False,</span>
    <span class="s0">na_option=&quot;keep&quot;,</span>
<span class="s0">):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Fast NaN-friendly version of ``scipy.stats.rankdata``.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">values : array of iu_64_floating_obj_t values to be ranked</span>
    <span class="s0">labels : np.ndarray[np.intp] or None</span>
        <span class="s0">Array containing unique label for each group, with its ordering</span>
        <span class="s0">matching up to the corresponding record in `values`. If not called</span>
        <span class="s0">from a groupby operation, will be None.</span>
    <span class="s0">is_datetimelike : bool, default False</span>
        <span class="s0">True if `values` contains datetime-like entries.</span>
    <span class="s0">ties_method : {'average', 'min', 'max', 'first', 'dense'}, default</span>
        <span class="s0">'average'</span>
        <span class="s0">* average: average rank of group</span>
        <span class="s0">* min: lowest rank in group</span>
        <span class="s0">* max: highest rank in group</span>
        <span class="s0">* first: ranks assigned in order they appear in the array</span>
        <span class="s0">* dense: like 'min', but rank always increases by 1 between groups</span>
    <span class="s0">ascending : bool, default True</span>
        <span class="s0">False for ranks by high (1) to low (N)</span>
        <span class="s0">na_option : {'keep', 'top', 'bottom'}, default 'keep'</span>
    <span class="s0">pct : bool, default False</span>
        <span class="s0">Compute percentage rank of data within each group</span>
    <span class="s0">na_option : {'keep', 'top', 'bottom'}, default 'keep'</span>
        <span class="s0">* keep: leave NA values where they are</span>
        <span class="s0">* top: smallest rank if ascending</span>
        <span class="s0">* bottom: smallest rank if descending</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">TiebreakEnumType tiebreak</span>
        <span class="s0">Py_ssize_t N</span>
        <span class="s0">int64_t[::1] grp_sizes</span>
        <span class="s0">intp_t[:] lexsort_indexer</span>
        <span class="s0">float64_t[::1] out</span>
        <span class="s0">ndarray[iu_64_floating_obj_t, ndim=1] masked_vals</span>
        <span class="s0">iu_64_floating_obj_t[:] masked_vals_memview</span>
        <span class="s0">uint8_t[:] mask</span>
        <span class="s0">bint keep_na, nans_rank_highest, check_labels, check_mask</span>
        <span class="s0">iu_64_floating_obj_t nan_fill_val</span>

    <span class="s0">tiebreak = tiebreakers[ties_method]</span>
    <span class="s0">if tiebreak == TIEBREAK_FIRST:</span>
        <span class="s0">if not ascending:</span>
            <span class="s0">tiebreak = TIEBREAK_FIRST_DESCENDING</span>

    <span class="s0">keep_na = na_option == 'keep'</span>

    <span class="s0">N = len(values)</span>
    <span class="s0">if labels is not None:</span>
        <span class="s0"># TODO(cython3): cast won't be necessary (#2992)</span>
        <span class="s0">assert &lt;Py_ssize_t&gt;len(labels) == N</span>
    <span class="s0">out = np.empty(N)</span>
    <span class="s0">grp_sizes = np.ones(N, dtype=np.int64)</span>

    <span class="s0"># If we don't care about labels, can short-circuit later label</span>
    <span class="s0"># comparisons</span>
    <span class="s0">check_labels = labels is not None</span>

    <span class="s0"># For cases where a mask is not possible, we can avoid mask checks</span>
    <span class="s0">check_mask = not (iu_64_floating_obj_t is uint64_t or</span>
                      <span class="s0">(iu_64_floating_obj_t is int64_t and not is_datetimelike))</span>

    <span class="s0"># Copy values into new array in order to fill missing data</span>
    <span class="s0"># with mask, without obfuscating location of missing data</span>
    <span class="s0"># in values array</span>
    <span class="s0">if iu_64_floating_obj_t is object and values.dtype != np.object_:</span>
        <span class="s0">masked_vals = values.astype('O')</span>
    <span class="s0">else:</span>
        <span class="s0">masked_vals = values.copy()</span>

    <span class="s0">if iu_64_floating_obj_t is object:</span>
        <span class="s0">mask = missing.isnaobj(masked_vals)</span>
    <span class="s0">elif iu_64_floating_obj_t is int64_t and is_datetimelike:</span>
        <span class="s0">mask = (masked_vals == NPY_NAT).astype(np.uint8)</span>
    <span class="s0">elif iu_64_floating_obj_t is float64_t:</span>
        <span class="s0">mask = np.isnan(masked_vals).astype(np.uint8)</span>
    <span class="s0">else:</span>
        <span class="s0">mask = np.zeros(shape=len(masked_vals), dtype=np.uint8)</span>

    <span class="s0"># If `na_option == 'top'`, we want to assign the lowest rank</span>
    <span class="s0"># to NaN regardless of ascending/descending. So if ascending,</span>
    <span class="s0"># fill with lowest value of type to end up with lowest rank.</span>
    <span class="s0"># If descending, fill with highest value since descending</span>
    <span class="s0"># will flip the ordering to still end up with lowest rank.</span>
    <span class="s0"># Symmetric logic applies to `na_option == 'bottom'`</span>
    <span class="s0">nans_rank_highest = ascending ^ (na_option == 'top')</span>
    <span class="s0">nan_fill_val = get_rank_nan_fill_val[iu_64_floating_obj_t](nans_rank_highest)</span>
    <span class="s0">if nans_rank_highest:</span>
        <span class="s0">order = [masked_vals, mask]</span>
    <span class="s0">else:</span>
        <span class="s0">order = [masked_vals, ~(np.asarray(mask))]</span>

    <span class="s0">if check_labels:</span>
        <span class="s0">order.append(labels)</span>

    <span class="s0">np.putmask(masked_vals, mask, nan_fill_val)</span>
    <span class="s0"># putmask doesn't accept a memoryview, so we assign as a separate step</span>
    <span class="s0">masked_vals_memview = masked_vals</span>

    <span class="s0"># lexsort using labels, then mask, then actual values</span>
    <span class="s0"># each label corresponds to a different group value,</span>
    <span class="s0"># the mask helps you differentiate missing values before</span>
    <span class="s0"># performing sort on the actual values</span>
    <span class="s0">lexsort_indexer = np.lexsort(order).astype(np.intp, copy=False)</span>

    <span class="s0">if not ascending:</span>
        <span class="s0">lexsort_indexer = lexsort_indexer[::-1]</span>

    <span class="s0">with nogil:</span>
        <span class="s0">rank_sorted_1d(</span>
            <span class="s0">out,</span>
            <span class="s0">grp_sizes,</span>
            <span class="s0">lexsort_indexer,</span>
            <span class="s0">masked_vals_memview,</span>
            <span class="s0">mask,</span>
            <span class="s0">check_mask=check_mask,</span>
            <span class="s0">N=N,</span>
            <span class="s0">tiebreak=tiebreak,</span>
            <span class="s0">keep_na=keep_na,</span>
            <span class="s0">pct=pct,</span>
            <span class="s0">labels=labels,</span>
        <span class="s0">)</span>

    <span class="s0">return np.asarray(out)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">cdef void rank_sorted_1d(</span>
    <span class="s0">float64_t[::1] out,</span>
    <span class="s0">int64_t[::1] grp_sizes,</span>
    <span class="s0">const intp_t[:] sort_indexer,</span>
    <span class="s0"># Can make const with cython3 (https://github.com/cython/cython/issues/3222)</span>
    <span class="s0">iu_64_floating_obj_t[:] masked_vals,</span>
    <span class="s0">const uint8_t[:] mask,</span>
    <span class="s0">bint check_mask,</span>
    <span class="s0">Py_ssize_t N,</span>
    <span class="s0">TiebreakEnumType tiebreak=TIEBREAK_AVERAGE,</span>
    <span class="s0">bint keep_na=True,</span>
    <span class="s0">bint pct=False,</span>
    <span class="s0"># https://github.com/cython/cython/issues/1630, only trailing arguments can</span>
    <span class="s0"># currently be omitted for cdef functions, which is why we keep this at the end</span>
    <span class="s0">const intp_t[:] labels=None,</span>
<span class="s0">) nogil:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">See rank_1d.__doc__. Handles only actual ranking, so sorting and masking should</span>
    <span class="s0">be handled in the caller. Note that `out` and `grp_sizes` are modified inplace.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">out : float64_t[::1]</span>
        <span class="s0">Array to store computed ranks</span>
    <span class="s0">grp_sizes : int64_t[::1]</span>
        <span class="s0">Array to store group counts, only used if pct=True. Should only be None</span>
        <span class="s0">if labels is None.</span>
    <span class="s0">sort_indexer : intp_t[:]</span>
        <span class="s0">Array of indices which sorts masked_vals</span>
    <span class="s0">masked_vals : iu_64_floating_obj_t[:]</span>
        <span class="s0">The values input to rank_1d, with missing values replaced by fill values</span>
    <span class="s0">mask : uint8_t[:]</span>
        <span class="s0">Array where entries are True if the value is missing, False otherwise.</span>
    <span class="s0">check_mask : bool</span>
        <span class="s0">If False, assumes the mask is all False to skip mask indexing</span>
    <span class="s0">N : Py_ssize_t</span>
        <span class="s0">The number of elements to rank. Note: it is not always true that</span>
        <span class="s0">N == len(out) or N == len(masked_vals) (see `nancorr_spearman` usage for why)</span>
    <span class="s0">tiebreak : TiebreakEnumType, default TIEBREAK_AVERAGE</span>
        <span class="s0">See rank_1d.__doc__ for the different modes</span>
    <span class="s0">keep_na : bool, default True</span>
        <span class="s0">Whether or not to keep nulls</span>
    <span class="s0">pct : bool, default False</span>
        <span class="s0">Compute percentage rank of data within each group</span>
    <span class="s0">labels : See rank_1d.__doc__, default None. None implies all labels are the same.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, dups=0, sum_ranks=0,</span>
        <span class="s0">Py_ssize_t grp_start=0, grp_vals_seen=1, grp_na_count=0</span>
        <span class="s0">bint at_end, next_val_diff, group_changed, check_labels</span>
        <span class="s0">int64_t grp_size</span>

    <span class="s0">check_labels = labels is not None</span>

    <span class="s0"># Loop over the length of the value array</span>
    <span class="s0"># each incremental i value can be looked up in the lexsort_indexer</span>
    <span class="s0"># array that we sorted previously, which gives us the location of</span>
    <span class="s0"># that sorted value for retrieval back from the original</span>
    <span class="s0"># values / masked_vals arrays</span>
    <span class="s0"># TODO(cython3): de-duplicate once cython supports conditional nogil</span>
    <span class="s0">if iu_64_floating_obj_t is object:</span>
        <span class="s0">with gil:</span>
            <span class="s0">for i in range(N):</span>
                <span class="s0">at_end = i == N - 1</span>

                <span class="s0"># dups and sum_ranks will be incremented each loop where</span>
                <span class="s0"># the value / group remains the same, and should be reset</span>
                <span class="s0"># when either of those change. Used to calculate tiebreakers</span>
                <span class="s0">dups += 1</span>
                <span class="s0">sum_ranks += i - grp_start + 1</span>

                <span class="s0">next_val_diff = at_end or are_diff(masked_vals[sort_indexer[i]],</span>
                                                   <span class="s0">masked_vals[sort_indexer[i+1]])</span>

                <span class="s0"># We'll need this check later anyway to determine group size, so just</span>
                <span class="s0"># compute it here since shortcircuiting won't help</span>
                <span class="s0">group_changed = at_end or (check_labels and</span>
                                           <span class="s0">(labels[sort_indexer[i]]</span>
                                            <span class="s0">!= labels[sort_indexer[i+1]]))</span>

                <span class="s0"># Update out only when there is a transition of values or labels.</span>
                <span class="s0"># When a new value or group is encountered, go back #dups steps(</span>
                <span class="s0"># the number of occurrence of current value) and assign the ranks</span>
                <span class="s0"># based on the starting index of the current group (grp_start)</span>
                <span class="s0"># and the current index</span>
                <span class="s0">if (next_val_diff or group_changed or (check_mask and</span>
                                                       <span class="s0">(mask[sort_indexer[i]]</span>
                                                        <span class="s0">^ mask[sort_indexer[i+1]]))):</span>

                    <span class="s0"># If keep_na, check for missing values and assign back</span>
                    <span class="s0"># to the result where appropriate</span>
                    <span class="s0">if keep_na and check_mask and mask[sort_indexer[i]]:</span>
                        <span class="s0">grp_na_count = dups</span>
                        <span class="s0">for j in range(i - dups + 1, i + 1):</span>
                            <span class="s0">out[sort_indexer[j]] = NaN</span>
                    <span class="s0">elif tiebreak == TIEBREAK_AVERAGE:</span>
                        <span class="s0">for j in range(i - dups + 1, i + 1):</span>
                            <span class="s0">out[sort_indexer[j]] = sum_ranks / &lt;float64_t&gt;dups</span>
                    <span class="s0">elif tiebreak == TIEBREAK_MIN:</span>
                        <span class="s0">for j in range(i - dups + 1, i + 1):</span>
                            <span class="s0">out[sort_indexer[j]] = i - grp_start - dups + 2</span>
                    <span class="s0">elif tiebreak == TIEBREAK_MAX:</span>
                        <span class="s0">for j in range(i - dups + 1, i + 1):</span>
                            <span class="s0">out[sort_indexer[j]] = i - grp_start + 1</span>

                    <span class="s0"># With n as the previous rank in the group and m as the number</span>
                    <span class="s0"># of duplicates in this stretch, if TIEBREAK_FIRST and ascending,</span>
                    <span class="s0"># then rankings should be n + 1, n + 2 ... n + m</span>
                    <span class="s0">elif tiebreak == TIEBREAK_FIRST:</span>
                        <span class="s0">for j in range(i - dups + 1, i + 1):</span>
                            <span class="s0">out[sort_indexer[j]] = j + 1 - grp_start</span>

                    <span class="s0"># If TIEBREAK_FIRST and descending, the ranking should be</span>
                    <span class="s0"># n + m, n + (m - 1) ... n + 1. This is equivalent to</span>
                    <span class="s0"># (i - dups + 1) + (i - j + 1) - grp_start</span>
                    <span class="s0">elif tiebreak == TIEBREAK_FIRST_DESCENDING:</span>
                        <span class="s0">for j in range(i - dups + 1, i + 1):</span>
                            <span class="s0">out[sort_indexer[j]] = 2 * i - j - dups + 2 - grp_start</span>
                    <span class="s0">elif tiebreak == TIEBREAK_DENSE:</span>
                        <span class="s0">for j in range(i - dups + 1, i + 1):</span>
                            <span class="s0">out[sort_indexer[j]] = grp_vals_seen</span>

                    <span class="s0"># Look forward to the next value (using the sorting in</span>
                    <span class="s0"># lexsort_indexer). If the value does not equal the current</span>
                    <span class="s0"># value then we need to reset the dups and sum_ranks, knowing</span>
                    <span class="s0"># that a new value is coming up. The conditional also needs</span>
                    <span class="s0"># to handle nan equality and the end of iteration. If group</span>
                    <span class="s0"># changes we do not record seeing a new value in the group</span>
                    <span class="s0">if not group_changed and (next_val_diff or (check_mask and</span>
                                              <span class="s0">(mask[sort_indexer[i]]</span>
                                               <span class="s0">^ mask[sort_indexer[i+1]]))):</span>
                        <span class="s0">dups = sum_ranks = 0</span>
                        <span class="s0">grp_vals_seen += 1</span>

                    <span class="s0"># Similar to the previous conditional, check now if we are</span>
                    <span class="s0"># moving to a new group. If so, keep track of the index where</span>
                    <span class="s0"># the new group occurs, so the tiebreaker calculations can</span>
                    <span class="s0"># decrement that from their position. Fill in the size of each</span>
                    <span class="s0"># group encountered (used by pct calculations later). Also be</span>
                    <span class="s0"># sure to reset any of the items helping to calculate dups</span>
                    <span class="s0">if group_changed:</span>

                        <span class="s0"># If not dense tiebreak, group size used to compute</span>
                        <span class="s0"># percentile will be # of non-null elements in group</span>
                        <span class="s0">if tiebreak != TIEBREAK_DENSE:</span>
                            <span class="s0">grp_size = i - grp_start + 1 - grp_na_count</span>

                        <span class="s0"># Otherwise, it will be the number of distinct values</span>
                        <span class="s0"># in the group, subtracting 1 if NaNs are present</span>
                        <span class="s0"># since that is a distinct value we shouldn't count</span>
                        <span class="s0">else:</span>
                            <span class="s0">grp_size = grp_vals_seen - (grp_na_count &gt; 0)</span>

                        <span class="s0">for j in range(grp_start, i + 1):</span>
                            <span class="s0">grp_sizes[sort_indexer[j]] = grp_size</span>

                        <span class="s0">dups = sum_ranks = 0</span>
                        <span class="s0">grp_na_count = 0</span>
                        <span class="s0">grp_start = i + 1</span>
                        <span class="s0">grp_vals_seen = 1</span>
    <span class="s0">else:</span>
        <span class="s0">for i in range(N):</span>
            <span class="s0">at_end = i == N - 1</span>

            <span class="s0"># dups and sum_ranks will be incremented each loop where</span>
            <span class="s0"># the value / group remains the same, and should be reset</span>
            <span class="s0"># when either of those change. Used to calculate tiebreakers</span>
            <span class="s0">dups += 1</span>
            <span class="s0">sum_ranks += i - grp_start + 1</span>

            <span class="s0">next_val_diff = at_end or (masked_vals[sort_indexer[i]]</span>
                                       <span class="s0">!= masked_vals[sort_indexer[i+1]])</span>

            <span class="s0"># We'll need this check later anyway to determine group size, so just</span>
            <span class="s0"># compute it here since shortcircuiting won't help</span>
            <span class="s0">group_changed = at_end or (check_labels and</span>
                                       <span class="s0">(labels[sort_indexer[i]]</span>
                                        <span class="s0">!= labels[sort_indexer[i+1]]))</span>

            <span class="s0"># Update out only when there is a transition of values or labels.</span>
            <span class="s0"># When a new value or group is encountered, go back #dups steps(</span>
            <span class="s0"># the number of occurrence of current value) and assign the ranks</span>
            <span class="s0"># based on the starting index of the current group (grp_start)</span>
            <span class="s0"># and the current index</span>
            <span class="s0">if (next_val_diff or group_changed</span>
                <span class="s0">or (check_mask and</span>
                    <span class="s0">(mask[sort_indexer[i]] ^ mask[sort_indexer[i+1]]))):</span>

                <span class="s0"># If keep_na, check for missing values and assign back</span>
                <span class="s0"># to the result where appropriate</span>
                <span class="s0">if keep_na and check_mask and mask[sort_indexer[i]]:</span>
                    <span class="s0">grp_na_count = dups</span>
                    <span class="s0">for j in range(i - dups + 1, i + 1):</span>
                        <span class="s0">out[sort_indexer[j]] = NaN</span>
                <span class="s0">elif tiebreak == TIEBREAK_AVERAGE:</span>
                    <span class="s0">for j in range(i - dups + 1, i + 1):</span>
                        <span class="s0">out[sort_indexer[j]] = sum_ranks / &lt;float64_t&gt;dups</span>
                <span class="s0">elif tiebreak == TIEBREAK_MIN:</span>
                    <span class="s0">for j in range(i - dups + 1, i + 1):</span>
                        <span class="s0">out[sort_indexer[j]] = i - grp_start - dups + 2</span>
                <span class="s0">elif tiebreak == TIEBREAK_MAX:</span>
                    <span class="s0">for j in range(i - dups + 1, i + 1):</span>
                        <span class="s0">out[sort_indexer[j]] = i - grp_start + 1</span>

                <span class="s0"># With n as the previous rank in the group and m as the number</span>
                <span class="s0"># of duplicates in this stretch, if TIEBREAK_FIRST and ascending,</span>
                <span class="s0"># then rankings should be n + 1, n + 2 ... n + m</span>
                <span class="s0">elif tiebreak == TIEBREAK_FIRST:</span>
                    <span class="s0">for j in range(i - dups + 1, i + 1):</span>
                        <span class="s0">out[sort_indexer[j]] = j + 1 - grp_start</span>

                <span class="s0"># If TIEBREAK_FIRST and descending, the ranking should be</span>
                <span class="s0"># n + m, n + (m - 1) ... n + 1. This is equivalent to</span>
                <span class="s0"># (i - dups + 1) + (i - j + 1) - grp_start</span>
                <span class="s0">elif tiebreak == TIEBREAK_FIRST_DESCENDING:</span>
                    <span class="s0">for j in range(i - dups + 1, i + 1):</span>
                        <span class="s0">out[sort_indexer[j]] = 2 * i - j - dups + 2 - grp_start</span>
                <span class="s0">elif tiebreak == TIEBREAK_DENSE:</span>
                    <span class="s0">for j in range(i - dups + 1, i + 1):</span>
                        <span class="s0">out[sort_indexer[j]] = grp_vals_seen</span>

                <span class="s0"># Look forward to the next value (using the sorting in</span>
                <span class="s0"># lexsort_indexer). If the value does not equal the current</span>
                <span class="s0"># value then we need to reset the dups and sum_ranks, knowing</span>
                <span class="s0"># that a new value is coming up. The conditional also needs</span>
                <span class="s0"># to handle nan equality and the end of iteration. If group</span>
                <span class="s0"># changes we do not record seeing a new value in the group</span>
                <span class="s0">if not group_changed and (next_val_diff</span>
                                          <span class="s0">or (check_mask and</span>
                                              <span class="s0">(mask[sort_indexer[i]]</span>
                                               <span class="s0">^ mask[sort_indexer[i+1]]))):</span>
                    <span class="s0">dups = sum_ranks = 0</span>
                    <span class="s0">grp_vals_seen += 1</span>

                <span class="s0"># Similar to the previous conditional, check now if we are</span>
                <span class="s0"># moving to a new group. If so, keep track of the index where</span>
                <span class="s0"># the new group occurs, so the tiebreaker calculations can</span>
                <span class="s0"># decrement that from their position. Fill in the size of each</span>
                <span class="s0"># group encountered (used by pct calculations later). Also be</span>
                <span class="s0"># sure to reset any of the items helping to calculate dups</span>
                <span class="s0">if group_changed:</span>

                    <span class="s0"># If not dense tiebreak, group size used to compute</span>
                    <span class="s0"># percentile will be # of non-null elements in group</span>
                    <span class="s0">if tiebreak != TIEBREAK_DENSE:</span>
                        <span class="s0">grp_size = i - grp_start + 1 - grp_na_count</span>

                    <span class="s0"># Otherwise, it will be the number of distinct values</span>
                    <span class="s0"># in the group, subtracting 1 if NaNs are present</span>
                    <span class="s0"># since that is a distinct value we shouldn't count</span>
                    <span class="s0">else:</span>
                        <span class="s0">grp_size = grp_vals_seen - (grp_na_count &gt; 0)</span>

                    <span class="s0">for j in range(grp_start, i + 1):</span>
                        <span class="s0">grp_sizes[sort_indexer[j]] = grp_size</span>

                    <span class="s0">dups = sum_ranks = 0</span>
                    <span class="s0">grp_na_count = 0</span>
                    <span class="s0">grp_start = i + 1</span>
                    <span class="s0">grp_vals_seen = 1</span>

    <span class="s0">if pct:</span>
        <span class="s0">for i in range(N):</span>
            <span class="s0">if grp_sizes[i] != 0:</span>
                <span class="s0">out[i] = out[i] / grp_sizes[i]</span>


<span class="s0">def rank_2d(</span>
    <span class="s0">ndarray[iu_64_floating_obj_t, ndim=2] in_arr,</span>
    <span class="s0">int axis=0,</span>
    <span class="s0">bint is_datetimelike=False,</span>
    <span class="s0">ties_method=&quot;average&quot;,</span>
    <span class="s0">bint ascending=True,</span>
    <span class="s0">na_option=&quot;keep&quot;,</span>
    <span class="s0">bint pct=False,</span>
<span class="s0">):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Fast NaN-friendly version of ``scipy.stats.rankdata``.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t k, n, col</span>
        <span class="s0">float64_t[::1, :] out  # Column-major so columns are contiguous</span>
        <span class="s0">int64_t[::1] grp_sizes</span>
        <span class="s0">ndarray[iu_64_floating_obj_t, ndim=2] values</span>
        <span class="s0">iu_64_floating_obj_t[:, :] masked_vals</span>
        <span class="s0">intp_t[:, :] sort_indexer</span>
        <span class="s0">uint8_t[:, :] mask</span>
        <span class="s0">TiebreakEnumType tiebreak</span>
        <span class="s0">bint check_mask, keep_na, nans_rank_highest</span>
        <span class="s0">iu_64_floating_obj_t nan_fill_val</span>

    <span class="s0">tiebreak = tiebreakers[ties_method]</span>
    <span class="s0">if tiebreak == TIEBREAK_FIRST:</span>
        <span class="s0">if not ascending:</span>
            <span class="s0">tiebreak = TIEBREAK_FIRST_DESCENDING</span>

    <span class="s0">keep_na = na_option == 'keep'</span>

    <span class="s0"># For cases where a mask is not possible, we can avoid mask checks</span>
    <span class="s0">check_mask = not (iu_64_floating_obj_t is uint64_t or</span>
                      <span class="s0">(iu_64_floating_obj_t is int64_t and not is_datetimelike))</span>

    <span class="s0">if axis == 1:</span>
        <span class="s0">values = np.asarray(in_arr).T.copy()</span>
    <span class="s0">else:</span>
        <span class="s0">values = np.asarray(in_arr).copy()</span>

    <span class="s0">if iu_64_floating_obj_t is object:</span>
        <span class="s0">if values.dtype != np.object_:</span>
            <span class="s0">values = values.astype('O')</span>

    <span class="s0">nans_rank_highest = ascending ^ (na_option == 'top')</span>
    <span class="s0">if check_mask:</span>
        <span class="s0">nan_fill_val = get_rank_nan_fill_val[iu_64_floating_obj_t](nans_rank_highest)</span>

        <span class="s0">if iu_64_floating_obj_t is object:</span>
            <span class="s0">mask = missing.isnaobj2d(values).view(np.uint8)</span>
        <span class="s0">elif iu_64_floating_obj_t is float64_t:</span>
            <span class="s0">mask = np.isnan(values).view(np.uint8)</span>

        <span class="s0"># int64 and datetimelike</span>
        <span class="s0">else:</span>
            <span class="s0">mask = (values == NPY_NAT).view(np.uint8)</span>
        <span class="s0">np.putmask(values, mask, nan_fill_val)</span>
    <span class="s0">else:</span>
        <span class="s0">mask = np.zeros_like(values, dtype=np.uint8)</span>

    <span class="s0">if nans_rank_highest:</span>
        <span class="s0">order = (values, mask)</span>
    <span class="s0">else:</span>
        <span class="s0">order = (values, ~np.asarray(mask))</span>

    <span class="s0">n, k = (&lt;object&gt;values).shape</span>
    <span class="s0">out = np.empty((n, k), dtype='f8', order='F')</span>
    <span class="s0">grp_sizes = np.ones(n, dtype=np.int64)</span>

    <span class="s0"># lexsort is slower, so only use if we need to worry about the mask</span>
    <span class="s0">if check_mask:</span>
        <span class="s0">sort_indexer = np.lexsort(order, axis=0).astype(np.intp, copy=False)</span>
    <span class="s0">else:</span>
        <span class="s0">kind = &quot;stable&quot; if ties_method == &quot;first&quot; else None</span>
        <span class="s0">sort_indexer = values.argsort(axis=0, kind=kind).astype(np.intp, copy=False)</span>

    <span class="s0">if not ascending:</span>
        <span class="s0">sort_indexer = sort_indexer[::-1, :]</span>

    <span class="s0"># putmask doesn't accept a memoryview, so we assign in a separate step</span>
    <span class="s0">masked_vals = values</span>
    <span class="s0">with nogil:</span>
        <span class="s0">for col in range(k):</span>
            <span class="s0">rank_sorted_1d(</span>
                <span class="s0">out[:, col],</span>
                <span class="s0">grp_sizes,</span>
                <span class="s0">sort_indexer[:, col],</span>
                <span class="s0">masked_vals[:, col],</span>
                <span class="s0">mask[:, col],</span>
                <span class="s0">check_mask=check_mask,</span>
                <span class="s0">N=n,</span>
                <span class="s0">tiebreak=tiebreak,</span>
                <span class="s0">keep_na=keep_na,</span>
                <span class="s0">pct=pct,</span>
            <span class="s0">)</span>

    <span class="s0">if axis == 1:</span>
        <span class="s0">return np.asarray(out.T)</span>
    <span class="s0">else:</span>
        <span class="s0">return np.asarray(out)</span>


<span class="s0">ctypedef fused diff_t:</span>
    <span class="s0">float64_t</span>
    <span class="s0">float32_t</span>
    <span class="s0">int8_t</span>
    <span class="s0">int16_t</span>
    <span class="s0">int32_t</span>
    <span class="s0">int64_t</span>

<span class="s0">ctypedef fused out_t:</span>
    <span class="s0">float32_t</span>
    <span class="s0">float64_t</span>
    <span class="s0">int64_t</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def diff_2d(</span>
    <span class="s0">ndarray[diff_t, ndim=2] arr,  # TODO(cython3) update to &quot;const diff_t[:, :] arr&quot;</span>
    <span class="s0">ndarray[out_t, ndim=2] out,</span>
    <span class="s0">Py_ssize_t periods,</span>
    <span class="s0">int axis,</span>
    <span class="s0">bint datetimelike=False,</span>
<span class="s0">):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, j, sx, sy, start, stop</span>
        <span class="s0">bint f_contig = arr.flags.f_contiguous</span>
        <span class="s0"># bint f_contig = arr.is_f_contig()  # TODO(cython3)</span>
        <span class="s0">diff_t left, right</span>

    <span class="s0"># Disable for unsupported dtype combinations,</span>
    <span class="s0">#  see https://github.com/cython/cython/issues/2646</span>
    <span class="s0">if (out_t is float32_t</span>
            <span class="s0">and not (diff_t is float32_t or diff_t is int8_t or diff_t is int16_t)):</span>
        <span class="s0">raise NotImplementedError  # pragma: no cover</span>
    <span class="s0">elif (out_t is float64_t</span>
          <span class="s0">and (diff_t is float32_t or diff_t is int8_t or diff_t is int16_t)):</span>
        <span class="s0">raise NotImplementedError  # pragma: no cover</span>
    <span class="s0">elif out_t is int64_t and diff_t is not int64_t:</span>
        <span class="s0"># We only have out_t of int64_t if we have datetimelike</span>
        <span class="s0">raise NotImplementedError  # pragma: no cover</span>
    <span class="s0">else:</span>
        <span class="s0"># We put this inside an indented else block to avoid cython build</span>
        <span class="s0">#  warnings about unreachable code</span>
        <span class="s0">sx, sy = (&lt;object&gt;arr).shape</span>
        <span class="s0">with nogil:</span>
            <span class="s0">if f_contig:</span>
                <span class="s0">if axis == 0:</span>
                    <span class="s0">if periods &gt;= 0:</span>
                        <span class="s0">start, stop = periods, sx</span>
                    <span class="s0">else:</span>
                        <span class="s0">start, stop = 0, sx + periods</span>
                    <span class="s0">for j in range(sy):</span>
                        <span class="s0">for i in range(start, stop):</span>
                            <span class="s0">left = arr[i, j]</span>
                            <span class="s0">right = arr[i - periods, j]</span>
                            <span class="s0">if out_t is int64_t and datetimelike:</span>
                                <span class="s0">if left == NPY_NAT or right == NPY_NAT:</span>
                                    <span class="s0">out[i, j] = NPY_NAT</span>
                                <span class="s0">else:</span>
                                    <span class="s0">out[i, j] = left - right</span>
                            <span class="s0">else:</span>
                                <span class="s0">out[i, j] = left - right</span>
                <span class="s0">else:</span>
                    <span class="s0">if periods &gt;= 0:</span>
                        <span class="s0">start, stop = periods, sy</span>
                    <span class="s0">else:</span>
                        <span class="s0">start, stop = 0, sy + periods</span>
                    <span class="s0">for j in range(start, stop):</span>
                        <span class="s0">for i in range(sx):</span>
                            <span class="s0">left = arr[i, j]</span>
                            <span class="s0">right = arr[i, j - periods]</span>
                            <span class="s0">if out_t is int64_t and datetimelike:</span>
                                <span class="s0">if left == NPY_NAT or right == NPY_NAT:</span>
                                    <span class="s0">out[i, j] = NPY_NAT</span>
                                <span class="s0">else:</span>
                                    <span class="s0">out[i, j] = left - right</span>
                            <span class="s0">else:</span>
                                <span class="s0">out[i, j] = left - right</span>
            <span class="s0">else:</span>
                <span class="s0">if axis == 0:</span>
                    <span class="s0">if periods &gt;= 0:</span>
                        <span class="s0">start, stop = periods, sx</span>
                    <span class="s0">else:</span>
                        <span class="s0">start, stop = 0, sx + periods</span>
                    <span class="s0">for i in range(start, stop):</span>
                        <span class="s0">for j in range(sy):</span>
                            <span class="s0">left = arr[i, j]</span>
                            <span class="s0">right = arr[i - periods, j]</span>
                            <span class="s0">if out_t is int64_t and datetimelike:</span>
                                <span class="s0">if left == NPY_NAT or right == NPY_NAT:</span>
                                    <span class="s0">out[i, j] = NPY_NAT</span>
                                <span class="s0">else:</span>
                                    <span class="s0">out[i, j] = left - right</span>
                            <span class="s0">else:</span>
                                <span class="s0">out[i, j] = left - right</span>
                <span class="s0">else:</span>
                    <span class="s0">if periods &gt;= 0:</span>
                        <span class="s0">start, stop = periods, sy</span>
                    <span class="s0">else:</span>
                        <span class="s0">start, stop = 0, sy + periods</span>
                    <span class="s0">for i in range(sx):</span>
                        <span class="s0">for j in range(start, stop):</span>
                            <span class="s0">left = arr[i, j]</span>
                            <span class="s0">right = arr[i, j - periods]</span>
                            <span class="s0">if out_t is int64_t and datetimelike:</span>
                                <span class="s0">if left == NPY_NAT or right == NPY_NAT:</span>
                                    <span class="s0">out[i, j] = NPY_NAT</span>
                                <span class="s0">else:</span>
                                    <span class="s0">out[i, j] = left - right</span>
                            <span class="s0">else:</span>
                                <span class="s0">out[i, j] = left - right</span>


<span class="s0"># generated from template</span>
<span class="s0">include &quot;algos_common_helper.pxi&quot;</span>
<span class="s0">include &quot;algos_take_helper.pxi&quot;</span>
</pre>
</body>
</html>