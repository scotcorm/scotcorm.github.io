<html>
<head>
<title>_polybase.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_polybase.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Abstract base class for the various polynomial Classes. 
 
The ABCPolyBase class provides the methods needed to implement the common API 
for the various polynomial classes. It operates as a mixin, but uses the 
abc module from the stdlib, hence it is only available for Python &gt;= 2.6. 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">abc</span>
<span class="s2">import </span><span class="s1">numbers</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">polyutils </span><span class="s2">as </span><span class="s1">pu</span>

<span class="s1">__all__ = [</span><span class="s3">'ABCPolyBase'</span><span class="s1">]</span>

<span class="s2">class </span><span class="s1">ABCPolyBase(abc.ABC):</span>
    <span class="s0">&quot;&quot;&quot;An abstract base class for immutable series classes. 
 
    ABCPolyBase provides the standard Python numerical methods 
    '+', '-', '*', '//', '%', 'divmod', '**', and '()' along with the 
    methods listed below. 
 
    .. versionadded:: 1.9.0 
 
    Parameters 
    ---------- 
    coef : array_like 
        Series coefficients in order of increasing degree, i.e., 
        ``(1, 2, 3)`` gives ``1*P_0(x) + 2*P_1(x) + 3*P_2(x)``, where 
        ``P_i`` is the basis polynomials of degree ``i``. 
    domain : (2,) array_like, optional 
        Domain to use. The interval ``[domain[0], domain[1]]`` is mapped 
        to the interval ``[window[0], window[1]]`` by shifting and scaling. 
        The default value is the derived class domain. 
    window : (2,) array_like, optional 
        Window, see domain for its use. The default value is the 
        derived class window. 
 
    Attributes 
    ---------- 
    coef : (N,) ndarray 
        Series coefficients in order of increasing degree. 
    domain : (2,) ndarray 
        Domain that is mapped to window. 
    window : (2,) ndarray 
        Window that domain is mapped to. 
 
    Class Attributes 
    ---------------- 
    maxpower : int 
        Maximum power allowed, i.e., the largest number ``n`` such that 
        ``p(x)**n`` is allowed. This is to limit runaway polynomial size. 
    domain : (2,) ndarray 
        Default domain of the class. 
    window : (2,) ndarray 
        Default window of the class. 
 
    &quot;&quot;&quot;</span>

    <span class="s4"># Not hashable</span>
    <span class="s1">__hash__ = </span><span class="s2">None</span>

    <span class="s4"># Opt out of numpy ufuncs and Python ops with ndarray subclasses.</span>
    <span class="s1">__array_ufunc__ = </span><span class="s2">None</span>

    <span class="s4"># Limit runaway size. T_n^m has degree n*m</span>
    <span class="s1">maxpower = </span><span class="s5">100</span>

    <span class="s4"># Unicode character mappings for improved __str__</span>
    <span class="s1">_superscript_mapping = str.maketrans({</span>
        <span class="s3">&quot;0&quot;</span><span class="s1">: </span><span class="s3">&quot;⁰&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;1&quot;</span><span class="s1">: </span><span class="s3">&quot;¹&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;2&quot;</span><span class="s1">: </span><span class="s3">&quot;²&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;3&quot;</span><span class="s1">: </span><span class="s3">&quot;³&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;4&quot;</span><span class="s1">: </span><span class="s3">&quot;⁴&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;5&quot;</span><span class="s1">: </span><span class="s3">&quot;⁵&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;6&quot;</span><span class="s1">: </span><span class="s3">&quot;⁶&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;7&quot;</span><span class="s1">: </span><span class="s3">&quot;⁷&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;8&quot;</span><span class="s1">: </span><span class="s3">&quot;⁸&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;9&quot;</span><span class="s1">: </span><span class="s3">&quot;⁹&quot;</span>
    <span class="s1">})</span>
    <span class="s1">_subscript_mapping = str.maketrans({</span>
        <span class="s3">&quot;0&quot;</span><span class="s1">: </span><span class="s3">&quot;₀&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;1&quot;</span><span class="s1">: </span><span class="s3">&quot;₁&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;2&quot;</span><span class="s1">: </span><span class="s3">&quot;₂&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;3&quot;</span><span class="s1">: </span><span class="s3">&quot;₃&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;4&quot;</span><span class="s1">: </span><span class="s3">&quot;₄&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;5&quot;</span><span class="s1">: </span><span class="s3">&quot;₅&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;6&quot;</span><span class="s1">: </span><span class="s3">&quot;₆&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;7&quot;</span><span class="s1">: </span><span class="s3">&quot;₇&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;8&quot;</span><span class="s1">: </span><span class="s3">&quot;₈&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;9&quot;</span><span class="s1">: </span><span class="s3">&quot;₉&quot;</span>
    <span class="s1">})</span>
    <span class="s4"># Some fonts don't support full unicode character ranges necessary for</span>
    <span class="s4"># the full set of superscripts and subscripts, including common/default</span>
    <span class="s4"># fonts in Windows shells/terminals. Therefore, default to ascii-only</span>
    <span class="s4"># printing on windows.</span>
    <span class="s1">_use_unicode = </span><span class="s2">not </span><span class="s1">os.name == </span><span class="s3">'nt'</span>

    <span class="s1">@property</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">domain(self):</span>
        <span class="s2">pass</span>

    <span class="s1">@property</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">window(self):</span>
        <span class="s2">pass</span>

    <span class="s1">@property</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">basis_name(self):</span>
        <span class="s2">pass</span>

    <span class="s1">@staticmethod</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">_add(c1</span><span class="s2">, </span><span class="s1">c2):</span>
        <span class="s2">pass</span>

    <span class="s1">@staticmethod</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">_sub(c1</span><span class="s2">, </span><span class="s1">c2):</span>
        <span class="s2">pass</span>

    <span class="s1">@staticmethod</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">_mul(c1</span><span class="s2">, </span><span class="s1">c2):</span>
        <span class="s2">pass</span>

    <span class="s1">@staticmethod</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">_div(c1</span><span class="s2">, </span><span class="s1">c2):</span>
        <span class="s2">pass</span>

    <span class="s1">@staticmethod</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">_pow(c</span><span class="s2">, </span><span class="s1">pow</span><span class="s2">, </span><span class="s1">maxpower=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">pass</span>

    <span class="s1">@staticmethod</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">_val(x</span><span class="s2">, </span><span class="s1">c):</span>
        <span class="s2">pass</span>

    <span class="s1">@staticmethod</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">_int(c</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">lbnd</span><span class="s2">, </span><span class="s1">scl):</span>
        <span class="s2">pass</span>

    <span class="s1">@staticmethod</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">_der(c</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">scl):</span>
        <span class="s2">pass</span>

    <span class="s1">@staticmethod</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">_fit(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">deg</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">, </span><span class="s1">full):</span>
        <span class="s2">pass</span>

    <span class="s1">@staticmethod</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">_line(off</span><span class="s2">, </span><span class="s1">scl):</span>
        <span class="s2">pass</span>

    <span class="s1">@staticmethod</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">_roots(c):</span>
        <span class="s2">pass</span>

    <span class="s1">@staticmethod</span>
    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">_fromroots(r):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">has_samecoef(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot;Check if coefficients match. 
 
        .. versionadded:: 1.6.0 
 
        Parameters 
        ---------- 
        other : class instance 
            The other class must have the ``coef`` attribute. 
 
        Returns 
        ------- 
        bool : boolean 
            True if the coefficients are the same, False otherwise. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(self.coef) != len(other.coef):</span>
            <span class="s2">return False</span>
        <span class="s2">elif not </span><span class="s1">np.all(self.coef == other.coef):</span>
            <span class="s2">return False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">has_samedomain(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot;Check if domains match. 
 
        .. versionadded:: 1.6.0 
 
        Parameters 
        ---------- 
        other : class instance 
            The other class must have the ``domain`` attribute. 
 
        Returns 
        ------- 
        bool : boolean 
            True if the domains are the same, False otherwise. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.all(self.domain == other.domain)</span>

    <span class="s2">def </span><span class="s1">has_samewindow(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot;Check if windows match. 
 
        .. versionadded:: 1.6.0 
 
        Parameters 
        ---------- 
        other : class instance 
            The other class must have the ``window`` attribute. 
 
        Returns 
        ------- 
        bool : boolean 
            True if the windows are the same, False otherwise. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.all(self.window == other.window)</span>

    <span class="s2">def </span><span class="s1">has_sametype(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot;Check if types match. 
 
        .. versionadded:: 1.7.0 
 
        Parameters 
        ---------- 
        other : object 
            Class instance. 
 
        Returns 
        ------- 
        bool : boolean 
            True if other is same class as self 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">self.__class__)</span>

    <span class="s2">def </span><span class="s1">_get_coefficients(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot;Interpret other as polynomial coefficients. 
 
        The `other` argument is checked to see if it is of the same 
        class as self with identical domain and window. If so, 
        return its coefficients, otherwise return `other`. 
 
        .. versionadded:: 1.9.0 
 
        Parameters 
        ---------- 
        other : anything 
            Object to be checked. 
 
        Returns 
        ------- 
        coef 
            The coefficients of`other` if it is a compatible instance, 
            of ABCPolyBase, otherwise `other`. 
 
        Raises 
        ------ 
        TypeError 
            When `other` is an incompatible instance of ABCPolyBase. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">ABCPolyBase):</span>
            <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">self.__class__):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Polynomial types differ&quot;</span><span class="s1">)</span>
            <span class="s2">elif not </span><span class="s1">np.all(self.domain == other.domain):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Domains differ&quot;</span><span class="s1">)</span>
            <span class="s2">elif not </span><span class="s1">np.all(self.window == other.window):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Windows differ&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">other.coef</span>
        <span class="s2">return </span><span class="s1">other</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">coef</span><span class="s2">, </span><span class="s1">domain=</span><span class="s2">None, </span><span class="s1">window=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">[coef] = pu.as_series([coef]</span><span class="s2">, </span><span class="s1">trim=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self.coef = coef</span>

        <span class="s2">if </span><span class="s1">domain </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">[domain] = pu.as_series([domain]</span><span class="s2">, </span><span class="s1">trim=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">len(domain) != </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Domain has wrong number of elements.&quot;</span><span class="s1">)</span>
            <span class="s1">self.domain = domain</span>

        <span class="s2">if </span><span class="s1">window </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">[window] = pu.as_series([window]</span><span class="s2">, </span><span class="s1">trim=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">len(window) != </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Window has wrong number of elements.&quot;</span><span class="s1">)</span>
            <span class="s1">self.window = window</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">coef = repr(self.coef)[</span><span class="s5">6</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">domain = repr(self.domain)[</span><span class="s5">6</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">window = repr(self.window)[</span><span class="s5">6</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">name = self.__class__.__name__</span>
        <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">(</span><span class="s2">{</span><span class="s1">coef</span><span class="s2">}</span><span class="s3">, domain=</span><span class="s2">{</span><span class="s1">domain</span><span class="s2">}</span><span class="s3">, window=</span><span class="s2">{</span><span class="s1">window</span><span class="s2">}</span><span class="s3">)&quot;</span>

    <span class="s2">def </span><span class="s1">__format__(self</span><span class="s2">, </span><span class="s1">fmt_str):</span>
        <span class="s2">if </span><span class="s1">fmt_str == </span><span class="s3">''</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.__str__()</span>
        <span class="s2">if </span><span class="s1">fmt_str </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">'ascii'</span><span class="s2">, </span><span class="s3">'unicode'</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">f&quot;Unsupported format string '</span><span class="s2">{</span><span class="s1">fmt_str</span><span class="s2">}</span><span class="s3">' passed to &quot;</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self.__class__</span><span class="s2">}</span><span class="s3">.__format__. Valid options are &quot;</span>
                <span class="s3">f&quot;'ascii' and 'unicode'&quot;</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">fmt_str == </span><span class="s3">'ascii'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._generate_string(self._str_term_ascii)</span>
        <span class="s2">return </span><span class="s1">self._generate_string(self._str_term_unicode)</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">if </span><span class="s1">self._use_unicode:</span>
            <span class="s2">return </span><span class="s1">self._generate_string(self._str_term_unicode)</span>
        <span class="s2">return </span><span class="s1">self._generate_string(self._str_term_ascii)</span>

    <span class="s2">def </span><span class="s1">_generate_string(self</span><span class="s2">, </span><span class="s1">term_method):</span>
        <span class="s0">&quot;&quot;&quot; 
        Generate the full string representation of the polynomial, using 
        ``term_method`` to generate each polynomial term. 
        &quot;&quot;&quot;</span>
        <span class="s4"># Get configuration for line breaks</span>
        <span class="s1">linewidth = np.get_printoptions().get(</span><span class="s3">'linewidth'</span><span class="s2">, </span><span class="s5">75</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">linewidth &lt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">linewidth = </span><span class="s5">1</span>
        <span class="s1">out = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self.coef[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">coef </span><span class="s2">in </span><span class="s1">enumerate(self.coef[</span><span class="s5">1</span><span class="s1">:]):</span>
            <span class="s1">out += </span><span class="s3">&quot; &quot;</span>
            <span class="s1">power = str(i + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s4"># Polynomial coefficient</span>
            <span class="s4"># The coefficient array can be an object array with elements that</span>
            <span class="s4"># will raise a TypeError with &gt;= 0 (e.g. strings or Python</span>
            <span class="s4"># complex). In this case, represent the coefficient as-is.</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">coef &gt;= </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">next_term = </span><span class="s3">f&quot;+ </span><span class="s2">{</span><span class="s1">coef</span><span class="s2">}</span><span class="s3">&quot;</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">next_term = </span><span class="s3">f&quot;- </span><span class="s2">{</span><span class="s1">-coef</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s2">except </span><span class="s1">TypeError:</span>
                <span class="s1">next_term = </span><span class="s3">f&quot;+ </span><span class="s2">{</span><span class="s1">coef</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s4"># Polynomial term</span>
            <span class="s1">next_term += term_method(power</span><span class="s2">, </span><span class="s3">&quot;x&quot;</span><span class="s1">)</span>
            <span class="s4"># Length of the current line with next term added</span>
            <span class="s1">line_len = len(out.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]) + len(next_term)</span>
            <span class="s4"># If not the last term in the polynomial, it will be two</span>
            <span class="s4"># characters longer due to the +/- with the next term</span>
            <span class="s2">if </span><span class="s1">i &lt; len(self.coef[</span><span class="s5">1</span><span class="s1">:]) - </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">line_len += </span><span class="s5">2</span>
            <span class="s4"># Handle linebreaking</span>
            <span class="s2">if </span><span class="s1">line_len &gt;= linewidth:</span>
                <span class="s1">next_term = next_term.replace(</span><span class="s3">&quot; &quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">out += next_term</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_str_term_unicode(cls</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">arg_str):</span>
        <span class="s0">&quot;&quot;&quot; 
        String representation of single polynomial term using unicode 
        characters for superscripts and subscripts. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">cls.basis_name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s3">&quot;Subclasses must define either a basis_name, or override &quot;</span>
                <span class="s3">&quot;_str_term_unicode(cls, i, arg_str)&quot;</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">f&quot;·</span><span class="s2">{</span><span class="s1">cls.basis_name</span><span class="s2">}{</span><span class="s1">i.translate(cls._subscript_mapping)</span><span class="s2">}</span><span class="s3">&quot;</span>
                <span class="s3">f&quot;(</span><span class="s2">{</span><span class="s1">arg_str</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_str_term_ascii(cls</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">arg_str):</span>
        <span class="s0">&quot;&quot;&quot; 
        String representation of a single polynomial term using ** and _ to 
        represent superscripts and subscripts, respectively. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">cls.basis_name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s3">&quot;Subclasses must define either a basis_name, or override &quot;</span>
                <span class="s3">&quot;_str_term_ascii(cls, i, arg_str)&quot;</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s3">f&quot; </span><span class="s2">{</span><span class="s1">cls.basis_name</span><span class="s2">}</span><span class="s3">_</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s3">(</span><span class="s2">{</span><span class="s1">arg_str</span><span class="s2">}</span><span class="s3">)&quot;</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_repr_latex_term(cls</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">arg_str</span><span class="s2">, </span><span class="s1">needs_parens):</span>
        <span class="s2">if </span><span class="s1">cls.basis_name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s3">&quot;Subclasses must define either a basis name, or override &quot;</span>
                <span class="s3">&quot;_repr_latex_term(i, arg_str, needs_parens)&quot;</span><span class="s1">)</span>
        <span class="s4"># since we always add parens, we don't care if the expression needs them</span>
        <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">{{{</span><span class="s1">cls.basis_name</span><span class="s2">}}}</span><span class="s3">_</span><span class="s2">{{{</span><span class="s1">i</span><span class="s2">}}}</span><span class="s3">(</span><span class="s2">{</span><span class="s1">arg_str</span><span class="s2">}</span><span class="s3">)&quot;</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_repr_latex_scalar(x):</span>
        <span class="s4"># TODO: we're stuck with disabling math formatting until we handle</span>
        <span class="s4"># exponents in this function</span>
        <span class="s2">return </span><span class="s3">r'\text{{{}}}'</span><span class="s1">.format(x)</span>

    <span class="s2">def </span><span class="s1">_repr_latex_(self):</span>
        <span class="s4"># get the scaled argument string to the basis functions</span>
        <span class="s1">off</span><span class="s2">, </span><span class="s1">scale = self.mapparms()</span>
        <span class="s2">if </span><span class="s1">off == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">scale == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">term = </span><span class="s3">'x'</span>
            <span class="s1">needs_parens = </span><span class="s2">False</span>
        <span class="s2">elif </span><span class="s1">scale == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">term = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self._repr_latex_scalar(off)</span><span class="s2">} </span><span class="s3">+ x&quot;</span>
            <span class="s1">needs_parens = </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">off == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">term = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self._repr_latex_scalar(scale)</span><span class="s2">}</span><span class="s3">x&quot;</span>
            <span class="s1">needs_parens = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">term = (</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self._repr_latex_scalar(off)</span><span class="s2">} </span><span class="s3">+ &quot;</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self._repr_latex_scalar(scale)</span><span class="s2">}</span><span class="s3">x&quot;</span>
            <span class="s1">)</span>
            <span class="s1">needs_parens = </span><span class="s2">True</span>

        <span class="s1">mute = </span><span class="s3">r&quot;\color{{LightGray}}{{{}}}&quot;</span><span class="s1">.format</span>

        <span class="s1">parts = []</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">enumerate(self.coef):</span>
            <span class="s4"># prevent duplication of + and - signs</span>
            <span class="s2">if </span><span class="s1">i == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">coef_str = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self._repr_latex_scalar(c)</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s2">elif not </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">numbers.Real):</span>
                <span class="s1">coef_str = </span><span class="s3">f&quot; + (</span><span class="s2">{</span><span class="s1">self._repr_latex_scalar(c)</span><span class="s2">}</span><span class="s3">)&quot;</span>
            <span class="s2">elif not </span><span class="s1">np.signbit(c):</span>
                <span class="s1">coef_str = </span><span class="s3">f&quot; + </span><span class="s2">{</span><span class="s1">self._repr_latex_scalar(c)</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">coef_str = </span><span class="s3">f&quot; - </span><span class="s2">{</span><span class="s1">self._repr_latex_scalar(-c)</span><span class="s2">}</span><span class="s3">&quot;</span>

            <span class="s4"># produce the string for the term</span>
            <span class="s1">term_str = self._repr_latex_term(i</span><span class="s2">, </span><span class="s1">term</span><span class="s2">, </span><span class="s1">needs_parens)</span>
            <span class="s2">if </span><span class="s1">term_str == </span><span class="s3">'1'</span><span class="s1">:</span>
                <span class="s1">part = coef_str</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">part = </span><span class="s3">rf&quot;</span><span class="s2">{</span><span class="s1">coef_str</span><span class="s2">}</span><span class="s3">\,</span><span class="s2">{</span><span class="s1">term_str</span><span class="s2">}</span><span class="s3">&quot;</span>

            <span class="s2">if </span><span class="s1">c == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">part = mute(part)</span>

            <span class="s1">parts.append(part)</span>

        <span class="s2">if </span><span class="s1">parts:</span>
            <span class="s1">body = </span><span class="s3">''</span><span class="s1">.join(parts)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># in case somehow there are no coefficients at all</span>
            <span class="s1">body = </span><span class="s3">'0'</span>

        <span class="s2">return </span><span class="s3">rf&quot;$x \mapsto </span><span class="s2">{</span><span class="s1">body</span><span class="s2">}</span><span class="s3">$&quot;</span>



    <span class="s4"># Pickle and copy</span>

    <span class="s2">def </span><span class="s1">__getstate__(self):</span>
        <span class="s1">ret = self.__dict__.copy()</span>
        <span class="s1">ret[</span><span class="s3">'coef'</span><span class="s1">] = self.coef.copy()</span>
        <span class="s1">ret[</span><span class="s3">'domain'</span><span class="s1">] = self.domain.copy()</span>
        <span class="s1">ret[</span><span class="s3">'window'</span><span class="s1">] = self.window.copy()</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">__setstate__(self</span><span class="s2">, </span><span class="s1">dict):</span>
        <span class="s1">self.__dict__ = dict</span>

    <span class="s4"># Call</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">arg):</span>
        <span class="s1">off</span><span class="s2">, </span><span class="s1">scl = pu.mapparms(self.domain</span><span class="s2">, </span><span class="s1">self.window)</span>
        <span class="s1">arg = off + scl*arg</span>
        <span class="s2">return </span><span class="s1">self._val(arg</span><span class="s2">, </span><span class="s1">self.coef)</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s2">return </span><span class="s1">iter(self.coef)</span>

    <span class="s2">def </span><span class="s1">__len__(self):</span>
        <span class="s2">return </span><span class="s1">len(self.coef)</span>

    <span class="s4"># Numeric properties.</span>

    <span class="s2">def </span><span class="s1">__neg__(self):</span>
        <span class="s2">return </span><span class="s1">self.__class__(-self.coef</span><span class="s2">, </span><span class="s1">self.domain</span><span class="s2">, </span><span class="s1">self.window)</span>

    <span class="s2">def </span><span class="s1">__pos__(self):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__add__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s1">othercoef = self._get_coefficients(other)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">coef = self._add(self.coef</span><span class="s2">, </span><span class="s1">othercoef)</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>
        <span class="s2">return </span><span class="s1">self.__class__(coef</span><span class="s2">, </span><span class="s1">self.domain</span><span class="s2">, </span><span class="s1">self.window)</span>

    <span class="s2">def </span><span class="s1">__sub__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s1">othercoef = self._get_coefficients(other)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">coef = self._sub(self.coef</span><span class="s2">, </span><span class="s1">othercoef)</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>
        <span class="s2">return </span><span class="s1">self.__class__(coef</span><span class="s2">, </span><span class="s1">self.domain</span><span class="s2">, </span><span class="s1">self.window)</span>

    <span class="s2">def </span><span class="s1">__mul__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s1">othercoef = self._get_coefficients(other)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">coef = self._mul(self.coef</span><span class="s2">, </span><span class="s1">othercoef)</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>
        <span class="s2">return </span><span class="s1">self.__class__(coef</span><span class="s2">, </span><span class="s1">self.domain</span><span class="s2">, </span><span class="s1">self.window)</span>

    <span class="s2">def </span><span class="s1">__truediv__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s4"># there is no true divide if the rhs is not a Number, although it</span>
        <span class="s4"># could return the first n elements of an infinite series.</span>
        <span class="s4"># It is hard to see where n would come from, though.</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">numbers.Number) </span><span class="s2">or </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">bool):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s3">f&quot;unsupported types for true division: &quot;</span>
                <span class="s3">f&quot;'</span><span class="s2">{</span><span class="s1">type(self)</span><span class="s2">}</span><span class="s3">', '</span><span class="s2">{</span><span class="s1">type(other)</span><span class="s2">}</span><span class="s3">'&quot;</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self.__floordiv__(other)</span>

    <span class="s2">def </span><span class="s1">__floordiv__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s1">res = self.__divmod__(other)</span>
        <span class="s2">if </span><span class="s1">res </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">res</span>
        <span class="s2">return </span><span class="s1">res[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">__mod__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s1">res = self.__divmod__(other)</span>
        <span class="s2">if </span><span class="s1">res </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">res</span>
        <span class="s2">return </span><span class="s1">res[</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">__divmod__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s1">othercoef = self._get_coefficients(other)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">quo</span><span class="s2">, </span><span class="s1">rem = self._div(self.coef</span><span class="s2">, </span><span class="s1">othercoef)</span>
        <span class="s2">except </span><span class="s1">ZeroDivisionError:</span>
            <span class="s2">raise</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>
        <span class="s1">quo = self.__class__(quo</span><span class="s2">, </span><span class="s1">self.domain</span><span class="s2">, </span><span class="s1">self.window)</span>
        <span class="s1">rem = self.__class__(rem</span><span class="s2">, </span><span class="s1">self.domain</span><span class="s2">, </span><span class="s1">self.window)</span>
        <span class="s2">return </span><span class="s1">quo</span><span class="s2">, </span><span class="s1">rem</span>

    <span class="s2">def </span><span class="s1">__pow__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s1">coef = self._pow(self.coef</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">maxpower=self.maxpower)</span>
        <span class="s1">res = self.__class__(coef</span><span class="s2">, </span><span class="s1">self.domain</span><span class="s2">, </span><span class="s1">self.window)</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">__radd__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">coef = self._add(other</span><span class="s2">, </span><span class="s1">self.coef)</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>
        <span class="s2">return </span><span class="s1">self.__class__(coef</span><span class="s2">, </span><span class="s1">self.domain</span><span class="s2">, </span><span class="s1">self.window)</span>

    <span class="s2">def </span><span class="s1">__rsub__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">coef = self._sub(other</span><span class="s2">, </span><span class="s1">self.coef)</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>
        <span class="s2">return </span><span class="s1">self.__class__(coef</span><span class="s2">, </span><span class="s1">self.domain</span><span class="s2">, </span><span class="s1">self.window)</span>

    <span class="s2">def </span><span class="s1">__rmul__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">coef = self._mul(other</span><span class="s2">, </span><span class="s1">self.coef)</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>
        <span class="s2">return </span><span class="s1">self.__class__(coef</span><span class="s2">, </span><span class="s1">self.domain</span><span class="s2">, </span><span class="s1">self.window)</span>

    <span class="s2">def </span><span class="s1">__rdiv__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s4"># set to __floordiv__ /.</span>
        <span class="s2">return </span><span class="s1">self.__rfloordiv__(other)</span>

    <span class="s2">def </span><span class="s1">__rtruediv__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s4"># An instance of ABCPolyBase is not considered a</span>
        <span class="s4"># Number.</span>
        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">def </span><span class="s1">__rfloordiv__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s1">res = self.__rdivmod__(other)</span>
        <span class="s2">if </span><span class="s1">res </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">res</span>
        <span class="s2">return </span><span class="s1">res[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">__rmod__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s1">res = self.__rdivmod__(other)</span>
        <span class="s2">if </span><span class="s1">res </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">res</span>
        <span class="s2">return </span><span class="s1">res[</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">__rdivmod__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">quo</span><span class="s2">, </span><span class="s1">rem = self._div(other</span><span class="s2">, </span><span class="s1">self.coef)</span>
        <span class="s2">except </span><span class="s1">ZeroDivisionError:</span>
            <span class="s2">raise</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>
        <span class="s1">quo = self.__class__(quo</span><span class="s2">, </span><span class="s1">self.domain</span><span class="s2">, </span><span class="s1">self.window)</span>
        <span class="s1">rem = self.__class__(rem</span><span class="s2">, </span><span class="s1">self.domain</span><span class="s2">, </span><span class="s1">self.window)</span>
        <span class="s2">return </span><span class="s1">quo</span><span class="s2">, </span><span class="s1">rem</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s1">res = (isinstance(other</span><span class="s2">, </span><span class="s1">self.__class__) </span><span class="s2">and</span>
               <span class="s1">np.all(self.domain == other.domain) </span><span class="s2">and</span>
               <span class="s1">np.all(self.window == other.window) </span><span class="s2">and</span>
               <span class="s1">(self.coef.shape == other.coef.shape) </span><span class="s2">and</span>
               <span class="s1">np.all(self.coef == other.coef))</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self.__eq__(other)</span>

    <span class="s4">#</span>
    <span class="s4"># Extra methods.</span>
    <span class="s4">#</span>

    <span class="s2">def </span><span class="s1">copy(self):</span>
        <span class="s0">&quot;&quot;&quot;Return a copy. 
 
        Returns 
        ------- 
        new_series : series 
            Copy of self. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.__class__(self.coef</span><span class="s2">, </span><span class="s1">self.domain</span><span class="s2">, </span><span class="s1">self.window)</span>

    <span class="s2">def </span><span class="s1">degree(self):</span>
        <span class="s0">&quot;&quot;&quot;The degree of the series. 
 
        .. versionadded:: 1.5.0 
 
        Returns 
        ------- 
        degree : int 
            Degree of the series, one less than the number of coefficients. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">len(self) - </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">cutdeg(self</span><span class="s2">, </span><span class="s1">deg):</span>
        <span class="s0">&quot;&quot;&quot;Truncate series to the given degree. 
 
        Reduce the degree of the series to `deg` by discarding the 
        high order terms. If `deg` is greater than the current degree a 
        copy of the current series is returned. This can be useful in least 
        squares where the coefficients of the high degree terms may be very 
        small. 
 
        .. versionadded:: 1.5.0 
 
        Parameters 
        ---------- 
        deg : non-negative int 
            The series is reduced to degree `deg` by discarding the high 
            order terms. The value of `deg` must be a non-negative integer. 
 
        Returns 
        ------- 
        new_series : series 
            New instance of series with reduced degree. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.truncate(deg + </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">trim(self</span><span class="s2">, </span><span class="s1">tol=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Remove trailing coefficients 
 
        Remove trailing coefficients until a coefficient is reached whose 
        absolute value greater than `tol` or the beginning of the series is 
        reached. If all the coefficients would be removed the series is set 
        to ``[0]``. A new series instance is returned with the new 
        coefficients.  The current instance remains unchanged. 
 
        Parameters 
        ---------- 
        tol : non-negative number. 
            All trailing coefficients less than `tol` will be removed. 
 
        Returns 
        ------- 
        new_series : series 
            New instance of series with trimmed coefficients. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">coef = pu.trimcoef(self.coef</span><span class="s2">, </span><span class="s1">tol)</span>
        <span class="s2">return </span><span class="s1">self.__class__(coef</span><span class="s2">, </span><span class="s1">self.domain</span><span class="s2">, </span><span class="s1">self.window)</span>

    <span class="s2">def </span><span class="s1">truncate(self</span><span class="s2">, </span><span class="s1">size):</span>
        <span class="s0">&quot;&quot;&quot;Truncate series to length `size`. 
 
        Reduce the series to length `size` by discarding the high 
        degree terms. The value of `size` must be a positive integer. This 
        can be useful in least squares where the coefficients of the 
        high degree terms may be very small. 
 
        Parameters 
        ---------- 
        size : positive int 
            The series is reduced to length `size` by discarding the high 
            degree terms. The value of `size` must be a positive integer. 
 
        Returns 
        ------- 
        new_series : series 
            New instance of series with truncated coefficients. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">isize = int(size)</span>
        <span class="s2">if </span><span class="s1">isize != size </span><span class="s2">or </span><span class="s1">isize &lt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;size must be a positive integer&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">isize &gt;= len(self.coef):</span>
            <span class="s1">coef = self.coef</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">coef = self.coef[:isize]</span>
        <span class="s2">return </span><span class="s1">self.__class__(coef</span><span class="s2">, </span><span class="s1">self.domain</span><span class="s2">, </span><span class="s1">self.window)</span>

    <span class="s2">def </span><span class="s1">convert(self</span><span class="s2">, </span><span class="s1">domain=</span><span class="s2">None, </span><span class="s1">kind=</span><span class="s2">None, </span><span class="s1">window=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Convert series to a different kind and/or domain and/or window. 
 
        Parameters 
        ---------- 
        domain : array_like, optional 
            The domain of the converted series. If the value is None, 
            the default domain of `kind` is used. 
        kind : class, optional 
            The polynomial series type class to which the current instance 
            should be converted. If kind is None, then the class of the 
            current instance is used. 
        window : array_like, optional 
            The window of the converted series. If the value is None, 
            the default window of `kind` is used. 
 
        Returns 
        ------- 
        new_series : series 
            The returned class can be of different type than the current 
            instance and/or have a different domain and/or different 
            window. 
 
        Notes 
        ----- 
        Conversion between domains and class types can result in 
        numerically ill defined series. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">kind </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">kind = self.__class__</span>
        <span class="s2">if </span><span class="s1">domain </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">domain = kind.domain</span>
        <span class="s2">if </span><span class="s1">window </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">window = kind.window</span>
        <span class="s2">return </span><span class="s1">self(kind.identity(domain</span><span class="s2">, </span><span class="s1">window=window))</span>

    <span class="s2">def </span><span class="s1">mapparms(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the mapping parameters. 
 
        The returned values define a linear map ``off + scl*x`` that is 
        applied to the input arguments before the series is evaluated. The 
        map depends on the ``domain`` and ``window``; if the current 
        ``domain`` is equal to the ``window`` the resulting map is the 
        identity.  If the coefficients of the series instance are to be 
        used by themselves outside this class, then the linear function 
        must be substituted for the ``x`` in the standard representation of 
        the base polynomials. 
 
        Returns 
        ------- 
        off, scl : float or complex 
            The mapping function is defined by ``off + scl*x``. 
 
        Notes 
        ----- 
        If the current domain is the interval ``[l1, r1]`` and the window 
        is ``[l2, r2]``, then the linear mapping function ``L`` is 
        defined by the equations:: 
 
            L(l1) = l2 
            L(r1) = r2 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">pu.mapparms(self.domain</span><span class="s2">, </span><span class="s1">self.window)</span>

    <span class="s2">def </span><span class="s1">integ(self</span><span class="s2">, </span><span class="s1">m=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">k=[]</span><span class="s2">, </span><span class="s1">lbnd=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Integrate. 
 
        Return a series instance that is the definite integral of the 
        current series. 
 
        Parameters 
        ---------- 
        m : non-negative int 
            The number of integrations to perform. 
        k : array_like 
            Integration constants. The first constant is applied to the 
            first integration, the second to the second, and so on. The 
            list of values must less than or equal to `m` in length and any 
            missing values are set to zero. 
        lbnd : Scalar 
            The lower bound of the definite integral. 
 
        Returns 
        ------- 
        new_series : series 
            A new series representing the integral. The domain is the same 
            as the domain of the integrated series. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">off</span><span class="s2">, </span><span class="s1">scl = self.mapparms()</span>
        <span class="s2">if </span><span class="s1">lbnd </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">lbnd = </span><span class="s5">0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">lbnd = off + scl*lbnd</span>
        <span class="s1">coef = self._int(self.coef</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">lbnd</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">/scl)</span>
        <span class="s2">return </span><span class="s1">self.__class__(coef</span><span class="s2">, </span><span class="s1">self.domain</span><span class="s2">, </span><span class="s1">self.window)</span>

    <span class="s2">def </span><span class="s1">deriv(self</span><span class="s2">, </span><span class="s1">m=</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Differentiate. 
 
        Return a series instance of that is the derivative of the current 
        series. 
 
        Parameters 
        ---------- 
        m : non-negative int 
            Find the derivative of order `m`. 
 
        Returns 
        ------- 
        new_series : series 
            A new series representing the derivative. The domain is the same 
            as the domain of the differentiated series. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">off</span><span class="s2">, </span><span class="s1">scl = self.mapparms()</span>
        <span class="s1">coef = self._der(self.coef</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">scl)</span>
        <span class="s2">return </span><span class="s1">self.__class__(coef</span><span class="s2">, </span><span class="s1">self.domain</span><span class="s2">, </span><span class="s1">self.window)</span>

    <span class="s2">def </span><span class="s1">roots(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the roots of the series polynomial. 
 
        Compute the roots for the series. Note that the accuracy of the 
        roots decrease the further outside the domain they lie. 
 
        Returns 
        ------- 
        roots : ndarray 
            Array containing the roots of the series. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">roots = self._roots(self.coef)</span>
        <span class="s2">return </span><span class="s1">pu.mapdomain(roots</span><span class="s2">, </span><span class="s1">self.window</span><span class="s2">, </span><span class="s1">self.domain)</span>

    <span class="s2">def </span><span class="s1">linspace(self</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">100</span><span class="s2">, </span><span class="s1">domain=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Return x, y values at equally spaced points in domain. 
 
        Returns the x, y values at `n` linearly spaced points across the 
        domain.  Here y is the value of the polynomial at the points x. By 
        default the domain is the same as that of the series instance. 
        This method is intended mostly as a plotting aid. 
 
        .. versionadded:: 1.5.0 
 
        Parameters 
        ---------- 
        n : int, optional 
            Number of point pairs to return. The default value is 100. 
        domain : {None, array_like}, optional 
            If not None, the specified domain is used instead of that of 
            the calling instance. It should be of the form ``[beg,end]``. 
            The default is None which case the class domain is used. 
 
        Returns 
        ------- 
        x, y : ndarray 
            x is equal to linspace(self.domain[0], self.domain[1], n) and 
            y is the series evaluated at element of x. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">domain </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">domain = self.domain</span>
        <span class="s1">x = np.linspace(domain[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">domain[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">n)</span>
        <span class="s1">y = self(x)</span>
        <span class="s2">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">fit(cls</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">deg</span><span class="s2">, </span><span class="s1">domain=</span><span class="s2">None, </span><span class="s1">rcond=</span><span class="s2">None, </span><span class="s1">full=</span><span class="s2">False, </span><span class="s1">w=</span><span class="s2">None,</span>
        <span class="s1">window=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Least squares fit to data. 
 
        Return a series instance that is the least squares fit to the data 
        `y` sampled at `x`. The domain of the returned instance can be 
        specified and this will often result in a superior fit with less 
        chance of ill conditioning. 
 
        Parameters 
        ---------- 
        x : array_like, shape (M,) 
            x-coordinates of the M sample points ``(x[i], y[i])``. 
        y : array_like, shape (M,) 
            y-coordinates of the M sample points ``(x[i], y[i])``. 
        deg : int or 1-D array_like 
            Degree(s) of the fitting polynomials. If `deg` is a single integer 
            all terms up to and including the `deg`'th term are included in the 
            fit. For NumPy versions &gt;= 1.11.0 a list of integers specifying the 
            degrees of the terms to include may be used instead. 
        domain : {None, [beg, end], []}, optional 
            Domain to use for the returned series. If ``None``, 
            then a minimal domain that covers the points `x` is chosen.  If 
            ``[]`` the class domain is used. The default value was the 
            class domain in NumPy 1.4 and ``None`` in later versions. 
            The ``[]`` option was added in numpy 1.5.0. 
        rcond : float, optional 
            Relative condition number of the fit. Singular values smaller 
            than this relative to the largest singular value will be 
            ignored. The default value is len(x)*eps, where eps is the 
            relative precision of the float type, about 2e-16 in most 
            cases. 
        full : bool, optional 
            Switch determining nature of return value. When it is False 
            (the default) just the coefficients are returned, when True 
            diagnostic information from the singular value decomposition is 
            also returned. 
        w : array_like, shape (M,), optional 
            Weights. If not None, the weight ``w[i]`` applies to the unsquared 
            residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are 
            chosen so that the errors of the products ``w[i]*y[i]`` all have 
            the same variance.  When using inverse-variance weighting, use 
            ``w[i] = 1/sigma(y[i])``.  The default value is None. 
 
            .. versionadded:: 1.5.0 
        window : {[beg, end]}, optional 
            Window to use for the returned series. The default 
            value is the default class domain 
 
            .. versionadded:: 1.6.0 
 
        Returns 
        ------- 
        new_series : series 
            A series that represents the least squares fit to the data and 
            has the domain and window specified in the call. If the 
            coefficients for the unscaled and unshifted basis polynomials are 
            of interest, do ``new_series.convert().coef``. 
 
        [resid, rank, sv, rcond] : list 
            These values are only returned if ``full == True`` 
 
            - resid -- sum of squared residuals of the least squares fit 
            - rank -- the numerical rank of the scaled Vandermonde matrix 
            - sv -- singular values of the scaled Vandermonde matrix 
            - rcond -- value of `rcond`. 
 
            For more details, see `linalg.lstsq`. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">domain </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">domain = pu.getdomain(x)</span>
        <span class="s2">elif </span><span class="s1">type(domain) </span><span class="s2">is </span><span class="s1">list </span><span class="s2">and </span><span class="s1">len(domain) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">domain = cls.domain</span>

        <span class="s2">if </span><span class="s1">window </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">window = cls.window</span>

        <span class="s1">xnew = pu.mapdomain(x</span><span class="s2">, </span><span class="s1">domain</span><span class="s2">, </span><span class="s1">window)</span>
        <span class="s1">res = cls._fit(xnew</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">deg</span><span class="s2">, </span><span class="s1">w=w</span><span class="s2">, </span><span class="s1">rcond=rcond</span><span class="s2">, </span><span class="s1">full=full)</span>
        <span class="s2">if </span><span class="s1">full:</span>
            <span class="s1">[coef</span><span class="s2">, </span><span class="s1">status] = res</span>
            <span class="s2">return </span><span class="s1">cls(coef</span><span class="s2">, </span><span class="s1">domain=domain</span><span class="s2">, </span><span class="s1">window=window)</span><span class="s2">, </span><span class="s1">status</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">coef = res</span>
            <span class="s2">return </span><span class="s1">cls(coef</span><span class="s2">, </span><span class="s1">domain=domain</span><span class="s2">, </span><span class="s1">window=window)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">fromroots(cls</span><span class="s2">, </span><span class="s1">roots</span><span class="s2">, </span><span class="s1">domain=[]</span><span class="s2">, </span><span class="s1">window=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Return series instance that has the specified roots. 
 
        Returns a series representing the product 
        ``(x - r[0])*(x - r[1])*...*(x - r[n-1])``, where ``r`` is a 
        list of roots. 
 
        Parameters 
        ---------- 
        roots : array_like 
            List of roots. 
        domain : {[], None, array_like}, optional 
            Domain for the resulting series. If None the domain is the 
            interval from the smallest root to the largest. If [] the 
            domain is the class domain. The default is []. 
        window : {None, array_like}, optional 
            Window for the returned series. If None the class window is 
            used. The default is None. 
 
        Returns 
        ------- 
        new_series : series 
            Series with the specified roots. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">[roots] = pu.as_series([roots]</span><span class="s2">, </span><span class="s1">trim=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">domain </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">domain = pu.getdomain(roots)</span>
        <span class="s2">elif </span><span class="s1">type(domain) </span><span class="s2">is </span><span class="s1">list </span><span class="s2">and </span><span class="s1">len(domain) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">domain = cls.domain</span>

        <span class="s2">if </span><span class="s1">window </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">window = cls.window</span>

        <span class="s1">deg = len(roots)</span>
        <span class="s1">off</span><span class="s2">, </span><span class="s1">scl = pu.mapparms(domain</span><span class="s2">, </span><span class="s1">window)</span>
        <span class="s1">rnew = off + scl*roots</span>
        <span class="s1">coef = cls._fromroots(rnew) / scl**deg</span>
        <span class="s2">return </span><span class="s1">cls(coef</span><span class="s2">, </span><span class="s1">domain=domain</span><span class="s2">, </span><span class="s1">window=window)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">identity(cls</span><span class="s2">, </span><span class="s1">domain=</span><span class="s2">None, </span><span class="s1">window=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Identity function. 
 
        If ``p`` is the returned series, then ``p(x) == x`` for all 
        values of x. 
 
        Parameters 
        ---------- 
        domain : {None, array_like}, optional 
            If given, the array must be of the form ``[beg, end]``, where 
            ``beg`` and ``end`` are the endpoints of the domain. If None is 
            given then the class domain is used. The default is None. 
        window : {None, array_like}, optional 
            If given, the resulting array must be if the form 
            ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of 
            the window. If None is given then the class window is used. The 
            default is None. 
 
        Returns 
        ------- 
        new_series : series 
             Series of representing the identity. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">domain </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">domain = cls.domain</span>
        <span class="s2">if </span><span class="s1">window </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">window = cls.window</span>
        <span class="s1">off</span><span class="s2">, </span><span class="s1">scl = pu.mapparms(window</span><span class="s2">, </span><span class="s1">domain)</span>
        <span class="s1">coef = cls._line(off</span><span class="s2">, </span><span class="s1">scl)</span>
        <span class="s2">return </span><span class="s1">cls(coef</span><span class="s2">, </span><span class="s1">domain</span><span class="s2">, </span><span class="s1">window)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">basis(cls</span><span class="s2">, </span><span class="s1">deg</span><span class="s2">, </span><span class="s1">domain=</span><span class="s2">None, </span><span class="s1">window=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Series basis polynomial of degree `deg`. 
 
        Returns the series representing the basis polynomial of degree `deg`. 
 
        .. versionadded:: 1.7.0 
 
        Parameters 
        ---------- 
        deg : int 
            Degree of the basis polynomial for the series. Must be &gt;= 0. 
        domain : {None, array_like}, optional 
            If given, the array must be of the form ``[beg, end]``, where 
            ``beg`` and ``end`` are the endpoints of the domain. If None is 
            given then the class domain is used. The default is None. 
        window : {None, array_like}, optional 
            If given, the resulting array must be if the form 
            ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of 
            the window. If None is given then the class window is used. The 
            default is None. 
 
        Returns 
        ------- 
        new_series : series 
            A series with the coefficient of the `deg` term set to one and 
            all others zero. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">domain </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">domain = cls.domain</span>
        <span class="s2">if </span><span class="s1">window </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">window = cls.window</span>
        <span class="s1">ideg = int(deg)</span>

        <span class="s2">if </span><span class="s1">ideg != deg </span><span class="s2">or </span><span class="s1">ideg &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;deg must be non-negative integer&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">cls([</span><span class="s5">0</span><span class="s1">]*ideg + [</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">domain</span><span class="s2">, </span><span class="s1">window)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">cast(cls</span><span class="s2">, </span><span class="s1">series</span><span class="s2">, </span><span class="s1">domain=</span><span class="s2">None, </span><span class="s1">window=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Convert series to series of this class. 
 
        The `series` is expected to be an instance of some polynomial 
        series of one of the types supported by by the numpy.polynomial 
        module, but could be some other class that supports the convert 
        method. 
 
        .. versionadded:: 1.7.0 
 
        Parameters 
        ---------- 
        series : series 
            The series instance to be converted. 
        domain : {None, array_like}, optional 
            If given, the array must be of the form ``[beg, end]``, where 
            ``beg`` and ``end`` are the endpoints of the domain. If None is 
            given then the class domain is used. The default is None. 
        window : {None, array_like}, optional 
            If given, the resulting array must be if the form 
            ``[beg, end]``, where ``beg`` and ``end`` are the endpoints of 
            the window. If None is given then the class window is used. The 
            default is None. 
 
        Returns 
        ------- 
        new_series : series 
            A series of the same kind as the calling class and equal to 
            `series` when evaluated. 
 
        See Also 
        -------- 
        convert : similar instance method 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">domain </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">domain = cls.domain</span>
        <span class="s2">if </span><span class="s1">window </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">window = cls.window</span>
        <span class="s2">return </span><span class="s1">series.convert(domain</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">, </span><span class="s1">window)</span>
</pre>
</body>
</html>