<html>
<head>
<title>routing.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
routing.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;When it comes to combining multiple controller or view functions 
(however you want to call them) you need a dispatcher. A simple way 
would be applying regular expression tests on the ``PATH_INFO`` and 
calling registered callback functions that return the value then. 
 
This module implements a much more powerful system than simple regular 
expression matching because it can also convert values in the URLs and 
build URLs. 
 
Here a simple example that creates a URL map for an application with 
two subdomains (www and kb) and some URL rules: 
 
.. code-block:: python 
 
    m = Map([ 
        # Static URLs 
        Rule('/', endpoint='static/index'), 
        Rule('/about', endpoint='static/about'), 
        Rule('/help', endpoint='static/help'), 
        # Knowledge Base 
        Subdomain('kb', [ 
            Rule('/', endpoint='kb/index'), 
            Rule('/browse/', endpoint='kb/browse'), 
            Rule('/browse/&lt;int:id&gt;/', endpoint='kb/browse'), 
            Rule('/browse/&lt;int:id&gt;/&lt;int:page&gt;', endpoint='kb/browse') 
        ]) 
    ], default_subdomain='www') 
 
If the application doesn't use subdomains it's perfectly fine to not set 
the default subdomain and not use the `Subdomain` rule factory. The 
endpoint in the rules can be anything, for example import paths or 
unique identifiers. The WSGI application can use those endpoints to get the 
handler for that URL.  It doesn't have to be a string at all but it's 
recommended. 
 
Now it's possible to create a URL adapter for one of the subdomains and 
build URLs: 
 
.. code-block:: python 
 
    c = m.bind('example.com') 
 
    c.build(&quot;kb/browse&quot;, dict(id=42)) 
    'http://kb.example.com/browse/42/' 
 
    c.build(&quot;kb/browse&quot;, dict()) 
    'http://kb.example.com/browse/' 
 
    c.build(&quot;kb/browse&quot;, dict(id=42, page=3)) 
    'http://kb.example.com/browse/42/3' 
 
    c.build(&quot;static/about&quot;) 
    '/about' 
 
    c.build(&quot;static/index&quot;, force_external=True) 
    'http://www.example.com/' 
 
    c = m.bind('example.com', subdomain='kb') 
 
    c.build(&quot;static/about&quot;) 
    'http://www.example.com/about' 
 
The first argument to bind is the server name *without* the subdomain. 
Per default it will assume that the script is mounted on the root, but 
often that's not the case so you can provide the real mount point as 
second argument: 
 
.. code-block:: python 
 
    c = m.bind('example.com', '/applications/example') 
 
The third argument can be the subdomain, if not given the default 
subdomain is used.  For more details about binding have a look at the 
documentation of the `MapAdapter`. 
 
And here is how you can match URLs: 
 
.. code-block:: python 
 
    c = m.bind('example.com') 
 
    c.match(&quot;/&quot;) 
    ('static/index', {}) 
 
    c.match(&quot;/about&quot;) 
    ('static/about', {}) 
 
    c = m.bind('example.com', '/', 'kb') 
 
    c.match(&quot;/&quot;) 
    ('kb/index', {}) 
 
    c.match(&quot;/browse/42/23&quot;) 
    ('kb/browse', {'id': 42, 'page': 23}) 
 
If matching fails you get a ``NotFound`` exception, if the rule thinks 
it's a good idea to redirect (for example because the URL was defined 
to have a slash at the end but the request was missing that slash) it 
will raise a ``RequestRedirect`` exception. Both are subclasses of 
``HTTPException`` so you can use those errors as responses in the 
application. 
 
If matching succeeded but the URL rule was incompatible to the given 
method (for example there were only rules for ``GET`` and ``HEAD`` but 
routing tried to match a ``POST`` request) a ``MethodNotAllowed`` 
exception is raised. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">ast</span>
<span class="s2">import </span><span class="s1">difflib</span>
<span class="s2">import </span><span class="s1">posixpath</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">typing</span>
<span class="s2">import </span><span class="s1">typing </span><span class="s2">as </span><span class="s1">t</span>
<span class="s2">import </span><span class="s1">uuid</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">pprint </span><span class="s2">import </span><span class="s1">pformat</span>
<span class="s2">from </span><span class="s1">string </span><span class="s2">import </span><span class="s1">Template</span>
<span class="s2">from </span><span class="s1">threading </span><span class="s2">import </span><span class="s1">Lock</span>
<span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">CodeType</span>

<span class="s2">from </span><span class="s1">._internal </span><span class="s2">import </span><span class="s1">_encode_idna</span>
<span class="s2">from </span><span class="s1">._internal </span><span class="s2">import </span><span class="s1">_get_environ</span>
<span class="s2">from </span><span class="s1">._internal </span><span class="s2">import </span><span class="s1">_to_bytes</span>
<span class="s2">from </span><span class="s1">._internal </span><span class="s2">import </span><span class="s1">_to_str</span>
<span class="s2">from </span><span class="s1">._internal </span><span class="s2">import </span><span class="s1">_wsgi_decoding_dance</span>
<span class="s2">from </span><span class="s1">.datastructures </span><span class="s2">import </span><span class="s1">ImmutableDict</span>
<span class="s2">from </span><span class="s1">.datastructures </span><span class="s2">import </span><span class="s1">MultiDict</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">BadHost</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">BadRequest</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">HTTPException</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">MethodNotAllowed</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">NotFound</span>
<span class="s2">from </span><span class="s1">.urls </span><span class="s2">import </span><span class="s1">_fast_url_quote</span>
<span class="s2">from </span><span class="s1">.urls </span><span class="s2">import </span><span class="s1">url_encode</span>
<span class="s2">from </span><span class="s1">.urls </span><span class="s2">import </span><span class="s1">url_join</span>
<span class="s2">from </span><span class="s1">.urls </span><span class="s2">import </span><span class="s1">url_quote</span>
<span class="s2">from </span><span class="s1">.urls </span><span class="s2">import </span><span class="s1">url_unquote</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">cached_property</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">redirect</span>
<span class="s2">from </span><span class="s1">.wsgi </span><span class="s2">import </span><span class="s1">get_host</span>

<span class="s2">if </span><span class="s1">t.TYPE_CHECKING:</span>
    <span class="s2">import </span><span class="s1">typing_extensions </span><span class="s2">as </span><span class="s1">te</span>
    <span class="s2">from </span><span class="s1">_typeshed.wsgi </span><span class="s2">import </span><span class="s1">WSGIApplication</span>
    <span class="s2">from </span><span class="s1">_typeshed.wsgi </span><span class="s2">import </span><span class="s1">WSGIEnvironment</span>
    <span class="s2">from </span><span class="s1">.wrappers.response </span><span class="s2">import </span><span class="s1">Response</span>

<span class="s1">_rule_re = re.compile(</span>
    <span class="s3">r&quot;&quot;&quot; 
    (?P&lt;static&gt;[^&lt;]*)                           # static rule data 
    &lt; 
    (?: 
        (?P&lt;converter&gt;[a-zA-Z_][a-zA-Z0-9_]*)   # converter name 
        (?:\((?P&lt;args&gt;.*?)\))?                  # converter arguments 
        \:                                      # variable delimiter 
    )? 
    (?P&lt;variable&gt;[a-zA-Z_][a-zA-Z0-9_]*)        # variable name 
    &gt; 
    &quot;&quot;&quot;</span><span class="s2">,</span>
    <span class="s1">re.VERBOSE</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s1">_simple_rule_re = re.compile(</span><span class="s3">r&quot;&lt;([^&gt;]+)&gt;&quot;</span><span class="s1">)</span>
<span class="s1">_converter_args_re = re.compile(</span>
    <span class="s3">r&quot;&quot;&quot; 
    ((?P&lt;name&gt;\w+)\s*=\s*)? 
    (?P&lt;value&gt; 
        True|False| 
        \d+.\d+| 
        \d+.| 
        \d+| 
        [\w\d_.]+| 
        [urUR]?(?P&lt;stringval&gt;&quot;[^&quot;]*?&quot;|'[^']*') 
    )\s*, 
    &quot;&quot;&quot;</span><span class="s2">,</span>
    <span class="s1">re.VERBOSE</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s1">_PYTHON_CONSTANTS = {</span><span class="s3">&quot;None&quot;</span><span class="s1">: </span><span class="s2">None, </span><span class="s3">&quot;True&quot;</span><span class="s1">: </span><span class="s2">True, </span><span class="s3">&quot;False&quot;</span><span class="s1">: </span><span class="s2">False</span><span class="s1">}</span>


<span class="s2">def </span><span class="s1">_pythonize(value: str) -&gt; t.Union[</span><span class="s2">None, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">str]:</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">in </span><span class="s1">_PYTHON_CONSTANTS:</span>
        <span class="s2">return </span><span class="s1">_PYTHON_CONSTANTS[value]</span>
    <span class="s2">for </span><span class="s1">convert </span><span class="s2">in </span><span class="s1">int</span><span class="s2">, </span><span class="s1">float:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">convert(value)  </span><span class="s4"># type: ignore</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">pass</span>
    <span class="s2">if </span><span class="s1">value[:</span><span class="s5">1</span><span class="s1">] == value[-</span><span class="s5">1</span><span class="s1">:] </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s3">&quot;</span><span class="s2">\&quot;</span><span class="s3">'&quot;</span><span class="s1">:</span>
        <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">str(value)</span>


<span class="s2">def </span><span class="s1">parse_converter_args(argstr: str) -&gt; t.Tuple[t.Tuple</span><span class="s2">, </span><span class="s1">t.Dict[str</span><span class="s2">, </span><span class="s1">t.Any]]:</span>
    <span class="s1">argstr += </span><span class="s3">&quot;,&quot;</span>
    <span class="s1">args = []</span>
    <span class="s1">kwargs = {}</span>

    <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">_converter_args_re.finditer(argstr):</span>
        <span class="s1">value = item.group(</span><span class="s3">&quot;stringval&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">value </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">value = item.group(</span><span class="s3">&quot;value&quot;</span><span class="s1">)</span>
        <span class="s1">value = _pythonize(value)</span>
        <span class="s2">if not </span><span class="s1">item.group(</span><span class="s3">&quot;name&quot;</span><span class="s1">):</span>
            <span class="s1">args.append(value)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">name = item.group(</span><span class="s3">&quot;name&quot;</span><span class="s1">)</span>
            <span class="s1">kwargs[name] = value</span>

    <span class="s2">return </span><span class="s1">tuple(args)</span><span class="s2">, </span><span class="s1">kwargs</span>


<span class="s2">def </span><span class="s1">parse_rule(rule: str) -&gt; t.Iterator[t.Tuple[t.Optional[str]</span><span class="s2">, </span><span class="s1">t.Optional[str]</span><span class="s2">, </span><span class="s1">str]]:</span>
    <span class="s0">&quot;&quot;&quot;Parse a rule and return it as generator. Each iteration yields tuples 
    in the form ``(converter, arguments, variable)``. If the converter is 
    `None` it's a static url part, otherwise it's a dynamic one. 
 
    :internal: 
    &quot;&quot;&quot;</span>
    <span class="s1">pos = </span><span class="s5">0</span>
    <span class="s1">end = len(rule)</span>
    <span class="s1">do_match = _rule_re.match</span>
    <span class="s1">used_names = set()</span>
    <span class="s2">while </span><span class="s1">pos &lt; end:</span>
        <span class="s1">m = do_match(rule</span><span class="s2">, </span><span class="s1">pos)</span>
        <span class="s2">if </span><span class="s1">m </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">break</span>
        <span class="s1">data = m.groupdict()</span>
        <span class="s2">if </span><span class="s1">data[</span><span class="s3">&quot;static&quot;</span><span class="s1">]:</span>
            <span class="s2">yield None, None, </span><span class="s1">data[</span><span class="s3">&quot;static&quot;</span><span class="s1">]</span>
        <span class="s1">variable = data[</span><span class="s3">&quot;variable&quot;</span><span class="s1">]</span>
        <span class="s1">converter = data[</span><span class="s3">&quot;converter&quot;</span><span class="s1">] </span><span class="s2">or </span><span class="s3">&quot;default&quot;</span>
        <span class="s2">if </span><span class="s1">variable </span><span class="s2">in </span><span class="s1">used_names:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;variable name </span><span class="s2">{</span><span class="s1">variable</span><span class="s2">!r} </span><span class="s3">used twice.&quot;</span><span class="s1">)</span>
        <span class="s1">used_names.add(variable)</span>
        <span class="s2">yield </span><span class="s1">converter</span><span class="s2">, </span><span class="s1">data[</span><span class="s3">&quot;args&quot;</span><span class="s1">] </span><span class="s2">or None, </span><span class="s1">variable</span>
        <span class="s1">pos = m.end()</span>
    <span class="s2">if </span><span class="s1">pos &lt; end:</span>
        <span class="s1">remaining = rule[pos:]</span>
        <span class="s2">if </span><span class="s3">&quot;&gt;&quot; </span><span class="s2">in </span><span class="s1">remaining </span><span class="s2">or </span><span class="s3">&quot;&lt;&quot; </span><span class="s2">in </span><span class="s1">remaining:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;malformed url rule: </span><span class="s2">{</span><span class="s1">rule</span><span class="s2">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s2">yield None, None, </span><span class="s1">remaining</span>


<span class="s2">class </span><span class="s1">RoutingException(Exception):</span>
    <span class="s0">&quot;&quot;&quot;Special exceptions that require the application to redirect, notifying 
    about missing urls, etc. 
 
    :internal: 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">RequestRedirect(HTTPException</span><span class="s2">, </span><span class="s1">RoutingException):</span>
    <span class="s0">&quot;&quot;&quot;Raise if the map requests a redirect. This is for example the case if 
    `strict_slashes` are activated and an url that requires a trailing slash. 
 
    The attribute `new_url` contains the absolute destination url. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">308</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">new_url: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(new_url)</span>
        <span class="s1">self.new_url = new_url</span>

    <span class="s2">def </span><span class="s1">get_response(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">environ: t.Optional[</span><span class="s3">&quot;WSGIEnvironment&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
        <span class="s1">scope: t.Optional[dict] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Response&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">redirect(self.new_url</span><span class="s2">, </span><span class="s1">self.code)</span>


<span class="s2">class </span><span class="s1">RequestPath(RoutingException):</span>
    <span class="s0">&quot;&quot;&quot;Internal exception.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span><span class="s3">&quot;path_info&quot;</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">path_info: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.path_info = path_info</span>


<span class="s2">class </span><span class="s1">RequestAliasRedirect(RoutingException):  </span><span class="s4"># noqa: B903</span>
    <span class="s0">&quot;&quot;&quot;This rule is an alias and wants to redirect to the canonical URL.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">matched_values: t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.matched_values = matched_values</span>


<span class="s2">class </span><span class="s1">BuildError(RoutingException</span><span class="s2">, </span><span class="s1">LookupError):</span>
    <span class="s0">&quot;&quot;&quot;Raised if the build system cannot find a URL for an endpoint with the 
    values provided. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">endpoint: str</span><span class="s2">,</span>
        <span class="s1">values: t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">,</span>
        <span class="s1">method: t.Optional[str]</span><span class="s2">,</span>
        <span class="s1">adapter: t.Optional[</span><span class="s3">&quot;MapAdapter&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(endpoint</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">method)</span>
        <span class="s1">self.endpoint = endpoint</span>
        <span class="s1">self.values = values</span>
        <span class="s1">self.method = method</span>
        <span class="s1">self.adapter = adapter</span>

    <span class="s1">@cached_property</span>
    <span class="s2">def </span><span class="s1">suggested(self) -&gt; t.Optional[</span><span class="s3">&quot;Rule&quot;</span><span class="s1">]:</span>
        <span class="s2">return </span><span class="s1">self.closest_rule(self.adapter)</span>

    <span class="s2">def </span><span class="s1">closest_rule(self</span><span class="s2">, </span><span class="s1">adapter: t.Optional[</span><span class="s3">&quot;MapAdapter&quot;</span><span class="s1">]) -&gt; t.Optional[</span><span class="s3">&quot;Rule&quot;</span><span class="s1">]:</span>
        <span class="s2">def </span><span class="s1">_score_rule(rule: </span><span class="s3">&quot;Rule&quot;</span><span class="s1">) -&gt; float:</span>
            <span class="s2">return </span><span class="s1">sum(</span>
                <span class="s1">[</span>
                    <span class="s5">0.98</span>
                    <span class="s1">* difflib.SequenceMatcher(</span>
                        <span class="s2">None, </span><span class="s1">rule.endpoint</span><span class="s2">, </span><span class="s1">self.endpoint</span>
                    <span class="s1">).ratio()</span><span class="s2">,</span>
                    <span class="s5">0.01 </span><span class="s1">* bool(set(self.values </span><span class="s2">or </span><span class="s1">()).issubset(rule.arguments))</span><span class="s2">,</span>
                    <span class="s5">0.01 </span><span class="s1">* bool(rule.methods </span><span class="s2">and </span><span class="s1">self.method </span><span class="s2">in </span><span class="s1">rule.methods)</span><span class="s2">,</span>
                <span class="s1">]</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">adapter </span><span class="s2">and </span><span class="s1">adapter.map._rules:</span>
            <span class="s2">return </span><span class="s1">max(adapter.map._rules</span><span class="s2">, </span><span class="s1">key=_score_rule)</span>

        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s1">message = [</span><span class="s3">f&quot;Could not build url for endpoint </span><span class="s2">{</span><span class="s1">self.endpoint</span><span class="s2">!r}</span><span class="s3">&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.method:</span>
            <span class="s1">message.append(</span><span class="s3">f&quot; (</span><span class="s2">{</span><span class="s1">self.method</span><span class="s2">!r}</span><span class="s3">)&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.values:</span>
            <span class="s1">message.append(</span><span class="s3">f&quot; with values </span><span class="s2">{</span><span class="s1">sorted(self.values)</span><span class="s2">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">message.append(</span><span class="s3">&quot;.&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.suggested:</span>
            <span class="s2">if </span><span class="s1">self.endpoint == self.suggested.endpoint:</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">self.method</span>
                    <span class="s2">and </span><span class="s1">self.suggested.methods </span><span class="s2">is not None</span>
                    <span class="s2">and </span><span class="s1">self.method </span><span class="s2">not in </span><span class="s1">self.suggested.methods</span>
                <span class="s1">):</span>
                    <span class="s1">message.append(</span>
                        <span class="s3">&quot; Did you mean to use methods&quot;</span>
                        <span class="s3">f&quot; </span><span class="s2">{</span><span class="s1">sorted(self.suggested.methods)</span><span class="s2">!r}</span><span class="s3">?&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">missing_values = self.suggested.arguments.union(</span>
                    <span class="s1">set(self.suggested.defaults </span><span class="s2">or </span><span class="s1">())</span>
                <span class="s1">) - set(self.values.keys())</span>
                <span class="s2">if </span><span class="s1">missing_values:</span>
                    <span class="s1">message.append(</span>
                        <span class="s3">f&quot; Did you forget to specify values </span><span class="s2">{</span><span class="s1">sorted(missing_values)</span><span class="s2">!r}</span><span class="s3">?&quot;</span>
                    <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">message.append(</span><span class="s3">f&quot; Did you mean </span><span class="s2">{</span><span class="s1">self.suggested.endpoint</span><span class="s2">!r} </span><span class="s3">instead?&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s3">&quot;&quot;</span><span class="s1">.join(message)</span>


<span class="s2">class </span><span class="s1">WebsocketMismatch(BadRequest):</span>
    <span class="s0">&quot;&quot;&quot;The only matched rule is either a WebSocket and the request is 
    HTTP, or the rule is HTTP and the request is a WebSocket. 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">ValidationError(ValueError):</span>
    <span class="s0">&quot;&quot;&quot;Validation error.  If a rule converter raises this exception the rule 
    does not match the current URL and the next URL is tried. 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">RuleFactory:</span>
    <span class="s0">&quot;&quot;&quot;As soon as you have more complex URL setups it's a good idea to use rule 
    factories to avoid repetitive tasks.  Some of them are builtin, others can 
    be added by subclassing `RuleFactory` and overriding `get_rules`. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">get_rules(self</span><span class="s2">, </span><span class="s1">map: </span><span class="s3">&quot;Map&quot;</span><span class="s1">) -&gt; t.Iterable[</span><span class="s3">&quot;Rule&quot;</span><span class="s1">]:</span>
        <span class="s0">&quot;&quot;&quot;Subclasses of `RuleFactory` have to override this method and return 
        an iterable of rules.&quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>


<span class="s2">class </span><span class="s1">Subdomain(RuleFactory):</span>
    <span class="s0">&quot;&quot;&quot;All URLs provided by this factory have the subdomain set to a 
    specific domain. For example if you want to use the subdomain for 
    the current language this can be a good setup:: 
 
        url_map = Map([ 
            Rule('/', endpoint='#select_language'), 
            Subdomain('&lt;string(length=2):lang_code&gt;', [ 
                Rule('/', endpoint='index'), 
                Rule('/about', endpoint='about'), 
                Rule('/help', endpoint='help') 
            ]) 
        ]) 
 
    All the rules except for the ``'#select_language'`` endpoint will now 
    listen on a two letter long subdomain that holds the language code 
    for the current request. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">subdomain: str</span><span class="s2">, </span><span class="s1">rules: t.Iterable[RuleFactory]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.subdomain = subdomain</span>
        <span class="s1">self.rules = rules</span>

    <span class="s2">def </span><span class="s1">get_rules(self</span><span class="s2">, </span><span class="s1">map: </span><span class="s3">&quot;Map&quot;</span><span class="s1">) -&gt; t.Iterator[</span><span class="s3">&quot;Rule&quot;</span><span class="s1">]:</span>
        <span class="s2">for </span><span class="s1">rulefactory </span><span class="s2">in </span><span class="s1">self.rules:</span>
            <span class="s2">for </span><span class="s1">rule </span><span class="s2">in </span><span class="s1">rulefactory.get_rules(map):</span>
                <span class="s1">rule = rule.empty()</span>
                <span class="s1">rule.subdomain = self.subdomain</span>
                <span class="s2">yield </span><span class="s1">rule</span>


<span class="s2">class </span><span class="s1">Submount(RuleFactory):</span>
    <span class="s0">&quot;&quot;&quot;Like `Subdomain` but prefixes the URL rule with a given string:: 
 
        url_map = Map([ 
            Rule('/', endpoint='index'), 
            Submount('/blog', [ 
                Rule('/', endpoint='blog/index'), 
                Rule('/entry/&lt;entry_slug&gt;', endpoint='blog/show') 
            ]) 
        ]) 
 
    Now the rule ``'blog/show'`` matches ``/blog/entry/&lt;entry_slug&gt;``. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">path: str</span><span class="s2">, </span><span class="s1">rules: t.Iterable[RuleFactory]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.path = path.rstrip(</span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>
        <span class="s1">self.rules = rules</span>

    <span class="s2">def </span><span class="s1">get_rules(self</span><span class="s2">, </span><span class="s1">map: </span><span class="s3">&quot;Map&quot;</span><span class="s1">) -&gt; t.Iterator[</span><span class="s3">&quot;Rule&quot;</span><span class="s1">]:</span>
        <span class="s2">for </span><span class="s1">rulefactory </span><span class="s2">in </span><span class="s1">self.rules:</span>
            <span class="s2">for </span><span class="s1">rule </span><span class="s2">in </span><span class="s1">rulefactory.get_rules(map):</span>
                <span class="s1">rule = rule.empty()</span>
                <span class="s1">rule.rule = self.path + rule.rule</span>
                <span class="s2">yield </span><span class="s1">rule</span>


<span class="s2">class </span><span class="s1">EndpointPrefix(RuleFactory):</span>
    <span class="s0">&quot;&quot;&quot;Prefixes all endpoints (which must be strings for this factory) with 
    another string. This can be useful for sub applications:: 
 
        url_map = Map([ 
            Rule('/', endpoint='index'), 
            EndpointPrefix('blog/', [Submount('/blog', [ 
                Rule('/', endpoint='index'), 
                Rule('/entry/&lt;entry_slug&gt;', endpoint='show') 
            ])]) 
        ]) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">prefix: str</span><span class="s2">, </span><span class="s1">rules: t.Iterable[RuleFactory]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.prefix = prefix</span>
        <span class="s1">self.rules = rules</span>

    <span class="s2">def </span><span class="s1">get_rules(self</span><span class="s2">, </span><span class="s1">map: </span><span class="s3">&quot;Map&quot;</span><span class="s1">) -&gt; t.Iterator[</span><span class="s3">&quot;Rule&quot;</span><span class="s1">]:</span>
        <span class="s2">for </span><span class="s1">rulefactory </span><span class="s2">in </span><span class="s1">self.rules:</span>
            <span class="s2">for </span><span class="s1">rule </span><span class="s2">in </span><span class="s1">rulefactory.get_rules(map):</span>
                <span class="s1">rule = rule.empty()</span>
                <span class="s1">rule.endpoint = self.prefix + rule.endpoint</span>
                <span class="s2">yield </span><span class="s1">rule</span>


<span class="s2">class </span><span class="s1">RuleTemplate:</span>
    <span class="s0">&quot;&quot;&quot;Returns copies of the rules wrapped and expands string templates in 
    the endpoint, rule, defaults or subdomain sections. 
 
    Here a small example for such a rule template:: 
 
        from werkzeug.routing import Map, Rule, RuleTemplate 
 
        resource = RuleTemplate([ 
            Rule('/$name/', endpoint='$name.list'), 
            Rule('/$name/&lt;int:id&gt;', endpoint='$name.show') 
        ]) 
 
        url_map = Map([resource(name='user'), resource(name='page')]) 
 
    When a rule template is called the keyword arguments are used to 
    replace the placeholders in all the string parameters. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">rules: t.Iterable[</span><span class="s3">&quot;Rule&quot;</span><span class="s1">]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.rules = list(rules)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any) -&gt; </span><span class="s3">&quot;RuleTemplateFactory&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">RuleTemplateFactory(self.rules</span><span class="s2">, </span><span class="s1">dict(*args</span><span class="s2">, </span><span class="s1">**kwargs))</span>


<span class="s2">class </span><span class="s1">RuleTemplateFactory(RuleFactory):</span>
    <span class="s0">&quot;&quot;&quot;A factory that fills in template variables into rules.  Used by 
    `RuleTemplate` internally. 
 
    :internal: 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">rules: t.Iterable[RuleFactory]</span><span class="s2">, </span><span class="s1">context: t.Dict[str</span><span class="s2">, </span><span class="s1">t.Any]</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.rules = rules</span>
        <span class="s1">self.context = context</span>

    <span class="s2">def </span><span class="s1">get_rules(self</span><span class="s2">, </span><span class="s1">map: </span><span class="s3">&quot;Map&quot;</span><span class="s1">) -&gt; t.Iterator[</span><span class="s3">&quot;Rule&quot;</span><span class="s1">]:</span>
        <span class="s2">for </span><span class="s1">rulefactory </span><span class="s2">in </span><span class="s1">self.rules:</span>
            <span class="s2">for </span><span class="s1">rule </span><span class="s2">in </span><span class="s1">rulefactory.get_rules(map):</span>
                <span class="s1">new_defaults = subdomain = </span><span class="s2">None</span>
                <span class="s2">if </span><span class="s1">rule.defaults:</span>
                    <span class="s1">new_defaults = {}</span>
                    <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">rule.defaults.items():</span>
                        <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">str):</span>
                            <span class="s1">value = Template(value).substitute(self.context)</span>
                        <span class="s1">new_defaults[key] = value</span>
                <span class="s2">if </span><span class="s1">rule.subdomain </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">subdomain = Template(rule.subdomain).substitute(self.context)</span>
                <span class="s1">new_endpoint = rule.endpoint</span>
                <span class="s2">if </span><span class="s1">isinstance(new_endpoint</span><span class="s2">, </span><span class="s1">str):</span>
                    <span class="s1">new_endpoint = Template(new_endpoint).substitute(self.context)</span>
                <span class="s2">yield </span><span class="s1">Rule(</span>
                    <span class="s1">Template(rule.rule).substitute(self.context)</span><span class="s2">,</span>
                    <span class="s1">new_defaults</span><span class="s2">,</span>
                    <span class="s1">subdomain</span><span class="s2">,</span>
                    <span class="s1">rule.methods</span><span class="s2">,</span>
                    <span class="s1">rule.build_only</span><span class="s2">,</span>
                    <span class="s1">new_endpoint</span><span class="s2">,</span>
                    <span class="s1">rule.strict_slashes</span><span class="s2">,</span>
                <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_prefix_names(src: str) -&gt; ast.stmt:</span>
    <span class="s0">&quot;&quot;&quot;ast parse and prefix names with `.` to avoid collision with user vars&quot;&quot;&quot;</span>
    <span class="s1">tree = ast.parse(src).body[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">isinstance(tree</span><span class="s2">, </span><span class="s1">ast.Expr):</span>
        <span class="s1">tree = tree.value  </span><span class="s4"># type: ignore</span>
    <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">ast.walk(tree):</span>
        <span class="s2">if </span><span class="s1">isinstance(node</span><span class="s2">, </span><span class="s1">ast.Name):</span>
            <span class="s1">node.id = </span><span class="s3">f&quot;.</span><span class="s2">{</span><span class="s1">node.id</span><span class="s2">}</span><span class="s3">&quot;</span>
    <span class="s2">return </span><span class="s1">tree</span>


<span class="s1">_CALL_CONVERTER_CODE_FMT = </span><span class="s3">&quot;self._converters[{elem!r}].to_url()&quot;</span>
<span class="s1">_IF_KWARGS_URL_ENCODE_CODE = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">if kwargs: 
    q = '?' 
    params = self._encode_query_vars(kwargs) 
else: 
    q = params = '' 
&quot;&quot;&quot;</span>
<span class="s1">_IF_KWARGS_URL_ENCODE_AST = _prefix_names(_IF_KWARGS_URL_ENCODE_CODE)</span>
<span class="s1">_URL_ENCODE_AST_NAMES = (_prefix_names(</span><span class="s3">&quot;q&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">_prefix_names(</span><span class="s3">&quot;params&quot;</span><span class="s1">))</span>


<span class="s2">class </span><span class="s1">Rule(RuleFactory):</span>
    <span class="s0">&quot;&quot;&quot;A Rule represents one URL pattern.  There are some options for `Rule` 
    that change the way it behaves and are passed to the `Rule` constructor. 
    Note that besides the rule-string all arguments *must* be keyword arguments 
    in order to not break the application on Werkzeug upgrades. 
 
    `string` 
        Rule strings basically are just normal URL paths with placeholders in 
        the format ``&lt;converter(arguments):name&gt;`` where the converter and the 
        arguments are optional.  If no converter is defined the `default` 
        converter is used which means `string` in the normal configuration. 
 
        URL rules that end with a slash are branch URLs, others are leaves. 
        If you have `strict_slashes` enabled (which is the default), all 
        branch URLs that are matched without a trailing slash will trigger a 
        redirect to the same URL with the missing slash appended. 
 
        The converters are defined on the `Map`. 
 
    `endpoint` 
        The endpoint for this rule. This can be anything. A reference to a 
        function, a string, a number etc.  The preferred way is using a string 
        because the endpoint is used for URL generation. 
 
    `defaults` 
        An optional dict with defaults for other rules with the same endpoint. 
        This is a bit tricky but useful if you want to have unique URLs:: 
 
            url_map = Map([ 
                Rule('/all/', defaults={'page': 1}, endpoint='all_entries'), 
                Rule('/all/page/&lt;int:page&gt;', endpoint='all_entries') 
            ]) 
 
        If a user now visits ``http://example.com/all/page/1`` he will be 
        redirected to ``http://example.com/all/``.  If `redirect_defaults` is 
        disabled on the `Map` instance this will only affect the URL 
        generation. 
 
    `subdomain` 
        The subdomain rule string for this rule. If not specified the rule 
        only matches for the `default_subdomain` of the map.  If the map is 
        not bound to a subdomain this feature is disabled. 
 
        Can be useful if you want to have user profiles on different subdomains 
        and all subdomains are forwarded to your application:: 
 
            url_map = Map([ 
                Rule('/', subdomain='&lt;username&gt;', endpoint='user/homepage'), 
                Rule('/stats', subdomain='&lt;username&gt;', endpoint='user/stats') 
            ]) 
 
    `methods` 
        A sequence of http methods this rule applies to.  If not specified, all 
        methods are allowed. For example this can be useful if you want different 
        endpoints for `POST` and `GET`.  If methods are defined and the path 
        matches but the method matched against is not in this list or in the 
        list of another rule for that path the error raised is of the type 
        `MethodNotAllowed` rather than `NotFound`.  If `GET` is present in the 
        list of methods and `HEAD` is not, `HEAD` is added automatically. 
 
    `strict_slashes` 
        Override the `Map` setting for `strict_slashes` only for this rule. If 
        not specified the `Map` setting is used. 
 
    `merge_slashes` 
        Override :attr:`Map.merge_slashes` for this rule. 
 
    `build_only` 
        Set this to True and the rule will never match but will create a URL 
        that can be build. This is useful if you have resources on a subdomain 
        or folder that are not handled by the WSGI application (like static data) 
 
    `redirect_to` 
        If given this must be either a string or callable.  In case of a 
        callable it's called with the url adapter that triggered the match and 
        the values of the URL as keyword arguments and has to return the target 
        for the redirect, otherwise it has to be a string with placeholders in 
        rule syntax:: 
 
            def foo_with_slug(adapter, id): 
                # ask the database for the slug for the old id.  this of 
                # course has nothing to do with werkzeug. 
                return f'foo/{Foo.get_slug_for_id(id)}' 
 
            url_map = Map([ 
                Rule('/foo/&lt;slug&gt;', endpoint='foo'), 
                Rule('/some/old/url/&lt;slug&gt;', redirect_to='foo/&lt;slug&gt;'), 
                Rule('/other/old/url/&lt;int:id&gt;', redirect_to=foo_with_slug) 
            ]) 
 
        When the rule is matched the routing system will raise a 
        `RequestRedirect` exception with the target for the redirect. 
 
        Keep in mind that the URL will be joined against the URL root of the 
        script so don't use a leading slash on the target URL unless you 
        really mean root of that domain. 
 
    `alias` 
        If enabled this rule serves as an alias for another rule with the same 
        endpoint and arguments. 
 
    `host` 
        If provided and the URL map has host matching enabled this can be 
        used to provide a match rule for the whole host.  This also means 
        that the subdomain feature is disabled. 
 
    `websocket` 
        If ``True``, this rule is only matches for WebSocket (``ws://``, 
        ``wss://``) requests. By default, rules will only match for HTTP 
        requests. 
 
    .. versionadded:: 1.0 
        Added ``websocket``. 
 
    .. versionadded:: 1.0 
        Added ``merge_slashes``. 
 
    .. versionadded:: 0.7 
        Added ``alias`` and ``host``. 
 
    .. versionchanged:: 0.6.1 
       ``HEAD`` is added to ``methods`` if ``GET`` is present. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">string: str</span><span class="s2">,</span>
        <span class="s1">defaults: t.Optional[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
        <span class="s1">subdomain: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">methods: t.Optional[t.Iterable[str]] = </span><span class="s2">None,</span>
        <span class="s1">build_only: bool = </span><span class="s2">False,</span>
        <span class="s1">endpoint: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">strict_slashes: t.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">merge_slashes: t.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">redirect_to: t.Optional[t.Union[str</span><span class="s2">, </span><span class="s1">t.Callable[...</span><span class="s2">, </span><span class="s1">str]]] = </span><span class="s2">None,</span>
        <span class="s1">alias: bool = </span><span class="s2">False,</span>
        <span class="s1">host: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">websocket: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">string.startswith(</span><span class="s3">&quot;/&quot;</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;urls must start with a leading slash&quot;</span><span class="s1">)</span>
        <span class="s1">self.rule = string</span>
        <span class="s1">self.is_leaf = </span><span class="s2">not </span><span class="s1">string.endswith(</span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>

        <span class="s1">self.map: </span><span class="s3">&quot;Map&quot; </span><span class="s1">= </span><span class="s2">None  </span><span class="s4"># type: ignore</span>
        <span class="s1">self.strict_slashes = strict_slashes</span>
        <span class="s1">self.merge_slashes = merge_slashes</span>
        <span class="s1">self.subdomain = subdomain</span>
        <span class="s1">self.host = host</span>
        <span class="s1">self.defaults = defaults</span>
        <span class="s1">self.build_only = build_only</span>
        <span class="s1">self.alias = alias</span>
        <span class="s1">self.websocket = websocket</span>

        <span class="s2">if </span><span class="s1">methods </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(methods</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;'methods' should be a list of strings.&quot;</span><span class="s1">)</span>

            <span class="s1">methods = {x.upper() </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">methods}</span>

            <span class="s2">if </span><span class="s3">&quot;HEAD&quot; </span><span class="s2">not in </span><span class="s1">methods </span><span class="s2">and </span><span class="s3">&quot;GET&quot; </span><span class="s2">in </span><span class="s1">methods:</span>
                <span class="s1">methods.add(</span><span class="s3">&quot;HEAD&quot;</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">websocket </span><span class="s2">and </span><span class="s1">methods - {</span><span class="s3">&quot;GET&quot;</span><span class="s2">, </span><span class="s3">&quot;HEAD&quot;</span><span class="s2">, </span><span class="s3">&quot;OPTIONS&quot;</span><span class="s1">}:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;WebSocket rules can only use 'GET', 'HEAD', and 'OPTIONS' methods.&quot;</span>
                <span class="s1">)</span>

        <span class="s1">self.methods = methods</span>
        <span class="s1">self.endpoint: str = endpoint  </span><span class="s4"># type: ignore</span>
        <span class="s1">self.redirect_to = redirect_to</span>

        <span class="s2">if </span><span class="s1">defaults:</span>
            <span class="s1">self.arguments = set(map(str</span><span class="s2">, </span><span class="s1">defaults))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.arguments = set()</span>

        <span class="s1">self._trace: t.List[t.Tuple[bool</span><span class="s2">, </span><span class="s1">str]] = []</span>

    <span class="s2">def </span><span class="s1">empty(self) -&gt; </span><span class="s3">&quot;Rule&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return an unbound copy of this rule. 
 
        This can be useful if want to reuse an already bound URL for another 
        map.  See ``get_empty_kwargs`` to override what keyword arguments are 
        provided to the new copy. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">type(self)(self.rule</span><span class="s2">, </span><span class="s1">**self.get_empty_kwargs())</span>

    <span class="s2">def </span><span class="s1">get_empty_kwargs(self) -&gt; t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Provides kwargs for instantiating empty copy with empty() 
 
        Use this method to provide custom keyword arguments to the subclass of 
        ``Rule`` when calling ``some_rule.empty()``.  Helpful when the subclass 
        has custom keyword arguments that are needed at instantiation. 
 
        Must return a ``dict`` that will be provided as kwargs to the new 
        instance of ``Rule``, following the initial ``self.rule`` value which 
        is always provided as the first, required positional argument. 
        &quot;&quot;&quot;</span>
        <span class="s1">defaults = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">self.defaults:</span>
            <span class="s1">defaults = dict(self.defaults)</span>
        <span class="s2">return </span><span class="s1">dict(</span>
            <span class="s1">defaults=defaults</span><span class="s2">,</span>
            <span class="s1">subdomain=self.subdomain</span><span class="s2">,</span>
            <span class="s1">methods=self.methods</span><span class="s2">,</span>
            <span class="s1">build_only=self.build_only</span><span class="s2">,</span>
            <span class="s1">endpoint=self.endpoint</span><span class="s2">,</span>
            <span class="s1">strict_slashes=self.strict_slashes</span><span class="s2">,</span>
            <span class="s1">redirect_to=self.redirect_to</span><span class="s2">,</span>
            <span class="s1">alias=self.alias</span><span class="s2">,</span>
            <span class="s1">host=self.host</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_rules(self</span><span class="s2">, </span><span class="s1">map: </span><span class="s3">&quot;Map&quot;</span><span class="s1">) -&gt; t.Iterator[</span><span class="s3">&quot;Rule&quot;</span><span class="s1">]:</span>
        <span class="s2">yield </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">refresh(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Rebinds and refreshes the URL.  Call this if you modified the 
        rule in place. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s1">self.bind(self.map</span><span class="s2">, </span><span class="s1">rebind=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">bind(self</span><span class="s2">, </span><span class="s1">map: </span><span class="s3">&quot;Map&quot;</span><span class="s2">, </span><span class="s1">rebind: bool = </span><span class="s2">False</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Bind the url to a map and create a regular expression based on 
        the information from the rule itself and the defaults from the map. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.map </span><span class="s2">is not None and not </span><span class="s1">rebind:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">f&quot;url rule </span><span class="s2">{</span><span class="s1">self</span><span class="s2">!r} </span><span class="s3">already bound to map </span><span class="s2">{</span><span class="s1">self.map</span><span class="s2">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">self.map = map</span>
        <span class="s2">if </span><span class="s1">self.strict_slashes </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.strict_slashes = map.strict_slashes</span>
        <span class="s2">if </span><span class="s1">self.merge_slashes </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.merge_slashes = map.merge_slashes</span>
        <span class="s2">if </span><span class="s1">self.subdomain </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.subdomain = map.default_subdomain</span>
        <span class="s1">self.compile()</span>

    <span class="s2">def </span><span class="s1">get_converter(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">variable_name: str</span><span class="s2">,</span>
        <span class="s1">converter_name: str</span><span class="s2">,</span>
        <span class="s1">args: t.Tuple</span><span class="s2">,</span>
        <span class="s1">kwargs: t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;BaseConverter&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Looks up the converter for the given parameter. 
 
        .. versionadded:: 0.9 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">converter_name </span><span class="s2">not in </span><span class="s1">self.map.converters:</span>
            <span class="s2">raise </span><span class="s1">LookupError(</span><span class="s3">f&quot;the converter </span><span class="s2">{</span><span class="s1">converter_name</span><span class="s2">!r} </span><span class="s3">does not exist&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self.map.converters[converter_name](self.map</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">_encode_query_vars(self</span><span class="s2">, </span><span class="s1">query_vars: t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">url_encode(</span>
            <span class="s1">query_vars</span><span class="s2">,</span>
            <span class="s1">charset=self.map.charset</span><span class="s2">,</span>
            <span class="s1">sort=self.map.sort_parameters</span><span class="s2">,</span>
            <span class="s1">key=self.map.sort_key</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">compile(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Compiles the regular expression and stores it.&quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">self.map </span><span class="s2">is not None, </span><span class="s3">&quot;rule not bound&quot;</span>

        <span class="s2">if </span><span class="s1">self.map.host_matching:</span>
            <span class="s1">domain_rule = self.host </span><span class="s2">or </span><span class="s3">&quot;&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">domain_rule = self.subdomain </span><span class="s2">or </span><span class="s3">&quot;&quot;</span>

        <span class="s1">self._trace = []</span>
        <span class="s1">self._converters: t.Dict[str</span><span class="s2">, </span><span class="s3">&quot;BaseConverter&quot;</span><span class="s1">] = {}</span>
        <span class="s1">self._static_weights: t.List[t.Tuple[int</span><span class="s2">, </span><span class="s1">int]] = []</span>
        <span class="s1">self._argument_weights: t.List[int] = []</span>
        <span class="s1">regex_parts = []</span>

        <span class="s2">def </span><span class="s1">_build_regex(rule: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s1">index = </span><span class="s5">0</span>
            <span class="s2">for </span><span class="s1">converter</span><span class="s2">, </span><span class="s1">arguments</span><span class="s2">, </span><span class="s1">variable </span><span class="s2">in </span><span class="s1">parse_rule(rule):</span>
                <span class="s2">if </span><span class="s1">converter </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">for </span><span class="s1">match </span><span class="s2">in </span><span class="s1">re.finditer(</span><span class="s3">r&quot;/+|[^/]+&quot;</span><span class="s2">, </span><span class="s1">variable):</span>
                        <span class="s1">part = match.group(</span><span class="s5">0</span><span class="s1">)</span>
                        <span class="s2">if </span><span class="s1">part.startswith(</span><span class="s3">&quot;/&quot;</span><span class="s1">):</span>
                            <span class="s2">if </span><span class="s1">self.merge_slashes:</span>
                                <span class="s1">regex_parts.append(</span><span class="s3">r&quot;/+?&quot;</span><span class="s1">)</span>
                                <span class="s1">self._trace.append((</span><span class="s2">False, </span><span class="s3">&quot;/&quot;</span><span class="s1">))</span>
                            <span class="s2">else</span><span class="s1">:</span>
                                <span class="s1">regex_parts.append(part)</span>
                                <span class="s1">self._trace.append((</span><span class="s2">False, </span><span class="s1">part))</span>
                            <span class="s2">continue</span>
                        <span class="s1">self._trace.append((</span><span class="s2">False, </span><span class="s1">part))</span>
                        <span class="s1">regex_parts.append(re.escape(part))</span>
                        <span class="s2">if </span><span class="s1">part:</span>
                            <span class="s1">self._static_weights.append((index</span><span class="s2">, </span><span class="s1">-len(part)))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">arguments:</span>
                        <span class="s1">c_args</span><span class="s2">, </span><span class="s1">c_kwargs = parse_converter_args(arguments)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">c_args = ()</span>
                        <span class="s1">c_kwargs = {}</span>
                    <span class="s1">convobj = self.get_converter(variable</span><span class="s2">, </span><span class="s1">converter</span><span class="s2">, </span><span class="s1">c_args</span><span class="s2">, </span><span class="s1">c_kwargs)</span>
                    <span class="s1">regex_parts.append(</span><span class="s3">f&quot;(?P&lt;</span><span class="s2">{</span><span class="s1">variable</span><span class="s2">}</span><span class="s3">&gt;</span><span class="s2">{</span><span class="s1">convobj.regex</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s1">)</span>
                    <span class="s1">self._converters[variable] = convobj</span>
                    <span class="s1">self._trace.append((</span><span class="s2">True, </span><span class="s1">variable))</span>
                    <span class="s1">self._argument_weights.append(convobj.weight)</span>
                    <span class="s1">self.arguments.add(str(variable))</span>
                <span class="s1">index = index + </span><span class="s5">1</span>

        <span class="s1">_build_regex(domain_rule)</span>
        <span class="s1">regex_parts.append(</span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">|&quot;</span><span class="s1">)</span>
        <span class="s1">self._trace.append((</span><span class="s2">False, </span><span class="s3">&quot;|&quot;</span><span class="s1">))</span>
        <span class="s1">_build_regex(self.rule </span><span class="s2">if </span><span class="s1">self.is_leaf </span><span class="s2">else </span><span class="s1">self.rule.rstrip(</span><span class="s3">&quot;/&quot;</span><span class="s1">))</span>
        <span class="s2">if not </span><span class="s1">self.is_leaf:</span>
            <span class="s1">self._trace.append((</span><span class="s2">False, </span><span class="s3">&quot;/&quot;</span><span class="s1">))</span>

        <span class="s1">self._build: t.Callable[...</span><span class="s2">, </span><span class="s1">t.Tuple[str</span><span class="s2">, </span><span class="s1">str]]</span>
        <span class="s1">self._build = self._compile_builder(</span><span class="s2">False</span><span class="s1">).__get__(self</span><span class="s2">, None</span><span class="s1">)  </span><span class="s4"># type: ignore</span>
        <span class="s1">self._build_unknown: t.Callable[...</span><span class="s2">, </span><span class="s1">t.Tuple[str</span><span class="s2">, </span><span class="s1">str]]</span>
        <span class="s1">self._build_unknown = self._compile_builder(</span><span class="s2">True</span><span class="s1">).__get__(  </span><span class="s4"># type: ignore</span>
            <span class="s1">self</span><span class="s2">, None</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.build_only:</span>
            <span class="s2">return</span>

        <span class="s2">if not </span><span class="s1">(self.is_leaf </span><span class="s2">and </span><span class="s1">self.strict_slashes):</span>
            <span class="s1">reps = </span><span class="s3">&quot;*&quot; </span><span class="s2">if </span><span class="s1">self.merge_slashes </span><span class="s2">else </span><span class="s3">&quot;?&quot;</span>
            <span class="s1">tail = </span><span class="s3">f&quot;(?&lt;!/)(?P&lt;__suffix__&gt;/</span><span class="s2">{</span><span class="s1">reps</span><span class="s2">}</span><span class="s3">)&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tail = </span><span class="s3">&quot;&quot;</span>

        <span class="s1">regex = </span><span class="s3">f&quot;^</span><span class="s2">{</span><span class="s3">''</span><span class="s1">.join(regex_parts)</span><span class="s2">}{</span><span class="s1">tail</span><span class="s2">}</span><span class="s3">$&quot;</span>
        <span class="s1">self._regex = re.compile(regex)</span>

    <span class="s2">def </span><span class="s1">match(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">path: str</span><span class="s2">, </span><span class="s1">method: t.Optional[str] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; t.Optional[t.MutableMapping[str</span><span class="s2">, </span><span class="s1">t.Any]]:</span>
        <span class="s0">&quot;&quot;&quot;Check if the rule matches a given path. Path is a string in the 
        form ``&quot;subdomain|/path&quot;`` and is assembled by the map.  If 
        the map is doing host matching the subdomain part will be the host 
        instead. 
 
        If the rule matches a dict with the converted values is returned, 
        otherwise the return value is `None`. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self.build_only:</span>
            <span class="s1">require_redirect = </span><span class="s2">False</span>

            <span class="s1">m = self._regex.search(path)</span>
            <span class="s2">if </span><span class="s1">m </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">groups = m.groupdict()</span>
                <span class="s4"># we have a folder like part of the url without a trailing</span>
                <span class="s4"># slash and strict slashes enabled. raise an exception that</span>
                <span class="s4"># tells the map to redirect to the same url but with a</span>
                <span class="s4"># trailing slash</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">self.strict_slashes</span>
                    <span class="s2">and not </span><span class="s1">self.is_leaf</span>
                    <span class="s2">and not </span><span class="s1">groups.pop(</span><span class="s3">&quot;__suffix__&quot;</span><span class="s1">)</span>
                    <span class="s2">and </span><span class="s1">(</span>
                        <span class="s1">method </span><span class="s2">is None or </span><span class="s1">self.methods </span><span class="s2">is None or </span><span class="s1">method </span><span class="s2">in </span><span class="s1">self.methods</span>
                    <span class="s1">)</span>
                <span class="s1">):</span>
                    <span class="s1">path += </span><span class="s3">&quot;/&quot;</span>
                    <span class="s1">require_redirect = </span><span class="s2">True</span>
                <span class="s4"># if we are not in strict slashes mode we have to remove</span>
                <span class="s4"># a __suffix__</span>
                <span class="s2">elif not </span><span class="s1">self.strict_slashes:</span>
                    <span class="s2">del </span><span class="s1">groups[</span><span class="s3">&quot;__suffix__&quot;</span><span class="s1">]</span>

                <span class="s1">result = {}</span>
                <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">groups.items():</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">value = self._converters[name].to_python(value)</span>
                    <span class="s2">except </span><span class="s1">ValidationError:</span>
                        <span class="s2">return None</span>
                    <span class="s1">result[str(name)] = value</span>
                <span class="s2">if </span><span class="s1">self.defaults:</span>
                    <span class="s1">result.update(self.defaults)</span>

                <span class="s2">if </span><span class="s1">self.merge_slashes:</span>
                    <span class="s1">new_path = </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(self.build(result</span><span class="s2">, False</span><span class="s1">))  </span><span class="s4"># type: ignore</span>
                    <span class="s2">if </span><span class="s1">path.endswith(</span><span class="s3">&quot;/&quot;</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">new_path.endswith(</span><span class="s3">&quot;/&quot;</span><span class="s1">):</span>
                        <span class="s1">new_path += </span><span class="s3">&quot;/&quot;</span>
                    <span class="s2">if </span><span class="s1">new_path.count(</span><span class="s3">&quot;/&quot;</span><span class="s1">) &lt; path.count(</span><span class="s3">&quot;/&quot;</span><span class="s1">):</span>
                        <span class="s4"># The URL will be encoded when MapAdapter.match</span>
                        <span class="s4"># handles the RequestPath raised below. Decode</span>
                        <span class="s4"># the URL here to avoid a double encoding.</span>
                        <span class="s1">path = url_unquote(new_path)</span>
                        <span class="s1">require_redirect = </span><span class="s2">True</span>

                <span class="s2">if </span><span class="s1">require_redirect:</span>
                    <span class="s1">path = path.split(</span><span class="s3">&quot;|&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">1</span><span class="s1">]</span>
                    <span class="s2">raise </span><span class="s1">RequestPath(path)</span>

                <span class="s2">if </span><span class="s1">self.alias </span><span class="s2">and </span><span class="s1">self.map.redirect_defaults:</span>
                    <span class="s2">raise </span><span class="s1">RequestAliasRedirect(result)</span>

                <span class="s2">return </span><span class="s1">result</span>

        <span class="s2">return None</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_get_func_code(code: CodeType</span><span class="s2">, </span><span class="s1">name: str) -&gt; t.Callable[...</span><span class="s2">, </span><span class="s1">t.Tuple[str</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s1">globs: t.Dict[str</span><span class="s2">, </span><span class="s1">t.Any] = {}</span>
        <span class="s1">locs: t.Dict[str</span><span class="s2">, </span><span class="s1">t.Any] = {}</span>
        <span class="s1">exec(code</span><span class="s2">, </span><span class="s1">globs</span><span class="s2">, </span><span class="s1">locs)</span>
        <span class="s2">return </span><span class="s1">locs[name]  </span><span class="s4"># type: ignore</span>

    <span class="s2">def </span><span class="s1">_compile_builder(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">append_unknown: bool = </span><span class="s2">True</span>
    <span class="s1">) -&gt; t.Callable[...</span><span class="s2">, </span><span class="s1">t.Tuple[str</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s1">defaults = self.defaults </span><span class="s2">or </span><span class="s1">{}</span>
        <span class="s1">dom_ops: t.List[t.Tuple[bool</span><span class="s2">, </span><span class="s1">str]] = []</span>
        <span class="s1">url_ops: t.List[t.Tuple[bool</span><span class="s2">, </span><span class="s1">str]] = []</span>

        <span class="s1">opl = dom_ops</span>
        <span class="s2">for </span><span class="s1">is_dynamic</span><span class="s2">, </span><span class="s1">data </span><span class="s2">in </span><span class="s1">self._trace:</span>
            <span class="s2">if </span><span class="s1">data == </span><span class="s3">&quot;|&quot; </span><span class="s2">and </span><span class="s1">opl </span><span class="s2">is </span><span class="s1">dom_ops:</span>
                <span class="s1">opl = url_ops</span>
                <span class="s2">continue</span>
            <span class="s4"># this seems like a silly case to ever come up but:</span>
            <span class="s4"># if a default is given for a value that appears in the rule,</span>
            <span class="s4"># resolve it to a constant ahead of time</span>
            <span class="s2">if </span><span class="s1">is_dynamic </span><span class="s2">and </span><span class="s1">data </span><span class="s2">in </span><span class="s1">defaults:</span>
                <span class="s1">data = self._converters[data].to_url(defaults[data])</span>
                <span class="s1">opl.append((</span><span class="s2">False, </span><span class="s1">data))</span>
            <span class="s2">elif not </span><span class="s1">is_dynamic:</span>
                <span class="s1">opl.append(</span>
                    <span class="s1">(</span><span class="s2">False, </span><span class="s1">url_quote(_to_bytes(data</span><span class="s2">, </span><span class="s1">self.map.charset)</span><span class="s2">, </span><span class="s1">safe=</span><span class="s3">&quot;/:|+&quot;</span><span class="s1">))</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">opl.append((</span><span class="s2">True, </span><span class="s1">data))</span>

        <span class="s2">def </span><span class="s1">_convert(elem: str) -&gt; ast.stmt:</span>
            <span class="s1">ret = _prefix_names(_CALL_CONVERTER_CODE_FMT.format(elem=elem))</span>
            <span class="s1">ret.args = [ast.Name(str(elem)</span><span class="s2">, </span><span class="s1">ast.Load())]  </span><span class="s4"># type: ignore  # str for py2</span>
            <span class="s2">return </span><span class="s1">ret</span>

        <span class="s2">def </span><span class="s1">_parts(ops: t.List[t.Tuple[bool</span><span class="s2">, </span><span class="s1">str]]) -&gt; t.List[ast.AST]:</span>
            <span class="s1">parts = [</span>
                <span class="s1">_convert(elem) </span><span class="s2">if </span><span class="s1">is_dynamic </span><span class="s2">else </span><span class="s1">ast.Str(s=elem)</span>
                <span class="s2">for </span><span class="s1">is_dynamic</span><span class="s2">, </span><span class="s1">elem </span><span class="s2">in </span><span class="s1">ops</span>
            <span class="s1">]</span>
            <span class="s1">parts = parts </span><span class="s2">or </span><span class="s1">[ast.Str(</span><span class="s3">&quot;&quot;</span><span class="s1">)]</span>
            <span class="s4"># constant fold</span>
            <span class="s1">ret = [parts[</span><span class="s5">0</span><span class="s1">]]</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">parts[</span><span class="s5">1</span><span class="s1">:]:</span>
                <span class="s2">if </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">ast.Str) </span><span class="s2">and </span><span class="s1">isinstance(ret[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ast.Str):</span>
                    <span class="s1">ret[-</span><span class="s5">1</span><span class="s1">] = ast.Str(ret[-</span><span class="s5">1</span><span class="s1">].s + p.s)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">ret.append(p)</span>
            <span class="s2">return </span><span class="s1">ret</span>

        <span class="s1">dom_parts = _parts(dom_ops)</span>
        <span class="s1">url_parts = _parts(url_ops)</span>
        <span class="s2">if not </span><span class="s1">append_unknown:</span>
            <span class="s1">body = []</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">body = [_IF_KWARGS_URL_ENCODE_AST]</span>
            <span class="s1">url_parts.extend(_URL_ENCODE_AST_NAMES)</span>

        <span class="s2">def </span><span class="s1">_join(parts: t.List[ast.AST]) -&gt; ast.AST:</span>
            <span class="s2">if </span><span class="s1">len(parts) == </span><span class="s5">1</span><span class="s1">:  </span><span class="s4"># shortcut</span>
                <span class="s2">return </span><span class="s1">parts[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">return </span><span class="s1">ast.JoinedStr(parts)</span>

        <span class="s1">body.append(</span>
            <span class="s1">ast.Return(ast.Tuple([_join(dom_parts)</span><span class="s2">, </span><span class="s1">_join(url_parts)]</span><span class="s2">, </span><span class="s1">ast.Load()))</span>
        <span class="s1">)</span>

        <span class="s1">pargs = [</span>
            <span class="s1">elem</span>
            <span class="s2">for </span><span class="s1">is_dynamic</span><span class="s2">, </span><span class="s1">elem </span><span class="s2">in </span><span class="s1">dom_ops + url_ops</span>
            <span class="s2">if </span><span class="s1">is_dynamic </span><span class="s2">and </span><span class="s1">elem </span><span class="s2">not in </span><span class="s1">defaults</span>
        <span class="s1">]</span>
        <span class="s1">kargs = [str(k) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">defaults]</span>

        <span class="s1">func_ast: ast.FunctionDef = _prefix_names(</span><span class="s3">&quot;def _(): pass&quot;</span><span class="s1">)  </span><span class="s4"># type: ignore</span>
        <span class="s1">func_ast.name = </span><span class="s3">f&quot;&lt;builder:</span><span class="s2">{</span><span class="s1">self.rule</span><span class="s2">!r}</span><span class="s3">&gt;&quot;</span>
        <span class="s1">func_ast.args.args.append(ast.arg(</span><span class="s3">&quot;.self&quot;</span><span class="s2">, None</span><span class="s1">))</span>
        <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">pargs + kargs:</span>
            <span class="s1">func_ast.args.args.append(ast.arg(arg</span><span class="s2">, None</span><span class="s1">))</span>
        <span class="s1">func_ast.args.kwarg = ast.arg(</span><span class="s3">&quot;.kwargs&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">kargs:</span>
            <span class="s1">func_ast.args.defaults.append(ast.Str(</span><span class="s3">&quot;&quot;</span><span class="s1">))</span>
        <span class="s1">func_ast.body = body</span>

        <span class="s4"># use `ast.parse` instead of `ast.Module` for better portability</span>
        <span class="s4"># Python 3.8 changes the signature of `ast.Module`</span>
        <span class="s1">module = ast.parse(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">module.body = [func_ast]</span>

        <span class="s4"># mark everything as on line 1, offset 0</span>
        <span class="s4"># less error-prone than `ast.fix_missing_locations`</span>
        <span class="s4"># bad line numbers cause an assert to fail in debug builds</span>
        <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">ast.walk(module):</span>
            <span class="s2">if </span><span class="s3">&quot;lineno&quot; </span><span class="s2">in </span><span class="s1">node._attributes:</span>
                <span class="s1">node.lineno = </span><span class="s5">1</span>
            <span class="s2">if </span><span class="s3">&quot;col_offset&quot; </span><span class="s2">in </span><span class="s1">node._attributes:</span>
                <span class="s1">node.col_offset = </span><span class="s5">0</span>

        <span class="s1">code = compile(module</span><span class="s2">, </span><span class="s3">&quot;&lt;werkzeug routing&gt;&quot;</span><span class="s2">, </span><span class="s3">&quot;exec&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._get_func_code(code</span><span class="s2">, </span><span class="s1">func_ast.name)</span>

    <span class="s2">def </span><span class="s1">build(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">values: t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">, </span><span class="s1">append_unknown: bool = </span><span class="s2">True</span>
    <span class="s1">) -&gt; t.Optional[t.Tuple[str</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s0">&quot;&quot;&quot;Assembles the relative url for that rule and the subdomain. 
        If building doesn't work for some reasons `None` is returned. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">append_unknown:</span>
                <span class="s2">return </span><span class="s1">self._build_unknown(**values)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self._build(**values)</span>
        <span class="s2">except </span><span class="s1">ValidationError:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">provides_defaults_for(self</span><span class="s2">, </span><span class="s1">rule: </span><span class="s3">&quot;Rule&quot;</span><span class="s1">) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Check if this rule has defaults for a given rule. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">bool(</span>
            <span class="s2">not </span><span class="s1">self.build_only</span>
            <span class="s2">and </span><span class="s1">self.defaults</span>
            <span class="s2">and </span><span class="s1">self.endpoint == rule.endpoint</span>
            <span class="s2">and </span><span class="s1">self != rule</span>
            <span class="s2">and </span><span class="s1">self.arguments == rule.arguments</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">suitable_for(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">values: t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">, </span><span class="s1">method: t.Optional[str] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Check if the dict of values has enough data for url generation. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s4"># if a method was given explicitly and that method is not supported</span>
        <span class="s4"># by this rule, this rule is not suitable.</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">method </span><span class="s2">is not None</span>
            <span class="s2">and </span><span class="s1">self.methods </span><span class="s2">is not None</span>
            <span class="s2">and </span><span class="s1">method </span><span class="s2">not in </span><span class="s1">self.methods</span>
        <span class="s1">):</span>
            <span class="s2">return False</span>

        <span class="s1">defaults = self.defaults </span><span class="s2">or </span><span class="s1">()</span>

        <span class="s4"># all arguments required must be either in the defaults dict or</span>
        <span class="s4"># the value dictionary otherwise it's not suitable</span>
        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self.arguments:</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">defaults </span><span class="s2">and </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">values:</span>
                <span class="s2">return False</span>

        <span class="s4"># in case defaults are given we ensure that either the value was</span>
        <span class="s4"># skipped or the value is the same as the default value.</span>
        <span class="s2">if </span><span class="s1">defaults:</span>
            <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">defaults.items():</span>
                <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">values </span><span class="s2">and </span><span class="s1">value != values[key]:</span>
                    <span class="s2">return False</span>

        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">match_compare_key(</span>
        <span class="s1">self</span><span class="s2">,</span>
    <span class="s1">) -&gt; t.Tuple[bool</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">t.Iterable[t.Tuple[int</span><span class="s2">, </span><span class="s1">int]]</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">t.Iterable[int]]:</span>
        <span class="s0">&quot;&quot;&quot;The match compare key for sorting. 
 
        Current implementation: 
 
        1.  rules without any arguments come first for performance 
            reasons only as we expect them to match faster and some 
            common ones usually don't have any arguments (index pages etc.) 
        2.  rules with more static parts come first so the second argument 
            is the negative length of the number of the static weights. 
        3.  we order by static weights, which is a combination of index 
            and length 
        4.  The more complex rules come first so the next argument is the 
            negative length of the number of argument weights. 
        5.  lastly we order by the actual argument weights. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">bool(self.arguments)</span><span class="s2">,</span>
            <span class="s1">-len(self._static_weights)</span><span class="s2">,</span>
            <span class="s1">self._static_weights</span><span class="s2">,</span>
            <span class="s1">-len(self._argument_weights)</span><span class="s2">,</span>
            <span class="s1">self._argument_weights</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">build_compare_key(self) -&gt; t.Tuple[int</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">int]:</span>
        <span class="s0">&quot;&quot;&quot;The build compare key for sorting. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s5">1 </span><span class="s2">if </span><span class="s1">self.alias </span><span class="s2">else </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-len(self.arguments)</span><span class="s2">, </span><span class="s1">-len(self.defaults </span><span class="s2">or </span><span class="s1">()))</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other: object) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">type(self)) </span><span class="s2">and </span><span class="s1">self._trace == other._trace</span>

    <span class="s1">__hash__ = </span><span class="s2">None  </span><span class="s4"># type: ignore</span>

    <span class="s2">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self.rule</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">if </span><span class="s1">self.map </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">f&quot;&lt;</span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">} </span><span class="s3">(unbound)&gt;&quot;</span>
        <span class="s1">parts = []</span>
        <span class="s2">for </span><span class="s1">is_dynamic</span><span class="s2">, </span><span class="s1">data </span><span class="s2">in </span><span class="s1">self._trace:</span>
            <span class="s2">if </span><span class="s1">is_dynamic:</span>
                <span class="s1">parts.append(</span><span class="s3">f&quot;&lt;</span><span class="s2">{</span><span class="s1">data</span><span class="s2">}</span><span class="s3">&gt;&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">parts.append(data)</span>
        <span class="s1">parts = </span><span class="s3">&quot;&quot;</span><span class="s1">.join(parts).lstrip(</span><span class="s3">&quot;|&quot;</span><span class="s1">)</span>
        <span class="s1">methods = </span><span class="s3">f&quot; (</span><span class="s2">{</span><span class="s3">', '</span><span class="s1">.join(self.methods)</span><span class="s2">}</span><span class="s3">)&quot; </span><span class="s2">if </span><span class="s1">self.methods </span><span class="s2">is not None else </span><span class="s3">&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">f&quot;&lt;</span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">} {</span><span class="s1">parts</span><span class="s2">!r}{</span><span class="s1">methods</span><span class="s2">} </span><span class="s3">-&gt; </span><span class="s2">{</span><span class="s1">self.endpoint</span><span class="s2">}</span><span class="s3">&gt;&quot;</span>


<span class="s2">class </span><span class="s1">BaseConverter:</span>
    <span class="s0">&quot;&quot;&quot;Base class for all converters.&quot;&quot;&quot;</span>

    <span class="s1">regex = </span><span class="s3">&quot;[^/]+&quot;</span>
    <span class="s1">weight = </span><span class="s5">100</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">map: </span><span class="s3">&quot;Map&quot;</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.map = map</span>

    <span class="s2">def </span><span class="s1">to_python(self</span><span class="s2">, </span><span class="s1">value: str) -&gt; t.Any:</span>
        <span class="s2">return </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">to_url(self</span><span class="s2">, </span><span class="s1">value: t.Any) -&gt; str:</span>
        <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">(bytes</span><span class="s2">, </span><span class="s1">bytearray)):</span>
            <span class="s2">return </span><span class="s1">_fast_url_quote(value)</span>
        <span class="s2">return </span><span class="s1">_fast_url_quote(str(value).encode(self.map.charset))</span>


<span class="s2">class </span><span class="s1">UnicodeConverter(BaseConverter):</span>
    <span class="s0">&quot;&quot;&quot;This converter is the default converter and accepts any string but 
    only one path segment.  Thus the string can not include a slash. 
 
    This is the default validator. 
 
    Example:: 
 
        Rule('/pages/&lt;page&gt;'), 
        Rule('/&lt;string(length=2):lang_code&gt;') 
 
    :param map: the :class:`Map`. 
    :param minlength: the minimum length of the string.  Must be greater 
                      or equal 1. 
    :param maxlength: the maximum length of the string. 
    :param length: the exact length of the string. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">map: </span><span class="s3">&quot;Map&quot;</span><span class="s2">,</span>
        <span class="s1">minlength: int = </span><span class="s5">1</span><span class="s2">,</span>
        <span class="s1">maxlength: t.Optional[int] = </span><span class="s2">None,</span>
        <span class="s1">length: t.Optional[int] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(map)</span>
        <span class="s2">if </span><span class="s1">length </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">length_regex = </span><span class="s3">f&quot;</span><span class="s2">{{{</span><span class="s1">int(length)</span><span class="s2">}}}</span><span class="s3">&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">maxlength </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">maxlength_value = </span><span class="s3">&quot;&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">maxlength_value = str(int(maxlength))</span>
            <span class="s1">length_regex = </span><span class="s3">f&quot;</span><span class="s2">{{{</span><span class="s1">int(minlength)</span><span class="s2">}</span><span class="s3">,</span><span class="s2">{</span><span class="s1">maxlength_value</span><span class="s2">}}}</span><span class="s3">&quot;</span>
        <span class="s1">self.regex = </span><span class="s3">f&quot;[^/]</span><span class="s2">{</span><span class="s1">length_regex</span><span class="s2">}</span><span class="s3">&quot;</span>


<span class="s2">class </span><span class="s1">AnyConverter(BaseConverter):</span>
    <span class="s0">&quot;&quot;&quot;Matches one of the items provided.  Items can either be Python 
    identifiers or strings:: 
 
        Rule('/&lt;any(about, help, imprint, class, &quot;foo,bar&quot;):page_name&gt;') 
 
    :param map: the :class:`Map`. 
    :param items: this function accepts the possible items as positional 
                  arguments. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">map: </span><span class="s3">&quot;Map&quot;</span><span class="s2">, </span><span class="s1">*items: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(map)</span>
        <span class="s1">self.regex = </span><span class="s3">f&quot;(?:</span><span class="s2">{</span><span class="s3">'|'</span><span class="s1">.join([re.escape(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">items])</span><span class="s2">}</span><span class="s3">)&quot;</span>


<span class="s2">class </span><span class="s1">PathConverter(BaseConverter):</span>
    <span class="s0">&quot;&quot;&quot;Like the default :class:`UnicodeConverter`, but it also matches 
    slashes.  This is useful for wikis and similar applications:: 
 
        Rule('/&lt;path:wikipage&gt;') 
        Rule('/&lt;path:wikipage&gt;/edit') 
 
    :param map: the :class:`Map`. 
    &quot;&quot;&quot;</span>

    <span class="s1">regex = </span><span class="s3">&quot;[^/].*?&quot;</span>
    <span class="s1">weight = </span><span class="s5">200</span>


<span class="s2">class </span><span class="s1">NumberConverter(BaseConverter):</span>
    <span class="s0">&quot;&quot;&quot;Baseclass for `IntegerConverter` and `FloatConverter`. 
 
    :internal: 
    &quot;&quot;&quot;</span>

    <span class="s1">weight = </span><span class="s5">50</span>
    <span class="s1">num_convert: t.Callable = int</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">map: </span><span class="s3">&quot;Map&quot;</span><span class="s2">,</span>
        <span class="s1">fixed_digits: int = </span><span class="s5">0</span><span class="s2">,</span>
        <span class="s1">min: t.Optional[int] = </span><span class="s2">None,</span>
        <span class="s1">max: t.Optional[int] = </span><span class="s2">None,</span>
        <span class="s1">signed: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">signed:</span>
            <span class="s1">self.regex = self.signed_regex</span>
        <span class="s1">super().__init__(map)</span>
        <span class="s1">self.fixed_digits = fixed_digits</span>
        <span class="s1">self.min = min</span>
        <span class="s1">self.max = max</span>
        <span class="s1">self.signed = signed</span>

    <span class="s2">def </span><span class="s1">to_python(self</span><span class="s2">, </span><span class="s1">value: str) -&gt; t.Any:</span>
        <span class="s2">if </span><span class="s1">self.fixed_digits </span><span class="s2">and </span><span class="s1">len(value) != self.fixed_digits:</span>
            <span class="s2">raise </span><span class="s1">ValidationError()</span>
        <span class="s1">value = self.num_convert(value)</span>
        <span class="s2">if </span><span class="s1">(self.min </span><span class="s2">is not None and </span><span class="s1">value &lt; self.min) </span><span class="s2">or </span><span class="s1">(</span>
            <span class="s1">self.max </span><span class="s2">is not None and </span><span class="s1">value &gt; self.max</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValidationError()</span>
        <span class="s2">return </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">to_url(self</span><span class="s2">, </span><span class="s1">value: t.Any) -&gt; str:</span>
        <span class="s1">value = str(self.num_convert(value))</span>
        <span class="s2">if </span><span class="s1">self.fixed_digits:</span>
            <span class="s1">value = value.zfill(self.fixed_digits)</span>
        <span class="s2">return </span><span class="s1">value</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">signed_regex(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">f&quot;-?</span><span class="s2">{</span><span class="s1">self.regex</span><span class="s2">}</span><span class="s3">&quot;</span>


<span class="s2">class </span><span class="s1">IntegerConverter(NumberConverter):</span>
    <span class="s0">&quot;&quot;&quot;This converter only accepts integer values:: 
 
        Rule(&quot;/page/&lt;int:page&gt;&quot;) 
 
    By default it only accepts unsigned, positive values. The ``signed`` 
    parameter will enable signed, negative values. :: 
 
        Rule(&quot;/page/&lt;int(signed=True):page&gt;&quot;) 
 
    :param map: The :class:`Map`. 
    :param fixed_digits: The number of fixed digits in the URL. If you 
        set this to ``4`` for example, the rule will only match if the 
        URL looks like ``/0001/``. The default is variable length. 
    :param min: The minimal value. 
    :param max: The maximal value. 
    :param signed: Allow signed (negative) values. 
 
    .. versionadded:: 0.15 
        The ``signed`` parameter. 
    &quot;&quot;&quot;</span>

    <span class="s1">regex = </span><span class="s3">r&quot;\d+&quot;</span>


<span class="s2">class </span><span class="s1">FloatConverter(NumberConverter):</span>
    <span class="s0">&quot;&quot;&quot;This converter only accepts floating point values:: 
 
        Rule(&quot;/probability/&lt;float:probability&gt;&quot;) 
 
    By default it only accepts unsigned, positive values. The ``signed`` 
    parameter will enable signed, negative values. :: 
 
        Rule(&quot;/offset/&lt;float(signed=True):offset&gt;&quot;) 
 
    :param map: The :class:`Map`. 
    :param min: The minimal value. 
    :param max: The maximal value. 
    :param signed: Allow signed (negative) values. 
 
    .. versionadded:: 0.15 
        The ``signed`` parameter. 
    &quot;&quot;&quot;</span>

    <span class="s1">regex = </span><span class="s3">r&quot;\d+\.\d+&quot;</span>
    <span class="s1">num_convert = float</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">map: </span><span class="s3">&quot;Map&quot;</span><span class="s2">,</span>
        <span class="s1">min: t.Optional[float] = </span><span class="s2">None,</span>
        <span class="s1">max: t.Optional[float] = </span><span class="s2">None,</span>
        <span class="s1">signed: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(map</span><span class="s2">, </span><span class="s1">min=min</span><span class="s2">, </span><span class="s1">max=max</span><span class="s2">, </span><span class="s1">signed=signed)  </span><span class="s4"># type: ignore</span>


<span class="s2">class </span><span class="s1">UUIDConverter(BaseConverter):</span>
    <span class="s0">&quot;&quot;&quot;This converter only accepts UUID strings:: 
 
        Rule('/object/&lt;uuid:identifier&gt;') 
 
    .. versionadded:: 0.10 
 
    :param map: the :class:`Map`. 
    &quot;&quot;&quot;</span>

    <span class="s1">regex = (</span>
        <span class="s3">r&quot;[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-&quot;</span>
        <span class="s3">r&quot;[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}&quot;</span>
    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">to_python(self</span><span class="s2">, </span><span class="s1">value: str) -&gt; uuid.UUID:</span>
        <span class="s2">return </span><span class="s1">uuid.UUID(value)</span>

    <span class="s2">def </span><span class="s1">to_url(self</span><span class="s2">, </span><span class="s1">value: uuid.UUID) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">str(value)</span>


<span class="s4">#: the default converter mapping for the map.</span>
<span class="s1">DEFAULT_CONVERTERS: t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Type[BaseConverter]] = {</span>
    <span class="s3">&quot;default&quot;</span><span class="s1">: UnicodeConverter</span><span class="s2">,</span>
    <span class="s3">&quot;string&quot;</span><span class="s1">: UnicodeConverter</span><span class="s2">,</span>
    <span class="s3">&quot;any&quot;</span><span class="s1">: AnyConverter</span><span class="s2">,</span>
    <span class="s3">&quot;path&quot;</span><span class="s1">: PathConverter</span><span class="s2">,</span>
    <span class="s3">&quot;int&quot;</span><span class="s1">: IntegerConverter</span><span class="s2">,</span>
    <span class="s3">&quot;float&quot;</span><span class="s1">: FloatConverter</span><span class="s2">,</span>
    <span class="s3">&quot;uuid&quot;</span><span class="s1">: UUIDConverter</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s2">class </span><span class="s1">Map:</span>
    <span class="s0">&quot;&quot;&quot;The map class stores all the URL rules and some configuration 
    parameters.  Some of the configuration values are only stored on the 
    `Map` instance since those affect all rules, others are just defaults 
    and can be overridden for each rule.  Note that you have to specify all 
    arguments besides the `rules` as keyword arguments! 
 
    :param rules: sequence of url rules for this map. 
    :param default_subdomain: The default subdomain for rules without a 
                              subdomain defined. 
    :param charset: charset of the url. defaults to ``&quot;utf-8&quot;`` 
    :param strict_slashes: If a rule ends with a slash but the matched 
        URL does not, redirect to the URL with a trailing slash. 
    :param merge_slashes: Merge consecutive slashes when matching or 
        building URLs. Matches will redirect to the normalized URL. 
        Slashes in variable parts are not merged. 
    :param redirect_defaults: This will redirect to the default rule if it 
                              wasn't visited that way. This helps creating 
                              unique URLs. 
    :param converters: A dict of converters that adds additional converters 
                       to the list of converters. If you redefine one 
                       converter this will override the original one. 
    :param sort_parameters: If set to `True` the url parameters are sorted. 
                            See `url_encode` for more details. 
    :param sort_key: The sort key function for `url_encode`. 
    :param encoding_errors: the error method to use for decoding 
    :param host_matching: if set to `True` it enables the host matching 
                          feature and disables the subdomain one.  If 
                          enabled the `host` parameter to rules is used 
                          instead of the `subdomain` one. 
 
    .. versionchanged:: 1.0 
        If ``url_scheme`` is ``ws`` or ``wss``, only WebSocket rules 
        will match. 
 
    .. versionchanged:: 1.0 
        Added ``merge_slashes``. 
 
    .. versionchanged:: 0.7 
        Added ``encoding_errors`` and ``host_matching``. 
 
    .. versionchanged:: 0.5 
        Added ``sort_parameters`` and ``sort_key``. 
    &quot;&quot;&quot;</span>

    <span class="s4">#: A dict of default converters to be used.</span>
    <span class="s1">default_converters = ImmutableDict(DEFAULT_CONVERTERS)</span>

    <span class="s4">#: The type of lock to use when updating.</span>
    <span class="s4">#:</span>
    <span class="s4">#: .. versionadded:: 1.0</span>
    <span class="s1">lock_class = Lock</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">rules: t.Optional[t.Iterable[RuleFactory]] = </span><span class="s2">None,</span>
        <span class="s1">default_subdomain: str = </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
        <span class="s1">charset: str = </span><span class="s3">&quot;utf-8&quot;</span><span class="s2">,</span>
        <span class="s1">strict_slashes: bool = </span><span class="s2">True,</span>
        <span class="s1">merge_slashes: bool = </span><span class="s2">True,</span>
        <span class="s1">redirect_defaults: bool = </span><span class="s2">True,</span>
        <span class="s1">converters: t.Optional[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Type[BaseConverter]]] = </span><span class="s2">None,</span>
        <span class="s1">sort_parameters: bool = </span><span class="s2">False,</span>
        <span class="s1">sort_key: t.Optional[t.Callable[[t.Any]</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
        <span class="s1">encoding_errors: str = </span><span class="s3">&quot;replace&quot;</span><span class="s2">,</span>
        <span class="s1">host_matching: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._rules: t.List[Rule] = []</span>
        <span class="s1">self._rules_by_endpoint: t.Dict[str</span><span class="s2">, </span><span class="s1">t.List[Rule]] = {}</span>
        <span class="s1">self._remap = </span><span class="s2">True</span>
        <span class="s1">self._remap_lock = self.lock_class()</span>

        <span class="s1">self.default_subdomain = default_subdomain</span>
        <span class="s1">self.charset = charset</span>
        <span class="s1">self.encoding_errors = encoding_errors</span>
        <span class="s1">self.strict_slashes = strict_slashes</span>
        <span class="s1">self.merge_slashes = merge_slashes</span>
        <span class="s1">self.redirect_defaults = redirect_defaults</span>
        <span class="s1">self.host_matching = host_matching</span>

        <span class="s1">self.converters = self.default_converters.copy()</span>
        <span class="s2">if </span><span class="s1">converters:</span>
            <span class="s1">self.converters.update(converters)</span>

        <span class="s1">self.sort_parameters = sort_parameters</span>
        <span class="s1">self.sort_key = sort_key</span>

        <span class="s2">for </span><span class="s1">rulefactory </span><span class="s2">in </span><span class="s1">rules </span><span class="s2">or </span><span class="s1">():</span>
            <span class="s1">self.add(rulefactory)</span>

    <span class="s2">def </span><span class="s1">is_endpoint_expecting(self</span><span class="s2">, </span><span class="s1">endpoint: str</span><span class="s2">, </span><span class="s1">*arguments: str) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Iterate over all rules and check if the endpoint expects 
        the arguments provided.  This is for example useful if you have 
        some URLs that expect a language code and others that do not and 
        you want to wrap the builder a bit so that the current language 
        code is automatically added if not provided but endpoints expect 
        it. 
 
        :param endpoint: the endpoint to check. 
        :param arguments: this function accepts one or more arguments 
                          as positional arguments.  Each one of them is 
                          checked. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.update()</span>
        <span class="s1">arguments = set(arguments)</span>
        <span class="s2">for </span><span class="s1">rule </span><span class="s2">in </span><span class="s1">self._rules_by_endpoint[endpoint]:</span>
            <span class="s2">if </span><span class="s1">arguments.issubset(rule.arguments):</span>
                <span class="s2">return True</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">iter_rules(self</span><span class="s2">, </span><span class="s1">endpoint: t.Optional[str] = </span><span class="s2">None</span><span class="s1">) -&gt; t.Iterator[Rule]:</span>
        <span class="s0">&quot;&quot;&quot;Iterate over all rules or the rules of an endpoint. 
 
        :param endpoint: if provided only the rules for that endpoint 
                         are returned. 
        :return: an iterator 
        &quot;&quot;&quot;</span>
        <span class="s1">self.update()</span>
        <span class="s2">if </span><span class="s1">endpoint </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">iter(self._rules_by_endpoint[endpoint])</span>
        <span class="s2">return </span><span class="s1">iter(self._rules)</span>

    <span class="s2">def </span><span class="s1">add(self</span><span class="s2">, </span><span class="s1">rulefactory: RuleFactory) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Add a new rule or factory to the map and bind it.  Requires that the 
        rule is not bound to another map. 
 
        :param rulefactory: a :class:`Rule` or :class:`RuleFactory` 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">rule </span><span class="s2">in </span><span class="s1">rulefactory.get_rules(self):</span>
            <span class="s1">rule.bind(self)</span>
            <span class="s1">self._rules.append(rule)</span>
            <span class="s1">self._rules_by_endpoint.setdefault(rule.endpoint</span><span class="s2">, </span><span class="s1">[]).append(rule)</span>
        <span class="s1">self._remap = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">bind(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">server_name: str</span><span class="s2">,</span>
        <span class="s1">script_name: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">subdomain: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">url_scheme: str = </span><span class="s3">&quot;http&quot;</span><span class="s2">,</span>
        <span class="s1">default_method: str = </span><span class="s3">&quot;GET&quot;</span><span class="s2">,</span>
        <span class="s1">path_info: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">query_args: t.Optional[t.Union[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;MapAdapter&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Return a new :class:`MapAdapter` with the details specified to the 
        call.  Note that `script_name` will default to ``'/'`` if not further 
        specified or `None`.  The `server_name` at least is a requirement 
        because the HTTP RFC requires absolute URLs for redirects and so all 
        redirect exceptions raised by Werkzeug will contain the full canonical 
        URL. 
 
        If no path_info is passed to :meth:`match` it will use the default path 
        info passed to bind.  While this doesn't really make sense for 
        manual bind calls, it's useful if you bind a map to a WSGI 
        environment which already contains the path info. 
 
        `subdomain` will default to the `default_subdomain` for this map if 
        no defined. If there is no `default_subdomain` you cannot use the 
        subdomain feature. 
 
        .. versionchanged:: 1.0 
            If ``url_scheme`` is ``ws`` or ``wss``, only WebSocket rules 
            will match. 
 
        .. versionchanged:: 0.15 
            ``path_info`` defaults to ``'/'`` if ``None``. 
 
        .. versionchanged:: 0.8 
            ``query_args`` can be a string. 
 
        .. versionchanged:: 0.7 
            Added ``query_args``. 
        &quot;&quot;&quot;</span>
        <span class="s1">server_name = server_name.lower()</span>
        <span class="s2">if </span><span class="s1">self.host_matching:</span>
            <span class="s2">if </span><span class="s1">subdomain </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;host matching enabled and a subdomain was provided&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">subdomain </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">subdomain = self.default_subdomain</span>
        <span class="s2">if </span><span class="s1">script_name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">script_name = </span><span class="s3">&quot;/&quot;</span>
        <span class="s2">if </span><span class="s1">path_info </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">path_info = </span><span class="s3">&quot;/&quot;</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">server_name = _encode_idna(server_name)  </span><span class="s4"># type: ignore</span>
        <span class="s2">except </span><span class="s1">UnicodeError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">BadHost() </span><span class="s2">from </span><span class="s1">e</span>

        <span class="s2">return </span><span class="s1">MapAdapter(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">server_name</span><span class="s2">,</span>
            <span class="s1">script_name</span><span class="s2">,</span>
            <span class="s1">subdomain</span><span class="s2">,</span>
            <span class="s1">url_scheme</span><span class="s2">,</span>
            <span class="s1">path_info</span><span class="s2">,</span>
            <span class="s1">default_method</span><span class="s2">,</span>
            <span class="s1">query_args</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">bind_to_environ(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">environ: </span><span class="s3">&quot;WSGIEnvironment&quot;</span><span class="s2">,</span>
        <span class="s1">server_name: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">subdomain: t.Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;MapAdapter&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Like :meth:`bind` but you can pass it an WSGI environment and it 
        will fetch the information from that dictionary.  Note that because of 
        limitations in the protocol there is no way to get the current 
        subdomain and real `server_name` from the environment.  If you don't 
        provide it, Werkzeug will use `SERVER_NAME` and `SERVER_PORT` (or 
        `HTTP_HOST` if provided) as used `server_name` with disabled subdomain 
        feature. 
 
        If `subdomain` is `None` but an environment and a server name is 
        provided it will calculate the current subdomain automatically. 
        Example: `server_name` is ``'example.com'`` and the `SERVER_NAME` 
        in the wsgi `environ` is ``'staging.dev.example.com'`` the calculated 
        subdomain will be ``'staging.dev'``. 
 
        If the object passed as environ has an environ attribute, the value of 
        this attribute is used instead.  This allows you to pass request 
        objects.  Additionally `PATH_INFO` added as a default of the 
        :class:`MapAdapter` so that you don't have to pass the path info to 
        the match method. 
 
        .. versionchanged:: 1.0.0 
            If the passed server name specifies port 443, it will match 
            if the incoming scheme is ``https`` without a port. 
 
        .. versionchanged:: 1.0.0 
            A warning is shown when the passed server name does not 
            match the incoming WSGI server name. 
 
        .. versionchanged:: 0.8 
           This will no longer raise a ValueError when an unexpected server 
           name was passed. 
 
        .. versionchanged:: 0.5 
            previously this method accepted a bogus `calculate_subdomain` 
            parameter that did not have any effect.  It was removed because 
            of that. 
 
        :param environ: a WSGI environment. 
        :param server_name: an optional server name hint (see above). 
        :param subdomain: optionally the current subdomain (see above). 
        &quot;&quot;&quot;</span>
        <span class="s1">environ = _get_environ(environ)</span>
        <span class="s1">wsgi_server_name = get_host(environ).lower()</span>
        <span class="s1">scheme = environ[</span><span class="s3">&quot;wsgi.url_scheme&quot;</span><span class="s1">]</span>
        <span class="s1">upgrade = any(</span>
            <span class="s1">v.strip() == </span><span class="s3">&quot;upgrade&quot;</span>
            <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">environ.get(</span><span class="s3">&quot;HTTP_CONNECTION&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">).lower().split(</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">upgrade </span><span class="s2">and </span><span class="s1">environ.get(</span><span class="s3">&quot;HTTP_UPGRADE&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">).lower() == </span><span class="s3">&quot;websocket&quot;</span><span class="s1">:</span>
            <span class="s1">scheme = </span><span class="s3">&quot;wss&quot; </span><span class="s2">if </span><span class="s1">scheme == </span><span class="s3">&quot;https&quot; </span><span class="s2">else </span><span class="s3">&quot;ws&quot;</span>

        <span class="s2">if </span><span class="s1">server_name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">server_name = wsgi_server_name</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">server_name = server_name.lower()</span>

            <span class="s4"># strip standard port to match get_host()</span>
            <span class="s2">if </span><span class="s1">scheme </span><span class="s2">in </span><span class="s1">{</span><span class="s3">&quot;http&quot;</span><span class="s2">, </span><span class="s3">&quot;ws&quot;</span><span class="s1">} </span><span class="s2">and </span><span class="s1">server_name.endswith(</span><span class="s3">&quot;:80&quot;</span><span class="s1">):</span>
                <span class="s1">server_name = server_name[:-</span><span class="s5">3</span><span class="s1">]</span>
            <span class="s2">elif </span><span class="s1">scheme </span><span class="s2">in </span><span class="s1">{</span><span class="s3">&quot;https&quot;</span><span class="s2">, </span><span class="s3">&quot;wss&quot;</span><span class="s1">} </span><span class="s2">and </span><span class="s1">server_name.endswith(</span><span class="s3">&quot;:443&quot;</span><span class="s1">):</span>
                <span class="s1">server_name = server_name[:-</span><span class="s5">4</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">subdomain </span><span class="s2">is None and not </span><span class="s1">self.host_matching:</span>
            <span class="s1">cur_server_name = wsgi_server_name.split(</span><span class="s3">&quot;.&quot;</span><span class="s1">)</span>
            <span class="s1">real_server_name = server_name.split(</span><span class="s3">&quot;.&quot;</span><span class="s1">)</span>
            <span class="s1">offset = -len(real_server_name)</span>

            <span class="s2">if </span><span class="s1">cur_server_name[offset:] != real_server_name:</span>
                <span class="s4"># This can happen even with valid configs if the server was</span>
                <span class="s4"># accessed directly by IP address under some situations.</span>
                <span class="s4"># Instead of raising an exception like in Werkzeug 0.7 or</span>
                <span class="s4"># earlier we go by an invalid subdomain which will result</span>
                <span class="s4"># in a 404 error on matching.</span>
                <span class="s1">warnings.warn(</span>
                    <span class="s3">f&quot;Current server name </span><span class="s2">{</span><span class="s1">wsgi_server_name</span><span class="s2">!r} </span><span class="s3">doesn't match configured&quot;</span>
                    <span class="s3">f&quot; server name </span><span class="s2">{</span><span class="s1">server_name</span><span class="s2">!r}</span><span class="s3">&quot;</span><span class="s2">,</span>
                    <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s1">subdomain = </span><span class="s3">&quot;&lt;invalid&gt;&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">subdomain = </span><span class="s3">&quot;.&quot;</span><span class="s1">.join(filter(</span><span class="s2">None, </span><span class="s1">cur_server_name[:offset]))</span>

        <span class="s2">def </span><span class="s1">_get_wsgi_string(name: str) -&gt; t.Optional[str]:</span>
            <span class="s1">val = environ.get(name)</span>
            <span class="s2">if </span><span class="s1">val </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">_wsgi_decoding_dance(val</span><span class="s2">, </span><span class="s1">self.charset)</span>
            <span class="s2">return None</span>

        <span class="s1">script_name = _get_wsgi_string(</span><span class="s3">&quot;SCRIPT_NAME&quot;</span><span class="s1">)</span>
        <span class="s1">path_info = _get_wsgi_string(</span><span class="s3">&quot;PATH_INFO&quot;</span><span class="s1">)</span>
        <span class="s1">query_args = _get_wsgi_string(</span><span class="s3">&quot;QUERY_STRING&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">Map.bind(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">server_name</span><span class="s2">,</span>
            <span class="s1">script_name</span><span class="s2">,</span>
            <span class="s1">subdomain</span><span class="s2">,</span>
            <span class="s1">scheme</span><span class="s2">,</span>
            <span class="s1">environ[</span><span class="s3">&quot;REQUEST_METHOD&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">path_info</span><span class="s2">,</span>
            <span class="s1">query_args=query_args</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">update(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Called before matching and building to keep the compiled rules 
        in the correct order after things changed. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._remap:</span>
            <span class="s2">return</span>

        <span class="s2">with </span><span class="s1">self._remap_lock:</span>
            <span class="s2">if not </span><span class="s1">self._remap:</span>
                <span class="s2">return</span>

            <span class="s1">self._rules.sort(key=</span><span class="s2">lambda </span><span class="s1">x: x.match_compare_key())</span>
            <span class="s2">for </span><span class="s1">rules </span><span class="s2">in </span><span class="s1">self._rules_by_endpoint.values():</span>
                <span class="s1">rules.sort(key=</span><span class="s2">lambda </span><span class="s1">x: x.build_compare_key())</span>
            <span class="s1">self._remap = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s1">rules = self.iter_rules()</span>
        <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">}</span><span class="s3">(</span><span class="s2">{</span><span class="s1">pformat(list(rules))</span><span class="s2">}</span><span class="s3">)&quot;</span>


<span class="s2">class </span><span class="s1">MapAdapter:</span>

    <span class="s0">&quot;&quot;&quot;Returned by :meth:`Map.bind` or :meth:`Map.bind_to_environ` and does 
    the URL matching and building based on runtime information. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">map: Map</span><span class="s2">,</span>
        <span class="s1">server_name: str</span><span class="s2">,</span>
        <span class="s1">script_name: str</span><span class="s2">,</span>
        <span class="s1">subdomain: t.Optional[str]</span><span class="s2">,</span>
        <span class="s1">url_scheme: str</span><span class="s2">,</span>
        <span class="s1">path_info: str</span><span class="s2">,</span>
        <span class="s1">default_method: str</span><span class="s2">,</span>
        <span class="s1">query_args: t.Optional[t.Union[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">self.map = map</span>
        <span class="s1">self.server_name = _to_str(server_name)</span>
        <span class="s1">script_name = _to_str(script_name)</span>
        <span class="s2">if not </span><span class="s1">script_name.endswith(</span><span class="s3">&quot;/&quot;</span><span class="s1">):</span>
            <span class="s1">script_name += </span><span class="s3">&quot;/&quot;</span>
        <span class="s1">self.script_name = script_name</span>
        <span class="s1">self.subdomain = _to_str(subdomain)</span>
        <span class="s1">self.url_scheme = _to_str(url_scheme)</span>
        <span class="s1">self.path_info = _to_str(path_info)</span>
        <span class="s1">self.default_method = _to_str(default_method)</span>
        <span class="s1">self.query_args = query_args</span>
        <span class="s1">self.websocket = self.url_scheme </span><span class="s2">in </span><span class="s1">{</span><span class="s3">&quot;ws&quot;</span><span class="s2">, </span><span class="s3">&quot;wss&quot;</span><span class="s1">}</span>

    <span class="s2">def </span><span class="s1">dispatch(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">view_func: t.Callable[[str</span><span class="s2">, </span><span class="s1">t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]]</span><span class="s2">, </span><span class="s3">&quot;WSGIApplication&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">path_info: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">method: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">catch_http_exceptions: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;WSGIApplication&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Does the complete dispatching process.  `view_func` is called with 
        the endpoint and a dict with the values for the view.  It should 
        look up the view function, call it, and return a response object 
        or WSGI application.  http exceptions are not caught by default 
        so that applications can display nicer error messages by just 
        catching them by hand.  If you want to stick with the default 
        error messages you can pass it ``catch_http_exceptions=True`` and 
        it will catch the http exceptions. 
 
        Here a small example for the dispatch usage:: 
 
            from werkzeug.wrappers import Request, Response 
            from werkzeug.wsgi import responder 
            from werkzeug.routing import Map, Rule 
 
            def on_index(request): 
                return Response('Hello from the index') 
 
            url_map = Map([Rule('/', endpoint='index')]) 
            views = {'index': on_index} 
 
            @responder 
            def application(environ, start_response): 
                request = Request(environ) 
                urls = url_map.bind_to_environ(environ) 
                return urls.dispatch(lambda e, v: views[e](request, **v), 
                                     catch_http_exceptions=True) 
 
        Keep in mind that this method might return exception objects, too, so 
        use :class:`Response.force_type` to get a response object. 
 
        :param view_func: a function that is called with the endpoint as 
                          first argument and the value dict as second.  Has 
                          to dispatch to the actual view function with this 
                          information.  (see above) 
        :param path_info: the path info to use for matching.  Overrides the 
                          path info specified on binding. 
        :param method: the HTTP method used for matching.  Overrides the 
                       method specified on binding. 
        :param catch_http_exceptions: set to `True` to catch any of the 
                                      werkzeug :class:`HTTPException`\\s. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">endpoint</span><span class="s2">, </span><span class="s1">args = self.match(path_info</span><span class="s2">, </span><span class="s1">method)</span>
            <span class="s2">except </span><span class="s1">RequestRedirect </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s2">return </span><span class="s1">e</span>
            <span class="s2">return </span><span class="s1">view_func(endpoint</span><span class="s2">, </span><span class="s1">args)</span>
        <span class="s2">except </span><span class="s1">HTTPException </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">if </span><span class="s1">catch_http_exceptions:</span>
                <span class="s2">return </span><span class="s1">e</span>
            <span class="s2">raise</span>

    <span class="s1">@typing.overload</span>
    <span class="s2">def </span><span class="s1">match(  </span><span class="s4"># type: ignore</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">path_info: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">method: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">return_rule: </span><span class="s3">&quot;te.Literal[False]&quot; </span><span class="s1">= </span><span class="s2">False,</span>
        <span class="s1">query_args: t.Optional[t.Union[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s2">None,</span>
        <span class="s1">websocket: t.Optional[bool] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; t.Tuple[str</span><span class="s2">, </span><span class="s1">t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]]:</span>
        <span class="s1">...</span>

    <span class="s1">@typing.overload</span>
    <span class="s2">def </span><span class="s1">match(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">path_info: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">method: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">return_rule: </span><span class="s3">&quot;te.Literal[True]&quot; </span><span class="s1">= </span><span class="s2">True,</span>
        <span class="s1">query_args: t.Optional[t.Union[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s2">None,</span>
        <span class="s1">websocket: t.Optional[bool] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; t.Tuple[Rule</span><span class="s2">, </span><span class="s1">t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]]:</span>
        <span class="s1">...</span>

    <span class="s2">def </span><span class="s1">match(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">path_info: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">method: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">return_rule: bool = </span><span class="s2">False,</span>
        <span class="s1">query_args: t.Optional[t.Union[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s2">None,</span>
        <span class="s1">websocket: t.Optional[bool] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; t.Tuple[t.Union[str</span><span class="s2">, </span><span class="s1">Rule]</span><span class="s2">, </span><span class="s1">t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]]:</span>
        <span class="s0">&quot;&quot;&quot;The usage is simple: you just pass the match method the current 
        path info as well as the method (which defaults to `GET`).  The 
        following things can then happen: 
 
        - you receive a `NotFound` exception that indicates that no URL is 
          matching.  A `NotFound` exception is also a WSGI application you 
          can call to get a default page not found page (happens to be the 
          same object as `werkzeug.exceptions.NotFound`) 
 
        - you receive a `MethodNotAllowed` exception that indicates that there 
          is a match for this URL but not for the current request method. 
          This is useful for RESTful applications. 
 
        - you receive a `RequestRedirect` exception with a `new_url` 
          attribute.  This exception is used to notify you about a request 
          Werkzeug requests from your WSGI application.  This is for example the 
          case if you request ``/foo`` although the correct URL is ``/foo/`` 
          You can use the `RequestRedirect` instance as response-like object 
          similar to all other subclasses of `HTTPException`. 
 
        - you receive a ``WebsocketMismatch`` exception if the only 
          match is a WebSocket rule but the bind is an HTTP request, or 
          if the match is an HTTP rule but the bind is a WebSocket 
          request. 
 
        - you get a tuple in the form ``(endpoint, arguments)`` if there is 
          a match (unless `return_rule` is True, in which case you get a tuple 
          in the form ``(rule, arguments)``) 
 
        If the path info is not passed to the match method the default path 
        info of the map is used (defaults to the root URL if not defined 
        explicitly). 
 
        All of the exceptions raised are subclasses of `HTTPException` so they 
        can be used as WSGI responses. They will all render generic error or 
        redirect pages. 
 
        Here is a small example for matching: 
 
        &gt;&gt;&gt; m = Map([ 
        ...     Rule('/', endpoint='index'), 
        ...     Rule('/downloads/', endpoint='downloads/index'), 
        ...     Rule('/downloads/&lt;int:id&gt;', endpoint='downloads/show') 
        ... ]) 
        &gt;&gt;&gt; urls = m.bind(&quot;example.com&quot;, &quot;/&quot;) 
        &gt;&gt;&gt; urls.match(&quot;/&quot;, &quot;GET&quot;) 
        ('index', {}) 
        &gt;&gt;&gt; urls.match(&quot;/downloads/42&quot;) 
        ('downloads/show', {'id': 42}) 
 
        And here is what happens on redirect and missing URLs: 
 
        &gt;&gt;&gt; urls.match(&quot;/downloads&quot;) 
        Traceback (most recent call last): 
          ... 
        RequestRedirect: http://example.com/downloads/ 
        &gt;&gt;&gt; urls.match(&quot;/missing&quot;) 
        Traceback (most recent call last): 
          ... 
        NotFound: 404 Not Found 
 
        :param path_info: the path info to use for matching.  Overrides the 
                          path info specified on binding. 
        :param method: the HTTP method used for matching.  Overrides the 
                       method specified on binding. 
        :param return_rule: return the rule that matched instead of just the 
                            endpoint (defaults to `False`). 
        :param query_args: optional query arguments that are used for 
                           automatic redirects as string or dictionary.  It's 
                           currently not possible to use the query arguments 
                           for URL matching. 
        :param websocket: Match WebSocket instead of HTTP requests. A 
            websocket request has a ``ws`` or ``wss`` 
            :attr:`url_scheme`. This overrides that detection. 
 
        .. versionadded:: 1.0 
            Added ``websocket``. 
 
        .. versionchanged:: 0.8 
            ``query_args`` can be a string. 
 
        .. versionadded:: 0.7 
            Added ``query_args``. 
 
        .. versionadded:: 0.6 
            Added ``return_rule``. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.map.update()</span>
        <span class="s2">if </span><span class="s1">path_info </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">path_info = self.path_info</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">path_info = _to_str(path_info</span><span class="s2">, </span><span class="s1">self.map.charset)</span>
        <span class="s2">if </span><span class="s1">query_args </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">query_args = self.query_args </span><span class="s2">or </span><span class="s1">{}</span>
        <span class="s1">method = (method </span><span class="s2">or </span><span class="s1">self.default_method).upper()</span>

        <span class="s2">if </span><span class="s1">websocket </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">websocket = self.websocket</span>

        <span class="s1">require_redirect = </span><span class="s2">False</span>

        <span class="s1">domain_part = self.server_name </span><span class="s2">if </span><span class="s1">self.map.host_matching </span><span class="s2">else </span><span class="s1">self.subdomain</span>
        <span class="s1">path_part = </span><span class="s3">f&quot;/</span><span class="s2">{</span><span class="s1">path_info.lstrip(</span><span class="s3">'/'</span><span class="s1">)</span><span class="s2">}</span><span class="s3">&quot; </span><span class="s2">if </span><span class="s1">path_info </span><span class="s2">else </span><span class="s3">&quot;&quot;</span>
        <span class="s1">path = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">domain_part</span><span class="s2">}</span><span class="s3">|</span><span class="s2">{</span><span class="s1">path_part</span><span class="s2">}</span><span class="s3">&quot;</span>

        <span class="s1">have_match_for = set()</span>
        <span class="s1">websocket_mismatch = </span><span class="s2">False</span>

        <span class="s2">for </span><span class="s1">rule </span><span class="s2">in </span><span class="s1">self.map._rules:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">rv = rule.match(path</span><span class="s2">, </span><span class="s1">method)</span>
            <span class="s2">except </span><span class="s1">RequestPath </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s2">raise </span><span class="s1">RequestRedirect(</span>
                    <span class="s1">self.make_redirect_url(</span>
                        <span class="s1">url_quote(e.path_info</span><span class="s2">, </span><span class="s1">self.map.charset</span><span class="s2">, </span><span class="s1">safe=</span><span class="s3">&quot;/:|+&quot;</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">query_args</span><span class="s2">,</span>
                    <span class="s1">)</span>
                <span class="s1">) </span><span class="s2">from None</span>
            <span class="s2">except </span><span class="s1">RequestAliasRedirect </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s2">raise </span><span class="s1">RequestRedirect(</span>
                    <span class="s1">self.make_alias_redirect_url(</span>
                        <span class="s1">path</span><span class="s2">, </span><span class="s1">rule.endpoint</span><span class="s2">, </span><span class="s1">e.matched_values</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">query_args</span>
                    <span class="s1">)</span>
                <span class="s1">) </span><span class="s2">from None</span>
            <span class="s2">if </span><span class="s1">rv </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">rule.methods </span><span class="s2">is not None and </span><span class="s1">method </span><span class="s2">not in </span><span class="s1">rule.methods:</span>
                <span class="s1">have_match_for.update(rule.methods)</span>
                <span class="s2">continue</span>

            <span class="s2">if </span><span class="s1">rule.websocket != websocket:</span>
                <span class="s1">websocket_mismatch = </span><span class="s2">True</span>
                <span class="s2">continue</span>

            <span class="s2">if </span><span class="s1">self.map.redirect_defaults:</span>
                <span class="s1">redirect_url = self.get_default_redirect(rule</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">rv</span><span class="s2">, </span><span class="s1">query_args)</span>
                <span class="s2">if </span><span class="s1">redirect_url </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">RequestRedirect(redirect_url)</span>

            <span class="s2">if </span><span class="s1">rule.redirect_to </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">isinstance(rule.redirect_to</span><span class="s2">, </span><span class="s1">str):</span>

                    <span class="s2">def </span><span class="s1">_handle_match(match: t.Match[str]) -&gt; str:</span>
                        <span class="s1">value = rv[match.group(</span><span class="s5">1</span><span class="s1">)]  </span><span class="s4"># type: ignore</span>
                        <span class="s2">return </span><span class="s1">rule._converters[match.group(</span><span class="s5">1</span><span class="s1">)].to_url(value)</span>

                    <span class="s1">redirect_url = _simple_rule_re.sub(_handle_match</span><span class="s2">, </span><span class="s1">rule.redirect_to)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">redirect_url = rule.redirect_to(self</span><span class="s2">, </span><span class="s1">**rv)</span>

                <span class="s2">if </span><span class="s1">self.subdomain:</span>
                    <span class="s1">netloc = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self.subdomain</span><span class="s2">}</span><span class="s3">.</span><span class="s2">{</span><span class="s1">self.server_name</span><span class="s2">}</span><span class="s3">&quot;</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">netloc = self.server_name</span>

                <span class="s2">raise </span><span class="s1">RequestRedirect(</span>
                    <span class="s1">url_join(</span>
                        <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self.url_scheme </span><span class="s2">or </span><span class="s3">'http'</span><span class="s2">}</span><span class="s3">://</span><span class="s2">{</span><span class="s1">netloc</span><span class="s2">}{</span><span class="s1">self.script_name</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">,</span>
                        <span class="s1">redirect_url</span><span class="s2">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

            <span class="s2">if </span><span class="s1">require_redirect:</span>
                <span class="s2">raise </span><span class="s1">RequestRedirect(</span>
                    <span class="s1">self.make_redirect_url(</span>
                        <span class="s1">url_quote(path_info</span><span class="s2">, </span><span class="s1">self.map.charset</span><span class="s2">, </span><span class="s1">safe=</span><span class="s3">&quot;/:|+&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">query_args</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

            <span class="s2">if </span><span class="s1">return_rule:</span>
                <span class="s2">return </span><span class="s1">rule</span><span class="s2">, </span><span class="s1">rv</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">rule.endpoint</span><span class="s2">, </span><span class="s1">rv</span>

        <span class="s2">if </span><span class="s1">have_match_for:</span>
            <span class="s2">raise </span><span class="s1">MethodNotAllowed(valid_methods=list(have_match_for))</span>

        <span class="s2">if </span><span class="s1">websocket_mismatch:</span>
            <span class="s2">raise </span><span class="s1">WebsocketMismatch()</span>

        <span class="s2">raise </span><span class="s1">NotFound()</span>

    <span class="s2">def </span><span class="s1">test(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">path_info: t.Optional[str] = </span><span class="s2">None, </span><span class="s1">method: t.Optional[str] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Test if a rule would match.  Works like `match` but returns `True` 
        if the URL matches, or `False` if it does not exist. 
 
        :param path_info: the path info to use for matching.  Overrides the 
                          path info specified on binding. 
        :param method: the HTTP method used for matching.  Overrides the 
                       method specified on binding. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.match(path_info</span><span class="s2">, </span><span class="s1">method)</span>
        <span class="s2">except </span><span class="s1">RequestRedirect:</span>
            <span class="s2">pass</span>
        <span class="s2">except </span><span class="s1">HTTPException:</span>
            <span class="s2">return False</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">allowed_methods(self</span><span class="s2">, </span><span class="s1">path_info: t.Optional[str] = </span><span class="s2">None</span><span class="s1">) -&gt; t.Iterable[str]:</span>
        <span class="s0">&quot;&quot;&quot;Returns the valid methods that match for a given path. 
 
        .. versionadded:: 0.7 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.match(path_info</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">&quot;--&quot;</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">MethodNotAllowed </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">return </span><span class="s1">e.valid_methods  </span><span class="s4"># type: ignore</span>
        <span class="s2">except </span><span class="s1">HTTPException:</span>
            <span class="s2">pass</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">get_host(self</span><span class="s2">, </span><span class="s1">domain_part: t.Optional[str]) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Figures out the full host name for the given domain part.  The 
        domain part is a subdomain in case host matching is disabled or 
        a full host name. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.map.host_matching:</span>
            <span class="s2">if </span><span class="s1">domain_part </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.server_name</span>
            <span class="s2">return </span><span class="s1">_to_str(domain_part</span><span class="s2">, </span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span>
        <span class="s1">subdomain = domain_part</span>
        <span class="s2">if </span><span class="s1">subdomain </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">subdomain = self.subdomain</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">subdomain = _to_str(subdomain</span><span class="s2">, </span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">subdomain:</span>
            <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">subdomain</span><span class="s2">}</span><span class="s3">.</span><span class="s2">{</span><span class="s1">self.server_name</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.server_name</span>

    <span class="s2">def </span><span class="s1">get_default_redirect(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">rule: Rule</span><span class="s2">,</span>
        <span class="s1">method: str</span><span class="s2">,</span>
        <span class="s1">values: t.MutableMapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">,</span>
        <span class="s1">query_args: t.Union[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">,</span>
    <span class="s1">) -&gt; t.Optional[str]:</span>
        <span class="s0">&quot;&quot;&quot;A helper that returns the URL to redirect to if it finds one. 
        This is used for default redirecting only. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">self.map.redirect_defaults</span>
        <span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">self.map._rules_by_endpoint[rule.endpoint]:</span>
            <span class="s4"># every rule that comes after this one, including ourself</span>
            <span class="s4"># has a lower priority for the defaults.  We order the ones</span>
            <span class="s4"># with the highest priority up for building.</span>
            <span class="s2">if </span><span class="s1">r </span><span class="s2">is </span><span class="s1">rule:</span>
                <span class="s2">break</span>
            <span class="s2">if </span><span class="s1">r.provides_defaults_for(rule) </span><span class="s2">and </span><span class="s1">r.suitable_for(values</span><span class="s2">, </span><span class="s1">method):</span>
                <span class="s1">values.update(r.defaults)  </span><span class="s4"># type: ignore</span>
                <span class="s1">domain_part</span><span class="s2">, </span><span class="s1">path = r.build(values)  </span><span class="s4"># type: ignore</span>
                <span class="s2">return </span><span class="s1">self.make_redirect_url(path</span><span class="s2">, </span><span class="s1">query_args</span><span class="s2">, </span><span class="s1">domain_part=domain_part)</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">encode_query_args(self</span><span class="s2">, </span><span class="s1">query_args: t.Union[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">, </span><span class="s1">str]) -&gt; str:</span>
        <span class="s2">if not </span><span class="s1">isinstance(query_args</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">return </span><span class="s1">url_encode(query_args</span><span class="s2">, </span><span class="s1">self.map.charset)</span>
        <span class="s2">return </span><span class="s1">query_args</span>

    <span class="s2">def </span><span class="s1">make_redirect_url(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">path_info: str</span><span class="s2">,</span>
        <span class="s1">query_args: t.Optional[t.Union[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s2">None,</span>
        <span class="s1">domain_part: t.Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Creates a redirect URL. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">query_args:</span>
            <span class="s1">suffix = </span><span class="s3">f&quot;?</span><span class="s2">{</span><span class="s1">self.encode_query_args(query_args)</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">suffix = </span><span class="s3">&quot;&quot;</span>

        <span class="s1">scheme = self.url_scheme </span><span class="s2">or </span><span class="s3">&quot;http&quot;</span>
        <span class="s1">host = self.get_host(domain_part)</span>
        <span class="s1">path = posixpath.join(self.script_name.strip(</span><span class="s3">&quot;/&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">path_info.lstrip(</span><span class="s3">&quot;/&quot;</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">scheme</span><span class="s2">}</span><span class="s3">://</span><span class="s2">{</span><span class="s1">host</span><span class="s2">}</span><span class="s3">/</span><span class="s2">{</span><span class="s1">path</span><span class="s2">}{</span><span class="s1">suffix</span><span class="s2">}</span><span class="s3">&quot;</span>

    <span class="s2">def </span><span class="s1">make_alias_redirect_url(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">path: str</span><span class="s2">,</span>
        <span class="s1">endpoint: str</span><span class="s2">,</span>
        <span class="s1">values: t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">,</span>
        <span class="s1">method: str</span><span class="s2">,</span>
        <span class="s1">query_args: t.Union[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Internally called to make an alias redirect URL.&quot;&quot;&quot;</span>
        <span class="s1">url = self.build(</span>
            <span class="s1">endpoint</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">append_unknown=</span><span class="s2">False, </span><span class="s1">force_external=</span><span class="s2">True</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">query_args:</span>
            <span class="s1">url += </span><span class="s3">f&quot;?</span><span class="s2">{</span><span class="s1">self.encode_query_args(query_args)</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s2">assert </span><span class="s1">url != path</span><span class="s2">, </span><span class="s3">&quot;detected invalid alias setting. No canonical URL found&quot;</span>
        <span class="s2">return </span><span class="s1">url</span>

    <span class="s2">def </span><span class="s1">_partial_build(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">endpoint: str</span><span class="s2">,</span>
        <span class="s1">values: t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">,</span>
        <span class="s1">method: t.Optional[str]</span><span class="s2">,</span>
        <span class="s1">append_unknown: bool</span><span class="s2">,</span>
    <span class="s1">) -&gt; t.Optional[t.Tuple[str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">bool]]:</span>
        <span class="s0">&quot;&quot;&quot;Helper for :meth:`build`.  Returns subdomain and path for the 
        rule that accepts this endpoint, values and method. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s4"># in case the method is none, try with the default method first</span>
        <span class="s2">if </span><span class="s1">method </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">rv = self._partial_build(</span>
                <span class="s1">endpoint</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">self.default_method</span><span class="s2">, </span><span class="s1">append_unknown</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">rv </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">rv</span>

        <span class="s4"># Default method did not match or a specific method is passed.</span>
        <span class="s4"># Check all for first match with matching host. If no matching</span>
        <span class="s4"># host is found, go with first result.</span>
        <span class="s1">first_match = </span><span class="s2">None</span>

        <span class="s2">for </span><span class="s1">rule </span><span class="s2">in </span><span class="s1">self.map._rules_by_endpoint.get(endpoint</span><span class="s2">, </span><span class="s1">()):</span>
            <span class="s2">if </span><span class="s1">rule.suitable_for(values</span><span class="s2">, </span><span class="s1">method):</span>
                <span class="s1">build_rv = rule.build(values</span><span class="s2">, </span><span class="s1">append_unknown)</span>

                <span class="s2">if </span><span class="s1">build_rv </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">rv = (build_rv[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">build_rv[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rule.websocket)</span>
                    <span class="s2">if </span><span class="s1">self.map.host_matching:</span>
                        <span class="s2">if </span><span class="s1">rv[</span><span class="s5">0</span><span class="s1">] == self.server_name:</span>
                            <span class="s2">return </span><span class="s1">rv</span>
                        <span class="s2">elif </span><span class="s1">first_match </span><span class="s2">is None</span><span class="s1">:</span>
                            <span class="s1">first_match = rv</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">return </span><span class="s1">rv</span>

        <span class="s2">return </span><span class="s1">first_match</span>

    <span class="s2">def </span><span class="s1">build(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">endpoint: str</span><span class="s2">,</span>
        <span class="s1">values: t.Optional[t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
        <span class="s1">method: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">force_external: bool = </span><span class="s2">False,</span>
        <span class="s1">append_unknown: bool = </span><span class="s2">True,</span>
        <span class="s1">url_scheme: t.Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Building URLs works pretty much the other way round.  Instead of 
        `match` you call `build` and pass it the endpoint and a dict of 
        arguments for the placeholders. 
 
        The `build` function also accepts an argument called `force_external` 
        which, if you set it to `True` will force external URLs. Per default 
        external URLs (include the server name) will only be used if the 
        target URL is on a different subdomain. 
 
        &gt;&gt;&gt; m = Map([ 
        ...     Rule('/', endpoint='index'), 
        ...     Rule('/downloads/', endpoint='downloads/index'), 
        ...     Rule('/downloads/&lt;int:id&gt;', endpoint='downloads/show') 
        ... ]) 
        &gt;&gt;&gt; urls = m.bind(&quot;example.com&quot;, &quot;/&quot;) 
        &gt;&gt;&gt; urls.build(&quot;index&quot;, {}) 
        '/' 
        &gt;&gt;&gt; urls.build(&quot;downloads/show&quot;, {'id': 42}) 
        '/downloads/42' 
        &gt;&gt;&gt; urls.build(&quot;downloads/show&quot;, {'id': 42}, force_external=True) 
        'http://example.com/downloads/42' 
 
        Because URLs cannot contain non ASCII data you will always get 
        bytes back.  Non ASCII characters are urlencoded with the 
        charset defined on the map instance. 
 
        Additional values are converted to strings and appended to the URL as 
        URL querystring parameters: 
 
        &gt;&gt;&gt; urls.build(&quot;index&quot;, {'q': 'My Searchstring'}) 
        '/?q=My+Searchstring' 
 
        When processing those additional values, lists are furthermore 
        interpreted as multiple values (as per 
        :py:class:`werkzeug.datastructures.MultiDict`): 
 
        &gt;&gt;&gt; urls.build(&quot;index&quot;, {'q': ['a', 'b', 'c']}) 
        '/?q=a&amp;q=b&amp;q=c' 
 
        Passing a ``MultiDict`` will also add multiple values: 
 
        &gt;&gt;&gt; urls.build(&quot;index&quot;, MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b')))) 
        '/?p=z&amp;q=a&amp;q=b' 
 
        If a rule does not exist when building a `BuildError` exception is 
        raised. 
 
        The build method accepts an argument called `method` which allows you 
        to specify the method you want to have an URL built for if you have 
        different methods for the same endpoint specified. 
 
        :param endpoint: the endpoint of the URL to build. 
        :param values: the values for the URL to build.  Unhandled values are 
                       appended to the URL as query parameters. 
        :param method: the HTTP method for the rule if there are different 
                       URLs for different methods on the same endpoint. 
        :param force_external: enforce full canonical external URLs. If the URL 
                               scheme is not provided, this will generate 
                               a protocol-relative URL. 
        :param append_unknown: unknown parameters are appended to the generated 
                               URL as query string argument.  Disable this 
                               if you want the builder to ignore those. 
        :param url_scheme: Scheme to use in place of the bound 
            :attr:`url_scheme`. 
 
        .. versionchanged:: 2.0 
            Added the ``url_scheme`` parameter. 
 
        .. versionadded:: 0.6 
           Added the ``append_unknown`` parameter. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.map.update()</span>

        <span class="s2">if </span><span class="s1">values:</span>
            <span class="s1">temp_values: t.Dict[str</span><span class="s2">, </span><span class="s1">t.Union[t.List[t.Any]</span><span class="s2">, </span><span class="s1">t.Any]] = {}</span>
            <span class="s1">always_list = isinstance(values</span><span class="s2">, </span><span class="s1">MultiDict)</span>
            <span class="s1">key: str</span>
            <span class="s1">value: t.Optional[t.Union[t.List[t.Any]</span><span class="s2">, </span><span class="s1">t.Any]]</span>

            <span class="s4"># For MultiDict, dict.items(values) is like values.lists()</span>
            <span class="s4"># without the call or list coercion overhead.</span>
            <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">dict.items(values):  </span><span class="s4"># type: ignore</span>
                <span class="s2">if </span><span class="s1">value </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">continue</span>

                <span class="s2">if </span><span class="s1">always_list </span><span class="s2">or </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
                    <span class="s1">value = [v </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">value </span><span class="s2">if </span><span class="s1">v </span><span class="s2">is not None</span><span class="s1">]</span>

                    <span class="s2">if not </span><span class="s1">value:</span>
                        <span class="s2">continue</span>

                    <span class="s2">if </span><span class="s1">len(value) == </span><span class="s5">1</span><span class="s1">:</span>
                        <span class="s1">value = value[</span><span class="s5">0</span><span class="s1">]</span>

                <span class="s1">temp_values[key] = value</span>

            <span class="s1">values = temp_values</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">values = {}</span>

        <span class="s1">rv = self._partial_build(endpoint</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">append_unknown)</span>
        <span class="s2">if </span><span class="s1">rv </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">BuildError(endpoint</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">self)</span>

        <span class="s1">domain_part</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">websocket = rv</span>
        <span class="s1">host = self.get_host(domain_part)</span>

        <span class="s2">if </span><span class="s1">url_scheme </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">url_scheme = self.url_scheme</span>

        <span class="s4"># Always build WebSocket routes with the scheme (browsers</span>
        <span class="s4"># require full URLs). If bound to a WebSocket, ensure that HTTP</span>
        <span class="s4"># routes are built with an HTTP scheme.</span>
        <span class="s1">secure = url_scheme </span><span class="s2">in </span><span class="s1">{</span><span class="s3">&quot;https&quot;</span><span class="s2">, </span><span class="s3">&quot;wss&quot;</span><span class="s1">}</span>

        <span class="s2">if </span><span class="s1">websocket:</span>
            <span class="s1">force_external = </span><span class="s2">True</span>
            <span class="s1">url_scheme = </span><span class="s3">&quot;wss&quot; </span><span class="s2">if </span><span class="s1">secure </span><span class="s2">else </span><span class="s3">&quot;ws&quot;</span>
        <span class="s2">elif </span><span class="s1">url_scheme:</span>
            <span class="s1">url_scheme = </span><span class="s3">&quot;https&quot; </span><span class="s2">if </span><span class="s1">secure </span><span class="s2">else </span><span class="s3">&quot;http&quot;</span>

        <span class="s4"># shortcut this.</span>
        <span class="s2">if not </span><span class="s1">force_external </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">(self.map.host_matching </span><span class="s2">and </span><span class="s1">host == self.server_name)</span>
            <span class="s2">or </span><span class="s1">(</span><span class="s2">not </span><span class="s1">self.map.host_matching </span><span class="s2">and </span><span class="s1">domain_part == self.subdomain)</span>
        <span class="s1">):</span>
            <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self.script_name.rstrip(</span><span class="s3">'/'</span><span class="s1">)</span><span class="s2">}</span><span class="s3">/</span><span class="s2">{</span><span class="s1">path.lstrip(</span><span class="s3">'/'</span><span class="s1">)</span><span class="s2">}</span><span class="s3">&quot;</span>

        <span class="s1">scheme = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">url_scheme</span><span class="s2">}</span><span class="s3">:&quot; </span><span class="s2">if </span><span class="s1">url_scheme </span><span class="s2">else </span><span class="s3">&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">scheme</span><span class="s2">}</span><span class="s3">//</span><span class="s2">{</span><span class="s1">host</span><span class="s2">}{</span><span class="s1">self.script_name[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">}</span><span class="s3">/</span><span class="s2">{</span><span class="s1">path.lstrip(</span><span class="s3">'/'</span><span class="s1">)</span><span class="s2">}</span><span class="s3">&quot;</span>
</pre>
</body>
</html>