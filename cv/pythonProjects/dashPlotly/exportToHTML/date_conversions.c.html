<html>
<head>
<title>date_conversions.c</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
date_conversions.c</font>
</center></td></tr></table>
<pre><span class="s0">/* 
Copyright (c) 2020, PyData Development Team 
All rights reserved. 
Distributed under the terms of the BSD Simplified License. 
The full license is in the LICENSE file, distributed with this software. 
*/</span>

<span class="s0">// Conversion routines that are useful for serialization,</span>
<span class="s0">// but which don't interact with JSON objects directly</span>

<span class="s2">#include </span><span class="s3">&quot;date_conversions.h&quot;</span>
<span class="s2">#include </span><span class="s1">&lt;../../../tslibs/src/datetime/np_datetime.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;../../../tslibs/src/datetime/np_datetime_strings.h&gt;</span>

<span class="s0">/* 
 * Function: scaleNanosecToUnit 
 * ----------------------------- 
 * 
 * Scales an integer value representing time in nanoseconds to provided unit. 
 * 
 * Mutates the provided value directly. Returns 0 on success, non-zero on error. 
 */</span>
<span class="s2">int </span><span class="s1">scaleNanosecToUnit(npy_int64 *value, NPY_DATETIMEUNIT unit) {</span>
    <span class="s2">switch </span><span class="s1">(unit) {</span>
    <span class="s2">case </span><span class="s1">NPY_FR_ns:</span>
        <span class="s2">break</span><span class="s1">;</span>
    <span class="s2">case </span><span class="s1">NPY_FR_us:</span>
        <span class="s1">*value /= </span><span class="s4">1000</span><span class="s1">LL;</span>
        <span class="s2">break</span><span class="s1">;</span>
    <span class="s2">case </span><span class="s1">NPY_FR_ms:</span>
        <span class="s1">*value /= </span><span class="s4">1000000</span><span class="s1">LL;</span>
        <span class="s2">break</span><span class="s1">;</span>
    <span class="s2">case </span><span class="s1">NPY_FR_s:</span>
        <span class="s1">*value /= </span><span class="s4">1000000000</span><span class="s1">LL;</span>
        <span class="s2">break</span><span class="s1">;</span>
    <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/* Converts the int64_t representation of a datetime to ISO; mutates len */</span>
<span class="s2">char </span><span class="s1">*int64ToIso(int64_t value, NPY_DATETIMEUNIT base, size_t *len) {</span>
    <span class="s1">npy_datetimestruct dts;</span>
    <span class="s2">int </span><span class="s1">ret_code;</span>

    <span class="s1">pandas_datetime_to_datetimestruct(value, NPY_FR_ns, &amp;dts);</span>

    <span class="s1">*len = (size_t)get_datetime_iso_8601_strlen(</span><span class="s4">0</span><span class="s1">, base);</span>
    <span class="s2">char </span><span class="s1">*result = PyObject_Malloc(*len);</span>

    <span class="s2">if </span><span class="s1">(result == NULL) {</span>
        <span class="s1">PyErr_NoMemory();</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>

    <span class="s1">ret_code = make_iso_8601_datetime(&amp;dts, result, *len, base);</span>
    <span class="s2">if </span><span class="s1">(ret_code != </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">PyErr_SetString(PyExc_ValueError,</span>
                        <span class="s3">&quot;Could not convert datetime value to string&quot;</span><span class="s1">);</span>
        <span class="s1">PyObject_Free(result);</span>
    <span class="s1">}</span>

    <span class="s0">// Note that get_datetime_iso_8601_strlen just gives a generic size</span>
    <span class="s0">// for ISO string conversion, not the actual size used</span>
    <span class="s1">*len = strlen(result);</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s1">npy_datetime NpyDateTimeToEpoch(npy_datetime dt, NPY_DATETIMEUNIT base) {</span>
    <span class="s1">scaleNanosecToUnit(&amp;dt, base);</span>
    <span class="s2">return </span><span class="s1">dt;</span>
<span class="s1">}</span>

<span class="s0">/* Convert PyDatetime To ISO C-string. mutates len */</span>
<span class="s2">char </span><span class="s1">*PyDateTimeToIso(PyObject *obj, NPY_DATETIMEUNIT base,</span>
                      <span class="s1">size_t *len) {</span>
    <span class="s1">npy_datetimestruct dts;</span>
    <span class="s2">int </span><span class="s1">ret;</span>

    <span class="s1">ret = convert_pydatetime_to_datetimestruct(obj, &amp;dts);</span>
    <span class="s2">if </span><span class="s1">(ret != </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(!PyErr_Occurred()) {</span>
            <span class="s1">PyErr_SetString(PyExc_ValueError,</span>
                            <span class="s3">&quot;Could not convert PyDateTime to numpy datetime&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>

    <span class="s1">*len = (size_t)get_datetime_iso_8601_strlen(</span><span class="s4">0</span><span class="s1">, base);</span>
    <span class="s2">char </span><span class="s1">*result = PyObject_Malloc(*len);</span>
    <span class="s1">ret = make_iso_8601_datetime(&amp;dts, result, *len, base);</span>

    <span class="s2">if </span><span class="s1">(ret != </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">PyErr_SetString(PyExc_ValueError,</span>
                        <span class="s3">&quot;Could not convert datetime value to string&quot;</span><span class="s1">);</span>
        <span class="s1">PyObject_Free(result);</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>

    <span class="s0">// Note that get_datetime_iso_8601_strlen just gives a generic size</span>
    <span class="s0">// for ISO string conversion, not the actual size used</span>
    <span class="s1">*len = strlen(result);</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s1">npy_datetime PyDateTimeToEpoch(PyObject *dt, NPY_DATETIMEUNIT base) {</span>
    <span class="s1">npy_datetimestruct dts;</span>
    <span class="s2">int </span><span class="s1">ret;</span>

    <span class="s1">ret = convert_pydatetime_to_datetimestruct(dt, &amp;dts);</span>
    <span class="s2">if </span><span class="s1">(ret != </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(!PyErr_Occurred()) {</span>
            <span class="s1">PyErr_SetString(PyExc_ValueError,</span>
                            <span class="s3">&quot;Could not convert PyDateTime to numpy datetime&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">// TODO(username): is setting errMsg required?</span>
        <span class="s0">// ((JSONObjectEncoder *)tc-&gt;encoder)-&gt;errorMsg = &quot;&quot;;</span>
        <span class="s0">// return NULL;</span>
    <span class="s1">}</span>

    <span class="s1">npy_datetime npy_dt = npy_datetimestruct_to_datetime(NPY_FR_ns, &amp;dts);</span>
    <span class="s2">return </span><span class="s1">NpyDateTimeToEpoch(npy_dt, base);</span>
<span class="s1">}</span>

<span class="s0">/* Converts the int64_t representation of a duration to ISO; mutates len */</span>
<span class="s2">char </span><span class="s1">*int64ToIsoDuration(int64_t value, size_t *len) {</span>
    <span class="s1">pandas_timedeltastruct tds;</span>
    <span class="s2">int </span><span class="s1">ret_code;</span>

    <span class="s1">pandas_timedelta_to_timedeltastruct(value, NPY_FR_ns, &amp;tds);</span>

    <span class="s0">// Max theoretical length of ISO Duration with 64 bit day</span>
    <span class="s0">// as the largest unit is 70 characters + 1 for a null terminator</span>
    <span class="s2">char </span><span class="s1">*result = PyObject_Malloc(</span><span class="s4">71</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(result == NULL) {</span>
        <span class="s1">PyErr_NoMemory();</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>

    <span class="s1">ret_code = make_iso_8601_timedelta(&amp;tds, result, len);</span>
    <span class="s2">if </span><span class="s1">(ret_code == -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">PyErr_SetString(PyExc_ValueError,</span>
                        <span class="s3">&quot;Could not convert timedelta value to string&quot;</span><span class="s1">);</span>
        <span class="s1">PyObject_Free(result);</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>
</pre>
</body>
</html>