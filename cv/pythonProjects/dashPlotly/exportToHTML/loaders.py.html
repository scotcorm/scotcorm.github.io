<html>
<head>
<title>loaders.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
loaders.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;API and implementations for loading templates from different data 
sources. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">importlib.util</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">typing </span><span class="s2">as </span><span class="s1">t</span>
<span class="s2">import </span><span class="s1">weakref</span>
<span class="s2">import </span><span class="s1">zipimport</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">abc</span>
<span class="s2">from </span><span class="s1">hashlib </span><span class="s2">import </span><span class="s1">sha1</span>
<span class="s2">from </span><span class="s1">importlib </span><span class="s2">import </span><span class="s1">import_module</span>
<span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">ModuleType</span>

<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">TemplateNotFound</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">internalcode</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">open_if_exists</span>

<span class="s2">if </span><span class="s1">t.TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">.environment </span><span class="s2">import </span><span class="s1">Environment</span>
    <span class="s2">from </span><span class="s1">.environment </span><span class="s2">import </span><span class="s1">Template</span>


<span class="s2">def </span><span class="s1">split_template_path(template: str) -&gt; t.List[str]:</span>
    <span class="s0">&quot;&quot;&quot;Split a path into segments and perform a sanity check.  If it detects 
    '..' in the path it will raise a `TemplateNotFound` error. 
    &quot;&quot;&quot;</span>
    <span class="s1">pieces = []</span>
    <span class="s2">for </span><span class="s1">piece </span><span class="s2">in </span><span class="s1">template.split(</span><span class="s3">&quot;/&quot;</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">os.path.sep </span><span class="s2">in </span><span class="s1">piece</span>
            <span class="s2">or </span><span class="s1">(os.path.altsep </span><span class="s2">and </span><span class="s1">os.path.altsep </span><span class="s2">in </span><span class="s1">piece)</span>
            <span class="s2">or </span><span class="s1">piece == os.path.pardir</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TemplateNotFound(template)</span>
        <span class="s2">elif </span><span class="s1">piece </span><span class="s2">and </span><span class="s1">piece != </span><span class="s3">&quot;.&quot;</span><span class="s1">:</span>
            <span class="s1">pieces.append(piece)</span>
    <span class="s2">return </span><span class="s1">pieces</span>


<span class="s2">class </span><span class="s1">BaseLoader:</span>
    <span class="s0">&quot;&quot;&quot;Baseclass for all loaders.  Subclass this and override `get_source` to 
    implement a custom loading mechanism.  The environment provides a 
    `get_template` method that calls the loader's `load` method to get the 
    :class:`Template` object. 
 
    A very basic example for a loader that looks up templates on the file 
    system could look like this:: 
 
        from jinja2 import BaseLoader, TemplateNotFound 
        from os.path import join, exists, getmtime 
 
        class MyLoader(BaseLoader): 
 
            def __init__(self, path): 
                self.path = path 
 
            def get_source(self, environment, template): 
                path = join(self.path, template) 
                if not exists(path): 
                    raise TemplateNotFound(template) 
                mtime = getmtime(path) 
                with open(path) as f: 
                    source = f.read() 
                return source, path, lambda: mtime == getmtime(path) 
    &quot;&quot;&quot;</span>

    <span class="s4">#: if set to `False` it indicates that the loader cannot provide access</span>
    <span class="s4">#: to the source of templates.</span>
    <span class="s4">#:</span>
    <span class="s4">#: .. versionadded:: 2.4</span>
    <span class="s1">has_source_access = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_source(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">environment: </span><span class="s3">&quot;Environment&quot;</span><span class="s2">, </span><span class="s1">template: str</span>
    <span class="s1">) -&gt; t.Tuple[str</span><span class="s2">, </span><span class="s1">t.Optional[str]</span><span class="s2">, </span><span class="s1">t.Optional[t.Callable[[]</span><span class="s2">, </span><span class="s1">bool]]]:</span>
        <span class="s0">&quot;&quot;&quot;Get the template source, filename and reload helper for a template. 
        It's passed the environment and template name and has to return a 
        tuple in the form ``(source, filename, uptodate)`` or raise a 
        `TemplateNotFound` error if it can't locate the template. 
 
        The source part of the returned tuple must be the source of the 
        template as a string. The filename should be the name of the 
        file on the filesystem if it was loaded from there, otherwise 
        ``None``. The filename is used by Python for the tracebacks 
        if no loader extension is used. 
 
        The last item in the tuple is the `uptodate` function.  If auto 
        reloading is enabled it's always called to check if the template 
        changed.  No arguments are passed so the function must store the 
        old state somewhere (for example in a closure).  If it returns `False` 
        the template will be reloaded. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self.has_source_access:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">} </span><span class="s3">cannot provide access to the source&quot;</span>
            <span class="s1">)</span>
        <span class="s2">raise </span><span class="s1">TemplateNotFound(template)</span>

    <span class="s2">def </span><span class="s1">list_templates(self) -&gt; t.List[str]:</span>
        <span class="s0">&quot;&quot;&quot;Iterates over all templates.  If the loader does not support that 
        it should raise a :exc:`TypeError` which is the default behavior. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;this loader cannot iterate over all templates&quot;</span><span class="s1">)</span>

    <span class="s1">@internalcode</span>
    <span class="s2">def </span><span class="s1">load(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">environment: </span><span class="s3">&quot;Environment&quot;</span><span class="s2">,</span>
        <span class="s1">name: str</span><span class="s2">,</span>
        <span class="s1">globals: t.Optional[t.MutableMapping[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Template&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Loads a template.  This method looks up the template in the cache 
        or loads one by calling :meth:`get_source`.  Subclasses should not 
        override this method as loaders working on collections of other 
        loaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`) 
        will not call this method but `get_source` directly. 
        &quot;&quot;&quot;</span>
        <span class="s1">code = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">globals </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">globals = {}</span>

        <span class="s4"># first we try to get the source for this template together</span>
        <span class="s4"># with the filename and the uptodate function.</span>
        <span class="s1">source</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">uptodate = self.get_source(environment</span><span class="s2">, </span><span class="s1">name)</span>

        <span class="s4"># try to load the code from the bytecode cache if there is a</span>
        <span class="s4"># bytecode cache configured.</span>
        <span class="s1">bcc = environment.bytecode_cache</span>
        <span class="s2">if </span><span class="s1">bcc </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">bucket = bcc.get_bucket(environment</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">source)</span>
            <span class="s1">code = bucket.code</span>

        <span class="s4"># if we don't have code so far (not cached, no longer up to</span>
        <span class="s4"># date) etc. we compile the template</span>
        <span class="s2">if </span><span class="s1">code </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">code = environment.compile(source</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">filename)</span>

        <span class="s4"># if the bytecode cache is available and the bucket doesn't</span>
        <span class="s4"># have a code so far, we give the bucket the new code and put</span>
        <span class="s4"># it back to the bytecode cache.</span>
        <span class="s2">if </span><span class="s1">bcc </span><span class="s2">is not None and </span><span class="s1">bucket.code </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">bucket.code = code</span>
            <span class="s1">bcc.set_bucket(bucket)</span>

        <span class="s2">return </span><span class="s1">environment.template_class.from_code(</span>
            <span class="s1">environment</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">globals</span><span class="s2">, </span><span class="s1">uptodate</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">FileSystemLoader(BaseLoader):</span>
    <span class="s0">&quot;&quot;&quot;Load templates from a directory in the file system. 
 
    The path can be relative or absolute. Relative paths are relative to 
    the current working directory. 
 
    .. code-block:: python 
 
        loader = FileSystemLoader(&quot;templates&quot;) 
 
    A list of paths can be given. The directories will be searched in 
    order, stopping at the first matching template. 
 
    .. code-block:: python 
 
        loader = FileSystemLoader([&quot;/override/templates&quot;, &quot;/default/templates&quot;]) 
 
    :param searchpath: A path, or list of paths, to the directory that 
        contains the templates. 
    :param encoding: Use this encoding to read the text from template 
        files. 
    :param followlinks: Follow symbolic links in the path. 
 
    .. versionchanged:: 2.8 
        Added the ``followlinks`` parameter. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">searchpath: t.Union[str</span><span class="s2">, </span><span class="s1">os.PathLike</span><span class="s2">, </span><span class="s1">t.Sequence[t.Union[str</span><span class="s2">, </span><span class="s1">os.PathLike]]]</span><span class="s2">,</span>
        <span class="s1">encoding: str = </span><span class="s3">&quot;utf-8&quot;</span><span class="s2">,</span>
        <span class="s1">followlinks: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">isinstance(searchpath</span><span class="s2">, </span><span class="s1">abc.Iterable) </span><span class="s2">or </span><span class="s1">isinstance(searchpath</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">searchpath = [searchpath]</span>

        <span class="s1">self.searchpath = [os.fspath(p) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">searchpath]</span>
        <span class="s1">self.encoding = encoding</span>
        <span class="s1">self.followlinks = followlinks</span>

    <span class="s2">def </span><span class="s1">get_source(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">environment: </span><span class="s3">&quot;Environment&quot;</span><span class="s2">, </span><span class="s1">template: str</span>
    <span class="s1">) -&gt; t.Tuple[str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">t.Callable[[]</span><span class="s2">, </span><span class="s1">bool]]:</span>
        <span class="s1">pieces = split_template_path(template)</span>
        <span class="s2">for </span><span class="s1">searchpath </span><span class="s2">in </span><span class="s1">self.searchpath:</span>
            <span class="s1">filename = os.path.join(searchpath</span><span class="s2">, </span><span class="s1">*pieces)</span>
            <span class="s1">f = open_if_exists(filename)</span>
            <span class="s2">if </span><span class="s1">f </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">contents = f.read().decode(self.encoding)</span>
            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s1">f.close()</span>

            <span class="s1">mtime = os.path.getmtime(filename)</span>

            <span class="s2">def </span><span class="s1">uptodate() -&gt; bool:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">os.path.getmtime(filename) == mtime</span>
                <span class="s2">except </span><span class="s1">OSError:</span>
                    <span class="s2">return False</span>

            <span class="s2">return </span><span class="s1">contents</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">uptodate</span>
        <span class="s2">raise </span><span class="s1">TemplateNotFound(template)</span>

    <span class="s2">def </span><span class="s1">list_templates(self) -&gt; t.List[str]:</span>
        <span class="s1">found = set()</span>
        <span class="s2">for </span><span class="s1">searchpath </span><span class="s2">in </span><span class="s1">self.searchpath:</span>
            <span class="s1">walk_dir = os.walk(searchpath</span><span class="s2">, </span><span class="s1">followlinks=self.followlinks)</span>
            <span class="s2">for </span><span class="s1">dirpath</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">filenames </span><span class="s2">in </span><span class="s1">walk_dir:</span>
                <span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">filenames:</span>
                    <span class="s1">template = (</span>
                        <span class="s1">os.path.join(dirpath</span><span class="s2">, </span><span class="s1">filename)[len(searchpath) :]</span>
                        <span class="s1">.strip(os.path.sep)</span>
                        <span class="s1">.replace(os.path.sep</span><span class="s2">, </span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>
                    <span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">template[:</span><span class="s5">2</span><span class="s1">] == </span><span class="s3">&quot;./&quot;</span><span class="s1">:</span>
                        <span class="s1">template = template[</span><span class="s5">2</span><span class="s1">:]</span>
                    <span class="s2">if </span><span class="s1">template </span><span class="s2">not in </span><span class="s1">found:</span>
                        <span class="s1">found.add(template)</span>
        <span class="s2">return </span><span class="s1">sorted(found)</span>


<span class="s2">class </span><span class="s1">PackageLoader(BaseLoader):</span>
    <span class="s0">&quot;&quot;&quot;Load templates from a directory in a Python package. 
 
    :param package_name: Import name of the package that contains the 
        template directory. 
    :param package_path: Directory within the imported package that 
        contains the templates. 
    :param encoding: Encoding of template files. 
 
    The following example looks up templates in the ``pages`` directory 
    within the ``project.ui`` package. 
 
    .. code-block:: python 
 
        loader = PackageLoader(&quot;project.ui&quot;, &quot;pages&quot;) 
 
    Only packages installed as directories (standard pip behavior) or 
    zip/egg files (less common) are supported. The Python API for 
    introspecting data in packages is too limited to support other 
    installation methods the way this loader requires. 
 
    There is limited support for :pep:`420` namespace packages. The 
    template directory is assumed to only be in one namespace 
    contributor. Zip files contributing to a namespace are not 
    supported. 
 
    .. versionchanged:: 3.0 
        No longer uses ``setuptools`` as a dependency. 
 
    .. versionchanged:: 3.0 
        Limited PEP 420 namespace package support. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">package_name: str</span><span class="s2">,</span>
        <span class="s1">package_path: </span><span class="s3">&quot;str&quot; </span><span class="s1">= </span><span class="s3">&quot;templates&quot;</span><span class="s2">,</span>
        <span class="s1">encoding: str = </span><span class="s3">&quot;utf-8&quot;</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">package_path = os.path.normpath(package_path).rstrip(os.path.sep)</span>

        <span class="s4"># normpath preserves &quot;.&quot;, which isn't valid in zip paths.</span>
        <span class="s2">if </span><span class="s1">package_path == os.path.curdir:</span>
            <span class="s1">package_path = </span><span class="s3">&quot;&quot;</span>
        <span class="s2">elif </span><span class="s1">package_path[:</span><span class="s5">2</span><span class="s1">] == os.path.curdir + os.path.sep:</span>
            <span class="s1">package_path = package_path[</span><span class="s5">2</span><span class="s1">:]</span>

        <span class="s1">self.package_path = package_path</span>
        <span class="s1">self.package_name = package_name</span>
        <span class="s1">self.encoding = encoding</span>

        <span class="s4"># Make sure the package exists. This also makes namespace</span>
        <span class="s4"># packages work, otherwise get_loader returns None.</span>
        <span class="s1">import_module(package_name)</span>
        <span class="s1">spec = importlib.util.find_spec(package_name)</span>
        <span class="s2">assert </span><span class="s1">spec </span><span class="s2">is not None, </span><span class="s3">&quot;An import spec was not found for the package.&quot;</span>
        <span class="s1">loader = spec.loader</span>
        <span class="s2">assert </span><span class="s1">loader </span><span class="s2">is not None, </span><span class="s3">&quot;A loader was not found for the package.&quot;</span>
        <span class="s1">self._loader = loader</span>
        <span class="s1">self._archive = </span><span class="s2">None</span>
        <span class="s1">template_root = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">isinstance(loader</span><span class="s2">, </span><span class="s1">zipimport.zipimporter):</span>
            <span class="s1">self._archive = loader.archive</span>
            <span class="s1">pkgdir = next(iter(spec.submodule_search_locations))  </span><span class="s4"># type: ignore</span>
            <span class="s1">template_root = os.path.join(pkgdir</span><span class="s2">, </span><span class="s1">package_path)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">roots: t.List[str] = []</span>

            <span class="s4"># One element for regular packages, multiple for namespace</span>
            <span class="s4"># packages, or None for single module file.</span>
            <span class="s2">if </span><span class="s1">spec.submodule_search_locations:</span>
                <span class="s1">roots.extend(spec.submodule_search_locations)</span>
            <span class="s4"># A single module file, use the parent directory instead.</span>
            <span class="s2">elif </span><span class="s1">spec.origin </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">roots.append(os.path.dirname(spec.origin))</span>

            <span class="s2">for </span><span class="s1">root </span><span class="s2">in </span><span class="s1">roots:</span>
                <span class="s1">root = os.path.join(root</span><span class="s2">, </span><span class="s1">package_path)</span>

                <span class="s2">if </span><span class="s1">os.path.isdir(root):</span>
                    <span class="s1">template_root = root</span>
                    <span class="s2">break</span>

        <span class="s2">if </span><span class="s1">template_root </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">f&quot;The </span><span class="s2">{</span><span class="s1">package_name</span><span class="s2">!r} </span><span class="s3">package was not installed in a&quot;</span>
                <span class="s3">&quot; way that PackageLoader understands.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self._template_root = template_root</span>

    <span class="s2">def </span><span class="s1">get_source(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">environment: </span><span class="s3">&quot;Environment&quot;</span><span class="s2">, </span><span class="s1">template: str</span>
    <span class="s1">) -&gt; t.Tuple[str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">t.Optional[t.Callable[[]</span><span class="s2">, </span><span class="s1">bool]]]:</span>
        <span class="s1">p = os.path.join(self._template_root</span><span class="s2">, </span><span class="s1">*split_template_path(template))</span>
        <span class="s1">up_to_date: t.Optional[t.Callable[[]</span><span class="s2">, </span><span class="s1">bool]]</span>

        <span class="s2">if </span><span class="s1">self._archive </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s4"># Package is a directory.</span>
            <span class="s2">if not </span><span class="s1">os.path.isfile(p):</span>
                <span class="s2">raise </span><span class="s1">TemplateNotFound(template)</span>

            <span class="s2">with </span><span class="s1">open(p</span><span class="s2">, </span><span class="s3">&quot;rb&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
                <span class="s1">source = f.read()</span>

            <span class="s1">mtime = os.path.getmtime(p)</span>

            <span class="s2">def </span><span class="s1">up_to_date() -&gt; bool:</span>
                <span class="s2">return </span><span class="s1">os.path.isfile(p) </span><span class="s2">and </span><span class="s1">os.path.getmtime(p) == mtime</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># Package is a zip file.</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">source = self._loader.get_data(p)  </span><span class="s4"># type: ignore</span>
            <span class="s2">except </span><span class="s1">OSError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s2">raise </span><span class="s1">TemplateNotFound(template) </span><span class="s2">from </span><span class="s1">e</span>

            <span class="s4"># Could use the zip's mtime for all template mtimes, but</span>
            <span class="s4"># would need to safely reload the module if it's out of</span>
            <span class="s4"># date, so just report it as always current.</span>
            <span class="s1">up_to_date = </span><span class="s2">None</span>

        <span class="s2">return </span><span class="s1">source.decode(self.encoding)</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">up_to_date</span>

    <span class="s2">def </span><span class="s1">list_templates(self) -&gt; t.List[str]:</span>
        <span class="s1">results: t.List[str] = []</span>

        <span class="s2">if </span><span class="s1">self._archive </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s4"># Package is a directory.</span>
            <span class="s1">offset = len(self._template_root)</span>

            <span class="s2">for </span><span class="s1">dirpath</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">filenames </span><span class="s2">in </span><span class="s1">os.walk(self._template_root):</span>
                <span class="s1">dirpath = dirpath[offset:].lstrip(os.path.sep)</span>
                <span class="s1">results.extend(</span>
                    <span class="s1">os.path.join(dirpath</span><span class="s2">, </span><span class="s1">name).replace(os.path.sep</span><span class="s2">, </span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>
                    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">filenames</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">hasattr(self._loader</span><span class="s2">, </span><span class="s3">&quot;_files&quot;</span><span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">&quot;This zip import does not have the required&quot;</span>
                    <span class="s3">&quot; metadata to list templates.&quot;</span>
                <span class="s1">)</span>

            <span class="s4"># Package is a zip file.</span>
            <span class="s1">prefix = (</span>
                <span class="s1">self._template_root[len(self._archive) :].lstrip(os.path.sep)</span>
                <span class="s1">+ os.path.sep</span>
            <span class="s1">)</span>
            <span class="s1">offset = len(prefix)</span>

            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._loader._files.keys():  </span><span class="s4"># type: ignore</span>
                <span class="s4"># Find names under the templates directory that aren't directories.</span>
                <span class="s2">if </span><span class="s1">name.startswith(prefix) </span><span class="s2">and </span><span class="s1">name[-</span><span class="s5">1</span><span class="s1">] != os.path.sep:</span>
                    <span class="s1">results.append(name[offset:].replace(os.path.sep</span><span class="s2">, </span><span class="s3">&quot;/&quot;</span><span class="s1">))</span>

        <span class="s1">results.sort()</span>
        <span class="s2">return </span><span class="s1">results</span>


<span class="s2">class </span><span class="s1">DictLoader(BaseLoader):</span>
    <span class="s0">&quot;&quot;&quot;Loads a template from a Python dict mapping template names to 
    template source.  This loader is useful for unittesting: 
 
    &gt;&gt;&gt; loader = DictLoader({'index.html': 'source here'}) 
 
    Because auto reloading is rarely useful this is disabled per default. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">mapping: t.Mapping[str</span><span class="s2">, </span><span class="s1">str]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.mapping = mapping</span>

    <span class="s2">def </span><span class="s1">get_source(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">environment: </span><span class="s3">&quot;Environment&quot;</span><span class="s2">, </span><span class="s1">template: str</span>
    <span class="s1">) -&gt; t.Tuple[str</span><span class="s2">, None, </span><span class="s1">t.Callable[[]</span><span class="s2">, </span><span class="s1">bool]]:</span>
        <span class="s2">if </span><span class="s1">template </span><span class="s2">in </span><span class="s1">self.mapping:</span>
            <span class="s1">source = self.mapping[template]</span>
            <span class="s2">return </span><span class="s1">source</span><span class="s2">, None, lambda</span><span class="s1">: source == self.mapping.get(template)</span>
        <span class="s2">raise </span><span class="s1">TemplateNotFound(template)</span>

    <span class="s2">def </span><span class="s1">list_templates(self) -&gt; t.List[str]:</span>
        <span class="s2">return </span><span class="s1">sorted(self.mapping)</span>


<span class="s2">class </span><span class="s1">FunctionLoader(BaseLoader):</span>
    <span class="s0">&quot;&quot;&quot;A loader that is passed a function which does the loading.  The 
    function receives the name of the template and has to return either 
    a string with the template source, a tuple in the form ``(source, 
    filename, uptodatefunc)`` or `None` if the template does not exist. 
 
    &gt;&gt;&gt; def load_template(name): 
    ...     if name == 'index.html': 
    ...         return '...' 
    ... 
    &gt;&gt;&gt; loader = FunctionLoader(load_template) 
 
    The `uptodatefunc` is a function that is called if autoreload is enabled 
    and has to return `True` if the template is still up to date.  For more 
    details have a look at :meth:`BaseLoader.get_source` which has the same 
    return value. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">load_func: t.Callable[</span>
            <span class="s1">[str]</span><span class="s2">,</span>
            <span class="s1">t.Optional[</span>
                <span class="s1">t.Union[</span>
                    <span class="s1">str</span><span class="s2">, </span><span class="s1">t.Tuple[str</span><span class="s2">, </span><span class="s1">t.Optional[str]</span><span class="s2">, </span><span class="s1">t.Optional[t.Callable[[]</span><span class="s2">, </span><span class="s1">bool]]]</span>
                <span class="s1">]</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.load_func = load_func</span>

    <span class="s2">def </span><span class="s1">get_source(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">environment: </span><span class="s3">&quot;Environment&quot;</span><span class="s2">, </span><span class="s1">template: str</span>
    <span class="s1">) -&gt; t.Tuple[str</span><span class="s2">, </span><span class="s1">t.Optional[str]</span><span class="s2">, </span><span class="s1">t.Optional[t.Callable[[]</span><span class="s2">, </span><span class="s1">bool]]]:</span>
        <span class="s1">rv = self.load_func(template)</span>

        <span class="s2">if </span><span class="s1">rv </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TemplateNotFound(template)</span>

        <span class="s2">if </span><span class="s1">isinstance(rv</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">return </span><span class="s1">rv</span><span class="s2">, None, None</span>

        <span class="s2">return </span><span class="s1">rv</span>


<span class="s2">class </span><span class="s1">PrefixLoader(BaseLoader):</span>
    <span class="s0">&quot;&quot;&quot;A loader that is passed a dict of loaders where each loader is bound 
    to a prefix.  The prefix is delimited from the template by a slash per 
    default, which can be changed by setting the `delimiter` argument to 
    something else:: 
 
        loader = PrefixLoader({ 
            'app1':     PackageLoader('mypackage.app1'), 
            'app2':     PackageLoader('mypackage.app2') 
        }) 
 
    By loading ``'app1/index.html'`` the file from the app1 package is loaded, 
    by loading ``'app2/index.html'`` the file from the second. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">mapping: t.Mapping[str</span><span class="s2">, </span><span class="s1">BaseLoader]</span><span class="s2">, </span><span class="s1">delimiter: str = </span><span class="s3">&quot;/&quot;</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.mapping = mapping</span>
        <span class="s1">self.delimiter = delimiter</span>

    <span class="s2">def </span><span class="s1">get_loader(self</span><span class="s2">, </span><span class="s1">template: str) -&gt; t.Tuple[BaseLoader</span><span class="s2">, </span><span class="s1">str]:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">prefix</span><span class="s2">, </span><span class="s1">name = template.split(self.delimiter</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">loader = self.mapping[prefix]</span>
        <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">KeyError) </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">TemplateNotFound(template) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s2">return </span><span class="s1">loader</span><span class="s2">, </span><span class="s1">name</span>

    <span class="s2">def </span><span class="s1">get_source(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">environment: </span><span class="s3">&quot;Environment&quot;</span><span class="s2">, </span><span class="s1">template: str</span>
    <span class="s1">) -&gt; t.Tuple[str</span><span class="s2">, </span><span class="s1">t.Optional[str]</span><span class="s2">, </span><span class="s1">t.Optional[t.Callable[[]</span><span class="s2">, </span><span class="s1">bool]]]:</span>
        <span class="s1">loader</span><span class="s2">, </span><span class="s1">name = self.get_loader(template)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">loader.get_source(environment</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s2">except </span><span class="s1">TemplateNotFound </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s4"># re-raise the exception with the correct filename here.</span>
            <span class="s4"># (the one that includes the prefix)</span>
            <span class="s2">raise </span><span class="s1">TemplateNotFound(template) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s1">@internalcode</span>
    <span class="s2">def </span><span class="s1">load(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">environment: </span><span class="s3">&quot;Environment&quot;</span><span class="s2">,</span>
        <span class="s1">name: str</span><span class="s2">,</span>
        <span class="s1">globals: t.Optional[t.MutableMapping[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Template&quot;</span><span class="s1">:</span>
        <span class="s1">loader</span><span class="s2">, </span><span class="s1">local_name = self.get_loader(name)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">loader.load(environment</span><span class="s2">, </span><span class="s1">local_name</span><span class="s2">, </span><span class="s1">globals)</span>
        <span class="s2">except </span><span class="s1">TemplateNotFound </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s4"># re-raise the exception with the correct filename here.</span>
            <span class="s4"># (the one that includes the prefix)</span>
            <span class="s2">raise </span><span class="s1">TemplateNotFound(name) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s2">def </span><span class="s1">list_templates(self) -&gt; t.List[str]:</span>
        <span class="s1">result = []</span>
        <span class="s2">for </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">loader </span><span class="s2">in </span><span class="s1">self.mapping.items():</span>
            <span class="s2">for </span><span class="s1">template </span><span class="s2">in </span><span class="s1">loader.list_templates():</span>
                <span class="s1">result.append(prefix + self.delimiter + template)</span>
        <span class="s2">return </span><span class="s1">result</span>


<span class="s2">class </span><span class="s1">ChoiceLoader(BaseLoader):</span>
    <span class="s0">&quot;&quot;&quot;This loader works like the `PrefixLoader` just that no prefix is 
    specified.  If a template could not be found by one loader the next one 
    is tried. 
 
    &gt;&gt;&gt; loader = ChoiceLoader([ 
    ...     FileSystemLoader('/path/to/user/templates'), 
    ...     FileSystemLoader('/path/to/system/templates') 
    ... ]) 
 
    This is useful if you want to allow users to override builtin templates 
    from a different location. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">loaders: t.Sequence[BaseLoader]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.loaders = loaders</span>

    <span class="s2">def </span><span class="s1">get_source(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">environment: </span><span class="s3">&quot;Environment&quot;</span><span class="s2">, </span><span class="s1">template: str</span>
    <span class="s1">) -&gt; t.Tuple[str</span><span class="s2">, </span><span class="s1">t.Optional[str]</span><span class="s2">, </span><span class="s1">t.Optional[t.Callable[[]</span><span class="s2">, </span><span class="s1">bool]]]:</span>
        <span class="s2">for </span><span class="s1">loader </span><span class="s2">in </span><span class="s1">self.loaders:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">loader.get_source(environment</span><span class="s2">, </span><span class="s1">template)</span>
            <span class="s2">except </span><span class="s1">TemplateNotFound:</span>
                <span class="s2">pass</span>
        <span class="s2">raise </span><span class="s1">TemplateNotFound(template)</span>

    <span class="s1">@internalcode</span>
    <span class="s2">def </span><span class="s1">load(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">environment: </span><span class="s3">&quot;Environment&quot;</span><span class="s2">,</span>
        <span class="s1">name: str</span><span class="s2">,</span>
        <span class="s1">globals: t.Optional[t.MutableMapping[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Template&quot;</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">loader </span><span class="s2">in </span><span class="s1">self.loaders:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">loader.load(environment</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">globals)</span>
            <span class="s2">except </span><span class="s1">TemplateNotFound:</span>
                <span class="s2">pass</span>
        <span class="s2">raise </span><span class="s1">TemplateNotFound(name)</span>

    <span class="s2">def </span><span class="s1">list_templates(self) -&gt; t.List[str]:</span>
        <span class="s1">found = set()</span>
        <span class="s2">for </span><span class="s1">loader </span><span class="s2">in </span><span class="s1">self.loaders:</span>
            <span class="s1">found.update(loader.list_templates())</span>
        <span class="s2">return </span><span class="s1">sorted(found)</span>


<span class="s2">class </span><span class="s1">_TemplateModule(ModuleType):</span>
    <span class="s0">&quot;&quot;&quot;Like a normal module but with support for weak references&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">ModuleLoader(BaseLoader):</span>
    <span class="s0">&quot;&quot;&quot;This loader loads templates from precompiled templates. 
 
    Example usage: 
 
    &gt;&gt;&gt; loader = ChoiceLoader([ 
    ...     ModuleLoader('/path/to/compiled/templates'), 
    ...     FileSystemLoader('/path/to/templates') 
    ... ]) 
 
    Templates can be precompiled with :meth:`Environment.compile_templates`. 
    &quot;&quot;&quot;</span>

    <span class="s1">has_source_access = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">path: t.Union[str</span><span class="s2">, </span><span class="s1">os.PathLike</span><span class="s2">, </span><span class="s1">t.Sequence[t.Union[str</span><span class="s2">, </span><span class="s1">os.PathLike]]]</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">package_name = </span><span class="s3">f&quot;_jinja2_module_templates_</span><span class="s2">{</span><span class="s1">id(self)</span><span class="s2">:</span><span class="s3">x</span><span class="s2">}</span><span class="s3">&quot;</span>

        <span class="s4"># create a fake module that looks for the templates in the</span>
        <span class="s4"># path given.</span>
        <span class="s1">mod = _TemplateModule(package_name)</span>

        <span class="s2">if not </span><span class="s1">isinstance(path</span><span class="s2">, </span><span class="s1">abc.Iterable) </span><span class="s2">or </span><span class="s1">isinstance(path</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">path = [path]</span>

        <span class="s1">mod.__path__ = [os.fspath(p) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">path]  </span><span class="s4"># type: ignore</span>

        <span class="s1">sys.modules[package_name] = weakref.proxy(</span>
            <span class="s1">mod</span><span class="s2">, lambda </span><span class="s1">x: sys.modules.pop(package_name</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s4"># the only strong reference, the sys.modules entry is weak</span>
        <span class="s4"># so that the garbage collector can remove it once the</span>
        <span class="s4"># loader that created it goes out of business.</span>
        <span class="s1">self.module = mod</span>
        <span class="s1">self.package_name = package_name</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">get_template_key(name: str) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">&quot;tmpl_&quot; </span><span class="s1">+ sha1(name.encode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)).hexdigest()</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">get_module_filename(name: str) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">ModuleLoader.get_template_key(name) + </span><span class="s3">&quot;.py&quot;</span>

    <span class="s1">@internalcode</span>
    <span class="s2">def </span><span class="s1">load(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">environment: </span><span class="s3">&quot;Environment&quot;</span><span class="s2">,</span>
        <span class="s1">name: str</span><span class="s2">,</span>
        <span class="s1">globals: t.Optional[t.MutableMapping[str</span><span class="s2">, </span><span class="s1">t.Any]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Template&quot;</span><span class="s1">:</span>
        <span class="s1">key = self.get_template_key(name)</span>
        <span class="s1">module = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self.package_name</span><span class="s2">}</span><span class="s3">.</span><span class="s2">{</span><span class="s1">key</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s1">mod = getattr(self.module</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">mod </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">mod = __import__(module</span><span class="s2">, None, None, </span><span class="s1">[</span><span class="s3">&quot;root&quot;</span><span class="s1">])</span>
            <span class="s2">except </span><span class="s1">ImportError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s2">raise </span><span class="s1">TemplateNotFound(name) </span><span class="s2">from </span><span class="s1">e</span>

            <span class="s4"># remove the entry from sys.modules, we only want the attribute</span>
            <span class="s4"># on the module object we have stored on the loader.</span>
            <span class="s1">sys.modules.pop(module</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">globals </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">globals = {}</span>

        <span class="s2">return </span><span class="s1">environment.template_class.from_module_dict(</span>
            <span class="s1">environment</span><span class="s2">, </span><span class="s1">mod.__dict__</span><span class="s2">, </span><span class="s1">globals</span>
        <span class="s1">)</span>
</pre>
</body>
</html>