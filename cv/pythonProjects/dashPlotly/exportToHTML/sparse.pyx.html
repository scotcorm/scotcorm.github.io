<html>
<head>
<title>sparse.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sparse.pyx</font>
</center></td></tr></table>
<pre><span class="s0">import cython</span>
<span class="s0">import numpy as np</span>

<span class="s0">cimport numpy as cnp</span>
<span class="s0">from numpy cimport (</span>
    <span class="s0">float32_t,</span>
    <span class="s0">float64_t,</span>
    <span class="s0">int8_t,</span>
    <span class="s0">int16_t,</span>
    <span class="s0">int32_t,</span>
    <span class="s0">int64_t,</span>
    <span class="s0">ndarray,</span>
    <span class="s0">uint8_t,</span>
<span class="s0">)</span>

<span class="s0">cnp.import_array()</span>


<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># Preamble stuff</span>

<span class="s0">cdef float64_t NaN = &lt;float64_t&gt;np.NaN</span>
<span class="s0">cdef float64_t INF = &lt;float64_t&gt;np.inf</span>

<span class="s0"># -----------------------------------------------------------------------------</span>


<span class="s0">cdef class SparseIndex:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Abstract superclass for sparse index types.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">def __init__(self):</span>
        <span class="s0">raise NotImplementedError</span>


<span class="s0">cdef class IntIndex(SparseIndex):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Object for holding exact integer sparse indexing information</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">length : integer</span>
    <span class="s0">indices : array-like</span>
        <span class="s0">Contains integers corresponding to the indices.</span>
    <span class="s0">check_integrity : bool, default=True</span>
        <span class="s0">Check integrity of the input.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">cdef readonly:</span>
        <span class="s0">Py_ssize_t length, npoints</span>
        <span class="s0">ndarray indices</span>

    <span class="s0">def __init__(self, Py_ssize_t length, indices, bint check_integrity=True):</span>
        <span class="s0">self.length = length</span>
        <span class="s0">self.indices = np.ascontiguousarray(indices, dtype=np.int32)</span>
        <span class="s0">self.npoints = len(self.indices)</span>

        <span class="s0">if check_integrity:</span>
            <span class="s0">self.check_integrity()</span>

    <span class="s0">def __reduce__(self):</span>
        <span class="s0">args = (self.length, self.indices)</span>
        <span class="s0">return IntIndex, args</span>

    <span class="s0">def __repr__(self) -&gt; str:</span>
        <span class="s0">output = 'IntIndex\n'</span>
        <span class="s0">output += f'Indices: {repr(self.indices)}\n'</span>
        <span class="s0">return output</span>

    <span class="s0">@property</span>
    <span class="s0">def nbytes(self) -&gt; int:</span>
        <span class="s0">return self.indices.nbytes</span>

    <span class="s0">cdef check_integrity(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Checks the following:</span>

        <span class="s0">- Indices are strictly ascending</span>
        <span class="s0">- Number of indices is at most self.length</span>
        <span class="s0">- Indices are at least 0 and at most the total length less one</span>

        <span class="s0">A ValueError is raised if any of these conditions is violated.</span>
        <span class="s0">&quot;&quot;&quot;</span>

        <span class="s0">if self.npoints &gt; self.length:</span>
            <span class="s0">raise ValueError(</span>
                <span class="s0">f&quot;Too many indices. Expected {self.length} but found {self.npoints}&quot;</span>
            <span class="s0">)</span>

        <span class="s0"># Indices are vacuously ordered and non-negative</span>
        <span class="s0"># if the sequence of indices is empty.</span>
        <span class="s0">if self.npoints == 0:</span>
            <span class="s0">return</span>

        <span class="s0">if self.indices.min() &lt; 0:</span>
            <span class="s0">raise ValueError(&quot;No index can be less than zero&quot;)</span>

        <span class="s0">if self.indices.max() &gt;= self.length:</span>
            <span class="s0">raise ValueError(&quot;All indices must be less than the length&quot;)</span>

        <span class="s0">monotonic = np.all(self.indices[:-1] &lt; self.indices[1:])</span>
        <span class="s0">if not monotonic:</span>
            <span class="s0">raise ValueError(&quot;Indices must be strictly increasing&quot;)</span>

    <span class="s0">def equals(self, other: object) -&gt; bool:</span>
        <span class="s0">if not isinstance(other, IntIndex):</span>
            <span class="s0">return False</span>

        <span class="s0">if self is other:</span>
            <span class="s0">return True</span>

        <span class="s0">same_length = self.length == other.length</span>
        <span class="s0">same_indices = np.array_equal(self.indices, other.indices)</span>
        <span class="s0">return same_length and same_indices</span>

    <span class="s0">@property</span>
    <span class="s0">def ngaps(self) -&gt; int:</span>
        <span class="s0">return self.length - self.npoints</span>

    <span class="s0">cpdef to_int_index(self):</span>
        <span class="s0">return self</span>

    <span class="s0">def to_block_index(self):</span>
        <span class="s0">locs, lens = get_blocks(self.indices)</span>
        <span class="s0">return BlockIndex(self.length, locs, lens)</span>

    <span class="s0">cpdef IntIndex intersect(self, SparseIndex y_):</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t out_length, xi, yi = 0, result_indexer = 0</span>
            <span class="s0">int32_t xind</span>
            <span class="s0">ndarray[int32_t, ndim=1] xindices, yindices, new_indices</span>
            <span class="s0">IntIndex y</span>

        <span class="s0"># if is one already, returns self</span>
        <span class="s0">y = y_.to_int_index()</span>

        <span class="s0">if self.length != y.length:</span>
            <span class="s0">raise Exception('Indices must reference same underlying length')</span>

        <span class="s0">xindices = self.indices</span>
        <span class="s0">yindices = y.indices</span>
        <span class="s0">new_indices = np.empty(min(</span>
            <span class="s0">len(xindices), len(yindices)), dtype=np.int32)</span>

        <span class="s0">for xi in range(self.npoints):</span>
            <span class="s0">xind = xindices[xi]</span>

            <span class="s0">while yi &lt; y.npoints and yindices[yi] &lt; xind:</span>
                <span class="s0">yi += 1</span>

            <span class="s0">if yi &gt;= y.npoints:</span>
                <span class="s0">break</span>

            <span class="s0"># TODO: would a two-pass algorithm be faster?</span>
            <span class="s0">if yindices[yi] == xind:</span>
                <span class="s0">new_indices[result_indexer] = xind</span>
                <span class="s0">result_indexer += 1</span>

        <span class="s0">new_indices = new_indices[:result_indexer]</span>
        <span class="s0">return IntIndex(self.length, new_indices)</span>

    <span class="s0">cpdef IntIndex make_union(self, SparseIndex y_):</span>

        <span class="s0">cdef:</span>
            <span class="s0">ndarray[int32_t, ndim=1] new_indices</span>
            <span class="s0">IntIndex y</span>

        <span class="s0"># if is one already, returns self</span>
        <span class="s0">y = y_.to_int_index()</span>

        <span class="s0">if self.length != y.length:</span>
            <span class="s0">raise ValueError('Indices must reference same underlying length')</span>

        <span class="s0">new_indices = np.union1d(self.indices, y.indices)</span>
        <span class="s0">return IntIndex(self.length, new_indices)</span>

    <span class="s0">@cython.wraparound(False)</span>
    <span class="s0">cpdef int32_t lookup(self, Py_ssize_t index):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the internal location if value exists on given index.</span>
        <span class="s0">Return -1 otherwise.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">int32_t res</span>
            <span class="s0">ndarray[int32_t, ndim=1] inds</span>

        <span class="s0">inds = self.indices</span>
        <span class="s0">if self.npoints == 0:</span>
            <span class="s0">return -1</span>
        <span class="s0">elif index &lt; 0 or self.length &lt;= index:</span>
            <span class="s0">return -1</span>

        <span class="s0">res = inds.searchsorted(index)</span>
        <span class="s0">if res == self.npoints:</span>
            <span class="s0">return -1</span>
        <span class="s0">elif inds[res] == index:</span>
            <span class="s0">return res</span>
        <span class="s0">else:</span>
            <span class="s0">return -1</span>

    <span class="s0">@cython.wraparound(False)</span>
    <span class="s0">cpdef ndarray[int32_t] lookup_array(self, ndarray[int32_t, ndim=1] indexer):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Vectorized lookup, returns ndarray[int32_t]</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t n, i, ind_val</span>
            <span class="s0">ndarray[int32_t, ndim=1] inds</span>
            <span class="s0">ndarray[uint8_t, ndim=1, cast=True] mask</span>
            <span class="s0">ndarray[int32_t, ndim=1] masked</span>
            <span class="s0">ndarray[int32_t, ndim=1] res</span>
            <span class="s0">ndarray[int32_t, ndim=1] results</span>

        <span class="s0">n = len(indexer)</span>
        <span class="s0">results = np.empty(n, dtype=np.int32)</span>
        <span class="s0">results[:] = -1</span>

        <span class="s0">if self.npoints == 0:</span>
            <span class="s0">return results</span>

        <span class="s0">inds = self.indices</span>
        <span class="s0">mask = (inds[0] &lt;= indexer) &amp; (indexer &lt;= inds[len(inds) - 1])</span>

        <span class="s0">masked = indexer[mask]</span>
        <span class="s0">res = inds.searchsorted(masked).astype(np.int32)</span>

        <span class="s0">res[inds[res] != masked] = -1</span>
        <span class="s0">results[mask] = res</span>
        <span class="s0">return results</span>


<span class="s0">cpdef get_blocks(ndarray[int32_t, ndim=1] indices):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t init_len, i, npoints, result_indexer = 0</span>
        <span class="s0">int32_t block, length = 1, cur, prev</span>
        <span class="s0">ndarray[int32_t, ndim=1] locs, lens</span>

    <span class="s0">npoints = len(indices)</span>

    <span class="s0"># just handle the special empty case separately</span>
    <span class="s0">if npoints == 0:</span>
        <span class="s0">return np.array([], dtype=np.int32), np.array([], dtype=np.int32)</span>

    <span class="s0"># block size can't be longer than npoints</span>
    <span class="s0">locs = np.empty(npoints, dtype=np.int32)</span>
    <span class="s0">lens = np.empty(npoints, dtype=np.int32)</span>

    <span class="s0"># TODO: two-pass algorithm faster?</span>
    <span class="s0">prev = block = indices[0]</span>
    <span class="s0">for i in range(1, npoints):</span>
        <span class="s0">cur = indices[i]</span>
        <span class="s0">if cur - prev &gt; 1:</span>
            <span class="s0"># new block</span>
            <span class="s0">locs[result_indexer] = block</span>
            <span class="s0">lens[result_indexer] = length</span>
            <span class="s0">block = cur</span>
            <span class="s0">length = 1</span>
            <span class="s0">result_indexer += 1</span>
        <span class="s0">else:</span>
            <span class="s0"># same block, increment length</span>
            <span class="s0">length += 1</span>

        <span class="s0">prev = cur</span>

    <span class="s0">locs[result_indexer] = block</span>
    <span class="s0">lens[result_indexer] = length</span>
    <span class="s0">result_indexer += 1</span>
    <span class="s0">locs = locs[:result_indexer]</span>
    <span class="s0">lens = lens[:result_indexer]</span>
    <span class="s0">return locs, lens</span>


<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># BlockIndex</span>

<span class="s0">cdef class BlockIndex(SparseIndex):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Object for holding block-based sparse indexing information</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef readonly:</span>
        <span class="s0">int32_t nblocks, npoints, length</span>
        <span class="s0">ndarray blocs, blengths</span>

    <span class="s0">cdef:</span>
        <span class="s0">object __weakref__  # need to be picklable</span>
        <span class="s0">int32_t *locbuf</span>
        <span class="s0">int32_t *lenbuf</span>

    <span class="s0">def __init__(self, length, blocs, blengths):</span>

        <span class="s0">self.blocs = np.ascontiguousarray(blocs, dtype=np.int32)</span>
        <span class="s0">self.blengths = np.ascontiguousarray(blengths, dtype=np.int32)</span>

        <span class="s0"># in case we need</span>
        <span class="s0">self.locbuf = &lt;int32_t*&gt;self.blocs.data</span>
        <span class="s0">self.lenbuf = &lt;int32_t*&gt;self.blengths.data</span>

        <span class="s0">self.length = length</span>
        <span class="s0">self.nblocks = np.int32(len(self.blocs))</span>
        <span class="s0">self.npoints = self.blengths.sum()</span>

        <span class="s0"># self.block_start = blocs</span>
        <span class="s0"># self.block_end = blocs + blengths</span>

        <span class="s0">self.check_integrity()</span>

    <span class="s0">def __reduce__(self):</span>
        <span class="s0">args = (self.length, self.blocs, self.blengths)</span>
        <span class="s0">return BlockIndex, args</span>

    <span class="s0">def __repr__(self) -&gt; str:</span>
        <span class="s0">output = 'BlockIndex\n'</span>
        <span class="s0">output += f'Block locations: {repr(self.blocs)}\n'</span>
        <span class="s0">output += f'Block lengths: {repr(self.blengths)}'</span>

        <span class="s0">return output</span>

    <span class="s0">@property</span>
    <span class="s0">def nbytes(self) -&gt; int:</span>
        <span class="s0">return self.blocs.nbytes + self.blengths.nbytes</span>

    <span class="s0">@property</span>
    <span class="s0">def ngaps(self) -&gt; int:</span>
        <span class="s0">return self.length - self.npoints</span>

    <span class="s0">cdef check_integrity(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Check:</span>
        <span class="s0">- Locations are in ascending order</span>
        <span class="s0">- No overlapping blocks</span>
        <span class="s0">- Blocks to not start after end of index, nor extend beyond end</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t i</span>
            <span class="s0">ndarray[int32_t, ndim=1] blocs, blengths</span>

        <span class="s0">blocs = self.blocs</span>
        <span class="s0">blengths = self.blengths</span>

        <span class="s0">if len(blocs) != len(blengths):</span>
            <span class="s0">raise ValueError('block bound arrays must be same length')</span>

        <span class="s0">for i in range(self.nblocks):</span>
            <span class="s0">if i &gt; 0:</span>
                <span class="s0">if blocs[i] &lt;= blocs[i - 1]:</span>
                    <span class="s0">raise ValueError('Locations not in ascending order')</span>

            <span class="s0">if i &lt; self.nblocks - 1:</span>
                <span class="s0">if blocs[i] + blengths[i] &gt; blocs[i + 1]:</span>
                    <span class="s0">raise ValueError(f'Block {i} overlaps')</span>
            <span class="s0">else:</span>
                <span class="s0">if blocs[i] + blengths[i] &gt; self.length:</span>
                    <span class="s0">raise ValueError(f'Block {i} extends beyond end')</span>

            <span class="s0"># no zero-length blocks</span>
            <span class="s0">if blengths[i] == 0:</span>
                <span class="s0">raise ValueError(f'Zero-length block {i}')</span>

    <span class="s0">def equals(self, other: object) -&gt; bool:</span>
        <span class="s0">if not isinstance(other, BlockIndex):</span>
            <span class="s0">return False</span>

        <span class="s0">if self is other:</span>
            <span class="s0">return True</span>

        <span class="s0">same_length = self.length == other.length</span>
        <span class="s0">same_blocks = (np.array_equal(self.blocs, other.blocs) and</span>
                       <span class="s0">np.array_equal(self.blengths, other.blengths))</span>
        <span class="s0">return same_length and same_blocks</span>

    <span class="s0">def to_block_index(self):</span>
        <span class="s0">return self</span>

    <span class="s0">cpdef to_int_index(self):</span>
        <span class="s0">cdef:</span>
            <span class="s0">int32_t i = 0, j, b</span>
            <span class="s0">int32_t offset</span>
            <span class="s0">ndarray[int32_t, ndim=1] indices</span>

        <span class="s0">indices = np.empty(self.npoints, dtype=np.int32)</span>

        <span class="s0">for b in range(self.nblocks):</span>
            <span class="s0">offset = self.locbuf[b]</span>

            <span class="s0">for j in range(self.lenbuf[b]):</span>
                <span class="s0">indices[i] = offset + j</span>
                <span class="s0">i += 1</span>

        <span class="s0">return IntIndex(self.length, indices)</span>

    <span class="s0">@property</span>
    <span class="s0">def indices(self):</span>
        <span class="s0">return self.to_int_index().indices</span>

    <span class="s0">cpdef BlockIndex intersect(self, SparseIndex other):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Intersect two BlockIndex objects</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">BlockIndex</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">BlockIndex y</span>
            <span class="s0">ndarray[int32_t, ndim=1] xloc, xlen, yloc, ylen, out_bloc, out_blen</span>
            <span class="s0">Py_ssize_t xi = 0, yi = 0, max_len, result_indexer = 0</span>
            <span class="s0">int32_t cur_loc, cur_length, diff</span>

        <span class="s0">y = other.to_block_index()</span>

        <span class="s0">if self.length != y.length:</span>
            <span class="s0">raise Exception('Indices must reference same underlying length')</span>

        <span class="s0">xloc = self.blocs</span>
        <span class="s0">xlen = self.blengths</span>
        <span class="s0">yloc = y.blocs</span>
        <span class="s0">ylen = y.blengths</span>

        <span class="s0"># block may be split, but can't exceed original len / 2 + 1</span>
        <span class="s0">max_len = min(self.length, y.length) // 2 + 1</span>
        <span class="s0">out_bloc = np.empty(max_len, dtype=np.int32)</span>
        <span class="s0">out_blen = np.empty(max_len, dtype=np.int32)</span>

        <span class="s0">while True:</span>
            <span class="s0"># we are done (or possibly never began)</span>
            <span class="s0">if xi &gt;= self.nblocks or yi &gt;= y.nblocks:</span>
                <span class="s0">break</span>

            <span class="s0"># completely symmetric...would like to avoid code dup but oh well</span>
            <span class="s0">if xloc[xi] &gt;= yloc[yi]:</span>
                <span class="s0">cur_loc = xloc[xi]</span>
                <span class="s0">diff = xloc[xi] - yloc[yi]</span>

                <span class="s0">if ylen[yi] &lt;= diff:</span>
                    <span class="s0"># have to skip this block</span>
                    <span class="s0">yi += 1</span>
                    <span class="s0">continue</span>

                <span class="s0">if ylen[yi] - diff &lt; xlen[xi]:</span>
                    <span class="s0"># take end of y block, move onward</span>
                    <span class="s0">cur_length = ylen[yi] - diff</span>
                    <span class="s0">yi += 1</span>
                <span class="s0">else:</span>
                    <span class="s0"># take end of x block</span>
                    <span class="s0">cur_length = xlen[xi]</span>
                    <span class="s0">xi += 1</span>

            <span class="s0">else:  # xloc[xi] &lt; yloc[yi]</span>
                <span class="s0">cur_loc = yloc[yi]</span>
                <span class="s0">diff = yloc[yi] - xloc[xi]</span>

                <span class="s0">if xlen[xi] &lt;= diff:</span>
                    <span class="s0"># have to skip this block</span>
                    <span class="s0">xi += 1</span>
                    <span class="s0">continue</span>

                <span class="s0">if xlen[xi] - diff &lt; ylen[yi]:</span>
                    <span class="s0"># take end of x block, move onward</span>
                    <span class="s0">cur_length = xlen[xi] - diff</span>
                    <span class="s0">xi += 1</span>
                <span class="s0">else:</span>
                    <span class="s0"># take end of y block</span>
                    <span class="s0">cur_length = ylen[yi]</span>
                    <span class="s0">yi += 1</span>

            <span class="s0">out_bloc[result_indexer] = cur_loc</span>
            <span class="s0">out_blen[result_indexer] = cur_length</span>
            <span class="s0">result_indexer += 1</span>

        <span class="s0">out_bloc = out_bloc[:result_indexer]</span>
        <span class="s0">out_blen = out_blen[:result_indexer]</span>

        <span class="s0">return BlockIndex(self.length, out_bloc, out_blen)</span>

    <span class="s0">cpdef BlockIndex make_union(self, SparseIndex y):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Combine together two BlockIndex objects, accepting indices if contained</span>
        <span class="s0">in one or the other</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">other : SparseIndex</span>

        <span class="s0">Notes</span>
        <span class="s0">-----</span>
        <span class="s0">union is a protected keyword in Cython, hence make_union</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">BlockIndex</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return BlockUnion(self, y.to_block_index()).result</span>

    <span class="s0">cpdef Py_ssize_t lookup(self, Py_ssize_t index):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return the internal location if value exists on given index.</span>
        <span class="s0">Return -1 otherwise.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t i, cum_len</span>
            <span class="s0">ndarray[int32_t, ndim=1] locs, lens</span>

        <span class="s0">locs = self.blocs</span>
        <span class="s0">lens = self.blengths</span>

        <span class="s0">if self.nblocks == 0:</span>
            <span class="s0">return -1</span>
        <span class="s0">elif index &lt; locs[0]:</span>
            <span class="s0">return -1</span>

        <span class="s0">cum_len = 0</span>
        <span class="s0">for i in range(self.nblocks):</span>
            <span class="s0">if index &gt;= locs[i] and index &lt; locs[i] + lens[i]:</span>
                <span class="s0">return cum_len + index - locs[i]</span>
            <span class="s0">cum_len += lens[i]</span>

        <span class="s0">return -1</span>

    <span class="s0">@cython.wraparound(False)</span>
    <span class="s0">cpdef ndarray[int32_t] lookup_array(self, ndarray[int32_t, ndim=1] indexer):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Vectorized lookup, returns ndarray[int32_t]</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t n, i, j, ind_val</span>
            <span class="s0">ndarray[int32_t, ndim=1] locs, lens</span>
            <span class="s0">ndarray[int32_t, ndim=1] results</span>

        <span class="s0">locs = self.blocs</span>
        <span class="s0">lens = self.blengths</span>

        <span class="s0">n = len(indexer)</span>
        <span class="s0">results = np.empty(n, dtype=np.int32)</span>
        <span class="s0">results[:] = -1</span>

        <span class="s0">if self.npoints == 0:</span>
            <span class="s0">return results</span>

        <span class="s0">for i in range(n):</span>
            <span class="s0">ind_val = indexer[i]</span>
            <span class="s0">if not (ind_val &lt; 0 or self.length &lt;= ind_val):</span>
                <span class="s0">cum_len = 0</span>
                <span class="s0">for j in range(self.nblocks):</span>
                    <span class="s0">if ind_val &gt;= locs[j] and ind_val &lt; locs[j] + lens[j]:</span>
                        <span class="s0">results[i] = cum_len + ind_val - locs[j]</span>
                    <span class="s0">cum_len += lens[j]</span>
        <span class="s0">return results</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class BlockMerge:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Object-oriented approach makes sharing state between recursive functions a</span>
    <span class="s0">lot easier and reduces code duplication</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">BlockIndex x, y, result</span>
        <span class="s0">ndarray xstart, xlen, xend, ystart, ylen, yend</span>
        <span class="s0">int32_t xi, yi  # block indices</span>

    <span class="s0">def __init__(self, BlockIndex x, BlockIndex y):</span>
        <span class="s0">self.x = x</span>
        <span class="s0">self.y = y</span>

        <span class="s0">if x.length != y.length:</span>
            <span class="s0">raise Exception('Indices must reference same underlying length')</span>

        <span class="s0">self.xstart = self.x.blocs</span>
        <span class="s0">self.ystart = self.y.blocs</span>

        <span class="s0">self.xend = self.x.blocs + self.x.blengths</span>
        <span class="s0">self.yend = self.y.blocs + self.y.blengths</span>

        <span class="s0"># self.xlen = self.x.blengths</span>
        <span class="s0"># self.ylen = self.y.blengths</span>

        <span class="s0">self.xi = 0</span>
        <span class="s0">self.yi = 0</span>

        <span class="s0">self.result = self._make_merged_blocks()</span>

    <span class="s0">cdef _make_merged_blocks(self):</span>
        <span class="s0">raise NotImplementedError</span>

    <span class="s0">cdef _set_current_indices(self, int32_t xi, int32_t yi, bint mode):</span>
        <span class="s0">if mode == 0:</span>
            <span class="s0">self.xi = xi</span>
            <span class="s0">self.yi = yi</span>
        <span class="s0">else:</span>
            <span class="s0">self.xi = yi</span>
            <span class="s0">self.yi = xi</span>


<span class="s0">@cython.internal</span>
<span class="s0">cdef class BlockUnion(BlockMerge):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Object-oriented approach makes sharing state between recursive functions a</span>
    <span class="s0">lot easier and reduces code duplication</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">cdef _make_merged_blocks(self):</span>
        <span class="s0">cdef:</span>
            <span class="s0">ndarray[int32_t, ndim=1] xstart, xend, ystart</span>
            <span class="s0">ndarray[int32_t, ndim=1] yend, out_bloc, out_blen</span>
            <span class="s0">int32_t nstart, nend, diff</span>
            <span class="s0">Py_ssize_t max_len, result_indexer = 0</span>

        <span class="s0">xstart = self.xstart</span>
        <span class="s0">xend = self.xend</span>
        <span class="s0">ystart = self.ystart</span>
        <span class="s0">yend = self.yend</span>

        <span class="s0">max_len = min(self.x.length, self.y.length) // 2 + 1</span>
        <span class="s0">out_bloc = np.empty(max_len, dtype=np.int32)</span>
        <span class="s0">out_blen = np.empty(max_len, dtype=np.int32)</span>

        <span class="s0">while True:</span>
            <span class="s0"># we are done (or possibly never began)</span>
            <span class="s0">if self.xi &gt;= self.x.nblocks and self.yi &gt;= self.y.nblocks:</span>
                <span class="s0">break</span>
            <span class="s0">elif self.yi &gt;= self.y.nblocks:</span>
                <span class="s0"># through with y, just pass through x blocks</span>
                <span class="s0">nstart = xstart[self.xi]</span>
                <span class="s0">nend = xend[self.xi]</span>
                <span class="s0">self.xi += 1</span>
            <span class="s0">elif self.xi &gt;= self.x.nblocks:</span>
                <span class="s0"># through with x, just pass through y blocks</span>
                <span class="s0">nstart = ystart[self.yi]</span>
                <span class="s0">nend = yend[self.yi]</span>
                <span class="s0">self.yi += 1</span>
            <span class="s0">else:</span>
                <span class="s0"># find end of new block</span>
                <span class="s0">if xstart[self.xi] &lt; ystart[self.yi]:</span>
                    <span class="s0">nstart = xstart[self.xi]</span>
                    <span class="s0">nend = self._find_next_block_end(0)</span>
                <span class="s0">else:</span>
                    <span class="s0">nstart = ystart[self.yi]</span>
                    <span class="s0">nend = self._find_next_block_end(1)</span>

            <span class="s0">out_bloc[result_indexer] = nstart</span>
            <span class="s0">out_blen[result_indexer] = nend - nstart</span>
            <span class="s0">result_indexer += 1</span>

        <span class="s0">out_bloc = out_bloc[:result_indexer]</span>
        <span class="s0">out_blen = out_blen[:result_indexer]</span>

        <span class="s0">return BlockIndex(self.x.length, out_bloc, out_blen)</span>

    <span class="s0">cdef int32_t _find_next_block_end(self, bint mode) except -1:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Wow, this got complicated in a hurry</span>

        <span class="s0">mode 0: block started in index x</span>
        <span class="s0">mode 1: block started in index y</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">ndarray[int32_t, ndim=1] xstart, xend, ystart, yend</span>
            <span class="s0">int32_t xi, yi, xnblocks, ynblocks, nend</span>

        <span class="s0">if mode != 0 and mode != 1:</span>
            <span class="s0">raise Exception('Mode must be 0 or 1')</span>

        <span class="s0"># so symmetric code will work</span>
        <span class="s0">if mode == 0:</span>
            <span class="s0">xstart = self.xstart</span>
            <span class="s0">xend = self.xend</span>
            <span class="s0">xi = self.xi</span>

            <span class="s0">ystart = self.ystart</span>
            <span class="s0">yend = self.yend</span>
            <span class="s0">yi = self.yi</span>
            <span class="s0">ynblocks = self.y.nblocks</span>
        <span class="s0">else:</span>
            <span class="s0">xstart = self.ystart</span>
            <span class="s0">xend = self.yend</span>
            <span class="s0">xi = self.yi</span>

            <span class="s0">ystart = self.xstart</span>
            <span class="s0">yend = self.xend</span>
            <span class="s0">yi = self.xi</span>
            <span class="s0">ynblocks = self.x.nblocks</span>

        <span class="s0">nend = xend[xi]</span>

        <span class="s0"># done with y?</span>
        <span class="s0">if yi == ynblocks:</span>
            <span class="s0">self._set_current_indices(xi + 1, yi, mode)</span>
            <span class="s0">return nend</span>
        <span class="s0">elif nend &lt; ystart[yi]:</span>
            <span class="s0"># block ends before y block</span>
            <span class="s0">self._set_current_indices(xi + 1, yi, mode)</span>
            <span class="s0">return nend</span>
        <span class="s0">else:</span>
            <span class="s0">while yi &lt; ynblocks and nend &gt; yend[yi]:</span>
                <span class="s0">yi += 1</span>

            <span class="s0">self._set_current_indices(xi + 1, yi, mode)</span>

            <span class="s0">if yi == ynblocks:</span>
                <span class="s0">return nend</span>

            <span class="s0">if nend &lt; ystart[yi]:</span>
                <span class="s0"># we're done, return the block end</span>
                <span class="s0">return nend</span>
            <span class="s0">else:</span>
                <span class="s0"># merge blocks, continue searching</span>
                <span class="s0"># this also catches the case where blocks</span>
                <span class="s0">return self._find_next_block_end(1 - mode)</span>


<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># Sparse arithmetic</span>

<span class="s0">include &quot;sparse_op_helper.pxi&quot;</span>


<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># SparseArray mask create operations</span>

<span class="s0">def make_mask_object_ndarray(ndarray[object, ndim=1] arr, object fill_value):</span>
    <span class="s0">cdef:</span>
        <span class="s0">object value</span>
        <span class="s0">Py_ssize_t i</span>
        <span class="s0">Py_ssize_t new_length = len(arr)</span>
        <span class="s0">ndarray[int8_t, ndim=1] mask</span>

    <span class="s0">mask = np.ones(new_length, dtype=np.int8)</span>

    <span class="s0">for i in range(new_length):</span>
        <span class="s0">value = arr[i]</span>
        <span class="s0">if value == fill_value and type(value) == type(fill_value):</span>
            <span class="s0">mask[i] = 0</span>

    <span class="s0">return mask.view(dtype=bool)</span>
</pre>
</body>
</html>