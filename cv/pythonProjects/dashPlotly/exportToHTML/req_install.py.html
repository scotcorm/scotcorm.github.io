<html>
<head>
<title>req_install.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
req_install.py</font>
</center></td></tr></table>
<pre><span class="s0"># The following comment should be removed at some point in the future.</span>
<span class="s0"># mypy: strict-optional=False</span>

<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">shutil</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">uuid</span>
<span class="s2">import </span><span class="s1">zipfile</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Collection</span><span class="s2">, </span><span class="s1">Dict</span><span class="s2">, </span><span class="s1">Iterable</span><span class="s2">, </span><span class="s1">List</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">, </span><span class="s1">Sequence</span><span class="s2">, </span><span class="s1">Union</span>

<span class="s2">from </span><span class="s1">pip._vendor.packaging.markers </span><span class="s2">import </span><span class="s1">Marker</span>
<span class="s2">from </span><span class="s1">pip._vendor.packaging.requirements </span><span class="s2">import </span><span class="s1">Requirement</span>
<span class="s2">from </span><span class="s1">pip._vendor.packaging.specifiers </span><span class="s2">import </span><span class="s1">SpecifierSet</span>
<span class="s2">from </span><span class="s1">pip._vendor.packaging.utils </span><span class="s2">import </span><span class="s1">canonicalize_name</span>
<span class="s2">from </span><span class="s1">pip._vendor.packaging.version </span><span class="s2">import </span><span class="s1">Version</span>
<span class="s2">from </span><span class="s1">pip._vendor.packaging.version </span><span class="s2">import </span><span class="s1">parse </span><span class="s2">as </span><span class="s1">parse_version</span>
<span class="s2">from </span><span class="s1">pip._vendor.pep517.wrappers </span><span class="s2">import </span><span class="s1">Pep517HookCaller</span>

<span class="s2">from </span><span class="s1">pip._internal.build_env </span><span class="s2">import </span><span class="s1">BuildEnvironment</span><span class="s2">, </span><span class="s1">NoOpBuildEnvironment</span>
<span class="s2">from </span><span class="s1">pip._internal.exceptions </span><span class="s2">import </span><span class="s1">InstallationError</span><span class="s2">, </span><span class="s1">LegacyInstallFailure</span>
<span class="s2">from </span><span class="s1">pip._internal.locations </span><span class="s2">import </span><span class="s1">get_scheme</span>
<span class="s2">from </span><span class="s1">pip._internal.metadata </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">BaseDistribution</span><span class="s2">,</span>
    <span class="s1">get_default_environment</span><span class="s2">,</span>
    <span class="s1">get_directory_distribution</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pip._internal.models.link </span><span class="s2">import </span><span class="s1">Link</span>
<span class="s2">from </span><span class="s1">pip._internal.operations.build.metadata </span><span class="s2">import </span><span class="s1">generate_metadata</span>
<span class="s2">from </span><span class="s1">pip._internal.operations.build.metadata_editable </span><span class="s2">import </span><span class="s1">generate_editable_metadata</span>
<span class="s2">from </span><span class="s1">pip._internal.operations.build.metadata_legacy </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">generate_metadata </span><span class="s2">as </span><span class="s1">generate_metadata_legacy</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pip._internal.operations.install.editable_legacy </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">install_editable </span><span class="s2">as </span><span class="s1">install_editable_legacy</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pip._internal.operations.install.legacy </span><span class="s2">import </span><span class="s1">install </span><span class="s2">as </span><span class="s1">install_legacy</span>
<span class="s2">from </span><span class="s1">pip._internal.operations.install.wheel </span><span class="s2">import </span><span class="s1">install_wheel</span>
<span class="s2">from </span><span class="s1">pip._internal.pyproject </span><span class="s2">import </span><span class="s1">load_pyproject_toml</span><span class="s2">, </span><span class="s1">make_pyproject_path</span>
<span class="s2">from </span><span class="s1">pip._internal.req.req_uninstall </span><span class="s2">import </span><span class="s1">UninstallPathSet</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.deprecation </span><span class="s2">import </span><span class="s1">deprecated</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.direct_url_helpers </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">direct_url_for_editable</span><span class="s2">,</span>
    <span class="s1">direct_url_from_link</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.hashes </span><span class="s2">import </span><span class="s1">Hashes</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.misc </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ask_path_exists</span><span class="s2">,</span>
    <span class="s1">backup_dir</span><span class="s2">,</span>
    <span class="s1">display_path</span><span class="s2">,</span>
    <span class="s1">hide_url</span><span class="s2">,</span>
    <span class="s1">redact_auth_from_url</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.packaging </span><span class="s2">import </span><span class="s1">safe_extra</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.subprocess </span><span class="s2">import </span><span class="s1">runner_with_spinner_message</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.temp_dir </span><span class="s2">import </span><span class="s1">TempDirectory</span><span class="s2">, </span><span class="s1">tempdir_kinds</span>
<span class="s2">from </span><span class="s1">pip._internal.utils.virtualenv </span><span class="s2">import </span><span class="s1">running_under_virtualenv</span>
<span class="s2">from </span><span class="s1">pip._internal.vcs </span><span class="s2">import </span><span class="s1">vcs</span>

<span class="s1">logger = logging.getLogger(__name__)</span>


<span class="s2">class </span><span class="s1">InstallRequirement:</span>
    <span class="s3">&quot;&quot;&quot; 
    Represents something that may be installed later on, may have information 
    about where to fetch the relevant requirement and also contains logic for 
    installing the said requirement. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">req: Optional[Requirement]</span><span class="s2">,</span>
        <span class="s1">comes_from: Optional[Union[str</span><span class="s2">, </span><span class="s4">&quot;InstallRequirement&quot;</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">editable: bool = </span><span class="s2">False,</span>
        <span class="s1">link: Optional[Link] = </span><span class="s2">None,</span>
        <span class="s1">markers: Optional[Marker] = </span><span class="s2">None,</span>
        <span class="s1">use_pep517: Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">isolated: bool = </span><span class="s2">False,</span>
        <span class="s1">install_options: Optional[List[str]] = </span><span class="s2">None,</span>
        <span class="s1">global_options: Optional[List[str]] = </span><span class="s2">None,</span>
        <span class="s1">hash_options: Optional[Dict[str</span><span class="s2">, </span><span class="s1">List[str]]] = </span><span class="s2">None,</span>
        <span class="s1">constraint: bool = </span><span class="s2">False,</span>
        <span class="s1">extras: Collection[str] = ()</span><span class="s2">,</span>
        <span class="s1">user_supplied: bool = </span><span class="s2">False,</span>
        <span class="s1">permit_editable_wheels: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">assert </span><span class="s1">req </span><span class="s2">is None or </span><span class="s1">isinstance(req</span><span class="s2">, </span><span class="s1">Requirement)</span><span class="s2">, </span><span class="s1">req</span>
        <span class="s1">self.req = req</span>
        <span class="s1">self.comes_from = comes_from</span>
        <span class="s1">self.constraint = constraint</span>
        <span class="s1">self.editable = editable</span>
        <span class="s1">self.permit_editable_wheels = permit_editable_wheels</span>
        <span class="s1">self.legacy_install_reason: Optional[int] = </span><span class="s2">None</span>

        <span class="s0"># source_dir is the local directory where the linked requirement is</span>
        <span class="s0"># located, or unpacked. In case unpacking is needed, creating and</span>
        <span class="s0"># populating source_dir is done by the RequirementPreparer. Note this</span>
        <span class="s0"># is not necessarily the directory where pyproject.toml or setup.py is</span>
        <span class="s0"># located - that one is obtained via unpacked_source_directory.</span>
        <span class="s1">self.source_dir: Optional[str] = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">self.editable:</span>
            <span class="s2">assert </span><span class="s1">link</span>
            <span class="s2">if </span><span class="s1">link.is_file:</span>
                <span class="s1">self.source_dir = os.path.normpath(os.path.abspath(link.file_path))</span>

        <span class="s2">if </span><span class="s1">link </span><span class="s2">is None and </span><span class="s1">req </span><span class="s2">and </span><span class="s1">req.url:</span>
            <span class="s0"># PEP 508 URL requirement</span>
            <span class="s1">link = Link(req.url)</span>
        <span class="s1">self.link = self.original_link = link</span>
        <span class="s1">self.original_link_is_in_wheel_cache = </span><span class="s2">False</span>

        <span class="s0"># Path to any downloaded or already-existing package.</span>
        <span class="s1">self.local_file_path: Optional[str] = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">self.link </span><span class="s2">and </span><span class="s1">self.link.is_file:</span>
            <span class="s1">self.local_file_path = self.link.file_path</span>

        <span class="s2">if </span><span class="s1">extras:</span>
            <span class="s1">self.extras = extras</span>
        <span class="s2">elif </span><span class="s1">req:</span>
            <span class="s1">self.extras = {safe_extra(extra) </span><span class="s2">for </span><span class="s1">extra </span><span class="s2">in </span><span class="s1">req.extras}</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.extras = set()</span>
        <span class="s2">if </span><span class="s1">markers </span><span class="s2">is None and </span><span class="s1">req:</span>
            <span class="s1">markers = req.marker</span>
        <span class="s1">self.markers = markers</span>

        <span class="s0"># This holds the Distribution object if this requirement is already installed.</span>
        <span class="s1">self.satisfied_by: Optional[BaseDistribution] = </span><span class="s2">None</span>
        <span class="s0"># Whether the installation process should try to uninstall an existing</span>
        <span class="s0"># distribution before installing this requirement.</span>
        <span class="s1">self.should_reinstall = </span><span class="s2">False</span>
        <span class="s0"># Temporary build location</span>
        <span class="s1">self._temp_build_dir: Optional[TempDirectory] = </span><span class="s2">None</span>
        <span class="s0"># Set to True after successful installation</span>
        <span class="s1">self.install_succeeded: Optional[bool] = </span><span class="s2">None</span>
        <span class="s0"># Supplied options</span>
        <span class="s1">self.install_options = install_options </span><span class="s2">if </span><span class="s1">install_options </span><span class="s2">else </span><span class="s1">[]</span>
        <span class="s1">self.global_options = global_options </span><span class="s2">if </span><span class="s1">global_options </span><span class="s2">else </span><span class="s1">[]</span>
        <span class="s1">self.hash_options = hash_options </span><span class="s2">if </span><span class="s1">hash_options </span><span class="s2">else </span><span class="s1">{}</span>
        <span class="s0"># Set to True after successful preparation of this requirement</span>
        <span class="s1">self.prepared = </span><span class="s2">False</span>
        <span class="s0"># User supplied requirement are explicitly requested for installation</span>
        <span class="s0"># by the user via CLI arguments or requirements files, as opposed to,</span>
        <span class="s0"># e.g. dependencies, extras or constraints.</span>
        <span class="s1">self.user_supplied = user_supplied</span>

        <span class="s1">self.isolated = isolated</span>
        <span class="s1">self.build_env: BuildEnvironment = NoOpBuildEnvironment()</span>

        <span class="s0"># For PEP 517, the directory where we request the project metadata</span>
        <span class="s0"># gets stored. We need this to pass to build_wheel, so the backend</span>
        <span class="s0"># can ensure that the wheel matches the metadata (see the PEP for</span>
        <span class="s0"># details).</span>
        <span class="s1">self.metadata_directory: Optional[str] = </span><span class="s2">None</span>

        <span class="s0"># The static build requirements (from pyproject.toml)</span>
        <span class="s1">self.pyproject_requires: Optional[List[str]] = </span><span class="s2">None</span>

        <span class="s0"># Build requirements that we will check are available</span>
        <span class="s1">self.requirements_to_check: List[str] = []</span>

        <span class="s0"># The PEP 517 backend we should use to build the project</span>
        <span class="s1">self.pep517_backend: Optional[Pep517HookCaller] = </span><span class="s2">None</span>

        <span class="s0"># Are we using PEP 517 for this requirement?</span>
        <span class="s0"># After pyproject.toml has been loaded, the only valid values are True</span>
        <span class="s0"># and False. Before loading, None is valid (meaning &quot;use the default&quot;).</span>
        <span class="s0"># Setting an explicit value before loading pyproject.toml is supported,</span>
        <span class="s0"># but after loading this flag should be treated as read only.</span>
        <span class="s1">self.use_pep517 = use_pep517</span>

        <span class="s0"># This requirement needs more preparation before it can be built</span>
        <span class="s1">self.needs_more_preparation = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s2">if </span><span class="s1">self.req:</span>
            <span class="s1">s = str(self.req)</span>
            <span class="s2">if </span><span class="s1">self.link:</span>
                <span class="s1">s += </span><span class="s4">&quot; from {}&quot;</span><span class="s1">.format(redact_auth_from_url(self.link.url))</span>
        <span class="s2">elif </span><span class="s1">self.link:</span>
            <span class="s1">s = redact_auth_from_url(self.link.url)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">s = </span><span class="s4">&quot;&lt;InstallRequirement&gt;&quot;</span>
        <span class="s2">if </span><span class="s1">self.satisfied_by </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">s += </span><span class="s4">&quot; in {}&quot;</span><span class="s1">.format(display_path(self.satisfied_by.location))</span>
        <span class="s2">if </span><span class="s1">self.comes_from:</span>
            <span class="s2">if </span><span class="s1">isinstance(self.comes_from</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">comes_from: Optional[str] = self.comes_from</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">comes_from = self.comes_from.from_path()</span>
            <span class="s2">if </span><span class="s1">comes_from:</span>
                <span class="s1">s += </span><span class="s4">f&quot; (from </span><span class="s2">{</span><span class="s1">comes_from</span><span class="s2">}</span><span class="s4">)&quot;</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;{} object: {} editable={!r}&gt;&quot;</span><span class="s1">.format(</span>
            <span class="s1">self.__class__.__name__</span><span class="s2">, </span><span class="s1">str(self)</span><span class="s2">, </span><span class="s1">self.editable</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">format_debug(self) -&gt; str:</span>
        <span class="s3">&quot;&quot;&quot;An un-tested helper for getting state, for debugging.&quot;&quot;&quot;</span>
        <span class="s1">attributes = vars(self)</span>
        <span class="s1">names = sorted(attributes)</span>

        <span class="s1">state = (</span><span class="s4">&quot;{}={!r}&quot;</span><span class="s1">.format(attr</span><span class="s2">, </span><span class="s1">attributes[attr]) </span><span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">sorted(names))</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;{name} object: {{{state}}}&gt;&quot;</span><span class="s1">.format(</span>
            <span class="s1">name=self.__class__.__name__</span><span class="s2">,</span>
            <span class="s1">state=</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(state)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s0"># Things that are valid for all kinds of requirements?</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">name(self) -&gt; Optional[str]:</span>
        <span class="s2">if </span><span class="s1">self.req </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s1">self.req.name</span>

    <span class="s1">@functools.lru_cache()  </span><span class="s0"># use cached_property in python 3.8+</span>
    <span class="s2">def </span><span class="s1">supports_pyproject_editable(self) -&gt; bool:</span>
        <span class="s2">if not </span><span class="s1">self.use_pep517:</span>
            <span class="s2">return False</span>
        <span class="s2">assert </span><span class="s1">self.pep517_backend</span>
        <span class="s2">with </span><span class="s1">self.build_env:</span>
            <span class="s1">runner = runner_with_spinner_message(</span>
                <span class="s4">&quot;Checking if build backend supports build_editable&quot;</span>
            <span class="s1">)</span>
            <span class="s2">with </span><span class="s1">self.pep517_backend.subprocess_runner(runner):</span>
                <span class="s2">return </span><span class="s4">&quot;build_editable&quot; </span><span class="s2">in </span><span class="s1">self.pep517_backend._supported_features()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">specifier(self) -&gt; SpecifierSet:</span>
        <span class="s2">return </span><span class="s1">self.req.specifier</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_pinned(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;Return whether I am pinned to an exact version. 
 
        For example, some-package==1.2 is pinned; some-package&gt;1.2 is not. 
        &quot;&quot;&quot;</span>
        <span class="s1">specifiers = self.specifier</span>
        <span class="s2">return </span><span class="s1">len(specifiers) == </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">next(iter(specifiers)).operator </span><span class="s2">in </span><span class="s1">{</span><span class="s4">&quot;==&quot;</span><span class="s2">, </span><span class="s4">&quot;===&quot;</span><span class="s1">}</span>

    <span class="s2">def </span><span class="s1">match_markers(self</span><span class="s2">, </span><span class="s1">extras_requested: Optional[Iterable[str]] = </span><span class="s2">None</span><span class="s1">) -&gt; bool:</span>
        <span class="s2">if not </span><span class="s1">extras_requested:</span>
            <span class="s0"># Provide an extra to safely evaluate the markers</span>
            <span class="s0"># without matching any extra</span>
            <span class="s1">extras_requested = (</span><span class="s4">&quot;&quot;</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.markers </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">any(</span>
                <span class="s1">self.markers.evaluate({</span><span class="s4">&quot;extra&quot;</span><span class="s1">: extra}) </span><span class="s2">for </span><span class="s1">extra </span><span class="s2">in </span><span class="s1">extras_requested</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return True</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">has_hash_options(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;Return whether any known-good hashes are specified as options. 
 
        These activate --require-hashes mode; hashes specified as part of a 
        URL do not. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">bool(self.hash_options)</span>

    <span class="s2">def </span><span class="s1">hashes(self</span><span class="s2">, </span><span class="s1">trust_internet: bool = </span><span class="s2">True</span><span class="s1">) -&gt; Hashes:</span>
        <span class="s3">&quot;&quot;&quot;Return a hash-comparer that considers my option- and URL-based 
        hashes to be known-good. 
 
        Hashes in URLs--ones embedded in the requirements file, not ones 
        downloaded from an index server--are almost peers with ones from 
        flags. They satisfy --require-hashes (whether it was implicitly or 
        explicitly activated) but do not activate it. md5 and sha224 are not 
        allowed in flags, which should nudge people toward good algos. We 
        always OR all hashes together, even ones from URLs. 
 
        :param trust_internet: Whether to trust URL-based (#md5=...) hashes 
            downloaded from the internet, as by populate_link() 
 
        &quot;&quot;&quot;</span>
        <span class="s1">good_hashes = self.hash_options.copy()</span>
        <span class="s1">link = self.link </span><span class="s2">if </span><span class="s1">trust_internet </span><span class="s2">else </span><span class="s1">self.original_link</span>
        <span class="s2">if </span><span class="s1">link </span><span class="s2">and </span><span class="s1">link.hash:</span>
            <span class="s1">good_hashes.setdefault(link.hash_name</span><span class="s2">, </span><span class="s1">[]).append(link.hash)</span>
        <span class="s2">return </span><span class="s1">Hashes(good_hashes)</span>

    <span class="s2">def </span><span class="s1">from_path(self) -&gt; Optional[str]:</span>
        <span class="s3">&quot;&quot;&quot;Format a nice indicator to show where this &quot;comes from&quot; &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.req </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return None</span>
        <span class="s1">s = str(self.req)</span>
        <span class="s2">if </span><span class="s1">self.comes_from:</span>
            <span class="s2">if </span><span class="s1">isinstance(self.comes_from</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">comes_from = self.comes_from</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">comes_from = self.comes_from.from_path()</span>
            <span class="s2">if </span><span class="s1">comes_from:</span>
                <span class="s1">s += </span><span class="s4">&quot;-&gt;&quot; </span><span class="s1">+ comes_from</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">ensure_build_location(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">build_dir: str</span><span class="s2">, </span><span class="s1">autodelete: bool</span><span class="s2">, </span><span class="s1">parallel_builds: bool</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s2">assert </span><span class="s1">build_dir </span><span class="s2">is not None</span>
        <span class="s2">if </span><span class="s1">self._temp_build_dir </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">self._temp_build_dir.path</span>
            <span class="s2">return </span><span class="s1">self._temp_build_dir.path</span>
        <span class="s2">if </span><span class="s1">self.req </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># Some systems have /tmp as a symlink which confuses custom</span>
            <span class="s0"># builds (such as numpy). Thus, we ensure that the real path</span>
            <span class="s0"># is returned.</span>
            <span class="s1">self._temp_build_dir = TempDirectory(</span>
                <span class="s1">kind=tempdir_kinds.REQ_BUILD</span><span class="s2">, </span><span class="s1">globally_managed=</span><span class="s2">True</span>
            <span class="s1">)</span>

            <span class="s2">return </span><span class="s1">self._temp_build_dir.path</span>

        <span class="s0"># This is the only remaining place where we manually determine the path</span>
        <span class="s0"># for the temporary directory. It is only needed for editables where</span>
        <span class="s0"># it is the value of the --src option.</span>

        <span class="s0"># When parallel builds are enabled, add a UUID to the build directory</span>
        <span class="s0"># name so multiple builds do not interfere with each other.</span>
        <span class="s1">dir_name: str = canonicalize_name(self.name)</span>
        <span class="s2">if </span><span class="s1">parallel_builds:</span>
            <span class="s1">dir_name = </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">dir_name</span><span class="s2">}</span><span class="s4">_</span><span class="s2">{</span><span class="s1">uuid.uuid4().hex</span><span class="s2">}</span><span class="s4">&quot;</span>

        <span class="s0"># FIXME: Is there a better place to create the build_dir? (hg and bzr</span>
        <span class="s0"># need this)</span>
        <span class="s2">if not </span><span class="s1">os.path.exists(build_dir):</span>
            <span class="s1">logger.debug(</span><span class="s4">&quot;Creating directory %s&quot;</span><span class="s2">, </span><span class="s1">build_dir)</span>
            <span class="s1">os.makedirs(build_dir)</span>
        <span class="s1">actual_build_dir = os.path.join(build_dir</span><span class="s2">, </span><span class="s1">dir_name)</span>
        <span class="s0"># `None` indicates that we respect the globally-configured deletion</span>
        <span class="s0"># settings, which is what we actually want when auto-deleting.</span>
        <span class="s1">delete_arg = </span><span class="s2">None if </span><span class="s1">autodelete </span><span class="s2">else False</span>
        <span class="s2">return </span><span class="s1">TempDirectory(</span>
            <span class="s1">path=actual_build_dir</span><span class="s2">,</span>
            <span class="s1">delete=delete_arg</span><span class="s2">,</span>
            <span class="s1">kind=tempdir_kinds.REQ_BUILD</span><span class="s2">,</span>
            <span class="s1">globally_managed=</span><span class="s2">True,</span>
        <span class="s1">).path</span>

    <span class="s2">def </span><span class="s1">_set_requirement(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Set requirement after generating metadata.&quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">self.req </span><span class="s2">is None</span>
        <span class="s2">assert </span><span class="s1">self.metadata </span><span class="s2">is not None</span>
        <span class="s2">assert </span><span class="s1">self.source_dir </span><span class="s2">is not None</span>

        <span class="s0"># Construct a Requirement object from the generated metadata</span>
        <span class="s2">if </span><span class="s1">isinstance(parse_version(self.metadata[</span><span class="s4">&quot;Version&quot;</span><span class="s1">])</span><span class="s2">, </span><span class="s1">Version):</span>
            <span class="s1">op = </span><span class="s4">&quot;==&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">op = </span><span class="s4">&quot;===&quot;</span>

        <span class="s1">self.req = Requirement(</span>
            <span class="s4">&quot;&quot;</span><span class="s1">.join(</span>
                <span class="s1">[</span>
                    <span class="s1">self.metadata[</span><span class="s4">&quot;Name&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">op</span><span class="s2">,</span>
                    <span class="s1">self.metadata[</span><span class="s4">&quot;Version&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">warn_on_mismatching_name(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">metadata_name = canonicalize_name(self.metadata[</span><span class="s4">&quot;Name&quot;</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">canonicalize_name(self.req.name) == metadata_name:</span>
            <span class="s0"># Everything is fine.</span>
            <span class="s2">return</span>

        <span class="s0"># If we're here, there's a mismatch. Log a warning about it.</span>
        <span class="s1">logger.warning(</span>
            <span class="s4">&quot;Generating metadata for package %s &quot;</span>
            <span class="s4">&quot;produced metadata for project name %s. Fix your &quot;</span>
            <span class="s4">&quot;#egg=%s fragments.&quot;</span><span class="s2">,</span>
            <span class="s1">self.name</span><span class="s2">,</span>
            <span class="s1">metadata_name</span><span class="s2">,</span>
            <span class="s1">self.name</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.req = Requirement(metadata_name)</span>

    <span class="s2">def </span><span class="s1">check_if_exists(self</span><span class="s2">, </span><span class="s1">use_user_site: bool) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Find an installed distribution that satisfies or conflicts 
        with this requirement, and set self.satisfied_by or 
        self.should_reinstall appropriately. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.req </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>
        <span class="s1">existing_dist = get_default_environment().get_distribution(self.req.name)</span>
        <span class="s2">if not </span><span class="s1">existing_dist:</span>
            <span class="s2">return</span>

        <span class="s1">version_compatible = self.req.specifier.contains(</span>
            <span class="s1">existing_dist.version</span><span class="s2">,</span>
            <span class="s1">prereleases=</span><span class="s2">True,</span>
        <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">version_compatible:</span>
            <span class="s1">self.satisfied_by = </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">use_user_site:</span>
                <span class="s2">if </span><span class="s1">existing_dist.in_usersite:</span>
                    <span class="s1">self.should_reinstall = </span><span class="s2">True</span>
                <span class="s2">elif </span><span class="s1">running_under_virtualenv() </span><span class="s2">and </span><span class="s1">existing_dist.in_site_packages:</span>
                    <span class="s2">raise </span><span class="s1">InstallationError(</span>
                        <span class="s4">f&quot;Will not install to the user site because it will &quot;</span>
                        <span class="s4">f&quot;lack sys.path precedence to </span><span class="s2">{</span><span class="s1">existing_dist.raw_name</span><span class="s2">} </span><span class="s4">&quot;</span>
                        <span class="s4">f&quot;in </span><span class="s2">{</span><span class="s1">existing_dist.location</span><span class="s2">}</span><span class="s4">&quot;</span>
                    <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.should_reinstall = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.editable:</span>
                <span class="s1">self.should_reinstall = </span><span class="s2">True</span>
                <span class="s0"># when installing editables, nothing pre-existing should ever</span>
                <span class="s0"># satisfy</span>
                <span class="s1">self.satisfied_by = </span><span class="s2">None</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.satisfied_by = existing_dist</span>

    <span class="s0"># Things valid for wheels</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_wheel(self) -&gt; bool:</span>
        <span class="s2">if not </span><span class="s1">self.link:</span>
            <span class="s2">return False</span>
        <span class="s2">return </span><span class="s1">self.link.is_wheel</span>

    <span class="s0"># Things valid for sdists</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">unpacked_source_directory(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">os.path.join(</span>
            <span class="s1">self.source_dir</span><span class="s2">, </span><span class="s1">self.link </span><span class="s2">and </span><span class="s1">self.link.subdirectory_fragment </span><span class="s2">or </span><span class="s4">&quot;&quot;</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">setup_py_path(self) -&gt; str:</span>
        <span class="s2">assert </span><span class="s1">self.source_dir</span><span class="s2">, </span><span class="s4">f&quot;No source dir for </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s1">setup_py = os.path.join(self.unpacked_source_directory</span><span class="s2">, </span><span class="s4">&quot;setup.py&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">setup_py</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">setup_cfg_path(self) -&gt; str:</span>
        <span class="s2">assert </span><span class="s1">self.source_dir</span><span class="s2">, </span><span class="s4">f&quot;No source dir for </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s1">setup_cfg = os.path.join(self.unpacked_source_directory</span><span class="s2">, </span><span class="s4">&quot;setup.cfg&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">setup_cfg</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">pyproject_toml_path(self) -&gt; str:</span>
        <span class="s2">assert </span><span class="s1">self.source_dir</span><span class="s2">, </span><span class="s4">f&quot;No source dir for </span><span class="s2">{</span><span class="s1">self</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s2">return </span><span class="s1">make_pyproject_path(self.unpacked_source_directory)</span>

    <span class="s2">def </span><span class="s1">load_pyproject_toml(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Load the pyproject.toml file. 
 
        After calling this routine, all of the attributes related to PEP 517 
        processing for this requirement have been set. In particular, the 
        use_pep517 attribute can be used to determine whether we should 
        follow the PEP 517 or legacy (setup.py) code path. 
        &quot;&quot;&quot;</span>
        <span class="s1">pyproject_toml_data = load_pyproject_toml(</span>
            <span class="s1">self.use_pep517</span><span class="s2">, </span><span class="s1">self.pyproject_toml_path</span><span class="s2">, </span><span class="s1">self.setup_py_path</span><span class="s2">, </span><span class="s1">str(self)</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">pyproject_toml_data </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.use_pep517 = </span><span class="s2">False</span>
            <span class="s2">return</span>

        <span class="s1">self.use_pep517 = </span><span class="s2">True</span>
        <span class="s1">requires</span><span class="s2">, </span><span class="s1">backend</span><span class="s2">, </span><span class="s1">check</span><span class="s2">, </span><span class="s1">backend_path = pyproject_toml_data</span>
        <span class="s1">self.requirements_to_check = check</span>
        <span class="s1">self.pyproject_requires = requires</span>
        <span class="s1">self.pep517_backend = Pep517HookCaller(</span>
            <span class="s1">self.unpacked_source_directory</span><span class="s2">,</span>
            <span class="s1">backend</span><span class="s2">,</span>
            <span class="s1">backend_path=backend_path</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">isolated_editable_sanity_check(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Check that an editable requirement if valid for use with PEP 517/518. 
 
        This verifies that an editable that has a pyproject.toml either supports PEP 660 
        or as a setup.py or a setup.cfg 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">self.editable</span>
            <span class="s2">and </span><span class="s1">self.use_pep517</span>
            <span class="s2">and not </span><span class="s1">self.supports_pyproject_editable()</span>
            <span class="s2">and not </span><span class="s1">os.path.isfile(self.setup_py_path)</span>
            <span class="s2">and not </span><span class="s1">os.path.isfile(self.setup_cfg_path)</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">InstallationError(</span>
                <span class="s4">f&quot;Project </span><span class="s2">{</span><span class="s1">self</span><span class="s2">} </span><span class="s4">has a 'pyproject.toml' and its build &quot;</span>
                <span class="s4">f&quot;backend is missing the 'build_editable' hook. Since it does not &quot;</span>
                <span class="s4">f&quot;have a 'setup.py' nor a 'setup.cfg', &quot;</span>
                <span class="s4">f&quot;it cannot be installed in editable mode. &quot;</span>
                <span class="s4">f&quot;Consider using a build backend that supports PEP 660.&quot;</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">prepare_metadata(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Ensure that project metadata is available. 
 
        Under PEP 517 and PEP 660, call the backend hook to prepare the metadata. 
        Under legacy processing, call setup.py egg-info. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">self.source_dir</span>
        <span class="s1">details = self.name </span><span class="s2">or </span><span class="s4">f&quot;from </span><span class="s2">{</span><span class="s1">self.link</span><span class="s2">}</span><span class="s4">&quot;</span>

        <span class="s2">if </span><span class="s1">self.use_pep517:</span>
            <span class="s2">assert </span><span class="s1">self.pep517_backend </span><span class="s2">is not None</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">self.editable</span>
                <span class="s2">and </span><span class="s1">self.permit_editable_wheels</span>
                <span class="s2">and </span><span class="s1">self.supports_pyproject_editable()</span>
            <span class="s1">):</span>
                <span class="s1">self.metadata_directory = generate_editable_metadata(</span>
                    <span class="s1">build_env=self.build_env</span><span class="s2">,</span>
                    <span class="s1">backend=self.pep517_backend</span><span class="s2">,</span>
                    <span class="s1">details=details</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.metadata_directory = generate_metadata(</span>
                    <span class="s1">build_env=self.build_env</span><span class="s2">,</span>
                    <span class="s1">backend=self.pep517_backend</span><span class="s2">,</span>
                    <span class="s1">details=details</span><span class="s2">,</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.metadata_directory = generate_metadata_legacy(</span>
                <span class="s1">build_env=self.build_env</span><span class="s2">,</span>
                <span class="s1">setup_py_path=self.setup_py_path</span><span class="s2">,</span>
                <span class="s1">source_dir=self.unpacked_source_directory</span><span class="s2">,</span>
                <span class="s1">isolated=self.isolated</span><span class="s2">,</span>
                <span class="s1">details=details</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s0"># Act on the newly generated metadata, based on the name and version.</span>
        <span class="s2">if not </span><span class="s1">self.name:</span>
            <span class="s1">self._set_requirement()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.warn_on_mismatching_name()</span>

        <span class="s1">self.assert_source_matches_version()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">metadata(self) -&gt; Any:</span>
        <span class="s2">if not </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s4">&quot;_metadata&quot;</span><span class="s1">):</span>
            <span class="s1">self._metadata = self.get_dist().metadata</span>

        <span class="s2">return </span><span class="s1">self._metadata</span>

    <span class="s2">def </span><span class="s1">get_dist(self) -&gt; BaseDistribution:</span>
        <span class="s2">return </span><span class="s1">get_directory_distribution(self.metadata_directory)</span>

    <span class="s2">def </span><span class="s1">assert_source_matches_version(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">assert </span><span class="s1">self.source_dir</span>
        <span class="s1">version = self.metadata[</span><span class="s4">&quot;version&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.req.specifier </span><span class="s2">and </span><span class="s1">version </span><span class="s2">not in </span><span class="s1">self.req.specifier:</span>
            <span class="s1">logger.warning(</span>
                <span class="s4">&quot;Requested %s, but installing version %s&quot;</span><span class="s2">,</span>
                <span class="s1">self</span><span class="s2">,</span>
                <span class="s1">version</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">logger.debug(</span>
                <span class="s4">&quot;Source in %s has version %s, which satisfies requirement %s&quot;</span><span class="s2">,</span>
                <span class="s1">display_path(self.source_dir)</span><span class="s2">,</span>
                <span class="s1">version</span><span class="s2">,</span>
                <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">)</span>

    <span class="s0"># For both source distributions and editables</span>
    <span class="s2">def </span><span class="s1">ensure_has_source_dir(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">parent_dir: str</span><span class="s2">,</span>
        <span class="s1">autodelete: bool = </span><span class="s2">False,</span>
        <span class="s1">parallel_builds: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Ensure that a source_dir is set. 
 
        This will create a temporary build dir if the name of the requirement 
        isn't known yet. 
 
        :param parent_dir: The ideal pip parent_dir for the source_dir. 
            Generally src_dir for editables and build_dir for sdists. 
        :return: self.source_dir 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.source_dir </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.source_dir = self.ensure_build_location(</span>
                <span class="s1">parent_dir</span><span class="s2">,</span>
                <span class="s1">autodelete=autodelete</span><span class="s2">,</span>
                <span class="s1">parallel_builds=parallel_builds</span><span class="s2">,</span>
            <span class="s1">)</span>

    <span class="s0"># For editable installations</span>
    <span class="s2">def </span><span class="s1">update_editable(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">self.link:</span>
            <span class="s1">logger.debug(</span>
                <span class="s4">&quot;Cannot update repository at %s; repository location is unknown&quot;</span><span class="s2">,</span>
                <span class="s1">self.source_dir</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s2">return</span>
        <span class="s2">assert </span><span class="s1">self.editable</span>
        <span class="s2">assert </span><span class="s1">self.source_dir</span>
        <span class="s2">if </span><span class="s1">self.link.scheme == </span><span class="s4">&quot;file&quot;</span><span class="s1">:</span>
            <span class="s0"># Static paths don't get updated</span>
            <span class="s2">return</span>
        <span class="s1">vcs_backend = vcs.get_backend_for_scheme(self.link.scheme)</span>
        <span class="s0"># Editable requirements are validated in Requirement constructors.</span>
        <span class="s0"># So here, if it's neither a path nor a valid VCS URL, it's a bug.</span>
        <span class="s2">assert </span><span class="s1">vcs_backend</span><span class="s2">, </span><span class="s4">f&quot;Unsupported VCS URL </span><span class="s2">{</span><span class="s1">self.link.url</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s1">hidden_url = hide_url(self.link.url)</span>
        <span class="s1">vcs_backend.obtain(self.source_dir</span><span class="s2">, </span><span class="s1">url=hidden_url</span><span class="s2">, </span><span class="s1">verbosity=</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s0"># Top-level Actions</span>
    <span class="s2">def </span><span class="s1">uninstall(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">auto_confirm: bool = </span><span class="s2">False, </span><span class="s1">verbose: bool = </span><span class="s2">False</span>
    <span class="s1">) -&gt; Optional[UninstallPathSet]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Uninstall the distribution currently satisfying this requirement. 
 
        Prompts before removing or modifying files unless 
        ``auto_confirm`` is True. 
 
        Refuses to delete or modify files outside of ``sys.prefix`` - 
        thus uninstallation within a virtual environment can only 
        modify that virtual environment, even if the virtualenv is 
        linked to global site-packages. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">self.req</span>
        <span class="s1">dist = get_default_environment().get_distribution(self.req.name)</span>
        <span class="s2">if not </span><span class="s1">dist:</span>
            <span class="s1">logger.warning(</span><span class="s4">&quot;Skipping %s as it is not installed.&quot;</span><span class="s2">, </span><span class="s1">self.name)</span>
            <span class="s2">return None</span>
        <span class="s1">logger.info(</span><span class="s4">&quot;Found existing installation: %s&quot;</span><span class="s2">, </span><span class="s1">dist)</span>

        <span class="s1">uninstalled_pathset = UninstallPathSet.from_dist(dist)</span>
        <span class="s1">uninstalled_pathset.remove(auto_confirm</span><span class="s2">, </span><span class="s1">verbose)</span>
        <span class="s2">return </span><span class="s1">uninstalled_pathset</span>

    <span class="s2">def </span><span class="s1">_get_archive_name(self</span><span class="s2">, </span><span class="s1">path: str</span><span class="s2">, </span><span class="s1">parentdir: str</span><span class="s2">, </span><span class="s1">rootdir: str) -&gt; str:</span>
        <span class="s2">def </span><span class="s1">_clean_zip_name(name: str</span><span class="s2">, </span><span class="s1">prefix: str) -&gt; str:</span>
            <span class="s2">assert </span><span class="s1">name.startswith(</span>
                <span class="s1">prefix + os.path.sep</span>
            <span class="s1">)</span><span class="s2">, </span><span class="s4">f&quot;name </span><span class="s2">{</span><span class="s1">name</span><span class="s2">!r} </span><span class="s4">doesn't start with prefix </span><span class="s2">{</span><span class="s1">prefix</span><span class="s2">!r}</span><span class="s4">&quot;</span>
            <span class="s1">name = name[len(prefix) + </span><span class="s5">1 </span><span class="s1">:]</span>
            <span class="s1">name = name.replace(os.path.sep</span><span class="s2">, </span><span class="s4">&quot;/&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">name</span>

        <span class="s1">path = os.path.join(parentdir</span><span class="s2">, </span><span class="s1">path)</span>
        <span class="s1">name = _clean_zip_name(path</span><span class="s2">, </span><span class="s1">rootdir)</span>
        <span class="s2">return </span><span class="s1">self.name + </span><span class="s4">&quot;/&quot; </span><span class="s1">+ name</span>

    <span class="s2">def </span><span class="s1">archive(self</span><span class="s2">, </span><span class="s1">build_dir: Optional[str]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Saves archive to provided build_dir. 
 
        Used for saving downloaded VCS requirements as part of `pip download`. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">self.source_dir</span>
        <span class="s2">if </span><span class="s1">build_dir </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s1">create_archive = </span><span class="s2">True</span>
        <span class="s1">archive_name = </span><span class="s4">&quot;{}-{}.zip&quot;</span><span class="s1">.format(self.name</span><span class="s2">, </span><span class="s1">self.metadata[</span><span class="s4">&quot;version&quot;</span><span class="s1">])</span>
        <span class="s1">archive_path = os.path.join(build_dir</span><span class="s2">, </span><span class="s1">archive_name)</span>

        <span class="s2">if </span><span class="s1">os.path.exists(archive_path):</span>
            <span class="s1">response = ask_path_exists(</span>
                <span class="s4">&quot;The file {} exists. (i)gnore, (w)ipe, &quot;</span>
                <span class="s4">&quot;(b)ackup, (a)bort &quot;</span><span class="s1">.format(display_path(archive_path))</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">&quot;i&quot;</span><span class="s2">, </span><span class="s4">&quot;w&quot;</span><span class="s2">, </span><span class="s4">&quot;b&quot;</span><span class="s2">, </span><span class="s4">&quot;a&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">response == </span><span class="s4">&quot;i&quot;</span><span class="s1">:</span>
                <span class="s1">create_archive = </span><span class="s2">False</span>
            <span class="s2">elif </span><span class="s1">response == </span><span class="s4">&quot;w&quot;</span><span class="s1">:</span>
                <span class="s1">logger.warning(</span><span class="s4">&quot;Deleting %s&quot;</span><span class="s2">, </span><span class="s1">display_path(archive_path))</span>
                <span class="s1">os.remove(archive_path)</span>
            <span class="s2">elif </span><span class="s1">response == </span><span class="s4">&quot;b&quot;</span><span class="s1">:</span>
                <span class="s1">dest_file = backup_dir(archive_path)</span>
                <span class="s1">logger.warning(</span>
                    <span class="s4">&quot;Backing up %s to %s&quot;</span><span class="s2">,</span>
                    <span class="s1">display_path(archive_path)</span><span class="s2">,</span>
                    <span class="s1">display_path(dest_file)</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s1">shutil.move(archive_path</span><span class="s2">, </span><span class="s1">dest_file)</span>
            <span class="s2">elif </span><span class="s1">response == </span><span class="s4">&quot;a&quot;</span><span class="s1">:</span>
                <span class="s1">sys.exit(-</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">create_archive:</span>
            <span class="s2">return</span>

        <span class="s1">zip_output = zipfile.ZipFile(</span>
            <span class="s1">archive_path</span><span class="s2">,</span>
            <span class="s4">&quot;w&quot;</span><span class="s2">,</span>
            <span class="s1">zipfile.ZIP_DEFLATED</span><span class="s2">,</span>
            <span class="s1">allowZip64=</span><span class="s2">True,</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">zip_output:</span>
            <span class="s1">dir = os.path.normcase(os.path.abspath(self.unpacked_source_directory))</span>
            <span class="s2">for </span><span class="s1">dirpath</span><span class="s2">, </span><span class="s1">dirnames</span><span class="s2">, </span><span class="s1">filenames </span><span class="s2">in </span><span class="s1">os.walk(dir):</span>
                <span class="s2">for </span><span class="s1">dirname </span><span class="s2">in </span><span class="s1">dirnames:</span>
                    <span class="s1">dir_arcname = self._get_archive_name(</span>
                        <span class="s1">dirname</span><span class="s2">,</span>
                        <span class="s1">parentdir=dirpath</span><span class="s2">,</span>
                        <span class="s1">rootdir=dir</span><span class="s2">,</span>
                    <span class="s1">)</span>
                    <span class="s1">zipdir = zipfile.ZipInfo(dir_arcname + </span><span class="s4">&quot;/&quot;</span><span class="s1">)</span>
                    <span class="s1">zipdir.external_attr = </span><span class="s5">0x1ED </span><span class="s1">&lt;&lt; </span><span class="s5">16  </span><span class="s0"># 0o755</span>
                    <span class="s1">zip_output.writestr(zipdir</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">filenames:</span>
                    <span class="s1">file_arcname = self._get_archive_name(</span>
                        <span class="s1">filename</span><span class="s2">,</span>
                        <span class="s1">parentdir=dirpath</span><span class="s2">,</span>
                        <span class="s1">rootdir=dir</span><span class="s2">,</span>
                    <span class="s1">)</span>
                    <span class="s1">filename = os.path.join(dirpath</span><span class="s2">, </span><span class="s1">filename)</span>
                    <span class="s1">zip_output.write(filename</span><span class="s2">, </span><span class="s1">file_arcname)</span>

        <span class="s1">logger.info(</span><span class="s4">&quot;Saved %s&quot;</span><span class="s2">, </span><span class="s1">display_path(archive_path))</span>

    <span class="s2">def </span><span class="s1">install(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">install_options: List[str]</span><span class="s2">,</span>
        <span class="s1">global_options: Optional[Sequence[str]] = </span><span class="s2">None,</span>
        <span class="s1">root: Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">home: Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">prefix: Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">warn_script_location: bool = </span><span class="s2">True,</span>
        <span class="s1">use_user_site: bool = </span><span class="s2">False,</span>
        <span class="s1">pycompile: bool = </span><span class="s2">True,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">scheme = get_scheme(</span>
            <span class="s1">self.name</span><span class="s2">,</span>
            <span class="s1">user=use_user_site</span><span class="s2">,</span>
            <span class="s1">home=home</span><span class="s2">,</span>
            <span class="s1">root=root</span><span class="s2">,</span>
            <span class="s1">isolated=self.isolated</span><span class="s2">,</span>
            <span class="s1">prefix=prefix</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">global_options = global_options </span><span class="s2">if </span><span class="s1">global_options </span><span class="s2">is not None else </span><span class="s1">[]</span>
        <span class="s2">if </span><span class="s1">self.editable </span><span class="s2">and not </span><span class="s1">self.is_wheel:</span>
            <span class="s1">install_editable_legacy(</span>
                <span class="s1">install_options</span><span class="s2">,</span>
                <span class="s1">global_options</span><span class="s2">,</span>
                <span class="s1">prefix=prefix</span><span class="s2">,</span>
                <span class="s1">home=home</span><span class="s2">,</span>
                <span class="s1">use_user_site=use_user_site</span><span class="s2">,</span>
                <span class="s1">name=self.name</span><span class="s2">,</span>
                <span class="s1">setup_py_path=self.setup_py_path</span><span class="s2">,</span>
                <span class="s1">isolated=self.isolated</span><span class="s2">,</span>
                <span class="s1">build_env=self.build_env</span><span class="s2">,</span>
                <span class="s1">unpacked_source_directory=self.unpacked_source_directory</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">self.install_succeeded = </span><span class="s2">True</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">self.is_wheel:</span>
            <span class="s2">assert </span><span class="s1">self.local_file_path</span>
            <span class="s1">direct_url = </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">self.editable:</span>
                <span class="s1">direct_url = direct_url_for_editable(self.unpacked_source_directory)</span>
            <span class="s2">elif </span><span class="s1">self.original_link:</span>
                <span class="s1">direct_url = direct_url_from_link(</span>
                    <span class="s1">self.original_link</span><span class="s2">,</span>
                    <span class="s1">self.source_dir</span><span class="s2">,</span>
                    <span class="s1">self.original_link_is_in_wheel_cache</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">install_wheel(</span>
                <span class="s1">self.name</span><span class="s2">,</span>
                <span class="s1">self.local_file_path</span><span class="s2">,</span>
                <span class="s1">scheme=scheme</span><span class="s2">,</span>
                <span class="s1">req_description=str(self.req)</span><span class="s2">,</span>
                <span class="s1">pycompile=pycompile</span><span class="s2">,</span>
                <span class="s1">warn_script_location=warn_script_location</span><span class="s2">,</span>
                <span class="s1">direct_url=direct_url</span><span class="s2">,</span>
                <span class="s1">requested=self.user_supplied</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">self.install_succeeded = </span><span class="s2">True</span>
            <span class="s2">return</span>

        <span class="s0"># TODO: Why don't we do this for editable installs?</span>

        <span class="s0"># Extend the list of global and install options passed on to</span>
        <span class="s0"># the setup.py call with the ones from the requirements file.</span>
        <span class="s0"># Options specified in requirements file override those</span>
        <span class="s0"># specified on the command line, since the last option given</span>
        <span class="s0"># to setup.py is the one that is used.</span>
        <span class="s1">global_options = list(global_options) + self.global_options</span>
        <span class="s1">install_options = list(install_options) + self.install_options</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">success = install_legacy(</span>
                <span class="s1">install_options=install_options</span><span class="s2">,</span>
                <span class="s1">global_options=global_options</span><span class="s2">,</span>
                <span class="s1">root=root</span><span class="s2">,</span>
                <span class="s1">home=home</span><span class="s2">,</span>
                <span class="s1">prefix=prefix</span><span class="s2">,</span>
                <span class="s1">use_user_site=use_user_site</span><span class="s2">,</span>
                <span class="s1">pycompile=pycompile</span><span class="s2">,</span>
                <span class="s1">scheme=scheme</span><span class="s2">,</span>
                <span class="s1">setup_py_path=self.setup_py_path</span><span class="s2">,</span>
                <span class="s1">isolated=self.isolated</span><span class="s2">,</span>
                <span class="s1">req_name=self.name</span><span class="s2">,</span>
                <span class="s1">build_env=self.build_env</span><span class="s2">,</span>
                <span class="s1">unpacked_source_directory=self.unpacked_source_directory</span><span class="s2">,</span>
                <span class="s1">req_description=str(self.req)</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">except </span><span class="s1">LegacyInstallFailure </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s1">self.install_succeeded = </span><span class="s2">False</span>
            <span class="s2">raise </span><span class="s1">exc</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s1">self.install_succeeded = </span><span class="s2">True</span>
            <span class="s2">raise</span>

        <span class="s1">self.install_succeeded = success</span>

        <span class="s2">if </span><span class="s1">success </span><span class="s2">and </span><span class="s1">self.legacy_install_reason == </span><span class="s5">8368</span><span class="s1">:</span>
            <span class="s1">deprecated(</span>
                <span class="s1">reason=(</span>
                    <span class="s4">&quot;{} was installed using the legacy 'setup.py install' &quot;</span>
                    <span class="s4">&quot;method, because a wheel could not be built for it.&quot;</span><span class="s1">.format(</span>
                        <span class="s1">self.name</span>
                    <span class="s1">)</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">replacement=</span><span class="s4">&quot;to fix the wheel build issue reported above&quot;</span><span class="s2">,</span>
                <span class="s1">gone_in=</span><span class="s2">None,</span>
                <span class="s1">issue=</span><span class="s5">8368</span><span class="s2">,</span>
            <span class="s1">)</span>


<span class="s2">def </span><span class="s1">check_invalid_constraint_type(req: InstallRequirement) -&gt; str:</span>

    <span class="s0"># Check for unsupported forms</span>
    <span class="s1">problem = </span><span class="s4">&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">req.name:</span>
        <span class="s1">problem = </span><span class="s4">&quot;Unnamed requirements are not allowed as constraints&quot;</span>
    <span class="s2">elif </span><span class="s1">req.editable:</span>
        <span class="s1">problem = </span><span class="s4">&quot;Editable requirements are not allowed as constraints&quot;</span>
    <span class="s2">elif </span><span class="s1">req.extras:</span>
        <span class="s1">problem = </span><span class="s4">&quot;Constraints cannot have extras&quot;</span>

    <span class="s2">if </span><span class="s1">problem:</span>
        <span class="s1">deprecated(</span>
            <span class="s1">reason=(</span>
                <span class="s4">&quot;Constraints are only allowed to take the form of a package &quot;</span>
                <span class="s4">&quot;name and a version specifier. Other forms were originally &quot;</span>
                <span class="s4">&quot;permitted as an accident of the implementation, but were &quot;</span>
                <span class="s4">&quot;undocumented. The new implementation of the resolver no &quot;</span>
                <span class="s4">&quot;longer supports these forms.&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">replacement=</span><span class="s4">&quot;replacing the constraint with a requirement&quot;</span><span class="s2">,</span>
            <span class="s0"># No plan yet for when the new resolver becomes default</span>
            <span class="s1">gone_in=</span><span class="s2">None,</span>
            <span class="s1">issue=</span><span class="s5">8210</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">problem</span>
</pre>
</body>
</html>