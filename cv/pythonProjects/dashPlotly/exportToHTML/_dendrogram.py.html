<html>
<head>
<title>_dendrogram.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_dendrogram.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">absolute_import</span>

<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">OrderedDict</span>

<span class="s2">from </span><span class="s1">plotly </span><span class="s2">import </span><span class="s1">exceptions</span><span class="s2">, </span><span class="s1">optional_imports</span>
<span class="s2">from </span><span class="s1">plotly.graph_objs </span><span class="s2">import </span><span class="s1">graph_objs</span>

<span class="s0"># Optional imports, may be None for users that only use our core functionality.</span>
<span class="s1">np = optional_imports.get_module(</span><span class="s3">&quot;numpy&quot;</span><span class="s1">)</span>
<span class="s1">scp = optional_imports.get_module(</span><span class="s3">&quot;scipy&quot;</span><span class="s1">)</span>
<span class="s1">sch = optional_imports.get_module(</span><span class="s3">&quot;scipy.cluster.hierarchy&quot;</span><span class="s1">)</span>
<span class="s1">scs = optional_imports.get_module(</span><span class="s3">&quot;scipy.spatial&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">create_dendrogram(</span>
    <span class="s1">X</span><span class="s2">,</span>
    <span class="s1">orientation=</span><span class="s3">&quot;bottom&quot;</span><span class="s2">,</span>
    <span class="s1">labels=</span><span class="s2">None,</span>
    <span class="s1">colorscale=</span><span class="s2">None,</span>
    <span class="s1">distfun=</span><span class="s2">None,</span>
    <span class="s1">linkagefun=</span><span class="s2">lambda </span><span class="s1">x: sch.linkage(x</span><span class="s2">, </span><span class="s3">&quot;complete&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">hovertext=</span><span class="s2">None,</span>
    <span class="s1">color_threshold=</span><span class="s2">None,</span>
<span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Function that returns a dendrogram Plotly figure object. This is a thin 
    wrapper around scipy.cluster.hierarchy.dendrogram. 
 
    See also https://dash.plot.ly/dash-bio/clustergram. 
 
    :param (ndarray) X: Matrix of observations as array of arrays 
    :param (str) orientation: 'top', 'right', 'bottom', or 'left' 
    :param (list) labels: List of axis category labels(observation labels) 
    :param (list) colorscale: Optional colorscale for the dendrogram tree. 
                              Requires 8 colors to be specified, the 7th of 
                              which is ignored.  With scipy&gt;=1.5.0, the 2nd, 3rd 
                              and 6th are used twice as often as the others. 
                              Given a shorter list, the missing values are 
                              replaced with defaults and with a longer list the 
                              extra values are ignored. 
    :param (function) distfun: Function to compute the pairwise distance from 
                               the observations 
    :param (function) linkagefun: Function to compute the linkage matrix from 
                               the pairwise distances 
    :param (list[list]) hovertext: List of hovertext for constituent traces of dendrogram 
                               clusters 
    :param (double) color_threshold: Value at which the separation of clusters will be made 
 
    Example 1: Simple bottom oriented dendrogram 
 
    &gt;&gt;&gt; from plotly.figure_factory import create_dendrogram 
 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; X = np.random.rand(10,10) 
    &gt;&gt;&gt; fig = create_dendrogram(X) 
    &gt;&gt;&gt; fig.show() 
 
    Example 2: Dendrogram to put on the left of the heatmap 
     
    &gt;&gt;&gt; from plotly.figure_factory import create_dendrogram 
 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; X = np.random.rand(5,5) 
    &gt;&gt;&gt; names = ['Jack', 'Oxana', 'John', 'Chelsea', 'Mark'] 
    &gt;&gt;&gt; dendro = create_dendrogram(X, orientation='right', labels=names) 
    &gt;&gt;&gt; dendro.update_layout({'width':700, 'height':500}) # doctest: +SKIP 
    &gt;&gt;&gt; dendro.show() 
 
    Example 3: Dendrogram with Pandas 
     
    &gt;&gt;&gt; from plotly.figure_factory import create_dendrogram 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import pandas as pd 
 
    &gt;&gt;&gt; Index= ['A','B','C','D','E','F','G','H','I','J'] 
    &gt;&gt;&gt; df = pd.DataFrame(abs(np.random.randn(10, 10)), index=Index) 
    &gt;&gt;&gt; fig = create_dendrogram(df, labels=Index) 
    &gt;&gt;&gt; fig.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">scp </span><span class="s2">or not </span><span class="s1">scs </span><span class="s2">or not </span><span class="s1">sch:</span>
        <span class="s2">raise </span><span class="s1">ImportError(</span>
            <span class="s3">&quot;FigureFactory.create_dendrogram requires scipy, </span><span class="s2">\ 
                            </span><span class="s3">scipy.spatial and scipy.hierarchy&quot;</span>
        <span class="s1">)</span>

    <span class="s1">s = X.shape</span>
    <span class="s2">if </span><span class="s1">len(s) != </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s1">exceptions.PlotlyError(</span><span class="s3">&quot;X should be 2-dimensional array.&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">distfun </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">distfun = scs.distance.pdist</span>

    <span class="s1">dendrogram = _Dendrogram(</span>
        <span class="s1">X</span><span class="s2">,</span>
        <span class="s1">orientation</span><span class="s2">,</span>
        <span class="s1">labels</span><span class="s2">,</span>
        <span class="s1">colorscale</span><span class="s2">,</span>
        <span class="s1">distfun=distfun</span><span class="s2">,</span>
        <span class="s1">linkagefun=linkagefun</span><span class="s2">,</span>
        <span class="s1">hovertext=hovertext</span><span class="s2">,</span>
        <span class="s1">color_threshold=color_threshold</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">graph_objs.Figure(data=dendrogram.data</span><span class="s2">, </span><span class="s1">layout=dendrogram.layout)</span>


<span class="s2">class </span><span class="s1">_Dendrogram(object):</span>
    <span class="s4">&quot;&quot;&quot;Refer to FigureFactory.create_dendrogram() for docstring.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">X</span><span class="s2">,</span>
        <span class="s1">orientation=</span><span class="s3">&quot;bottom&quot;</span><span class="s2">,</span>
        <span class="s1">labels=</span><span class="s2">None,</span>
        <span class="s1">colorscale=</span><span class="s2">None,</span>
        <span class="s1">width=np.inf</span><span class="s2">,</span>
        <span class="s1">height=np.inf</span><span class="s2">,</span>
        <span class="s1">xaxis=</span><span class="s3">&quot;xaxis&quot;</span><span class="s2">,</span>
        <span class="s1">yaxis=</span><span class="s3">&quot;yaxis&quot;</span><span class="s2">,</span>
        <span class="s1">distfun=</span><span class="s2">None,</span>
        <span class="s1">linkagefun=</span><span class="s2">lambda </span><span class="s1">x: sch.linkage(x</span><span class="s2">, </span><span class="s3">&quot;complete&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">hovertext=</span><span class="s2">None,</span>
        <span class="s1">color_threshold=</span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">self.orientation = orientation</span>
        <span class="s1">self.labels = labels</span>
        <span class="s1">self.xaxis = xaxis</span>
        <span class="s1">self.yaxis = yaxis</span>
        <span class="s1">self.data = []</span>
        <span class="s1">self.leaves = []</span>
        <span class="s1">self.sign = {self.xaxis: </span><span class="s5">1</span><span class="s2">, </span><span class="s1">self.yaxis: </span><span class="s5">1</span><span class="s1">}</span>
        <span class="s1">self.layout = {self.xaxis: {}</span><span class="s2">, </span><span class="s1">self.yaxis: {}}</span>

        <span class="s2">if </span><span class="s1">self.orientation </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;left&quot;</span><span class="s2">, </span><span class="s3">&quot;bottom&quot;</span><span class="s1">]:</span>
            <span class="s1">self.sign[self.xaxis] = </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.sign[self.xaxis] = -</span><span class="s5">1</span>

        <span class="s2">if </span><span class="s1">self.orientation </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;right&quot;</span><span class="s2">, </span><span class="s3">&quot;bottom&quot;</span><span class="s1">]:</span>
            <span class="s1">self.sign[self.yaxis] = </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.sign[self.yaxis] = -</span><span class="s5">1</span>

        <span class="s2">if </span><span class="s1">distfun </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">distfun = scs.distance.pdist</span>

        <span class="s1">(dd_traces</span><span class="s2">, </span><span class="s1">xvals</span><span class="s2">, </span><span class="s1">yvals</span><span class="s2">, </span><span class="s1">ordered_labels</span><span class="s2">, </span><span class="s1">leaves) = self.get_dendrogram_traces(</span>
            <span class="s1">X</span><span class="s2">, </span><span class="s1">colorscale</span><span class="s2">, </span><span class="s1">distfun</span><span class="s2">, </span><span class="s1">linkagefun</span><span class="s2">, </span><span class="s1">hovertext</span><span class="s2">, </span><span class="s1">color_threshold</span>
        <span class="s1">)</span>

        <span class="s1">self.labels = ordered_labels</span>
        <span class="s1">self.leaves = leaves</span>
        <span class="s1">yvals_flat = yvals.flatten()</span>
        <span class="s1">xvals_flat = xvals.flatten()</span>

        <span class="s1">self.zero_vals = []</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(yvals_flat)):</span>
            <span class="s2">if </span><span class="s1">yvals_flat[i] == </span><span class="s5">0.0 </span><span class="s2">and </span><span class="s1">xvals_flat[i] </span><span class="s2">not in </span><span class="s1">self.zero_vals:</span>
                <span class="s1">self.zero_vals.append(xvals_flat[i])</span>

        <span class="s2">if </span><span class="s1">len(self.zero_vals) &gt; len(yvals) + </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0"># If the length of zero_vals is larger than the length of yvals,</span>
            <span class="s0"># it means that there are wrong vals because of the identicial samples.</span>
            <span class="s0"># Three and more identicial samples will make the yvals of spliting</span>
            <span class="s0"># center into 0 and it will accidentally take it as leaves.</span>
            <span class="s1">l_border = int(min(self.zero_vals))</span>
            <span class="s1">r_border = int(max(self.zero_vals))</span>
            <span class="s1">correct_leaves_pos = range(</span>
                <span class="s1">l_border</span><span class="s2">, </span><span class="s1">r_border + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">int((r_border - l_border) / len(yvals))</span>
            <span class="s1">)</span>
            <span class="s0"># Regenerating the leaves pos from the self.zero_vals with equally intervals.</span>
            <span class="s1">self.zero_vals = [v </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">correct_leaves_pos]</span>

        <span class="s1">self.zero_vals.sort()</span>
        <span class="s1">self.layout = self.set_figure_layout(width</span><span class="s2">, </span><span class="s1">height)</span>
        <span class="s1">self.data = dd_traces</span>

    <span class="s2">def </span><span class="s1">get_color_dict(self</span><span class="s2">, </span><span class="s1">colorscale):</span>
        <span class="s4">&quot;&quot;&quot; 
        Returns colorscale used for dendrogram tree clusters. 
 
        :param (list) colorscale: Colors to use for the plot in rgb format. 
        :rtype (dict): A dict of default colors mapped to the user colorscale. 
 
        &quot;&quot;&quot;</span>

        <span class="s0"># These are the color codes returned for dendrograms</span>
        <span class="s0"># We're replacing them with nicer colors</span>
        <span class="s0"># This list is the colors that can be used by dendrogram, which were</span>
        <span class="s0"># determined as the combination of the default above_threshold_color and</span>
        <span class="s0"># the default color palette (see scipy/cluster/hierarchy.py)</span>
        <span class="s1">d = {</span>
            <span class="s3">&quot;r&quot;</span><span class="s1">: </span><span class="s3">&quot;red&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;g&quot;</span><span class="s1">: </span><span class="s3">&quot;green&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;b&quot;</span><span class="s1">: </span><span class="s3">&quot;blue&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;c&quot;</span><span class="s1">: </span><span class="s3">&quot;cyan&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;m&quot;</span><span class="s1">: </span><span class="s3">&quot;magenta&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;y&quot;</span><span class="s1">: </span><span class="s3">&quot;yellow&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;k&quot;</span><span class="s1">: </span><span class="s3">&quot;black&quot;</span><span class="s2">,</span>
            <span class="s0"># TODO: 'w' doesn't seem to be in the default color</span>
            <span class="s0"># palette in scipy/cluster/hierarchy.py</span>
            <span class="s3">&quot;w&quot;</span><span class="s1">: </span><span class="s3">&quot;white&quot;</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s1">default_colors = OrderedDict(sorted(d.items()</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">t: t[</span><span class="s5">0</span><span class="s1">]))</span>

        <span class="s2">if </span><span class="s1">colorscale </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">rgb_colorscale = [</span>
                <span class="s3">&quot;rgb(0,116,217)&quot;</span><span class="s2">,  </span><span class="s0"># blue</span>
                <span class="s3">&quot;rgb(35,205,205)&quot;</span><span class="s2">,  </span><span class="s0"># cyan</span>
                <span class="s3">&quot;rgb(61,153,112)&quot;</span><span class="s2">,  </span><span class="s0"># green</span>
                <span class="s3">&quot;rgb(40,35,35)&quot;</span><span class="s2">,  </span><span class="s0"># black</span>
                <span class="s3">&quot;rgb(133,20,75)&quot;</span><span class="s2">,  </span><span class="s0"># magenta</span>
                <span class="s3">&quot;rgb(255,65,54)&quot;</span><span class="s2">,  </span><span class="s0"># red</span>
                <span class="s3">&quot;rgb(255,255,255)&quot;</span><span class="s2">,  </span><span class="s0"># white</span>
                <span class="s3">&quot;rgb(255,220,0)&quot;</span><span class="s2">,  </span><span class="s0"># yellow</span>
            <span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rgb_colorscale = colorscale</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(default_colors.keys())):</span>
            <span class="s1">k = list(default_colors.keys())[i]  </span><span class="s0"># PY3 won't index keys</span>
            <span class="s2">if </span><span class="s1">i &lt; len(rgb_colorscale):</span>
                <span class="s1">default_colors[k] = rgb_colorscale[i]</span>

        <span class="s0"># add support for cyclic format colors as introduced in scipy===1.5.0</span>
        <span class="s0"># before this, the colors were named 'r', 'b', 'y' etc., now they are</span>
        <span class="s0"># named 'C0', 'C1', etc. To keep the colors consistent regardless of the</span>
        <span class="s0"># scipy version, we try as much as possible to map the new colors to the</span>
        <span class="s0"># old colors</span>
        <span class="s0"># this mapping was found by inpecting scipy/cluster/hierarchy.py (see</span>
        <span class="s0"># comment above).</span>
        <span class="s1">new_old_color_map = [</span>
            <span class="s1">(</span><span class="s3">&quot;C0&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;C1&quot;</span><span class="s2">, </span><span class="s3">&quot;g&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;C2&quot;</span><span class="s2">, </span><span class="s3">&quot;r&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;C3&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;C4&quot;</span><span class="s2">, </span><span class="s3">&quot;m&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;C5&quot;</span><span class="s2">, </span><span class="s3">&quot;y&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;C6&quot;</span><span class="s2">, </span><span class="s3">&quot;k&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;C7&quot;</span><span class="s2">, </span><span class="s3">&quot;g&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;C8&quot;</span><span class="s2">, </span><span class="s3">&quot;r&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;C9&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s2">for </span><span class="s1">nc</span><span class="s2">, </span><span class="s1">oc </span><span class="s2">in </span><span class="s1">new_old_color_map:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">default_colors[nc] = default_colors[oc]</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s0"># it could happen that the old color isn't found (if a custom</span>
                <span class="s0"># colorscale was specified), in this case we set it to an</span>
                <span class="s0"># arbitrary default.</span>
                <span class="s1">default_colors[n] = </span><span class="s3">&quot;rgb(0,116,217)&quot;</span>

        <span class="s2">return </span><span class="s1">default_colors</span>

    <span class="s2">def </span><span class="s1">set_axis_layout(self</span><span class="s2">, </span><span class="s1">axis_key):</span>
        <span class="s4">&quot;&quot;&quot; 
        Sets and returns default axis object for dendrogram figure. 
 
        :param (str) axis_key: E.g., 'xaxis', 'xaxis1', 'yaxis', yaxis1', etc. 
        :rtype (dict): An axis_key dictionary with set parameters. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">axis_defaults = {</span>
            <span class="s3">&quot;type&quot;</span><span class="s1">: </span><span class="s3">&quot;linear&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;ticks&quot;</span><span class="s1">: </span><span class="s3">&quot;outside&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;mirror&quot;</span><span class="s1">: </span><span class="s3">&quot;allticks&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;rangemode&quot;</span><span class="s1">: </span><span class="s3">&quot;tozero&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;showticklabels&quot;</span><span class="s1">: </span><span class="s2">True,</span>
            <span class="s3">&quot;zeroline&quot;</span><span class="s1">: </span><span class="s2">False,</span>
            <span class="s3">&quot;showgrid&quot;</span><span class="s1">: </span><span class="s2">False,</span>
            <span class="s3">&quot;showline&quot;</span><span class="s1">: </span><span class="s2">True,</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">len(self.labels) != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">axis_key_labels = self.xaxis</span>
            <span class="s2">if </span><span class="s1">self.orientation </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;left&quot;</span><span class="s2">, </span><span class="s3">&quot;right&quot;</span><span class="s1">]:</span>
                <span class="s1">axis_key_labels = self.yaxis</span>
            <span class="s2">if </span><span class="s1">axis_key_labels </span><span class="s2">not in </span><span class="s1">self.layout:</span>
                <span class="s1">self.layout[axis_key_labels] = {}</span>
            <span class="s1">self.layout[axis_key_labels][</span><span class="s3">&quot;tickvals&quot;</span><span class="s1">] = [</span>
                <span class="s1">zv * self.sign[axis_key] </span><span class="s2">for </span><span class="s1">zv </span><span class="s2">in </span><span class="s1">self.zero_vals</span>
            <span class="s1">]</span>
            <span class="s1">self.layout[axis_key_labels][</span><span class="s3">&quot;ticktext&quot;</span><span class="s1">] = self.labels</span>
            <span class="s1">self.layout[axis_key_labels][</span><span class="s3">&quot;tickmode&quot;</span><span class="s1">] = </span><span class="s3">&quot;array&quot;</span>

        <span class="s1">self.layout[axis_key].update(axis_defaults)</span>

        <span class="s2">return </span><span class="s1">self.layout[axis_key]</span>

    <span class="s2">def </span><span class="s1">set_figure_layout(self</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height):</span>
        <span class="s4">&quot;&quot;&quot; 
        Sets and returns default layout object for dendrogram figure. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.layout.update(</span>
            <span class="s1">{</span>
                <span class="s3">&quot;showlegend&quot;</span><span class="s1">: </span><span class="s2">False,</span>
                <span class="s3">&quot;autosize&quot;</span><span class="s1">: </span><span class="s2">False,</span>
                <span class="s3">&quot;hovermode&quot;</span><span class="s1">: </span><span class="s3">&quot;closest&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;width&quot;</span><span class="s1">: width</span><span class="s2">,</span>
                <span class="s3">&quot;height&quot;</span><span class="s1">: height</span><span class="s2">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

        <span class="s1">self.set_axis_layout(self.xaxis)</span>
        <span class="s1">self.set_axis_layout(self.yaxis)</span>

        <span class="s2">return </span><span class="s1">self.layout</span>

    <span class="s2">def </span><span class="s1">get_dendrogram_traces(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">colorscale</span><span class="s2">, </span><span class="s1">distfun</span><span class="s2">, </span><span class="s1">linkagefun</span><span class="s2">, </span><span class="s1">hovertext</span><span class="s2">, </span><span class="s1">color_threshold</span>
    <span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Calculates all the elements needed for plotting a dendrogram. 
 
        :param (ndarray) X: Matrix of observations as array of arrays 
        :param (list) colorscale: Color scale for dendrogram tree clusters 
        :param (function) distfun: Function to compute the pairwise distance 
                                   from the observations 
        :param (function) linkagefun: Function to compute the linkage matrix 
                                      from the pairwise distances 
        :param (list) hovertext: List of hovertext for constituent traces of dendrogram 
        :rtype (tuple): Contains all the traces in the following order: 
            (a) trace_list: List of Plotly trace objects for dendrogram tree 
            (b) icoord: All X points of the dendrogram tree as array of arrays 
                with length 4 
            (c) dcoord: All Y points of the dendrogram tree as array of arrays 
                with length 4 
            (d) ordered_labels: leaf labels in the order they are going to 
                appear on the plot 
            (e) P['leaves']: left-to-right traversal of the leaves 
 
        &quot;&quot;&quot;</span>
        <span class="s1">d = distfun(X)</span>
        <span class="s1">Z = linkagefun(d)</span>
        <span class="s1">P = sch.dendrogram(</span>
            <span class="s1">Z</span><span class="s2">,</span>
            <span class="s1">orientation=self.orientation</span><span class="s2">,</span>
            <span class="s1">labels=self.labels</span><span class="s2">,</span>
            <span class="s1">no_plot=</span><span class="s2">True,</span>
            <span class="s1">color_threshold=color_threshold</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">icoord = scp.array(P[</span><span class="s3">&quot;icoord&quot;</span><span class="s1">])</span>
        <span class="s1">dcoord = scp.array(P[</span><span class="s3">&quot;dcoord&quot;</span><span class="s1">])</span>
        <span class="s1">ordered_labels = scp.array(P[</span><span class="s3">&quot;ivl&quot;</span><span class="s1">])</span>
        <span class="s1">color_list = scp.array(P[</span><span class="s3">&quot;color_list&quot;</span><span class="s1">])</span>
        <span class="s1">colors = self.get_color_dict(colorscale)</span>

        <span class="s1">trace_list = []</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(icoord)):</span>
            <span class="s0"># xs and ys are arrays of 4 points that make up the '∩' shapes</span>
            <span class="s0"># of the dendrogram tree</span>
            <span class="s2">if </span><span class="s1">self.orientation </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;top&quot;</span><span class="s2">, </span><span class="s3">&quot;bottom&quot;</span><span class="s1">]:</span>
                <span class="s1">xs = icoord[i]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">xs = dcoord[i]</span>

            <span class="s2">if </span><span class="s1">self.orientation </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;top&quot;</span><span class="s2">, </span><span class="s3">&quot;bottom&quot;</span><span class="s1">]:</span>
                <span class="s1">ys = dcoord[i]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">ys = icoord[i]</span>
            <span class="s1">color_key = color_list[i]</span>
            <span class="s1">hovertext_label = </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">hovertext:</span>
                <span class="s1">hovertext_label = hovertext[i]</span>
            <span class="s1">trace = dict(</span>
                <span class="s1">type=</span><span class="s3">&quot;scatter&quot;</span><span class="s2">,</span>
                <span class="s1">x=np.multiply(self.sign[self.xaxis]</span><span class="s2">, </span><span class="s1">xs)</span><span class="s2">,</span>
                <span class="s1">y=np.multiply(self.sign[self.yaxis]</span><span class="s2">, </span><span class="s1">ys)</span><span class="s2">,</span>
                <span class="s1">mode=</span><span class="s3">&quot;lines&quot;</span><span class="s2">,</span>
                <span class="s1">marker=dict(color=colors[color_key])</span><span class="s2">,</span>
                <span class="s1">text=hovertext_label</span><span class="s2">,</span>
                <span class="s1">hoverinfo=</span><span class="s3">&quot;text&quot;</span><span class="s2">,</span>
            <span class="s1">)</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">x_index = int(self.xaxis[-</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s1">x_index = </span><span class="s3">&quot;&quot;</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">y_index = int(self.yaxis[-</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s1">y_index = </span><span class="s3">&quot;&quot;</span>

            <span class="s1">trace[</span><span class="s3">&quot;xaxis&quot;</span><span class="s1">] = </span><span class="s3">&quot;x&quot; </span><span class="s1">+ x_index</span>
            <span class="s1">trace[</span><span class="s3">&quot;yaxis&quot;</span><span class="s1">] = </span><span class="s3">&quot;y&quot; </span><span class="s1">+ y_index</span>

            <span class="s1">trace_list.append(trace)</span>

        <span class="s2">return </span><span class="s1">trace_list</span><span class="s2">, </span><span class="s1">icoord</span><span class="s2">, </span><span class="s1">dcoord</span><span class="s2">, </span><span class="s1">ordered_labels</span><span class="s2">, </span><span class="s1">P[</span><span class="s3">&quot;leaves&quot;</span><span class="s1">]</span>
</pre>
</body>
</html>