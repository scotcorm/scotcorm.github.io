<html>
<head>
<title>lib.pyi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
lib.pyi</font>
</center></td></tr></table>
<pre><span class="s0"># TODO(npdtypes): Many types specified here can be made more specific/accurate;</span>
<span class="s0">#  the more specific versions are specified in comments</span>

<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">Generator</span><span class="s2">,</span>
    <span class="s1">Hashable</span><span class="s2">,</span>
    <span class="s1">Literal</span><span class="s2">,</span>
    <span class="s1">overload</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">pandas._typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ArrayLike</span><span class="s2">,</span>
    <span class="s1">DtypeObj</span><span class="s2">,</span>
    <span class="s1">npt</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s0"># placeholder until we can specify np.ndarray[object, ndim=2]</span>
<span class="s1">ndarray_obj_2d = np.ndarray</span>

<span class="s2">from </span><span class="s1">enum </span><span class="s2">import </span><span class="s1">Enum</span>

<span class="s2">class </span><span class="s1">NoDefault(Enum): ...</span>

<span class="s1">no_default: NoDefault</span>

<span class="s1">i8max: int</span>
<span class="s1">u8max: int</span>

<span class="s2">def </span><span class="s1">item_from_zerodim(val: object) -&gt; object: ...</span>
<span class="s2">def </span><span class="s1">infer_dtype(value: object</span><span class="s2">, </span><span class="s1">skipna: bool = ...) -&gt; str: ...</span>
<span class="s2">def </span><span class="s1">is_iterator(obj: object) -&gt; bool: ...</span>
<span class="s2">def </span><span class="s1">is_scalar(val: object) -&gt; bool: ...</span>
<span class="s2">def </span><span class="s1">is_list_like(obj: object</span><span class="s2">, </span><span class="s1">allow_sets: bool = ...) -&gt; bool: ...</span>
<span class="s2">def </span><span class="s1">is_period(val: object) -&gt; bool: ...</span>
<span class="s2">def </span><span class="s1">is_interval(val: object) -&gt; bool: ...</span>
<span class="s2">def </span><span class="s1">is_decimal(val: object) -&gt; bool: ...</span>
<span class="s2">def </span><span class="s1">is_complex(val: object) -&gt; bool: ...</span>
<span class="s2">def </span><span class="s1">is_bool(val: object) -&gt; bool: ...</span>
<span class="s2">def </span><span class="s1">is_integer(val: object) -&gt; bool: ...</span>
<span class="s2">def </span><span class="s1">is_float(val: object) -&gt; bool: ...</span>
<span class="s2">def </span><span class="s1">is_interval_array(values: np.ndarray) -&gt; bool: ...</span>
<span class="s2">def </span><span class="s1">is_datetime64_array(values: np.ndarray) -&gt; bool: ...</span>
<span class="s2">def </span><span class="s1">is_timedelta_or_timedelta64_array(values: np.ndarray) -&gt; bool: ...</span>
<span class="s2">def </span><span class="s1">is_datetime_with_singletz_array(values: np.ndarray) -&gt; bool: ...</span>
<span class="s2">def </span><span class="s1">is_time_array(values: np.ndarray</span><span class="s2">, </span><span class="s1">skipna: bool = ...): ...</span>
<span class="s2">def </span><span class="s1">is_date_array(values: np.ndarray</span><span class="s2">, </span><span class="s1">skipna: bool = ...): ...</span>
<span class="s2">def </span><span class="s1">is_datetime_array(values: np.ndarray</span><span class="s2">, </span><span class="s1">skipna: bool = ...): ...</span>
<span class="s2">def </span><span class="s1">is_string_array(values: np.ndarray</span><span class="s2">, </span><span class="s1">skipna: bool = ...): ...</span>
<span class="s2">def </span><span class="s1">is_float_array(values: np.ndarray</span><span class="s2">, </span><span class="s1">skipna: bool = ...): ...</span>
<span class="s2">def </span><span class="s1">is_integer_array(values: np.ndarray</span><span class="s2">, </span><span class="s1">skipna: bool = ...): ...</span>
<span class="s2">def </span><span class="s1">is_bool_array(values: np.ndarray</span><span class="s2">, </span><span class="s1">skipna: bool = ...): ...</span>
<span class="s2">def </span><span class="s1">fast_multiget(mapping: dict</span><span class="s2">, </span><span class="s1">keys: np.ndarray</span><span class="s2">, </span><span class="s1">default=...) -&gt; np.ndarray: ...</span>
<span class="s2">def </span><span class="s1">fast_unique_multiple_list_gen(gen: Generator</span><span class="s2">, </span><span class="s1">sort: bool = ...) -&gt; list: ...</span>
<span class="s2">def </span><span class="s1">fast_unique_multiple_list(lists: list</span><span class="s2">, </span><span class="s1">sort: bool | </span><span class="s2">None </span><span class="s1">= ...) -&gt; list: ...</span>
<span class="s2">def </span><span class="s1">fast_unique_multiple(arrays: list</span><span class="s2">, </span><span class="s1">sort: bool = ...) -&gt; list: ...</span>
<span class="s2">def </span><span class="s1">map_infer(</span>
    <span class="s1">arr: np.ndarray</span><span class="s2">,</span>
    <span class="s1">f: Callable[[Any]</span><span class="s2">, </span><span class="s1">Any]</span><span class="s2">,</span>
    <span class="s1">convert: bool = ...</span><span class="s2">,</span>
    <span class="s1">ignore_na: bool = ...</span><span class="s2">,</span>
<span class="s1">) -&gt; np.ndarray: ...</span>
<span class="s1">@overload  </span><span class="s0"># both convert_datetime and convert_to_nullable_integer False -&gt; np.ndarray</span>
<span class="s2">def </span><span class="s1">maybe_convert_objects(</span>
    <span class="s1">objects: npt.NDArray[np.object_]</span><span class="s2">,</span>
    <span class="s1">*</span><span class="s2">,</span>
    <span class="s1">try_float: bool = ...</span><span class="s2">,</span>
    <span class="s1">safe: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_datetime: Literal[</span><span class="s2">False</span><span class="s1">] = ...</span><span class="s2">,</span>
    <span class="s1">convert_timedelta: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_period: Literal[</span><span class="s2">False</span><span class="s1">] = ...</span><span class="s2">,</span>
    <span class="s1">convert_interval: Literal[</span><span class="s2">False</span><span class="s1">] = ...</span><span class="s2">,</span>
    <span class="s1">convert_to_nullable_integer: Literal[</span><span class="s2">False</span><span class="s1">] = ...</span><span class="s2">,</span>
    <span class="s1">dtype_if_all_nat: DtypeObj | </span><span class="s2">None </span><span class="s1">= ...</span><span class="s2">,</span>
<span class="s1">) -&gt; np.ndarray: ...</span>
<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">maybe_convert_objects(</span>
    <span class="s1">objects: npt.NDArray[np.object_]</span><span class="s2">,</span>
    <span class="s1">*</span><span class="s2">,</span>
    <span class="s1">try_float: bool = ...</span><span class="s2">,</span>
    <span class="s1">safe: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_datetime: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_timedelta: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_period: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_interval: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_to_nullable_integer: Literal[</span><span class="s2">True</span><span class="s1">] = ...</span><span class="s2">,</span>
    <span class="s1">dtype_if_all_nat: DtypeObj | </span><span class="s2">None </span><span class="s1">= ...</span><span class="s2">,</span>
<span class="s1">) -&gt; ArrayLike: ...</span>
<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">maybe_convert_objects(</span>
    <span class="s1">objects: npt.NDArray[np.object_]</span><span class="s2">,</span>
    <span class="s1">*</span><span class="s2">,</span>
    <span class="s1">try_float: bool = ...</span><span class="s2">,</span>
    <span class="s1">safe: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_datetime: Literal[</span><span class="s2">True</span><span class="s1">] = ...</span><span class="s2">,</span>
    <span class="s1">convert_timedelta: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_period: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_interval: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_to_nullable_integer: bool = ...</span><span class="s2">,</span>
    <span class="s1">dtype_if_all_nat: DtypeObj | </span><span class="s2">None </span><span class="s1">= ...</span><span class="s2">,</span>
<span class="s1">) -&gt; ArrayLike: ...</span>
<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">maybe_convert_objects(</span>
    <span class="s1">objects: npt.NDArray[np.object_]</span><span class="s2">,</span>
    <span class="s1">*</span><span class="s2">,</span>
    <span class="s1">try_float: bool = ...</span><span class="s2">,</span>
    <span class="s1">safe: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_datetime: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_timedelta: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_period: Literal[</span><span class="s2">True</span><span class="s1">] = ...</span><span class="s2">,</span>
    <span class="s1">convert_interval: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_to_nullable_integer: bool = ...</span><span class="s2">,</span>
    <span class="s1">dtype_if_all_nat: DtypeObj | </span><span class="s2">None </span><span class="s1">= ...</span><span class="s2">,</span>
<span class="s1">) -&gt; ArrayLike: ...</span>
<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">maybe_convert_objects(</span>
    <span class="s1">objects: npt.NDArray[np.object_]</span><span class="s2">,</span>
    <span class="s1">*</span><span class="s2">,</span>
    <span class="s1">try_float: bool = ...</span><span class="s2">,</span>
    <span class="s1">safe: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_datetime: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_timedelta: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_period: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_interval: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_to_nullable_integer: bool = ...</span><span class="s2">,</span>
    <span class="s1">dtype_if_all_nat: DtypeObj | </span><span class="s2">None </span><span class="s1">= ...</span><span class="s2">,</span>
<span class="s1">) -&gt; ArrayLike: ...</span>
<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">maybe_convert_numeric(</span>
    <span class="s1">values: npt.NDArray[np.object_]</span><span class="s2">,</span>
    <span class="s1">na_values: set</span><span class="s2">,</span>
    <span class="s1">convert_empty: bool = ...</span><span class="s2">,</span>
    <span class="s1">coerce_numeric: bool = ...</span><span class="s2">,</span>
    <span class="s1">convert_to_masked_nullable: Literal[</span><span class="s2">False</span><span class="s1">] = ...</span><span class="s2">,</span>
<span class="s1">) -&gt; tuple[np.ndarray</span><span class="s2">, None</span><span class="s1">]: ...</span>
<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">maybe_convert_numeric(</span>
    <span class="s1">values: npt.NDArray[np.object_]</span><span class="s2">,</span>
    <span class="s1">na_values: set</span><span class="s2">,</span>
    <span class="s1">convert_empty: bool = ...</span><span class="s2">,</span>
    <span class="s1">coerce_numeric: bool = ...</span><span class="s2">,</span>
    <span class="s1">*</span><span class="s2">,</span>
    <span class="s1">convert_to_masked_nullable: Literal[</span><span class="s2">True</span><span class="s1">]</span><span class="s2">,</span>
<span class="s1">) -&gt; tuple[np.ndarray</span><span class="s2">, </span><span class="s1">np.ndarray]: ...</span>

<span class="s0"># TODO: restrict `arr`?</span>
<span class="s2">def </span><span class="s1">ensure_string_array(</span>
    <span class="s1">arr</span><span class="s2">,</span>
    <span class="s1">na_value: object = ...</span><span class="s2">,</span>
    <span class="s1">convert_na_value: bool = ...</span><span class="s2">,</span>
    <span class="s1">copy: bool = ...</span><span class="s2">,</span>
    <span class="s1">skipna: bool = ...</span><span class="s2">,</span>
<span class="s1">) -&gt; npt.NDArray[np.object_]: ...</span>
<span class="s2">def </span><span class="s1">infer_datetimelike_array(</span>
    <span class="s1">arr: npt.NDArray[np.object_]</span><span class="s2">,</span>
<span class="s1">) -&gt; tuple[str</span><span class="s2">, </span><span class="s1">bool]: ...</span>
<span class="s2">def </span><span class="s1">astype_intsafe(</span>
    <span class="s1">arr: npt.NDArray[np.object_]</span><span class="s2">,</span>
    <span class="s1">new_dtype: np.dtype</span><span class="s2">,</span>
<span class="s1">) -&gt; np.ndarray: ...</span>
<span class="s2">def </span><span class="s1">fast_zip(ndarrays: list) -&gt; npt.NDArray[np.object_]: ...</span>

<span class="s0"># TODO: can we be more specific about rows?</span>
<span class="s2">def </span><span class="s1">to_object_array_tuples(rows: object) -&gt; ndarray_obj_2d: ...</span>
<span class="s2">def </span><span class="s1">tuples_to_object_array(</span>
    <span class="s1">tuples: npt.NDArray[np.object_]</span><span class="s2">,</span>
<span class="s1">) -&gt; ndarray_obj_2d: ...</span>

<span class="s0"># TODO: can we be more specific about rows?</span>
<span class="s2">def </span><span class="s1">to_object_array(rows: object</span><span class="s2">, </span><span class="s1">min_width: int = ...) -&gt; ndarray_obj_2d: ...</span>
<span class="s2">def </span><span class="s1">dicts_to_array(dicts: list</span><span class="s2">, </span><span class="s1">columns: list) -&gt; ndarray_obj_2d: ...</span>
<span class="s2">def </span><span class="s1">maybe_booleans_to_slice(</span>
    <span class="s1">mask: npt.NDArray[np.uint8]</span><span class="s2">,</span>
<span class="s1">) -&gt; slice | npt.NDArray[np.uint8]: ...</span>
<span class="s2">def </span><span class="s1">maybe_indices_to_slice(</span>
    <span class="s1">indices: npt.NDArray[np.intp]</span><span class="s2">,</span>
    <span class="s1">max_len: int</span><span class="s2">,</span>
<span class="s1">) -&gt; slice | npt.NDArray[np.intp]: ...</span>
<span class="s2">def </span><span class="s1">is_all_arraylike(obj: list) -&gt; bool: ...</span>

<span class="s0"># -----------------------------------------------------------------</span>
<span class="s0"># Functions which in reality take memoryviews</span>

<span class="s2">def </span><span class="s1">memory_usage_of_objects(arr: np.ndarray) -&gt; int: ...  </span><span class="s0"># object[:]  # np.int64</span>
<span class="s2">def </span><span class="s1">map_infer_mask(</span>
    <span class="s1">arr: np.ndarray</span><span class="s2">,</span>
    <span class="s1">f: Callable[[Any]</span><span class="s2">, </span><span class="s1">Any]</span><span class="s2">,</span>
    <span class="s1">mask: np.ndarray</span><span class="s2">,  </span><span class="s0"># const uint8_t[:]</span>
    <span class="s1">convert: bool = ...</span><span class="s2">,</span>
    <span class="s1">na_value: Any = ...</span><span class="s2">,</span>
    <span class="s1">dtype: np.dtype = ...</span><span class="s2">,</span>
<span class="s1">) -&gt; np.ndarray: ...</span>
<span class="s2">def </span><span class="s1">indices_fast(</span>
    <span class="s1">index: npt.NDArray[np.intp]</span><span class="s2">,</span>
    <span class="s1">labels: np.ndarray</span><span class="s2">,  </span><span class="s0"># const int64_t[:]</span>
    <span class="s1">keys: list</span><span class="s2">,</span>
    <span class="s1">sorted_labels: list[npt.NDArray[np.int64]]</span><span class="s2">,</span>
<span class="s1">) -&gt; dict[Hashable</span><span class="s2">, </span><span class="s1">npt.NDArray[np.intp]]: ...</span>
<span class="s2">def </span><span class="s1">generate_slices(</span>
    <span class="s1">labels: np.ndarray</span><span class="s2">, </span><span class="s1">ngroups: int  </span><span class="s0"># const intp_t[:]</span>
<span class="s1">) -&gt; tuple[npt.NDArray[np.int64]</span><span class="s2">, </span><span class="s1">npt.NDArray[np.int64]]: ...</span>
<span class="s2">def </span><span class="s1">count_level_2d(</span>
    <span class="s1">mask: np.ndarray</span><span class="s2">,  </span><span class="s0"># ndarray[uint8_t, ndim=2, cast=True],</span>
    <span class="s1">labels: np.ndarray</span><span class="s2">,  </span><span class="s0"># const intp_t[:]</span>
    <span class="s1">max_bin: int</span><span class="s2">,</span>
    <span class="s1">axis: int</span><span class="s2">,</span>
<span class="s1">) -&gt; np.ndarray: ...  </span><span class="s0"># np.ndarray[np.int64, ndim=2]</span>
<span class="s2">def </span><span class="s1">get_level_sorter(</span>
    <span class="s1">label: np.ndarray</span><span class="s2">,  </span><span class="s0"># const int64_t[:]</span>
    <span class="s1">starts: np.ndarray</span><span class="s2">,  </span><span class="s0"># const intp_t[:]</span>
<span class="s1">) -&gt; np.ndarray: ...  </span><span class="s0">#  np.ndarray[np.intp, ndim=1]</span>
<span class="s2">def </span><span class="s1">generate_bins_dt64(</span>
    <span class="s1">values: npt.NDArray[np.int64]</span><span class="s2">,</span>
    <span class="s1">binner: np.ndarray</span><span class="s2">,  </span><span class="s0"># const int64_t[:]</span>
    <span class="s1">closed: object = ...</span><span class="s2">,</span>
    <span class="s1">hasnans: bool = ...</span><span class="s2">,</span>
<span class="s1">) -&gt; np.ndarray: ...  </span><span class="s0"># np.ndarray[np.int64, ndim=1]</span>
<span class="s2">def </span><span class="s1">array_equivalent_object(</span>
    <span class="s1">left: np.ndarray</span><span class="s2">,  </span><span class="s0"># object[:]</span>
    <span class="s1">right: np.ndarray</span><span class="s2">,  </span><span class="s0"># object[:]</span>
<span class="s1">) -&gt; bool: ...</span>
<span class="s2">def </span><span class="s1">has_infs(arr: np.ndarray) -&gt; bool: ...  </span><span class="s0"># const floating[:]</span>
<span class="s2">def </span><span class="s1">get_reverse_indexer(</span>
    <span class="s1">indexer: np.ndarray</span><span class="s2">,  </span><span class="s0"># const intp_t[:]</span>
    <span class="s1">length: int</span><span class="s2">,</span>
<span class="s1">) -&gt; npt.NDArray[np.intp]: ...</span>
<span class="s2">def </span><span class="s1">is_bool_list(obj: list) -&gt; bool: ...</span>
<span class="s2">def </span><span class="s1">dtypes_all_equal(types: list[DtypeObj]) -&gt; bool: ...</span>
</pre>
</body>
</html>