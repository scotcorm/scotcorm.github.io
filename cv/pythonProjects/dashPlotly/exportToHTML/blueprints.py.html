<html>
<head>
<title>blueprints.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
blueprints.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">typing </span><span class="s0">as </span><span class="s1">t</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">defaultdict</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">update_wrapper</span>

<span class="s0">from </span><span class="s1">.scaffold </span><span class="s0">import </span><span class="s1">_endpoint_from_view_func</span>
<span class="s0">from </span><span class="s1">.scaffold </span><span class="s0">import </span><span class="s1">_sentinel</span>
<span class="s0">from </span><span class="s1">.scaffold </span><span class="s0">import </span><span class="s1">Scaffold</span>
<span class="s0">from </span><span class="s1">.typing </span><span class="s0">import </span><span class="s1">AfterRequestCallable</span>
<span class="s0">from </span><span class="s1">.typing </span><span class="s0">import </span><span class="s1">BeforeFirstRequestCallable</span>
<span class="s0">from </span><span class="s1">.typing </span><span class="s0">import </span><span class="s1">BeforeRequestCallable</span>
<span class="s0">from </span><span class="s1">.typing </span><span class="s0">import </span><span class="s1">TeardownCallable</span>
<span class="s0">from </span><span class="s1">.typing </span><span class="s0">import </span><span class="s1">TemplateContextProcessorCallable</span>
<span class="s0">from </span><span class="s1">.typing </span><span class="s0">import </span><span class="s1">TemplateFilterCallable</span>
<span class="s0">from </span><span class="s1">.typing </span><span class="s0">import </span><span class="s1">TemplateGlobalCallable</span>
<span class="s0">from </span><span class="s1">.typing </span><span class="s0">import </span><span class="s1">TemplateTestCallable</span>
<span class="s0">from </span><span class="s1">.typing </span><span class="s0">import </span><span class="s1">URLDefaultCallable</span>
<span class="s0">from </span><span class="s1">.typing </span><span class="s0">import </span><span class="s1">URLValuePreprocessorCallable</span>

<span class="s0">if </span><span class="s1">t.TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">.app </span><span class="s0">import </span><span class="s1">Flask</span>
    <span class="s0">from </span><span class="s1">.typing </span><span class="s0">import </span><span class="s1">ErrorHandlerCallable</span>

<span class="s1">DeferredSetupFunction = t.Callable[[</span><span class="s2">&quot;BlueprintSetupState&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">t.Callable]</span>


<span class="s0">class </span><span class="s1">BlueprintSetupState:</span>
    <span class="s3">&quot;&quot;&quot;Temporary holder object for registering a blueprint with the 
    application.  An instance of this class is created by the 
    :meth:`~flask.Blueprint.make_setup_state` method and later passed 
    to all register callback functions. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">blueprint: </span><span class="s2">&quot;Blueprint&quot;</span><span class="s0">,</span>
        <span class="s1">app: </span><span class="s2">&quot;Flask&quot;</span><span class="s0">,</span>
        <span class="s1">options: t.Any</span><span class="s0">,</span>
        <span class="s1">first_registration: bool</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">#: a reference to the current application</span>
        <span class="s1">self.app = app</span>

        <span class="s4">#: a reference to the blueprint that created this setup state.</span>
        <span class="s1">self.blueprint = blueprint</span>

        <span class="s4">#: a dictionary with all options that were passed to the</span>
        <span class="s4">#: :meth:`~flask.Flask.register_blueprint` method.</span>
        <span class="s1">self.options = options</span>

        <span class="s4">#: as blueprints can be registered multiple times with the</span>
        <span class="s4">#: application and not everything wants to be registered</span>
        <span class="s4">#: multiple times on it, this attribute can be used to figure</span>
        <span class="s4">#: out if the blueprint was registered in the past already.</span>
        <span class="s1">self.first_registration = first_registration</span>

        <span class="s1">subdomain = self.options.get(</span><span class="s2">&quot;subdomain&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">subdomain </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">subdomain = self.blueprint.subdomain</span>

        <span class="s4">#: The subdomain that the blueprint should be active for, ``None``</span>
        <span class="s4">#: otherwise.</span>
        <span class="s1">self.subdomain = subdomain</span>

        <span class="s1">url_prefix = self.options.get(</span><span class="s2">&quot;url_prefix&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">url_prefix </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">url_prefix = self.blueprint.url_prefix</span>
        <span class="s4">#: The prefix that should be used for all URLs defined on the</span>
        <span class="s4">#: blueprint.</span>
        <span class="s1">self.url_prefix = url_prefix</span>

        <span class="s1">self.name = self.options.get(</span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s1">blueprint.name)</span>
        <span class="s1">self.name_prefix = self.options.get(</span><span class="s2">&quot;name_prefix&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>

        <span class="s4">#: A dictionary with URL defaults that is added to each and every</span>
        <span class="s4">#: URL that was defined with the blueprint.</span>
        <span class="s1">self.url_defaults = dict(self.blueprint.url_values_defaults)</span>
        <span class="s1">self.url_defaults.update(self.options.get(</span><span class="s2">&quot;url_defaults&quot;</span><span class="s0">, </span><span class="s1">()))</span>

    <span class="s0">def </span><span class="s1">add_url_rule(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">rule: str</span><span class="s0">,</span>
        <span class="s1">endpoint: t.Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">view_func: t.Optional[t.Callable] = </span><span class="s0">None,</span>
        <span class="s1">**options: t.Any</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;A helper method to register a rule (and optionally a view function) 
        to the application.  The endpoint is automatically prefixed with the 
        blueprint's name. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.url_prefix </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">rule:</span>
                <span class="s1">rule = </span><span class="s2">&quot;/&quot;</span><span class="s1">.join((self.url_prefix.rstrip(</span><span class="s2">&quot;/&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">rule.lstrip(</span><span class="s2">&quot;/&quot;</span><span class="s1">)))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">rule = self.url_prefix</span>
        <span class="s1">options.setdefault(</span><span class="s2">&quot;subdomain&quot;</span><span class="s0">, </span><span class="s1">self.subdomain)</span>
        <span class="s0">if </span><span class="s1">endpoint </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">endpoint = _endpoint_from_view_func(view_func)  </span><span class="s4"># type: ignore</span>
        <span class="s1">defaults = self.url_defaults</span>
        <span class="s0">if </span><span class="s2">&quot;defaults&quot; </span><span class="s0">in </span><span class="s1">options:</span>
            <span class="s1">defaults = dict(defaults</span><span class="s0">, </span><span class="s1">**options.pop(</span><span class="s2">&quot;defaults&quot;</span><span class="s1">))</span>

        <span class="s1">self.app.add_url_rule(</span>
            <span class="s1">rule</span><span class="s0">,</span>
            <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">self.name_prefix</span><span class="s0">}</span><span class="s2">.</span><span class="s0">{</span><span class="s1">self.name</span><span class="s0">}</span><span class="s2">.</span><span class="s0">{</span><span class="s1">endpoint</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">.lstrip(</span><span class="s2">&quot;.&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">view_func</span><span class="s0">,</span>
            <span class="s1">defaults=defaults</span><span class="s0">,</span>
            <span class="s1">**options</span><span class="s0">,</span>
        <span class="s1">)</span>


<span class="s0">class </span><span class="s1">Blueprint(Scaffold):</span>
    <span class="s3">&quot;&quot;&quot;Represents a blueprint, a collection of routes and other 
    app-related functions that can be registered on a real application 
    later. 
 
    A blueprint is an object that allows defining application functions 
    without requiring an application object ahead of time. It uses the 
    same decorators as :class:`~flask.Flask`, but defers the need for an 
    application by recording them for later registration. 
 
    Decorating a function with a blueprint creates a deferred function 
    that is called with :class:`~flask.blueprints.BlueprintSetupState` 
    when the blueprint is registered on an application. 
 
    See :doc:`/blueprints` for more information. 
 
    :param name: The name of the blueprint. Will be prepended to each 
        endpoint name. 
    :param import_name: The name of the blueprint package, usually 
        ``__name__``. This helps locate the ``root_path`` for the 
        blueprint. 
    :param static_folder: A folder with static files that should be 
        served by the blueprint's static route. The path is relative to 
        the blueprint's root path. Blueprint static files are disabled 
        by default. 
    :param static_url_path: The url to serve static files from. 
        Defaults to ``static_folder``. If the blueprint does not have 
        a ``url_prefix``, the app's static route will take precedence, 
        and the blueprint's static files won't be accessible. 
    :param template_folder: A folder with templates that should be added 
        to the app's template search path. The path is relative to the 
        blueprint's root path. Blueprint templates are disabled by 
        default. Blueprint templates have a lower precedence than those 
        in the app's templates folder. 
    :param url_prefix: A path to prepend to all of the blueprint's URLs, 
        to make them distinct from the rest of the app's routes. 
    :param subdomain: A subdomain that blueprint routes will match on by 
        default. 
    :param url_defaults: A dict of default values that blueprint routes 
        will receive by default. 
    :param root_path: By default, the blueprint will automatically set 
        this based on ``import_name``. In certain situations this 
        automatic detection can fail, so the path can be specified 
        manually instead. 
 
    .. versionchanged:: 1.1.0 
        Blueprints have a ``cli`` group to register nested CLI commands. 
        The ``cli_group`` parameter controls the name of the group under 
        the ``flask`` command. 
 
    .. versionadded:: 0.7 
    &quot;&quot;&quot;</span>

    <span class="s1">warn_on_modifications = </span><span class="s0">False</span>
    <span class="s1">_got_registered_once = </span><span class="s0">False</span>

    <span class="s4">#: Blueprint local JSON encoder class to use. Set to ``None`` to use</span>
    <span class="s4">#: the app's :class:`~flask.Flask.json_encoder`.</span>
    <span class="s1">json_encoder = </span><span class="s0">None</span>
    <span class="s4">#: Blueprint local JSON decoder class to use. Set to ``None`` to use</span>
    <span class="s4">#: the app's :class:`~flask.Flask.json_decoder`.</span>
    <span class="s1">json_decoder = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">name: str</span><span class="s0">,</span>
        <span class="s1">import_name: str</span><span class="s0">,</span>
        <span class="s1">static_folder: t.Optional[t.Union[str</span><span class="s0">, </span><span class="s1">os.PathLike]] = </span><span class="s0">None,</span>
        <span class="s1">static_url_path: t.Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">template_folder: t.Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">url_prefix: t.Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">subdomain: t.Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">url_defaults: t.Optional[dict] = </span><span class="s0">None,</span>
        <span class="s1">root_path: t.Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">cli_group: t.Optional[str] = _sentinel</span><span class="s0">,  </span><span class="s4"># type: ignore</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">import_name=import_name</span><span class="s0">,</span>
            <span class="s1">static_folder=static_folder</span><span class="s0">,</span>
            <span class="s1">static_url_path=static_url_path</span><span class="s0">,</span>
            <span class="s1">template_folder=template_folder</span><span class="s0">,</span>
            <span class="s1">root_path=root_path</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s2">&quot;.&quot; </span><span class="s0">in </span><span class="s1">name:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;'name' may not contain a dot '.' character.&quot;</span><span class="s1">)</span>

        <span class="s1">self.name = name</span>
        <span class="s1">self.url_prefix = url_prefix</span>
        <span class="s1">self.subdomain = subdomain</span>
        <span class="s1">self.deferred_functions: t.List[DeferredSetupFunction] = []</span>

        <span class="s0">if </span><span class="s1">url_defaults </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">url_defaults = {}</span>

        <span class="s1">self.url_values_defaults = url_defaults</span>
        <span class="s1">self.cli_group = cli_group</span>
        <span class="s1">self._blueprints: t.List[t.Tuple[</span><span class="s2">&quot;Blueprint&quot;</span><span class="s0">, </span><span class="s1">dict]] = []</span>

    <span class="s0">def </span><span class="s1">_is_setup_finished(self) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">self.warn_on_modifications </span><span class="s0">and </span><span class="s1">self._got_registered_once</span>

    <span class="s0">def </span><span class="s1">record(self</span><span class="s0">, </span><span class="s1">func: t.Callable) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Registers a function that is called when the blueprint is 
        registered on the application.  This function is called with the 
        state as argument as returned by the :meth:`make_setup_state` 
        method. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._got_registered_once </span><span class="s0">and </span><span class="s1">self.warn_on_modifications:</span>
            <span class="s0">from </span><span class="s1">warnings </span><span class="s0">import </span><span class="s1">warn</span>

            <span class="s1">warn(</span>
                <span class="s1">Warning(</span>
                    <span class="s2">&quot;The blueprint was already registered once but is&quot;</span>
                    <span class="s2">&quot; getting modified now. These changes will not show&quot;</span>
                    <span class="s2">&quot; up.&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">self.deferred_functions.append(func)</span>

    <span class="s0">def </span><span class="s1">record_once(self</span><span class="s0">, </span><span class="s1">func: t.Callable) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Works like :meth:`record` but wraps the function in another 
        function that will ensure the function is only called once.  If the 
        blueprint is registered a second time on the application, the 
        function passed is not called. 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">wrapper(state: BlueprintSetupState) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">state.first_registration:</span>
                <span class="s1">func(state)</span>

        <span class="s0">return </span><span class="s1">self.record(update_wrapper(wrapper</span><span class="s0">, </span><span class="s1">func))</span>

    <span class="s0">def </span><span class="s1">make_setup_state(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">app: </span><span class="s2">&quot;Flask&quot;</span><span class="s0">, </span><span class="s1">options: dict</span><span class="s0">, </span><span class="s1">first_registration: bool = </span><span class="s0">False</span>
    <span class="s1">) -&gt; BlueprintSetupState:</span>
        <span class="s3">&quot;&quot;&quot;Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState` 
        object that is later passed to the register callback functions. 
        Subclasses can override this to return a subclass of the setup state. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">BlueprintSetupState(self</span><span class="s0">, </span><span class="s1">app</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">first_registration)</span>

    <span class="s0">def </span><span class="s1">register_blueprint(self</span><span class="s0">, </span><span class="s1">blueprint: </span><span class="s2">&quot;Blueprint&quot;</span><span class="s0">, </span><span class="s1">**options: t.Any) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Register a :class:`~flask.Blueprint` on this blueprint. Keyword 
        arguments passed to this method will override the defaults set 
        on the blueprint. 
 
        .. versionchanged:: 2.0.1 
            The ``name`` option can be used to change the (pre-dotted) 
            name the blueprint is registered with. This allows the same 
            blueprint to be registered multiple times with unique names 
            for ``url_for``. 
 
        .. versionadded:: 2.0 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">blueprint </span><span class="s0">is </span><span class="s1">self:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Cannot register a blueprint on itself&quot;</span><span class="s1">)</span>
        <span class="s1">self._blueprints.append((blueprint</span><span class="s0">, </span><span class="s1">options))</span>

    <span class="s0">def </span><span class="s1">register(self</span><span class="s0">, </span><span class="s1">app: </span><span class="s2">&quot;Flask&quot;</span><span class="s0">, </span><span class="s1">options: dict) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Called by :meth:`Flask.register_blueprint` to register all 
        views and callbacks registered on the blueprint with the 
        application. Creates a :class:`.BlueprintSetupState` and calls 
        each :meth:`record` callback with it. 
 
        :param app: The application this blueprint is being registered 
            with. 
        :param options: Keyword arguments forwarded from 
            :meth:`~Flask.register_blueprint`. 
 
        .. versionchanged:: 2.0.1 
            Nested blueprints are registered with their dotted name. 
            This allows different blueprints with the same name to be 
            nested at different locations. 
 
        .. versionchanged:: 2.0.1 
            The ``name`` option can be used to change the (pre-dotted) 
            name the blueprint is registered with. This allows the same 
            blueprint to be registered multiple times with unique names 
            for ``url_for``. 
 
        .. versionchanged:: 2.0.1 
            Registering the same blueprint with the same name multiple 
            times is deprecated and will become an error in Flask 2.1. 
        &quot;&quot;&quot;</span>
        <span class="s1">name_prefix = options.get(</span><span class="s2">&quot;name_prefix&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">self_name = options.get(</span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s1">self.name)</span>
        <span class="s1">name = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">name_prefix</span><span class="s0">}</span><span class="s2">.</span><span class="s0">{</span><span class="s1">self_name</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">.lstrip(</span><span class="s2">&quot;.&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">app.blueprints:</span>
            <span class="s1">existing_at = </span><span class="s2">f&quot; '</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s2">'&quot; </span><span class="s0">if </span><span class="s1">self_name != name </span><span class="s0">else </span><span class="s2">&quot;&quot;</span>

            <span class="s0">if </span><span class="s1">app.blueprints[name] </span><span class="s0">is not </span><span class="s1">self:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">f&quot;The name '</span><span class="s0">{</span><span class="s1">self_name</span><span class="s0">}</span><span class="s2">' is already registered for&quot;</span>
                    <span class="s2">f&quot; a different blueprint</span><span class="s0">{</span><span class="s1">existing_at</span><span class="s0">}</span><span class="s2">. Use 'name='&quot;</span>
                    <span class="s2">&quot; to provide a unique name.&quot;</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">import </span><span class="s1">warnings</span>

                <span class="s1">warnings.warn(</span>
                    <span class="s2">f&quot;The name '</span><span class="s0">{</span><span class="s1">self_name</span><span class="s0">}</span><span class="s2">' is already registered for&quot;</span>
                    <span class="s2">f&quot; this blueprint</span><span class="s0">{</span><span class="s1">existing_at</span><span class="s0">}</span><span class="s2">. Use 'name=' to&quot;</span>
                    <span class="s2">&quot; provide a unique name. This will become an error&quot;</span>
                    <span class="s2">&quot; in Flask 2.1.&quot;</span><span class="s0">,</span>
                    <span class="s1">stacklevel=</span><span class="s5">4</span><span class="s0">,</span>
                <span class="s1">)</span>

        <span class="s1">first_bp_registration = </span><span class="s0">not </span><span class="s1">any(bp </span><span class="s0">is </span><span class="s1">self </span><span class="s0">for </span><span class="s1">bp </span><span class="s0">in </span><span class="s1">app.blueprints.values())</span>
        <span class="s1">first_name_registration = name </span><span class="s0">not in </span><span class="s1">app.blueprints</span>

        <span class="s1">app.blueprints[name] = self</span>
        <span class="s1">self._got_registered_once = </span><span class="s0">True</span>
        <span class="s1">state = self.make_setup_state(app</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">first_bp_registration)</span>

        <span class="s0">if </span><span class="s1">self.has_static_folder:</span>
            <span class="s1">state.add_url_rule(</span>
                <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">self.static_url_path</span><span class="s0">}</span><span class="s2">/&lt;path:filename&gt;&quot;</span><span class="s0">,</span>
                <span class="s1">view_func=self.send_static_file</span><span class="s0">,</span>
                <span class="s1">endpoint=</span><span class="s2">&quot;static&quot;</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s4"># Merge blueprint data into parent.</span>
        <span class="s0">if </span><span class="s1">first_bp_registration </span><span class="s0">or </span><span class="s1">first_name_registration:</span>

            <span class="s0">def </span><span class="s1">extend(bp_dict</span><span class="s0">, </span><span class="s1">parent_dict):</span>
                <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">values </span><span class="s0">in </span><span class="s1">bp_dict.items():</span>
                    <span class="s1">key = name </span><span class="s0">if </span><span class="s1">key </span><span class="s0">is None else </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s2">.</span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s2">&quot;</span>
                    <span class="s1">parent_dict[key].extend(values)</span>

            <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">self.error_handler_spec.items():</span>
                <span class="s1">key = name </span><span class="s0">if </span><span class="s1">key </span><span class="s0">is None else </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s2">.</span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s2">&quot;</span>
                <span class="s1">value = defaultdict(</span>
                    <span class="s1">dict</span><span class="s0">,</span>
                    <span class="s1">{</span>
                        <span class="s1">code: {</span>
                            <span class="s1">exc_class: func </span><span class="s0">for </span><span class="s1">exc_class</span><span class="s0">, </span><span class="s1">func </span><span class="s0">in </span><span class="s1">code_values.items()</span>
                        <span class="s1">}</span>
                        <span class="s0">for </span><span class="s1">code</span><span class="s0">, </span><span class="s1">code_values </span><span class="s0">in </span><span class="s1">value.items()</span>
                    <span class="s1">}</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s1">app.error_handler_spec[key] = value</span>

            <span class="s0">for </span><span class="s1">endpoint</span><span class="s0">, </span><span class="s1">func </span><span class="s0">in </span><span class="s1">self.view_functions.items():</span>
                <span class="s1">app.view_functions[endpoint] = func</span>

            <span class="s1">extend(self.before_request_funcs</span><span class="s0">, </span><span class="s1">app.before_request_funcs)</span>
            <span class="s1">extend(self.after_request_funcs</span><span class="s0">, </span><span class="s1">app.after_request_funcs)</span>
            <span class="s1">extend(</span>
                <span class="s1">self.teardown_request_funcs</span><span class="s0">,</span>
                <span class="s1">app.teardown_request_funcs</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">extend(self.url_default_functions</span><span class="s0">, </span><span class="s1">app.url_default_functions)</span>
            <span class="s1">extend(self.url_value_preprocessors</span><span class="s0">, </span><span class="s1">app.url_value_preprocessors)</span>
            <span class="s1">extend(self.template_context_processors</span><span class="s0">, </span><span class="s1">app.template_context_processors)</span>

        <span class="s0">for </span><span class="s1">deferred </span><span class="s0">in </span><span class="s1">self.deferred_functions:</span>
            <span class="s1">deferred(state)</span>

        <span class="s1">cli_resolved_group = options.get(</span><span class="s2">&quot;cli_group&quot;</span><span class="s0">, </span><span class="s1">self.cli_group)</span>

        <span class="s0">if </span><span class="s1">self.cli.commands:</span>
            <span class="s0">if </span><span class="s1">cli_resolved_group </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">app.cli.commands.update(self.cli.commands)</span>
            <span class="s0">elif </span><span class="s1">cli_resolved_group </span><span class="s0">is </span><span class="s1">_sentinel:</span>
                <span class="s1">self.cli.name = name</span>
                <span class="s1">app.cli.add_command(self.cli)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.cli.name = cli_resolved_group</span>
                <span class="s1">app.cli.add_command(self.cli)</span>

        <span class="s0">for </span><span class="s1">blueprint</span><span class="s0">, </span><span class="s1">bp_options </span><span class="s0">in </span><span class="s1">self._blueprints:</span>
            <span class="s1">bp_options = bp_options.copy()</span>
            <span class="s1">bp_url_prefix = bp_options.get(</span><span class="s2">&quot;url_prefix&quot;</span><span class="s1">)</span>

            <span class="s0">if </span><span class="s1">bp_url_prefix </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">bp_url_prefix = blueprint.url_prefix</span>

            <span class="s0">if </span><span class="s1">state.url_prefix </span><span class="s0">is not None and </span><span class="s1">bp_url_prefix </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">bp_options[</span><span class="s2">&quot;url_prefix&quot;</span><span class="s1">] = (</span>
                    <span class="s1">state.url_prefix.rstrip(</span><span class="s2">&quot;/&quot;</span><span class="s1">) + </span><span class="s2">&quot;/&quot; </span><span class="s1">+ bp_url_prefix.lstrip(</span><span class="s2">&quot;/&quot;</span><span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">bp_url_prefix </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">bp_options[</span><span class="s2">&quot;url_prefix&quot;</span><span class="s1">] = bp_url_prefix</span>
            <span class="s0">elif </span><span class="s1">state.url_prefix </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">bp_options[</span><span class="s2">&quot;url_prefix&quot;</span><span class="s1">] = state.url_prefix</span>

            <span class="s1">bp_options[</span><span class="s2">&quot;name_prefix&quot;</span><span class="s1">] = name</span>
            <span class="s1">blueprint.register(app</span><span class="s0">, </span><span class="s1">bp_options)</span>

    <span class="s0">def </span><span class="s1">add_url_rule(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">rule: str</span><span class="s0">,</span>
        <span class="s1">endpoint: t.Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">view_func: t.Optional[t.Callable] = </span><span class="s0">None,</span>
        <span class="s1">provide_automatic_options: t.Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">**options: t.Any</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Like :meth:`Flask.add_url_rule` but for a blueprint.  The endpoint for 
        the :func:`url_for` function is prefixed with the name of the blueprint. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">endpoint </span><span class="s0">and </span><span class="s2">&quot;.&quot; </span><span class="s0">in </span><span class="s1">endpoint:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;'endpoint' may not contain a dot '.' character.&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">view_func </span><span class="s0">and </span><span class="s1">hasattr(view_func</span><span class="s0">, </span><span class="s2">&quot;__name__&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s2">&quot;.&quot; </span><span class="s0">in </span><span class="s1">view_func.__name__:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;'view_func' name may not contain a dot '.' character.&quot;</span><span class="s1">)</span>

        <span class="s1">self.record(</span>
            <span class="s0">lambda </span><span class="s1">s: s.add_url_rule(</span>
                <span class="s1">rule</span><span class="s0">,</span>
                <span class="s1">endpoint</span><span class="s0">,</span>
                <span class="s1">view_func</span><span class="s0">,</span>
                <span class="s1">provide_automatic_options=provide_automatic_options</span><span class="s0">,</span>
                <span class="s1">**options</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">app_template_filter(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">name: t.Optional[str] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; t.Callable[[TemplateFilterCallable]</span><span class="s0">, </span><span class="s1">TemplateFilterCallable]:</span>
        <span class="s3">&quot;&quot;&quot;Register a custom template filter, available application wide.  Like 
        :meth:`Flask.template_filter` but for a blueprint. 
 
        :param name: the optional name of the filter, otherwise the 
                     function name will be used. 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">decorator(f: TemplateFilterCallable) -&gt; TemplateFilterCallable:</span>
            <span class="s1">self.add_app_template_filter(f</span><span class="s0">, </span><span class="s1">name=name)</span>
            <span class="s0">return </span><span class="s1">f</span>

        <span class="s0">return </span><span class="s1">decorator</span>

    <span class="s0">def </span><span class="s1">add_app_template_filter(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">f: TemplateFilterCallable</span><span class="s0">, </span><span class="s1">name: t.Optional[str] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Register a custom template filter, available application wide.  Like 
        :meth:`Flask.add_template_filter` but for a blueprint.  Works exactly 
        like the :meth:`app_template_filter` decorator. 
 
        :param name: the optional name of the filter, otherwise the 
                     function name will be used. 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">register_template(state: BlueprintSetupState) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
            <span class="s1">state.app.jinja_env.filters[name </span><span class="s0">or </span><span class="s1">f.__name__] = f</span>

        <span class="s1">self.record_once(register_template)</span>

    <span class="s0">def </span><span class="s1">app_template_test(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">name: t.Optional[str] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; t.Callable[[TemplateTestCallable]</span><span class="s0">, </span><span class="s1">TemplateTestCallable]:</span>
        <span class="s3">&quot;&quot;&quot;Register a custom template test, available application wide.  Like 
        :meth:`Flask.template_test` but for a blueprint. 
 
        .. versionadded:: 0.10 
 
        :param name: the optional name of the test, otherwise the 
                     function name will be used. 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">decorator(f: TemplateTestCallable) -&gt; TemplateTestCallable:</span>
            <span class="s1">self.add_app_template_test(f</span><span class="s0">, </span><span class="s1">name=name)</span>
            <span class="s0">return </span><span class="s1">f</span>

        <span class="s0">return </span><span class="s1">decorator</span>

    <span class="s0">def </span><span class="s1">add_app_template_test(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">f: TemplateTestCallable</span><span class="s0">, </span><span class="s1">name: t.Optional[str] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Register a custom template test, available application wide.  Like 
        :meth:`Flask.add_template_test` but for a blueprint.  Works exactly 
        like the :meth:`app_template_test` decorator. 
 
        .. versionadded:: 0.10 
 
        :param name: the optional name of the test, otherwise the 
                     function name will be used. 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">register_template(state: BlueprintSetupState) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
            <span class="s1">state.app.jinja_env.tests[name </span><span class="s0">or </span><span class="s1">f.__name__] = f</span>

        <span class="s1">self.record_once(register_template)</span>

    <span class="s0">def </span><span class="s1">app_template_global(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">name: t.Optional[str] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; t.Callable[[TemplateGlobalCallable]</span><span class="s0">, </span><span class="s1">TemplateGlobalCallable]:</span>
        <span class="s3">&quot;&quot;&quot;Register a custom template global, available application wide.  Like 
        :meth:`Flask.template_global` but for a blueprint. 
 
        .. versionadded:: 0.10 
 
        :param name: the optional name of the global, otherwise the 
                     function name will be used. 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">decorator(f: TemplateGlobalCallable) -&gt; TemplateGlobalCallable:</span>
            <span class="s1">self.add_app_template_global(f</span><span class="s0">, </span><span class="s1">name=name)</span>
            <span class="s0">return </span><span class="s1">f</span>

        <span class="s0">return </span><span class="s1">decorator</span>

    <span class="s0">def </span><span class="s1">add_app_template_global(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">f: TemplateGlobalCallable</span><span class="s0">, </span><span class="s1">name: t.Optional[str] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Register a custom template global, available application wide.  Like 
        :meth:`Flask.add_template_global` but for a blueprint.  Works exactly 
        like the :meth:`app_template_global` decorator. 
 
        .. versionadded:: 0.10 
 
        :param name: the optional name of the global, otherwise the 
                     function name will be used. 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">register_template(state: BlueprintSetupState) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
            <span class="s1">state.app.jinja_env.globals[name </span><span class="s0">or </span><span class="s1">f.__name__] = f</span>

        <span class="s1">self.record_once(register_template)</span>

    <span class="s0">def </span><span class="s1">before_app_request(self</span><span class="s0">, </span><span class="s1">f: BeforeRequestCallable) -&gt; BeforeRequestCallable:</span>
        <span class="s3">&quot;&quot;&quot;Like :meth:`Flask.before_request`.  Such a function is executed 
        before each request, even if outside of a blueprint. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.record_once(</span>
            <span class="s0">lambda </span><span class="s1">s: s.app.before_request_funcs.setdefault(</span><span class="s0">None, </span><span class="s1">[]).append(f)</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">f</span>

    <span class="s0">def </span><span class="s1">before_app_first_request(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">f: BeforeFirstRequestCallable</span>
    <span class="s1">) -&gt; BeforeFirstRequestCallable:</span>
        <span class="s3">&quot;&quot;&quot;Like :meth:`Flask.before_first_request`.  Such a function is 
        executed before the first request to the application. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.record_once(</span><span class="s0">lambda </span><span class="s1">s: s.app.before_first_request_funcs.append(f))</span>
        <span class="s0">return </span><span class="s1">f</span>

    <span class="s0">def </span><span class="s1">after_app_request(self</span><span class="s0">, </span><span class="s1">f: AfterRequestCallable) -&gt; AfterRequestCallable:</span>
        <span class="s3">&quot;&quot;&quot;Like :meth:`Flask.after_request` but for a blueprint.  Such a function 
        is executed after each request, even if outside of the blueprint. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.record_once(</span>
            <span class="s0">lambda </span><span class="s1">s: s.app.after_request_funcs.setdefault(</span><span class="s0">None, </span><span class="s1">[]).append(f)</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">f</span>

    <span class="s0">def </span><span class="s1">teardown_app_request(self</span><span class="s0">, </span><span class="s1">f: TeardownCallable) -&gt; TeardownCallable:</span>
        <span class="s3">&quot;&quot;&quot;Like :meth:`Flask.teardown_request` but for a blueprint.  Such a 
        function is executed when tearing down each request, even if outside of 
        the blueprint. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.record_once(</span>
            <span class="s0">lambda </span><span class="s1">s: s.app.teardown_request_funcs.setdefault(</span><span class="s0">None, </span><span class="s1">[]).append(f)</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">f</span>

    <span class="s0">def </span><span class="s1">app_context_processor(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">f: TemplateContextProcessorCallable</span>
    <span class="s1">) -&gt; TemplateContextProcessorCallable:</span>
        <span class="s3">&quot;&quot;&quot;Like :meth:`Flask.context_processor` but for a blueprint.  Such a 
        function is executed each request, even if outside of the blueprint. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.record_once(</span>
            <span class="s0">lambda </span><span class="s1">s: s.app.template_context_processors.setdefault(</span><span class="s0">None, </span><span class="s1">[]).append(f)</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">f</span>

    <span class="s0">def </span><span class="s1">app_errorhandler(self</span><span class="s0">, </span><span class="s1">code: t.Union[t.Type[Exception]</span><span class="s0">, </span><span class="s1">int]) -&gt; t.Callable:</span>
        <span class="s3">&quot;&quot;&quot;Like :meth:`Flask.errorhandler` but for a blueprint.  This 
        handler is used for all requests, even if outside of the blueprint. 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">decorator(</span>
            <span class="s1">f: </span><span class="s2">&quot;ErrorHandlerCallable[Exception]&quot;</span><span class="s0">,</span>
        <span class="s1">) -&gt; </span><span class="s2">&quot;ErrorHandlerCallable[Exception]&quot;</span><span class="s1">:</span>
            <span class="s1">self.record_once(</span><span class="s0">lambda </span><span class="s1">s: s.app.errorhandler(code)(f))</span>
            <span class="s0">return </span><span class="s1">f</span>

        <span class="s0">return </span><span class="s1">decorator</span>

    <span class="s0">def </span><span class="s1">app_url_value_preprocessor(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">f: URLValuePreprocessorCallable</span>
    <span class="s1">) -&gt; URLValuePreprocessorCallable:</span>
        <span class="s3">&quot;&quot;&quot;Same as :meth:`url_value_preprocessor` but application wide.&quot;&quot;&quot;</span>
        <span class="s1">self.record_once(</span>
            <span class="s0">lambda </span><span class="s1">s: s.app.url_value_preprocessors.setdefault(</span><span class="s0">None, </span><span class="s1">[]).append(f)</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">f</span>

    <span class="s0">def </span><span class="s1">app_url_defaults(self</span><span class="s0">, </span><span class="s1">f: URLDefaultCallable) -&gt; URLDefaultCallable:</span>
        <span class="s3">&quot;&quot;&quot;Same as :meth:`url_defaults` but application wide.&quot;&quot;&quot;</span>
        <span class="s1">self.record_once(</span>
            <span class="s0">lambda </span><span class="s1">s: s.app.url_default_functions.setdefault(</span><span class="s0">None, </span><span class="s1">[]).append(f)</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">f</span>
</pre>
</body>
</html>