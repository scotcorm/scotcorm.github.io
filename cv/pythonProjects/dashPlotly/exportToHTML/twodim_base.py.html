<html>
<head>
<title>twodim_base.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
twodim_base.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; Basic functions for manipulating 2d arrays 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">functools</span>

<span class="s2">from </span><span class="s1">numpy.core.numeric </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">asanyarray</span><span class="s2">, </span><span class="s1">arange</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">, </span><span class="s1">greater_equal</span><span class="s2">, </span><span class="s1">multiply</span><span class="s2">, </span><span class="s1">ones</span><span class="s2">,</span>
    <span class="s1">asarray</span><span class="s2">, </span><span class="s1">where</span><span class="s2">, </span><span class="s1">int8</span><span class="s2">, </span><span class="s1">int16</span><span class="s2">, </span><span class="s1">int32</span><span class="s2">, </span><span class="s1">int64</span><span class="s2">, </span><span class="s1">intp</span><span class="s2">, </span><span class="s1">empty</span><span class="s2">, </span><span class="s1">promote_types</span><span class="s2">,</span>
    <span class="s1">diagonal</span><span class="s2">, </span><span class="s1">nonzero</span><span class="s2">, </span><span class="s1">indices</span>
    <span class="s1">)</span>
<span class="s2">from </span><span class="s1">numpy.core.overrides </span><span class="s2">import </span><span class="s1">set_array_function_like_doc</span><span class="s2">, </span><span class="s1">set_module</span>
<span class="s2">from </span><span class="s1">numpy.core </span><span class="s2">import </span><span class="s1">overrides</span>
<span class="s2">from </span><span class="s1">numpy.core </span><span class="s2">import </span><span class="s1">iinfo</span>
<span class="s2">from </span><span class="s1">numpy.lib.stride_tricks </span><span class="s2">import </span><span class="s1">broadcast_to</span>


<span class="s1">__all__ = [</span>
    <span class="s3">'diag'</span><span class="s2">, </span><span class="s3">'diagflat'</span><span class="s2">, </span><span class="s3">'eye'</span><span class="s2">, </span><span class="s3">'fliplr'</span><span class="s2">, </span><span class="s3">'flipud'</span><span class="s2">, </span><span class="s3">'tri'</span><span class="s2">, </span><span class="s3">'triu'</span><span class="s2">,</span>
    <span class="s3">'tril'</span><span class="s2">, </span><span class="s3">'vander'</span><span class="s2">, </span><span class="s3">'histogram2d'</span><span class="s2">, </span><span class="s3">'mask_indices'</span><span class="s2">, </span><span class="s3">'tril_indices'</span><span class="s2">,</span>
    <span class="s3">'tril_indices_from'</span><span class="s2">, </span><span class="s3">'triu_indices'</span><span class="s2">, </span><span class="s3">'triu_indices_from'</span><span class="s2">, </span><span class="s1">]</span>


<span class="s1">array_function_dispatch = functools.partial(</span>
    <span class="s1">overrides.array_function_dispatch</span><span class="s2">, </span><span class="s1">module=</span><span class="s3">'numpy'</span><span class="s1">)</span>


<span class="s1">i1 = iinfo(int8)</span>
<span class="s1">i2 = iinfo(int16)</span>
<span class="s1">i4 = iinfo(int32)</span>


<span class="s2">def </span><span class="s1">_min_int(low</span><span class="s2">, </span><span class="s1">high):</span>
    <span class="s0">&quot;&quot;&quot; get small int that fits the range &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">high &lt;= i1.max </span><span class="s2">and </span><span class="s1">low &gt;= i1.min:</span>
        <span class="s2">return </span><span class="s1">int8</span>
    <span class="s2">if </span><span class="s1">high &lt;= i2.max </span><span class="s2">and </span><span class="s1">low &gt;= i2.min:</span>
        <span class="s2">return </span><span class="s1">int16</span>
    <span class="s2">if </span><span class="s1">high &lt;= i4.max </span><span class="s2">and </span><span class="s1">low &gt;= i4.min:</span>
        <span class="s2">return </span><span class="s1">int32</span>
    <span class="s2">return </span><span class="s1">int64</span>


<span class="s2">def </span><span class="s1">_flip_dispatcher(m):</span>
    <span class="s2">return </span><span class="s1">(m</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_flip_dispatcher)</span>
<span class="s2">def </span><span class="s1">fliplr(m):</span>
    <span class="s0">&quot;&quot;&quot; 
    Reverse the order of elements along axis 1 (left/right). 
 
    For a 2-D array, this flips the entries in each row in the left/right 
    direction. Columns are preserved, but appear in a different order than 
    before. 
 
    Parameters 
    ---------- 
    m : array_like 
        Input array, must be at least 2-D. 
 
    Returns 
    ------- 
    f : ndarray 
        A view of `m` with the columns reversed.  Since a view 
        is returned, this operation is :math:`\\mathcal O(1)`. 
 
    See Also 
    -------- 
    flipud : Flip array in the up/down direction. 
    flip : Flip array in one or more dimensions. 
    rot90 : Rotate array counterclockwise. 
 
    Notes 
    ----- 
    Equivalent to ``m[:,::-1]`` or ``np.flip(m, axis=1)``. 
    Requires the array to be at least 2-D. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; A = np.diag([1.,2.,3.]) 
    &gt;&gt;&gt; A 
    array([[1.,  0.,  0.], 
           [0.,  2.,  0.], 
           [0.,  0.,  3.]]) 
    &gt;&gt;&gt; np.fliplr(A) 
    array([[0.,  0.,  1.], 
           [0.,  2.,  0.], 
           [3.,  0.,  0.]]) 
 
    &gt;&gt;&gt; A = np.random.randn(2,3,5) 
    &gt;&gt;&gt; np.all(np.fliplr(A) == A[:,::-1,...]) 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = asanyarray(m)</span>
    <span class="s2">if </span><span class="s1">m.ndim &lt; </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Input must be &gt;= 2-d.&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">m[:</span><span class="s2">, </span><span class="s1">::-</span><span class="s4">1</span><span class="s1">]</span>


<span class="s1">@array_function_dispatch(_flip_dispatcher)</span>
<span class="s2">def </span><span class="s1">flipud(m):</span>
    <span class="s0">&quot;&quot;&quot; 
    Reverse the order of elements along axis 0 (up/down). 
 
    For a 2-D array, this flips the entries in each column in the up/down 
    direction. Rows are preserved, but appear in a different order than before. 
 
    Parameters 
    ---------- 
    m : array_like 
        Input array. 
 
    Returns 
    ------- 
    out : array_like 
        A view of `m` with the rows reversed.  Since a view is 
        returned, this operation is :math:`\\mathcal O(1)`. 
 
    See Also 
    -------- 
    fliplr : Flip array in the left/right direction. 
    flip : Flip array in one or more dimensions. 
    rot90 : Rotate array counterclockwise. 
 
    Notes 
    ----- 
    Equivalent to ``m[::-1, ...]`` or ``np.flip(m, axis=0)``. 
    Requires the array to be at least 1-D. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; A = np.diag([1.0, 2, 3]) 
    &gt;&gt;&gt; A 
    array([[1.,  0.,  0.], 
           [0.,  2.,  0.], 
           [0.,  0.,  3.]]) 
    &gt;&gt;&gt; np.flipud(A) 
    array([[0.,  0.,  3.], 
           [0.,  2.,  0.], 
           [1.,  0.,  0.]]) 
 
    &gt;&gt;&gt; A = np.random.randn(2,3,5) 
    &gt;&gt;&gt; np.all(np.flipud(A) == A[::-1,...]) 
    True 
 
    &gt;&gt;&gt; np.flipud([1,2]) 
    array([2, 1]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = asanyarray(m)</span>
    <span class="s2">if </span><span class="s1">m.ndim &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Input must be &gt;= 1-d.&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">m[::-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">...]</span>


<span class="s2">def </span><span class="s1">_eye_dispatcher(N</span><span class="s2">, </span><span class="s1">M=</span><span class="s2">None, </span><span class="s1">k=</span><span class="s2">None, </span><span class="s1">dtype=</span><span class="s2">None, </span><span class="s1">order=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">like=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(like</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@set_array_function_like_doc</span>
<span class="s1">@set_module(</span><span class="s3">'numpy'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">eye(N</span><span class="s2">, </span><span class="s1">M=</span><span class="s2">None, </span><span class="s1">k=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">'C'</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">like=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a 2-D array with ones on the diagonal and zeros elsewhere. 
 
    Parameters 
    ---------- 
    N : int 
      Number of rows in the output. 
    M : int, optional 
      Number of columns in the output. If None, defaults to `N`. 
    k : int, optional 
      Index of the diagonal: 0 (the default) refers to the main diagonal, 
      a positive value refers to an upper diagonal, and a negative value 
      to a lower diagonal. 
    dtype : data-type, optional 
      Data-type of the returned array. 
    order : {'C', 'F'}, optional 
        Whether the output should be stored in row-major (C-style) or 
        column-major (Fortran-style) order in memory. 
 
        .. versionadded:: 1.14.0 
    ${ARRAY_FUNCTION_LIKE} 
 
        .. versionadded:: 1.20.0 
 
    Returns 
    ------- 
    I : ndarray of shape (N,M) 
      An array where all elements are equal to zero, except for the `k`-th 
      diagonal, whose values are equal to one. 
 
    See Also 
    -------- 
    identity : (almost) equivalent function 
    diag : diagonal 2-D array from a 1-D array specified by the user. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.eye(2, dtype=int) 
    array([[1, 0], 
           [0, 1]]) 
    &gt;&gt;&gt; np.eye(3, k=1) 
    array([[0.,  1.,  0.], 
           [0.,  0.,  1.], 
           [0.,  0.,  0.]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">like </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">_eye_with_like(N</span><span class="s2">, </span><span class="s1">M=M</span><span class="s2">, </span><span class="s1">k=k</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=order</span><span class="s2">, </span><span class="s1">like=like)</span>
    <span class="s2">if </span><span class="s1">M </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">M = N</span>
    <span class="s1">m = zeros((N</span><span class="s2">, </span><span class="s1">M)</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">order=order)</span>
    <span class="s2">if </span><span class="s1">k &gt;= M:</span>
        <span class="s2">return </span><span class="s1">m</span>
    <span class="s2">if </span><span class="s1">k &gt;= </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">i = k</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">i = (-k) * M</span>
    <span class="s1">m[:M-k].flat[i::M+</span><span class="s4">1</span><span class="s1">] = </span><span class="s4">1</span>
    <span class="s2">return </span><span class="s1">m</span>


<span class="s1">_eye_with_like = array_function_dispatch(</span>
    <span class="s1">_eye_dispatcher</span>
<span class="s1">)(eye)</span>


<span class="s2">def </span><span class="s1">_diag_dispatcher(v</span><span class="s2">, </span><span class="s1">k=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(v</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_diag_dispatcher)</span>
<span class="s2">def </span><span class="s1">diag(v</span><span class="s2">, </span><span class="s1">k=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Extract a diagonal or construct a diagonal array. 
 
    See the more detailed documentation for ``numpy.diagonal`` if you use this 
    function to extract a diagonal and wish to write to the resulting array; 
    whether it returns a copy or a view depends on what version of numpy you 
    are using. 
 
    Parameters 
    ---------- 
    v : array_like 
        If `v` is a 2-D array, return a copy of its `k`-th diagonal. 
        If `v` is a 1-D array, return a 2-D array with `v` on the `k`-th 
        diagonal. 
    k : int, optional 
        Diagonal in question. The default is 0. Use `k&gt;0` for diagonals 
        above the main diagonal, and `k&lt;0` for diagonals below the main 
        diagonal. 
 
    Returns 
    ------- 
    out : ndarray 
        The extracted diagonal or constructed diagonal array. 
 
    See Also 
    -------- 
    diagonal : Return specified diagonals. 
    diagflat : Create a 2-D array with the flattened input as a diagonal. 
    trace : Sum along diagonals. 
    triu : Upper triangle of an array. 
    tril : Lower triangle of an array. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; x = np.arange(9).reshape((3,3)) 
    &gt;&gt;&gt; x 
    array([[0, 1, 2], 
           [3, 4, 5], 
           [6, 7, 8]]) 
 
    &gt;&gt;&gt; np.diag(x) 
    array([0, 4, 8]) 
    &gt;&gt;&gt; np.diag(x, k=1) 
    array([1, 5]) 
    &gt;&gt;&gt; np.diag(x, k=-1) 
    array([3, 7]) 
 
    &gt;&gt;&gt; np.diag(np.diag(x)) 
    array([[0, 0, 0], 
           [0, 4, 0], 
           [0, 0, 8]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">v = asanyarray(v)</span>
    <span class="s1">s = v.shape</span>
    <span class="s2">if </span><span class="s1">len(s) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">n = s[</span><span class="s4">0</span><span class="s1">]+abs(k)</span>
        <span class="s1">res = zeros((n</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">, </span><span class="s1">v.dtype)</span>
        <span class="s2">if </span><span class="s1">k &gt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">i = k</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">i = (-k) * n</span>
        <span class="s1">res[:n-k].flat[i::n+</span><span class="s4">1</span><span class="s1">] = v</span>
        <span class="s2">return </span><span class="s1">res</span>
    <span class="s2">elif </span><span class="s1">len(s) == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">diagonal(v</span><span class="s2">, </span><span class="s1">k)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Input must be 1- or 2-d.&quot;</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_diag_dispatcher)</span>
<span class="s2">def </span><span class="s1">diagflat(v</span><span class="s2">, </span><span class="s1">k=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a two-dimensional array with the flattened input as a diagonal. 
 
    Parameters 
    ---------- 
    v : array_like 
        Input data, which is flattened and set as the `k`-th 
        diagonal of the output. 
    k : int, optional 
        Diagonal to set; 0, the default, corresponds to the &quot;main&quot; diagonal, 
        a positive (negative) `k` giving the number of the diagonal above 
        (below) the main. 
 
    Returns 
    ------- 
    out : ndarray 
        The 2-D output array. 
 
    See Also 
    -------- 
    diag : MATLAB work-alike for 1-D and 2-D arrays. 
    diagonal : Return specified diagonals. 
    trace : Sum along diagonals. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.diagflat([[1,2], [3,4]]) 
    array([[1, 0, 0, 0], 
           [0, 2, 0, 0], 
           [0, 0, 3, 0], 
           [0, 0, 0, 4]]) 
 
    &gt;&gt;&gt; np.diagflat([1,2], 1) 
    array([[0, 1, 0], 
           [0, 0, 2], 
           [0, 0, 0]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">wrap = v.__array_wrap__</span>
    <span class="s2">except </span><span class="s1">AttributeError:</span>
        <span class="s1">wrap = </span><span class="s2">None</span>
    <span class="s1">v = asarray(v).ravel()</span>
    <span class="s1">s = len(v)</span>
    <span class="s1">n = s + abs(k)</span>
    <span class="s1">res = zeros((n</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">, </span><span class="s1">v.dtype)</span>
    <span class="s2">if </span><span class="s1">(k &gt;= </span><span class="s4">0</span><span class="s1">):</span>
        <span class="s1">i = arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">n-k</span><span class="s2">, </span><span class="s1">dtype=intp)</span>
        <span class="s1">fi = i+k+i*n</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">i = arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">n+k</span><span class="s2">, </span><span class="s1">dtype=intp)</span>
        <span class="s1">fi = i+(i-k)*n</span>
    <span class="s1">res.flat[fi] = v</span>
    <span class="s2">if not </span><span class="s1">wrap:</span>
        <span class="s2">return </span><span class="s1">res</span>
    <span class="s2">return </span><span class="s1">wrap(res)</span>


<span class="s2">def </span><span class="s1">_tri_dispatcher(N</span><span class="s2">, </span><span class="s1">M=</span><span class="s2">None, </span><span class="s1">k=</span><span class="s2">None, </span><span class="s1">dtype=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">like=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(like</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@set_array_function_like_doc</span>
<span class="s1">@set_module(</span><span class="s3">'numpy'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">tri(N</span><span class="s2">, </span><span class="s1">M=</span><span class="s2">None, </span><span class="s1">k=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">like=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    An array with ones at and below the given diagonal and zeros elsewhere. 
 
    Parameters 
    ---------- 
    N : int 
        Number of rows in the array. 
    M : int, optional 
        Number of columns in the array. 
        By default, `M` is taken equal to `N`. 
    k : int, optional 
        The sub-diagonal at and below which the array is filled. 
        `k` = 0 is the main diagonal, while `k` &lt; 0 is below it, 
        and `k` &gt; 0 is above.  The default is 0. 
    dtype : dtype, optional 
        Data type of the returned array.  The default is float. 
    ${ARRAY_FUNCTION_LIKE} 
 
        .. versionadded:: 1.20.0 
 
    Returns 
    ------- 
    tri : ndarray of shape (N, M) 
        Array with its lower triangle filled with ones and zero elsewhere; 
        in other words ``T[i,j] == 1`` for ``j &lt;= i + k``, 0 otherwise. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.tri(3, 5, 2, dtype=int) 
    array([[1, 1, 1, 0, 0], 
           [1, 1, 1, 1, 0], 
           [1, 1, 1, 1, 1]]) 
 
    &gt;&gt;&gt; np.tri(3, 5, -1) 
    array([[0.,  0.,  0.,  0.,  0.], 
           [1.,  0.,  0.,  0.,  0.], 
           [1.,  1.,  0.,  0.,  0.]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">like </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">_tri_with_like(N</span><span class="s2">, </span><span class="s1">M=M</span><span class="s2">, </span><span class="s1">k=k</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">like=like)</span>

    <span class="s2">if </span><span class="s1">M </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">M = N</span>

    <span class="s1">m = greater_equal.outer(arange(N</span><span class="s2">, </span><span class="s1">dtype=_min_int(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">N))</span><span class="s2">,</span>
                            <span class="s1">arange(-k</span><span class="s2">, </span><span class="s1">M-k</span><span class="s2">, </span><span class="s1">dtype=_min_int(-k</span><span class="s2">, </span><span class="s1">M - k)))</span>

    <span class="s5"># Avoid making a copy if the requested type is already bool</span>
    <span class="s1">m = m.astype(dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">m</span>


<span class="s1">_tri_with_like = array_function_dispatch(</span>
    <span class="s1">_tri_dispatcher</span>
<span class="s1">)(tri)</span>


<span class="s2">def </span><span class="s1">_trilu_dispatcher(m</span><span class="s2">, </span><span class="s1">k=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(m</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_trilu_dispatcher)</span>
<span class="s2">def </span><span class="s1">tril(m</span><span class="s2">, </span><span class="s1">k=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Lower triangle of an array. 
 
    Return a copy of an array with elements above the `k`-th diagonal zeroed. 
    For arrays with ``ndim`` exceeding 2, `tril` will apply to the final two 
    axes. 
 
    Parameters 
    ---------- 
    m : array_like, shape (..., M, N) 
        Input array. 
    k : int, optional 
        Diagonal above which to zero elements.  `k = 0` (the default) is the 
        main diagonal, `k &lt; 0` is below it and `k &gt; 0` is above. 
 
    Returns 
    ------- 
    tril : ndarray, shape (..., M, N) 
        Lower triangle of `m`, of same shape and data-type as `m`. 
 
    See Also 
    -------- 
    triu : same thing, only for the upper triangle 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1) 
    array([[ 0,  0,  0], 
           [ 4,  0,  0], 
           [ 7,  8,  0], 
           [10, 11, 12]]) 
 
    &gt;&gt;&gt; np.tril(np.arange(3*4*5).reshape(3, 4, 5)) 
    array([[[ 0,  0,  0,  0,  0], 
            [ 5,  6,  0,  0,  0], 
            [10, 11, 12,  0,  0], 
            [15, 16, 17, 18,  0]], 
           [[20,  0,  0,  0,  0], 
            [25, 26,  0,  0,  0], 
            [30, 31, 32,  0,  0], 
            [35, 36, 37, 38,  0]], 
           [[40,  0,  0,  0,  0], 
            [45, 46,  0,  0,  0], 
            [50, 51, 52,  0,  0], 
            [55, 56, 57, 58,  0]]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = asanyarray(m)</span>
    <span class="s1">mask = tri(*m.shape[-</span><span class="s4">2</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">k=k</span><span class="s2">, </span><span class="s1">dtype=bool)</span>

    <span class="s2">return </span><span class="s1">where(mask</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">zeros(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">m.dtype))</span>


<span class="s1">@array_function_dispatch(_trilu_dispatcher)</span>
<span class="s2">def </span><span class="s1">triu(m</span><span class="s2">, </span><span class="s1">k=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Upper triangle of an array. 
 
    Return a copy of an array with the elements below the `k`-th diagonal 
    zeroed. For arrays with ``ndim`` exceeding 2, `triu` will apply to the final 
    two axes. 
 
    Please refer to the documentation for `tril` for further details. 
 
    See Also 
    -------- 
    tril : lower triangle of an array 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1) 
    array([[ 1,  2,  3], 
           [ 4,  5,  6], 
           [ 0,  8,  9], 
           [ 0,  0, 12]]) 
 
    &gt;&gt;&gt; np.triu(np.arange(3*4*5).reshape(3, 4, 5)) 
    array([[[ 0,  1,  2,  3,  4], 
            [ 0,  6,  7,  8,  9], 
            [ 0,  0, 12, 13, 14], 
            [ 0,  0,  0, 18, 19]], 
           [[20, 21, 22, 23, 24], 
            [ 0, 26, 27, 28, 29], 
            [ 0,  0, 32, 33, 34], 
            [ 0,  0,  0, 38, 39]], 
           [[40, 41, 42, 43, 44], 
            [ 0, 46, 47, 48, 49], 
            [ 0,  0, 52, 53, 54], 
            [ 0,  0,  0, 58, 59]]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = asanyarray(m)</span>
    <span class="s1">mask = tri(*m.shape[-</span><span class="s4">2</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">k=k-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype=bool)</span>

    <span class="s2">return </span><span class="s1">where(mask</span><span class="s2">, </span><span class="s1">zeros(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">m.dtype)</span><span class="s2">, </span><span class="s1">m)</span>


<span class="s2">def </span><span class="s1">_vander_dispatcher(x</span><span class="s2">, </span><span class="s1">N=</span><span class="s2">None, </span><span class="s1">increasing=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(x</span><span class="s2">,</span><span class="s1">)</span>


<span class="s5"># Originally borrowed from John Hunter and matplotlib</span>
<span class="s1">@array_function_dispatch(_vander_dispatcher)</span>
<span class="s2">def </span><span class="s1">vander(x</span><span class="s2">, </span><span class="s1">N=</span><span class="s2">None, </span><span class="s1">increasing=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Generate a Vandermonde matrix. 
 
    The columns of the output matrix are powers of the input vector. The 
    order of the powers is determined by the `increasing` boolean argument. 
    Specifically, when `increasing` is False, the `i`-th output column is 
    the input vector raised element-wise to the power of ``N - i - 1``. Such 
    a matrix with a geometric progression in each row is named for Alexandre- 
    Theophile Vandermonde. 
 
    Parameters 
    ---------- 
    x : array_like 
        1-D input array. 
    N : int, optional 
        Number of columns in the output.  If `N` is not specified, a square 
        array is returned (``N = len(x)``). 
    increasing : bool, optional 
        Order of the powers of the columns.  If True, the powers increase 
        from left to right, if False (the default) they are reversed. 
 
        .. versionadded:: 1.9.0 
 
    Returns 
    ------- 
    out : ndarray 
        Vandermonde matrix.  If `increasing` is False, the first column is 
        ``x^(N-1)``, the second ``x^(N-2)`` and so forth. If `increasing` is 
        True, the columns are ``x^0, x^1, ..., x^(N-1)``. 
 
    See Also 
    -------- 
    polynomial.polynomial.polyvander 
 
    Examples 
    -------- 
    &gt;&gt;&gt; x = np.array([1, 2, 3, 5]) 
    &gt;&gt;&gt; N = 3 
    &gt;&gt;&gt; np.vander(x, N) 
    array([[ 1,  1,  1], 
           [ 4,  2,  1], 
           [ 9,  3,  1], 
           [25,  5,  1]]) 
 
    &gt;&gt;&gt; np.column_stack([x**(N-1-i) for i in range(N)]) 
    array([[ 1,  1,  1], 
           [ 4,  2,  1], 
           [ 9,  3,  1], 
           [25,  5,  1]]) 
 
    &gt;&gt;&gt; x = np.array([1, 2, 3, 5]) 
    &gt;&gt;&gt; np.vander(x) 
    array([[  1,   1,   1,   1], 
           [  8,   4,   2,   1], 
           [ 27,   9,   3,   1], 
           [125,  25,   5,   1]]) 
    &gt;&gt;&gt; np.vander(x, increasing=True) 
    array([[  1,   1,   1,   1], 
           [  1,   2,   4,   8], 
           [  1,   3,   9,  27], 
           [  1,   5,  25, 125]]) 
 
    The determinant of a square Vandermonde matrix is the product 
    of the differences between the values of the input vector: 
 
    &gt;&gt;&gt; np.linalg.det(np.vander(x)) 
    48.000000000000043 # may vary 
    &gt;&gt;&gt; (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1) 
    48 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x = asarray(x)</span>
    <span class="s2">if </span><span class="s1">x.ndim != </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;x must be a one-dimensional array or sequence.&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">N </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">N = len(x)</span>

    <span class="s1">v = empty((len(x)</span><span class="s2">, </span><span class="s1">N)</span><span class="s2">, </span><span class="s1">dtype=promote_types(x.dtype</span><span class="s2">, </span><span class="s1">int))</span>
    <span class="s1">tmp = v[:</span><span class="s2">, </span><span class="s1">::-</span><span class="s4">1</span><span class="s1">] </span><span class="s2">if not </span><span class="s1">increasing </span><span class="s2">else </span><span class="s1">v</span>

    <span class="s2">if </span><span class="s1">N &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">tmp[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1</span>
    <span class="s2">if </span><span class="s1">N &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">tmp[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">:] = x[:</span><span class="s2">, None</span><span class="s1">]</span>
        <span class="s1">multiply.accumulate(tmp[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">out=tmp[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">v</span>


<span class="s2">def </span><span class="s1">_histogram2d_dispatcher(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">bins=</span><span class="s2">None, </span><span class="s1">range=</span><span class="s2">None, </span><span class="s1">normed=</span><span class="s2">None,</span>
                            <span class="s1">weights=</span><span class="s2">None, </span><span class="s1">density=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">yield </span><span class="s1">x</span>
    <span class="s2">yield </span><span class="s1">y</span>

    <span class="s5"># This terrible logic is adapted from the checks in histogram2d</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">N = len(bins)</span>
    <span class="s2">except </span><span class="s1">TypeError:</span>
        <span class="s1">N = </span><span class="s4">1</span>
    <span class="s2">if </span><span class="s1">N == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">yield from </span><span class="s1">bins  </span><span class="s5"># bins=[x, y]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">yield </span><span class="s1">bins</span>

    <span class="s2">yield </span><span class="s1">weights</span>


<span class="s1">@array_function_dispatch(_histogram2d_dispatcher)</span>
<span class="s2">def </span><span class="s1">histogram2d(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">bins=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">range=</span><span class="s2">None, </span><span class="s1">normed=</span><span class="s2">None, </span><span class="s1">weights=</span><span class="s2">None,</span>
                <span class="s1">density=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the bi-dimensional histogram of two data samples. 
 
    Parameters 
    ---------- 
    x : array_like, shape (N,) 
        An array containing the x coordinates of the points to be 
        histogrammed. 
    y : array_like, shape (N,) 
        An array containing the y coordinates of the points to be 
        histogrammed. 
    bins : int or array_like or [int, int] or [array, array], optional 
        The bin specification: 
 
          * If int, the number of bins for the two dimensions (nx=ny=bins). 
          * If array_like, the bin edges for the two dimensions 
            (x_edges=y_edges=bins). 
          * If [int, int], the number of bins in each dimension 
            (nx, ny = bins). 
          * If [array, array], the bin edges in each dimension 
            (x_edges, y_edges = bins). 
          * A combination [int, array] or [array, int], where int 
            is the number of bins and array is the bin edges. 
 
    range : array_like, shape(2,2), optional 
        The leftmost and rightmost edges of the bins along each dimension 
        (if not specified explicitly in the `bins` parameters): 
        ``[[xmin, xmax], [ymin, ymax]]``. All values outside of this range 
        will be considered outliers and not tallied in the histogram. 
    density : bool, optional 
        If False, the default, returns the number of samples in each bin. 
        If True, returns the probability *density* function at the bin, 
        ``bin_count / sample_count / bin_area``. 
    normed : bool, optional 
        An alias for the density argument that behaves identically. To avoid 
        confusion with the broken normed argument to `histogram`, `density` 
        should be preferred. 
    weights : array_like, shape(N,), optional 
        An array of values ``w_i`` weighing each sample ``(x_i, y_i)``. 
        Weights are normalized to 1 if `normed` is True. If `normed` is 
        False, the values of the returned histogram are equal to the sum of 
        the weights belonging to the samples falling into each bin. 
 
    Returns 
    ------- 
    H : ndarray, shape(nx, ny) 
        The bi-dimensional histogram of samples `x` and `y`. Values in `x` 
        are histogrammed along the first dimension and values in `y` are 
        histogrammed along the second dimension. 
    xedges : ndarray, shape(nx+1,) 
        The bin edges along the first dimension. 
    yedges : ndarray, shape(ny+1,) 
        The bin edges along the second dimension. 
 
    See Also 
    -------- 
    histogram : 1D histogram 
    histogramdd : Multidimensional histogram 
 
    Notes 
    ----- 
    When `normed` is True, then the returned histogram is the sample 
    density, defined such that the sum over bins of the product 
    ``bin_value * bin_area`` is 1. 
 
    Please note that the histogram does not follow the Cartesian convention 
    where `x` values are on the abscissa and `y` values on the ordinate 
    axis.  Rather, `x` is histogrammed along the first dimension of the 
    array (vertical), and `y` along the second dimension of the array 
    (horizontal).  This ensures compatibility with `histogramdd`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from matplotlib.image import NonUniformImage 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    Construct a 2-D histogram with variable bin width. First define the bin 
    edges: 
 
    &gt;&gt;&gt; xedges = [0, 1, 3, 5] 
    &gt;&gt;&gt; yedges = [0, 2, 3, 4, 6] 
 
    Next we create a histogram H with random bin content: 
 
    &gt;&gt;&gt; x = np.random.normal(2, 1, 100) 
    &gt;&gt;&gt; y = np.random.normal(1, 1, 100) 
    &gt;&gt;&gt; H, xedges, yedges = np.histogram2d(x, y, bins=(xedges, yedges)) 
    &gt;&gt;&gt; # Histogram does not follow Cartesian convention (see Notes), 
    &gt;&gt;&gt; # therefore transpose H for visualization purposes. 
    &gt;&gt;&gt; H = H.T 
 
    :func:`imshow &lt;matplotlib.pyplot.imshow&gt;` can only display square bins: 
 
    &gt;&gt;&gt; fig = plt.figure(figsize=(7, 3)) 
    &gt;&gt;&gt; ax = fig.add_subplot(131, title='imshow: square bins') 
    &gt;&gt;&gt; plt.imshow(H, interpolation='nearest', origin='lower', 
    ...         extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]]) 
    &lt;matplotlib.image.AxesImage object at 0x...&gt; 
 
    :func:`pcolormesh &lt;matplotlib.pyplot.pcolormesh&gt;` can display actual edges: 
 
    &gt;&gt;&gt; ax = fig.add_subplot(132, title='pcolormesh: actual edges', 
    ...         aspect='equal') 
    &gt;&gt;&gt; X, Y = np.meshgrid(xedges, yedges) 
    &gt;&gt;&gt; ax.pcolormesh(X, Y, H) 
    &lt;matplotlib.collections.QuadMesh object at 0x...&gt; 
 
    :class:`NonUniformImage &lt;matplotlib.image.NonUniformImage&gt;` can be used to 
    display actual bin edges with interpolation: 
 
    &gt;&gt;&gt; ax = fig.add_subplot(133, title='NonUniformImage: interpolated', 
    ...         aspect='equal', xlim=xedges[[0, -1]], ylim=yedges[[0, -1]]) 
    &gt;&gt;&gt; im = NonUniformImage(ax, interpolation='bilinear') 
    &gt;&gt;&gt; xcenters = (xedges[:-1] + xedges[1:]) / 2 
    &gt;&gt;&gt; ycenters = (yedges[:-1] + yedges[1:]) / 2 
    &gt;&gt;&gt; im.set_data(xcenters, ycenters, H) 
    &gt;&gt;&gt; ax.images.append(im) 
    &gt;&gt;&gt; plt.show() 
 
    It is also possible to construct a 2-D histogram without specifying bin 
    edges: 
 
    &gt;&gt;&gt; # Generate non-symmetric test data 
    &gt;&gt;&gt; n = 10000 
    &gt;&gt;&gt; x = np.linspace(1, 100, n) 
    &gt;&gt;&gt; y = 2*np.log(x) + np.random.rand(n) - 0.5 
    &gt;&gt;&gt; # Compute 2d histogram. Note the order of x/y and xedges/yedges 
    &gt;&gt;&gt; H, yedges, xedges = np.histogram2d(y, x, bins=20) 
 
    Now we can plot the histogram using 
    :func:`pcolormesh &lt;matplotlib.pyplot.pcolormesh&gt;`, and a 
    :func:`hexbin &lt;matplotlib.pyplot.hexbin&gt;` for comparison. 
 
    &gt;&gt;&gt; # Plot histogram using pcolormesh 
    &gt;&gt;&gt; fig, (ax1, ax2) = plt.subplots(ncols=2, sharey=True) 
    &gt;&gt;&gt; ax1.pcolormesh(xedges, yedges, H, cmap='rainbow') 
    &gt;&gt;&gt; ax1.plot(x, 2*np.log(x), 'k-') 
    &gt;&gt;&gt; ax1.set_xlim(x.min(), x.max()) 
    &gt;&gt;&gt; ax1.set_ylim(y.min(), y.max()) 
    &gt;&gt;&gt; ax1.set_xlabel('x') 
    &gt;&gt;&gt; ax1.set_ylabel('y') 
    &gt;&gt;&gt; ax1.set_title('histogram2d') 
    &gt;&gt;&gt; ax1.grid() 
 
    &gt;&gt;&gt; # Create hexbin plot for comparison 
    &gt;&gt;&gt; ax2.hexbin(x, y, gridsize=20, cmap='rainbow') 
    &gt;&gt;&gt; ax2.plot(x, 2*np.log(x), 'k-') 
    &gt;&gt;&gt; ax2.set_title('hexbin') 
    &gt;&gt;&gt; ax2.set_xlim(x.min(), x.max()) 
    &gt;&gt;&gt; ax2.set_xlabel('x') 
    &gt;&gt;&gt; ax2.grid() 
 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">histogramdd</span>
    
    <span class="s2">if </span><span class="s1">len(x) != len(y):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'x and y must have the same length.'</span><span class="s1">)</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">N = len(bins)</span>
    <span class="s2">except </span><span class="s1">TypeError:</span>
        <span class="s1">N = </span><span class="s4">1</span>

    <span class="s2">if </span><span class="s1">N != </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">N != </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s1">xedges = yedges = asarray(bins)</span>
        <span class="s1">bins = [xedges</span><span class="s2">, </span><span class="s1">yedges]</span>
    <span class="s1">hist</span><span class="s2">, </span><span class="s1">edges = histogramdd([x</span><span class="s2">, </span><span class="s1">y]</span><span class="s2">, </span><span class="s1">bins</span><span class="s2">, </span><span class="s1">range</span><span class="s2">, </span><span class="s1">normed</span><span class="s2">, </span><span class="s1">weights</span><span class="s2">, </span><span class="s1">density)</span>
    <span class="s2">return </span><span class="s1">hist</span><span class="s2">, </span><span class="s1">edges[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">edges[</span><span class="s4">1</span><span class="s1">]</span>


<span class="s1">@set_module(</span><span class="s3">'numpy'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">mask_indices(n</span><span class="s2">, </span><span class="s1">mask_func</span><span class="s2">, </span><span class="s1">k=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the indices to access (n, n) arrays, given a masking function. 
 
    Assume `mask_func` is a function that, for a square array a of size 
    ``(n, n)`` with a possible offset argument `k`, when called as 
    ``mask_func(a, k)`` returns a new array with zeros in certain locations 
    (functions like `triu` or `tril` do precisely this). Then this function 
    returns the indices where the non-zero values would be located. 
 
    Parameters 
    ---------- 
    n : int 
        The returned indices will be valid to access arrays of shape (n, n). 
    mask_func : callable 
        A function whose call signature is similar to that of `triu`, `tril`. 
        That is, ``mask_func(x, k)`` returns a boolean array, shaped like `x`. 
        `k` is an optional argument to the function. 
    k : scalar 
        An optional argument which is passed through to `mask_func`. Functions 
        like `triu`, `tril` take a second argument that is interpreted as an 
        offset. 
 
    Returns 
    ------- 
    indices : tuple of arrays. 
        The `n` arrays of indices corresponding to the locations where 
        ``mask_func(np.ones((n, n)), k)`` is True. 
 
    See Also 
    -------- 
    triu, tril, triu_indices, tril_indices 
 
    Notes 
    ----- 
    .. versionadded:: 1.4.0 
 
    Examples 
    -------- 
    These are the indices that would allow you to access the upper triangular 
    part of any 3x3 array: 
 
    &gt;&gt;&gt; iu = np.mask_indices(3, np.triu) 
 
    For example, if `a` is a 3x3 array: 
 
    &gt;&gt;&gt; a = np.arange(9).reshape(3, 3) 
    &gt;&gt;&gt; a 
    array([[0, 1, 2], 
           [3, 4, 5], 
           [6, 7, 8]]) 
    &gt;&gt;&gt; a[iu] 
    array([0, 1, 2, 4, 5, 8]) 
 
    An offset can be passed also to the masking function.  This gets us the 
    indices starting on the first diagonal right of the main one: 
 
    &gt;&gt;&gt; iu1 = np.mask_indices(3, np.triu, 1) 
 
    with which we now extract only three elements: 
 
    &gt;&gt;&gt; a[iu1] 
    array([1, 2, 5]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = ones((n</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">, </span><span class="s1">int)</span>
    <span class="s1">a = mask_func(m</span><span class="s2">, </span><span class="s1">k)</span>
    <span class="s2">return </span><span class="s1">nonzero(a != </span><span class="s4">0</span><span class="s1">)</span>


<span class="s1">@set_module(</span><span class="s3">'numpy'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">tril_indices(n</span><span class="s2">, </span><span class="s1">k=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">m=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the indices for the lower-triangle of an (n, m) array. 
 
    Parameters 
    ---------- 
    n : int 
        The row dimension of the arrays for which the returned 
        indices will be valid. 
    k : int, optional 
        Diagonal offset (see `tril` for details). 
    m : int, optional 
        .. versionadded:: 1.9.0 
 
        The column dimension of the arrays for which the returned 
        arrays will be valid. 
        By default `m` is taken equal to `n`. 
 
 
    Returns 
    ------- 
    inds : tuple of arrays 
        The indices for the triangle. The returned tuple contains two arrays, 
        each with the indices along one dimension of the array. 
 
    See also 
    -------- 
    triu_indices : similar function, for upper-triangular. 
    mask_indices : generic function accepting an arbitrary mask function. 
    tril, triu 
 
    Notes 
    ----- 
    .. versionadded:: 1.4.0 
 
    Examples 
    -------- 
    Compute two different sets of indices to access 4x4 arrays, one for the 
    lower triangular part starting at the main diagonal, and one starting two 
    diagonals further right: 
 
    &gt;&gt;&gt; il1 = np.tril_indices(4) 
    &gt;&gt;&gt; il2 = np.tril_indices(4, 2) 
 
    Here is how they can be used with a sample array: 
 
    &gt;&gt;&gt; a = np.arange(16).reshape(4, 4) 
    &gt;&gt;&gt; a 
    array([[ 0,  1,  2,  3], 
           [ 4,  5,  6,  7], 
           [ 8,  9, 10, 11], 
           [12, 13, 14, 15]]) 
 
    Both for indexing: 
 
    &gt;&gt;&gt; a[il1] 
    array([ 0,  4,  5, ..., 13, 14, 15]) 
 
    And for assigning values: 
 
    &gt;&gt;&gt; a[il1] = -1 
    &gt;&gt;&gt; a 
    array([[-1,  1,  2,  3], 
           [-1, -1,  6,  7], 
           [-1, -1, -1, 11], 
           [-1, -1, -1, -1]]) 
 
    These cover almost the whole array (two diagonals right of the main one): 
 
    &gt;&gt;&gt; a[il2] = -10 
    &gt;&gt;&gt; a 
    array([[-10, -10, -10,   3], 
           [-10, -10, -10, -10], 
           [-10, -10, -10, -10], 
           [-10, -10, -10, -10]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">tri_ = tri(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">k=k</span><span class="s2">, </span><span class="s1">dtype=bool)</span>

    <span class="s2">return </span><span class="s1">tuple(broadcast_to(inds</span><span class="s2">, </span><span class="s1">tri_.shape)[tri_]</span>
                 <span class="s2">for </span><span class="s1">inds </span><span class="s2">in </span><span class="s1">indices(tri_.shape</span><span class="s2">, </span><span class="s1">sparse=</span><span class="s2">True</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">_trilu_indices_form_dispatcher(arr</span><span class="s2">, </span><span class="s1">k=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">(arr</span><span class="s2">,</span><span class="s1">)</span>


<span class="s1">@array_function_dispatch(_trilu_indices_form_dispatcher)</span>
<span class="s2">def </span><span class="s1">tril_indices_from(arr</span><span class="s2">, </span><span class="s1">k=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the indices for the lower-triangle of arr. 
 
    See `tril_indices` for full details. 
 
    Parameters 
    ---------- 
    arr : array_like 
        The indices will be valid for square arrays whose dimensions are 
        the same as arr. 
    k : int, optional 
        Diagonal offset (see `tril` for details). 
 
    See Also 
    -------- 
    tril_indices, tril 
 
    Notes 
    ----- 
    .. versionadded:: 1.4.0 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">arr.ndim != </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;input array must be 2-d&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">tril_indices(arr.shape[-</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">k=k</span><span class="s2">, </span><span class="s1">m=arr.shape[-</span><span class="s4">1</span><span class="s1">])</span>


<span class="s1">@set_module(</span><span class="s3">'numpy'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">triu_indices(n</span><span class="s2">, </span><span class="s1">k=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">m=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the indices for the upper-triangle of an (n, m) array. 
 
    Parameters 
    ---------- 
    n : int 
        The size of the arrays for which the returned indices will 
        be valid. 
    k : int, optional 
        Diagonal offset (see `triu` for details). 
    m : int, optional 
        .. versionadded:: 1.9.0 
 
        The column dimension of the arrays for which the returned 
        arrays will be valid. 
        By default `m` is taken equal to `n`. 
 
 
    Returns 
    ------- 
    inds : tuple, shape(2) of ndarrays, shape(`n`) 
        The indices for the triangle. The returned tuple contains two arrays, 
        each with the indices along one dimension of the array.  Can be used 
        to slice a ndarray of shape(`n`, `n`). 
 
    See also 
    -------- 
    tril_indices : similar function, for lower-triangular. 
    mask_indices : generic function accepting an arbitrary mask function. 
    triu, tril 
 
    Notes 
    ----- 
    .. versionadded:: 1.4.0 
 
    Examples 
    -------- 
    Compute two different sets of indices to access 4x4 arrays, one for the 
    upper triangular part starting at the main diagonal, and one starting two 
    diagonals further right: 
 
    &gt;&gt;&gt; iu1 = np.triu_indices(4) 
    &gt;&gt;&gt; iu2 = np.triu_indices(4, 2) 
 
    Here is how they can be used with a sample array: 
 
    &gt;&gt;&gt; a = np.arange(16).reshape(4, 4) 
    &gt;&gt;&gt; a 
    array([[ 0,  1,  2,  3], 
           [ 4,  5,  6,  7], 
           [ 8,  9, 10, 11], 
           [12, 13, 14, 15]]) 
 
    Both for indexing: 
 
    &gt;&gt;&gt; a[iu1] 
    array([ 0,  1,  2, ..., 10, 11, 15]) 
 
    And for assigning values: 
 
    &gt;&gt;&gt; a[iu1] = -1 
    &gt;&gt;&gt; a 
    array([[-1, -1, -1, -1], 
           [ 4, -1, -1, -1], 
           [ 8,  9, -1, -1], 
           [12, 13, 14, -1]]) 
 
    These cover only a small part of the whole array (two diagonals right 
    of the main one): 
 
    &gt;&gt;&gt; a[iu2] = -10 
    &gt;&gt;&gt; a 
    array([[ -1,  -1, -10, -10], 
           [  4,  -1,  -1, -10], 
           [  8,   9,  -1,  -1], 
           [ 12,  13,  14,  -1]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">tri_ = ~tri(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">k=k - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype=bool)</span>

    <span class="s2">return </span><span class="s1">tuple(broadcast_to(inds</span><span class="s2">, </span><span class="s1">tri_.shape)[tri_]</span>
                 <span class="s2">for </span><span class="s1">inds </span><span class="s2">in </span><span class="s1">indices(tri_.shape</span><span class="s2">, </span><span class="s1">sparse=</span><span class="s2">True</span><span class="s1">))</span>


<span class="s1">@array_function_dispatch(_trilu_indices_form_dispatcher)</span>
<span class="s2">def </span><span class="s1">triu_indices_from(arr</span><span class="s2">, </span><span class="s1">k=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the indices for the upper-triangle of arr. 
 
    See `triu_indices` for full details. 
 
    Parameters 
    ---------- 
    arr : ndarray, shape(N, N) 
        The indices will be valid for square arrays. 
    k : int, optional 
        Diagonal offset (see `triu` for details). 
 
    Returns 
    ------- 
    triu_indices_from : tuple, shape(2) of ndarray, shape(N) 
        Indices for the upper-triangle of `arr`. 
 
    See Also 
    -------- 
    triu_indices, triu 
 
    Notes 
    ----- 
    .. versionadded:: 1.4.0 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">arr.ndim != </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;input array must be 2-d&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">triu_indices(arr.shape[-</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">k=k</span><span class="s2">, </span><span class="s1">m=arr.shape[-</span><span class="s4">1</span><span class="s1">])</span>
</pre>
</body>
</html>