<html>
<head>
<title>_hexbin_mapbox.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_hexbin_mapbox.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">plotly.express._core </span><span class="s0">import </span><span class="s1">build_dataframe</span>
<span class="s0">from </span><span class="s1">plotly.express._doc </span><span class="s0">import </span><span class="s1">make_docstring</span>
<span class="s0">from </span><span class="s1">plotly.express._chart_types </span><span class="s0">import </span><span class="s1">choropleth_mapbox</span><span class="s0">, </span><span class="s1">scatter_mapbox</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>


<span class="s0">def </span><span class="s1">_project_latlon_to_wgs84(lat</span><span class="s0">, </span><span class="s1">lon):</span>
    <span class="s2">&quot;&quot;&quot; 
    Projects lat and lon to WGS84, used to get regular hexagons on a mapbox map 
    &quot;&quot;&quot;</span>
    <span class="s1">x = lon * np.pi / </span><span class="s3">180</span>
    <span class="s1">y = np.arctanh(np.sin(lat * np.pi / </span><span class="s3">180</span><span class="s1">))</span>
    <span class="s0">return </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span>


<span class="s0">def </span><span class="s1">_project_wgs84_to_latlon(x</span><span class="s0">, </span><span class="s1">y):</span>
    <span class="s2">&quot;&quot;&quot; 
    Projects WGS84 to lat and lon, used to get regular hexagons on a mapbox map 
    &quot;&quot;&quot;</span>
    <span class="s1">lon = x * </span><span class="s3">180 </span><span class="s1">/ np.pi</span>
    <span class="s1">lat = (</span><span class="s3">2 </span><span class="s1">* np.arctan(np.exp(y)) - np.pi / </span><span class="s3">2</span><span class="s1">) * </span><span class="s3">180 </span><span class="s1">/ np.pi</span>
    <span class="s0">return </span><span class="s1">lat</span><span class="s0">, </span><span class="s1">lon</span>


<span class="s0">def </span><span class="s1">_getBoundsZoomLevel(lon_min</span><span class="s0">, </span><span class="s1">lon_max</span><span class="s0">, </span><span class="s1">lat_min</span><span class="s0">, </span><span class="s1">lat_max</span><span class="s0">, </span><span class="s1">mapDim):</span>
    <span class="s2">&quot;&quot;&quot; 
    Get the mapbox zoom level given bounds and a figure dimension 
    Source: https://stackoverflow.com/questions/6048975/google-maps-v3-how-to-calculate-the-zoom-level-for-a-given-bounds 
    &quot;&quot;&quot;</span>

    <span class="s1">scale = (</span>
        <span class="s3">2  </span><span class="s4"># adjustment to reflect MapBox base tiles are 512x512 vs. Google's 256x256</span>
    <span class="s1">)</span>
    <span class="s1">WORLD_DIM = {</span><span class="s5">&quot;height&quot;</span><span class="s1">: </span><span class="s3">256 </span><span class="s1">* scale</span><span class="s0">, </span><span class="s5">&quot;width&quot;</span><span class="s1">: </span><span class="s3">256 </span><span class="s1">* scale}</span>
    <span class="s1">ZOOM_MAX = </span><span class="s3">18</span>

    <span class="s0">def </span><span class="s1">latRad(lat):</span>
        <span class="s1">sin = np.sin(lat * np.pi / </span><span class="s3">180</span><span class="s1">)</span>
        <span class="s1">radX2 = np.log((</span><span class="s3">1 </span><span class="s1">+ sin) / (</span><span class="s3">1 </span><span class="s1">- sin)) / </span><span class="s3">2</span>
        <span class="s0">return </span><span class="s1">max(min(radX2</span><span class="s0">, </span><span class="s1">np.pi)</span><span class="s0">, </span><span class="s1">-np.pi) / </span><span class="s3">2</span>

    <span class="s0">def </span><span class="s1">zoom(mapPx</span><span class="s0">, </span><span class="s1">worldPx</span><span class="s0">, </span><span class="s1">fraction):</span>
        <span class="s0">return </span><span class="s3">0.95 </span><span class="s1">* np.log(mapPx / worldPx / fraction) / np.log(</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s1">latFraction = (latRad(lat_max) - latRad(lat_min)) / np.pi</span>

    <span class="s1">lngDiff = lon_max - lon_min</span>
    <span class="s1">lngFraction = ((lngDiff + </span><span class="s3">360</span><span class="s1">) </span><span class="s0">if </span><span class="s1">lngDiff &lt; </span><span class="s3">0 </span><span class="s0">else </span><span class="s1">lngDiff) / </span><span class="s3">360</span>

    <span class="s1">latZoom = zoom(mapDim[</span><span class="s5">&quot;height&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">WORLD_DIM[</span><span class="s5">&quot;height&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">latFraction)</span>
    <span class="s1">lngZoom = zoom(mapDim[</span><span class="s5">&quot;width&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">WORLD_DIM[</span><span class="s5">&quot;width&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">lngFraction)</span>

    <span class="s0">return </span><span class="s1">min(latZoom</span><span class="s0">, </span><span class="s1">lngZoom</span><span class="s0">, </span><span class="s1">ZOOM_MAX)</span>


<span class="s0">def </span><span class="s1">_compute_hexbin(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">x_range</span><span class="s0">, </span><span class="s1">y_range</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">nx</span><span class="s0">, </span><span class="s1">agg_func</span><span class="s0">, </span><span class="s1">min_count):</span>
    <span class="s2">&quot;&quot;&quot; 
    Computes the aggregation at hexagonal bin level. 
    Also defines the coordinates of the hexagons for plotting. 
    The binning is inspired by matplotlib's implementation. 
 
    Parameters 
    ---------- 
    x : np.ndarray 
        Array of x values (shape N) 
    y : np.ndarray 
        Array of y values (shape N) 
    x_range : np.ndarray 
        Min and max x (shape 2) 
    y_range : np.ndarray 
        Min and max y (shape 2) 
    color : np.ndarray 
        Metric to aggregate at hexagon level (shape N) 
    nx : int 
        Number of hexagons horizontally 
    agg_func : function 
        Numpy compatible aggregator, this function must take a one-dimensional 
        np.ndarray as input and output a scalar 
    min_count : int 
        Minimum number of points in the hexagon for the hexagon to be displayed 
 
    Returns 
    ------- 
    np.ndarray 
        X coordinates of each hexagon (shape M x 6) 
    np.ndarray 
        Y coordinates of each hexagon (shape M x 6) 
    np.ndarray 
        Centers of the hexagons (shape M x 2) 
    np.ndarray 
        Aggregated value in each hexagon (shape M) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xmin = x_range.min()</span>
    <span class="s1">xmax = x_range.max()</span>
    <span class="s1">ymin = y_range.min()</span>
    <span class="s1">ymax = y_range.max()</span>

    <span class="s4"># In the x-direction, the hexagons exactly cover the region from</span>
    <span class="s4"># xmin to xmax. Need some padding to avoid roundoff errors.</span>
    <span class="s1">padding = </span><span class="s3">1.0e-9 </span><span class="s1">* (xmax - xmin)</span>
    <span class="s1">xmin -= padding</span>
    <span class="s1">xmax += padding</span>

    <span class="s1">Dx = xmax - xmin</span>
    <span class="s1">Dy = ymax - ymin</span>
    <span class="s0">if </span><span class="s1">Dx == </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">Dy &gt; </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">dx = Dy / nx</span>
    <span class="s0">elif </span><span class="s1">Dx == </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">Dy == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">dx</span><span class="s0">, </span><span class="s1">_ = _project_latlon_to_wgs84(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">dx = Dx / nx</span>
    <span class="s1">dy = dx * np.sqrt(</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">ny = np.ceil(Dy / dy).astype(int)</span>

    <span class="s4"># Center the hexagons vertically since we only want regular hexagons</span>
    <span class="s1">ymin -= (ymin + dy * ny - ymax) / </span><span class="s3">2</span>

    <span class="s1">x = (x - xmin) / dx</span>
    <span class="s1">y = (y - ymin) / dy</span>
    <span class="s1">ix1 = np.round(x).astype(int)</span>
    <span class="s1">iy1 = np.round(y).astype(int)</span>
    <span class="s1">ix2 = np.floor(x).astype(int)</span>
    <span class="s1">iy2 = np.floor(y).astype(int)</span>

    <span class="s1">nx1 = nx + </span><span class="s3">1</span>
    <span class="s1">ny1 = ny + </span><span class="s3">1</span>
    <span class="s1">nx2 = nx</span>
    <span class="s1">ny2 = ny</span>
    <span class="s1">n = nx1 * ny1 + nx2 * ny2</span>

    <span class="s1">d1 = (x - ix1) ** </span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">3.0 </span><span class="s1">* (y - iy1) ** </span><span class="s3">2</span>
    <span class="s1">d2 = (x - ix2 - </span><span class="s3">0.5</span><span class="s1">) ** </span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">3.0 </span><span class="s1">* (y - iy2 - </span><span class="s3">0.5</span><span class="s1">) ** </span><span class="s3">2</span>
    <span class="s1">bdist = d1 &lt; d2</span>

    <span class="s0">if </span><span class="s1">color </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">lattice1 = np.zeros((nx1</span><span class="s0">, </span><span class="s1">ny1))</span>
        <span class="s1">lattice2 = np.zeros((nx2</span><span class="s0">, </span><span class="s1">ny2))</span>
        <span class="s1">c1 = (</span><span class="s3">0 </span><span class="s1">&lt;= ix1) &amp; (ix1 &lt; nx1) &amp; (</span><span class="s3">0 </span><span class="s1">&lt;= iy1) &amp; (iy1 &lt; ny1) &amp; bdist</span>
        <span class="s1">c2 = (</span><span class="s3">0 </span><span class="s1">&lt;= ix2) &amp; (ix2 &lt; nx2) &amp; (</span><span class="s3">0 </span><span class="s1">&lt;= iy2) &amp; (iy2 &lt; ny2) &amp; ~bdist</span>
        <span class="s1">np.add.at(lattice1</span><span class="s0">, </span><span class="s1">(ix1[c1]</span><span class="s0">, </span><span class="s1">iy1[c1])</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">np.add.at(lattice2</span><span class="s0">, </span><span class="s1">(ix2[c2]</span><span class="s0">, </span><span class="s1">iy2[c2])</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">min_count </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">lattice1[lattice1 &lt; min_count] = np.nan</span>
            <span class="s1">lattice2[lattice2 &lt; min_count] = np.nan</span>
        <span class="s1">accum = np.concatenate([lattice1.ravel()</span><span class="s0">, </span><span class="s1">lattice2.ravel()])</span>
        <span class="s1">good_idxs = ~np.isnan(accum)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">min_count </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">min_count = </span><span class="s3">1</span>

        <span class="s4"># create accumulation arrays</span>
        <span class="s1">lattice1 = np.empty((nx1</span><span class="s0">, </span><span class="s1">ny1)</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(nx1):</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(ny1):</span>
                <span class="s1">lattice1[i</span><span class="s0">, </span><span class="s1">j] = []</span>
        <span class="s1">lattice2 = np.empty((nx2</span><span class="s0">, </span><span class="s1">ny2)</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(nx2):</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(ny2):</span>
                <span class="s1">lattice2[i</span><span class="s0">, </span><span class="s1">j] = []</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(x)):</span>
            <span class="s0">if </span><span class="s1">bdist[i]:</span>
                <span class="s0">if </span><span class="s3">0 </span><span class="s1">&lt;= ix1[i] &lt; nx1 </span><span class="s0">and </span><span class="s3">0 </span><span class="s1">&lt;= iy1[i] &lt; ny1:</span>
                    <span class="s1">lattice1[ix1[i]</span><span class="s0">, </span><span class="s1">iy1[i]].append(color[i])</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s3">0 </span><span class="s1">&lt;= ix2[i] &lt; nx2 </span><span class="s0">and </span><span class="s3">0 </span><span class="s1">&lt;= iy2[i] &lt; ny2:</span>
                    <span class="s1">lattice2[ix2[i]</span><span class="s0">, </span><span class="s1">iy2[i]].append(color[i])</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(nx1):</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(ny1):</span>
                <span class="s1">vals = lattice1[i</span><span class="s0">, </span><span class="s1">j]</span>
                <span class="s0">if </span><span class="s1">len(vals) &gt;= min_count:</span>
                    <span class="s1">lattice1[i</span><span class="s0">, </span><span class="s1">j] = agg_func(vals)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">lattice1[i</span><span class="s0">, </span><span class="s1">j] = np.nan</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(nx2):</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(ny2):</span>
                <span class="s1">vals = lattice2[i</span><span class="s0">, </span><span class="s1">j]</span>
                <span class="s0">if </span><span class="s1">len(vals) &gt;= min_count:</span>
                    <span class="s1">lattice2[i</span><span class="s0">, </span><span class="s1">j] = agg_func(vals)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">lattice2[i</span><span class="s0">, </span><span class="s1">j] = np.nan</span>

        <span class="s1">accum = np.hstack(</span>
            <span class="s1">(lattice1.astype(float).ravel()</span><span class="s0">, </span><span class="s1">lattice2.astype(float).ravel())</span>
        <span class="s1">)</span>
        <span class="s1">good_idxs = ~np.isnan(accum)</span>

    <span class="s1">agreggated_value = accum[good_idxs]</span>

    <span class="s1">centers = np.zeros((n</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">float)</span>
    <span class="s1">centers[: nx1 * ny1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] = np.repeat(np.arange(nx1)</span><span class="s0">, </span><span class="s1">ny1)</span>
    <span class="s1">centers[: nx1 * ny1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">] = np.tile(np.arange(ny1)</span><span class="s0">, </span><span class="s1">nx1)</span>
    <span class="s1">centers[nx1 * ny1 :</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] = np.repeat(np.arange(nx2) + </span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">ny2)</span>
    <span class="s1">centers[nx1 * ny1 :</span><span class="s0">, </span><span class="s3">1</span><span class="s1">] = np.tile(np.arange(ny2)</span><span class="s0">, </span><span class="s1">nx2) + </span><span class="s3">0.5</span>
    <span class="s1">centers[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] *= dx</span>
    <span class="s1">centers[:</span><span class="s0">, </span><span class="s3">1</span><span class="s1">] *= dy</span>
    <span class="s1">centers[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] += xmin</span>
    <span class="s1">centers[:</span><span class="s0">, </span><span class="s3">1</span><span class="s1">] += ymin</span>
    <span class="s1">centers = centers[good_idxs]</span>

    <span class="s4"># Define normalised regular hexagon coordinates</span>
    <span class="s1">hx = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.5</span><span class="s1">]</span>
    <span class="s1">hy = [</span>
        <span class="s1">-</span><span class="s3">0.5 </span><span class="s1">/ np.cos(np.pi / </span><span class="s3">6</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">-</span><span class="s3">0.5 </span><span class="s1">* np.tan(np.pi / </span><span class="s3">6</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s3">0.5 </span><span class="s1">* np.tan(np.pi / </span><span class="s3">6</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s3">0.5 </span><span class="s1">/ np.cos(np.pi / </span><span class="s3">6</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s3">0.5 </span><span class="s1">* np.tan(np.pi / </span><span class="s3">6</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">-</span><span class="s3">0.5 </span><span class="s1">* np.tan(np.pi / </span><span class="s3">6</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span>

    <span class="s4"># Number of hexagons needed</span>
    <span class="s1">m = len(centers)</span>

    <span class="s4"># Coordinates for all hexagonal patches</span>
    <span class="s1">hxs = np.array([hx] * m) * dx + np.vstack(centers[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>
    <span class="s1">hys = np.array([hy] * m) * dy / np.sqrt(</span><span class="s3">3</span><span class="s1">) + np.vstack(centers[:</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s0">return </span><span class="s1">hxs</span><span class="s0">, </span><span class="s1">hys</span><span class="s0">, </span><span class="s1">centers</span><span class="s0">, </span><span class="s1">agreggated_value</span>


<span class="s0">def </span><span class="s1">_compute_wgs84_hexbin(</span>
    <span class="s1">lat=</span><span class="s0">None,</span>
    <span class="s1">lon=</span><span class="s0">None,</span>
    <span class="s1">lat_range=</span><span class="s0">None,</span>
    <span class="s1">lon_range=</span><span class="s0">None,</span>
    <span class="s1">color=</span><span class="s0">None,</span>
    <span class="s1">nx=</span><span class="s0">None,</span>
    <span class="s1">agg_func=</span><span class="s0">None,</span>
    <span class="s1">min_count=</span><span class="s0">None,</span>
<span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Computes the lat-lon aggregation at hexagonal bin level. 
    Latitude and longitude need to be projected to WGS84 before aggregating 
    in order to display regular hexagons on the map. 
 
    Parameters 
    ---------- 
    lat : np.ndarray 
        Array of latitudes (shape N) 
    lon : np.ndarray 
        Array of longitudes (shape N) 
    lat_range : np.ndarray 
        Min and max latitudes (shape 2) 
    lon_range : np.ndarray 
        Min and max longitudes (shape 2) 
    color : np.ndarray 
        Metric to aggregate at hexagon level (shape N) 
    nx : int 
        Number of hexagons horizontally 
    agg_func : function 
        Numpy compatible aggregator, this function must take a one-dimensional 
        np.ndarray as input and output a scalar 
    min_count : int 
        Minimum number of points in the hexagon for the hexagon to be displayed 
 
    Returns 
    ------- 
    np.ndarray 
        Lat coordinates of each hexagon (shape M x 6) 
    np.ndarray 
        Lon coordinates of each hexagon (shape M x 6) 
    pd.Series 
        Unique id for each hexagon, to be used in the geojson data (shape M) 
    np.ndarray 
        Aggregated value in each hexagon (shape M) 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># Project to WGS 84</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = _project_latlon_to_wgs84(lat</span><span class="s0">, </span><span class="s1">lon)</span>

    <span class="s0">if </span><span class="s1">lat_range </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">lat_range = np.array([lat.min()</span><span class="s0">, </span><span class="s1">lat.max()])</span>
    <span class="s0">if </span><span class="s1">lon_range </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">lon_range = np.array([lon.min()</span><span class="s0">, </span><span class="s1">lon.max()])</span>

    <span class="s1">x_range</span><span class="s0">, </span><span class="s1">y_range = _project_latlon_to_wgs84(lat_range</span><span class="s0">, </span><span class="s1">lon_range)</span>

    <span class="s1">hxs</span><span class="s0">, </span><span class="s1">hys</span><span class="s0">, </span><span class="s1">centers</span><span class="s0">, </span><span class="s1">agreggated_value = _compute_hexbin(</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">x_range</span><span class="s0">, </span><span class="s1">y_range</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">nx</span><span class="s0">, </span><span class="s1">agg_func</span><span class="s0">, </span><span class="s1">min_count</span>
    <span class="s1">)</span>

    <span class="s4"># Convert back to lat-lon</span>
    <span class="s1">hexagons_lats</span><span class="s0">, </span><span class="s1">hexagons_lons = _project_wgs84_to_latlon(hxs</span><span class="s0">, </span><span class="s1">hys)</span>

    <span class="s4"># Create unique feature id based on hexagon center</span>
    <span class="s1">centers = centers.astype(str)</span>
    <span class="s1">hexagons_ids = pd.Series(centers[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]) + </span><span class="s5">&quot;,&quot; </span><span class="s1">+ pd.Series(centers[:</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s0">return </span><span class="s1">hexagons_lats</span><span class="s0">, </span><span class="s1">hexagons_lons</span><span class="s0">, </span><span class="s1">hexagons_ids</span><span class="s0">, </span><span class="s1">agreggated_value</span>


<span class="s0">def </span><span class="s1">_hexagons_to_geojson(hexagons_lats</span><span class="s0">, </span><span class="s1">hexagons_lons</span><span class="s0">, </span><span class="s1">ids=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Creates a geojson of hexagonal features based on the outputs of 
    _compute_wgs84_hexbin 
    &quot;&quot;&quot;</span>
    <span class="s1">features = []</span>
    <span class="s0">if </span><span class="s1">ids </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">ids = np.arange(len(hexagons_lats))</span>
    <span class="s0">for </span><span class="s1">lat</span><span class="s0">, </span><span class="s1">lon</span><span class="s0">, </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">zip(hexagons_lats</span><span class="s0">, </span><span class="s1">hexagons_lons</span><span class="s0">, </span><span class="s1">ids):</span>
        <span class="s1">points = np.array([lon</span><span class="s0">, </span><span class="s1">lat]).T.tolist()</span>
        <span class="s1">points.append(points[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">features.append(</span>
            <span class="s1">dict(</span>
                <span class="s1">type=</span><span class="s5">&quot;Feature&quot;</span><span class="s0">,</span>
                <span class="s1">id=idx</span><span class="s0">,</span>
                <span class="s1">geometry=dict(type=</span><span class="s5">&quot;Polygon&quot;</span><span class="s0">, </span><span class="s1">coordinates=[points])</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">dict(type=</span><span class="s5">&quot;FeatureCollection&quot;</span><span class="s0">, </span><span class="s1">features=features)</span>


<span class="s0">def </span><span class="s1">create_hexbin_mapbox(</span>
    <span class="s1">data_frame=</span><span class="s0">None,</span>
    <span class="s1">lat=</span><span class="s0">None,</span>
    <span class="s1">lon=</span><span class="s0">None,</span>
    <span class="s1">color=</span><span class="s0">None,</span>
    <span class="s1">nx_hexagon=</span><span class="s3">5</span><span class="s0">,</span>
    <span class="s1">agg_func=</span><span class="s0">None,</span>
    <span class="s1">animation_frame=</span><span class="s0">None,</span>
    <span class="s1">color_discrete_sequence=</span><span class="s0">None,</span>
    <span class="s1">color_discrete_map={}</span><span class="s0">,</span>
    <span class="s1">labels={}</span><span class="s0">,</span>
    <span class="s1">color_continuous_scale=</span><span class="s0">None,</span>
    <span class="s1">range_color=</span><span class="s0">None,</span>
    <span class="s1">color_continuous_midpoint=</span><span class="s0">None,</span>
    <span class="s1">opacity=</span><span class="s0">None,</span>
    <span class="s1">zoom=</span><span class="s0">None,</span>
    <span class="s1">center=</span><span class="s0">None,</span>
    <span class="s1">mapbox_style=</span><span class="s0">None,</span>
    <span class="s1">title=</span><span class="s0">None,</span>
    <span class="s1">template=</span><span class="s0">None,</span>
    <span class="s1">width=</span><span class="s0">None,</span>
    <span class="s1">height=</span><span class="s0">None,</span>
    <span class="s1">min_count=</span><span class="s0">None,</span>
    <span class="s1">show_original_data=</span><span class="s0">False,</span>
    <span class="s1">original_data_marker=</span><span class="s0">None,</span>
<span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Returns a figure aggregating scattered points into connected hexagons  
    &quot;&quot;&quot;</span>
    <span class="s1">args = build_dataframe(args=locals()</span><span class="s0">, </span><span class="s1">constructor=</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">agg_func </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">agg_func = np.mean</span>

    <span class="s1">lat_range = args[</span><span class="s5">&quot;data_frame&quot;</span><span class="s1">][args[</span><span class="s5">&quot;lat&quot;</span><span class="s1">]].agg([</span><span class="s5">&quot;min&quot;</span><span class="s0">, </span><span class="s5">&quot;max&quot;</span><span class="s1">]).values</span>
    <span class="s1">lon_range = args[</span><span class="s5">&quot;data_frame&quot;</span><span class="s1">][args[</span><span class="s5">&quot;lon&quot;</span><span class="s1">]].agg([</span><span class="s5">&quot;min&quot;</span><span class="s0">, </span><span class="s5">&quot;max&quot;</span><span class="s1">]).values</span>

    <span class="s1">hexagons_lats</span><span class="s0">, </span><span class="s1">hexagons_lons</span><span class="s0">, </span><span class="s1">hexagons_ids</span><span class="s0">, </span><span class="s1">count = _compute_wgs84_hexbin(</span>
        <span class="s1">lat=args[</span><span class="s5">&quot;data_frame&quot;</span><span class="s1">][args[</span><span class="s5">&quot;lat&quot;</span><span class="s1">]].values</span><span class="s0">,</span>
        <span class="s1">lon=args[</span><span class="s5">&quot;data_frame&quot;</span><span class="s1">][args[</span><span class="s5">&quot;lon&quot;</span><span class="s1">]].values</span><span class="s0">,</span>
        <span class="s1">lat_range=lat_range</span><span class="s0">,</span>
        <span class="s1">lon_range=lon_range</span><span class="s0">,</span>
        <span class="s1">color=</span><span class="s0">None,</span>
        <span class="s1">nx=nx_hexagon</span><span class="s0">,</span>
        <span class="s1">agg_func=agg_func</span><span class="s0">,</span>
        <span class="s1">min_count=min_count</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">geojson = _hexagons_to_geojson(hexagons_lats</span><span class="s0">, </span><span class="s1">hexagons_lons</span><span class="s0">, </span><span class="s1">hexagons_ids)</span>

    <span class="s0">if </span><span class="s1">zoom </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">height </span><span class="s0">is None and </span><span class="s1">width </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">mapDim = dict(height=</span><span class="s3">450</span><span class="s0">, </span><span class="s1">width=</span><span class="s3">450</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">height </span><span class="s0">is None and </span><span class="s1">width </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">mapDim = dict(height=</span><span class="s3">450</span><span class="s0">, </span><span class="s1">width=width)</span>
        <span class="s0">elif </span><span class="s1">height </span><span class="s0">is not None and </span><span class="s1">width </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">mapDim = dict(height=height</span><span class="s0">, </span><span class="s1">width=height)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">mapDim = dict(height=height</span><span class="s0">, </span><span class="s1">width=width)</span>
        <span class="s1">zoom = _getBoundsZoomLevel(</span>
            <span class="s1">lon_range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">lon_range[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">lat_range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">lat_range[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mapDim</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">center </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">center = dict(lat=lat_range.mean()</span><span class="s0">, </span><span class="s1">lon=lon_range.mean())</span>

    <span class="s0">if </span><span class="s1">args[</span><span class="s5">&quot;animation_frame&quot;</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">groups = args[</span><span class="s5">&quot;data_frame&quot;</span><span class="s1">].groupby(args[</span><span class="s5">&quot;animation_frame&quot;</span><span class="s1">]).groups</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">groups = {</span><span class="s3">0</span><span class="s1">: args[</span><span class="s5">&quot;data_frame&quot;</span><span class="s1">].index}</span>

    <span class="s1">agg_data_frame_list = []</span>
    <span class="s0">for </span><span class="s1">frame</span><span class="s0">, </span><span class="s1">index </span><span class="s0">in </span><span class="s1">groups.items():</span>
        <span class="s1">df = args[</span><span class="s5">&quot;data_frame&quot;</span><span class="s1">].loc[index]</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">hexagons_ids</span><span class="s0">, </span><span class="s1">aggregated_value = _compute_wgs84_hexbin(</span>
            <span class="s1">lat=df[args[</span><span class="s5">&quot;lat&quot;</span><span class="s1">]].values</span><span class="s0">,</span>
            <span class="s1">lon=df[args[</span><span class="s5">&quot;lon&quot;</span><span class="s1">]].values</span><span class="s0">,</span>
            <span class="s1">lat_range=lat_range</span><span class="s0">,</span>
            <span class="s1">lon_range=lon_range</span><span class="s0">,</span>
            <span class="s1">color=df[args[</span><span class="s5">&quot;color&quot;</span><span class="s1">]].values </span><span class="s0">if </span><span class="s1">args[</span><span class="s5">&quot;color&quot;</span><span class="s1">] </span><span class="s0">else None,</span>
            <span class="s1">nx=nx_hexagon</span><span class="s0">,</span>
            <span class="s1">agg_func=agg_func</span><span class="s0">,</span>
            <span class="s1">min_count=min_count</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">agg_data_frame_list.append(</span>
            <span class="s1">pd.DataFrame(</span>
                <span class="s1">np.c_[hexagons_ids</span><span class="s0">, </span><span class="s1">aggregated_value]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s5">&quot;locations&quot;</span><span class="s0">, </span><span class="s5">&quot;color&quot;</span><span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s1">agg_data_frame = (</span>
        <span class="s1">pd.concat(agg_data_frame_list</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">keys=groups.keys())</span>
        <span class="s1">.rename_axis(index=(</span><span class="s5">&quot;frame&quot;</span><span class="s0">, </span><span class="s5">&quot;index&quot;</span><span class="s1">))</span>
        <span class="s1">.reset_index(</span><span class="s5">&quot;frame&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>

    <span class="s1">agg_data_frame[</span><span class="s5">&quot;color&quot;</span><span class="s1">] = pd.to_numeric(agg_data_frame[</span><span class="s5">&quot;color&quot;</span><span class="s1">])</span>

    <span class="s0">if </span><span class="s1">range_color </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">range_color = [agg_data_frame[</span><span class="s5">&quot;color&quot;</span><span class="s1">].min()</span><span class="s0">, </span><span class="s1">agg_data_frame[</span><span class="s5">&quot;color&quot;</span><span class="s1">].max()]</span>

    <span class="s1">fig = choropleth_mapbox(</span>
        <span class="s1">data_frame=agg_data_frame</span><span class="s0">,</span>
        <span class="s1">geojson=geojson</span><span class="s0">,</span>
        <span class="s1">locations=</span><span class="s5">&quot;locations&quot;</span><span class="s0">,</span>
        <span class="s1">color=</span><span class="s5">&quot;color&quot;</span><span class="s0">,</span>
        <span class="s1">hover_data={</span><span class="s5">&quot;color&quot;</span><span class="s1">: </span><span class="s0">True, </span><span class="s5">&quot;locations&quot;</span><span class="s1">: </span><span class="s0">False, </span><span class="s5">&quot;frame&quot;</span><span class="s1">: </span><span class="s0">False</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s1">animation_frame=(</span><span class="s5">&quot;frame&quot; </span><span class="s0">if </span><span class="s1">args[</span><span class="s5">&quot;animation_frame&quot;</span><span class="s1">] </span><span class="s0">is not None else None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">color_discrete_sequence=color_discrete_sequence</span><span class="s0">,</span>
        <span class="s1">color_discrete_map=color_discrete_map</span><span class="s0">,</span>
        <span class="s1">labels=labels</span><span class="s0">,</span>
        <span class="s1">color_continuous_scale=color_continuous_scale</span><span class="s0">,</span>
        <span class="s1">range_color=range_color</span><span class="s0">,</span>
        <span class="s1">color_continuous_midpoint=color_continuous_midpoint</span><span class="s0">,</span>
        <span class="s1">opacity=opacity</span><span class="s0">,</span>
        <span class="s1">zoom=zoom</span><span class="s0">,</span>
        <span class="s1">center=center</span><span class="s0">,</span>
        <span class="s1">mapbox_style=mapbox_style</span><span class="s0">,</span>
        <span class="s1">title=title</span><span class="s0">,</span>
        <span class="s1">template=template</span><span class="s0">,</span>
        <span class="s1">width=width</span><span class="s0">,</span>
        <span class="s1">height=height</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">show_original_data:</span>
        <span class="s1">original_fig = scatter_mapbox(</span>
            <span class="s1">data_frame=(</span>
                <span class="s1">args[</span><span class="s5">&quot;data_frame&quot;</span><span class="s1">].sort_values(by=args[</span><span class="s5">&quot;animation_frame&quot;</span><span class="s1">])</span>
                <span class="s0">if </span><span class="s1">args[</span><span class="s5">&quot;animation_frame&quot;</span><span class="s1">] </span><span class="s0">is not None</span>
                <span class="s0">else </span><span class="s1">args[</span><span class="s5">&quot;data_frame&quot;</span><span class="s1">]</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">lat=args[</span><span class="s5">&quot;lat&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">lon=args[</span><span class="s5">&quot;lon&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">animation_frame=args[</span><span class="s5">&quot;animation_frame&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">original_fig.data[</span><span class="s3">0</span><span class="s1">].hoverinfo = </span><span class="s5">&quot;skip&quot;</span>
        <span class="s1">original_fig.data[</span><span class="s3">0</span><span class="s1">].hovertemplate = </span><span class="s0">None</span>
        <span class="s1">original_fig.data[</span><span class="s3">0</span><span class="s1">].marker = original_data_marker</span>

        <span class="s1">fig.add_trace(original_fig.data[</span><span class="s3">0</span><span class="s1">])</span>

        <span class="s0">if </span><span class="s1">args[</span><span class="s5">&quot;animation_frame&quot;</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(original_fig.frames)):</span>
                <span class="s1">original_fig.frames[i].data[</span><span class="s3">0</span><span class="s1">].hoverinfo = </span><span class="s5">&quot;skip&quot;</span>
                <span class="s1">original_fig.frames[i].data[</span><span class="s3">0</span><span class="s1">].hovertemplate = </span><span class="s0">None</span>
                <span class="s1">original_fig.frames[i].data[</span><span class="s3">0</span><span class="s1">].marker = original_data_marker</span>

                <span class="s1">fig.frames[i].data = [</span>
                    <span class="s1">fig.frames[i].data[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
                    <span class="s1">original_fig.frames[i].data[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">]</span>

    <span class="s0">return </span><span class="s1">fig</span>


<span class="s1">create_hexbin_mapbox.__doc__ = make_docstring(</span>
    <span class="s1">create_hexbin_mapbox</span><span class="s0">,</span>
    <span class="s1">override_dict=dict(</span>
        <span class="s1">nx_hexagon=[</span><span class="s5">&quot;int&quot;</span><span class="s0">, </span><span class="s5">&quot;Number of hexagons (horizontally) to be created&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">agg_func=[</span>
            <span class="s5">&quot;function&quot;</span><span class="s0">,</span>
            <span class="s5">&quot;Numpy array aggregator, it must take as input a 1D array&quot;</span><span class="s0">,</span>
            <span class="s5">&quot;and output a scalar value.&quot;</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">min_count=[</span>
            <span class="s5">&quot;int&quot;</span><span class="s0">,</span>
            <span class="s5">&quot;Minimum number of points in a hexagon for it to be displayed.&quot;</span><span class="s0">,</span>
            <span class="s5">&quot;If None and color is not set, display all hexagons.&quot;</span><span class="s0">,</span>
            <span class="s5">&quot;If None and color is set, only display hexagons that contain points.&quot;</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">show_original_data=[</span>
            <span class="s5">&quot;bool&quot;</span><span class="s0">,</span>
            <span class="s5">&quot;Whether to show the original data on top of the hexbin aggregation.&quot;</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">original_data_marker=[</span><span class="s5">&quot;dict&quot;</span><span class="s0">, </span><span class="s5">&quot;Scattermapbox marker options.&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span><span class="s0">,</span>
<span class="s1">)</span>
</pre>
</body>
</html>