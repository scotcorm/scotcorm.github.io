<html>
<head>
<title>test_umath.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #808080;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_umath.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">platform</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">import </span><span class="s1">fnmatch</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">from </span><span class="s1">fractions </span><span class="s0">import </span><span class="s1">Fraction</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">reduce</span>

<span class="s0">import </span><span class="s1">numpy.core.umath </span><span class="s0">as </span><span class="s1">ncu</span>
<span class="s0">from </span><span class="s1">numpy.core </span><span class="s0">import </span><span class="s1">_umath_tests </span><span class="s0">as </span><span class="s1">ncu_tests</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">assert_</span><span class="s0">, </span><span class="s1">assert_equal</span><span class="s0">, </span><span class="s1">assert_raises</span><span class="s0">, </span><span class="s1">assert_raises_regex</span><span class="s0">,</span>
    <span class="s1">assert_array_equal</span><span class="s0">, </span><span class="s1">assert_almost_equal</span><span class="s0">, </span><span class="s1">assert_array_almost_equal</span><span class="s0">,</span>
    <span class="s1">assert_array_max_ulp</span><span class="s0">, </span><span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">assert_no_warnings</span><span class="s0">, </span><span class="s1">suppress_warnings</span><span class="s0">,</span>
    <span class="s1">_gen_alignment_data</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp</span>
    <span class="s1">)</span>

<span class="s0">def </span><span class="s1">get_glibc_version():</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">ver = os.confstr(</span><span class="s2">'CS_GNU_LIBC_VERSION'</span><span class="s1">).rsplit(</span><span class="s2">' '</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">inst:</span>
        <span class="s1">ver = </span><span class="s2">'0.0'</span>

    <span class="s0">return </span><span class="s1">ver</span>


<span class="s1">glibcver = get_glibc_version()</span>
<span class="s1">glibc_older_than = </span><span class="s0">lambda </span><span class="s1">x: (glibcver != </span><span class="s2">'0.0' </span><span class="s0">and </span><span class="s1">glibcver &lt; x)</span>

<span class="s0">def </span><span class="s1">on_powerpc():</span>
    <span class="s4">&quot;&quot;&quot; True if we are running on a Power PC platform.&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">platform.processor() == </span><span class="s2">'powerpc' </span><span class="s0">or </span><span class="s1">\</span>
           <span class="s1">platform.machine().startswith(</span><span class="s2">'ppc'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">bad_arcsinh():</span>
    <span class="s4">&quot;&quot;&quot;The blocklisted trig functions are not accurate on aarch64 for 
    complex256. Rather than dig through the actual problem skip the 
    test. This should be fixed when we can move past glibc2.17 
    which is the version in manylinux2014 
    &quot;&quot;&quot;</span>
    <span class="s1">x = </span><span class="s3">1.78e-10</span>
    <span class="s1">v1 = np.arcsinh(np.float128(x))</span>
    <span class="s1">v2 = np.arcsinh(np.complex256(x)).real</span>
    <span class="s5"># The eps for float128 is 1-e33, so this is way bigger</span>
    <span class="s0">return </span><span class="s1">abs((v1 / v2) - </span><span class="s3">1.0</span><span class="s1">) &gt; </span><span class="s3">1e-23</span>


<span class="s0">class </span><span class="s1">_FilterInvalids:</span>
    <span class="s0">def </span><span class="s1">setup(self):</span>
        <span class="s1">self.olderr = np.seterr(invalid=</span><span class="s2">'ignore'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">teardown(self):</span>
        <span class="s1">np.seterr(**self.olderr)</span>


<span class="s0">class </span><span class="s1">TestConstants:</span>
    <span class="s0">def </span><span class="s1">test_pi(self):</span>
        <span class="s1">assert_allclose(ncu.pi</span><span class="s0">, </span><span class="s3">3.141592653589793</span><span class="s0">, </span><span class="s3">1e-15</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_e(self):</span>
        <span class="s1">assert_allclose(ncu.e</span><span class="s0">, </span><span class="s3">2.718281828459045</span><span class="s0">, </span><span class="s3">1e-15</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_euler_gamma(self):</span>
        <span class="s1">assert_allclose(ncu.euler_gamma</span><span class="s0">, </span><span class="s3">0.5772156649015329</span><span class="s0">, </span><span class="s3">1e-15</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestOut:</span>
    <span class="s0">def </span><span class="s1">test_out_subok(self):</span>
        <span class="s0">for </span><span class="s1">subok </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">a = np.array(</span><span class="s3">0.5</span><span class="s1">)</span>
            <span class="s1">o = np.empty(())</span>

            <span class="s1">r = np.add(a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">o</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s1">assert_(r </span><span class="s0">is </span><span class="s1">o)</span>
            <span class="s1">r = np.add(a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">out=o</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s1">assert_(r </span><span class="s0">is </span><span class="s1">o)</span>
            <span class="s1">r = np.add(a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">out=(o</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s1">assert_(r </span><span class="s0">is </span><span class="s1">o)</span>

            <span class="s1">d = np.array(</span><span class="s3">5.7</span><span class="s1">)</span>
            <span class="s1">o1 = np.empty(())</span>
            <span class="s1">o2 = np.empty(()</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span>

            <span class="s1">r1</span><span class="s0">, </span><span class="s1">r2 = np.frexp(d</span><span class="s0">, </span><span class="s1">o1</span><span class="s0">, None, </span><span class="s1">subok=subok)</span>
            <span class="s1">assert_(r1 </span><span class="s0">is </span><span class="s1">o1)</span>
            <span class="s1">r1</span><span class="s0">, </span><span class="s1">r2 = np.frexp(d</span><span class="s0">, None, </span><span class="s1">o2</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s1">assert_(r2 </span><span class="s0">is </span><span class="s1">o2)</span>
            <span class="s1">r1</span><span class="s0">, </span><span class="s1">r2 = np.frexp(d</span><span class="s0">, </span><span class="s1">o1</span><span class="s0">, </span><span class="s1">o2</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s1">assert_(r1 </span><span class="s0">is </span><span class="s1">o1)</span>
            <span class="s1">assert_(r2 </span><span class="s0">is </span><span class="s1">o2)</span>

            <span class="s1">r1</span><span class="s0">, </span><span class="s1">r2 = np.frexp(d</span><span class="s0">, </span><span class="s1">out=(o1</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s1">assert_(r1 </span><span class="s0">is </span><span class="s1">o1)</span>
            <span class="s1">r1</span><span class="s0">, </span><span class="s1">r2 = np.frexp(d</span><span class="s0">, </span><span class="s1">out=(</span><span class="s0">None, </span><span class="s1">o2)</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s1">assert_(r2 </span><span class="s0">is </span><span class="s1">o2)</span>
            <span class="s1">r1</span><span class="s0">, </span><span class="s1">r2 = np.frexp(d</span><span class="s0">, </span><span class="s1">out=(o1</span><span class="s0">, </span><span class="s1">o2)</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s1">assert_(r1 </span><span class="s0">is </span><span class="s1">o1)</span>
            <span class="s1">assert_(r2 </span><span class="s0">is </span><span class="s1">o2)</span>

            <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
                <span class="s5"># Out argument must be tuple, since there are multiple outputs.</span>
                <span class="s1">r1</span><span class="s0">, </span><span class="s1">r2 = np.frexp(d</span><span class="s0">, </span><span class="s1">out=o1</span><span class="s0">, </span><span class="s1">subok=subok)</span>

            <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">o</span><span class="s0">, </span><span class="s1">o</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">o</span><span class="s0">, </span><span class="s1">out=o</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, None, </span><span class="s1">out=o</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">out=(o</span><span class="s0">, </span><span class="s1">o)</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">out=()</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">out=[]</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">out=([]</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s1">o.flags.writeable = </span><span class="s0">False</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">o</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">out=o</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">out=(o</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">subok=subok)</span>

    <span class="s0">def </span><span class="s1">test_out_wrap_subok(self):</span>
        <span class="s0">class </span><span class="s1">ArrayWrap(np.ndarray):</span>
            <span class="s1">__array_priority__ = </span><span class="s3">10</span>

            <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">arr):</span>
                <span class="s0">return </span><span class="s1">np.asarray(arr).view(cls).copy()</span>

            <span class="s0">def </span><span class="s1">__array_wrap__(self</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">context):</span>
                <span class="s0">return </span><span class="s1">arr.view(type(self))</span>

        <span class="s0">for </span><span class="s1">subok </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">a = ArrayWrap([</span><span class="s3">0.5</span><span class="s1">])</span>

            <span class="s1">r = np.add(a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s0">if </span><span class="s1">subok:</span>
                <span class="s1">assert_(isinstance(r</span><span class="s0">, </span><span class="s1">ArrayWrap))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assert_(type(r) == np.ndarray)</span>

            <span class="s1">r = np.add(a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, None, </span><span class="s1">subok=subok)</span>
            <span class="s0">if </span><span class="s1">subok:</span>
                <span class="s1">assert_(isinstance(r</span><span class="s0">, </span><span class="s1">ArrayWrap))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assert_(type(r) == np.ndarray)</span>

            <span class="s1">r = np.add(a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">out=</span><span class="s0">None, </span><span class="s1">subok=subok)</span>
            <span class="s0">if </span><span class="s1">subok:</span>
                <span class="s1">assert_(isinstance(r</span><span class="s0">, </span><span class="s1">ArrayWrap))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assert_(type(r) == np.ndarray)</span>

            <span class="s1">r = np.add(a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">out=(</span><span class="s0">None,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s0">if </span><span class="s1">subok:</span>
                <span class="s1">assert_(isinstance(r</span><span class="s0">, </span><span class="s1">ArrayWrap))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assert_(type(r) == np.ndarray)</span>

            <span class="s1">d = ArrayWrap([</span><span class="s3">5.7</span><span class="s1">])</span>
            <span class="s1">o1 = np.empty((</span><span class="s3">1</span><span class="s0">,</span><span class="s1">))</span>
            <span class="s1">o2 = np.empty((</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span>

            <span class="s1">r1</span><span class="s0">, </span><span class="s1">r2 = np.frexp(d</span><span class="s0">, </span><span class="s1">o1</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s0">if </span><span class="s1">subok:</span>
                <span class="s1">assert_(isinstance(r2</span><span class="s0">, </span><span class="s1">ArrayWrap))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assert_(type(r2) == np.ndarray)</span>

            <span class="s1">r1</span><span class="s0">, </span><span class="s1">r2 = np.frexp(d</span><span class="s0">, </span><span class="s1">o1</span><span class="s0">, None, </span><span class="s1">subok=subok)</span>
            <span class="s0">if </span><span class="s1">subok:</span>
                <span class="s1">assert_(isinstance(r2</span><span class="s0">, </span><span class="s1">ArrayWrap))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assert_(type(r2) == np.ndarray)</span>

            <span class="s1">r1</span><span class="s0">, </span><span class="s1">r2 = np.frexp(d</span><span class="s0">, None, </span><span class="s1">o2</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s0">if </span><span class="s1">subok:</span>
                <span class="s1">assert_(isinstance(r1</span><span class="s0">, </span><span class="s1">ArrayWrap))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assert_(type(r1) == np.ndarray)</span>

            <span class="s1">r1</span><span class="s0">, </span><span class="s1">r2 = np.frexp(d</span><span class="s0">, </span><span class="s1">out=(o1</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s0">if </span><span class="s1">subok:</span>
                <span class="s1">assert_(isinstance(r2</span><span class="s0">, </span><span class="s1">ArrayWrap))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assert_(type(r2) == np.ndarray)</span>

            <span class="s1">r1</span><span class="s0">, </span><span class="s1">r2 = np.frexp(d</span><span class="s0">, </span><span class="s1">out=(</span><span class="s0">None, </span><span class="s1">o2)</span><span class="s0">, </span><span class="s1">subok=subok)</span>
            <span class="s0">if </span><span class="s1">subok:</span>
                <span class="s1">assert_(isinstance(r1</span><span class="s0">, </span><span class="s1">ArrayWrap))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assert_(type(r1) == np.ndarray)</span>

            <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
                <span class="s5"># Out argument must be tuple, since there are multiple outputs.</span>
                <span class="s1">r1</span><span class="s0">, </span><span class="s1">r2 = np.frexp(d</span><span class="s0">, </span><span class="s1">out=o1</span><span class="s0">, </span><span class="s1">subok=subok)</span>


<span class="s0">class </span><span class="s1">TestComparisons:</span>
    <span class="s0">def </span><span class="s1">test_ignore_object_identity_in_equal(self):</span>
        <span class="s5"># Check comparing identical objects whose comparison</span>
        <span class="s5"># is not a simple boolean, e.g., arrays that are compared elementwise.</span>
        <span class="s1">a = np.array([np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.equal</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a)</span>

        <span class="s5"># Check error raised when comparing identical non-comparable objects.</span>
        <span class="s0">class </span><span class="s1">FunkyType:</span>
            <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;I won't compare&quot;</span><span class="s1">)</span>

        <span class="s1">a = np.array([FunkyType()])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.equal</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a)</span>

        <span class="s5"># Check identity doesn't override comparison mismatch.</span>
        <span class="s1">a = np.array([np.nan]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">assert_equal(np.equal(a</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_ignore_object_identity_in_not_equal(self):</span>
        <span class="s5"># Check comparing identical objects whose comparison</span>
        <span class="s5"># is not a simple boolean, e.g., arrays that are compared elementwise.</span>
        <span class="s1">a = np.array([np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.not_equal</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a)</span>

        <span class="s5"># Check error raised when comparing identical non-comparable objects.</span>
        <span class="s0">class </span><span class="s1">FunkyType:</span>
            <span class="s0">def </span><span class="s1">__ne__(self</span><span class="s0">, </span><span class="s1">other):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;I won't compare&quot;</span><span class="s1">)</span>

        <span class="s1">a = np.array([FunkyType()])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.not_equal</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a)</span>

        <span class="s5"># Check identity doesn't override comparison mismatch.</span>
        <span class="s1">a = np.array([np.nan]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">assert_equal(np.not_equal(a</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True</span><span class="s1">])</span>


<span class="s0">class </span><span class="s1">TestAdd:</span>
    <span class="s0">def </span><span class="s1">test_reduce_alignment(self):</span>
        <span class="s5"># gh-9876</span>
        <span class="s5"># make sure arrays with weird strides work with the optimizations in</span>
        <span class="s5"># pairwise_sum_@TYPE@. On x86, the 'b' field will count as aligned at a</span>
        <span class="s5"># 4 byte offset, even though its itemsize is 8.</span>
        <span class="s1">a = np.zeros(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">dtype=[(</span><span class="s2">'a'</span><span class="s0">, </span><span class="s1">np.int32)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">'b'</span><span class="s0">, </span><span class="s1">np.float64)])</span>
        <span class="s1">a[</span><span class="s2">'a'</span><span class="s1">] = -</span><span class="s3">1</span>
        <span class="s1">assert_equal(a[</span><span class="s2">'b'</span><span class="s1">].sum()</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestDivision:</span>
    <span class="s0">def </span><span class="s1">test_division_int(self):</span>
        <span class="s5"># int division should follow Python</span>
        <span class="s1">x = np.array([</span><span class="s3">5</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">90</span><span class="s0">, </span><span class="s3">100</span><span class="s0">, </span><span class="s1">-</span><span class="s3">5</span><span class="s0">, </span><span class="s1">-</span><span class="s3">10</span><span class="s0">, </span><span class="s1">-</span><span class="s3">90</span><span class="s0">, </span><span class="s1">-</span><span class="s3">100</span><span class="s0">, </span><span class="s1">-</span><span class="s3">120</span><span class="s1">])</span>
        <span class="s0">if </span><span class="s3">5 </span><span class="s1">/ </span><span class="s3">10 </span><span class="s1">== </span><span class="s3">0.5</span><span class="s1">:</span>
            <span class="s1">assert_equal(x / </span><span class="s3">100</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.05</span><span class="s0">, </span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">0.9</span><span class="s0">, </span><span class="s3">1</span><span class="s0">,</span>
                                   <span class="s1">-</span><span class="s3">0.05</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.9</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.2</span><span class="s1">])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">assert_equal(x / </span><span class="s3">100</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">assert_equal(x // </span><span class="s3">100</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">assert_equal(x % </span><span class="s3">100</span><span class="s0">, </span><span class="s1">[</span><span class="s3">5</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">90</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">95</span><span class="s0">, </span><span class="s3">90</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">80</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype,ex_val&quot;</span><span class="s0">, </span><span class="s1">itertools.product(</span>
        <span class="s1">np.sctypes[</span><span class="s2">'int'</span><span class="s1">] + np.sctypes[</span><span class="s2">'uint'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span>
            <span class="s1">(</span>
                <span class="s5"># dividend</span>
                <span class="s2">&quot;np.arange(fo.max-lsize, fo.max, dtype=dtype),&quot;</span>
                <span class="s5"># divisors</span>
                <span class="s2">&quot;np.arange(lsize, dtype=dtype),&quot;</span>
                <span class="s5"># scalar divisors</span>
                <span class="s2">&quot;range(15)&quot;</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s5"># dividend</span>
                <span class="s2">&quot;np.arange(fo.min, fo.min+lsize, dtype=dtype),&quot;</span>
                <span class="s5"># divisors</span>
                <span class="s2">&quot;np.arange(lsize//-2, lsize//2, dtype=dtype),&quot;</span>
                <span class="s5"># scalar divisors</span>
                <span class="s2">&quot;range(fo.min, fo.min + 15)&quot;</span>
            <span class="s1">)</span><span class="s0">, </span><span class="s1">(</span>
                <span class="s5"># dividend</span>
                <span class="s2">&quot;np.arange(fo.max-lsize, fo.max, dtype=dtype),&quot;</span>
                <span class="s5"># divisors</span>
                <span class="s2">&quot;np.arange(lsize, dtype=dtype),&quot;</span>
                <span class="s5"># scalar divisors</span>
                <span class="s2">&quot;[1,3,9,13,neg, fo.min+1, fo.min//2, fo.max//3, fo.max//4]&quot;</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s1">))</span>
    <span class="s0">def </span><span class="s1">test_division_int_boundary(self</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">ex_val):</span>
        <span class="s1">fo = np.iinfo(dtype)</span>
        <span class="s1">neg = -</span><span class="s3">1 </span><span class="s0">if </span><span class="s1">fo.min &lt; </span><span class="s3">0 </span><span class="s0">else </span><span class="s3">1</span>
        <span class="s5"># Large enough to test SIMD loops and remaind elements</span>
        <span class="s1">lsize = </span><span class="s3">512 </span><span class="s1">+ </span><span class="s3">7</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">divisors = eval(ex_val)</span>
        <span class="s1">a_lst</span><span class="s0">, </span><span class="s1">b_lst = a.tolist()</span><span class="s0">, </span><span class="s1">b.tolist()</span>

        <span class="s1">c_div = </span><span class="s0">lambda </span><span class="s1">n</span><span class="s0">, </span><span class="s1">d: (</span>
            <span class="s3">0 </span><span class="s0">if </span><span class="s1">d == </span><span class="s3">0 </span><span class="s0">or </span><span class="s1">(n </span><span class="s0">and </span><span class="s1">n == fo.min </span><span class="s0">and </span><span class="s1">d == -</span><span class="s3">1</span><span class="s1">) </span><span class="s0">else </span><span class="s1">n//d</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">ac = a.copy()</span>
            <span class="s1">ac //= b</span>
            <span class="s1">div_ab = a // b</span>
        <span class="s1">div_lst = [c_div(x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y </span><span class="s0">in </span><span class="s1">zip(a_lst</span><span class="s0">, </span><span class="s1">b_lst)]</span>

        <span class="s1">msg = </span><span class="s2">&quot;Integer arrays floor division check (//)&quot;</span>
        <span class="s0">assert </span><span class="s1">all(div_ab == div_lst)</span><span class="s0">, </span><span class="s1">msg</span>
        <span class="s1">msg_eq = </span><span class="s2">&quot;Integer arrays floor division check (//=)&quot;</span>
        <span class="s0">assert </span><span class="s1">all(ac == div_lst)</span><span class="s0">, </span><span class="s1">msg_eq</span>

        <span class="s0">for </span><span class="s1">divisor </span><span class="s0">in </span><span class="s1">divisors:</span>
            <span class="s1">ac = a.copy()</span>
            <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s2">'ignore'</span><span class="s1">):</span>
                <span class="s1">div_a = a // divisor</span>
                <span class="s1">ac //= divisor</span>
            <span class="s1">div_lst = [c_div(i</span><span class="s0">, </span><span class="s1">divisor) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">a_lst]</span>

            <span class="s0">assert </span><span class="s1">all(div_a == div_lst)</span><span class="s0">, </span><span class="s1">msg</span>
            <span class="s0">assert </span><span class="s1">all(ac == div_lst)</span><span class="s0">, </span><span class="s1">msg_eq</span>

        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s3">0 </span><span class="s0">in </span><span class="s1">b </span><span class="s0">or </span><span class="s1">(fo.min </span><span class="s0">and </span><span class="s1">-</span><span class="s3">1 </span><span class="s0">in </span><span class="s1">b </span><span class="s0">and </span><span class="s1">fo.min </span><span class="s0">in </span><span class="s1">a):</span>
                <span class="s5"># Verify overflow case</span>
                <span class="s0">with </span><span class="s1">pytest.raises(FloatingPointError):</span>
                    <span class="s1">a // b</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">a // b</span>
            <span class="s0">if </span><span class="s1">fo.min </span><span class="s0">and </span><span class="s1">fo.min </span><span class="s0">in </span><span class="s1">a:</span>
                <span class="s0">with </span><span class="s1">pytest.raises(FloatingPointError):</span>
                    <span class="s1">a // -</span><span class="s3">1</span>
            <span class="s0">elif </span><span class="s1">fo.min:</span>
                <span class="s1">a // -</span><span class="s3">1</span>
            <span class="s0">with </span><span class="s1">pytest.raises(FloatingPointError):</span>
                <span class="s1">a // </span><span class="s3">0</span>
            <span class="s0">with </span><span class="s1">pytest.raises(FloatingPointError):</span>
                <span class="s1">ac = a.copy()</span>
                <span class="s1">ac //= </span><span class="s3">0</span>

            <span class="s1">np.array([]</span><span class="s0">, </span><span class="s1">dtype=dtype) // </span><span class="s3">0</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype,ex_val&quot;</span><span class="s0">, </span><span class="s1">itertools.product(</span>
        <span class="s1">np.sctypes[</span><span class="s2">'int'</span><span class="s1">] + np.sctypes[</span><span class="s2">'uint'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span>
            <span class="s2">&quot;np.array([fo.max, 1, 2, 1, 1, 2, 3], dtype=dtype)&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;np.array([fo.min, 1, -2, 1, 1, 2, -3], dtype=dtype)&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;np.arange(fo.min, fo.min+(100*10), 10, dtype=dtype)&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;np.arange(fo.max-(100*7), fo.max, 7, dtype=dtype)&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s1">))</span>
    <span class="s0">def </span><span class="s1">test_division_int_reduce(self</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">ex_val):</span>
        <span class="s1">fo = np.iinfo(dtype)</span>
        <span class="s1">a = eval(ex_val)</span>
        <span class="s1">lst = a.tolist()</span>
        <span class="s1">c_div = </span><span class="s0">lambda </span><span class="s1">n</span><span class="s0">, </span><span class="s1">d: (</span>
            <span class="s3">0 </span><span class="s0">if </span><span class="s1">d == </span><span class="s3">0 </span><span class="s0">or </span><span class="s1">(n </span><span class="s0">and </span><span class="s1">n == fo.min </span><span class="s0">and </span><span class="s1">d == -</span><span class="s3">1</span><span class="s1">) </span><span class="s0">else </span><span class="s1">n//d</span>
        <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">div_a = np.floor_divide.reduce(a)</span>
        <span class="s1">div_lst = reduce(c_div</span><span class="s0">, </span><span class="s1">lst)</span>
        <span class="s1">msg = </span><span class="s2">&quot;Reduce floor integer division check&quot;</span>
        <span class="s0">assert </span><span class="s1">div_a == div_lst</span><span class="s0">, </span><span class="s1">msg</span>

        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">pytest.raises(FloatingPointError):</span>
                <span class="s1">np.floor_divide.reduce(np.arange(-</span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s0">, </span><span class="s1">dtype=dtype))</span>
            <span class="s0">if </span><span class="s1">fo.min:</span>
                <span class="s0">with </span><span class="s1">pytest.raises(FloatingPointError):</span>
                    <span class="s1">np.floor_divide.reduce(</span>
                        <span class="s1">np.array([fo.min</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
                    <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
            <span class="s2">&quot;dividend,divisor,quotient&quot;</span><span class="s0">,</span>
            <span class="s1">[(np.timedelta64(</span><span class="s3">2</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.timedelta64(</span><span class="s3">2</span><span class="s0">,</span><span class="s2">'M'</span><span class="s1">)</span><span class="s0">, </span><span class="s3">12</span><span class="s1">)</span><span class="s0">,</span>
             <span class="s1">(np.timedelta64(</span><span class="s3">2</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.timedelta64(-</span><span class="s3">2</span><span class="s0">,</span><span class="s2">'M'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">12</span><span class="s1">)</span><span class="s0">,</span>
             <span class="s1">(np.timedelta64(-</span><span class="s3">2</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.timedelta64(</span><span class="s3">2</span><span class="s0">,</span><span class="s2">'M'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">12</span><span class="s1">)</span><span class="s0">,</span>
             <span class="s1">(np.timedelta64(-</span><span class="s3">2</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.timedelta64(-</span><span class="s3">2</span><span class="s0">,</span><span class="s2">'M'</span><span class="s1">)</span><span class="s0">, </span><span class="s3">12</span><span class="s1">)</span><span class="s0">,</span>
             <span class="s1">(np.timedelta64(</span><span class="s3">2</span><span class="s0">,</span><span class="s2">'M'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.timedelta64(-</span><span class="s3">2</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
             <span class="s1">(np.timedelta64(</span><span class="s3">2</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.timedelta64(</span><span class="s3">0</span><span class="s0">,</span><span class="s2">'M'</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
             <span class="s1">(np.timedelta64(</span><span class="s3">2</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">)</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">np.timedelta64(</span><span class="s3">1</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">))</span><span class="s0">,</span>
             <span class="s1">(np.timedelta64(</span><span class="s3">2</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">np.timedelta64(-</span><span class="s3">1</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">))</span><span class="s0">,</span>
             <span class="s1">(np.timedelta64(-</span><span class="s3">2</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">)</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">np.timedelta64(-</span><span class="s3">1</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">))</span><span class="s0">,</span>
             <span class="s1">(np.timedelta64(-</span><span class="s3">2</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">np.timedelta64(</span><span class="s3">1</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">))</span><span class="s0">,</span>
             <span class="s1">(np.timedelta64(-</span><span class="s3">2</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">np.timedelta64(</span><span class="s3">1</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">))</span><span class="s0">,</span>
             <span class="s1">(np.timedelta64(-</span><span class="s3">2</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3</span><span class="s0">, </span><span class="s1">np.timedelta64(</span><span class="s3">0</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">))</span><span class="s0">,</span>
             <span class="s1">(np.timedelta64(-</span><span class="s3">2</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">np.timedelta64(</span><span class="s2">'Nat'</span><span class="s0">,</span><span class="s2">'Y'</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_division_int_timedelta(self</span><span class="s0">, </span><span class="s1">dividend</span><span class="s0">, </span><span class="s1">divisor</span><span class="s0">, </span><span class="s1">quotient):</span>
        <span class="s5"># If either divisor is 0 or quotient is Nat, check for division by 0</span>
        <span class="s0">if </span><span class="s1">divisor </span><span class="s0">and </span><span class="s1">(isinstance(quotient</span><span class="s0">, </span><span class="s1">int) </span><span class="s0">or not </span><span class="s1">np.isnat(quotient)):</span>
            <span class="s1">msg = </span><span class="s2">&quot;Timedelta floor division check&quot;</span>
            <span class="s0">assert </span><span class="s1">dividend // divisor == quotient</span><span class="s0">, </span><span class="s1">msg</span>

            <span class="s5"># Test for arrays as well</span>
            <span class="s1">msg = </span><span class="s2">&quot;Timedelta arrays floor division check&quot;</span>
            <span class="s1">dividend_array = np.array([dividend]*</span><span class="s3">5</span><span class="s1">)</span>
            <span class="s1">quotient_array = np.array([quotient]*</span><span class="s3">5</span><span class="s1">)</span>
            <span class="s0">assert </span><span class="s1">all(dividend_array // divisor == quotient_array)</span><span class="s0">, </span><span class="s1">msg</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s2">'raise'</span><span class="s0">, </span><span class="s1">invalid=</span><span class="s2">'raise'</span><span class="s1">):</span>
                <span class="s0">with </span><span class="s1">pytest.raises(FloatingPointError):</span>
                    <span class="s1">dividend // divisor</span>

    <span class="s0">def </span><span class="s1">test_division_complex(self):</span>
        <span class="s5"># check that implementation is correct</span>
        <span class="s1">msg = </span><span class="s2">&quot;Complex division implementation check&quot;</span>
        <span class="s1">x = np.array([</span><span class="s3">1. </span><span class="s1">+ </span><span class="s3">1.</span><span class="s1">*</span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1. </span><span class="s1">+ </span><span class="s3">.5</span><span class="s1">*</span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1. </span><span class="s1">+ </span><span class="s3">2.</span><span class="s1">*</span><span class="s3">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.complex128)</span>
        <span class="s1">assert_almost_equal(x**</span><span class="s3">2</span><span class="s1">/x</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
        <span class="s5"># check overflow, underflow</span>
        <span class="s1">msg = </span><span class="s2">&quot;Complex division overflow/underflow check&quot;</span>
        <span class="s1">x = np.array([</span><span class="s3">1.e+110</span><span class="s0">, </span><span class="s3">1.e-110</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.complex128)</span>
        <span class="s1">y = x**</span><span class="s3">2</span><span class="s1">/x</span>
        <span class="s1">assert_almost_equal(y/x</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

    <span class="s0">def </span><span class="s1">test_zero_division_complex(self):</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">divide=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">x = np.array([</span><span class="s3">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.complex128)</span>
            <span class="s1">y = </span><span class="s3">1.0</span><span class="s1">/x</span>
            <span class="s1">assert_(np.isinf(y)[</span><span class="s3">0</span><span class="s1">])</span>
            <span class="s1">y = complex(np.inf</span><span class="s0">, </span><span class="s1">np.nan)/x</span>
            <span class="s1">assert_(np.isinf(y)[</span><span class="s3">0</span><span class="s1">])</span>
            <span class="s1">y = complex(np.nan</span><span class="s0">, </span><span class="s1">np.inf)/x</span>
            <span class="s1">assert_(np.isinf(y)[</span><span class="s3">0</span><span class="s1">])</span>
            <span class="s1">y = complex(np.inf</span><span class="s0">, </span><span class="s1">np.inf)/x</span>
            <span class="s1">assert_(np.isinf(y)[</span><span class="s3">0</span><span class="s1">])</span>
            <span class="s1">y = </span><span class="s3">0.0</span><span class="s1">/x</span>
            <span class="s1">assert_(np.isnan(y)[</span><span class="s3">0</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_floor_division_complex(self):</span>
        <span class="s5"># check that floor division, divmod and remainder raises type errors</span>
        <span class="s1">x = np.array([</span><span class="s3">.9 </span><span class="s1">+ </span><span class="s3">1j</span><span class="s0">, </span><span class="s1">-</span><span class="s3">.1 </span><span class="s1">+ </span><span class="s3">1j</span><span class="s0">, </span><span class="s3">.9 </span><span class="s1">+ </span><span class="s3">.5</span><span class="s1">*</span><span class="s3">1j</span><span class="s0">, </span><span class="s3">.9 </span><span class="s1">+ </span><span class="s3">2.</span><span class="s1">*</span><span class="s3">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.complex128)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">x // </span><span class="s3">7</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">np.divmod(x</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">np.remainder(x</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_floor_division_signed_zero(self):</span>
        <span class="s5"># Check that the sign bit is correctly set when dividing positive and</span>
        <span class="s5"># negative zero by one.</span>
        <span class="s1">x = np.zeros(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.signbit(x//</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.signbit((-x)//</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'dtype'</span><span class="s0">, </span><span class="s1">np.typecodes[</span><span class="s2">'Float'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_floor_division_errors(self</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s1">fnan = np.array(np.nan</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">fone = np.array(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">fzer = np.array(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">finf = np.array(np.inf</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s5"># divide by zero error check</span>
        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s2">'raise'</span><span class="s0">, </span><span class="s1">invalid=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.floor_divide</span><span class="s0">, </span><span class="s1">fone</span><span class="s0">, </span><span class="s1">fzer)</span>
        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s2">'ignore'</span><span class="s0">, </span><span class="s1">invalid=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s1">np.floor_divide(fone</span><span class="s0">, </span><span class="s1">fzer)</span>

        <span class="s5"># The following already contain a NaN and should not warn</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s1">np.floor_divide(fnan</span><span class="s0">, </span><span class="s1">fone)</span>
            <span class="s1">np.floor_divide(fone</span><span class="s0">, </span><span class="s1">fnan)</span>
            <span class="s1">np.floor_divide(fnan</span><span class="s0">, </span><span class="s1">fzer)</span>
            <span class="s1">np.floor_divide(fzer</span><span class="s0">, </span><span class="s1">fnan)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'dtype'</span><span class="s0">, </span><span class="s1">np.typecodes[</span><span class="s2">'Float'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_floor_division_corner_cases(self</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s5"># test corner cases like 1.0//0.0 for errors and return vals</span>
        <span class="s1">x = np.zeros(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">y = np.ones(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">fnan = np.array(np.nan</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">fone = np.array(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">fzer = np.array(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">finf = np.array(np.inf</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s2">&quot;invalid value encountered in floor_divide&quot;</span><span class="s1">)</span>
            <span class="s1">div = np.floor_divide(fnan</span><span class="s0">, </span><span class="s1">fone)</span>
            <span class="s0">assert</span><span class="s1">(np.isnan(div))</span><span class="s0">, </span><span class="s2">&quot;dt: %s, div: %s&quot; </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">div)</span>
            <span class="s1">div = np.floor_divide(fone</span><span class="s0">, </span><span class="s1">fnan)</span>
            <span class="s0">assert</span><span class="s1">(np.isnan(div))</span><span class="s0">, </span><span class="s2">&quot;dt: %s, div: %s&quot; </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">div)</span>
            <span class="s1">div = np.floor_divide(fnan</span><span class="s0">, </span><span class="s1">fzer)</span>
            <span class="s0">assert</span><span class="s1">(np.isnan(div))</span><span class="s0">, </span><span class="s2">&quot;dt: %s, div: %s&quot; </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">div)</span>
        <span class="s5"># verify 1.0//0.0 computations return inf</span>
        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">z = np.floor_divide(y</span><span class="s0">, </span><span class="s1">x)</span>
            <span class="s1">assert_(np.isinf(z).all())</span>

<span class="s0">def </span><span class="s1">floor_divide_and_remainder(x</span><span class="s0">, </span><span class="s1">y):</span>
    <span class="s0">return </span><span class="s1">(np.floor_divide(x</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s1">np.remainder(x</span><span class="s0">, </span><span class="s1">y))</span>


<span class="s0">def </span><span class="s1">_signs(dt):</span>
    <span class="s0">if </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">np.typecodes[</span><span class="s2">'UnsignedInteger'</span><span class="s1">]:</span>
        <span class="s0">return </span><span class="s1">(+</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">(+</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestRemainder:</span>

    <span class="s0">def </span><span class="s1">test_remainder_basic(self):</span>
        <span class="s1">dt = np.typecodes[</span><span class="s2">'AllInteger'</span><span class="s1">] + np.typecodes[</span><span class="s2">'Float'</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">[floor_divide_and_remainder</span><span class="s0">, </span><span class="s1">np.divmod]:</span>
            <span class="s0">for </span><span class="s1">dt1</span><span class="s0">, </span><span class="s1">dt2 </span><span class="s0">in </span><span class="s1">itertools.product(dt</span><span class="s0">, </span><span class="s1">dt):</span>
                <span class="s0">for </span><span class="s1">sg1</span><span class="s0">, </span><span class="s1">sg2 </span><span class="s0">in </span><span class="s1">itertools.product(_signs(dt1)</span><span class="s0">, </span><span class="s1">_signs(dt2)):</span>
                    <span class="s1">fmt = </span><span class="s2">'op: %s, dt1: %s, dt2: %s, sg1: %s, sg2: %s'</span>
                    <span class="s1">msg = fmt % (op.__name__</span><span class="s0">, </span><span class="s1">dt1</span><span class="s0">, </span><span class="s1">dt2</span><span class="s0">, </span><span class="s1">sg1</span><span class="s0">, </span><span class="s1">sg2)</span>
                    <span class="s1">a = np.array(sg1*</span><span class="s3">71</span><span class="s0">, </span><span class="s1">dtype=dt1)</span>
                    <span class="s1">b = np.array(sg2*</span><span class="s3">19</span><span class="s0">, </span><span class="s1">dtype=dt2)</span>
                    <span class="s1">div</span><span class="s0">, </span><span class="s1">rem = op(a</span><span class="s0">, </span><span class="s1">b)</span>
                    <span class="s1">assert_equal(div*b + rem</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
                    <span class="s0">if </span><span class="s1">sg2 == -</span><span class="s3">1</span><span class="s1">:</span>
                        <span class="s1">assert_(b &lt; rem &lt;= </span><span class="s3">0</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">assert_(b &gt; rem &gt;= </span><span class="s3">0</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_float_remainder_exact(self):</span>
        <span class="s5"># test that float results are exact for small integers. This also</span>
        <span class="s5"># holds for the same integers scaled by powers of two.</span>
        <span class="s1">nlst = list(range(-</span><span class="s3">127</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">plst = list(range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">128</span><span class="s1">))</span>
        <span class="s1">dividend = nlst + [</span><span class="s3">0</span><span class="s1">] + plst</span>
        <span class="s1">divisor = nlst + plst</span>
        <span class="s1">arg = list(itertools.product(dividend</span><span class="s0">, </span><span class="s1">divisor))</span>
        <span class="s1">tgt = list(divmod(*t) </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">arg)</span>

        <span class="s1">a</span><span class="s0">, </span><span class="s1">b = np.array(arg</span><span class="s0">, </span><span class="s1">dtype=int).T</span>
        <span class="s5"># convert exact integer results from Python to float so that</span>
        <span class="s5"># signed zero can be used, it is checked.</span>
        <span class="s1">tgtdiv</span><span class="s0">, </span><span class="s1">tgtrem = np.array(tgt</span><span class="s0">, </span><span class="s1">dtype=float).T</span>
        <span class="s1">tgtdiv = np.where((tgtdiv == </span><span class="s3">0.0</span><span class="s1">) &amp; ((b &lt; </span><span class="s3">0</span><span class="s1">) ^ (a &lt; </span><span class="s3">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">tgtdiv)</span>
        <span class="s1">tgtrem = np.where((tgtrem == </span><span class="s3">0.0</span><span class="s1">) &amp; (b &lt; </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">tgtrem)</span>

        <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">[floor_divide_and_remainder</span><span class="s0">, </span><span class="s1">np.divmod]:</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">np.typecodes[</span><span class="s2">'Float'</span><span class="s1">]:</span>
                <span class="s1">msg = </span><span class="s2">'op: %s, dtype: %s' </span><span class="s1">% (op.__name__</span><span class="s0">, </span><span class="s1">dt)</span>
                <span class="s1">fa = a.astype(dt)</span>
                <span class="s1">fb = b.astype(dt)</span>
                <span class="s1">div</span><span class="s0">, </span><span class="s1">rem = op(fa</span><span class="s0">, </span><span class="s1">fb)</span>
                <span class="s1">assert_equal(div</span><span class="s0">, </span><span class="s1">tgtdiv</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
                <span class="s1">assert_equal(rem</span><span class="s0">, </span><span class="s1">tgtrem</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

    <span class="s0">def </span><span class="s1">test_float_remainder_roundoff(self):</span>
        <span class="s5"># gh-6127</span>
        <span class="s1">dt = np.typecodes[</span><span class="s2">'Float'</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">[floor_divide_and_remainder</span><span class="s0">, </span><span class="s1">np.divmod]:</span>
            <span class="s0">for </span><span class="s1">dt1</span><span class="s0">, </span><span class="s1">dt2 </span><span class="s0">in </span><span class="s1">itertools.product(dt</span><span class="s0">, </span><span class="s1">dt):</span>
                <span class="s0">for </span><span class="s1">sg1</span><span class="s0">, </span><span class="s1">sg2 </span><span class="s0">in </span><span class="s1">itertools.product((+</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(+</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)):</span>
                    <span class="s1">fmt = </span><span class="s2">'op: %s, dt1: %s, dt2: %s, sg1: %s, sg2: %s'</span>
                    <span class="s1">msg = fmt % (op.__name__</span><span class="s0">, </span><span class="s1">dt1</span><span class="s0">, </span><span class="s1">dt2</span><span class="s0">, </span><span class="s1">sg1</span><span class="s0">, </span><span class="s1">sg2)</span>
                    <span class="s1">a = np.array(sg1*</span><span class="s3">78</span><span class="s1">*</span><span class="s3">6e-8</span><span class="s0">, </span><span class="s1">dtype=dt1)</span>
                    <span class="s1">b = np.array(sg2*</span><span class="s3">6e-8</span><span class="s0">, </span><span class="s1">dtype=dt2)</span>
                    <span class="s1">div</span><span class="s0">, </span><span class="s1">rem = op(a</span><span class="s0">, </span><span class="s1">b)</span>
                    <span class="s5"># Equal assertion should hold when fmod is used</span>
                    <span class="s1">assert_equal(div*b + rem</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
                    <span class="s0">if </span><span class="s1">sg2 == -</span><span class="s3">1</span><span class="s1">:</span>
                        <span class="s1">assert_(b &lt; rem &lt;= </span><span class="s3">0</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">assert_(b &gt; rem &gt;= </span><span class="s3">0</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s1">@pytest.mark.xfail(sys.platform.startswith(</span><span class="s2">&quot;darwin&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">reason=</span><span class="s2">&quot;MacOS seems to not give the correct 'invalid' warning for &quot;</span>
                   <span class="s2">&quot;`fmod`.  Hopefully, others always do.&quot;</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'dtype'</span><span class="s0">, </span><span class="s1">np.typecodes[</span><span class="s2">'Float'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_float_divmod_errors(self</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s5"># Check valid errors raised for divmod and remainder</span>
        <span class="s1">fzero = np.array(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">fone = np.array(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">finf = np.array(np.inf</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">fnan = np.array(np.nan</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s5"># since divmod is combination of both remainder and divide</span>
        <span class="s5"># ops it will set both dividebyzero and invalid flags</span>
        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s2">'raise'</span><span class="s0">, </span><span class="s1">invalid=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.divmod</span><span class="s0">, </span><span class="s1">fone</span><span class="s0">, </span><span class="s1">fzero)</span>
        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s2">'ignore'</span><span class="s0">, </span><span class="s1">invalid=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.divmod</span><span class="s0">, </span><span class="s1">fone</span><span class="s0">, </span><span class="s1">fzero)</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.divmod</span><span class="s0">, </span><span class="s1">fzero</span><span class="s0">, </span><span class="s1">fzero)</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.divmod</span><span class="s0">, </span><span class="s1">finf</span><span class="s0">, </span><span class="s1">finf)</span>
        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s2">'ignore'</span><span class="s0">, </span><span class="s1">invalid=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.divmod</span><span class="s0">, </span><span class="s1">finf</span><span class="s0">, </span><span class="s1">fzero)</span>
        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s2">'raise'</span><span class="s0">, </span><span class="s1">invalid=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s5"># inf / 0 does not set any flags, only the modulo creates a NaN</span>
            <span class="s1">np.divmod(finf</span><span class="s0">, </span><span class="s1">fzero)</span>

    <span class="s1">@pytest.mark.xfail(sys.platform.startswith(</span><span class="s2">&quot;darwin&quot;</span><span class="s1">)</span><span class="s0">,</span>
           <span class="s1">reason=</span><span class="s2">&quot;MacOS seems to not give the correct 'invalid' warning for &quot;</span>
                  <span class="s2">&quot;`fmod`.  Hopefully, others always do.&quot;</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'dtype'</span><span class="s0">, </span><span class="s1">np.typecodes[</span><span class="s2">'Float'</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'fn'</span><span class="s0">, </span><span class="s1">[np.fmod</span><span class="s0">, </span><span class="s1">np.remainder])</span>
    <span class="s0">def </span><span class="s1">test_float_remainder_errors(self</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">fn):</span>
        <span class="s1">fzero = np.array(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">fone = np.array(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">finf = np.array(np.inf</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">fnan = np.array(np.nan</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

        <span class="s5"># The following already contain a NaN and should not warn.</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">pytest.raises(FloatingPointError</span><span class="s0">,</span>
                    <span class="s1">match=</span><span class="s2">&quot;invalid value&quot;</span><span class="s1">):</span>
                <span class="s1">fn(fone</span><span class="s0">, </span><span class="s1">fzero)</span>
            <span class="s1">fn(fnan</span><span class="s0">, </span><span class="s1">fzero)</span>
            <span class="s1">fn(fzero</span><span class="s0">, </span><span class="s1">fnan)</span>
            <span class="s1">fn(fone</span><span class="s0">, </span><span class="s1">fnan)</span>
            <span class="s1">fn(fnan</span><span class="s0">, </span><span class="s1">fone)</span>

    <span class="s0">def </span><span class="s1">test_float_remainder_overflow(self):</span>
        <span class="s1">a = np.finfo(np.float64).tiny</span>
        <span class="s0">with </span><span class="s1">np.errstate(over=</span><span class="s2">'ignore'</span><span class="s0">, </span><span class="s1">invalid=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">div</span><span class="s0">, </span><span class="s1">mod = np.divmod(</span><span class="s3">4</span><span class="s0">, </span><span class="s1">a)</span>
            <span class="s1">np.isinf(div)</span>
            <span class="s1">assert_(mod == </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">np.errstate(over=</span><span class="s2">'raise'</span><span class="s0">, </span><span class="s1">invalid=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.divmod</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'raise'</span><span class="s0">, </span><span class="s1">over=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.divmod</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s1">a)</span>

    <span class="s0">def </span><span class="s1">test_float_divmod_corner_cases(self):</span>
        <span class="s5"># check nan cases</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">np.typecodes[</span><span class="s2">'Float'</span><span class="s1">]:</span>
            <span class="s1">fnan = np.array(np.nan</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">fone = np.array(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">fzer = np.array(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">finf = np.array(np.inf</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
                <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s2">&quot;invalid value encountered in divmod&quot;</span><span class="s1">)</span>
                <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s2">&quot;divide by zero encountered in divmod&quot;</span><span class="s1">)</span>
                <span class="s1">div</span><span class="s0">, </span><span class="s1">rem = np.divmod(fone</span><span class="s0">, </span><span class="s1">fzer)</span>
                <span class="s0">assert</span><span class="s1">(np.isinf(div))</span><span class="s0">, </span><span class="s2">'dt: %s, div: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem)</span>
                <span class="s0">assert</span><span class="s1">(np.isnan(rem))</span><span class="s0">, </span><span class="s2">'dt: %s, rem: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem)</span>
                <span class="s1">div</span><span class="s0">, </span><span class="s1">rem = np.divmod(fzer</span><span class="s0">, </span><span class="s1">fzer)</span>
                <span class="s0">assert</span><span class="s1">(np.isnan(rem))</span><span class="s0">, </span><span class="s2">'dt: %s, rem: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem)</span>
                <span class="s1">assert_(np.isnan(div))</span><span class="s0">, </span><span class="s2">'dt: %s, rem: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem)</span>
                <span class="s1">div</span><span class="s0">, </span><span class="s1">rem = np.divmod(finf</span><span class="s0">, </span><span class="s1">finf)</span>
                <span class="s0">assert</span><span class="s1">(np.isnan(div))</span><span class="s0">, </span><span class="s2">'dt: %s, rem: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem)</span>
                <span class="s0">assert</span><span class="s1">(np.isnan(rem))</span><span class="s0">, </span><span class="s2">'dt: %s, rem: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem)</span>
                <span class="s1">div</span><span class="s0">, </span><span class="s1">rem = np.divmod(finf</span><span class="s0">, </span><span class="s1">fzer)</span>
                <span class="s0">assert</span><span class="s1">(np.isinf(div))</span><span class="s0">, </span><span class="s2">'dt: %s, rem: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem)</span>
                <span class="s0">assert</span><span class="s1">(np.isnan(rem))</span><span class="s0">, </span><span class="s2">'dt: %s, rem: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem)</span>
                <span class="s1">div</span><span class="s0">, </span><span class="s1">rem = np.divmod(fnan</span><span class="s0">, </span><span class="s1">fone)</span>
                <span class="s0">assert</span><span class="s1">(np.isnan(rem))</span><span class="s0">, </span><span class="s2">&quot;dt: %s, rem: %s&quot; </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem)</span>
                <span class="s0">assert</span><span class="s1">(np.isnan(div))</span><span class="s0">, </span><span class="s2">&quot;dt: %s, rem: %s&quot; </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem)</span>
                <span class="s1">div</span><span class="s0">, </span><span class="s1">rem = np.divmod(fone</span><span class="s0">, </span><span class="s1">fnan)</span>
                <span class="s0">assert</span><span class="s1">(np.isnan(rem))</span><span class="s0">, </span><span class="s2">&quot;dt: %s, rem: %s&quot; </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem)</span>
                <span class="s0">assert</span><span class="s1">(np.isnan(div))</span><span class="s0">, </span><span class="s2">&quot;dt: %s, rem: %s&quot; </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem)</span>
                <span class="s1">div</span><span class="s0">, </span><span class="s1">rem = np.divmod(fnan</span><span class="s0">, </span><span class="s1">fzer)</span>
                <span class="s0">assert</span><span class="s1">(np.isnan(rem))</span><span class="s0">, </span><span class="s2">&quot;dt: %s, rem: %s&quot; </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem)</span>
                <span class="s0">assert</span><span class="s1">(np.isnan(div))</span><span class="s0">, </span><span class="s2">&quot;dt: %s, rem: %s&quot; </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem)</span>

    <span class="s0">def </span><span class="s1">test_float_remainder_corner_cases(self):</span>
        <span class="s5"># Check remainder magnitude.</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">np.typecodes[</span><span class="s2">'Float'</span><span class="s1">]:</span>
            <span class="s1">fone = np.array(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">fzer = np.array(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">fnan = np.array(np.nan</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">b = np.array(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">a = np.nextafter(np.array(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">dtype=dt)</span><span class="s0">, </span><span class="s1">-b)</span>
            <span class="s1">rem = np.remainder(a</span><span class="s0">, </span><span class="s1">b)</span>
            <span class="s1">assert_(rem &lt;= b</span><span class="s0">, </span><span class="s2">'dt: %s' </span><span class="s1">% dt)</span>
            <span class="s1">rem = np.remainder(-a</span><span class="s0">, </span><span class="s1">-b)</span>
            <span class="s1">assert_(rem &gt;= -b</span><span class="s0">, </span><span class="s2">'dt: %s' </span><span class="s1">% dt)</span>

        <span class="s5"># Check nans, inf</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s2">&quot;invalid value encountered in remainder&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s2">&quot;invalid value encountered in fmod&quot;</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">np.typecodes[</span><span class="s2">'Float'</span><span class="s1">]:</span>
                <span class="s1">fone = np.array(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">fzer = np.array(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">finf = np.array(np.inf</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">fnan = np.array(np.nan</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">rem = np.remainder(fone</span><span class="s0">, </span><span class="s1">fzer)</span>
                <span class="s1">assert_(np.isnan(rem)</span><span class="s0">, </span><span class="s2">'dt: %s, rem: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem))</span>
                <span class="s5"># MSVC 2008 returns NaN here, so disable the check.</span>
                <span class="s5">#rem = np.remainder(fone, finf)</span>
                <span class="s5">#assert_(rem == fone, 'dt: %s, rem: %s' % (dt, rem))</span>
                <span class="s1">rem = np.remainder(finf</span><span class="s0">, </span><span class="s1">fone)</span>
                <span class="s1">fmod = np.fmod(finf</span><span class="s0">, </span><span class="s1">fone)</span>
                <span class="s1">assert_(np.isnan(fmod)</span><span class="s0">, </span><span class="s2">'dt: %s, fmod: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">fmod))</span>
                <span class="s1">assert_(np.isnan(rem)</span><span class="s0">, </span><span class="s2">'dt: %s, rem: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem))</span>
                <span class="s1">rem = np.remainder(finf</span><span class="s0">, </span><span class="s1">finf)</span>
                <span class="s1">fmod = np.fmod(finf</span><span class="s0">, </span><span class="s1">fone)</span>
                <span class="s1">assert_(np.isnan(rem)</span><span class="s0">, </span><span class="s2">'dt: %s, rem: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem))</span>
                <span class="s1">assert_(np.isnan(fmod)</span><span class="s0">, </span><span class="s2">'dt: %s, fmod: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">fmod))</span>
                <span class="s1">rem = np.remainder(finf</span><span class="s0">, </span><span class="s1">fzer)</span>
                <span class="s1">fmod = np.fmod(finf</span><span class="s0">, </span><span class="s1">fzer)</span>
                <span class="s1">assert_(np.isnan(rem)</span><span class="s0">, </span><span class="s2">'dt: %s, rem: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem))</span>
                <span class="s1">assert_(np.isnan(fmod)</span><span class="s0">, </span><span class="s2">'dt: %s, fmod: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">fmod))</span>
                <span class="s1">rem = np.remainder(fone</span><span class="s0">, </span><span class="s1">fnan)</span>
                <span class="s1">fmod = np.fmod(fone</span><span class="s0">, </span><span class="s1">fnan)</span>
                <span class="s1">assert_(np.isnan(rem)</span><span class="s0">, </span><span class="s2">'dt: %s, rem: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem))</span>
                <span class="s1">assert_(np.isnan(fmod)</span><span class="s0">, </span><span class="s2">'dt: %s, fmod: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">fmod))</span>
                <span class="s1">rem = np.remainder(fnan</span><span class="s0">, </span><span class="s1">fzer)</span>
                <span class="s1">fmod = np.fmod(fnan</span><span class="s0">, </span><span class="s1">fzer)</span>
                <span class="s1">assert_(np.isnan(rem)</span><span class="s0">, </span><span class="s2">'dt: %s, rem: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem))</span>
                <span class="s1">assert_(np.isnan(fmod)</span><span class="s0">, </span><span class="s2">'dt: %s, fmod: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem))</span>
                <span class="s1">rem = np.remainder(fnan</span><span class="s0">, </span><span class="s1">fone)</span>
                <span class="s1">fmod = np.fmod(fnan</span><span class="s0">, </span><span class="s1">fone)</span>
                <span class="s1">assert_(np.isnan(rem)</span><span class="s0">, </span><span class="s2">'dt: %s, rem: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem))</span>
                <span class="s1">assert_(np.isnan(fmod)</span><span class="s0">, </span><span class="s2">'dt: %s, fmod: %s' </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">rem))</span>


<span class="s0">class </span><span class="s1">TestCbrt:</span>
    <span class="s0">def </span><span class="s1">test_cbrt_scalar(self):</span>
        <span class="s1">assert_almost_equal((np.cbrt(np.float32(-</span><span class="s3">2.5</span><span class="s1">)**</span><span class="s3">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2.5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_cbrt(self):</span>
        <span class="s1">x = np.array([</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3.</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf])</span>
        <span class="s1">assert_almost_equal(np.cbrt(x**</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">x)</span>

        <span class="s1">assert_(np.isnan(np.cbrt(np.nan)))</span>
        <span class="s1">assert_equal(np.cbrt(np.inf)</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s1">assert_equal(np.cbrt(-np.inf)</span><span class="s0">, </span><span class="s1">-np.inf)</span>


<span class="s0">class </span><span class="s1">TestPower:</span>
    <span class="s0">def </span><span class="s1">test_power_float(self):</span>
        <span class="s1">x = np.array([</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s1">])</span>
        <span class="s1">assert_equal(x**</span><span class="s3">0</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">])</span>
        <span class="s1">assert_equal(x**</span><span class="s3">1</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s1">assert_equal(x**</span><span class="s3">2</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">4.</span><span class="s0">, </span><span class="s3">9.</span><span class="s1">])</span>
        <span class="s1">y = x.copy()</span>
        <span class="s1">y **= </span><span class="s3">2</span>
        <span class="s1">assert_equal(y</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">4.</span><span class="s0">, </span><span class="s3">9.</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(x**(-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">/</span><span class="s3">3</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(x**(</span><span class="s3">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.</span><span class="s0">, </span><span class="s1">ncu.sqrt(</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ncu.sqrt(</span><span class="s3">3</span><span class="s1">)])</span>

        <span class="s0">for </span><span class="s1">out</span><span class="s0">, </span><span class="s1">inp</span><span class="s0">, </span><span class="s1">msg </span><span class="s0">in </span><span class="s1">_gen_alignment_data(dtype=np.float32</span><span class="s0">,</span>
                                                 <span class="s1">type=</span><span class="s2">'unary'</span><span class="s0">,</span>
                                                 <span class="s1">max_size=</span><span class="s3">11</span><span class="s1">):</span>
            <span class="s1">exp = [ncu.sqrt(i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">inp]</span>
            <span class="s1">assert_almost_equal(inp**(</span><span class="s3">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">exp</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
            <span class="s1">np.sqrt(inp</span><span class="s0">, </span><span class="s1">out=out)</span>
            <span class="s1">assert_equal(out</span><span class="s0">, </span><span class="s1">exp</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

        <span class="s0">for </span><span class="s1">out</span><span class="s0">, </span><span class="s1">inp</span><span class="s0">, </span><span class="s1">msg </span><span class="s0">in </span><span class="s1">_gen_alignment_data(dtype=np.float64</span><span class="s0">,</span>
                                                 <span class="s1">type=</span><span class="s2">'unary'</span><span class="s0">,</span>
                                                 <span class="s1">max_size=</span><span class="s3">7</span><span class="s1">):</span>
            <span class="s1">exp = [ncu.sqrt(i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">inp]</span>
            <span class="s1">assert_almost_equal(inp**(</span><span class="s3">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">exp</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
            <span class="s1">np.sqrt(inp</span><span class="s0">, </span><span class="s1">out=out)</span>
            <span class="s1">assert_equal(out</span><span class="s0">, </span><span class="s1">exp</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

    <span class="s0">def </span><span class="s1">test_power_complex(self):</span>
        <span class="s1">x = np.array([</span><span class="s3">1</span><span class="s1">+</span><span class="s3">2j</span><span class="s0">, </span><span class="s3">2</span><span class="s1">+</span><span class="s3">3j</span><span class="s0">, </span><span class="s3">3</span><span class="s1">+</span><span class="s3">4j</span><span class="s1">])</span>
        <span class="s1">assert_equal(x**</span><span class="s3">0</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">])</span>
        <span class="s1">assert_equal(x**</span><span class="s3">1</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s1">assert_almost_equal(x**</span><span class="s3">2</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">3</span><span class="s1">+</span><span class="s3">4j</span><span class="s0">, </span><span class="s1">-</span><span class="s3">5</span><span class="s1">+</span><span class="s3">12j</span><span class="s0">, </span><span class="s1">-</span><span class="s3">7</span><span class="s1">+</span><span class="s3">24j</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(x**</span><span class="s3">3</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">1</span><span class="s1">+</span><span class="s3">2j</span><span class="s1">)**</span><span class="s3">3</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s1">+</span><span class="s3">3j</span><span class="s1">)**</span><span class="s3">3</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s1">+</span><span class="s3">4j</span><span class="s1">)**</span><span class="s3">3</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(x**</span><span class="s3">4</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">1</span><span class="s1">+</span><span class="s3">2j</span><span class="s1">)**</span><span class="s3">4</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s1">+</span><span class="s3">3j</span><span class="s1">)**</span><span class="s3">4</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s1">+</span><span class="s3">4j</span><span class="s1">)**</span><span class="s3">4</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(x**(-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">/(</span><span class="s3">1</span><span class="s1">+</span><span class="s3">2j</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">/(</span><span class="s3">2</span><span class="s1">+</span><span class="s3">3j</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">/(</span><span class="s3">3</span><span class="s1">+</span><span class="s3">4j</span><span class="s1">)])</span>
        <span class="s1">assert_almost_equal(x**(-</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">/(</span><span class="s3">1</span><span class="s1">+</span><span class="s3">2j</span><span class="s1">)**</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">/(</span><span class="s3">2</span><span class="s1">+</span><span class="s3">3j</span><span class="s1">)**</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">/(</span><span class="s3">3</span><span class="s1">+</span><span class="s3">4j</span><span class="s1">)**</span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(x**(-</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[(-</span><span class="s3">11</span><span class="s1">+</span><span class="s3">2j</span><span class="s1">)/</span><span class="s3">125</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">46</span><span class="s1">-</span><span class="s3">9j</span><span class="s1">)/</span><span class="s3">2197</span><span class="s0">,</span>
                                      <span class="s1">(-</span><span class="s3">117</span><span class="s1">-</span><span class="s3">44j</span><span class="s1">)/</span><span class="s3">15625</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(x**(</span><span class="s3">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[ncu.sqrt(</span><span class="s3">1</span><span class="s1">+</span><span class="s3">2j</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ncu.sqrt(</span><span class="s3">2</span><span class="s1">+</span><span class="s3">3j</span><span class="s1">)</span><span class="s0">,</span>
                                       <span class="s1">ncu.sqrt(</span><span class="s3">3</span><span class="s1">+</span><span class="s3">4j</span><span class="s1">)])</span>
        <span class="s1">norm = </span><span class="s3">1.</span><span class="s1">/((x**</span><span class="s3">14</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(x**</span><span class="s3">14 </span><span class="s1">* norm</span><span class="s0">,</span>
                <span class="s1">[i * norm </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">[-</span><span class="s3">76443</span><span class="s1">+</span><span class="s3">16124j</span><span class="s0">, </span><span class="s3">23161315</span><span class="s1">+</span><span class="s3">58317492j</span><span class="s0">,</span>
                                    <span class="s3">5583548873 </span><span class="s1">+ </span><span class="s3">2465133864j</span><span class="s1">]])</span>

        <span class="s5"># Ticket #836</span>
        <span class="s0">def </span><span class="s1">assert_complex_equal(x</span><span class="s0">, </span><span class="s1">y):</span>
            <span class="s1">assert_array_equal(x.real</span><span class="s0">, </span><span class="s1">y.real)</span>
            <span class="s1">assert_array_equal(x.imag</span><span class="s0">, </span><span class="s1">y.imag)</span>

        <span class="s0">for </span><span class="s1">z </span><span class="s0">in </span><span class="s1">[complex(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.inf)]:</span>
            <span class="s1">z = np.array([z]</span><span class="s0">, </span><span class="s1">dtype=np.complex_)</span>
            <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
                <span class="s1">assert_complex_equal(z**</span><span class="s3">1</span><span class="s0">, </span><span class="s1">z)</span>
                <span class="s1">assert_complex_equal(z**</span><span class="s3">2</span><span class="s0">, </span><span class="s1">z*z)</span>
                <span class="s1">assert_complex_equal(z**</span><span class="s3">3</span><span class="s0">, </span><span class="s1">z*z*z)</span>

    <span class="s0">def </span><span class="s1">test_power_zero(self):</span>
        <span class="s5"># ticket #1271</span>
        <span class="s1">zero = np.array([</span><span class="s3">0j</span><span class="s1">])</span>
        <span class="s1">one = np.array([</span><span class="s3">1</span><span class="s1">+</span><span class="s3">0j</span><span class="s1">])</span>
        <span class="s1">cnan = np.array([complex(np.nan</span><span class="s0">, </span><span class="s1">np.nan)])</span>
        <span class="s5"># FIXME cinf not tested.</span>
        <span class="s5">#cinf = np.array([complex(np.inf, 0)])</span>

        <span class="s0">def </span><span class="s1">assert_complex_equal(x</span><span class="s0">, </span><span class="s1">y):</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">y = np.asarray(x)</span><span class="s0">, </span><span class="s1">np.asarray(y)</span>
            <span class="s1">assert_array_equal(x.real</span><span class="s0">, </span><span class="s1">y.real)</span>
            <span class="s1">assert_array_equal(x.imag</span><span class="s0">, </span><span class="s1">y.imag)</span>

        <span class="s5"># positive powers</span>
        <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">[</span><span class="s3">0.33</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6.6</span><span class="s1">]:</span>
            <span class="s1">assert_complex_equal(np.power(zero</span><span class="s0">, </span><span class="s1">p)</span><span class="s0">, </span><span class="s1">zero)</span>

        <span class="s5"># zero power</span>
        <span class="s1">assert_complex_equal(np.power(zero</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">one)</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">assert_complex_equal(np.power(zero</span><span class="s0">, </span><span class="s3">0</span><span class="s1">+</span><span class="s3">1j</span><span class="s1">)</span><span class="s0">, </span><span class="s1">cnan)</span>

            <span class="s5"># negative power</span>
            <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">[</span><span class="s3">0.33</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6.6</span><span class="s1">]:</span>
                <span class="s1">assert_complex_equal(np.power(zero</span><span class="s0">, </span><span class="s1">-p)</span><span class="s0">, </span><span class="s1">cnan)</span>
            <span class="s1">assert_complex_equal(np.power(zero</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">+</span><span class="s3">0.2j</span><span class="s1">)</span><span class="s0">, </span><span class="s1">cnan)</span>

    <span class="s0">def </span><span class="s1">test_fast_power(self):</span>
        <span class="s1">x = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.int16)</span>
        <span class="s1">res = x**</span><span class="s3">2.0</span>
        <span class="s1">assert_((x**</span><span class="s3">2.00001</span><span class="s1">).dtype </span><span class="s0">is </span><span class="s1">res.dtype)</span>
        <span class="s1">assert_array_equal(res</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">9</span><span class="s1">])</span>
        <span class="s5"># check the inplace operation on the casted copy doesn't mess with x</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">np.may_share_memory(res</span><span class="s0">, </span><span class="s1">x))</span>
        <span class="s1">assert_array_equal(x</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>

        <span class="s5"># Check that the fast path ignores 1-element not 0-d arrays</span>
        <span class="s1">res = x ** np.array([[[</span><span class="s3">2</span><span class="s1">]]])</span>
        <span class="s1">assert_equal(res.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_integer_power(self):</span>
        <span class="s1">a = np.array([</span><span class="s3">15</span><span class="s0">, </span><span class="s3">15</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'i8'</span><span class="s1">)</span>
        <span class="s1">b = np.power(a</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(b</span><span class="s0">, </span><span class="s1">[</span><span class="s3">437893890380859375</span><span class="s0">, </span><span class="s3">437893890380859375</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_integer_power_with_integer_zero_exponent(self):</span>
        <span class="s1">dtypes = np.typecodes[</span><span class="s2">'Integer'</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dtypes:</span>
            <span class="s1">arr = np.arange(-</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">assert_equal(np.power(arr</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.ones_like(arr))</span>

        <span class="s1">dtypes = np.typecodes[</span><span class="s2">'UnsignedInteger'</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dtypes:</span>
            <span class="s1">arr = np.arange(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">assert_equal(np.power(arr</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.ones_like(arr))</span>

    <span class="s0">def </span><span class="s1">test_integer_power_of_1(self):</span>
        <span class="s1">dtypes = np.typecodes[</span><span class="s2">'AllInteger'</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dtypes:</span>
            <span class="s1">arr = np.arange(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">assert_equal(np.power(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">arr)</span><span class="s0">, </span><span class="s1">np.ones_like(arr))</span>

    <span class="s0">def </span><span class="s1">test_integer_power_of_zero(self):</span>
        <span class="s1">dtypes = np.typecodes[</span><span class="s2">'AllInteger'</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dtypes:</span>
            <span class="s1">arr = np.arange(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">assert_equal(np.power(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">arr)</span><span class="s0">, </span><span class="s1">np.zeros_like(arr))</span>

    <span class="s0">def </span><span class="s1">test_integer_to_negative_power(self):</span>
        <span class="s1">dtypes = np.typecodes[</span><span class="s2">'Integer'</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dtypes:</span>
            <span class="s1">a = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">b = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">one = np.array(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">minusone = np.array(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.power</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.power</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">minusone)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.power</span><span class="s0">, </span><span class="s1">one</span><span class="s0">, </span><span class="s1">b)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.power</span><span class="s0">, </span><span class="s1">one</span><span class="s0">, </span><span class="s1">minusone)</span>


<span class="s0">class </span><span class="s1">TestFloat_power:</span>
    <span class="s0">def </span><span class="s1">test_type_conversion(self):</span>
        <span class="s1">arg_type = </span><span class="s2">'?bhilBHILefdgFDG'</span>
        <span class="s1">res_type = </span><span class="s2">'ddddddddddddgDDG'</span>
        <span class="s0">for </span><span class="s1">dtin</span><span class="s0">, </span><span class="s1">dtout </span><span class="s0">in </span><span class="s1">zip(arg_type</span><span class="s0">, </span><span class="s1">res_type):</span>
            <span class="s1">msg = </span><span class="s2">&quot;dtin: %s, dtout: %s&quot; </span><span class="s1">% (dtin</span><span class="s0">, </span><span class="s1">dtout)</span>
            <span class="s1">arg = np.ones(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dtin)</span>
            <span class="s1">res = np.float_power(arg</span><span class="s0">, </span><span class="s1">arg)</span>
            <span class="s1">assert_(res.dtype.name == np.dtype(dtout).name</span><span class="s0">, </span><span class="s1">msg)</span>


<span class="s0">class </span><span class="s1">TestLog2:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'dt'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_log2_values(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s1">x = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">32</span><span class="s0">, </span><span class="s3">64</span><span class="s0">, </span><span class="s3">128</span><span class="s0">, </span><span class="s3">256</span><span class="s0">, </span><span class="s3">512</span><span class="s0">, </span><span class="s3">1024</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span>
        <span class="s1">xf = np.array(x</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
        <span class="s1">yf = np.array(y</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
        <span class="s1">assert_almost_equal(np.log2(xf)</span><span class="s0">, </span><span class="s1">yf)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;i&quot;</span><span class="s0">, </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">65</span><span class="s1">))</span>
    <span class="s0">def </span><span class="s1">test_log2_ints(self</span><span class="s0">, </span><span class="s1">i):</span>
        <span class="s5"># a good log2 implementation should provide this,</span>
        <span class="s5"># might fail on OS with bad libm</span>
        <span class="s1">v = np.log2(</span><span class="s3">2.</span><span class="s1">**i)</span>
        <span class="s1">assert_equal(v</span><span class="s0">, </span><span class="s1">float(i)</span><span class="s0">, </span><span class="s1">err_msg=</span><span class="s2">'at exponent %d' </span><span class="s1">% i)</span>

    <span class="s0">def </span><span class="s1">test_log2_special(self):</span>
        <span class="s1">assert_equal(np.log2(</span><span class="s3">1.</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.log2(np.inf)</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s1">assert_(np.isnan(np.log2(np.nan)))</span>

        <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">as </span><span class="s1">w:</span>
            <span class="s1">warnings.filterwarnings(</span><span class="s2">'always'</span><span class="s0">, </span><span class="s2">''</span><span class="s0">, </span><span class="s1">RuntimeWarning)</span>
            <span class="s1">assert_(np.isnan(np.log2(-</span><span class="s3">1.</span><span class="s1">)))</span>
            <span class="s1">assert_(np.isnan(np.log2(-np.inf)))</span>
            <span class="s1">assert_equal(np.log2(</span><span class="s3">0.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-np.inf)</span>
            <span class="s1">assert_(w[</span><span class="s3">0</span><span class="s1">].category </span><span class="s0">is </span><span class="s1">RuntimeWarning)</span>
            <span class="s1">assert_(w[</span><span class="s3">1</span><span class="s1">].category </span><span class="s0">is </span><span class="s1">RuntimeWarning)</span>
            <span class="s1">assert_(w[</span><span class="s3">2</span><span class="s1">].category </span><span class="s0">is </span><span class="s1">RuntimeWarning)</span>


<span class="s0">class </span><span class="s1">TestExp2:</span>
    <span class="s0">def </span><span class="s1">test_exp2_values(self):</span>
        <span class="s1">x = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">32</span><span class="s0">, </span><span class="s3">64</span><span class="s0">, </span><span class="s3">128</span><span class="s0">, </span><span class="s3">256</span><span class="s0">, </span><span class="s3">512</span><span class="s0">, </span><span class="s3">1024</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">]:</span>
            <span class="s1">xf = np.array(x</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">yf = np.array(y</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">assert_almost_equal(np.exp2(yf)</span><span class="s0">, </span><span class="s1">xf)</span>


<span class="s0">class </span><span class="s1">TestLogAddExp2(_FilterInvalids):</span>
    <span class="s5"># Need test for intermediate precisions</span>
    <span class="s0">def </span><span class="s1">test_logaddexp2_values(self):</span>
        <span class="s1">x = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s3">5</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">z = [</span><span class="s3">6</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">dt</span><span class="s0">, </span><span class="s1">dec_ </span><span class="s0">in </span><span class="s1">zip([</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">15</span><span class="s0">, </span><span class="s3">15</span><span class="s1">]):</span>
            <span class="s1">xf = np.log2(np.array(x</span><span class="s0">, </span><span class="s1">dtype=dt))</span>
            <span class="s1">yf = np.log2(np.array(y</span><span class="s0">, </span><span class="s1">dtype=dt))</span>
            <span class="s1">zf = np.log2(np.array(z</span><span class="s0">, </span><span class="s1">dtype=dt))</span>
            <span class="s1">assert_almost_equal(np.logaddexp2(xf</span><span class="s0">, </span><span class="s1">yf)</span><span class="s0">, </span><span class="s1">zf</span><span class="s0">, </span><span class="s1">decimal=dec_)</span>

    <span class="s0">def </span><span class="s1">test_logaddexp2_range(self):</span>
        <span class="s1">x = [</span><span class="s3">1000000</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1000000</span><span class="s0">, </span><span class="s3">1000200</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1000200</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s3">1000200</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1000200</span><span class="s0">, </span><span class="s3">1000000</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1000000</span><span class="s1">]</span>
        <span class="s1">z = [</span><span class="s3">1000200</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1000000</span><span class="s0">, </span><span class="s3">1000200</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1000000</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">]:</span>
            <span class="s1">logxf = np.array(x</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">logyf = np.array(y</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">logzf = np.array(z</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">assert_almost_equal(np.logaddexp2(logxf</span><span class="s0">, </span><span class="s1">logyf)</span><span class="s0">, </span><span class="s1">logzf)</span>

    <span class="s0">def </span><span class="s1">test_inf(self):</span>
        <span class="s1">inf = np.inf</span>
        <span class="s1">x = [inf</span><span class="s0">, </span><span class="s1">-inf</span><span class="s0">,  </span><span class="s1">inf</span><span class="s0">, </span><span class="s1">-inf</span><span class="s0">, </span><span class="s1">inf</span><span class="s0">, </span><span class="s3">1</span><span class="s0">,  </span><span class="s1">-inf</span><span class="s0">,  </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">y = [inf</span><span class="s0">,  </span><span class="s1">inf</span><span class="s0">, </span><span class="s1">-inf</span><span class="s0">, </span><span class="s1">-inf</span><span class="s0">, </span><span class="s3">1</span><span class="s0">,   </span><span class="s1">inf</span><span class="s0">, </span><span class="s3">1</span><span class="s0">,   </span><span class="s1">-inf]</span>
        <span class="s1">z = [inf</span><span class="s0">,  </span><span class="s1">inf</span><span class="s0">,  </span><span class="s1">inf</span><span class="s0">, </span><span class="s1">-inf</span><span class="s0">, </span><span class="s1">inf</span><span class="s0">, </span><span class="s1">inf</span><span class="s0">, </span><span class="s3">1</span><span class="s0">,    </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">]:</span>
                <span class="s1">logxf = np.array(x</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">logyf = np.array(y</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">logzf = np.array(z</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">assert_equal(np.logaddexp2(logxf</span><span class="s0">, </span><span class="s1">logyf)</span><span class="s0">, </span><span class="s1">logzf)</span>

    <span class="s0">def </span><span class="s1">test_nan(self):</span>
        <span class="s1">assert_(np.isnan(np.logaddexp2(np.nan</span><span class="s0">, </span><span class="s1">np.inf)))</span>
        <span class="s1">assert_(np.isnan(np.logaddexp2(np.inf</span><span class="s0">, </span><span class="s1">np.nan)))</span>
        <span class="s1">assert_(np.isnan(np.logaddexp2(np.nan</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)))</span>
        <span class="s1">assert_(np.isnan(np.logaddexp2(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">np.nan)))</span>
        <span class="s1">assert_(np.isnan(np.logaddexp2(np.nan</span><span class="s0">, </span><span class="s1">np.nan)))</span>

    <span class="s0">def </span><span class="s1">test_reduce(self):</span>
        <span class="s1">assert_equal(np.logaddexp2.identity</span><span class="s0">, </span><span class="s1">-np.inf)</span>
        <span class="s1">assert_equal(np.logaddexp2.reduce([])</span><span class="s0">, </span><span class="s1">-np.inf)</span>
        <span class="s1">assert_equal(np.logaddexp2.reduce([-np.inf])</span><span class="s0">, </span><span class="s1">-np.inf)</span>
        <span class="s1">assert_equal(np.logaddexp2.reduce([-np.inf</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestLog:</span>
    <span class="s0">def </span><span class="s1">test_log_values(self):</span>
        <span class="s1">x = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">32</span><span class="s0">, </span><span class="s3">64</span><span class="s0">, </span><span class="s3">128</span><span class="s0">, </span><span class="s3">256</span><span class="s0">, </span><span class="s3">512</span><span class="s0">, </span><span class="s3">1024</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">]:</span>
            <span class="s1">log2_ = </span><span class="s3">0.69314718055994530943</span>
            <span class="s1">xf = np.array(x</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">yf = np.array(y</span><span class="s0">, </span><span class="s1">dtype=dt)*log2_</span>
            <span class="s1">assert_almost_equal(np.log(xf)</span><span class="s0">, </span><span class="s1">yf)</span>

        <span class="s5"># test aliasing(issue #17761)</span>
        <span class="s1">x = np.array([</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0.937500</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">0.947500</span><span class="s0">, </span><span class="s3">1.054697</span><span class="s1">])</span>
        <span class="s1">xf = np.log(x)</span>
        <span class="s1">assert_almost_equal(np.log(x</span><span class="s0">, </span><span class="s1">out=x)</span><span class="s0">, </span><span class="s1">xf)</span>

        <span class="s5"># test log() of max for dtype does not raise</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">]:</span>
            <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">'raise'</span><span class="s1">):</span>
                <span class="s1">x = np.finfo(dt).max</span>
                <span class="s1">np.log(x)</span>

    <span class="s0">def </span><span class="s1">test_log_strides(self):</span>
        <span class="s1">np.random.seed(</span><span class="s3">42</span><span class="s1">)</span>
        <span class="s1">strides = np.array([-</span><span class="s3">4</span><span class="s0">,</span><span class="s1">-</span><span class="s3">3</span><span class="s0">,</span><span class="s1">-</span><span class="s3">2</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">4</span><span class="s1">])</span>
        <span class="s1">sizes = np.arange(</span><span class="s3">2</span><span class="s0">,</span><span class="s3">100</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">ii </span><span class="s0">in </span><span class="s1">sizes:</span>
            <span class="s1">x_f64 = np.float64(np.random.uniform(low=</span><span class="s3">0.01</span><span class="s0">, </span><span class="s1">high=</span><span class="s3">100.0</span><span class="s0">,</span><span class="s1">size=ii))</span>
            <span class="s1">x_special = x_f64.copy()</span>
            <span class="s1">x_special[</span><span class="s3">3</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">:</span><span class="s3">4</span><span class="s1">] = </span><span class="s3">1.0</span>
            <span class="s1">y_true = np.log(x_f64)</span>
            <span class="s1">y_special = np.log(x_special)</span>
            <span class="s0">for </span><span class="s1">jj </span><span class="s0">in </span><span class="s1">strides:</span>
                <span class="s1">assert_array_almost_equal_nulp(np.log(x_f64[::jj])</span><span class="s0">, </span><span class="s1">y_true[::jj]</span><span class="s0">, </span><span class="s1">nulp=</span><span class="s3">2</span><span class="s1">)</span>
                <span class="s1">assert_array_almost_equal_nulp(np.log(x_special[::jj])</span><span class="s0">, </span><span class="s1">y_special[::jj]</span><span class="s0">, </span><span class="s1">nulp=</span><span class="s3">2</span><span class="s1">)</span>

<span class="s0">class </span><span class="s1">TestExp:</span>
    <span class="s0">def </span><span class="s1">test_exp_values(self):</span>
        <span class="s1">x = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">32</span><span class="s0">, </span><span class="s3">64</span><span class="s0">, </span><span class="s3">128</span><span class="s0">, </span><span class="s3">256</span><span class="s0">, </span><span class="s3">512</span><span class="s0">, </span><span class="s3">1024</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">]:</span>
            <span class="s1">log2_ = </span><span class="s3">0.69314718055994530943</span>
            <span class="s1">xf = np.array(x</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">yf = np.array(y</span><span class="s0">, </span><span class="s1">dtype=dt)*log2_</span>
            <span class="s1">assert_almost_equal(np.exp(yf)</span><span class="s0">, </span><span class="s1">xf)</span>

    <span class="s0">def </span><span class="s1">test_exp_strides(self):</span>
        <span class="s1">np.random.seed(</span><span class="s3">42</span><span class="s1">)</span>
        <span class="s1">strides = np.array([-</span><span class="s3">4</span><span class="s0">,</span><span class="s1">-</span><span class="s3">3</span><span class="s0">,</span><span class="s1">-</span><span class="s3">2</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">4</span><span class="s1">])</span>
        <span class="s1">sizes = np.arange(</span><span class="s3">2</span><span class="s0">,</span><span class="s3">100</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">ii </span><span class="s0">in </span><span class="s1">sizes:</span>
            <span class="s1">x_f64 = np.float64(np.random.uniform(low=</span><span class="s3">0.01</span><span class="s0">, </span><span class="s1">high=</span><span class="s3">709.1</span><span class="s0">,</span><span class="s1">size=ii))</span>
            <span class="s1">y_true = np.exp(x_f64)</span>
            <span class="s0">for </span><span class="s1">jj </span><span class="s0">in </span><span class="s1">strides:</span>
                <span class="s1">assert_array_almost_equal_nulp(np.exp(x_f64[::jj])</span><span class="s0">, </span><span class="s1">y_true[::jj]</span><span class="s0">, </span><span class="s1">nulp=</span><span class="s3">2</span><span class="s1">)</span>

<span class="s0">class </span><span class="s1">TestSpecialFloats:</span>
    <span class="s0">def </span><span class="s1">test_exp_values(self):</span>
        <span class="s1">x = [np.nan</span><span class="s0">,  </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]</span>
        <span class="s1">y = [np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf]</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">]:</span>
            <span class="s1">xf = np.array(x</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">yf = np.array(y</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">assert_equal(np.exp(yf)</span><span class="s0">, </span><span class="s1">xf)</span>

    <span class="s5"># See: https://github.com/numpy/numpy/issues/19192</span>
    <span class="s1">@pytest.mark.xfail(</span>
        <span class="s1">glibc_older_than(</span><span class="s2">&quot;2.17&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">reason=</span><span class="s2">&quot;Older glibc versions may not raise appropriate FP exceptions&quot;</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_exp_exceptions(self):</span>
        <span class="s0">with </span><span class="s1">np.errstate(over=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.exp</span><span class="s0">, </span><span class="s1">np.float32(</span><span class="s3">100.</span><span class="s1">))</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.exp</span><span class="s0">, </span><span class="s1">np.float32(</span><span class="s3">1E19</span><span class="s1">))</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.exp</span><span class="s0">, </span><span class="s1">np.float64(</span><span class="s3">800.</span><span class="s1">))</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.exp</span><span class="s0">, </span><span class="s1">np.float64(</span><span class="s3">1E19</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">np.errstate(under=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.exp</span><span class="s0">, </span><span class="s1">np.float32(-</span><span class="s3">1000.</span><span class="s1">))</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.exp</span><span class="s0">, </span><span class="s1">np.float32(-</span><span class="s3">1E19</span><span class="s1">))</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.exp</span><span class="s0">, </span><span class="s1">np.float64(-</span><span class="s3">1000.</span><span class="s1">))</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.exp</span><span class="s0">, </span><span class="s1">np.float64(-</span><span class="s3">1E19</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_log_values(self):</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">x = [np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">np.nan]</span>
            <span class="s1">y = [np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">]</span>
            <span class="s1">y1p = [np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2.0</span><span class="s1">]</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">]:</span>
                <span class="s1">xf = np.array(x</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">yf = np.array(y</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">yf1p = np.array(y1p</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">assert_equal(np.log(yf)</span><span class="s0">, </span><span class="s1">xf)</span>
                <span class="s1">assert_equal(np.log2(yf)</span><span class="s0">, </span><span class="s1">xf)</span>
                <span class="s1">assert_equal(np.log10(yf)</span><span class="s0">, </span><span class="s1">xf)</span>
                <span class="s1">assert_equal(np.log1p(yf1p)</span><span class="s0">, </span><span class="s1">xf)</span>

        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">]:</span>
                <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.log</span><span class="s0">,</span>
                              <span class="s1">np.array(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">dtype=dt))</span>
                <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.log2</span><span class="s0">,</span>
                              <span class="s1">np.array(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">dtype=dt))</span>
                <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.log10</span><span class="s0">,</span>
                              <span class="s1">np.array(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">dtype=dt))</span>
                <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.log1p</span><span class="s0">,</span>
                              <span class="s1">np.array(-</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">dtype=dt))</span>

        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">]:</span>
                <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.log</span><span class="s0">,</span>
                              <span class="s1">np.array(-np.inf</span><span class="s0">, </span><span class="s1">dtype=dt))</span>
                <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.log</span><span class="s0">,</span>
                              <span class="s1">np.array(-</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">dtype=dt))</span>
                <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.log2</span><span class="s0">,</span>
                              <span class="s1">np.array(-np.inf</span><span class="s0">, </span><span class="s1">dtype=dt))</span>
                <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.log2</span><span class="s0">,</span>
                              <span class="s1">np.array(-</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">dtype=dt))</span>
                <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.log10</span><span class="s0">,</span>
                              <span class="s1">np.array(-np.inf</span><span class="s0">, </span><span class="s1">dtype=dt))</span>
                <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.log10</span><span class="s0">,</span>
                              <span class="s1">np.array(-</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">dtype=dt))</span>
                <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.log1p</span><span class="s0">,</span>
                              <span class="s1">np.array(-np.inf</span><span class="s0">, </span><span class="s1">dtype=dt))</span>
                <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.log1p</span><span class="s0">,</span>
                              <span class="s1">np.array(-</span><span class="s3">2.0</span><span class="s0">, </span><span class="s1">dtype=dt))</span>

        <span class="s5"># See https://github.com/numpy/numpy/issues/18005</span>
        <span class="s0">with </span><span class="s1">assert_no_warnings():</span>
            <span class="s1">a = np.array(</span><span class="s3">1e9</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'float32'</span><span class="s1">)</span>
            <span class="s1">np.log(a)</span>

    <span class="s0">def </span><span class="s1">test_sincos_values(self):</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">x = [np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span>
            <span class="s1">y = [np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf]</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">]:</span>
                <span class="s1">xf = np.array(x</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">yf = np.array(y</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">assert_equal(np.sin(yf)</span><span class="s0">, </span><span class="s1">xf)</span>
                <span class="s1">assert_equal(np.cos(yf)</span><span class="s0">, </span><span class="s1">xf)</span>

        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.sin</span><span class="s0">, </span><span class="s1">np.float32(-np.inf))</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.sin</span><span class="s0">, </span><span class="s1">np.float32(np.inf))</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.cos</span><span class="s0">, </span><span class="s1">np.float32(-np.inf))</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.cos</span><span class="s0">, </span><span class="s1">np.float32(np.inf))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'dt'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_sqrt_values(self</span><span class="s0">, </span><span class="s1">dt):</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">x = [np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]</span>
            <span class="s1">y = [np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]</span>
            <span class="s1">xf = np.array(x</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">yf = np.array(y</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">assert_equal(np.sqrt(yf)</span><span class="s0">, </span><span class="s1">xf)</span>

        <span class="s5"># with np.errstate(invalid='raise'):</span>
        <span class="s5">#     assert_raises(</span>
        <span class="s5">#         FloatingPointError, np.sqrt, np.array(-100., dtype=dt)</span>
        <span class="s5">#     )</span>

    <span class="s0">def </span><span class="s1">test_abs_values(self):</span>
        <span class="s1">x = [np.nan</span><span class="s0">,  </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span>
        <span class="s1">y = [np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s3">0.</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">]:</span>
            <span class="s1">xf = np.array(x</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">yf = np.array(y</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">assert_equal(np.abs(yf)</span><span class="s0">, </span><span class="s1">xf)</span>

    <span class="s0">def </span><span class="s1">test_square_values(self):</span>
        <span class="s1">x = [np.nan</span><span class="s0">,  </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf]</span>
        <span class="s1">y = [np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf]</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">]:</span>
                <span class="s1">xf = np.array(x</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">yf = np.array(y</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">assert_equal(np.square(yf)</span><span class="s0">, </span><span class="s1">xf)</span>

        <span class="s0">with </span><span class="s1">np.errstate(over=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.square</span><span class="s0">,</span>
                          <span class="s1">np.array(</span><span class="s3">1E32</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'f'</span><span class="s1">))</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.square</span><span class="s0">,</span>
                          <span class="s1">np.array(</span><span class="s3">1E200</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'d'</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_reciprocal_values(self):</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">x = [np.nan</span><span class="s0">,  </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf]</span>
            <span class="s1">y = [np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s3">0.</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.</span><span class="s1">]</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">]:</span>
                <span class="s1">xf = np.array(x</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">yf = np.array(y</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">assert_equal(np.reciprocal(yf)</span><span class="s0">, </span><span class="s1">xf)</span>

        <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">]:</span>
                <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.reciprocal</span><span class="s0">,</span>
                              <span class="s1">np.array(-</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">dtype=dt))</span>

    <span class="s0">def </span><span class="s1">test_tan(self):</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">in_ = [np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf]</span>
            <span class="s1">out = [np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">]:</span>
                <span class="s1">in_arr = np.array(in_</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">out_arr = np.array(out</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">assert_equal(np.tan(in_arr)</span><span class="s0">, </span><span class="s1">out_arr)</span>

        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">]:</span>
                <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.tan</span><span class="s0">,</span>
                              <span class="s1">np.array(np.inf</span><span class="s0">, </span><span class="s1">dtype=dt))</span>
                <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.tan</span><span class="s0">,</span>
                              <span class="s1">np.array(-np.inf</span><span class="s0">, </span><span class="s1">dtype=dt))</span>

    <span class="s0">def </span><span class="s1">test_arcsincos(self):</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">in_ = [np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf]</span>
            <span class="s1">out = [np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">]:</span>
                <span class="s1">in_arr = np.array(in_</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">out_arr = np.array(out</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">assert_equal(np.arcsin(in_arr)</span><span class="s0">, </span><span class="s1">out_arr)</span>
                <span class="s1">assert_equal(np.arccos(in_arr)</span><span class="s0">, </span><span class="s1">out_arr)</span>

        <span class="s0">for </span><span class="s1">callable </span><span class="s0">in </span><span class="s1">[np.arcsin</span><span class="s0">, </span><span class="s1">np.arccos]:</span>
            <span class="s0">for </span><span class="s1">value </span><span class="s0">in </span><span class="s1">[np.inf</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2.0</span><span class="s1">]:</span>
                <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">]:</span>
                    <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'raise'</span><span class="s1">):</span>
                        <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">callable</span><span class="s0">,</span>
                                      <span class="s1">np.array(value</span><span class="s0">, </span><span class="s1">dtype=dt))</span>

    <span class="s0">def </span><span class="s1">test_arctan(self):</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">in_ = [np.nan</span><span class="s0">, </span><span class="s1">-np.nan]</span>
            <span class="s1">out = [np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">]:</span>
                <span class="s1">in_arr = np.array(in_</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">out_arr = np.array(out</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">assert_equal(np.arctan(in_arr)</span><span class="s0">, </span><span class="s1">out_arr)</span>

    <span class="s0">def </span><span class="s1">test_sinh(self):</span>
        <span class="s1">in_ = [np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf]</span>
        <span class="s1">out = [np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf]</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">]:</span>
            <span class="s1">in_arr = np.array(in_</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">out_arr = np.array(out</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">assert_equal(np.sinh(in_arr)</span><span class="s0">, </span><span class="s1">out_arr)</span>

        <span class="s0">with </span><span class="s1">np.errstate(over=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.sinh</span><span class="s0">,</span>
                          <span class="s1">np.array(</span><span class="s3">120.0</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'f'</span><span class="s1">))</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.sinh</span><span class="s0">,</span>
                          <span class="s1">np.array(</span><span class="s3">1200.0</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'d'</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_cosh(self):</span>
        <span class="s1">in_ = [np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf]</span>
        <span class="s1">out = [np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.inf]</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">]:</span>
            <span class="s1">in_arr = np.array(in_</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">out_arr = np.array(out</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">assert_equal(np.cosh(in_arr)</span><span class="s0">, </span><span class="s1">out_arr)</span>

        <span class="s0">with </span><span class="s1">np.errstate(over=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.cosh</span><span class="s0">,</span>
                          <span class="s1">np.array(</span><span class="s3">120.0</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'f'</span><span class="s1">))</span>
            <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.cosh</span><span class="s0">,</span>
                          <span class="s1">np.array(</span><span class="s3">1200.0</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'d'</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_tanh(self):</span>
        <span class="s1">in_ = [np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf]</span>
        <span class="s1">out = [np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">]:</span>
            <span class="s1">in_arr = np.array(in_</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">out_arr = np.array(out</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">assert_equal(np.tanh(in_arr)</span><span class="s0">, </span><span class="s1">out_arr)</span>

    <span class="s0">def </span><span class="s1">test_arcsinh(self):</span>
        <span class="s1">in_ = [np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf]</span>
        <span class="s1">out = [np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf]</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">]:</span>
            <span class="s1">in_arr = np.array(in_</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">out_arr = np.array(out</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">assert_equal(np.arcsinh(in_arr)</span><span class="s0">, </span><span class="s1">out_arr)</span>

    <span class="s0">def </span><span class="s1">test_arccosh(self):</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">in_ = [np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">]</span>
            <span class="s1">out = [np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">np.nan]</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">]:</span>
                <span class="s1">in_arr = np.array(in_</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">out_arr = np.array(out</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">assert_equal(np.arccosh(in_arr)</span><span class="s0">, </span><span class="s1">out_arr)</span>

        <span class="s0">for </span><span class="s1">value </span><span class="s0">in </span><span class="s1">[</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">-np.inf]:</span>
            <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'raise'</span><span class="s1">):</span>
                <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">]:</span>
                    <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.arccosh</span><span class="s0">,</span>
                                  <span class="s1">np.array(value</span><span class="s0">, </span><span class="s1">dtype=dt))</span>

    <span class="s0">def </span><span class="s1">test_arctanh(self):</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">in_ = [np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">]</span>
            <span class="s1">out = [np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">np.nan]</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">]:</span>
                <span class="s1">in_arr = np.array(in_</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">out_arr = np.array(out</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">assert_equal(np.arctanh(in_arr)</span><span class="s0">, </span><span class="s1">out_arr)</span>

        <span class="s0">for </span><span class="s1">value </span><span class="s0">in </span><span class="s1">[</span><span class="s3">1.01</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">]:</span>
            <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'raise'</span><span class="s0">, </span><span class="s1">divide=</span><span class="s2">'raise'</span><span class="s1">):</span>
                <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">]:</span>
                    <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.arctanh</span><span class="s0">,</span>
                                  <span class="s1">np.array(value</span><span class="s0">, </span><span class="s1">dtype=dt))</span>

    <span class="s0">def </span><span class="s1">test_exp2(self):</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">in_ = [np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf]</span>
            <span class="s1">out = [np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">]</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">]:</span>
                <span class="s1">in_arr = np.array(in_</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">out_arr = np.array(out</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">assert_equal(np.exp2(in_arr)</span><span class="s0">, </span><span class="s1">out_arr)</span>

        <span class="s0">for </span><span class="s1">value </span><span class="s0">in </span><span class="s1">[</span><span class="s3">2000.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2000.0</span><span class="s1">]:</span>
            <span class="s0">with </span><span class="s1">np.errstate(over=</span><span class="s2">'raise'</span><span class="s0">, </span><span class="s1">under=</span><span class="s2">'raise'</span><span class="s1">):</span>
                <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">]:</span>
                    <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.exp2</span><span class="s0">,</span>
                                  <span class="s1">np.array(value</span><span class="s0">, </span><span class="s1">dtype=dt))</span>

    <span class="s0">def </span><span class="s1">test_expm1(self):</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">in_ = [np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf]</span>
            <span class="s1">out = [np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">]</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">]:</span>
                <span class="s1">in_arr = np.array(in_</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">out_arr = np.array(out</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">assert_equal(np.expm1(in_arr)</span><span class="s0">, </span><span class="s1">out_arr)</span>

        <span class="s0">for </span><span class="s1">value </span><span class="s0">in </span><span class="s1">[</span><span class="s3">200.0</span><span class="s0">, </span><span class="s3">2000.0</span><span class="s1">]:</span>
            <span class="s0">with </span><span class="s1">np.errstate(over=</span><span class="s2">'raise'</span><span class="s1">):</span>
                <span class="s1">assert_raises(FloatingPointError</span><span class="s0">, </span><span class="s1">np.expm1</span><span class="s0">,</span>
                              <span class="s1">np.array(value</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'f'</span><span class="s1">))</span>

<span class="s0">class </span><span class="s1">TestFPClass:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;stride&quot;</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">4</span><span class="s0">,</span><span class="s1">-</span><span class="s3">2</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">4</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_fpclass(self</span><span class="s0">, </span><span class="s1">stride):</span>
        <span class="s1">arr_f64 = np.array([np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">2.2251e-308</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2.2251e-308</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'d'</span><span class="s1">)</span>
        <span class="s1">arr_f32 = np.array([np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.4013e-045</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.4013e-045</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'f'</span><span class="s1">)</span>
        <span class="s1">nan     = np.array([</span><span class="s0">True, True, False, False, False, False, False, False, False, False</span><span class="s1">])</span>
        <span class="s1">inf     = np.array([</span><span class="s0">False, False, True, True, False, False, False, False, False, False</span><span class="s1">])</span>
        <span class="s1">sign    = np.array([</span><span class="s0">False, True, False, True, True, False, True, False, False, True</span><span class="s1">])</span>
        <span class="s1">finite  = np.array([</span><span class="s0">False, False, False, False, True, True, True, True, True, True</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.isnan(arr_f32[::stride])</span><span class="s0">, </span><span class="s1">nan[::stride])</span>
        <span class="s1">assert_equal(np.isnan(arr_f64[::stride])</span><span class="s0">, </span><span class="s1">nan[::stride])</span>
        <span class="s1">assert_equal(np.isinf(arr_f32[::stride])</span><span class="s0">, </span><span class="s1">inf[::stride])</span>
        <span class="s1">assert_equal(np.isinf(arr_f64[::stride])</span><span class="s0">, </span><span class="s1">inf[::stride])</span>
        <span class="s1">assert_equal(np.signbit(arr_f32[::stride])</span><span class="s0">, </span><span class="s1">sign[::stride])</span>
        <span class="s1">assert_equal(np.signbit(arr_f64[::stride])</span><span class="s0">, </span><span class="s1">sign[::stride])</span>
        <span class="s1">assert_equal(np.isfinite(arr_f32[::stride])</span><span class="s0">, </span><span class="s1">finite[::stride])</span>
        <span class="s1">assert_equal(np.isfinite(arr_f64[::stride])</span><span class="s0">, </span><span class="s1">finite[::stride])</span>

<span class="s0">class </span><span class="s1">TestLDExp:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;stride&quot;</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">4</span><span class="s0">,</span><span class="s1">-</span><span class="s3">2</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">4</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_ldexp(self</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">stride):</span>
        <span class="s1">mant = np.array([</span><span class="s3">0.125</span><span class="s0">, </span><span class="s3">0.25</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s0">, </span><span class="s3">4.</span><span class="s0">, </span><span class="s3">8.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">exp  = np.array([</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'i'</span><span class="s1">)</span>
        <span class="s1">out  = np.zeros(</span><span class="s3">8</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">assert_equal(np.ldexp(mant[::stride]</span><span class="s0">, </span><span class="s1">exp[::stride]</span><span class="s0">, </span><span class="s1">out=out[::stride])</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s3">8</span><span class="s0">, </span><span class="s1">dtype=dtype)[::stride])</span>
        <span class="s1">assert_equal(out[::stride]</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s3">8</span><span class="s0">, </span><span class="s1">dtype=dtype)[::stride])</span>

<span class="s0">class </span><span class="s1">TestFRExp:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;stride&quot;</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">4</span><span class="s0">,</span><span class="s1">-</span><span class="s3">2</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">4</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">sys.platform.startswith(</span><span class="s2">'linux'</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">reason=</span><span class="s2">&quot;np.frexp gives different answers for NAN/INF on windows and linux&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_frexp(self</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">stride):</span>
        <span class="s1">arr = np.array([np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">mant_true = np.array([np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">exp_true  = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'i'</span><span class="s1">)</span>
        <span class="s1">out_mant  = np.ones(</span><span class="s3">8</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">out_exp   = </span><span class="s3">2</span><span class="s1">*np.ones(</span><span class="s3">8</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'i'</span><span class="s1">)</span>
        <span class="s1">mant</span><span class="s0">, </span><span class="s1">exp = np.frexp(arr[::stride]</span><span class="s0">, </span><span class="s1">out=(out_mant[::stride]</span><span class="s0">, </span><span class="s1">out_exp[::stride]))</span>
        <span class="s1">assert_equal(mant_true[::stride]</span><span class="s0">, </span><span class="s1">mant)</span>
        <span class="s1">assert_equal(exp_true[::stride]</span><span class="s0">, </span><span class="s1">exp)</span>
        <span class="s1">assert_equal(out_mant[::stride]</span><span class="s0">, </span><span class="s1">mant_true[::stride])</span>
        <span class="s1">assert_equal(out_exp[::stride]</span><span class="s0">, </span><span class="s1">exp_true[::stride])</span>

<span class="s5"># func : [maxulperror, low, high]</span>
<span class="s1">avx_ufuncs = {</span><span class="s2">'sqrt'        </span><span class="s1">:[</span><span class="s3">1</span><span class="s0">,  </span><span class="s3">0.</span><span class="s0">,   </span><span class="s3">100.</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s2">'absolute'    </span><span class="s1">:[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">100.</span><span class="s0">, </span><span class="s3">100.</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s2">'reciprocal'  </span><span class="s1">:[</span><span class="s3">1</span><span class="s0">,  </span><span class="s3">1.</span><span class="s0">,   </span><span class="s3">100.</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s2">'square'      </span><span class="s1">:[</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">100.</span><span class="s0">, </span><span class="s3">100.</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s2">'rint'        </span><span class="s1">:[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">100.</span><span class="s0">, </span><span class="s3">100.</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s2">'floor'       </span><span class="s1">:[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">100.</span><span class="s0">, </span><span class="s3">100.</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s2">'ceil'        </span><span class="s1">:[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">100.</span><span class="s0">, </span><span class="s3">100.</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s2">'trunc'       </span><span class="s1">:[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">100.</span><span class="s0">, </span><span class="s3">100.</span><span class="s1">]}</span>

<span class="s0">class </span><span class="s1">TestAVXUfuncs:</span>
    <span class="s0">def </span><span class="s1">test_avx_based_ufunc(self):</span>
        <span class="s1">strides = np.array([-</span><span class="s3">4</span><span class="s0">,</span><span class="s1">-</span><span class="s3">3</span><span class="s0">,</span><span class="s1">-</span><span class="s3">2</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">4</span><span class="s1">])</span>
        <span class="s1">np.random.seed(</span><span class="s3">42</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">func</span><span class="s0">, </span><span class="s1">prop </span><span class="s0">in </span><span class="s1">avx_ufuncs.items():</span>
            <span class="s1">maxulperr = prop[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">minval = prop[</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">maxval = prop[</span><span class="s3">2</span><span class="s1">]</span>
            <span class="s5"># various array sizes to ensure masking in AVX is tested</span>
            <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">,</span><span class="s3">32</span><span class="s1">):</span>
                <span class="s1">myfunc = getattr(np</span><span class="s0">, </span><span class="s1">func)</span>
                <span class="s1">x_f32 = np.float32(np.random.uniform(low=minval</span><span class="s0">, </span><span class="s1">high=maxval</span><span class="s0">,</span>
                    <span class="s1">size=size))</span>
                <span class="s1">x_f64 = np.float64(x_f32)</span>
                <span class="s1">x_f128 = np.longdouble(x_f32)</span>
                <span class="s1">y_true128 = myfunc(x_f128)</span>
                <span class="s0">if </span><span class="s1">maxulperr == </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">assert_equal(myfunc(x_f32)</span><span class="s0">, </span><span class="s1">np.float32(y_true128))</span>
                    <span class="s1">assert_equal(myfunc(x_f64)</span><span class="s0">, </span><span class="s1">np.float64(y_true128))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">assert_array_max_ulp(myfunc(x_f32)</span><span class="s0">, </span><span class="s1">np.float32(y_true128)</span><span class="s0">,</span>
                            <span class="s1">maxulp=maxulperr)</span>
                    <span class="s1">assert_array_max_ulp(myfunc(x_f64)</span><span class="s0">, </span><span class="s1">np.float64(y_true128)</span><span class="s0">,</span>
                            <span class="s1">maxulp=maxulperr)</span>
                <span class="s5"># various strides to test gather instruction</span>
                <span class="s0">if </span><span class="s1">size &gt; </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s1">y_true32 = myfunc(x_f32)</span>
                    <span class="s1">y_true64 = myfunc(x_f64)</span>
                    <span class="s0">for </span><span class="s1">jj </span><span class="s0">in </span><span class="s1">strides:</span>
                        <span class="s1">assert_equal(myfunc(x_f64[::jj])</span><span class="s0">, </span><span class="s1">y_true64[::jj])</span>
                        <span class="s1">assert_equal(myfunc(x_f32[::jj])</span><span class="s0">, </span><span class="s1">y_true32[::jj])</span>

<span class="s0">class </span><span class="s1">TestAVXFloat32Transcendental:</span>
    <span class="s0">def </span><span class="s1">test_exp_float32(self):</span>
        <span class="s1">np.random.seed(</span><span class="s3">42</span><span class="s1">)</span>
        <span class="s1">x_f32 = np.float32(np.random.uniform(low=</span><span class="s3">0.0</span><span class="s0">,</span><span class="s1">high=</span><span class="s3">88.1</span><span class="s0">,</span><span class="s1">size=</span><span class="s3">1000000</span><span class="s1">))</span>
        <span class="s1">x_f64 = np.float64(x_f32)</span>
        <span class="s1">assert_array_max_ulp(np.exp(x_f32)</span><span class="s0">, </span><span class="s1">np.float32(np.exp(x_f64))</span><span class="s0">, </span><span class="s1">maxulp=</span><span class="s3">3</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_log_float32(self):</span>
        <span class="s1">np.random.seed(</span><span class="s3">42</span><span class="s1">)</span>
        <span class="s1">x_f32 = np.float32(np.random.uniform(low=</span><span class="s3">0.0</span><span class="s0">,</span><span class="s1">high=</span><span class="s3">1000</span><span class="s0">,</span><span class="s1">size=</span><span class="s3">1000000</span><span class="s1">))</span>
        <span class="s1">x_f64 = np.float64(x_f32)</span>
        <span class="s1">assert_array_max_ulp(np.log(x_f32)</span><span class="s0">, </span><span class="s1">np.float32(np.log(x_f64))</span><span class="s0">, </span><span class="s1">maxulp=</span><span class="s3">4</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_sincos_float32(self):</span>
        <span class="s1">np.random.seed(</span><span class="s3">42</span><span class="s1">)</span>
        <span class="s1">N = </span><span class="s3">1000000</span>
        <span class="s1">M = np.int_(N/</span><span class="s3">20</span><span class="s1">)</span>
        <span class="s1">index = np.random.randint(low=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">high=N</span><span class="s0">, </span><span class="s1">size=M)</span>
        <span class="s1">x_f32 = np.float32(np.random.uniform(low=-</span><span class="s3">100.</span><span class="s0">,</span><span class="s1">high=</span><span class="s3">100.</span><span class="s0">,</span><span class="s1">size=N))</span>
        <span class="s0">if not </span><span class="s1">glibc_older_than(</span><span class="s2">&quot;2.17&quot;</span><span class="s1">):</span>
            <span class="s5"># test coverage for elements &gt; 117435.992f for which glibc is used</span>
            <span class="s5"># this is known to be problematic on old glibc, so skip it there</span>
            <span class="s1">x_f32[index] = np.float32(</span><span class="s3">10E+10</span><span class="s1">*np.random.rand(M))</span>
        <span class="s1">x_f64 = np.float64(x_f32)</span>
        <span class="s1">assert_array_max_ulp(np.sin(x_f32)</span><span class="s0">, </span><span class="s1">np.float32(np.sin(x_f64))</span><span class="s0">, </span><span class="s1">maxulp=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">assert_array_max_ulp(np.cos(x_f32)</span><span class="s0">, </span><span class="s1">np.float32(np.cos(x_f64))</span><span class="s0">, </span><span class="s1">maxulp=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s5"># test aliasing(issue #17761)</span>
        <span class="s1">tx_f32 = x_f32.copy()</span>
        <span class="s1">assert_array_max_ulp(np.sin(x_f32</span><span class="s0">, </span><span class="s1">out=x_f32)</span><span class="s0">, </span><span class="s1">np.float32(np.sin(x_f64))</span><span class="s0">, </span><span class="s1">maxulp=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">assert_array_max_ulp(np.cos(tx_f32</span><span class="s0">, </span><span class="s1">out=tx_f32)</span><span class="s0">, </span><span class="s1">np.float32(np.cos(x_f64))</span><span class="s0">, </span><span class="s1">maxulp=</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_strided_float32(self):</span>
        <span class="s1">np.random.seed(</span><span class="s3">42</span><span class="s1">)</span>
        <span class="s1">strides = np.array([-</span><span class="s3">4</span><span class="s0">,</span><span class="s1">-</span><span class="s3">3</span><span class="s0">,</span><span class="s1">-</span><span class="s3">2</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s3">4</span><span class="s1">])</span>
        <span class="s1">sizes = np.arange(</span><span class="s3">2</span><span class="s0">,</span><span class="s3">100</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">ii </span><span class="s0">in </span><span class="s1">sizes:</span>
            <span class="s1">x_f32 = np.float32(np.random.uniform(low=</span><span class="s3">0.01</span><span class="s0">,</span><span class="s1">high=</span><span class="s3">88.1</span><span class="s0">,</span><span class="s1">size=ii))</span>
            <span class="s1">x_f32_large = x_f32.copy()</span>
            <span class="s1">x_f32_large[</span><span class="s3">3</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">:</span><span class="s3">4</span><span class="s1">] = </span><span class="s3">120000.0</span>
            <span class="s1">exp_true = np.exp(x_f32)</span>
            <span class="s1">log_true = np.log(x_f32)</span>
            <span class="s1">sin_true = np.sin(x_f32_large)</span>
            <span class="s1">cos_true = np.cos(x_f32_large)</span>
            <span class="s0">for </span><span class="s1">jj </span><span class="s0">in </span><span class="s1">strides:</span>
                <span class="s1">assert_array_almost_equal_nulp(np.exp(x_f32[::jj])</span><span class="s0">, </span><span class="s1">exp_true[::jj]</span><span class="s0">, </span><span class="s1">nulp=</span><span class="s3">2</span><span class="s1">)</span>
                <span class="s1">assert_array_almost_equal_nulp(np.log(x_f32[::jj])</span><span class="s0">, </span><span class="s1">log_true[::jj]</span><span class="s0">, </span><span class="s1">nulp=</span><span class="s3">2</span><span class="s1">)</span>
                <span class="s1">assert_array_almost_equal_nulp(np.sin(x_f32_large[::jj])</span><span class="s0">, </span><span class="s1">sin_true[::jj]</span><span class="s0">, </span><span class="s1">nulp=</span><span class="s3">2</span><span class="s1">)</span>
                <span class="s1">assert_array_almost_equal_nulp(np.cos(x_f32_large[::jj])</span><span class="s0">, </span><span class="s1">cos_true[::jj]</span><span class="s0">, </span><span class="s1">nulp=</span><span class="s3">2</span><span class="s1">)</span>

<span class="s0">class </span><span class="s1">TestLogAddExp(_FilterInvalids):</span>
    <span class="s0">def </span><span class="s1">test_logaddexp_values(self):</span>
        <span class="s1">x = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s3">5</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">z = [</span><span class="s3">6</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">dt</span><span class="s0">, </span><span class="s1">dec_ </span><span class="s0">in </span><span class="s1">zip([</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">15</span><span class="s0">, </span><span class="s3">15</span><span class="s1">]):</span>
            <span class="s1">xf = np.log(np.array(x</span><span class="s0">, </span><span class="s1">dtype=dt))</span>
            <span class="s1">yf = np.log(np.array(y</span><span class="s0">, </span><span class="s1">dtype=dt))</span>
            <span class="s1">zf = np.log(np.array(z</span><span class="s0">, </span><span class="s1">dtype=dt))</span>
            <span class="s1">assert_almost_equal(np.logaddexp(xf</span><span class="s0">, </span><span class="s1">yf)</span><span class="s0">, </span><span class="s1">zf</span><span class="s0">, </span><span class="s1">decimal=dec_)</span>

    <span class="s0">def </span><span class="s1">test_logaddexp_range(self):</span>
        <span class="s1">x = [</span><span class="s3">1000000</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1000000</span><span class="s0">, </span><span class="s3">1000200</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1000200</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s3">1000200</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1000200</span><span class="s0">, </span><span class="s3">1000000</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1000000</span><span class="s1">]</span>
        <span class="s1">z = [</span><span class="s3">1000200</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1000000</span><span class="s0">, </span><span class="s3">1000200</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1000000</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">]:</span>
            <span class="s1">logxf = np.array(x</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">logyf = np.array(y</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">logzf = np.array(z</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">assert_almost_equal(np.logaddexp(logxf</span><span class="s0">, </span><span class="s1">logyf)</span><span class="s0">, </span><span class="s1">logzf)</span>

    <span class="s0">def </span><span class="s1">test_inf(self):</span>
        <span class="s1">inf = np.inf</span>
        <span class="s1">x = [inf</span><span class="s0">, </span><span class="s1">-inf</span><span class="s0">,  </span><span class="s1">inf</span><span class="s0">, </span><span class="s1">-inf</span><span class="s0">, </span><span class="s1">inf</span><span class="s0">, </span><span class="s3">1</span><span class="s0">,  </span><span class="s1">-inf</span><span class="s0">,  </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">y = [inf</span><span class="s0">,  </span><span class="s1">inf</span><span class="s0">, </span><span class="s1">-inf</span><span class="s0">, </span><span class="s1">-inf</span><span class="s0">, </span><span class="s3">1</span><span class="s0">,   </span><span class="s1">inf</span><span class="s0">, </span><span class="s3">1</span><span class="s0">,   </span><span class="s1">-inf]</span>
        <span class="s1">z = [inf</span><span class="s0">,  </span><span class="s1">inf</span><span class="s0">,  </span><span class="s1">inf</span><span class="s0">, </span><span class="s1">-inf</span><span class="s0">, </span><span class="s1">inf</span><span class="s0">, </span><span class="s1">inf</span><span class="s0">, </span><span class="s3">1</span><span class="s0">,    </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'raise'</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">[</span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">]:</span>
                <span class="s1">logxf = np.array(x</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">logyf = np.array(y</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">logzf = np.array(z</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">assert_equal(np.logaddexp(logxf</span><span class="s0">, </span><span class="s1">logyf)</span><span class="s0">, </span><span class="s1">logzf)</span>

    <span class="s0">def </span><span class="s1">test_nan(self):</span>
        <span class="s1">assert_(np.isnan(np.logaddexp(np.nan</span><span class="s0">, </span><span class="s1">np.inf)))</span>
        <span class="s1">assert_(np.isnan(np.logaddexp(np.inf</span><span class="s0">, </span><span class="s1">np.nan)))</span>
        <span class="s1">assert_(np.isnan(np.logaddexp(np.nan</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)))</span>
        <span class="s1">assert_(np.isnan(np.logaddexp(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">np.nan)))</span>
        <span class="s1">assert_(np.isnan(np.logaddexp(np.nan</span><span class="s0">, </span><span class="s1">np.nan)))</span>

    <span class="s0">def </span><span class="s1">test_reduce(self):</span>
        <span class="s1">assert_equal(np.logaddexp.identity</span><span class="s0">, </span><span class="s1">-np.inf)</span>
        <span class="s1">assert_equal(np.logaddexp.reduce([])</span><span class="s0">, </span><span class="s1">-np.inf)</span>


<span class="s0">class </span><span class="s1">TestLog1p:</span>
    <span class="s0">def </span><span class="s1">test_log1p(self):</span>
        <span class="s1">assert_almost_equal(ncu.log1p(</span><span class="s3">0.2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ncu.log(</span><span class="s3">1.2</span><span class="s1">))</span>
        <span class="s1">assert_almost_equal(ncu.log1p(</span><span class="s3">1e-6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ncu.log(</span><span class="s3">1</span><span class="s1">+</span><span class="s3">1e-6</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_special(self):</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">divide=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">assert_equal(ncu.log1p(np.nan)</span><span class="s0">, </span><span class="s1">np.nan)</span>
            <span class="s1">assert_equal(ncu.log1p(np.inf)</span><span class="s0">, </span><span class="s1">np.inf)</span>
            <span class="s1">assert_equal(ncu.log1p(-</span><span class="s3">1.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-np.inf)</span>
            <span class="s1">assert_equal(ncu.log1p(-</span><span class="s3">2.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.nan)</span>
            <span class="s1">assert_equal(ncu.log1p(-np.inf)</span><span class="s0">, </span><span class="s1">np.nan)</span>


<span class="s0">class </span><span class="s1">TestExpm1:</span>
    <span class="s0">def </span><span class="s1">test_expm1(self):</span>
        <span class="s1">assert_almost_equal(ncu.expm1(</span><span class="s3">0.2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ncu.exp(</span><span class="s3">0.2</span><span class="s1">)-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(ncu.expm1(</span><span class="s3">1e-6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ncu.exp(</span><span class="s3">1e-6</span><span class="s1">)-</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_special(self):</span>
        <span class="s1">assert_equal(ncu.expm1(np.inf)</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s1">assert_equal(ncu.expm1(</span><span class="s3">0.</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">)</span>
        <span class="s1">assert_equal(ncu.expm1(-</span><span class="s3">0.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.</span><span class="s1">)</span>
        <span class="s1">assert_equal(ncu.expm1(np.inf)</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s1">assert_equal(ncu.expm1(-np.inf)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_complex(self):</span>
        <span class="s1">x = np.asarray(</span><span class="s3">1e-12</span><span class="s1">)</span>
        <span class="s1">assert_allclose(x</span><span class="s0">, </span><span class="s1">ncu.expm1(x))</span>
        <span class="s1">x = x.astype(np.complex128)</span>
        <span class="s1">assert_allclose(x</span><span class="s0">, </span><span class="s1">ncu.expm1(x))</span>


<span class="s0">class </span><span class="s1">TestHypot:</span>
    <span class="s0">def </span><span class="s1">test_simple(self):</span>
        <span class="s1">assert_almost_equal(ncu.hypot(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ncu.sqrt(</span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">assert_almost_equal(ncu.hypot(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_reduce(self):</span>
        <span class="s1">assert_almost_equal(ncu.hypot.reduce([</span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">4.0</span><span class="s1">])</span><span class="s0">, </span><span class="s3">5.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(ncu.hypot.reduce([</span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s3">5.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(ncu.hypot.reduce([</span><span class="s3">9.0</span><span class="s0">, </span><span class="s3">12.0</span><span class="s0">, </span><span class="s3">20.0</span><span class="s1">])</span><span class="s0">, </span><span class="s3">25.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(ncu.hypot.reduce([])</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">assert_hypot_isnan(x</span><span class="s0">, </span><span class="s1">y):</span>
    <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'ignore'</span><span class="s1">):</span>
        <span class="s1">assert_(np.isnan(ncu.hypot(x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">,</span>
                <span class="s2">&quot;hypot(%s, %s) is %s, not nan&quot; </span><span class="s1">% (x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">ncu.hypot(x</span><span class="s0">, </span><span class="s1">y)))</span>


<span class="s0">def </span><span class="s1">assert_hypot_isinf(x</span><span class="s0">, </span><span class="s1">y):</span>
    <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'ignore'</span><span class="s1">):</span>
        <span class="s1">assert_(np.isinf(ncu.hypot(x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">,</span>
                <span class="s2">&quot;hypot(%s, %s) is %s, not inf&quot; </span><span class="s1">% (x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">ncu.hypot(x</span><span class="s0">, </span><span class="s1">y)))</span>


<span class="s0">class </span><span class="s1">TestHypotSpecialValues:</span>
    <span class="s0">def </span><span class="s1">test_nan_outputs(self):</span>
        <span class="s1">assert_hypot_isnan(np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">assert_hypot_isnan(np.nan</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_nan_outputs2(self):</span>
        <span class="s1">assert_hypot_isinf(np.nan</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s1">assert_hypot_isinf(np.inf</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">assert_hypot_isinf(np.inf</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_hypot_isinf(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s1">assert_hypot_isinf(np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s1">assert_hypot_isinf(np.inf</span><span class="s0">, </span><span class="s3">23.0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_no_fpe(self):</span>
        <span class="s1">assert_no_warnings(ncu.hypot</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">assert_arctan2_isnan(x</span><span class="s0">, </span><span class="s1">y):</span>
    <span class="s1">assert_(np.isnan(ncu.arctan2(x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s2">&quot;arctan(%s, %s) is %s, not nan&quot; </span><span class="s1">% (x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">ncu.arctan2(x</span><span class="s0">, </span><span class="s1">y)))</span>


<span class="s0">def </span><span class="s1">assert_arctan2_ispinf(x</span><span class="s0">, </span><span class="s1">y):</span>
    <span class="s1">assert_((np.isinf(ncu.arctan2(x</span><span class="s0">, </span><span class="s1">y)) </span><span class="s0">and </span><span class="s1">ncu.arctan2(x</span><span class="s0">, </span><span class="s1">y) &gt; </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;arctan(%s, %s) is %s, not +inf&quot; </span><span class="s1">% (x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">ncu.arctan2(x</span><span class="s0">, </span><span class="s1">y)))</span>


<span class="s0">def </span><span class="s1">assert_arctan2_isninf(x</span><span class="s0">, </span><span class="s1">y):</span>
    <span class="s1">assert_((np.isinf(ncu.arctan2(x</span><span class="s0">, </span><span class="s1">y)) </span><span class="s0">and </span><span class="s1">ncu.arctan2(x</span><span class="s0">, </span><span class="s1">y) &lt; </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;arctan(%s, %s) is %s, not -inf&quot; </span><span class="s1">% (x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">ncu.arctan2(x</span><span class="s0">, </span><span class="s1">y)))</span>


<span class="s0">def </span><span class="s1">assert_arctan2_ispzero(x</span><span class="s0">, </span><span class="s1">y):</span>
    <span class="s1">assert_((ncu.arctan2(x</span><span class="s0">, </span><span class="s1">y) == </span><span class="s3">0 </span><span class="s0">and not </span><span class="s1">np.signbit(ncu.arctan2(x</span><span class="s0">, </span><span class="s1">y)))</span><span class="s0">, </span><span class="s2">&quot;arctan(%s, %s) is %s, not +0&quot; </span><span class="s1">% (x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">ncu.arctan2(x</span><span class="s0">, </span><span class="s1">y)))</span>


<span class="s0">def </span><span class="s1">assert_arctan2_isnzero(x</span><span class="s0">, </span><span class="s1">y):</span>
    <span class="s1">assert_((ncu.arctan2(x</span><span class="s0">, </span><span class="s1">y) == </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">np.signbit(ncu.arctan2(x</span><span class="s0">, </span><span class="s1">y)))</span><span class="s0">, </span><span class="s2">&quot;arctan(%s, %s) is %s, not -0&quot; </span><span class="s1">% (x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">ncu.arctan2(x</span><span class="s0">, </span><span class="s1">y)))</span>


<span class="s0">class </span><span class="s1">TestArctan2SpecialValues:</span>
    <span class="s0">def </span><span class="s1">test_one_one(self):</span>
        <span class="s5"># atan2(1, 1) returns pi/4.</span>
        <span class="s1">assert_almost_equal(ncu.arctan2(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0.25 </span><span class="s1">* np.pi)</span>
        <span class="s1">assert_almost_equal(ncu.arctan2(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.25 </span><span class="s1">* np.pi)</span>
        <span class="s1">assert_almost_equal(ncu.arctan2(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0.75 </span><span class="s1">* np.pi)</span>

    <span class="s0">def </span><span class="s1">test_zero_nzero(self):</span>
        <span class="s5"># atan2(+-0, -0) returns +-pi.</span>
        <span class="s1">assert_almost_equal(ncu.arctan2(np.PZERO</span><span class="s0">, </span><span class="s1">np.NZERO)</span><span class="s0">, </span><span class="s1">np.pi)</span>
        <span class="s1">assert_almost_equal(ncu.arctan2(np.NZERO</span><span class="s0">, </span><span class="s1">np.NZERO)</span><span class="s0">, </span><span class="s1">-np.pi)</span>

    <span class="s0">def </span><span class="s1">test_zero_pzero(self):</span>
        <span class="s5"># atan2(+-0, +0) returns +-0.</span>
        <span class="s1">assert_arctan2_ispzero(np.PZERO</span><span class="s0">, </span><span class="s1">np.PZERO)</span>
        <span class="s1">assert_arctan2_isnzero(np.NZERO</span><span class="s0">, </span><span class="s1">np.PZERO)</span>

    <span class="s0">def </span><span class="s1">test_zero_negative(self):</span>
        <span class="s5"># atan2(+-0, x) returns +-pi for x &lt; 0.</span>
        <span class="s1">assert_almost_equal(ncu.arctan2(np.PZERO</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.pi)</span>
        <span class="s1">assert_almost_equal(ncu.arctan2(np.NZERO</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-np.pi)</span>

    <span class="s0">def </span><span class="s1">test_zero_positive(self):</span>
        <span class="s5"># atan2(+-0, x) returns +-0 for x &gt; 0.</span>
        <span class="s1">assert_arctan2_ispzero(np.PZERO</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_arctan2_isnzero(np.NZERO</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_positive_zero(self):</span>
        <span class="s5"># atan2(y, +-0) returns +pi/2 for y &gt; 0.</span>
        <span class="s1">assert_almost_equal(ncu.arctan2(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.PZERO)</span><span class="s0">, </span><span class="s3">0.5 </span><span class="s1">* np.pi)</span>
        <span class="s1">assert_almost_equal(ncu.arctan2(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.NZERO)</span><span class="s0">, </span><span class="s3">0.5 </span><span class="s1">* np.pi)</span>

    <span class="s0">def </span><span class="s1">test_negative_zero(self):</span>
        <span class="s5"># atan2(y, +-0) returns -pi/2 for y &lt; 0.</span>
        <span class="s1">assert_almost_equal(ncu.arctan2(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.PZERO)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.5 </span><span class="s1">* np.pi)</span>
        <span class="s1">assert_almost_equal(ncu.arctan2(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.NZERO)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.5 </span><span class="s1">* np.pi)</span>

    <span class="s0">def </span><span class="s1">test_any_ninf(self):</span>
        <span class="s5"># atan2(+-y, -infinity) returns +-pi for finite y &gt; 0.</span>
        <span class="s1">assert_almost_equal(ncu.arctan2(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.NINF)</span><span class="s0">,  </span><span class="s1">np.pi)</span>
        <span class="s1">assert_almost_equal(ncu.arctan2(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.NINF)</span><span class="s0">, </span><span class="s1">-np.pi)</span>

    <span class="s0">def </span><span class="s1">test_any_pinf(self):</span>
        <span class="s5"># atan2(+-y, +infinity) returns +-0 for finite y &gt; 0.</span>
        <span class="s1">assert_arctan2_ispzero(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s1">assert_arctan2_isnzero(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.inf)</span>

    <span class="s0">def </span><span class="s1">test_inf_any(self):</span>
        <span class="s5"># atan2(+-infinity, x) returns +-pi/2 for finite x.</span>
        <span class="s1">assert_almost_equal(ncu.arctan2( np.inf</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,  </span><span class="s3">0.5 </span><span class="s1">* np.pi)</span>
        <span class="s1">assert_almost_equal(ncu.arctan2(-np.inf</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.5 </span><span class="s1">* np.pi)</span>

    <span class="s0">def </span><span class="s1">test_inf_ninf(self):</span>
        <span class="s5"># atan2(+-infinity, -infinity) returns +-3*pi/4.</span>
        <span class="s1">assert_almost_equal(ncu.arctan2( np.inf</span><span class="s0">, </span><span class="s1">-np.inf)</span><span class="s0">,  </span><span class="s3">0.75 </span><span class="s1">* np.pi)</span>
        <span class="s1">assert_almost_equal(ncu.arctan2(-np.inf</span><span class="s0">, </span><span class="s1">-np.inf)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.75 </span><span class="s1">* np.pi)</span>

    <span class="s0">def </span><span class="s1">test_inf_pinf(self):</span>
        <span class="s5"># atan2(+-infinity, +infinity) returns +-pi/4.</span>
        <span class="s1">assert_almost_equal(ncu.arctan2( np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">,  </span><span class="s3">0.25 </span><span class="s1">* np.pi)</span>
        <span class="s1">assert_almost_equal(ncu.arctan2(-np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.25 </span><span class="s1">* np.pi)</span>

    <span class="s0">def </span><span class="s1">test_nan_any(self):</span>
        <span class="s5"># atan2(nan, x) returns nan for any x, including inf</span>
        <span class="s1">assert_arctan2_isnan(np.nan</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s1">assert_arctan2_isnan(np.inf</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">assert_arctan2_isnan(np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>


<span class="s0">class </span><span class="s1">TestLdexp:</span>
    <span class="s0">def </span><span class="s1">_check_ldexp(self</span><span class="s0">, </span><span class="s1">tp):</span>
        <span class="s1">assert_almost_equal(ncu.ldexp(np.array(</span><span class="s3">2.</span><span class="s0">, </span><span class="s1">np.float32)</span><span class="s0">,</span>
                                      <span class="s1">np.array(</span><span class="s3">3</span><span class="s0">, </span><span class="s1">tp))</span><span class="s0">, </span><span class="s3">16.</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(ncu.ldexp(np.array(</span><span class="s3">2.</span><span class="s0">, </span><span class="s1">np.float64)</span><span class="s0">,</span>
                                      <span class="s1">np.array(</span><span class="s3">3</span><span class="s0">, </span><span class="s1">tp))</span><span class="s0">, </span><span class="s3">16.</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(ncu.ldexp(np.array(</span><span class="s3">2.</span><span class="s0">, </span><span class="s1">np.longdouble)</span><span class="s0">,</span>
                                      <span class="s1">np.array(</span><span class="s3">3</span><span class="s0">, </span><span class="s1">tp))</span><span class="s0">, </span><span class="s3">16.</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_ldexp(self):</span>
        <span class="s5"># The default Python int type should work</span>
        <span class="s1">assert_almost_equal(ncu.ldexp(</span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">,  </span><span class="s3">16.</span><span class="s1">)</span>
        <span class="s5"># The following int types should all be accepted</span>
        <span class="s1">self._check_ldexp(np.int8)</span>
        <span class="s1">self._check_ldexp(np.int16)</span>
        <span class="s1">self._check_ldexp(np.int32)</span>
        <span class="s1">self._check_ldexp(</span><span class="s2">'i'</span><span class="s1">)</span>
        <span class="s1">self._check_ldexp(</span><span class="s2">'l'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_ldexp_overflow(self):</span>
        <span class="s5"># silence warning emitted on overflow</span>
        <span class="s0">with </span><span class="s1">np.errstate(over=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">imax = np.iinfo(np.dtype(</span><span class="s2">'l'</span><span class="s1">)).max</span>
            <span class="s1">imin = np.iinfo(np.dtype(</span><span class="s2">'l'</span><span class="s1">)).min</span>
            <span class="s1">assert_equal(ncu.ldexp(</span><span class="s3">2.</span><span class="s0">, </span><span class="s1">imax)</span><span class="s0">, </span><span class="s1">np.inf)</span>
            <span class="s1">assert_equal(ncu.ldexp(</span><span class="s3">2.</span><span class="s0">, </span><span class="s1">imin)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestMaximum(_FilterInvalids):</span>
    <span class="s0">def </span><span class="s1">test_reduce(self):</span>
        <span class="s1">dflt = np.typecodes[</span><span class="s2">'AllFloat'</span><span class="s1">]</span>
        <span class="s1">dint = np.typecodes[</span><span class="s2">'AllInteger'</span><span class="s1">]</span>
        <span class="s1">seq1 = np.arange(</span><span class="s3">11</span><span class="s1">)</span>
        <span class="s1">seq2 = seq1[::-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">func = np.maximum.reduce</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dint:</span>
            <span class="s1">tmp1 = seq1.astype(dt)</span>
            <span class="s1">tmp2 = seq2.astype(dt)</span>
            <span class="s1">assert_equal(func(tmp1)</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
            <span class="s1">assert_equal(func(tmp2)</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dflt:</span>
            <span class="s1">tmp1 = seq1.astype(dt)</span>
            <span class="s1">tmp2 = seq2.astype(dt)</span>
            <span class="s1">assert_equal(func(tmp1)</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
            <span class="s1">assert_equal(func(tmp2)</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
            <span class="s1">tmp1[::</span><span class="s3">2</span><span class="s1">] = np.nan</span>
            <span class="s1">tmp2[::</span><span class="s3">2</span><span class="s1">] = np.nan</span>
            <span class="s1">assert_equal(func(tmp1)</span><span class="s0">, </span><span class="s1">np.nan)</span>
            <span class="s1">assert_equal(func(tmp2)</span><span class="s0">, </span><span class="s1">np.nan)</span>

    <span class="s0">def </span><span class="s1">test_reduce_complex(self):</span>
        <span class="s1">assert_equal(np.maximum.reduce([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2j</span><span class="s1">])</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.maximum.reduce([</span><span class="s3">1</span><span class="s1">+</span><span class="s3">3j</span><span class="s0">, </span><span class="s3">2j</span><span class="s1">])</span><span class="s0">, </span><span class="s3">1</span><span class="s1">+</span><span class="s3">3j</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_float_nans(self):</span>
        <span class="s1">nan = np.nan</span>
        <span class="s1">arg1 = np.array([</span><span class="s3">0</span><span class="s0">,   </span><span class="s1">nan</span><span class="s0">, </span><span class="s1">nan])</span>
        <span class="s1">arg2 = np.array([nan</span><span class="s0">, </span><span class="s3">0</span><span class="s0">,   </span><span class="s1">nan])</span>
        <span class="s1">out = np.array([nan</span><span class="s0">, </span><span class="s1">nan</span><span class="s0">, </span><span class="s1">nan])</span>
        <span class="s1">assert_equal(np.maximum(arg1</span><span class="s0">, </span><span class="s1">arg2)</span><span class="s0">, </span><span class="s1">out)</span>

    <span class="s0">def </span><span class="s1">test_object_nans(self):</span>
        <span class="s5"># Multiple checks to give this a chance to</span>
        <span class="s5"># fail if cmp is used instead of rich compare.</span>
        <span class="s5"># Failure cannot be guaranteed.</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">x = np.array(float(</span><span class="s2">'nan'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">object)</span>
            <span class="s1">y = </span><span class="s3">1.0</span>
            <span class="s1">z = np.array(float(</span><span class="s2">'nan'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">object)</span>
            <span class="s1">assert_(np.maximum(x</span><span class="s0">, </span><span class="s1">y) == </span><span class="s3">1.0</span><span class="s1">)</span>
            <span class="s1">assert_(np.maximum(z</span><span class="s0">, </span><span class="s1">y) == </span><span class="s3">1.0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_complex_nans(self):</span>
        <span class="s1">nan = np.nan</span>
        <span class="s0">for </span><span class="s1">cnan </span><span class="s0">in </span><span class="s1">[complex(nan</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">nan)</span><span class="s0">, </span><span class="s1">complex(nan</span><span class="s0">, </span><span class="s1">nan)]:</span>
            <span class="s1">arg1 = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s1">cnan</span><span class="s0">, </span><span class="s1">cnan]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
            <span class="s1">arg2 = np.array([cnan</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">cnan]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
            <span class="s1">out = np.array([nan</span><span class="s0">, </span><span class="s1">nan</span><span class="s0">, </span><span class="s1">nan]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
            <span class="s1">assert_equal(np.maximum(arg1</span><span class="s0">, </span><span class="s1">arg2)</span><span class="s0">, </span><span class="s1">out)</span>

    <span class="s0">def </span><span class="s1">test_object_array(self):</span>
        <span class="s1">arg1 = np.arange(</span><span class="s3">5</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">arg2 = arg1 + </span><span class="s3">1</span>
        <span class="s1">assert_equal(np.maximum(arg1</span><span class="s0">, </span><span class="s1">arg2)</span><span class="s0">, </span><span class="s1">arg2)</span>

    <span class="s0">def </span><span class="s1">test_strided_array(self):</span>
        <span class="s1">arr1 = np.array([-</span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">10.0</span><span class="s0">,  </span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf])</span>
        <span class="s1">arr2 = np.array([-</span><span class="s3">2.0</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">,    </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">,    </span><span class="s1">-</span><span class="s3">3.0</span><span class="s1">])</span>
        <span class="s1">maxtrue  = np.array([-</span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3.0</span><span class="s1">])</span>
        <span class="s1">out = np.ones(</span><span class="s3">8</span><span class="s1">)</span>
        <span class="s1">out_maxtrue = np.array([-</span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">10.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.maximum(arr1</span><span class="s0">,</span><span class="s1">arr2)</span><span class="s0">, </span><span class="s1">maxtrue)</span>
        <span class="s1">assert_equal(np.maximum(arr1[::</span><span class="s3">2</span><span class="s1">]</span><span class="s0">,</span><span class="s1">arr2[::</span><span class="s3">2</span><span class="s1">])</span><span class="s0">, </span><span class="s1">maxtrue[::</span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.maximum(arr1[:</span><span class="s3">4</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">arr2[::</span><span class="s3">2</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.array([-</span><span class="s3">2.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">10.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]))</span>
        <span class="s1">assert_equal(np.maximum(arr1[::</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">arr2[:</span><span class="s3">3</span><span class="s1">:])</span><span class="s0">, </span><span class="s1">np.array([-</span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">np.nan]))</span>
        <span class="s1">assert_equal(np.maximum(arr1[:</span><span class="s3">6</span><span class="s1">:</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">arr2[::</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">out=out[::</span><span class="s3">3</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.array([-</span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">10.</span><span class="s0">, </span><span class="s1">np.nan]))</span>
        <span class="s1">assert_equal(out</span><span class="s0">, </span><span class="s1">out_maxtrue)</span>


<span class="s0">class </span><span class="s1">TestMinimum(_FilterInvalids):</span>
    <span class="s0">def </span><span class="s1">test_reduce(self):</span>
        <span class="s1">dflt = np.typecodes[</span><span class="s2">'AllFloat'</span><span class="s1">]</span>
        <span class="s1">dint = np.typecodes[</span><span class="s2">'AllInteger'</span><span class="s1">]</span>
        <span class="s1">seq1 = np.arange(</span><span class="s3">11</span><span class="s1">)</span>
        <span class="s1">seq2 = seq1[::-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">func = np.minimum.reduce</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dint:</span>
            <span class="s1">tmp1 = seq1.astype(dt)</span>
            <span class="s1">tmp2 = seq2.astype(dt)</span>
            <span class="s1">assert_equal(func(tmp1)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">assert_equal(func(tmp2)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dflt:</span>
            <span class="s1">tmp1 = seq1.astype(dt)</span>
            <span class="s1">tmp2 = seq2.astype(dt)</span>
            <span class="s1">assert_equal(func(tmp1)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">assert_equal(func(tmp2)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">tmp1[::</span><span class="s3">2</span><span class="s1">] = np.nan</span>
            <span class="s1">tmp2[::</span><span class="s3">2</span><span class="s1">] = np.nan</span>
            <span class="s1">assert_equal(func(tmp1)</span><span class="s0">, </span><span class="s1">np.nan)</span>
            <span class="s1">assert_equal(func(tmp2)</span><span class="s0">, </span><span class="s1">np.nan)</span>

    <span class="s0">def </span><span class="s1">test_reduce_complex(self):</span>
        <span class="s1">assert_equal(np.minimum.reduce([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2j</span><span class="s1">])</span><span class="s0">, </span><span class="s3">2j</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.minimum.reduce([</span><span class="s3">1</span><span class="s1">+</span><span class="s3">3j</span><span class="s0">, </span><span class="s3">2j</span><span class="s1">])</span><span class="s0">, </span><span class="s3">2j</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_float_nans(self):</span>
        <span class="s1">nan = np.nan</span>
        <span class="s1">arg1 = np.array([</span><span class="s3">0</span><span class="s0">,   </span><span class="s1">nan</span><span class="s0">, </span><span class="s1">nan])</span>
        <span class="s1">arg2 = np.array([nan</span><span class="s0">, </span><span class="s3">0</span><span class="s0">,   </span><span class="s1">nan])</span>
        <span class="s1">out = np.array([nan</span><span class="s0">, </span><span class="s1">nan</span><span class="s0">, </span><span class="s1">nan])</span>
        <span class="s1">assert_equal(np.minimum(arg1</span><span class="s0">, </span><span class="s1">arg2)</span><span class="s0">, </span><span class="s1">out)</span>

    <span class="s0">def </span><span class="s1">test_object_nans(self):</span>
        <span class="s5"># Multiple checks to give this a chance to</span>
        <span class="s5"># fail if cmp is used instead of rich compare.</span>
        <span class="s5"># Failure cannot be guaranteed.</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">x = np.array(float(</span><span class="s2">'nan'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">object)</span>
            <span class="s1">y = </span><span class="s3">1.0</span>
            <span class="s1">z = np.array(float(</span><span class="s2">'nan'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">object)</span>
            <span class="s1">assert_(np.minimum(x</span><span class="s0">, </span><span class="s1">y) == </span><span class="s3">1.0</span><span class="s1">)</span>
            <span class="s1">assert_(np.minimum(z</span><span class="s0">, </span><span class="s1">y) == </span><span class="s3">1.0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_complex_nans(self):</span>
        <span class="s1">nan = np.nan</span>
        <span class="s0">for </span><span class="s1">cnan </span><span class="s0">in </span><span class="s1">[complex(nan</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">nan)</span><span class="s0">, </span><span class="s1">complex(nan</span><span class="s0">, </span><span class="s1">nan)]:</span>
            <span class="s1">arg1 = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s1">cnan</span><span class="s0">, </span><span class="s1">cnan]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
            <span class="s1">arg2 = np.array([cnan</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">cnan]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
            <span class="s1">out = np.array([nan</span><span class="s0">, </span><span class="s1">nan</span><span class="s0">, </span><span class="s1">nan]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
            <span class="s1">assert_equal(np.minimum(arg1</span><span class="s0">, </span><span class="s1">arg2)</span><span class="s0">, </span><span class="s1">out)</span>

    <span class="s0">def </span><span class="s1">test_object_array(self):</span>
        <span class="s1">arg1 = np.arange(</span><span class="s3">5</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">arg2 = arg1 + </span><span class="s3">1</span>
        <span class="s1">assert_equal(np.minimum(arg1</span><span class="s0">, </span><span class="s1">arg2)</span><span class="s0">, </span><span class="s1">arg1)</span>

    <span class="s0">def </span><span class="s1">test_strided_array(self):</span>
        <span class="s1">arr1 = np.array([-</span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">10.0</span><span class="s0">,  </span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">-np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf])</span>
        <span class="s1">arr2 = np.array([-</span><span class="s3">2.0</span><span class="s0">,</span><span class="s1">-</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">,    </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">,    </span><span class="s1">-</span><span class="s3">3.0</span><span class="s1">])</span>
        <span class="s1">mintrue  = np.array([-</span><span class="s3">4.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">-np.inf])</span>
        <span class="s1">out = np.ones(</span><span class="s3">8</span><span class="s1">)</span>
        <span class="s1">out_mintrue = np.array([-</span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.minimum(arr1</span><span class="s0">,</span><span class="s1">arr2)</span><span class="s0">, </span><span class="s1">mintrue)</span>
        <span class="s1">assert_equal(np.minimum(arr1[::</span><span class="s3">2</span><span class="s1">]</span><span class="s0">,</span><span class="s1">arr2[::</span><span class="s3">2</span><span class="s1">])</span><span class="s0">, </span><span class="s1">mintrue[::</span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.minimum(arr1[:</span><span class="s3">4</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">arr2[::</span><span class="s3">2</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.array([-</span><span class="s3">4.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">]))</span>
        <span class="s1">assert_equal(np.minimum(arr1[::</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">arr2[:</span><span class="s3">3</span><span class="s1">:])</span><span class="s0">, </span><span class="s1">np.array([-</span><span class="s3">4.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">np.nan]))</span>
        <span class="s1">assert_equal(np.minimum(arr1[:</span><span class="s3">6</span><span class="s1">:</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">arr2[::</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">out=out[::</span><span class="s3">3</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.array([-</span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">np.nan]))</span>
        <span class="s1">assert_equal(out</span><span class="s0">, </span><span class="s1">out_mintrue)</span>

<span class="s0">class </span><span class="s1">TestFmax(_FilterInvalids):</span>
    <span class="s0">def </span><span class="s1">test_reduce(self):</span>
        <span class="s1">dflt = np.typecodes[</span><span class="s2">'AllFloat'</span><span class="s1">]</span>
        <span class="s1">dint = np.typecodes[</span><span class="s2">'AllInteger'</span><span class="s1">]</span>
        <span class="s1">seq1 = np.arange(</span><span class="s3">11</span><span class="s1">)</span>
        <span class="s1">seq2 = seq1[::-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">func = np.fmax.reduce</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dint:</span>
            <span class="s1">tmp1 = seq1.astype(dt)</span>
            <span class="s1">tmp2 = seq2.astype(dt)</span>
            <span class="s1">assert_equal(func(tmp1)</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
            <span class="s1">assert_equal(func(tmp2)</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dflt:</span>
            <span class="s1">tmp1 = seq1.astype(dt)</span>
            <span class="s1">tmp2 = seq2.astype(dt)</span>
            <span class="s1">assert_equal(func(tmp1)</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
            <span class="s1">assert_equal(func(tmp2)</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
            <span class="s1">tmp1[::</span><span class="s3">2</span><span class="s1">] = np.nan</span>
            <span class="s1">tmp2[::</span><span class="s3">2</span><span class="s1">] = np.nan</span>
            <span class="s1">assert_equal(func(tmp1)</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span>
            <span class="s1">assert_equal(func(tmp2)</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_reduce_complex(self):</span>
        <span class="s1">assert_equal(np.fmax.reduce([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2j</span><span class="s1">])</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.fmax.reduce([</span><span class="s3">1</span><span class="s1">+</span><span class="s3">3j</span><span class="s0">, </span><span class="s3">2j</span><span class="s1">])</span><span class="s0">, </span><span class="s3">1</span><span class="s1">+</span><span class="s3">3j</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_float_nans(self):</span>
        <span class="s1">nan = np.nan</span>
        <span class="s1">arg1 = np.array([</span><span class="s3">0</span><span class="s0">,   </span><span class="s1">nan</span><span class="s0">, </span><span class="s1">nan])</span>
        <span class="s1">arg2 = np.array([nan</span><span class="s0">, </span><span class="s3">0</span><span class="s0">,   </span><span class="s1">nan])</span>
        <span class="s1">out = np.array([</span><span class="s3">0</span><span class="s0">,   </span><span class="s3">0</span><span class="s0">,   </span><span class="s1">nan])</span>
        <span class="s1">assert_equal(np.fmax(arg1</span><span class="s0">, </span><span class="s1">arg2)</span><span class="s0">, </span><span class="s1">out)</span>

    <span class="s0">def </span><span class="s1">test_complex_nans(self):</span>
        <span class="s1">nan = np.nan</span>
        <span class="s0">for </span><span class="s1">cnan </span><span class="s0">in </span><span class="s1">[complex(nan</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">nan)</span><span class="s0">, </span><span class="s1">complex(nan</span><span class="s0">, </span><span class="s1">nan)]:</span>
            <span class="s1">arg1 = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s1">cnan</span><span class="s0">, </span><span class="s1">cnan]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
            <span class="s1">arg2 = np.array([cnan</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">cnan]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
            <span class="s1">out = np.array([</span><span class="s3">0</span><span class="s0">,    </span><span class="s3">0</span><span class="s0">, </span><span class="s1">nan]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
            <span class="s1">assert_equal(np.fmax(arg1</span><span class="s0">, </span><span class="s1">arg2)</span><span class="s0">, </span><span class="s1">out)</span>


<span class="s0">class </span><span class="s1">TestFmin(_FilterInvalids):</span>
    <span class="s0">def </span><span class="s1">test_reduce(self):</span>
        <span class="s1">dflt = np.typecodes[</span><span class="s2">'AllFloat'</span><span class="s1">]</span>
        <span class="s1">dint = np.typecodes[</span><span class="s2">'AllInteger'</span><span class="s1">]</span>
        <span class="s1">seq1 = np.arange(</span><span class="s3">11</span><span class="s1">)</span>
        <span class="s1">seq2 = seq1[::-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">func = np.fmin.reduce</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dint:</span>
            <span class="s1">tmp1 = seq1.astype(dt)</span>
            <span class="s1">tmp2 = seq2.astype(dt)</span>
            <span class="s1">assert_equal(func(tmp1)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">assert_equal(func(tmp2)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">dflt:</span>
            <span class="s1">tmp1 = seq1.astype(dt)</span>
            <span class="s1">tmp2 = seq2.astype(dt)</span>
            <span class="s1">assert_equal(func(tmp1)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">assert_equal(func(tmp2)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">tmp1[::</span><span class="s3">2</span><span class="s1">] = np.nan</span>
            <span class="s1">tmp2[::</span><span class="s3">2</span><span class="s1">] = np.nan</span>
            <span class="s1">assert_equal(func(tmp1)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">assert_equal(func(tmp2)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_reduce_complex(self):</span>
        <span class="s1">assert_equal(np.fmin.reduce([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2j</span><span class="s1">])</span><span class="s0">, </span><span class="s3">2j</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.fmin.reduce([</span><span class="s3">1</span><span class="s1">+</span><span class="s3">3j</span><span class="s0">, </span><span class="s3">2j</span><span class="s1">])</span><span class="s0">, </span><span class="s3">2j</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_float_nans(self):</span>
        <span class="s1">nan = np.nan</span>
        <span class="s1">arg1 = np.array([</span><span class="s3">0</span><span class="s0">,   </span><span class="s1">nan</span><span class="s0">, </span><span class="s1">nan])</span>
        <span class="s1">arg2 = np.array([nan</span><span class="s0">, </span><span class="s3">0</span><span class="s0">,   </span><span class="s1">nan])</span>
        <span class="s1">out = np.array([</span><span class="s3">0</span><span class="s0">,   </span><span class="s3">0</span><span class="s0">,   </span><span class="s1">nan])</span>
        <span class="s1">assert_equal(np.fmin(arg1</span><span class="s0">, </span><span class="s1">arg2)</span><span class="s0">, </span><span class="s1">out)</span>

    <span class="s0">def </span><span class="s1">test_complex_nans(self):</span>
        <span class="s1">nan = np.nan</span>
        <span class="s0">for </span><span class="s1">cnan </span><span class="s0">in </span><span class="s1">[complex(nan</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">nan)</span><span class="s0">, </span><span class="s1">complex(nan</span><span class="s0">, </span><span class="s1">nan)]:</span>
            <span class="s1">arg1 = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s1">cnan</span><span class="s0">, </span><span class="s1">cnan]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
            <span class="s1">arg2 = np.array([cnan</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">cnan]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
            <span class="s1">out = np.array([</span><span class="s3">0</span><span class="s0">,    </span><span class="s3">0</span><span class="s0">, </span><span class="s1">nan]</span><span class="s0">, </span><span class="s1">dtype=complex)</span>
            <span class="s1">assert_equal(np.fmin(arg1</span><span class="s0">, </span><span class="s1">arg2)</span><span class="s0">, </span><span class="s1">out)</span>


<span class="s0">class </span><span class="s1">TestBool:</span>
    <span class="s0">def </span><span class="s1">test_exceptions(self):</span>
        <span class="s1">a = np.ones(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=np.bool_)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.negative</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.positive</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.subtract</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a)</span>

    <span class="s0">def </span><span class="s1">test_truth_table_logical(self):</span>
        <span class="s5"># 2, 3 and 4 serves as true values</span>
        <span class="s1">input1 = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span>
        <span class="s1">input2 = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span>

        <span class="s1">typecodes = (np.typecodes[</span><span class="s2">'AllFloat'</span><span class="s1">]</span>
                     <span class="s1">+ np.typecodes[</span><span class="s2">'AllInteger'</span><span class="s1">]</span>
                     <span class="s1">+ </span><span class="s2">'?'</span><span class="s1">)     </span><span class="s5"># boolean</span>
        <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">map(np.dtype</span><span class="s0">, </span><span class="s1">typecodes):</span>
            <span class="s1">arg1 = np.asarray(input1</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">arg2 = np.asarray(input2</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

            <span class="s5"># OR</span>
            <span class="s1">out = [</span><span class="s0">False, True, True, True</span><span class="s1">]</span>
            <span class="s0">for </span><span class="s1">func </span><span class="s0">in </span><span class="s1">(np.logical_or</span><span class="s0">, </span><span class="s1">np.maximum):</span>
                <span class="s1">assert_equal(func(arg1</span><span class="s0">, </span><span class="s1">arg2).astype(bool)</span><span class="s0">, </span><span class="s1">out)</span>
            <span class="s5"># AND</span>
            <span class="s1">out = [</span><span class="s0">False, False, False, True</span><span class="s1">]</span>
            <span class="s0">for </span><span class="s1">func </span><span class="s0">in </span><span class="s1">(np.logical_and</span><span class="s0">, </span><span class="s1">np.minimum):</span>
                <span class="s1">assert_equal(func(arg1</span><span class="s0">, </span><span class="s1">arg2).astype(bool)</span><span class="s0">, </span><span class="s1">out)</span>
            <span class="s5"># XOR</span>
            <span class="s1">out = [</span><span class="s0">False, True, True, False</span><span class="s1">]</span>
            <span class="s0">for </span><span class="s1">func </span><span class="s0">in </span><span class="s1">(np.logical_xor</span><span class="s0">, </span><span class="s1">np.not_equal):</span>
                <span class="s1">assert_equal(func(arg1</span><span class="s0">, </span><span class="s1">arg2).astype(bool)</span><span class="s0">, </span><span class="s1">out)</span>

    <span class="s0">def </span><span class="s1">test_truth_table_bitwise(self):</span>
        <span class="s1">arg1 = [</span><span class="s0">False, False, True, True</span><span class="s1">]</span>
        <span class="s1">arg2 = [</span><span class="s0">False, True, False, True</span><span class="s1">]</span>

        <span class="s1">out = [</span><span class="s0">False, True, True, True</span><span class="s1">]</span>
        <span class="s1">assert_equal(np.bitwise_or(arg1</span><span class="s0">, </span><span class="s1">arg2)</span><span class="s0">, </span><span class="s1">out)</span>

        <span class="s1">out = [</span><span class="s0">False, False, False, True</span><span class="s1">]</span>
        <span class="s1">assert_equal(np.bitwise_and(arg1</span><span class="s0">, </span><span class="s1">arg2)</span><span class="s0">, </span><span class="s1">out)</span>

        <span class="s1">out = [</span><span class="s0">False, True, True, False</span><span class="s1">]</span>
        <span class="s1">assert_equal(np.bitwise_xor(arg1</span><span class="s0">, </span><span class="s1">arg2)</span><span class="s0">, </span><span class="s1">out)</span>

    <span class="s0">def </span><span class="s1">test_reduce(self):</span>
        <span class="s1">none = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">bool)</span>
        <span class="s1">some = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">bool)</span>
        <span class="s1">every = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">bool)</span>
        <span class="s1">empty = np.array([]</span><span class="s0">, </span><span class="s1">bool)</span>

        <span class="s1">arrs = [none</span><span class="s0">, </span><span class="s1">some</span><span class="s0">, </span><span class="s1">every</span><span class="s0">, </span><span class="s1">empty]</span>

        <span class="s0">for </span><span class="s1">arr </span><span class="s0">in </span><span class="s1">arrs:</span>
            <span class="s1">assert_equal(np.logical_and.reduce(arr)</span><span class="s0">, </span><span class="s1">all(arr))</span>

        <span class="s0">for </span><span class="s1">arr </span><span class="s0">in </span><span class="s1">arrs:</span>
            <span class="s1">assert_equal(np.logical_or.reduce(arr)</span><span class="s0">, </span><span class="s1">any(arr))</span>

        <span class="s0">for </span><span class="s1">arr </span><span class="s0">in </span><span class="s1">arrs:</span>
            <span class="s1">assert_equal(np.logical_xor.reduce(arr)</span><span class="s0">, </span><span class="s1">arr.sum() % </span><span class="s3">2 </span><span class="s1">== </span><span class="s3">1</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestBitwiseUFuncs:</span>

    <span class="s1">bitwise_types = [np.dtype(c) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s2">'?' </span><span class="s1">+ </span><span class="s2">'bBhHiIlLqQ' </span><span class="s1">+ </span><span class="s2">'O'</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_values(self):</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">self.bitwise_types:</span>
            <span class="s1">zeros = np.array([</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">ones = np.array([-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">msg = </span><span class="s2">&quot;dt = '%s'&quot; </span><span class="s1">% dt.char</span>

            <span class="s1">assert_equal(np.bitwise_not(zeros)</span><span class="s0">, </span><span class="s1">ones</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
            <span class="s1">assert_equal(np.bitwise_not(ones)</span><span class="s0">, </span><span class="s1">zeros</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

            <span class="s1">assert_equal(np.bitwise_or(zeros</span><span class="s0">, </span><span class="s1">zeros)</span><span class="s0">, </span><span class="s1">zeros</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
            <span class="s1">assert_equal(np.bitwise_or(zeros</span><span class="s0">, </span><span class="s1">ones)</span><span class="s0">, </span><span class="s1">ones</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
            <span class="s1">assert_equal(np.bitwise_or(ones</span><span class="s0">, </span><span class="s1">zeros)</span><span class="s0">, </span><span class="s1">ones</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
            <span class="s1">assert_equal(np.bitwise_or(ones</span><span class="s0">, </span><span class="s1">ones)</span><span class="s0">, </span><span class="s1">ones</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

            <span class="s1">assert_equal(np.bitwise_xor(zeros</span><span class="s0">, </span><span class="s1">zeros)</span><span class="s0">, </span><span class="s1">zeros</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
            <span class="s1">assert_equal(np.bitwise_xor(zeros</span><span class="s0">, </span><span class="s1">ones)</span><span class="s0">, </span><span class="s1">ones</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
            <span class="s1">assert_equal(np.bitwise_xor(ones</span><span class="s0">, </span><span class="s1">zeros)</span><span class="s0">, </span><span class="s1">ones</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
            <span class="s1">assert_equal(np.bitwise_xor(ones</span><span class="s0">, </span><span class="s1">ones)</span><span class="s0">, </span><span class="s1">zeros</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

            <span class="s1">assert_equal(np.bitwise_and(zeros</span><span class="s0">, </span><span class="s1">zeros)</span><span class="s0">, </span><span class="s1">zeros</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
            <span class="s1">assert_equal(np.bitwise_and(zeros</span><span class="s0">, </span><span class="s1">ones)</span><span class="s0">, </span><span class="s1">zeros</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
            <span class="s1">assert_equal(np.bitwise_and(ones</span><span class="s0">, </span><span class="s1">zeros)</span><span class="s0">, </span><span class="s1">zeros</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
            <span class="s1">assert_equal(np.bitwise_and(ones</span><span class="s0">, </span><span class="s1">ones)</span><span class="s0">, </span><span class="s1">ones</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

    <span class="s0">def </span><span class="s1">test_types(self):</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">self.bitwise_types:</span>
            <span class="s1">zeros = np.array([</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">ones = np.array([-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">msg = </span><span class="s2">&quot;dt = '%s'&quot; </span><span class="s1">% dt.char</span>

            <span class="s1">assert_(np.bitwise_not(zeros).dtype == dt</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">assert_(np.bitwise_or(zeros</span><span class="s0">, </span><span class="s1">zeros).dtype == dt</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">assert_(np.bitwise_xor(zeros</span><span class="s0">, </span><span class="s1">zeros).dtype == dt</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">assert_(np.bitwise_and(zeros</span><span class="s0">, </span><span class="s1">zeros).dtype == dt</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_identity(self):</span>
        <span class="s1">assert_(np.bitwise_or.identity == </span><span class="s3">0</span><span class="s0">, </span><span class="s2">'bitwise_or'</span><span class="s1">)</span>
        <span class="s1">assert_(np.bitwise_xor.identity == </span><span class="s3">0</span><span class="s0">, </span><span class="s2">'bitwise_xor'</span><span class="s1">)</span>
        <span class="s1">assert_(np.bitwise_and.identity == -</span><span class="s3">1</span><span class="s0">, </span><span class="s2">'bitwise_and'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_reduction(self):</span>
        <span class="s1">binary_funcs = (np.bitwise_or</span><span class="s0">, </span><span class="s1">np.bitwise_xor</span><span class="s0">, </span><span class="s1">np.bitwise_and)</span>

        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">self.bitwise_types:</span>
            <span class="s1">zeros = np.array([</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">ones = np.array([-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">binary_funcs:</span>
                <span class="s1">msg = </span><span class="s2">&quot;dt: '%s', f: '%s'&quot; </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">f)</span>
                <span class="s1">assert_equal(f.reduce(zeros)</span><span class="s0">, </span><span class="s1">zeros</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
                <span class="s1">assert_equal(f.reduce(ones)</span><span class="s0">, </span><span class="s1">ones</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

        <span class="s5"># Test empty reduction, no object dtype</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">self.bitwise_types[:-</span><span class="s3">1</span><span class="s1">]:</span>
            <span class="s5"># No object array types</span>
            <span class="s1">empty = np.array([]</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">binary_funcs:</span>
                <span class="s1">msg = </span><span class="s2">&quot;dt: '%s', f: '%s'&quot; </span><span class="s1">% (dt</span><span class="s0">, </span><span class="s1">f)</span>
                <span class="s1">tgt = np.array(f.identity</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">res = f.reduce(empty)</span>
                <span class="s1">assert_equal(res</span><span class="s0">, </span><span class="s1">tgt</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
                <span class="s1">assert_(res.dtype == tgt.dtype</span><span class="s0">, </span><span class="s1">msg)</span>

        <span class="s5"># Empty object arrays use the identity.  Note that the types may</span>
        <span class="s5"># differ, the actual type used is determined by the assign_identity</span>
        <span class="s5"># function and is not the same as the type returned by the identity</span>
        <span class="s5"># method.</span>
        <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">binary_funcs:</span>
            <span class="s1">msg = </span><span class="s2">&quot;dt: '%s'&quot; </span><span class="s1">% (f</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">empty = np.array([]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
            <span class="s1">tgt = f.identity</span>
            <span class="s1">res = f.reduce(empty)</span>
            <span class="s1">assert_equal(res</span><span class="s0">, </span><span class="s1">tgt</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

        <span class="s5"># Non-empty object arrays do not use the identity</span>
        <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">binary_funcs:</span>
            <span class="s1">msg = </span><span class="s2">&quot;dt: '%s'&quot; </span><span class="s1">% (f</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">btype = np.array([</span><span class="s0">True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
            <span class="s1">assert_(type(f.reduce(btype)) </span><span class="s0">is </span><span class="s1">bool</span><span class="s0">, </span><span class="s1">msg)</span>


<span class="s0">class </span><span class="s1">TestInt:</span>
    <span class="s0">def </span><span class="s1">test_logical_not(self):</span>
        <span class="s1">x = np.ones(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">dtype=np.int16)</span>
        <span class="s1">o = np.ones(</span><span class="s3">10 </span><span class="s1">* </span><span class="s3">2</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">tgt = o.copy()</span>
        <span class="s1">tgt[::</span><span class="s3">2</span><span class="s1">] = </span><span class="s0">False</span>
        <span class="s1">os = o[::</span><span class="s3">2</span><span class="s1">]</span>
        <span class="s1">assert_array_equal(np.logical_not(x</span><span class="s0">, </span><span class="s1">out=os)</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(o</span><span class="s0">, </span><span class="s1">tgt)</span>


<span class="s0">class </span><span class="s1">TestFloatingPoint:</span>
    <span class="s0">def </span><span class="s1">test_floating_point(self):</span>
        <span class="s1">assert_equal(ncu.FLOATING_POINT_SUPPORT</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestDegrees:</span>
    <span class="s0">def </span><span class="s1">test_degrees(self):</span>
        <span class="s1">assert_almost_equal(ncu.degrees(np.pi)</span><span class="s0">, </span><span class="s3">180.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(ncu.degrees(-</span><span class="s3">0.5</span><span class="s1">*np.pi)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">90.0</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestRadians:</span>
    <span class="s0">def </span><span class="s1">test_radians(self):</span>
        <span class="s1">assert_almost_equal(ncu.radians(</span><span class="s3">180.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.pi)</span>
        <span class="s1">assert_almost_equal(ncu.radians(-</span><span class="s3">90.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.5</span><span class="s1">*np.pi)</span>


<span class="s0">class </span><span class="s1">TestHeavside:</span>
    <span class="s0">def </span><span class="s1">test_heaviside(self):</span>
        <span class="s1">x = np.array([[-</span><span class="s3">30.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">0.2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">7.5</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">-np.inf]])</span>
        <span class="s1">expectedhalf = np.array([[</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">]])</span>
        <span class="s1">expected1 = expectedhalf.copy()</span>
        <span class="s1">expected1[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">] = </span><span class="s3">1</span>

        <span class="s1">h = ncu.heaviside(x</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)</span>
        <span class="s1">assert_equal(h</span><span class="s0">, </span><span class="s1">expectedhalf)</span>

        <span class="s1">h = ncu.heaviside(x</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(h</span><span class="s0">, </span><span class="s1">expected1)</span>

        <span class="s1">x = x.astype(np.float32)</span>

        <span class="s1">h = ncu.heaviside(x</span><span class="s0">, </span><span class="s1">np.float32(</span><span class="s3">0.5</span><span class="s1">))</span>
        <span class="s1">assert_equal(h</span><span class="s0">, </span><span class="s1">expectedhalf.astype(np.float32))</span>

        <span class="s1">h = ncu.heaviside(x</span><span class="s0">, </span><span class="s1">np.float32(</span><span class="s3">1.0</span><span class="s1">))</span>
        <span class="s1">assert_equal(h</span><span class="s0">, </span><span class="s1">expected1.astype(np.float32))</span>


<span class="s0">class </span><span class="s1">TestSign:</span>
    <span class="s0">def </span><span class="s1">test_sign(self):</span>
        <span class="s1">a = np.array([np.inf</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3.0</span><span class="s1">])</span>
        <span class="s1">out = np.zeros(a.shape)</span>
        <span class="s1">tgt = np.array([</span><span class="s3">1.</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">])</span>

        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'ignore'</span><span class="s1">):</span>
            <span class="s1">res = ncu.sign(a)</span>
            <span class="s1">assert_equal(res</span><span class="s0">, </span><span class="s1">tgt)</span>
            <span class="s1">res = ncu.sign(a</span><span class="s0">, </span><span class="s1">out)</span>
            <span class="s1">assert_equal(res</span><span class="s0">, </span><span class="s1">tgt)</span>
            <span class="s1">assert_equal(out</span><span class="s0">, </span><span class="s1">tgt)</span>

    <span class="s0">def </span><span class="s1">test_sign_dtype_object(self):</span>
        <span class="s5"># In reference to github issue #6229</span>

        <span class="s1">foo = np.array([-</span><span class="s3">.1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">.1</span><span class="s1">])</span>
        <span class="s1">a = np.sign(foo.astype(object))</span>
        <span class="s1">b = np.sign(foo)</span>

        <span class="s1">assert_array_equal(a</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s0">def </span><span class="s1">test_sign_dtype_nan_object(self):</span>
        <span class="s5"># In reference to github issue #6229</span>
        <span class="s0">def </span><span class="s1">test_nan():</span>
            <span class="s1">foo = np.array([np.nan])</span>
            <span class="s5"># FIXME: a not used</span>
            <span class="s1">a = np.sign(foo.astype(object))</span>

        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">test_nan)</span>

<span class="s0">class </span><span class="s1">TestMinMax:</span>
    <span class="s0">def </span><span class="s1">test_minmax_blocked(self):</span>
        <span class="s5"># simd tests on max/min, test all alignments, slow but important</span>
        <span class="s5"># for 2 * vz + 2 * (vs - 1) + 1 (unrolled once)</span>
        <span class="s0">for </span><span class="s1">dt</span><span class="s0">, </span><span class="s1">sz </span><span class="s0">in </span><span class="s1">[(np.float32</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(np.float64</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)]:</span>
            <span class="s0">for </span><span class="s1">out</span><span class="s0">, </span><span class="s1">inp</span><span class="s0">, </span><span class="s1">msg </span><span class="s0">in </span><span class="s1">_gen_alignment_data(dtype=dt</span><span class="s0">, </span><span class="s1">type=</span><span class="s2">'unary'</span><span class="s0">,</span>
                                                     <span class="s1">max_size=sz):</span>
                <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(inp.size):</span>
                    <span class="s1">inp[:] = np.arange(inp.size</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                    <span class="s1">inp[i] = np.nan</span>
                    <span class="s1">emsg = </span><span class="s0">lambda</span><span class="s1">: </span><span class="s2">'%r</span><span class="s0">\n</span><span class="s2">%s' </span><span class="s1">% (inp</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
                        <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">,</span>
                                   <span class="s2">&quot;invalid value encountered in reduce&quot;</span><span class="s1">)</span>
                        <span class="s1">assert_(np.isnan(inp.max())</span><span class="s0">, </span><span class="s1">msg=emsg)</span>
                        <span class="s1">assert_(np.isnan(inp.min())</span><span class="s0">, </span><span class="s1">msg=emsg)</span>

                    <span class="s1">inp[i] = </span><span class="s3">1e10</span>
                    <span class="s1">assert_equal(inp.max()</span><span class="s0">, </span><span class="s3">1e10</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
                    <span class="s1">inp[i] = -</span><span class="s3">1e10</span>
                    <span class="s1">assert_equal(inp.min()</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1e10</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

    <span class="s0">def </span><span class="s1">test_lower_align(self):</span>
        <span class="s5"># check data that is not aligned to element size</span>
        <span class="s5"># i.e doubles are aligned to 4 bytes on i386</span>
        <span class="s1">d = np.zeros(</span><span class="s3">23 </span><span class="s1">* </span><span class="s3">8</span><span class="s0">, </span><span class="s1">dtype=np.int8)[</span><span class="s3">4</span><span class="s1">:-</span><span class="s3">4</span><span class="s1">].view(np.float64)</span>
        <span class="s1">assert_equal(d.max()</span><span class="s0">, </span><span class="s1">d[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(d.min()</span><span class="s0">, </span><span class="s1">d[</span><span class="s3">0</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_reduce_reorder(self):</span>
        <span class="s5"># gh 10370, 11029 Some compilers reorder the call to npy_getfloatstatus</span>
        <span class="s5"># and put it before the call to an intrisic function that causes</span>
        <span class="s5"># invalid status to be set. Also make sure warnings are not emitted</span>
        <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">32</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">(np.float32</span><span class="s0">, </span><span class="s1">np.float16</span><span class="s0">, </span><span class="s1">np.complex64):</span>
                <span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">np.diagflat(np.array([np.nan] * n</span><span class="s0">, </span><span class="s1">dtype=dt)):</span>
                    <span class="s1">assert_equal(np.min(r)</span><span class="s0">, </span><span class="s1">np.nan)</span>

    <span class="s0">def </span><span class="s1">test_minimize_no_warns(self):</span>
        <span class="s1">a = np.minimum(np.nan</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">np.nan)</span>


<span class="s0">class </span><span class="s1">TestAbsoluteNegative:</span>
    <span class="s0">def </span><span class="s1">test_abs_neg_blocked(self):</span>
        <span class="s5"># simd tests on abs, test all alignments for vz + 2 * (vs - 1) + 1</span>
        <span class="s0">for </span><span class="s1">dt</span><span class="s0">, </span><span class="s1">sz </span><span class="s0">in </span><span class="s1">[(np.float32</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(np.float64</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)]:</span>
            <span class="s0">for </span><span class="s1">out</span><span class="s0">, </span><span class="s1">inp</span><span class="s0">, </span><span class="s1">msg </span><span class="s0">in </span><span class="s1">_gen_alignment_data(dtype=dt</span><span class="s0">, </span><span class="s1">type=</span><span class="s2">'unary'</span><span class="s0">,</span>
                                                     <span class="s1">max_size=sz):</span>
                <span class="s1">tgt = [ncu.absolute(i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">inp]</span>
                <span class="s1">np.absolute(inp</span><span class="s0">, </span><span class="s1">out=out)</span>
                <span class="s1">assert_equal(out</span><span class="s0">, </span><span class="s1">tgt</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
                <span class="s1">assert_((out &gt;= </span><span class="s3">0</span><span class="s1">).all())</span>

                <span class="s1">tgt = [-</span><span class="s3">1</span><span class="s1">*(i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">inp]</span>
                <span class="s1">np.negative(inp</span><span class="s0">, </span><span class="s1">out=out)</span>
                <span class="s1">assert_equal(out</span><span class="s0">, </span><span class="s1">tgt</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

                <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">np.inf]:</span>
                    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(inp.size):</span>
                        <span class="s1">d = np.arange(inp.size</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                        <span class="s1">inp[:] = -d</span>
                        <span class="s1">inp[i] = v</span>
                        <span class="s1">d[i] = -v </span><span class="s0">if </span><span class="s1">v == -np.inf </span><span class="s0">else </span><span class="s1">v</span>
                        <span class="s1">assert_array_equal(np.abs(inp)</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
                        <span class="s1">np.abs(inp</span><span class="s0">, </span><span class="s1">out=out)</span>
                        <span class="s1">assert_array_equal(out</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

                        <span class="s1">assert_array_equal(-inp</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">*inp</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
                        <span class="s1">d = -</span><span class="s3">1 </span><span class="s1">* inp</span>
                        <span class="s1">np.negative(inp</span><span class="s0">, </span><span class="s1">out=out)</span>
                        <span class="s1">assert_array_equal(out</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

    <span class="s0">def </span><span class="s1">test_lower_align(self):</span>
        <span class="s5"># check data that is not aligned to element size</span>
        <span class="s5"># i.e doubles are aligned to 4 bytes on i386</span>
        <span class="s1">d = np.zeros(</span><span class="s3">23 </span><span class="s1">* </span><span class="s3">8</span><span class="s0">, </span><span class="s1">dtype=np.int8)[</span><span class="s3">4</span><span class="s1">:-</span><span class="s3">4</span><span class="s1">].view(np.float64)</span>
        <span class="s1">assert_equal(np.abs(d)</span><span class="s0">, </span><span class="s1">d)</span>
        <span class="s1">assert_equal(np.negative(d)</span><span class="s0">, </span><span class="s1">-d)</span>
        <span class="s1">np.negative(d</span><span class="s0">, </span><span class="s1">out=d)</span>
        <span class="s1">np.negative(np.ones_like(d)</span><span class="s0">, </span><span class="s1">out=d)</span>
        <span class="s1">np.abs(d</span><span class="s0">, </span><span class="s1">out=d)</span>
        <span class="s1">np.abs(np.ones_like(d)</span><span class="s0">, </span><span class="s1">out=d)</span>


<span class="s0">class </span><span class="s1">TestPositive:</span>
    <span class="s0">def </span><span class="s1">test_valid(self):</span>
        <span class="s1">valid_dtypes = [int</span><span class="s0">, </span><span class="s1">float</span><span class="s0">, </span><span class="s1">complex</span><span class="s0">, </span><span class="s1">object]</span>
        <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">valid_dtypes:</span>
            <span class="s1">x = np.arange(</span><span class="s3">5</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">result = np.positive(x)</span>
            <span class="s1">assert_equal(x</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">err_msg=str(dtype))</span>

    <span class="s0">def </span><span class="s1">test_invalid(self):</span>
        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">np.positive(</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">np.positive(np.datetime64(</span><span class="s2">'2000-01-01'</span><span class="s1">))</span>
        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">np.positive(np.array([</span><span class="s2">'foo'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=str))</span>
        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">np.positive(np.array([</span><span class="s2">'bar'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object))</span>


<span class="s0">class </span><span class="s1">TestSpecialMethods:</span>
    <span class="s0">def </span><span class="s1">test_wrap(self):</span>

        <span class="s0">class </span><span class="s1">with_wrap:</span>
            <span class="s0">def </span><span class="s1">__array__(self):</span>
                <span class="s0">return </span><span class="s1">np.zeros(</span><span class="s3">1</span><span class="s1">)</span>

            <span class="s0">def </span><span class="s1">__array_wrap__(self</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">context):</span>
                <span class="s1">r = with_wrap()</span>
                <span class="s1">r.arr = arr</span>
                <span class="s1">r.context = context</span>
                <span class="s0">return </span><span class="s1">r</span>

        <span class="s1">a = with_wrap()</span>
        <span class="s1">x = ncu.minimum(a</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(x.arr</span><span class="s0">, </span><span class="s1">np.zeros(</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">func</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">i = x.context</span>
        <span class="s1">assert_(func </span><span class="s0">is </span><span class="s1">ncu.minimum)</span>
        <span class="s1">assert_equal(len(args)</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(args[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(args[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(i</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_wrap_and_prepare_out(self):</span>
        <span class="s5"># Calling convention for out should not affect how special methods are</span>
        <span class="s5"># called</span>

        <span class="s0">class </span><span class="s1">StoreArrayPrepareWrap(np.ndarray):</span>
            <span class="s1">_wrap_args = </span><span class="s0">None</span>
            <span class="s1">_prepare_args = </span><span class="s0">None</span>
            <span class="s0">def </span><span class="s1">__new__(cls):</span>
                <span class="s0">return </span><span class="s1">np.zeros(()).view(cls)</span>
            <span class="s0">def </span><span class="s1">__array_wrap__(self</span><span class="s0">, </span><span class="s1">obj</span><span class="s0">, </span><span class="s1">context):</span>
                <span class="s1">self._wrap_args = context[</span><span class="s3">1</span><span class="s1">]</span>
                <span class="s0">return </span><span class="s1">obj</span>
            <span class="s0">def </span><span class="s1">__array_prepare__(self</span><span class="s0">, </span><span class="s1">obj</span><span class="s0">, </span><span class="s1">context):</span>
                <span class="s1">self._prepare_args = context[</span><span class="s3">1</span><span class="s1">]</span>
                <span class="s0">return </span><span class="s1">obj</span>
            <span class="s1">@property</span>
            <span class="s0">def </span><span class="s1">args(self):</span>
                <span class="s5"># We need to ensure these are fetched at the same time, before</span>
                <span class="s5"># any other ufuncs are called by the assertions</span>
                <span class="s0">return </span><span class="s1">(self._prepare_args</span><span class="s0">, </span><span class="s1">self._wrap_args)</span>
            <span class="s0">def </span><span class="s1">__repr__(self):</span>
                <span class="s0">return </span><span class="s2">&quot;a&quot;  </span><span class="s5"># for short test output</span>

        <span class="s0">def </span><span class="s1">do_test(f_call</span><span class="s0">, </span><span class="s1">f_expected):</span>
            <span class="s1">a = StoreArrayPrepareWrap()</span>
            <span class="s1">f_call(a)</span>
            <span class="s1">p</span><span class="s0">, </span><span class="s1">w = a.args</span>
            <span class="s1">expected = f_expected(a)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">assert_equal(p</span><span class="s0">, </span><span class="s1">expected)</span>
                <span class="s1">assert_equal(w</span><span class="s0">, </span><span class="s1">expected)</span>
            <span class="s0">except </span><span class="s1">AssertionError </span><span class="s0">as </span><span class="s1">e:</span>
                <span class="s5"># assert_equal produces truly useless error messages</span>
                <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s1">.join([</span>
                    <span class="s2">&quot;Bad arguments passed in ufunc call&quot;</span><span class="s0">,</span>
                    <span class="s2">&quot; expected:              {}&quot;</span><span class="s1">.format(expected)</span><span class="s0">,</span>
                    <span class="s2">&quot; __array_prepare__ got: {}&quot;</span><span class="s1">.format(p)</span><span class="s0">,</span>
                    <span class="s2">&quot; __array_wrap__ got:    {}&quot;</span><span class="s1">.format(w)</span>
                <span class="s1">]))</span>

        <span class="s5"># method not on the out argument</span>
        <span class="s1">do_test(</span><span class="s0">lambda </span><span class="s1">a: np.add(a</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,              lambda </span><span class="s1">a: (a</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">do_test(</span><span class="s0">lambda </span><span class="s1">a: np.add(a</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,        lambda </span><span class="s1">a: (a</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">do_test(</span><span class="s0">lambda </span><span class="s1">a: np.add(a</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">out=</span><span class="s0">None</span><span class="s1">)</span><span class="s0">,    lambda </span><span class="s1">a: (a</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">do_test(</span><span class="s0">lambda </span><span class="s1">a: np.add(a</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">out=(</span><span class="s0">None,</span><span class="s1">))</span><span class="s0">, lambda </span><span class="s1">a: (a</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s5"># method on the out argument</span>
        <span class="s1">do_test(</span><span class="s0">lambda </span><span class="s1">a: np.add(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">,           lambda </span><span class="s1">a: (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">a))</span>
        <span class="s1">do_test(</span><span class="s0">lambda </span><span class="s1">a: np.add(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">out=a)</span><span class="s0">,       lambda </span><span class="s1">a: (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">a))</span>
        <span class="s1">do_test(</span><span class="s0">lambda </span><span class="s1">a: np.add(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">out=(a</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,    lambda </span><span class="s1">a: (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">a))</span>

        <span class="s5"># Also check the where mask handling:</span>
        <span class="s1">do_test(</span><span class="s0">lambda </span><span class="s1">a: np.add(a</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">where=</span><span class="s0">False</span><span class="s1">)</span><span class="s0">, lambda </span><span class="s1">a: (a</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">do_test(</span><span class="s0">lambda </span><span class="s1">a: np.add(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">where=</span><span class="s0">False</span><span class="s1">)</span><span class="s0">, lambda </span><span class="s1">a: (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">a))</span>

    <span class="s0">def </span><span class="s1">test_wrap_with_iterable(self):</span>
        <span class="s5"># test fix for bug #1026:</span>

        <span class="s0">class </span><span class="s1">with_wrap(np.ndarray):</span>
            <span class="s1">__array_priority__ = </span><span class="s3">10</span>

            <span class="s0">def </span><span class="s1">__new__(cls):</span>
                <span class="s0">return </span><span class="s1">np.asarray(</span><span class="s3">1</span><span class="s1">).view(cls).copy()</span>

            <span class="s0">def </span><span class="s1">__array_wrap__(self</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">context):</span>
                <span class="s0">return </span><span class="s1">arr.view(type(self))</span>

        <span class="s1">a = with_wrap()</span>
        <span class="s1">x = ncu.multiply(a</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">assert_(isinstance(x</span><span class="s0">, </span><span class="s1">with_wrap))</span>
        <span class="s1">assert_array_equal(x</span><span class="s0">, </span><span class="s1">np.array((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)))</span>

    <span class="s0">def </span><span class="s1">test_priority_with_scalar(self):</span>
        <span class="s5"># test fix for bug #826:</span>

        <span class="s0">class </span><span class="s1">A(np.ndarray):</span>
            <span class="s1">__array_priority__ = </span><span class="s3">10</span>

            <span class="s0">def </span><span class="s1">__new__(cls):</span>
                <span class="s0">return </span><span class="s1">np.asarray(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s2">'float64'</span><span class="s1">).view(cls).copy()</span>

        <span class="s1">a = A()</span>
        <span class="s1">x = np.float64(</span><span class="s3">1</span><span class="s1">)*a</span>
        <span class="s1">assert_(isinstance(x</span><span class="s0">, </span><span class="s1">A))</span>
        <span class="s1">assert_array_equal(x</span><span class="s0">, </span><span class="s1">np.array(</span><span class="s3">1</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_old_wrap(self):</span>

        <span class="s0">class </span><span class="s1">with_wrap:</span>
            <span class="s0">def </span><span class="s1">__array__(self):</span>
                <span class="s0">return </span><span class="s1">np.zeros(</span><span class="s3">1</span><span class="s1">)</span>

            <span class="s0">def </span><span class="s1">__array_wrap__(self</span><span class="s0">, </span><span class="s1">arr):</span>
                <span class="s1">r = with_wrap()</span>
                <span class="s1">r.arr = arr</span>
                <span class="s0">return </span><span class="s1">r</span>

        <span class="s1">a = with_wrap()</span>
        <span class="s1">x = ncu.minimum(a</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(x.arr</span><span class="s0">, </span><span class="s1">np.zeros(</span><span class="s3">1</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_priority(self):</span>

        <span class="s0">class </span><span class="s1">A:</span>
            <span class="s0">def </span><span class="s1">__array__(self):</span>
                <span class="s0">return </span><span class="s1">np.zeros(</span><span class="s3">1</span><span class="s1">)</span>

            <span class="s0">def </span><span class="s1">__array_wrap__(self</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">context):</span>
                <span class="s1">r = type(self)()</span>
                <span class="s1">r.arr = arr</span>
                <span class="s1">r.context = context</span>
                <span class="s0">return </span><span class="s1">r</span>

        <span class="s0">class </span><span class="s1">B(A):</span>
            <span class="s1">__array_priority__ = </span><span class="s3">20.</span>

        <span class="s0">class </span><span class="s1">C(A):</span>
            <span class="s1">__array_priority__ = </span><span class="s3">40.</span>

        <span class="s1">x = np.zeros(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">a = A()</span>
        <span class="s1">b = B()</span>
        <span class="s1">c = C()</span>
        <span class="s1">f = ncu.minimum</span>
        <span class="s1">assert_(type(f(x</span><span class="s0">, </span><span class="s1">x)) </span><span class="s0">is </span><span class="s1">np.ndarray)</span>
        <span class="s1">assert_(type(f(x</span><span class="s0">, </span><span class="s1">a)) </span><span class="s0">is </span><span class="s1">A)</span>
        <span class="s1">assert_(type(f(x</span><span class="s0">, </span><span class="s1">b)) </span><span class="s0">is </span><span class="s1">B)</span>
        <span class="s1">assert_(type(f(x</span><span class="s0">, </span><span class="s1">c)) </span><span class="s0">is </span><span class="s1">C)</span>
        <span class="s1">assert_(type(f(a</span><span class="s0">, </span><span class="s1">x)) </span><span class="s0">is </span><span class="s1">A)</span>
        <span class="s1">assert_(type(f(b</span><span class="s0">, </span><span class="s1">x)) </span><span class="s0">is </span><span class="s1">B)</span>
        <span class="s1">assert_(type(f(c</span><span class="s0">, </span><span class="s1">x)) </span><span class="s0">is </span><span class="s1">C)</span>

        <span class="s1">assert_(type(f(a</span><span class="s0">, </span><span class="s1">a)) </span><span class="s0">is </span><span class="s1">A)</span>
        <span class="s1">assert_(type(f(a</span><span class="s0">, </span><span class="s1">b)) </span><span class="s0">is </span><span class="s1">B)</span>
        <span class="s1">assert_(type(f(b</span><span class="s0">, </span><span class="s1">a)) </span><span class="s0">is </span><span class="s1">B)</span>
        <span class="s1">assert_(type(f(b</span><span class="s0">, </span><span class="s1">b)) </span><span class="s0">is </span><span class="s1">B)</span>
        <span class="s1">assert_(type(f(b</span><span class="s0">, </span><span class="s1">c)) </span><span class="s0">is </span><span class="s1">C)</span>
        <span class="s1">assert_(type(f(c</span><span class="s0">, </span><span class="s1">b)) </span><span class="s0">is </span><span class="s1">C)</span>
        <span class="s1">assert_(type(f(c</span><span class="s0">, </span><span class="s1">c)) </span><span class="s0">is </span><span class="s1">C)</span>

        <span class="s1">assert_(type(ncu.exp(a) </span><span class="s0">is </span><span class="s1">A))</span>
        <span class="s1">assert_(type(ncu.exp(b) </span><span class="s0">is </span><span class="s1">B))</span>
        <span class="s1">assert_(type(ncu.exp(c) </span><span class="s0">is </span><span class="s1">C))</span>

    <span class="s0">def </span><span class="s1">test_failing_wrap(self):</span>

        <span class="s0">class </span><span class="s1">A:</span>
            <span class="s0">def </span><span class="s1">__array__(self):</span>
                <span class="s0">return </span><span class="s1">np.zeros(</span><span class="s3">2</span><span class="s1">)</span>

            <span class="s0">def </span><span class="s1">__array_wrap__(self</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">context):</span>
                <span class="s0">raise </span><span class="s1">RuntimeError</span>

        <span class="s1">a = A()</span>
        <span class="s1">assert_raises(RuntimeError</span><span class="s0">, </span><span class="s1">ncu.maximum</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_raises(RuntimeError</span><span class="s0">, </span><span class="s1">ncu.maximum.reduce</span><span class="s0">, </span><span class="s1">a)</span>

    <span class="s0">def </span><span class="s1">test_failing_out_wrap(self):</span>

        <span class="s1">singleton = np.array([</span><span class="s3">1.0</span><span class="s1">])</span>

        <span class="s0">class </span><span class="s1">Ok(np.ndarray):</span>
            <span class="s0">def </span><span class="s1">__array_wrap__(self</span><span class="s0">, </span><span class="s1">obj):</span>
                <span class="s0">return </span><span class="s1">singleton</span>

        <span class="s0">class </span><span class="s1">Bad(np.ndarray):</span>
            <span class="s0">def </span><span class="s1">__array_wrap__(self</span><span class="s0">, </span><span class="s1">obj):</span>
                <span class="s0">raise </span><span class="s1">RuntimeError</span>

        <span class="s1">ok = np.empty(</span><span class="s3">1</span><span class="s1">).view(Ok)</span>
        <span class="s1">bad = np.empty(</span><span class="s3">1</span><span class="s1">).view(Bad)</span>
        <span class="s5"># double-free (segfault) of &quot;ok&quot; if &quot;bad&quot; raises an exception</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">10</span><span class="s1">):</span>
            <span class="s1">assert_raises(RuntimeError</span><span class="s0">, </span><span class="s1">ncu.frexp</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">ok</span><span class="s0">, </span><span class="s1">bad)</span>

    <span class="s0">def </span><span class="s1">test_none_wrap(self):</span>
        <span class="s5"># Tests that issue #8507 is resolved. Previously, this would segfault</span>

        <span class="s0">class </span><span class="s1">A:</span>
            <span class="s0">def </span><span class="s1">__array__(self):</span>
                <span class="s0">return </span><span class="s1">np.zeros(</span><span class="s3">1</span><span class="s1">)</span>

            <span class="s0">def </span><span class="s1">__array_wrap__(self</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">context=</span><span class="s0">None</span><span class="s1">):</span>
                <span class="s0">return None</span>

        <span class="s1">a = A()</span>
        <span class="s1">assert_equal(ncu.maximum(a</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_default_prepare(self):</span>

        <span class="s0">class </span><span class="s1">with_wrap:</span>
            <span class="s1">__array_priority__ = </span><span class="s3">10</span>

            <span class="s0">def </span><span class="s1">__array__(self):</span>
                <span class="s0">return </span><span class="s1">np.zeros(</span><span class="s3">1</span><span class="s1">)</span>

            <span class="s0">def </span><span class="s1">__array_wrap__(self</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">context):</span>
                <span class="s0">return </span><span class="s1">arr</span>

        <span class="s1">a = with_wrap()</span>
        <span class="s1">x = ncu.minimum(a</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(x</span><span class="s0">, </span><span class="s1">np.zeros(</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">assert_equal(type(x)</span><span class="s0">, </span><span class="s1">np.ndarray)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;use_where&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_prepare(self</span><span class="s0">, </span><span class="s1">use_where):</span>

        <span class="s0">class </span><span class="s1">with_prepare(np.ndarray):</span>
            <span class="s1">__array_priority__ = </span><span class="s3">10</span>

            <span class="s0">def </span><span class="s1">__array_prepare__(self</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">context):</span>
                <span class="s5"># make sure we can return a new</span>
                <span class="s0">return </span><span class="s1">np.array(arr).view(type=with_prepare)</span>

        <span class="s1">a = np.array(</span><span class="s3">1</span><span class="s1">).view(type=with_prepare)</span>
        <span class="s0">if </span><span class="s1">use_where:</span>
            <span class="s1">x = np.add(a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">where=np.array(</span><span class="s0">True</span><span class="s1">))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">x = np.add(a</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(x</span><span class="s0">, </span><span class="s1">np.array(</span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">assert_equal(type(x)</span><span class="s0">, </span><span class="s1">with_prepare)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;use_where&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_prepare_out(self</span><span class="s0">, </span><span class="s1">use_where):</span>

        <span class="s0">class </span><span class="s1">with_prepare(np.ndarray):</span>
            <span class="s1">__array_priority__ = </span><span class="s3">10</span>

            <span class="s0">def </span><span class="s1">__array_prepare__(self</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">context):</span>
                <span class="s0">return </span><span class="s1">np.array(arr).view(type=with_prepare)</span>

        <span class="s1">a = np.array([</span><span class="s3">1</span><span class="s1">]).view(type=with_prepare)</span>
        <span class="s0">if </span><span class="s1">use_where:</span>
            <span class="s1">x = np.add(a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">where=[</span><span class="s0">True</span><span class="s1">])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">x = np.add(a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s5"># Returned array is new, because of the strange</span>
        <span class="s5"># __array_prepare__ above</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">np.shares_memory(x</span><span class="s0">, </span><span class="s1">a))</span>
        <span class="s1">assert_equal(x</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s3">2</span><span class="s1">]))</span>
        <span class="s1">assert_equal(type(x)</span><span class="s0">, </span><span class="s1">with_prepare)</span>

    <span class="s0">def </span><span class="s1">test_failing_prepare(self):</span>

        <span class="s0">class </span><span class="s1">A:</span>
            <span class="s0">def </span><span class="s1">__array__(self):</span>
                <span class="s0">return </span><span class="s1">np.zeros(</span><span class="s3">1</span><span class="s1">)</span>

            <span class="s0">def </span><span class="s1">__array_prepare__(self</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">context=</span><span class="s0">None</span><span class="s1">):</span>
                <span class="s0">raise </span><span class="s1">RuntimeError</span>

        <span class="s1">a = A()</span>
        <span class="s1">assert_raises(RuntimeError</span><span class="s0">, </span><span class="s1">ncu.maximum</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_raises(RuntimeError</span><span class="s0">, </span><span class="s1">ncu.maximum</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">where=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_array_too_many_args(self):</span>

        <span class="s0">class </span><span class="s1">A:</span>
            <span class="s0">def </span><span class="s1">__array__(self</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">context):</span>
                <span class="s0">return </span><span class="s1">np.zeros(</span><span class="s3">1</span><span class="s1">)</span>

        <span class="s1">a = A()</span>
        <span class="s1">assert_raises_regex(TypeError</span><span class="s0">, </span><span class="s2">'2 required positional'</span><span class="s0">, </span><span class="s1">np.sum</span><span class="s0">, </span><span class="s1">a)</span>

    <span class="s0">def </span><span class="s1">test_ufunc_override(self):</span>
        <span class="s5"># check override works even with instance with high priority.</span>
        <span class="s0">class </span><span class="s1">A:</span>
            <span class="s0">def </span><span class="s1">__array_ufunc__(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">inputs</span><span class="s0">, </span><span class="s1">kwargs</span>

        <span class="s0">class </span><span class="s1">MyNDArray(np.ndarray):</span>
            <span class="s1">__array_priority__ = </span><span class="s3">100</span>

        <span class="s1">a = A()</span>
        <span class="s1">b = np.array([</span><span class="s3">1</span><span class="s1">]).view(MyNDArray)</span>
        <span class="s1">res0 = np.multiply(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">res1 = np.multiply(b</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">out=a)</span>

        <span class="s5"># self</span>
        <span class="s1">assert_equal(res0[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(res1[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(res0[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.multiply)</span>
        <span class="s1">assert_equal(res1[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.multiply)</span>
        <span class="s1">assert_equal(res0[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'__call__'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res1[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'__call__'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res0[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(a</span><span class="s0">, </span><span class="s1">b))</span>
        <span class="s1">assert_equal(res1[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(b</span><span class="s0">, </span><span class="s1">b))</span>
        <span class="s1">assert_equal(res0[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{})</span>
        <span class="s1">assert_equal(res1[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'out'</span><span class="s1">: (a</span><span class="s0">,</span><span class="s1">)})</span>

    <span class="s0">def </span><span class="s1">test_ufunc_override_mro(self):</span>

        <span class="s5"># Some multi arg functions for testing.</span>
        <span class="s0">def </span><span class="s1">tres_mul(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c):</span>
            <span class="s0">return </span><span class="s1">a * b * c</span>

        <span class="s0">def </span><span class="s1">quatro_mul(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">d):</span>
            <span class="s0">return </span><span class="s1">a * b * c * d</span>

        <span class="s5"># Make these into ufuncs.</span>
        <span class="s1">three_mul_ufunc = np.frompyfunc(tres_mul</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">four_mul_ufunc = np.frompyfunc(quatro_mul</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s0">class </span><span class="s1">A:</span>
            <span class="s0">def </span><span class="s1">__array_ufunc__(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s0">return </span><span class="s2">&quot;A&quot;</span>

        <span class="s0">class </span><span class="s1">ASub(A):</span>
            <span class="s0">def </span><span class="s1">__array_ufunc__(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s0">return </span><span class="s2">&quot;ASub&quot;</span>

        <span class="s0">class </span><span class="s1">B:</span>
            <span class="s0">def </span><span class="s1">__array_ufunc__(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s0">return </span><span class="s2">&quot;B&quot;</span>

        <span class="s0">class </span><span class="s1">C:</span>
            <span class="s0">def </span><span class="s1">__init__(self):</span>
                <span class="s1">self.count = </span><span class="s3">0</span>

            <span class="s0">def </span><span class="s1">__array_ufunc__(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s1">self.count += </span><span class="s3">1</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>

        <span class="s0">class </span><span class="s1">CSub(C):</span>
            <span class="s0">def </span><span class="s1">__array_ufunc__(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s1">self.count += </span><span class="s3">1</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>

        <span class="s1">a = A()</span>
        <span class="s1">a_sub = ASub()</span>
        <span class="s1">b = B()</span>
        <span class="s1">c = C()</span>

        <span class="s5"># Standard</span>
        <span class="s1">res = np.multiply(a</span><span class="s0">, </span><span class="s1">a_sub)</span>
        <span class="s1">assert_equal(res</span><span class="s0">, </span><span class="s2">&quot;ASub&quot;</span><span class="s1">)</span>
        <span class="s1">res = np.multiply(a_sub</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(res</span><span class="s0">, </span><span class="s2">&quot;ASub&quot;</span><span class="s1">)</span>

        <span class="s5"># With 1 NotImplemented</span>
        <span class="s1">res = np.multiply(c</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(res</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(c.count</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s5"># Check our counter works, so we can trust tests below.</span>
        <span class="s1">res = np.multiply(c</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(c.count</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>

        <span class="s5"># Both NotImplemented.</span>
        <span class="s1">c = C()</span>
        <span class="s1">c_sub = CSub()</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.multiply</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">c_sub)</span>
        <span class="s1">assert_equal(c.count</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(c_sub.count</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">c.count = c_sub.count = </span><span class="s3">0</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.multiply</span><span class="s0">, </span><span class="s1">c_sub</span><span class="s0">, </span><span class="s1">c)</span>
        <span class="s1">assert_equal(c.count</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(c_sub.count</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">c.count = </span><span class="s3">0</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.multiply</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">c)</span>
        <span class="s1">assert_equal(c.count</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">c.count = </span><span class="s3">0</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.multiply</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">c)</span>
        <span class="s1">assert_equal(c.count</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s5"># Ternary testing.</span>
        <span class="s1">assert_equal(three_mul_ufunc(a</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(three_mul_ufunc(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(three_mul_ufunc(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>

        <span class="s1">assert_equal(three_mul_ufunc(a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(three_mul_ufunc(a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(three_mul_ufunc(a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(three_mul_ufunc(a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">a_sub)</span><span class="s0">, </span><span class="s2">&quot;ASub&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(three_mul_ufunc(a</span><span class="s0">, </span><span class="s1">a_sub</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;ASub&quot;</span><span class="s1">)</span>
        <span class="s1">c.count = </span><span class="s3">0</span>
        <span class="s1">assert_equal(three_mul_ufunc(c</span><span class="s0">, </span><span class="s1">a_sub</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;ASub&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(c.count</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">c.count = </span><span class="s3">0</span>
        <span class="s1">assert_equal(three_mul_ufunc(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">a_sub</span><span class="s0">, </span><span class="s1">c)</span><span class="s0">, </span><span class="s2">&quot;ASub&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(c.count</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s1">c.count = </span><span class="s3">0</span>
        <span class="s1">assert_equal(three_mul_ufunc(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c)</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(c.count</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">c_sub.count = </span><span class="s3">0</span>
        <span class="s1">assert_equal(three_mul_ufunc(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c_sub)</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(c_sub.count</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(three_mul_ufunc(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">)</span>

        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">three_mul_ufunc</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">c)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">three_mul_ufunc</span><span class="s0">, </span><span class="s1">c_sub</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">c)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">three_mul_ufunc</span><span class="s0">, </span><span class="s1">c_sub</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>

        <span class="s5"># Quaternary testing.</span>
        <span class="s1">assert_equal(four_mul_ufunc(a</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(four_mul_ufunc(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(four_mul_ufunc(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(four_mul_ufunc(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>

        <span class="s1">assert_equal(four_mul_ufunc(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(four_mul_ufunc(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(four_mul_ufunc(b</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(four_mul_ufunc(a_sub</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s2">&quot;ASub&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(four_mul_ufunc(a</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">a_sub)</span><span class="s0">, </span><span class="s2">&quot;ASub&quot;</span><span class="s1">)</span>

        <span class="s1">c = C()</span>
        <span class="s1">c_sub = CSub()</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">four_mul_ufunc</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s1">c)</span>
        <span class="s1">assert_equal(c.count</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">c.count = </span><span class="s3">0</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">four_mul_ufunc</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">c_sub</span><span class="s0">, </span><span class="s1">c)</span>
        <span class="s1">assert_equal(c_sub.count</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(c.count</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">c2 = C()</span>
        <span class="s1">c.count = c_sub.count = </span><span class="s3">0</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">four_mul_ufunc</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">c_sub</span><span class="s0">, </span><span class="s1">c2)</span>
        <span class="s1">assert_equal(c_sub.count</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(c.count</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(c2.count</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">c.count = c2.count = c_sub.count = </span><span class="s3">0</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">four_mul_ufunc</span><span class="s0">, </span><span class="s1">c2</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">c_sub</span><span class="s0">, </span><span class="s1">c)</span>
        <span class="s1">assert_equal(c_sub.count</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(c.count</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(c2.count</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_ufunc_override_methods(self):</span>

        <span class="s0">class </span><span class="s1">A:</span>
            <span class="s0">def </span><span class="s1">__array_ufunc__(self</span><span class="s0">, </span><span class="s1">ufunc</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s0">, </span><span class="s1">ufunc</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">inputs</span><span class="s0">, </span><span class="s1">kwargs</span>

        <span class="s5"># __call__</span>
        <span class="s1">a = A()</span>
        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">np.multiply.__call__(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">foo=</span><span class="s2">'bar'</span><span class="s0">, </span><span class="s1">answer=</span><span class="s3">42</span><span class="s1">)</span>
        <span class="s1">res = np.multiply.__call__(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">subok=</span><span class="s2">'bar'</span><span class="s0">, </span><span class="s1">where=</span><span class="s3">42</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.multiply)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'__call__'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">a))</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'subok'</span><span class="s1">: </span><span class="s2">'bar'</span><span class="s0">, </span><span class="s2">'where'</span><span class="s1">: </span><span class="s3">42</span><span class="s1">})</span>

        <span class="s5"># __call__, wrong args</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.multiply</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.multiply</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.multiply</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">sig=</span><span class="s2">'a'</span><span class="s0">, </span><span class="s1">signature=</span><span class="s2">'a'</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">ncu_tests.inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>

        <span class="s5"># reduce, positional args</span>
        <span class="s1">res = np.multiply.reduce(a</span><span class="s0">, </span><span class="s2">'axis0'</span><span class="s0">, </span><span class="s2">'dtype0'</span><span class="s0">, </span><span class="s2">'out0'</span><span class="s0">, </span><span class="s2">'keep0'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.multiply)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'reduce'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(a</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'dtype'</span><span class="s1">:</span><span class="s2">'dtype0'</span><span class="s0">,</span>
                              <span class="s2">'out'</span><span class="s1">: (</span><span class="s2">'out0'</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
                              <span class="s2">'keepdims'</span><span class="s1">: </span><span class="s2">'keep0'</span><span class="s0">,</span>
                              <span class="s2">'axis'</span><span class="s1">: </span><span class="s2">'axis0'</span><span class="s1">})</span>

        <span class="s5"># reduce, kwargs</span>
        <span class="s1">res = np.multiply.reduce(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">'axis0'</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'dtype0'</span><span class="s0">, </span><span class="s1">out=</span><span class="s2">'out0'</span><span class="s0">,</span>
                                 <span class="s1">keepdims=</span><span class="s2">'keep0'</span><span class="s0">, </span><span class="s1">initial=</span><span class="s2">'init0'</span><span class="s0">,</span>
                                 <span class="s1">where=</span><span class="s2">'where0'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.multiply)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'reduce'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(a</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'dtype'</span><span class="s1">:</span><span class="s2">'dtype0'</span><span class="s0">,</span>
                              <span class="s2">'out'</span><span class="s1">: (</span><span class="s2">'out0'</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
                              <span class="s2">'keepdims'</span><span class="s1">: </span><span class="s2">'keep0'</span><span class="s0">,</span>
                              <span class="s2">'axis'</span><span class="s1">: </span><span class="s2">'axis0'</span><span class="s0">,</span>
                              <span class="s2">'initial'</span><span class="s1">: </span><span class="s2">'init0'</span><span class="s0">,</span>
                              <span class="s2">'where'</span><span class="s1">: </span><span class="s2">'where0'</span><span class="s1">})</span>

        <span class="s5"># reduce, output equal to None removed, but not other explicit ones,</span>
        <span class="s5"># even if they are at their default value.</span>
        <span class="s1">res = np.multiply.reduce(a</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, None, False</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'axis'</span><span class="s1">: </span><span class="s3">0</span><span class="s0">, </span><span class="s2">'dtype'</span><span class="s1">: </span><span class="s0">None, </span><span class="s2">'keepdims'</span><span class="s1">: </span><span class="s0">False</span><span class="s1">})</span>
        <span class="s1">res = np.multiply.reduce(a</span><span class="s0">, </span><span class="s1">out=</span><span class="s0">None, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'axis'</span><span class="s1">: </span><span class="s3">0</span><span class="s0">, </span><span class="s2">'keepdims'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">})</span>
        <span class="s1">res = np.multiply.reduce(a</span><span class="s0">, None, </span><span class="s1">out=(</span><span class="s0">None,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'axis'</span><span class="s1">: </span><span class="s0">None, </span><span class="s2">'dtype'</span><span class="s1">: </span><span class="s0">None</span><span class="s1">})</span>
        <span class="s1">res = np.multiply.reduce(a</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, None, False, </span><span class="s3">2</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'axis'</span><span class="s1">: </span><span class="s3">0</span><span class="s0">, </span><span class="s2">'dtype'</span><span class="s1">: </span><span class="s0">None, </span><span class="s2">'keepdims'</span><span class="s1">: </span><span class="s0">False,</span>
                              <span class="s2">'initial'</span><span class="s1">: </span><span class="s3">2</span><span class="s0">, </span><span class="s2">'where'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">})</span>
        <span class="s5"># np._NoValue ignored for initial</span>
        <span class="s1">res = np.multiply.reduce(a</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, None, False,</span>
                                 <span class="s1">np._NoValue</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'axis'</span><span class="s1">: </span><span class="s3">0</span><span class="s0">, </span><span class="s2">'dtype'</span><span class="s1">: </span><span class="s0">None, </span><span class="s2">'keepdims'</span><span class="s1">: </span><span class="s0">False,</span>
                              <span class="s2">'where'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">})</span>
        <span class="s5"># None kept for initial, True for where.</span>
        <span class="s1">res = np.multiply.reduce(a</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, None, False, None, True</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'axis'</span><span class="s1">: </span><span class="s3">0</span><span class="s0">, </span><span class="s2">'dtype'</span><span class="s1">: </span><span class="s0">None, </span><span class="s2">'keepdims'</span><span class="s1">: </span><span class="s0">False,</span>
                              <span class="s2">'initial'</span><span class="s1">: </span><span class="s0">None, </span><span class="s2">'where'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">})</span>

        <span class="s5"># reduce, wrong args</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.multiply.reduce</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">out=())</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.multiply.reduce</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">out=(</span><span class="s2">'out0'</span><span class="s0">, </span><span class="s2">'out1'</span><span class="s1">))</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.multiply.reduce</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s2">'axis0'</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">'axis0'</span><span class="s1">)</span>

        <span class="s5"># accumulate, pos args</span>
        <span class="s1">res = np.multiply.accumulate(a</span><span class="s0">, </span><span class="s2">'axis0'</span><span class="s0">, </span><span class="s2">'dtype0'</span><span class="s0">, </span><span class="s2">'out0'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.multiply)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'accumulate'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(a</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'dtype'</span><span class="s1">:</span><span class="s2">'dtype0'</span><span class="s0">,</span>
                              <span class="s2">'out'</span><span class="s1">: (</span><span class="s2">'out0'</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
                              <span class="s2">'axis'</span><span class="s1">: </span><span class="s2">'axis0'</span><span class="s1">})</span>

        <span class="s5"># accumulate, kwargs</span>
        <span class="s1">res = np.multiply.accumulate(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">'axis0'</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'dtype0'</span><span class="s0">,</span>
                                     <span class="s1">out=</span><span class="s2">'out0'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.multiply)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'accumulate'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(a</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'dtype'</span><span class="s1">:</span><span class="s2">'dtype0'</span><span class="s0">,</span>
                              <span class="s2">'out'</span><span class="s1">: (</span><span class="s2">'out0'</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
                              <span class="s2">'axis'</span><span class="s1">: </span><span class="s2">'axis0'</span><span class="s1">})</span>

        <span class="s5"># accumulate, output equal to None removed.</span>
        <span class="s1">res = np.multiply.accumulate(a</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, None</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'axis'</span><span class="s1">: </span><span class="s3">0</span><span class="s0">, </span><span class="s2">'dtype'</span><span class="s1">: </span><span class="s0">None</span><span class="s1">})</span>
        <span class="s1">res = np.multiply.accumulate(a</span><span class="s0">, </span><span class="s1">out=</span><span class="s0">None, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'dtype1'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'axis'</span><span class="s1">: </span><span class="s3">0</span><span class="s0">, </span><span class="s2">'dtype'</span><span class="s1">: </span><span class="s2">'dtype1'</span><span class="s1">})</span>
        <span class="s1">res = np.multiply.accumulate(a</span><span class="s0">, None, </span><span class="s1">out=(</span><span class="s0">None,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'axis'</span><span class="s1">: </span><span class="s0">None, </span><span class="s2">'dtype'</span><span class="s1">: </span><span class="s0">None</span><span class="s1">})</span>

        <span class="s5"># accumulate, wrong args</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.multiply.accumulate</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">out=())</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.multiply.accumulate</span><span class="s0">, </span><span class="s1">a</span><span class="s0">,</span>
                      <span class="s1">out=(</span><span class="s2">'out0'</span><span class="s0">, </span><span class="s2">'out1'</span><span class="s1">))</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.multiply.accumulate</span><span class="s0">, </span><span class="s1">a</span><span class="s0">,</span>
                      <span class="s2">'axis0'</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">'axis0'</span><span class="s1">)</span>

        <span class="s5"># reduceat, pos args</span>
        <span class="s1">res = np.multiply.reduceat(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'axis0'</span><span class="s0">, </span><span class="s2">'dtype0'</span><span class="s0">, </span><span class="s2">'out0'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.multiply)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'reduceat'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]))</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'dtype'</span><span class="s1">:</span><span class="s2">'dtype0'</span><span class="s0">,</span>
                              <span class="s2">'out'</span><span class="s1">: (</span><span class="s2">'out0'</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
                              <span class="s2">'axis'</span><span class="s1">: </span><span class="s2">'axis0'</span><span class="s1">})</span>

        <span class="s5"># reduceat, kwargs</span>
        <span class="s1">res = np.multiply.reduceat(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">'axis0'</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'dtype0'</span><span class="s0">,</span>
                                   <span class="s1">out=</span><span class="s2">'out0'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.multiply)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'reduceat'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]))</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'dtype'</span><span class="s1">:</span><span class="s2">'dtype0'</span><span class="s0">,</span>
                              <span class="s2">'out'</span><span class="s1">: (</span><span class="s2">'out0'</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
                              <span class="s2">'axis'</span><span class="s1">: </span><span class="s2">'axis0'</span><span class="s1">})</span>

        <span class="s5"># reduceat, output equal to None removed.</span>
        <span class="s1">res = np.multiply.reduceat(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, None</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'axis'</span><span class="s1">: </span><span class="s3">0</span><span class="s0">, </span><span class="s2">'dtype'</span><span class="s1">: </span><span class="s0">None</span><span class="s1">})</span>
        <span class="s1">res = np.multiply.reduceat(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None, </span><span class="s1">out=</span><span class="s0">None, </span><span class="s1">dtype=</span><span class="s2">'dt'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'axis'</span><span class="s1">: </span><span class="s0">None, </span><span class="s2">'dtype'</span><span class="s1">: </span><span class="s2">'dt'</span><span class="s1">})</span>
        <span class="s1">res = np.multiply.reduceat(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, None, None, </span><span class="s1">out=(</span><span class="s0">None,</span><span class="s1">))</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'axis'</span><span class="s1">: </span><span class="s0">None, </span><span class="s2">'dtype'</span><span class="s1">: </span><span class="s0">None</span><span class="s1">})</span>

        <span class="s5"># reduceat, wrong args</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.multiply.reduce</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">out=())</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.multiply.reduce</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">out=(</span><span class="s2">'out0'</span><span class="s0">, </span><span class="s2">'out1'</span><span class="s1">))</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.multiply.reduce</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s2">'axis0'</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">'axis0'</span><span class="s1">)</span>

        <span class="s5"># outer</span>
        <span class="s1">res = np.multiply.outer(a</span><span class="s0">, </span><span class="s3">42</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.multiply)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'outer'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(a</span><span class="s0">, </span><span class="s3">42</span><span class="s1">))</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{})</span>

        <span class="s5"># outer, wrong args</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.multiply.outer</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.multiply.outer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.multiply.outer</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">sig=</span><span class="s2">'a'</span><span class="s0">, </span><span class="s1">signature=</span><span class="s2">'a'</span><span class="s1">)</span>

        <span class="s5"># at</span>
        <span class="s1">res = np.multiply.at(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'b0'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.multiply)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'at'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'b0'</span><span class="s1">))</span>

        <span class="s5"># at, wrong args</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.multiply.at</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.multiply.at</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a)</span>

    <span class="s0">def </span><span class="s1">test_ufunc_override_out(self):</span>

        <span class="s0">class </span><span class="s1">A:</span>
            <span class="s0">def </span><span class="s1">__array_ufunc__(self</span><span class="s0">, </span><span class="s1">ufunc</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s0">return </span><span class="s1">kwargs</span>

        <span class="s0">class </span><span class="s1">B:</span>
            <span class="s0">def </span><span class="s1">__array_ufunc__(self</span><span class="s0">, </span><span class="s1">ufunc</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s0">return </span><span class="s1">kwargs</span>

        <span class="s1">a = A()</span>
        <span class="s1">b = B()</span>
        <span class="s1">res0 = np.multiply(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s2">'out_arg'</span><span class="s1">)</span>
        <span class="s1">res1 = np.multiply(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">out=</span><span class="s2">'out_arg'</span><span class="s1">)</span>
        <span class="s1">res2 = np.multiply(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s2">'out_arg'</span><span class="s1">)</span>
        <span class="s1">res3 = np.multiply(</span><span class="s3">3</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">out=</span><span class="s2">'out_arg'</span><span class="s1">)</span>
        <span class="s1">res4 = np.multiply(a</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s2">'out_arg'</span><span class="s1">)</span>
        <span class="s1">res5 = np.multiply(a</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s1">out=</span><span class="s2">'out_arg'</span><span class="s1">)</span>

        <span class="s1">assert_equal(res0[</span><span class="s2">'out'</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'out_arg'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res1[</span><span class="s2">'out'</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'out_arg'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res2[</span><span class="s2">'out'</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'out_arg'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res3[</span><span class="s2">'out'</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'out_arg'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res4[</span><span class="s2">'out'</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'out_arg'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res5[</span><span class="s2">'out'</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'out_arg'</span><span class="s1">)</span>

        <span class="s5"># ufuncs with multiple output modf and frexp.</span>
        <span class="s1">res6 = np.modf(a</span><span class="s0">, </span><span class="s2">'out0'</span><span class="s0">, </span><span class="s2">'out1'</span><span class="s1">)</span>
        <span class="s1">res7 = np.frexp(a</span><span class="s0">, </span><span class="s2">'out0'</span><span class="s0">, </span><span class="s2">'out1'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res6[</span><span class="s2">'out'</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'out0'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res6[</span><span class="s2">'out'</span><span class="s1">][</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'out1'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res7[</span><span class="s2">'out'</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'out0'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res7[</span><span class="s2">'out'</span><span class="s1">][</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'out1'</span><span class="s1">)</span>

        <span class="s5"># While we're at it, check that default output is never passed on.</span>
        <span class="s1">assert_(np.sin(a</span><span class="s0">, None</span><span class="s1">) == {})</span>
        <span class="s1">assert_(np.sin(a</span><span class="s0">, </span><span class="s1">out=</span><span class="s0">None</span><span class="s1">) == {})</span>
        <span class="s1">assert_(np.sin(a</span><span class="s0">, </span><span class="s1">out=(</span><span class="s0">None,</span><span class="s1">)) == {})</span>
        <span class="s1">assert_(np.modf(a</span><span class="s0">, None</span><span class="s1">) == {})</span>
        <span class="s1">assert_(np.modf(a</span><span class="s0">, None, None</span><span class="s1">) == {})</span>
        <span class="s1">assert_(np.modf(a</span><span class="s0">, </span><span class="s1">out=(</span><span class="s0">None, None</span><span class="s1">)) == {})</span>
        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s5"># Out argument must be tuple, since there are multiple outputs.</span>
            <span class="s1">np.modf(a</span><span class="s0">, </span><span class="s1">out=</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s5"># don't give positional and output argument, or too many arguments.</span>
        <span class="s5"># wrong number of arguments in the tuple is an error too.</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.multiply</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s2">'one'</span><span class="s0">, </span><span class="s1">out=</span><span class="s2">'two'</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.multiply</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s2">'one'</span><span class="s0">, </span><span class="s2">'two'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.multiply</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">out=(</span><span class="s2">'one'</span><span class="s0">, </span><span class="s2">'two'</span><span class="s1">))</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.multiply</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">out=())</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.modf</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s2">'one'</span><span class="s0">, </span><span class="s1">out=(</span><span class="s2">'two'</span><span class="s0">, </span><span class="s2">'three'</span><span class="s1">))</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.modf</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s2">'one'</span><span class="s0">, </span><span class="s2">'two'</span><span class="s0">, </span><span class="s2">'three'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.modf</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">out=(</span><span class="s2">'one'</span><span class="s0">, </span><span class="s2">'two'</span><span class="s0">, </span><span class="s2">'three'</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.modf</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">out=(</span><span class="s2">'one'</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_ufunc_override_exception(self):</span>

        <span class="s0">class </span><span class="s1">A:</span>
            <span class="s0">def </span><span class="s1">__array_ufunc__(self</span><span class="s0">, </span><span class="s1">*a</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;oops&quot;</span><span class="s1">)</span>

        <span class="s1">a = A()</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.negative</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">out=a)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.negative</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.divide</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s1">a)</span>

    <span class="s0">def </span><span class="s1">test_ufunc_override_not_implemented(self):</span>

        <span class="s0">class </span><span class="s1">A:</span>
            <span class="s0">def </span><span class="s1">__array_ufunc__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>

        <span class="s1">msg = (</span><span class="s2">&quot;operand type(s) all returned NotImplemented from &quot;</span>
               <span class="s2">&quot;__array_ufunc__(&lt;ufunc 'negative'&gt;, '__call__', &lt;*&gt;): 'A'&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">assert_raises_regex(TypeError</span><span class="s0">, </span><span class="s1">fnmatch.translate(msg)):</span>
            <span class="s1">np.negative(A())</span>

        <span class="s1">msg = (</span><span class="s2">&quot;operand type(s) all returned NotImplemented from &quot;</span>
               <span class="s2">&quot;__array_ufunc__(&lt;ufunc 'add'&gt;, '__call__', &lt;*&gt;, &lt;object *&gt;, &quot;</span>
               <span class="s2">&quot;out=(1,)): 'A', 'object', 'int'&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">assert_raises_regex(TypeError</span><span class="s0">, </span><span class="s1">fnmatch.translate(msg)):</span>
            <span class="s1">np.add(A()</span><span class="s0">, </span><span class="s1">object()</span><span class="s0">, </span><span class="s1">out=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_ufunc_override_disabled(self):</span>

        <span class="s0">class </span><span class="s1">OptOut:</span>
            <span class="s1">__array_ufunc__ = </span><span class="s0">None</span>

        <span class="s1">opt_out = OptOut()</span>

        <span class="s5"># ufuncs always raise</span>
        <span class="s1">msg = </span><span class="s2">&quot;operand 'OptOut' does not support ufuncs&quot;</span>
        <span class="s0">with </span><span class="s1">assert_raises_regex(TypeError</span><span class="s0">, </span><span class="s1">msg):</span>
            <span class="s1">np.add(opt_out</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">assert_raises_regex(TypeError</span><span class="s0">, </span><span class="s1">msg):</span>
            <span class="s1">np.add(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">opt_out)</span>
        <span class="s0">with </span><span class="s1">assert_raises_regex(TypeError</span><span class="s0">, </span><span class="s1">msg):</span>
            <span class="s1">np.negative(opt_out)</span>

        <span class="s5"># opt-outs still hold even when other arguments have pathological</span>
        <span class="s5"># __array_ufunc__ implementations</span>

        <span class="s0">class </span><span class="s1">GreedyArray:</span>
            <span class="s0">def </span><span class="s1">__array_ufunc__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s0">return </span><span class="s1">self</span>

        <span class="s1">greedy = GreedyArray()</span>
        <span class="s1">assert_(np.negative(greedy) </span><span class="s0">is </span><span class="s1">greedy)</span>
        <span class="s0">with </span><span class="s1">assert_raises_regex(TypeError</span><span class="s0">, </span><span class="s1">msg):</span>
            <span class="s1">np.add(greedy</span><span class="s0">, </span><span class="s1">opt_out)</span>
        <span class="s0">with </span><span class="s1">assert_raises_regex(TypeError</span><span class="s0">, </span><span class="s1">msg):</span>
            <span class="s1">np.add(greedy</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">out=opt_out)</span>

    <span class="s0">def </span><span class="s1">test_gufunc_override(self):</span>
        <span class="s5"># gufunc are just ufunc instances, but follow a different path,</span>
        <span class="s5"># so check __array_ufunc__ overrides them properly.</span>
        <span class="s0">class </span><span class="s1">A:</span>
            <span class="s0">def </span><span class="s1">__array_ufunc__(self</span><span class="s0">, </span><span class="s1">ufunc</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s0">, </span><span class="s1">ufunc</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">inputs</span><span class="s0">, </span><span class="s1">kwargs</span>

        <span class="s1">inner1d = ncu_tests.inner1d</span>
        <span class="s1">a = A()</span>
        <span class="s1">res = inner1d(a</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">inner1d)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'__call__'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(a</span><span class="s0">, </span><span class="s1">a))</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{})</span>

        <span class="s1">res = inner1d(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">out=a)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">inner1d)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'__call__'</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">assert_equal(res[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'out'</span><span class="s1">: (a</span><span class="s0">,</span><span class="s1">)})</span>

        <span class="s5"># wrong number of arguments in the tuple is an error too.</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">out=</span><span class="s2">'two'</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s2">'one'</span><span class="s0">, </span><span class="s1">out=</span><span class="s2">'two'</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s2">'one'</span><span class="s0">, </span><span class="s2">'two'</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">out=(</span><span class="s2">'one'</span><span class="s0">, </span><span class="s2">'two'</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">out=())</span>

    <span class="s0">def </span><span class="s1">test_ufunc_override_with_super(self):</span>
        <span class="s5"># NOTE: this class is used in doc/source/user/basics.subclassing.rst</span>
        <span class="s5"># if you make any changes here, do update it there too.</span>
        <span class="s0">class </span><span class="s1">A(np.ndarray):</span>
            <span class="s0">def </span><span class="s1">__array_ufunc__(self</span><span class="s0">, </span><span class="s1">ufunc</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">out=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
                <span class="s1">args = []</span>
                <span class="s1">in_no = []</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">input_ </span><span class="s0">in </span><span class="s1">enumerate(inputs):</span>
                    <span class="s0">if </span><span class="s1">isinstance(input_</span><span class="s0">, </span><span class="s1">A):</span>
                        <span class="s1">in_no.append(i)</span>
                        <span class="s1">args.append(input_.view(np.ndarray))</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">args.append(input_)</span>

                <span class="s1">outputs = out</span>
                <span class="s1">out_no = []</span>
                <span class="s0">if </span><span class="s1">outputs:</span>
                    <span class="s1">out_args = []</span>
                    <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">output </span><span class="s0">in </span><span class="s1">enumerate(outputs):</span>
                        <span class="s0">if </span><span class="s1">isinstance(output</span><span class="s0">, </span><span class="s1">A):</span>
                            <span class="s1">out_no.append(j)</span>
                            <span class="s1">out_args.append(output.view(np.ndarray))</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">out_args.append(output)</span>
                    <span class="s1">kwargs[</span><span class="s2">'out'</span><span class="s1">] = tuple(out_args)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">outputs = (</span><span class="s0">None,</span><span class="s1">) * ufunc.nout</span>

                <span class="s1">info = {}</span>
                <span class="s0">if </span><span class="s1">in_no:</span>
                    <span class="s1">info[</span><span class="s2">'inputs'</span><span class="s1">] = in_no</span>
                <span class="s0">if </span><span class="s1">out_no:</span>
                    <span class="s1">info[</span><span class="s2">'outputs'</span><span class="s1">] = out_no</span>

                <span class="s1">results = super().__array_ufunc__(ufunc</span><span class="s0">, </span><span class="s1">method</span><span class="s0">,</span>
                                                  <span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
                <span class="s0">if </span><span class="s1">results </span><span class="s0">is </span><span class="s1">NotImplemented:</span>
                    <span class="s0">return </span><span class="s1">NotImplemented</span>

                <span class="s0">if </span><span class="s1">method == </span><span class="s2">'at'</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">isinstance(inputs[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">A):</span>
                        <span class="s1">inputs[</span><span class="s3">0</span><span class="s1">].info = info</span>
                    <span class="s0">return</span>

                <span class="s0">if </span><span class="s1">ufunc.nout == </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s1">results = (results</span><span class="s0">,</span><span class="s1">)</span>

                <span class="s1">results = tuple((np.asarray(result).view(A)</span>
                                 <span class="s0">if </span><span class="s1">output </span><span class="s0">is None else </span><span class="s1">output)</span>
                                <span class="s0">for </span><span class="s1">result</span><span class="s0">, </span><span class="s1">output </span><span class="s0">in </span><span class="s1">zip(results</span><span class="s0">, </span><span class="s1">outputs))</span>
                <span class="s0">if </span><span class="s1">results </span><span class="s0">and </span><span class="s1">isinstance(results[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">A):</span>
                    <span class="s1">results[</span><span class="s3">0</span><span class="s1">].info = info</span>

                <span class="s0">return </span><span class="s1">results[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">if </span><span class="s1">len(results) == </span><span class="s3">1 </span><span class="s0">else </span><span class="s1">results</span>

        <span class="s0">class </span><span class="s1">B:</span>
            <span class="s0">def </span><span class="s1">__array_ufunc__(self</span><span class="s0">, </span><span class="s1">ufunc</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s0">if </span><span class="s1">any(isinstance(input_</span><span class="s0">, </span><span class="s1">A) </span><span class="s0">for </span><span class="s1">input_ </span><span class="s0">in </span><span class="s1">inputs):</span>
                    <span class="s0">return </span><span class="s2">&quot;A!&quot;</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">NotImplemented</span>

        <span class="s1">d = np.arange(</span><span class="s3">5.</span><span class="s1">)</span>
        <span class="s5"># 1 input, 1 output</span>
        <span class="s1">a = np.arange(</span><span class="s3">5.</span><span class="s1">).view(A)</span>
        <span class="s1">b = np.sin(a)</span>
        <span class="s1">check = np.sin(d)</span>
        <span class="s1">assert_(np.all(check == b))</span>
        <span class="s1">assert_equal(b.info</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'inputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]})</span>
        <span class="s1">b = np.sin(d</span><span class="s0">, </span><span class="s1">out=(a</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">assert_(np.all(check == b))</span>
        <span class="s1">assert_equal(b.info</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'outputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]})</span>
        <span class="s1">assert_(b </span><span class="s0">is </span><span class="s1">a)</span>
        <span class="s1">a = np.arange(</span><span class="s3">5.</span><span class="s1">).view(A)</span>
        <span class="s1">b = np.sin(a</span><span class="s0">, </span><span class="s1">out=a)</span>
        <span class="s1">assert_(np.all(check == b))</span>
        <span class="s1">assert_equal(b.info</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'inputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'outputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]})</span>

        <span class="s5"># 1 input, 2 outputs</span>
        <span class="s1">a = np.arange(</span><span class="s3">5.</span><span class="s1">).view(A)</span>
        <span class="s1">b1</span><span class="s0">, </span><span class="s1">b2 = np.modf(a)</span>
        <span class="s1">assert_equal(b1.info</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'inputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]})</span>
        <span class="s1">b1</span><span class="s0">, </span><span class="s1">b2 = np.modf(d</span><span class="s0">, </span><span class="s1">out=(</span><span class="s0">None, </span><span class="s1">a))</span>
        <span class="s1">assert_(b2 </span><span class="s0">is </span><span class="s1">a)</span>
        <span class="s1">assert_equal(b1.info</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'outputs'</span><span class="s1">: [</span><span class="s3">1</span><span class="s1">]})</span>
        <span class="s1">a = np.arange(</span><span class="s3">5.</span><span class="s1">).view(A)</span>
        <span class="s1">b = np.arange(</span><span class="s3">5.</span><span class="s1">).view(A)</span>
        <span class="s1">c1</span><span class="s0">, </span><span class="s1">c2 = np.modf(a</span><span class="s0">, </span><span class="s1">out=(a</span><span class="s0">, </span><span class="s1">b))</span>
        <span class="s1">assert_(c1 </span><span class="s0">is </span><span class="s1">a)</span>
        <span class="s1">assert_(c2 </span><span class="s0">is </span><span class="s1">b)</span>
        <span class="s1">assert_equal(c1.info</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'inputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'outputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]})</span>

        <span class="s5"># 2 input, 1 output</span>
        <span class="s1">a = np.arange(</span><span class="s3">5.</span><span class="s1">).view(A)</span>
        <span class="s1">b = np.arange(</span><span class="s3">5.</span><span class="s1">).view(A)</span>
        <span class="s1">c = np.add(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">out=a)</span>
        <span class="s1">assert_(c </span><span class="s0">is </span><span class="s1">a)</span>
        <span class="s1">assert_equal(c.info</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'inputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'outputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]})</span>
        <span class="s5"># some tests with a non-ndarray subclass</span>
        <span class="s1">a = np.arange(</span><span class="s3">5.</span><span class="s1">)</span>
        <span class="s1">b = B()</span>
        <span class="s1">assert_(a.__array_ufunc__(np.add</span><span class="s0">, </span><span class="s2">'__call__'</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b) </span><span class="s0">is </span><span class="s1">NotImplemented)</span>
        <span class="s1">assert_(b.__array_ufunc__(np.add</span><span class="s0">, </span><span class="s2">'__call__'</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b) </span><span class="s0">is </span><span class="s1">NotImplemented)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">a = a.view(A)</span>
        <span class="s1">assert_(a.__array_ufunc__(np.add</span><span class="s0">, </span><span class="s2">'__call__'</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b) </span><span class="s0">is </span><span class="s1">NotImplemented)</span>
        <span class="s1">assert_(b.__array_ufunc__(np.add</span><span class="s0">, </span><span class="s2">'__call__'</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b) == </span><span class="s2">&quot;A!&quot;</span><span class="s1">)</span>
        <span class="s1">assert_(np.add(a</span><span class="s0">, </span><span class="s1">b) == </span><span class="s2">&quot;A!&quot;</span><span class="s1">)</span>
        <span class="s5"># regression check for gh-9102 -- tests ufunc.reduce implicitly.</span>
        <span class="s1">d = np.array([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]])</span>
        <span class="s1">a = d.view(A)</span>
        <span class="s1">c = a.any()</span>
        <span class="s1">check = d.any()</span>
        <span class="s1">assert_equal(c</span><span class="s0">, </span><span class="s1">check)</span>
        <span class="s1">assert_(c.info</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'inputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]})</span>
        <span class="s1">c = a.max()</span>
        <span class="s1">check = d.max()</span>
        <span class="s1">assert_equal(c</span><span class="s0">, </span><span class="s1">check)</span>
        <span class="s1">assert_(c.info</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'inputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]})</span>
        <span class="s1">b = np.array(</span><span class="s3">0</span><span class="s1">).view(A)</span>
        <span class="s1">c = a.max(out=b)</span>
        <span class="s1">assert_equal(c</span><span class="s0">, </span><span class="s1">check)</span>
        <span class="s1">assert_(c </span><span class="s0">is </span><span class="s1">b)</span>
        <span class="s1">assert_(c.info</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'inputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'outputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]})</span>
        <span class="s1">check = a.max(axis=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">b = np.zeros_like(check).view(A)</span>
        <span class="s1">c = a.max(axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">out=b)</span>
        <span class="s1">assert_equal(c</span><span class="s0">, </span><span class="s1">check)</span>
        <span class="s1">assert_(c </span><span class="s0">is </span><span class="s1">b)</span>
        <span class="s1">assert_(c.info</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'inputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'outputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]})</span>
        <span class="s5"># simple explicit tests of reduce, accumulate, reduceat</span>
        <span class="s1">check = np.add.reduce(d</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">c = np.add.reduce(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(c</span><span class="s0">, </span><span class="s1">check)</span>
        <span class="s1">assert_(c.info</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'inputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]})</span>
        <span class="s1">b = np.zeros_like(c)</span>
        <span class="s1">c = np.add.reduce(a</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, None, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(c</span><span class="s0">, </span><span class="s1">check)</span>
        <span class="s1">assert_(c </span><span class="s0">is </span><span class="s1">b)</span>
        <span class="s1">assert_(c.info</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'inputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'outputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]})</span>
        <span class="s1">check = np.add.accumulate(d</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">c = np.add.accumulate(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(c</span><span class="s0">, </span><span class="s1">check)</span>
        <span class="s1">assert_(c.info</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'inputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]})</span>
        <span class="s1">b = np.zeros_like(c)</span>
        <span class="s1">c = np.add.accumulate(a</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(c</span><span class="s0">, </span><span class="s1">check)</span>
        <span class="s1">assert_(c </span><span class="s0">is </span><span class="s1">b)</span>
        <span class="s1">assert_(c.info</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'inputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'outputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]})</span>
        <span class="s1">indices = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">check = np.add.reduceat(d</span><span class="s0">, </span><span class="s1">indices</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">c = np.add.reduceat(a</span><span class="s0">, </span><span class="s1">indices</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(c</span><span class="s0">, </span><span class="s1">check)</span>
        <span class="s1">assert_(c.info</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'inputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]})</span>
        <span class="s1">b = np.zeros_like(c)</span>
        <span class="s1">c = np.add.reduceat(a</span><span class="s0">, </span><span class="s1">indices</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, None, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(c</span><span class="s0">, </span><span class="s1">check)</span>
        <span class="s1">assert_(c </span><span class="s0">is </span><span class="s1">b)</span>
        <span class="s1">assert_(c.info</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'inputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'outputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]})</span>
        <span class="s5"># and a few tests for at</span>
        <span class="s1">d = np.array([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]])</span>
        <span class="s1">check = d.copy()</span>
        <span class="s1">a = d.copy().view(A)</span>
        <span class="s1">np.add.at(check</span><span class="s0">, </span><span class="s1">([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">)</span>
        <span class="s1">np.add.at(a</span><span class="s0">, </span><span class="s1">([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">)</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">check)</span>
        <span class="s1">assert_(a.info</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'inputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]})</span>
        <span class="s1">b = np.array(</span><span class="s3">1.</span><span class="s1">).view(A)</span>
        <span class="s1">a = d.copy().view(A)</span>
        <span class="s1">np.add.at(a</span><span class="s0">, </span><span class="s1">([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">check)</span>
        <span class="s1">assert_(a.info</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'inputs'</span><span class="s1">: [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]})</span>


<span class="s0">class </span><span class="s1">TestChoose:</span>
    <span class="s0">def </span><span class="s1">test_mixed(self):</span>
        <span class="s1">c = np.array([</span><span class="s0">True, True</span><span class="s1">])</span>
        <span class="s1">a = np.array([</span><span class="s0">True, True</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.choose(c</span><span class="s0">, </span><span class="s1">(a</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]))</span>


<span class="s0">class </span><span class="s1">TestRationalFunctions:</span>
    <span class="s0">def </span><span class="s1">test_lcm(self):</span>
        <span class="s1">self._test_lcm_inner(np.int16)</span>
        <span class="s1">self._test_lcm_inner(np.uint16)</span>

    <span class="s0">def </span><span class="s1">test_lcm_object(self):</span>
        <span class="s1">self._test_lcm_inner(np.object_)</span>

    <span class="s0">def </span><span class="s1">test_gcd(self):</span>
        <span class="s1">self._test_gcd_inner(np.int16)</span>
        <span class="s1">self._test_lcm_inner(np.uint16)</span>

    <span class="s0">def </span><span class="s1">test_gcd_object(self):</span>
        <span class="s1">self._test_gcd_inner(np.object_)</span>

    <span class="s0">def </span><span class="s1">_test_lcm_inner(self</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s5"># basic use</span>
        <span class="s1">a = np.array([</span><span class="s3">12</span><span class="s0">, </span><span class="s3">120</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">b = np.array([</span><span class="s3">20</span><span class="s0">, </span><span class="s3">200</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">assert_equal(np.lcm(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">60</span><span class="s0">, </span><span class="s3">600</span><span class="s1">])</span>

        <span class="s0">if not </span><span class="s1">issubclass(dtype</span><span class="s0">, </span><span class="s1">np.unsignedinteger):</span>
            <span class="s5"># negatives are ignored</span>
            <span class="s1">a = np.array([</span><span class="s3">12</span><span class="s0">, </span><span class="s1">-</span><span class="s3">12</span><span class="s0">,  </span><span class="s3">12</span><span class="s0">, </span><span class="s1">-</span><span class="s3">12</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">b = np.array([</span><span class="s3">20</span><span class="s0">,  </span><span class="s3">20</span><span class="s0">, </span><span class="s1">-</span><span class="s3">20</span><span class="s0">, </span><span class="s1">-</span><span class="s3">20</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">assert_equal(np.lcm(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">60</span><span class="s1">]*</span><span class="s3">4</span><span class="s1">)</span>

        <span class="s5"># reduce</span>
        <span class="s1">a = np.array([</span><span class="s3">3</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">20</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">assert_equal(np.lcm.reduce([</span><span class="s3">3</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">20</span><span class="s1">])</span><span class="s0">, </span><span class="s3">60</span><span class="s1">)</span>

        <span class="s5"># broadcasting, and a test including 0</span>
        <span class="s1">a = np.arange(</span><span class="s3">6</span><span class="s1">).astype(dtype)</span>
        <span class="s1">b = </span><span class="s3">20</span>
        <span class="s1">assert_equal(np.lcm(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">60</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">_test_gcd_inner(self</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s5"># basic use</span>
        <span class="s1">a = np.array([</span><span class="s3">12</span><span class="s0">, </span><span class="s3">120</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">b = np.array([</span><span class="s3">20</span><span class="s0">, </span><span class="s3">200</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">assert_equal(np.gcd(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">40</span><span class="s1">])</span>

        <span class="s0">if not </span><span class="s1">issubclass(dtype</span><span class="s0">, </span><span class="s1">np.unsignedinteger):</span>
            <span class="s5"># negatives are ignored</span>
            <span class="s1">a = np.array([</span><span class="s3">12</span><span class="s0">, </span><span class="s1">-</span><span class="s3">12</span><span class="s0">,  </span><span class="s3">12</span><span class="s0">, </span><span class="s1">-</span><span class="s3">12</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">b = np.array([</span><span class="s3">20</span><span class="s0">,  </span><span class="s3">20</span><span class="s0">, </span><span class="s1">-</span><span class="s3">20</span><span class="s0">, </span><span class="s1">-</span><span class="s3">20</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">assert_equal(np.gcd(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s1">]*</span><span class="s3">4</span><span class="s1">)</span>

        <span class="s5"># reduce</span>
        <span class="s1">a = np.array([</span><span class="s3">15</span><span class="s0">, </span><span class="s3">25</span><span class="s0">, </span><span class="s3">35</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">assert_equal(np.gcd.reduce(a)</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>

        <span class="s5"># broadcasting, and a test including 0</span>
        <span class="s1">a = np.arange(</span><span class="s3">6</span><span class="s1">).astype(dtype)</span>
        <span class="s1">b = </span><span class="s3">20</span>
        <span class="s1">assert_equal(np.gcd(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">20</span><span class="s0">,  </span><span class="s3">1</span><span class="s0">,  </span><span class="s3">2</span><span class="s0">,  </span><span class="s3">1</span><span class="s0">,  </span><span class="s3">4</span><span class="s0">,  </span><span class="s3">5</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_lcm_overflow(self):</span>
        <span class="s5"># verify that we don't overflow when a*b does overflow</span>
        <span class="s1">big = np.int32(np.iinfo(np.int32).max // </span><span class="s3">11</span><span class="s1">)</span>
        <span class="s1">a = </span><span class="s3">2</span><span class="s1">*big</span>
        <span class="s1">b = </span><span class="s3">5</span><span class="s1">*big</span>
        <span class="s1">assert_equal(np.lcm(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s3">10</span><span class="s1">*big)</span>

    <span class="s0">def </span><span class="s1">test_gcd_overflow(self):</span>
        <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">(np.int32</span><span class="s0">, </span><span class="s1">np.int64):</span>
            <span class="s5"># verify that we don't overflow when taking abs(x)</span>
            <span class="s5"># not relevant for lcm, where the result is unrepresentable anyway</span>
            <span class="s1">a = dtype(np.iinfo(dtype).min)  </span><span class="s5"># negative power of two</span>
            <span class="s1">q = -(a // </span><span class="s3">4</span><span class="s1">)</span>
            <span class="s1">assert_equal(np.gcd(a</span><span class="s0">,  </span><span class="s1">q*</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">q)</span>
            <span class="s1">assert_equal(np.gcd(a</span><span class="s0">, </span><span class="s1">-q*</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">q)</span>

    <span class="s0">def </span><span class="s1">test_decimal(self):</span>
        <span class="s0">from </span><span class="s1">decimal </span><span class="s0">import </span><span class="s1">Decimal</span>
        <span class="s1">a = np.array([</span><span class="s3">1</span><span class="s0">,  </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]) * Decimal(</span><span class="s2">'0.20'</span><span class="s1">)</span>
        <span class="s1">b = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">,  </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]) * Decimal(</span><span class="s2">'0.12'</span><span class="s1">)</span>

        <span class="s1">assert_equal(np.gcd(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s3">4</span><span class="s1">*[Decimal(</span><span class="s2">'0.04'</span><span class="s1">)])</span>
        <span class="s1">assert_equal(np.lcm(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s3">4</span><span class="s1">*[Decimal(</span><span class="s2">'0.60'</span><span class="s1">)])</span>

    <span class="s0">def </span><span class="s1">test_float(self):</span>
        <span class="s5"># not well-defined on float due to rounding errors</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.gcd</span><span class="s0">, </span><span class="s3">0.3</span><span class="s0">, </span><span class="s3">0.4</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.lcm</span><span class="s0">, </span><span class="s3">0.3</span><span class="s0">, </span><span class="s3">0.4</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_builtin_long(self):</span>
        <span class="s5"># sanity check that array coercion is alright for builtin longs</span>
        <span class="s1">assert_equal(np.array(</span><span class="s3">2</span><span class="s1">**</span><span class="s3">200</span><span class="s1">).item()</span><span class="s0">, </span><span class="s3">2</span><span class="s1">**</span><span class="s3">200</span><span class="s1">)</span>

        <span class="s5"># expressed as prime factors</span>
        <span class="s1">a = np.array(</span><span class="s3">2</span><span class="s1">**</span><span class="s3">100 </span><span class="s1">* </span><span class="s3">3</span><span class="s1">**</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">b = np.array([</span><span class="s3">2</span><span class="s1">**</span><span class="s3">100 </span><span class="s1">* </span><span class="s3">5</span><span class="s1">**</span><span class="s3">7</span><span class="s0">, </span><span class="s3">2</span><span class="s1">**</span><span class="s3">50 </span><span class="s1">* </span><span class="s3">3</span><span class="s1">**</span><span class="s3">10</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.gcd(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s1">**</span><span class="s3">100</span><span class="s0">,               </span><span class="s3">2</span><span class="s1">**</span><span class="s3">50 </span><span class="s1">* </span><span class="s3">3</span><span class="s1">**</span><span class="s3">5</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.lcm(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s1">**</span><span class="s3">100 </span><span class="s1">* </span><span class="s3">3</span><span class="s1">**</span><span class="s3">5 </span><span class="s1">* </span><span class="s3">5</span><span class="s1">**</span><span class="s3">7</span><span class="s0">, </span><span class="s3">2</span><span class="s1">**</span><span class="s3">100 </span><span class="s1">* </span><span class="s3">3</span><span class="s1">**</span><span class="s3">10</span><span class="s1">])</span>

        <span class="s1">assert_equal(np.gcd(</span><span class="s3">2</span><span class="s1">**</span><span class="s3">100</span><span class="s0">, </span><span class="s3">3</span><span class="s1">**</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestRoundingFunctions:</span>

    <span class="s0">def </span><span class="s1">test_object_direct(self):</span>
        <span class="s4">&quot;&quot;&quot; test direct implementation of these magic methods &quot;&quot;&quot;</span>
        <span class="s0">class </span><span class="s1">C:</span>
            <span class="s0">def </span><span class="s1">__floor__(self):</span>
                <span class="s0">return </span><span class="s3">1</span>
            <span class="s0">def </span><span class="s1">__ceil__(self):</span>
                <span class="s0">return </span><span class="s3">2</span>
            <span class="s0">def </span><span class="s1">__trunc__(self):</span>
                <span class="s0">return </span><span class="s3">3</span>

        <span class="s1">arr = np.array([C()</span><span class="s0">, </span><span class="s1">C()])</span>
        <span class="s1">assert_equal(np.floor(arr)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.ceil(arr)</span><span class="s0">,  </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.trunc(arr)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_object_indirect(self):</span>
        <span class="s4">&quot;&quot;&quot; test implementations via __float__ &quot;&quot;&quot;</span>
        <span class="s0">class </span><span class="s1">C:</span>
            <span class="s0">def </span><span class="s1">__float__(self):</span>
                <span class="s0">return </span><span class="s1">-</span><span class="s3">2.5</span>

        <span class="s1">arr = np.array([C()</span><span class="s0">, </span><span class="s1">C()])</span>
        <span class="s1">assert_equal(np.floor(arr)</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">3</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.ceil(arr)</span><span class="s0">,  </span><span class="s1">[-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">np.trunc(arr)  </span><span class="s5"># consistent with math.trunc</span>

    <span class="s0">def </span><span class="s1">test_fraction(self):</span>
        <span class="s1">f = Fraction(-</span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.floor(f)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.ceil(f)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.trunc(f)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestComplexFunctions:</span>
    <span class="s1">funcs = [np.arcsin</span><span class="s0">,  </span><span class="s1">np.arccos</span><span class="s0">,  </span><span class="s1">np.arctan</span><span class="s0">, </span><span class="s1">np.arcsinh</span><span class="s0">, </span><span class="s1">np.arccosh</span><span class="s0">,</span>
             <span class="s1">np.arctanh</span><span class="s0">, </span><span class="s1">np.sin</span><span class="s0">,     </span><span class="s1">np.cos</span><span class="s0">,    </span><span class="s1">np.tan</span><span class="s0">,     </span><span class="s1">np.exp</span><span class="s0">,</span>
             <span class="s1">np.exp2</span><span class="s0">,    </span><span class="s1">np.log</span><span class="s0">,     </span><span class="s1">np.sqrt</span><span class="s0">,   </span><span class="s1">np.log10</span><span class="s0">,   </span><span class="s1">np.log2</span><span class="s0">,</span>
             <span class="s1">np.log1p]</span>

    <span class="s0">def </span><span class="s1">test_it(self):</span>
        <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">self.funcs:</span>
            <span class="s0">if </span><span class="s1">f </span><span class="s0">is </span><span class="s1">np.arccosh:</span>
                <span class="s1">x = </span><span class="s3">1.5</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">x = </span><span class="s3">.5</span>
            <span class="s1">fr = f(x)</span>
            <span class="s1">fz = f(complex(x))</span>
            <span class="s1">assert_almost_equal(fz.real</span><span class="s0">, </span><span class="s1">fr</span><span class="s0">, </span><span class="s1">err_msg=</span><span class="s2">'real part %s' </span><span class="s1">% f)</span>
            <span class="s1">assert_almost_equal(fz.imag</span><span class="s0">, </span><span class="s3">0.</span><span class="s0">, </span><span class="s1">err_msg=</span><span class="s2">'imag part %s' </span><span class="s1">% f)</span>

    <span class="s0">def </span><span class="s1">test_precisions_consistent(self):</span>
        <span class="s1">z = </span><span class="s3">1 </span><span class="s1">+ </span><span class="s3">1j</span>
        <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">self.funcs:</span>
            <span class="s1">fcf = f(np.csingle(z))</span>
            <span class="s1">fcd = f(np.cdouble(z))</span>
            <span class="s1">fcl = f(np.clongdouble(z))</span>
            <span class="s1">assert_almost_equal(fcf</span><span class="s0">, </span><span class="s1">fcd</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">6</span><span class="s0">, </span><span class="s1">err_msg=</span><span class="s2">'fch-fcd %s' </span><span class="s1">% f)</span>
            <span class="s1">assert_almost_equal(fcl</span><span class="s0">, </span><span class="s1">fcd</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">15</span><span class="s0">, </span><span class="s1">err_msg=</span><span class="s2">'fch-fcl %s' </span><span class="s1">% f)</span>

    <span class="s0">def </span><span class="s1">test_branch_cuts(self):</span>
        <span class="s5"># check branch cuts and continuity on them</span>
        <span class="s1">_check_branch_cut(np.log</span><span class="s0">,   </span><span class="s1">-</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">_check_branch_cut(np.log2</span><span class="s0">,  </span><span class="s1">-</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">_check_branch_cut(np.log10</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">_check_branch_cut(np.log1p</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">_check_branch_cut(np.sqrt</span><span class="s0">,  </span><span class="s1">-</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, True</span><span class="s1">)</span>

        <span class="s1">_check_branch_cut(np.arcsin</span><span class="s0">, </span><span class="s1">[ -</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">,   </span><span class="s1">[</span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">_check_branch_cut(np.arccos</span><span class="s0">, </span><span class="s1">[ -</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">,   </span><span class="s1">[</span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">_check_branch_cut(np.arctan</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">-</span><span class="s3">2j</span><span class="s0">, </span><span class="s3">2j</span><span class="s1">]</span><span class="s0">,  </span><span class="s1">[</span><span class="s3">1</span><span class="s0">,  </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, True</span><span class="s1">)</span>

        <span class="s1">_check_branch_cut(np.arcsinh</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">-</span><span class="s3">2j</span><span class="s0">,  </span><span class="s3">2j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">,   </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">_check_branch_cut(np.arccosh</span><span class="s0">, </span><span class="s1">[ -</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1j</span><span class="s0">,  </span><span class="s3">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">_check_branch_cut(np.arctanh</span><span class="s0">, </span><span class="s1">[ -</span><span class="s3">2</span><span class="s0">,   </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, True</span><span class="s1">)</span>

        <span class="s5"># check against bogus branch cuts: assert continuity between quadrants</span>
        <span class="s1">_check_branch_cut(np.arcsin</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">-</span><span class="s3">2j</span><span class="s0">, </span><span class="s3">2j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[ </span><span class="s3">1</span><span class="s0">,  </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">_check_branch_cut(np.arccos</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">-</span><span class="s3">2j</span><span class="s0">, </span><span class="s3">2j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[ </span><span class="s3">1</span><span class="s0">,  </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">_check_branch_cut(np.arctan</span><span class="s0">, </span><span class="s1">[ -</span><span class="s3">2</span><span class="s0">,  </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s1">_check_branch_cut(np.arcsinh</span><span class="s0">, </span><span class="s1">[ -</span><span class="s3">2</span><span class="s0">,  </span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">_check_branch_cut(np.arccosh</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">-</span><span class="s3">2j</span><span class="s0">, </span><span class="s3">2j</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">,  </span><span class="s3">1</span><span class="s0">,  </span><span class="s3">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">_check_branch_cut(np.arctanh</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">-</span><span class="s3">2j</span><span class="s0">, </span><span class="s3">2j</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">,  </span><span class="s3">1</span><span class="s0">,  </span><span class="s3">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_branch_cuts_complex64(self):</span>
        <span class="s5"># check branch cuts and continuity on them</span>
        <span class="s1">_check_branch_cut(np.log</span><span class="s0">,   </span><span class="s1">-</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, True, </span><span class="s1">np.complex64)</span>
        <span class="s1">_check_branch_cut(np.log2</span><span class="s0">,  </span><span class="s1">-</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, True, </span><span class="s1">np.complex64)</span>
        <span class="s1">_check_branch_cut(np.log10</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, True, </span><span class="s1">np.complex64)</span>
        <span class="s1">_check_branch_cut(np.log1p</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, True, </span><span class="s1">np.complex64)</span>
        <span class="s1">_check_branch_cut(np.sqrt</span><span class="s0">,  </span><span class="s1">-</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, True, </span><span class="s1">np.complex64)</span>

        <span class="s1">_check_branch_cut(np.arcsin</span><span class="s0">, </span><span class="s1">[ -</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">,   </span><span class="s1">[</span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, True, </span><span class="s1">np.complex64)</span>
        <span class="s1">_check_branch_cut(np.arccos</span><span class="s0">, </span><span class="s1">[ -</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">,   </span><span class="s1">[</span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, True, </span><span class="s1">np.complex64)</span>
        <span class="s1">_check_branch_cut(np.arctan</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">-</span><span class="s3">2j</span><span class="s0">, </span><span class="s3">2j</span><span class="s1">]</span><span class="s0">,  </span><span class="s1">[</span><span class="s3">1</span><span class="s0">,  </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, True, </span><span class="s1">np.complex64)</span>

        <span class="s1">_check_branch_cut(np.arcsinh</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">-</span><span class="s3">2j</span><span class="s0">,  </span><span class="s3">2j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">,   </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, True, </span><span class="s1">np.complex64)</span>
        <span class="s1">_check_branch_cut(np.arccosh</span><span class="s0">, </span><span class="s1">[ -</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1j</span><span class="s0">,  </span><span class="s3">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, True, </span><span class="s1">np.complex64)</span>
        <span class="s1">_check_branch_cut(np.arctanh</span><span class="s0">, </span><span class="s1">[ -</span><span class="s3">2</span><span class="s0">,   </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, True, </span><span class="s1">np.complex64)</span>

        <span class="s5"># check against bogus branch cuts: assert continuity between quadrants</span>
        <span class="s1">_check_branch_cut(np.arcsin</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">-</span><span class="s3">2j</span><span class="s0">, </span><span class="s3">2j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[ </span><span class="s3">1</span><span class="s0">,  </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, False, </span><span class="s1">np.complex64)</span>
        <span class="s1">_check_branch_cut(np.arccos</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">-</span><span class="s3">2j</span><span class="s0">, </span><span class="s3">2j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[ </span><span class="s3">1</span><span class="s0">,  </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, False, </span><span class="s1">np.complex64)</span>
        <span class="s1">_check_branch_cut(np.arctan</span><span class="s0">, </span><span class="s1">[ -</span><span class="s3">2</span><span class="s0">,  </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, False, </span><span class="s1">np.complex64)</span>

        <span class="s1">_check_branch_cut(np.arcsinh</span><span class="s0">, </span><span class="s1">[ -</span><span class="s3">2</span><span class="s0">,  </span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1j</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, False, </span><span class="s1">np.complex64)</span>
        <span class="s1">_check_branch_cut(np.arccosh</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">-</span><span class="s3">2j</span><span class="s0">, </span><span class="s3">2j</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">,  </span><span class="s3">1</span><span class="s0">,  </span><span class="s3">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, False, </span><span class="s1">np.complex64)</span>
        <span class="s1">_check_branch_cut(np.arctanh</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">-</span><span class="s3">2j</span><span class="s0">, </span><span class="s3">2j</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">,  </span><span class="s3">1</span><span class="s0">,  </span><span class="s3">1j</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, False, </span><span class="s1">np.complex64)</span>

    <span class="s0">def </span><span class="s1">test_against_cmath(self):</span>
        <span class="s0">import </span><span class="s1">cmath</span>

        <span class="s1">points = [-</span><span class="s3">1</span><span class="s1">-</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">+</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">+</span><span class="s3">1</span><span class="s1">-</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">+</span><span class="s3">1</span><span class="s1">+</span><span class="s3">1j</span><span class="s1">]</span>
        <span class="s1">name_map = {</span><span class="s2">'arcsin'</span><span class="s1">: </span><span class="s2">'asin'</span><span class="s0">, </span><span class="s2">'arccos'</span><span class="s1">: </span><span class="s2">'acos'</span><span class="s0">, </span><span class="s2">'arctan'</span><span class="s1">: </span><span class="s2">'atan'</span><span class="s0">,</span>
                    <span class="s2">'arcsinh'</span><span class="s1">: </span><span class="s2">'asinh'</span><span class="s0">, </span><span class="s2">'arccosh'</span><span class="s1">: </span><span class="s2">'acosh'</span><span class="s0">, </span><span class="s2">'arctanh'</span><span class="s1">: </span><span class="s2">'atanh'</span><span class="s1">}</span>
        <span class="s1">atol = </span><span class="s3">4</span><span class="s1">*np.finfo(complex).eps</span>
        <span class="s0">for </span><span class="s1">func </span><span class="s0">in </span><span class="s1">self.funcs:</span>
            <span class="s1">fname = func.__name__.split(</span><span class="s2">'.'</span><span class="s1">)[-</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">cname = name_map.get(fname</span><span class="s0">, </span><span class="s1">fname)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">cfunc = getattr(cmath</span><span class="s0">, </span><span class="s1">cname)</span>
            <span class="s0">except </span><span class="s1">AttributeError:</span>
                <span class="s0">continue</span>
            <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">points:</span>
                <span class="s1">a = complex(func(np.complex_(p)))</span>
                <span class="s1">b = cfunc(p)</span>
                <span class="s1">assert_(abs(a - b) &lt; atol</span><span class="s0">, </span><span class="s2">&quot;%s %s: %s; cmath: %s&quot; </span><span class="s1">% (fname</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'dtype'</span><span class="s0">, </span><span class="s1">[np.complex64</span><span class="s0">, </span><span class="s1">np.complex_</span><span class="s0">, </span><span class="s1">np.longcomplex])</span>
    <span class="s0">def </span><span class="s1">test_loss_of_precision(self</span><span class="s0">, </span><span class="s1">dtype):</span>
        <span class="s4">&quot;&quot;&quot;Check loss of precision in complex arc* functions&quot;&quot;&quot;</span>

        <span class="s5"># Check against known-good functions</span>

        <span class="s1">info = np.finfo(dtype)</span>
        <span class="s1">real_dtype = dtype(</span><span class="s3">0.</span><span class="s1">).real.dtype</span>
        <span class="s1">eps = info.eps</span>

        <span class="s0">def </span><span class="s1">check(x</span><span class="s0">, </span><span class="s1">rtol):</span>
            <span class="s1">x = x.astype(real_dtype)</span>

            <span class="s1">z = x.astype(dtype)</span>
            <span class="s1">d = np.absolute(np.arcsinh(x)/np.arcsinh(z).real - </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">assert_(np.all(d &lt; rtol)</span><span class="s0">, </span><span class="s1">(np.argmax(d)</span><span class="s0">, </span><span class="s1">x[np.argmax(d)]</span><span class="s0">, </span><span class="s1">d.max()</span><span class="s0">,</span>
                                      <span class="s2">'arcsinh'</span><span class="s1">))</span>

            <span class="s1">z = (</span><span class="s3">1j</span><span class="s1">*x).astype(dtype)</span>
            <span class="s1">d = np.absolute(np.arcsinh(x)/np.arcsin(z).imag - </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">assert_(np.all(d &lt; rtol)</span><span class="s0">, </span><span class="s1">(np.argmax(d)</span><span class="s0">, </span><span class="s1">x[np.argmax(d)]</span><span class="s0">, </span><span class="s1">d.max()</span><span class="s0">,</span>
                                      <span class="s2">'arcsin'</span><span class="s1">))</span>

            <span class="s1">z = x.astype(dtype)</span>
            <span class="s1">d = np.absolute(np.arctanh(x)/np.arctanh(z).real - </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">assert_(np.all(d &lt; rtol)</span><span class="s0">, </span><span class="s1">(np.argmax(d)</span><span class="s0">, </span><span class="s1">x[np.argmax(d)]</span><span class="s0">, </span><span class="s1">d.max()</span><span class="s0">,</span>
                                      <span class="s2">'arctanh'</span><span class="s1">))</span>

            <span class="s1">z = (</span><span class="s3">1j</span><span class="s1">*x).astype(dtype)</span>
            <span class="s1">d = np.absolute(np.arctanh(x)/np.arctan(z).imag - </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">assert_(np.all(d &lt; rtol)</span><span class="s0">, </span><span class="s1">(np.argmax(d)</span><span class="s0">, </span><span class="s1">x[np.argmax(d)]</span><span class="s0">, </span><span class="s1">d.max()</span><span class="s0">,</span>
                                      <span class="s2">'arctan'</span><span class="s1">))</span>

        <span class="s5"># The switchover was chosen as 1e-3; hence there can be up to</span>
        <span class="s5"># ~eps/1e-3 of relative cancellation error before it</span>

        <span class="s1">x_series = np.logspace(-</span><span class="s3">20</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3.001</span><span class="s0">, </span><span class="s3">200</span><span class="s1">)</span>
        <span class="s1">x_basic = np.logspace(-</span><span class="s3">2.999</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is </span><span class="s1">np.longcomplex:</span>
            <span class="s0">if </span><span class="s1">(platform.machine() == </span><span class="s2">'aarch64' </span><span class="s0">and </span><span class="s1">bad_arcsinh()):</span>
                <span class="s1">pytest.skip(</span><span class="s2">&quot;Trig functions of np.longcomplex values known &quot;</span>
                            <span class="s2">&quot;to be inaccurate on aarch64 for some compilation &quot;</span>
                            <span class="s2">&quot;configurations.&quot;</span><span class="s1">)</span>
            <span class="s5"># It's not guaranteed that the system-provided arc functions</span>
            <span class="s5"># are accurate down to a few epsilons. (Eg. on Linux 64-bit)</span>
            <span class="s5"># So, give more leeway for long complex tests here:</span>
            <span class="s1">check(x_series</span><span class="s0">, </span><span class="s3">50.0</span><span class="s1">*eps)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">check(x_series</span><span class="s0">, </span><span class="s3">2.1</span><span class="s1">*eps)</span>
        <span class="s1">check(x_basic</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">*eps/</span><span class="s3">1e-3</span><span class="s1">)</span>

        <span class="s5"># Check a few points</span>

        <span class="s1">z = np.array([</span><span class="s3">1e-5</span><span class="s1">*(</span><span class="s3">1</span><span class="s1">+</span><span class="s3">1j</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">p = </span><span class="s3">9.999999999333333333e-6 </span><span class="s1">+ </span><span class="s3">1.000000000066666666e-5j</span>
        <span class="s1">d = np.absolute(</span><span class="s3">1</span><span class="s1">-np.arctanh(z)/p)</span>
        <span class="s1">assert_(np.all(d &lt; </span><span class="s3">1e-15</span><span class="s1">))</span>

        <span class="s1">p = </span><span class="s3">1.0000000000333333333e-5 </span><span class="s1">+ </span><span class="s3">9.999999999666666667e-6j</span>
        <span class="s1">d = np.absolute(</span><span class="s3">1</span><span class="s1">-np.arcsinh(z)/p)</span>
        <span class="s1">assert_(np.all(d &lt; </span><span class="s3">1e-15</span><span class="s1">))</span>

        <span class="s1">p = </span><span class="s3">9.999999999333333333e-6j </span><span class="s1">+ </span><span class="s3">1.000000000066666666e-5</span>
        <span class="s1">d = np.absolute(</span><span class="s3">1</span><span class="s1">-np.arctan(z)/p)</span>
        <span class="s1">assert_(np.all(d &lt; </span><span class="s3">1e-15</span><span class="s1">))</span>

        <span class="s1">p = </span><span class="s3">1.0000000000333333333e-5j </span><span class="s1">+ </span><span class="s3">9.999999999666666667e-6</span>
        <span class="s1">d = np.absolute(</span><span class="s3">1</span><span class="s1">-np.arcsin(z)/p)</span>
        <span class="s1">assert_(np.all(d &lt; </span><span class="s3">1e-15</span><span class="s1">))</span>

        <span class="s5"># Check continuity across switchover points</span>

        <span class="s0">def </span><span class="s1">check(func</span><span class="s0">, </span><span class="s1">z0</span><span class="s0">, </span><span class="s1">d=</span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">z0 = np.asarray(z0</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
            <span class="s1">zp = z0 + abs(z0) * d * eps * </span><span class="s3">2</span>
            <span class="s1">zm = z0 - abs(z0) * d * eps * </span><span class="s3">2</span>
            <span class="s1">assert_(np.all(zp != zm)</span><span class="s0">, </span><span class="s1">(zp</span><span class="s0">, </span><span class="s1">zm))</span>

            <span class="s5"># NB: the cancellation error at the switchover is at least eps</span>
            <span class="s1">good = (abs(func(zp) - func(zm)) &lt; </span><span class="s3">2</span><span class="s1">*eps)</span>
            <span class="s1">assert_(np.all(good)</span><span class="s0">, </span><span class="s1">(func</span><span class="s0">, </span><span class="s1">z0[~good]))</span>

        <span class="s0">for </span><span class="s1">func </span><span class="s0">in </span><span class="s1">(np.arcsinh</span><span class="s0">, </span><span class="s1">np.arcsinh</span><span class="s0">, </span><span class="s1">np.arcsin</span><span class="s0">, </span><span class="s1">np.arctanh</span><span class="s0">, </span><span class="s1">np.arctan):</span>
            <span class="s1">pts = [rp+</span><span class="s3">1j</span><span class="s1">*ip </span><span class="s0">for </span><span class="s1">rp </span><span class="s0">in </span><span class="s1">(-</span><span class="s3">1e-3</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1e-3</span><span class="s1">) </span><span class="s0">for </span><span class="s1">ip </span><span class="s0">in</span><span class="s1">(-</span><span class="s3">1e-3</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1e-3</span><span class="s1">)</span>
                   <span class="s0">if </span><span class="s1">rp != </span><span class="s3">0 </span><span class="s0">or </span><span class="s1">ip != </span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">check(func</span><span class="s0">, </span><span class="s1">pts</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">check(func</span><span class="s0">, </span><span class="s1">pts</span><span class="s0">, </span><span class="s3">1j</span><span class="s1">)</span>
            <span class="s1">check(func</span><span class="s0">, </span><span class="s1">pts</span><span class="s0">, </span><span class="s3">1</span><span class="s1">+</span><span class="s3">1j</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestAttributes:</span>
    <span class="s0">def </span><span class="s1">test_attributes(self):</span>
        <span class="s1">add = ncu.add</span>
        <span class="s1">assert_equal(add.__name__</span><span class="s0">, </span><span class="s2">'add'</span><span class="s1">)</span>
        <span class="s1">assert_(add.ntypes &gt;= </span><span class="s3">18</span><span class="s1">)  </span><span class="s5"># don't fail if types added</span>
        <span class="s1">assert_(</span><span class="s2">'ii-&gt;i' </span><span class="s0">in </span><span class="s1">add.types)</span>
        <span class="s1">assert_equal(add.nin</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(add.nout</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(add.identity</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_doc(self):</span>
        <span class="s5"># don't bother checking the long list of kwargs, which are likely to</span>
        <span class="s5"># change</span>
        <span class="s1">assert_(ncu.add.__doc__.startswith(</span>
            <span class="s2">&quot;add(x1, x2, /, out=None, *, where=True&quot;</span><span class="s1">))</span>
        <span class="s1">assert_(ncu.frexp.__doc__.startswith(</span>
            <span class="s2">&quot;frexp(x[, out1, out2], / [, out=(None, None)], *, where=True&quot;</span><span class="s1">))</span>


<span class="s0">class </span><span class="s1">TestSubclass:</span>

    <span class="s0">def </span><span class="s1">test_subclass_op(self):</span>

        <span class="s0">class </span><span class="s1">simple(np.ndarray):</span>
            <span class="s0">def </span><span class="s1">__new__(subtype</span><span class="s0">, </span><span class="s1">shape):</span>
                <span class="s1">self = np.ndarray.__new__(subtype</span><span class="s0">, </span><span class="s1">shape</span><span class="s0">, </span><span class="s1">dtype=object)</span>
                <span class="s1">self.fill(</span><span class="s3">0</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">self</span>

        <span class="s1">a = simple((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))</span>
        <span class="s1">assert_equal(a+a</span><span class="s0">, </span><span class="s1">a)</span>


<span class="s0">class </span><span class="s1">TestFrompyfunc:</span>

    <span class="s0">def </span><span class="s1">test_identity(self):</span>
        <span class="s0">def </span><span class="s1">mul(a</span><span class="s0">, </span><span class="s1">b):</span>
            <span class="s0">return </span><span class="s1">a * b</span>

        <span class="s5"># with identity=value</span>
        <span class="s1">mul_ufunc = np.frompyfunc(mul</span><span class="s0">, </span><span class="s1">nin=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">nout=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">identity=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(mul_ufunc.reduce([</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">])</span><span class="s0">, </span><span class="s3">24</span><span class="s1">)</span>
        <span class="s1">assert_equal(mul_ufunc.reduce(np.ones((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">axis=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(mul_ufunc.reduce([])</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s5"># with identity=None (reorderable)</span>
        <span class="s1">mul_ufunc = np.frompyfunc(mul</span><span class="s0">, </span><span class="s1">nin=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">nout=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">identity=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">assert_equal(mul_ufunc.reduce([</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">])</span><span class="s0">, </span><span class="s3">24</span><span class="s1">)</span>
        <span class="s1">assert_equal(mul_ufunc.reduce(np.ones((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">axis=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, lambda</span><span class="s1">: mul_ufunc.reduce([]))</span>

        <span class="s5"># with no identity (not reorderable)</span>
        <span class="s1">mul_ufunc = np.frompyfunc(mul</span><span class="s0">, </span><span class="s1">nin=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">nout=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(mul_ufunc.reduce([</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">])</span><span class="s0">, </span><span class="s3">24</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, lambda</span><span class="s1">: mul_ufunc.reduce(np.ones((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">axis=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, lambda</span><span class="s1">: mul_ufunc.reduce([]))</span>


<span class="s0">def </span><span class="s1">_check_branch_cut(f</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">re_sign=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">im_sign=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">sig_zero_ok=</span><span class="s0">False,</span>
                      <span class="s1">dtype=complex):</span>
    <span class="s4">&quot;&quot;&quot; 
    Check for a branch cut in a function. 
 
    Assert that `x0` lies on a branch cut of function `f` and `f` is 
    continuous from the direction `dx`. 
 
    Parameters 
    ---------- 
    f : func 
        Function to check 
    x0 : array-like 
        Point on branch cut 
    dx : array-like 
        Direction to check continuity in 
    re_sign, im_sign : {1, -1} 
        Change of sign of the real or imaginary part expected 
    sig_zero_ok : bool 
        Whether to check if the branch cut respects signed zero (if applicable) 
    dtype : dtype 
        Dtype to check (should be complex) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x0 = np.atleast_1d(x0).astype(dtype)</span>
    <span class="s1">dx = np.atleast_1d(dx).astype(dtype)</span>

    <span class="s0">if </span><span class="s1">np.dtype(dtype).char == </span><span class="s2">'F'</span><span class="s1">:</span>
        <span class="s1">scale = np.finfo(dtype).eps * </span><span class="s3">1e2</span>
        <span class="s1">atol = np.float32(</span><span class="s3">1e-2</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">scale = np.finfo(dtype).eps * </span><span class="s3">1e3</span>
        <span class="s1">atol = </span><span class="s3">1e-4</span>

    <span class="s1">y0 = f(x0)</span>
    <span class="s1">yp = f(x0 + dx*scale*np.absolute(x0)/np.absolute(dx))</span>
    <span class="s1">ym = f(x0 - dx*scale*np.absolute(x0)/np.absolute(dx))</span>

    <span class="s1">assert_(np.all(np.absolute(y0.real - yp.real) &lt; atol)</span><span class="s0">, </span><span class="s1">(y0</span><span class="s0">, </span><span class="s1">yp))</span>
    <span class="s1">assert_(np.all(np.absolute(y0.imag - yp.imag) &lt; atol)</span><span class="s0">, </span><span class="s1">(y0</span><span class="s0">, </span><span class="s1">yp))</span>
    <span class="s1">assert_(np.all(np.absolute(y0.real - ym.real*re_sign) &lt; atol)</span><span class="s0">, </span><span class="s1">(y0</span><span class="s0">, </span><span class="s1">ym))</span>
    <span class="s1">assert_(np.all(np.absolute(y0.imag - ym.imag*im_sign) &lt; atol)</span><span class="s0">, </span><span class="s1">(y0</span><span class="s0">, </span><span class="s1">ym))</span>

    <span class="s0">if </span><span class="s1">sig_zero_ok:</span>
        <span class="s5"># check that signed zeros also work as a displacement</span>
        <span class="s1">jr = (x0.real == </span><span class="s3">0</span><span class="s1">) &amp; (dx.real != </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">ji = (x0.imag == </span><span class="s3">0</span><span class="s1">) &amp; (dx.imag != </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">np.any(jr):</span>
            <span class="s1">x = x0[jr]</span>
            <span class="s1">x.real = np.NZERO</span>
            <span class="s1">ym = f(x)</span>
            <span class="s1">assert_(np.all(np.absolute(y0[jr].real - ym.real*re_sign) &lt; atol)</span><span class="s0">, </span><span class="s1">(y0[jr]</span><span class="s0">, </span><span class="s1">ym))</span>
            <span class="s1">assert_(np.all(np.absolute(y0[jr].imag - ym.imag*im_sign) &lt; atol)</span><span class="s0">, </span><span class="s1">(y0[jr]</span><span class="s0">, </span><span class="s1">ym))</span>

        <span class="s0">if </span><span class="s1">np.any(ji):</span>
            <span class="s1">x = x0[ji]</span>
            <span class="s1">x.imag = np.NZERO</span>
            <span class="s1">ym = f(x)</span>
            <span class="s1">assert_(np.all(np.absolute(y0[ji].real - ym.real*re_sign) &lt; atol)</span><span class="s0">, </span><span class="s1">(y0[ji]</span><span class="s0">, </span><span class="s1">ym))</span>
            <span class="s1">assert_(np.all(np.absolute(y0[ji].imag - ym.imag*im_sign) &lt; atol)</span><span class="s0">, </span><span class="s1">(y0[ji]</span><span class="s0">, </span><span class="s1">ym))</span>

<span class="s0">def </span><span class="s1">test_copysign():</span>
    <span class="s1">assert_(np.copysign(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">) == -</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
        <span class="s1">assert_(</span><span class="s3">1 </span><span class="s1">/ np.copysign(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">) &lt; </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_(</span><span class="s3">1 </span><span class="s1">/ np.copysign(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">) &gt; </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_(np.signbit(np.copysign(np.nan</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)))</span>
    <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">np.signbit(np.copysign(np.nan</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)))</span>

<span class="s0">def </span><span class="s1">_test_nextafter(t):</span>
    <span class="s1">one = t(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">two = t(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">zero = t(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">eps = np.finfo(t).eps</span>
    <span class="s1">assert_(np.nextafter(one</span><span class="s0">, </span><span class="s1">two) - one == eps)</span>
    <span class="s1">assert_(np.nextafter(one</span><span class="s0">, </span><span class="s1">zero) - one &lt; </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_(np.isnan(np.nextafter(np.nan</span><span class="s0">, </span><span class="s1">one)))</span>
    <span class="s1">assert_(np.isnan(np.nextafter(one</span><span class="s0">, </span><span class="s1">np.nan)))</span>
    <span class="s1">assert_(np.nextafter(one</span><span class="s0">, </span><span class="s1">one) == one)</span>

<span class="s0">def </span><span class="s1">test_nextafter():</span>
    <span class="s0">return </span><span class="s1">_test_nextafter(np.float64)</span>


<span class="s0">def </span><span class="s1">test_nextafterf():</span>
    <span class="s0">return </span><span class="s1">_test_nextafter(np.float32)</span>


<span class="s1">@pytest.mark.skipif(np.finfo(np.double) == np.finfo(np.longdouble)</span><span class="s0">,</span>
                    <span class="s1">reason=</span><span class="s2">&quot;long double is same as double&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.xfail(condition=platform.machine().startswith(</span><span class="s2">&quot;ppc64&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">reason=</span><span class="s2">&quot;IBM double double&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_nextafterl():</span>
    <span class="s0">return </span><span class="s1">_test_nextafter(np.longdouble)</span>


<span class="s0">def </span><span class="s1">test_nextafter_0():</span>
    <span class="s0">for </span><span class="s1">t</span><span class="s0">, </span><span class="s1">direction </span><span class="s0">in </span><span class="s1">itertools.product(np.sctypes[</span><span class="s2">'float'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)):</span>
        <span class="s5"># The value of tiny for double double is NaN, so we need to pass the</span>
        <span class="s5"># assert</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(UserWarning)</span>
            <span class="s0">if not </span><span class="s1">np.isnan(np.finfo(t).tiny):</span>
                <span class="s1">tiny = np.finfo(t).tiny</span>
                <span class="s1">assert_(</span>
                    <span class="s3">0. </span><span class="s1">&lt; direction * np.nextafter(t(</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">t(direction)) &lt; tiny)</span>
        <span class="s1">assert_equal(np.nextafter(t(</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">t(direction)) / t(</span><span class="s3">2.1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">direction * </span><span class="s3">0.0</span><span class="s1">)</span>

<span class="s0">def </span><span class="s1">_test_spacing(t):</span>
    <span class="s1">one = t(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">eps = np.finfo(t).eps</span>
    <span class="s1">nan = t(np.nan)</span>
    <span class="s1">inf = t(np.inf)</span>
    <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'ignore'</span><span class="s1">):</span>
        <span class="s1">assert_(np.spacing(one) == eps)</span>
        <span class="s1">assert_(np.isnan(np.spacing(nan)))</span>
        <span class="s1">assert_(np.isnan(np.spacing(inf)))</span>
        <span class="s1">assert_(np.isnan(np.spacing(-inf)))</span>
        <span class="s1">assert_(np.spacing(t(</span><span class="s3">1e30</span><span class="s1">)) != </span><span class="s3">0</span><span class="s1">)</span>

<span class="s0">def </span><span class="s1">test_spacing():</span>
    <span class="s0">return </span><span class="s1">_test_spacing(np.float64)</span>

<span class="s0">def </span><span class="s1">test_spacingf():</span>
    <span class="s0">return </span><span class="s1">_test_spacing(np.float32)</span>


<span class="s1">@pytest.mark.skipif(np.finfo(np.double) == np.finfo(np.longdouble)</span><span class="s0">,</span>
                    <span class="s1">reason=</span><span class="s2">&quot;long double is same as double&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.xfail(condition=platform.machine().startswith(</span><span class="s2">&quot;ppc64&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">reason=</span><span class="s2">&quot;IBM double double&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_spacingl():</span>
    <span class="s0">return </span><span class="s1">_test_spacing(np.longdouble)</span>

<span class="s0">def </span><span class="s1">test_spacing_gfortran():</span>
    <span class="s5"># Reference from this fortran file, built with gfortran 4.3.3 on linux</span>
    <span class="s5"># 32bits:</span>
    <span class="s5">#       PROGRAM test_spacing</span>
    <span class="s5">#        INTEGER, PARAMETER :: SGL = SELECTED_REAL_KIND(p=6, r=37)</span>
    <span class="s5">#        INTEGER, PARAMETER :: DBL = SELECTED_REAL_KIND(p=13, r=200)</span>
    <span class="s5">#</span>
    <span class="s5">#        WRITE(*,*) spacing(0.00001_DBL)</span>
    <span class="s5">#        WRITE(*,*) spacing(1.0_DBL)</span>
    <span class="s5">#        WRITE(*,*) spacing(1000._DBL)</span>
    <span class="s5">#        WRITE(*,*) spacing(10500._DBL)</span>
    <span class="s5">#</span>
    <span class="s5">#        WRITE(*,*) spacing(0.00001_SGL)</span>
    <span class="s5">#        WRITE(*,*) spacing(1.0_SGL)</span>
    <span class="s5">#        WRITE(*,*) spacing(1000._SGL)</span>
    <span class="s5">#        WRITE(*,*) spacing(10500._SGL)</span>
    <span class="s5">#       END PROGRAM</span>
    <span class="s1">ref = {np.float64: [</span><span class="s3">1.69406589450860068E-021</span><span class="s0">,</span>
                        <span class="s3">2.22044604925031308E-016</span><span class="s0">,</span>
                        <span class="s3">1.13686837721616030E-013</span><span class="s0">,</span>
                        <span class="s3">1.81898940354585648E-012</span><span class="s1">]</span><span class="s0">,</span>
           <span class="s1">np.float32: [</span><span class="s3">9.09494702E-13</span><span class="s0">,</span>
                        <span class="s3">1.19209290E-07</span><span class="s0">,</span>
                        <span class="s3">6.10351563E-05</span><span class="s0">,</span>
                        <span class="s3">9.76562500E-04</span><span class="s1">]}</span>

    <span class="s0">for </span><span class="s1">dt</span><span class="s0">, </span><span class="s1">dec_ </span><span class="s0">in </span><span class="s1">zip([np.float32</span><span class="s0">, </span><span class="s1">np.float64]</span><span class="s0">, </span><span class="s1">(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)):</span>
        <span class="s1">x = np.array([</span><span class="s3">1e-5</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1000</span><span class="s0">, </span><span class="s3">10500</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
        <span class="s1">assert_array_almost_equal(np.spacing(x)</span><span class="s0">, </span><span class="s1">ref[dt]</span><span class="s0">, </span><span class="s1">decimal=dec_)</span>

<span class="s0">def </span><span class="s1">test_nextafter_vs_spacing():</span>
    <span class="s5"># XXX: spacing does not handle long double yet</span>
    <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">[np.float32</span><span class="s0">, </span><span class="s1">np.float64]:</span>
        <span class="s0">for </span><span class="s1">_f </span><span class="s0">in </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1e-5</span><span class="s0">, </span><span class="s3">1000</span><span class="s1">]:</span>
            <span class="s1">f = t(_f)</span>
            <span class="s1">f1 = t(_f + </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">assert_(np.nextafter(f</span><span class="s0">, </span><span class="s1">f1) - f == np.spacing(f))</span>

<span class="s0">def </span><span class="s1">test_pos_nan():</span>
    <span class="s4">&quot;&quot;&quot;Check np.nan is a positive nan.&quot;&quot;&quot;</span>
    <span class="s1">assert_(np.signbit(np.nan) == </span><span class="s3">0</span><span class="s1">)</span>

<span class="s0">def </span><span class="s1">test_reduceat():</span>
    <span class="s4">&quot;&quot;&quot;Test bug in reduceat when structured arrays are not copied.&quot;&quot;&quot;</span>
    <span class="s1">db = np.dtype([(</span><span class="s2">'name'</span><span class="s0">, </span><span class="s2">'S11'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">'time'</span><span class="s0">, </span><span class="s1">np.int64)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">'value'</span><span class="s0">, </span><span class="s1">np.float32)])</span>
    <span class="s1">a = np.empty([</span><span class="s3">100</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=db)</span>
    <span class="s1">a[</span><span class="s2">'name'</span><span class="s1">] = </span><span class="s2">'Simple'</span>
    <span class="s1">a[</span><span class="s2">'time'</span><span class="s1">] = </span><span class="s3">10</span>
    <span class="s1">a[</span><span class="s2">'value'</span><span class="s1">] = </span><span class="s3">100</span>
    <span class="s1">indx = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">15</span><span class="s0">, </span><span class="s3">25</span><span class="s1">]</span>

    <span class="s1">h2 = []</span>
    <span class="s1">val1 = indx[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">for </span><span class="s1">val2 </span><span class="s0">in </span><span class="s1">indx[</span><span class="s3">1</span><span class="s1">:]:</span>
        <span class="s1">h2.append(np.add.reduce(a[</span><span class="s2">'value'</span><span class="s1">][val1:val2]))</span>
        <span class="s1">val1 = val2</span>
    <span class="s1">h2.append(np.add.reduce(a[</span><span class="s2">'value'</span><span class="s1">][val1:]))</span>
    <span class="s1">h2 = np.array(h2)</span>

    <span class="s5"># test buffered -- this should work</span>
    <span class="s1">h1 = np.add.reduceat(a[</span><span class="s2">'value'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">indx)</span>
    <span class="s1">assert_array_almost_equal(h1</span><span class="s0">, </span><span class="s1">h2)</span>

    <span class="s5"># This is when the error occurs.</span>
    <span class="s5"># test no buffer</span>
    <span class="s1">np.setbufsize(</span><span class="s3">32</span><span class="s1">)</span>
    <span class="s1">h1 = np.add.reduceat(a[</span><span class="s2">'value'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">indx)</span>
    <span class="s1">np.setbufsize(np.UFUNC_BUFSIZE_DEFAULT)</span>
    <span class="s1">assert_array_almost_equal(h1</span><span class="s0">, </span><span class="s1">h2)</span>

<span class="s0">def </span><span class="s1">test_reduceat_empty():</span>
    <span class="s4">&quot;&quot;&quot;Reduceat should work with empty arrays&quot;&quot;&quot;</span>
    <span class="s1">indices = np.array([]</span><span class="s0">, </span><span class="s2">'i4'</span><span class="s1">)</span>
    <span class="s1">x = np.array([]</span><span class="s0">, </span><span class="s2">'f8'</span><span class="s1">)</span>
    <span class="s1">result = np.add.reduceat(x</span><span class="s0">, </span><span class="s1">indices)</span>
    <span class="s1">assert_equal(result.dtype</span><span class="s0">, </span><span class="s1">x.dtype)</span>
    <span class="s1">assert_equal(result.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">,</span><span class="s1">))</span>
    <span class="s5"># Another case with a slightly different zero-sized shape</span>
    <span class="s1">x = np.ones((</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
    <span class="s1">result = np.add.reduceat(x</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(result.dtype</span><span class="s0">, </span><span class="s1">x.dtype)</span>
    <span class="s1">assert_equal(result.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
    <span class="s1">result = np.add.reduceat(x</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(result.dtype</span><span class="s0">, </span><span class="s1">x.dtype)</span>
    <span class="s1">assert_equal(result.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

<span class="s0">def </span><span class="s1">test_complex_nan_comparisons():</span>
    <span class="s1">nans = [complex(np.nan</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">, </span><span class="s1">complex(np.nan</span><span class="s0">, </span><span class="s1">np.nan)]</span>
    <span class="s1">fins = [complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">complex(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">complex(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">complex(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)]</span>

    <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'ignore'</span><span class="s1">):</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">nans + fins:</span>
            <span class="s1">x = np.array([x])</span>
            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">nans + fins:</span>
                <span class="s1">y = np.array([y])</span>

                <span class="s0">if </span><span class="s1">np.isfinite(x) </span><span class="s0">and </span><span class="s1">np.isfinite(y):</span>
                    <span class="s0">continue</span>

                <span class="s1">assert_equal(x &lt; y</span><span class="s0">, False, </span><span class="s1">err_msg=</span><span class="s2">&quot;%r &lt; %r&quot; </span><span class="s1">% (x</span><span class="s0">, </span><span class="s1">y))</span>
                <span class="s1">assert_equal(x &gt; y</span><span class="s0">, False, </span><span class="s1">err_msg=</span><span class="s2">&quot;%r &gt; %r&quot; </span><span class="s1">% (x</span><span class="s0">, </span><span class="s1">y))</span>
                <span class="s1">assert_equal(x &lt;= y</span><span class="s0">, False, </span><span class="s1">err_msg=</span><span class="s2">&quot;%r &lt;= %r&quot; </span><span class="s1">% (x</span><span class="s0">, </span><span class="s1">y))</span>
                <span class="s1">assert_equal(x &gt;= y</span><span class="s0">, False, </span><span class="s1">err_msg=</span><span class="s2">&quot;%r &gt;= %r&quot; </span><span class="s1">% (x</span><span class="s0">, </span><span class="s1">y))</span>
                <span class="s1">assert_equal(x == y</span><span class="s0">, False, </span><span class="s1">err_msg=</span><span class="s2">&quot;%r == %r&quot; </span><span class="s1">% (x</span><span class="s0">, </span><span class="s1">y))</span>


<span class="s0">def </span><span class="s1">test_rint_big_int():</span>
    <span class="s5"># np.rint bug for large integer values on Windows 32-bit and MKL</span>
    <span class="s5"># https://github.com/numpy/numpy/issues/6685</span>
    <span class="s1">val = </span><span class="s3">4607998452777363968</span>
    <span class="s5"># This is exactly representable in floating point</span>
    <span class="s1">assert_equal(val</span><span class="s0">, </span><span class="s1">int(float(val)))</span>
    <span class="s5"># Rint should not change the value</span>
    <span class="s1">assert_equal(val</span><span class="s0">, </span><span class="s1">np.rint(val))</span>

<span class="s1">@pytest.mark.parametrize(</span><span class="s2">'ftype'</span><span class="s0">, </span><span class="s1">[np.float32</span><span class="s0">, </span><span class="s1">np.float64])</span>
<span class="s0">def </span><span class="s1">test_memoverlap_accumulate(ftype):</span>
    <span class="s5"># Reproduces bug https://github.com/numpy/numpy/issues/15597</span>
    <span class="s1">arr = np.array([</span><span class="s3">0.61</span><span class="s0">, </span><span class="s3">0.60</span><span class="s0">, </span><span class="s3">0.77</span><span class="s0">, </span><span class="s3">0.41</span><span class="s0">, </span><span class="s3">0.19</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=ftype)</span>
    <span class="s1">out_max = np.array([</span><span class="s3">0.61</span><span class="s0">, </span><span class="s3">0.61</span><span class="s0">, </span><span class="s3">0.77</span><span class="s0">, </span><span class="s3">0.77</span><span class="s0">, </span><span class="s3">0.77</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=ftype)</span>
    <span class="s1">out_min = np.array([</span><span class="s3">0.61</span><span class="s0">, </span><span class="s3">0.60</span><span class="s0">, </span><span class="s3">0.60</span><span class="s0">, </span><span class="s3">0.41</span><span class="s0">, </span><span class="s3">0.19</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=ftype)</span>
    <span class="s1">assert_equal(np.maximum.accumulate(arr)</span><span class="s0">, </span><span class="s1">out_max)</span>
    <span class="s1">assert_equal(np.minimum.accumulate(arr)</span><span class="s0">, </span><span class="s1">out_min)</span>

<span class="s0">def </span><span class="s1">test_signaling_nan_exceptions():</span>
    <span class="s0">with </span><span class="s1">assert_no_warnings():</span>
        <span class="s1">a = np.ndarray(shape=()</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'float32'</span><span class="s0">, </span><span class="s1">buffer=</span><span class="s6">b'</span><span class="s0">\x00\xe0\xbf\xff</span><span class="s6">'</span><span class="s1">)</span>
        <span class="s1">np.isnan(a)</span>

<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;arr&quot;</span><span class="s0">, </span><span class="s1">[</span>
    <span class="s1">np.arange(</span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">np.matrix([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">np.matrix([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]])</span><span class="s0">,</span>
    <span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_outer_subclass_preserve(arr):</span>
    <span class="s5"># for gh-8661</span>
    <span class="s0">class </span><span class="s1">foo(np.ndarray): </span><span class="s0">pass</span>
    <span class="s1">actual = np.multiply.outer(arr.view(foo)</span><span class="s0">, </span><span class="s1">arr.view(foo))</span>
    <span class="s0">assert </span><span class="s1">actual.__class__.__name__ == </span><span class="s2">'foo'</span>

<span class="s0">def </span><span class="s1">test_outer_bad_subclass():</span>
    <span class="s0">class </span><span class="s1">BadArr1(np.ndarray):</span>
        <span class="s0">def </span><span class="s1">__array_finalize__(self</span><span class="s0">, </span><span class="s1">obj):</span>
            <span class="s5"># The outer call reshapes to 3 dims, try to do a bad reshape.</span>
            <span class="s0">if </span><span class="s1">self.ndim == </span><span class="s3">3</span><span class="s1">:</span>
                <span class="s1">self.shape = self.shape + (</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__array_prepare__(self</span><span class="s0">, </span><span class="s1">obj</span><span class="s0">, </span><span class="s1">context=</span><span class="s0">None</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">obj</span>

    <span class="s0">class </span><span class="s1">BadArr2(np.ndarray):</span>
        <span class="s0">def </span><span class="s1">__array_finalize__(self</span><span class="s0">, </span><span class="s1">obj):</span>
            <span class="s0">if </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">BadArr2):</span>
                <span class="s5"># outer inserts 1-sized dims. In that case disturb them.</span>
                <span class="s0">if </span><span class="s1">self.shape[-</span><span class="s3">1</span><span class="s1">] == </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s1">self.shape = self.shape[::-</span><span class="s3">1</span><span class="s1">]</span>

        <span class="s0">def </span><span class="s1">__array_prepare__(self</span><span class="s0">, </span><span class="s1">obj</span><span class="s0">, </span><span class="s1">context=</span><span class="s0">None</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">obj</span>

    <span class="s0">for </span><span class="s1">cls </span><span class="s0">in </span><span class="s1">[BadArr1</span><span class="s0">, </span><span class="s1">BadArr2]:</span>
        <span class="s1">arr = np.ones((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)).view(cls)</span>
        <span class="s0">with </span><span class="s1">assert_raises(TypeError) </span><span class="s0">as </span><span class="s1">a:</span>
            <span class="s5"># The first array gets reshaped (not the second one)</span>
            <span class="s1">np.add.outer(arr</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>

        <span class="s5"># This actually works, since we only see the reshaping error:</span>
        <span class="s1">arr = np.ones((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)).view(cls)</span>
        <span class="s0">assert </span><span class="s1">type(np.add.outer([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">arr)) </span><span class="s0">is </span><span class="s1">cls</span>

<span class="s0">def </span><span class="s1">test_outer_exceeds_maxdims():</span>
    <span class="s1">deep = np.ones((</span><span class="s3">1</span><span class="s0">,</span><span class="s1">) * </span><span class="s3">17</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
        <span class="s1">np.add.outer(deep</span><span class="s0">, </span><span class="s1">deep)</span>

<span class="s0">def </span><span class="s1">test_bad_legacy_ufunc_silent_errors():</span>
    <span class="s5"># legacy ufuncs can't report errors and NumPy can't check if the GIL</span>
    <span class="s5"># is released.  So NumPy has to check after the GIL is released just to</span>
    <span class="s5"># cover all bases.  `np.power` uses/used to use this.</span>
    <span class="s1">arr = np.arange(</span><span class="s3">3</span><span class="s1">).astype(np.float64)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">r&quot;How unexpected :\)!&quot;</span><span class="s1">):</span>
        <span class="s1">ncu_tests.always_error(arr</span><span class="s0">, </span><span class="s1">arr)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">r&quot;How unexpected :\)!&quot;</span><span class="s1">):</span>
        <span class="s5"># not contiguous means the fast-path cannot be taken</span>
        <span class="s1">non_contig = arr.repeat(</span><span class="s3">20</span><span class="s1">).reshape(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)[:</span><span class="s0">, </span><span class="s1">::</span><span class="s3">2</span><span class="s1">]</span>
        <span class="s1">ncu_tests.always_error(non_contig</span><span class="s0">, </span><span class="s1">arr)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">r&quot;How unexpected :\)!&quot;</span><span class="s1">):</span>
        <span class="s1">ncu_tests.always_error.outer(arr</span><span class="s0">, </span><span class="s1">arr)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">r&quot;How unexpected :\)!&quot;</span><span class="s1">):</span>
        <span class="s1">ncu_tests.always_error.reduce(arr)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">r&quot;How unexpected :\)!&quot;</span><span class="s1">):</span>
        <span class="s1">ncu_tests.always_error.reduceat(arr</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">r&quot;How unexpected :\)!&quot;</span><span class="s1">):</span>
        <span class="s1">ncu_tests.always_error.accumulate(arr)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">r&quot;How unexpected :\)!&quot;</span><span class="s1">):</span>
        <span class="s1">ncu_tests.always_error.at(arr</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">arr)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">'x1'</span><span class="s0">, </span><span class="s1">[np.arange(</span><span class="s3">3.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">]])</span>
<span class="s0">def </span><span class="s1">test_bad_legacy_gufunc_silent_errors(x1):</span>
    <span class="s5"># Verify that an exception raised in a gufunc loop propagates correctly.</span>
    <span class="s5"># The signature of always_error_gufunc is '(i),()-&gt;()'.</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">r&quot;How unexpected :\)!&quot;</span><span class="s1">):</span>
        <span class="s1">ncu_tests.always_error_gufunc(x1</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">)</span>
</pre>
</body>
</html>