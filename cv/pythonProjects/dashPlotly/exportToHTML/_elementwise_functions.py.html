<html>
<head>
<title>_elementwise_functions.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_elementwise_functions.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">._dtypes </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">_boolean_dtypes</span><span class="s0">,</span>
    <span class="s1">_floating_dtypes</span><span class="s0">,</span>
    <span class="s1">_integer_dtypes</span><span class="s0">,</span>
    <span class="s1">_integer_or_boolean_dtypes</span><span class="s0">,</span>
    <span class="s1">_numeric_dtypes</span><span class="s0">,</span>
    <span class="s1">_result_type</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">._array_object </span><span class="s0">import </span><span class="s1">Array</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>


<span class="s0">def </span><span class="s1">abs(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.abs &lt;numpy.abs&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in abs&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.abs(x._array))</span>


<span class="s4"># Note: the function name is different here</span>
<span class="s0">def </span><span class="s1">acos(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.arccos &lt;numpy.arccos&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in acos&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.arccos(x._array))</span>


<span class="s4"># Note: the function name is different here</span>
<span class="s0">def </span><span class="s1">acosh(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.arccosh &lt;numpy.arccosh&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in acosh&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.arccosh(x._array))</span>


<span class="s0">def </span><span class="s1">add(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.add &lt;numpy.add&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in add&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.add(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s4"># Note: the function name is different here</span>
<span class="s0">def </span><span class="s1">asin(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.arcsin &lt;numpy.arcsin&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in asin&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.arcsin(x._array))</span>


<span class="s4"># Note: the function name is different here</span>
<span class="s0">def </span><span class="s1">asinh(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.arcsinh &lt;numpy.arcsinh&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in asinh&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.arcsinh(x._array))</span>


<span class="s4"># Note: the function name is different here</span>
<span class="s0">def </span><span class="s1">atan(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.arctan &lt;numpy.arctan&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in atan&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.arctan(x._array))</span>


<span class="s4"># Note: the function name is different here</span>
<span class="s0">def </span><span class="s1">atan2(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.arctan2 &lt;numpy.arctan2&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in atan2&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.arctan2(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s4"># Note: the function name is different here</span>
<span class="s0">def </span><span class="s1">atanh(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.arctanh &lt;numpy.arctanh&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in atanh&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.arctanh(x._array))</span>


<span class="s0">def </span><span class="s1">bitwise_and(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.bitwise_and &lt;numpy.bitwise_and&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_integer_or_boolean_dtypes</span>
        <span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_integer_or_boolean_dtypes</span>
    <span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only integer or boolean dtypes are allowed in bitwise_and&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.bitwise_and(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s4"># Note: the function name is different here</span>
<span class="s0">def </span><span class="s1">bitwise_left_shift(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.left_shift &lt;numpy.left_shift&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_integer_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_integer_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only integer dtypes are allowed in bitwise_left_shift&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s4"># Note: bitwise_left_shift is only defined for x2 nonnegative.</span>
    <span class="s0">if </span><span class="s1">np.any(x2._array &lt; </span><span class="s5">0</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;bitwise_left_shift(x1, x2) is only defined for x2 &gt;= 0&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.left_shift(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s4"># Note: the function name is different here</span>
<span class="s0">def </span><span class="s1">bitwise_invert(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.invert &lt;numpy.invert&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_integer_or_boolean_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only integer or boolean dtypes are allowed in bitwise_invert&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.invert(x._array))</span>


<span class="s0">def </span><span class="s1">bitwise_or(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.bitwise_or &lt;numpy.bitwise_or&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_integer_or_boolean_dtypes</span>
        <span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_integer_or_boolean_dtypes</span>
    <span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only integer or boolean dtypes are allowed in bitwise_or&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.bitwise_or(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s4"># Note: the function name is different here</span>
<span class="s0">def </span><span class="s1">bitwise_right_shift(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.right_shift &lt;numpy.right_shift&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_integer_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_integer_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only integer dtypes are allowed in bitwise_right_shift&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s4"># Note: bitwise_right_shift is only defined for x2 nonnegative.</span>
    <span class="s0">if </span><span class="s1">np.any(x2._array &lt; </span><span class="s5">0</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;bitwise_right_shift(x1, x2) is only defined for x2 &gt;= 0&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.right_shift(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s0">def </span><span class="s1">bitwise_xor(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.bitwise_xor &lt;numpy.bitwise_xor&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_integer_or_boolean_dtypes</span>
        <span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_integer_or_boolean_dtypes</span>
    <span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only integer or boolean dtypes are allowed in bitwise_xor&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.bitwise_xor(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s0">def </span><span class="s1">ceil(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.ceil &lt;numpy.ceil&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in ceil&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">in </span><span class="s1">_integer_dtypes:</span>
        <span class="s4"># Note: The return dtype of ceil is the same as the input</span>
        <span class="s0">return </span><span class="s1">x</span>
    <span class="s0">return </span><span class="s1">Array._new(np.ceil(x._array))</span>


<span class="s0">def </span><span class="s1">cos(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.cos &lt;numpy.cos&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in cos&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.cos(x._array))</span>


<span class="s0">def </span><span class="s1">cosh(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.cosh &lt;numpy.cosh&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in cosh&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.cosh(x._array))</span>


<span class="s0">def </span><span class="s1">divide(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.divide &lt;numpy.divide&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in divide&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.divide(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s0">def </span><span class="s1">equal(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.equal &lt;numpy.equal&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.equal(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s0">def </span><span class="s1">exp(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.exp &lt;numpy.exp&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in exp&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.exp(x._array))</span>


<span class="s0">def </span><span class="s1">expm1(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.expm1 &lt;numpy.expm1&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in expm1&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.expm1(x._array))</span>


<span class="s0">def </span><span class="s1">floor(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.floor &lt;numpy.floor&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in floor&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">in </span><span class="s1">_integer_dtypes:</span>
        <span class="s4"># Note: The return dtype of floor is the same as the input</span>
        <span class="s0">return </span><span class="s1">x</span>
    <span class="s0">return </span><span class="s1">Array._new(np.floor(x._array))</span>


<span class="s0">def </span><span class="s1">floor_divide(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.floor_divide &lt;numpy.floor_divide&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in floor_divide&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.floor_divide(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s0">def </span><span class="s1">greater(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.greater &lt;numpy.greater&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in greater&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.greater(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s0">def </span><span class="s1">greater_equal(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.greater_equal &lt;numpy.greater_equal&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in greater_equal&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.greater_equal(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s0">def </span><span class="s1">isfinite(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.isfinite &lt;numpy.isfinite&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in isfinite&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.isfinite(x._array))</span>


<span class="s0">def </span><span class="s1">isinf(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.isinf &lt;numpy.isinf&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in isinf&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.isinf(x._array))</span>


<span class="s0">def </span><span class="s1">isnan(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.isnan &lt;numpy.isnan&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in isnan&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.isnan(x._array))</span>


<span class="s0">def </span><span class="s1">less(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.less &lt;numpy.less&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in less&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.less(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s0">def </span><span class="s1">less_equal(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.less_equal &lt;numpy.less_equal&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in less_equal&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.less_equal(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s0">def </span><span class="s1">log(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.log &lt;numpy.log&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in log&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.log(x._array))</span>


<span class="s0">def </span><span class="s1">log1p(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.log1p &lt;numpy.log1p&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in log1p&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.log1p(x._array))</span>


<span class="s0">def </span><span class="s1">log2(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.log2 &lt;numpy.log2&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in log2&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.log2(x._array))</span>


<span class="s0">def </span><span class="s1">log10(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.log10 &lt;numpy.log10&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in log10&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.log10(x._array))</span>


<span class="s0">def </span><span class="s1">logaddexp(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.logaddexp &lt;numpy.logaddexp&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in logaddexp&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.logaddexp(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s0">def </span><span class="s1">logical_and(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.logical_and &lt;numpy.logical_and&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_boolean_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_boolean_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only boolean dtypes are allowed in logical_and&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.logical_and(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s0">def </span><span class="s1">logical_not(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.logical_not &lt;numpy.logical_not&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_boolean_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only boolean dtypes are allowed in logical_not&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.logical_not(x._array))</span>


<span class="s0">def </span><span class="s1">logical_or(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.logical_or &lt;numpy.logical_or&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_boolean_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_boolean_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only boolean dtypes are allowed in logical_or&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.logical_or(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s0">def </span><span class="s1">logical_xor(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.logical_xor &lt;numpy.logical_xor&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_boolean_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_boolean_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only boolean dtypes are allowed in logical_xor&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.logical_xor(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s0">def </span><span class="s1">multiply(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.multiply &lt;numpy.multiply&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in multiply&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.multiply(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s0">def </span><span class="s1">negative(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.negative &lt;numpy.negative&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in negative&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.negative(x._array))</span>


<span class="s0">def </span><span class="s1">not_equal(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.not_equal &lt;numpy.not_equal&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.not_equal(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s0">def </span><span class="s1">positive(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.positive &lt;numpy.positive&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in positive&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.positive(x._array))</span>


<span class="s4"># Note: the function name is different here</span>
<span class="s0">def </span><span class="s1">pow(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.power &lt;numpy.power&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in pow&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.power(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s0">def </span><span class="s1">remainder(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.remainder &lt;numpy.remainder&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in remainder&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.remainder(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s0">def </span><span class="s1">round(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.round &lt;numpy.round&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in round&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.round(x._array))</span>


<span class="s0">def </span><span class="s1">sign(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.sign &lt;numpy.sign&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in sign&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.sign(x._array))</span>


<span class="s0">def </span><span class="s1">sin(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.sin &lt;numpy.sin&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in sin&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.sin(x._array))</span>


<span class="s0">def </span><span class="s1">sinh(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.sinh &lt;numpy.sinh&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in sinh&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.sinh(x._array))</span>


<span class="s0">def </span><span class="s1">square(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.square &lt;numpy.square&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in square&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.square(x._array))</span>


<span class="s0">def </span><span class="s1">sqrt(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.sqrt &lt;numpy.sqrt&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in sqrt&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.sqrt(x._array))</span>


<span class="s0">def </span><span class="s1">subtract(x1: Array</span><span class="s0">, </span><span class="s1">x2: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.subtract &lt;numpy.subtract&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes </span><span class="s0">or </span><span class="s1">x2.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in subtract&quot;</span><span class="s1">)</span>
    <span class="s4"># Call result type here just to raise on disallowed type combinations</span>
    <span class="s1">_result_type(x1.dtype</span><span class="s0">, </span><span class="s1">x2.dtype)</span>
    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 = Array._normalize_two_args(x1</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.subtract(x1._array</span><span class="s0">, </span><span class="s1">x2._array))</span>


<span class="s0">def </span><span class="s1">tan(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.tan &lt;numpy.tan&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in tan&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.tan(x._array))</span>


<span class="s0">def </span><span class="s1">tanh(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.tanh &lt;numpy.tanh&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only floating-point dtypes are allowed in tanh&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array._new(np.tanh(x._array))</span>


<span class="s0">def </span><span class="s1">trunc(x: Array</span><span class="s0">, </span><span class="s1">/) -&gt; Array:</span>
    <span class="s2">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.trunc &lt;numpy.trunc&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Only numeric dtypes are allowed in trunc&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">x.dtype </span><span class="s0">in </span><span class="s1">_integer_dtypes:</span>
        <span class="s4"># Note: The return dtype of trunc is the same as the input</span>
        <span class="s0">return </span><span class="s1">x</span>
    <span class="s0">return </span><span class="s1">Array._new(np.trunc(x._array))</span>
</pre>
</body>
</html>