<html>
<head>
<title>string_arrow.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
string_arrow.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">collections.abc </span><span class="s0">import </span><span class="s1">Callable  </span><span class="s2"># noqa: PDF001</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s0">,</span>
    <span class="s1">Any</span><span class="s0">,</span>
    <span class="s1">Union</span><span class="s0">,</span>
    <span class="s1">cast</span><span class="s0">,</span>
    <span class="s1">overload</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas._libs </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">lib</span><span class="s0">,</span>
    <span class="s1">missing </span><span class="s0">as </span><span class="s1">libmissing</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Dtype</span><span class="s0">,</span>
    <span class="s1">NpDtype</span><span class="s0">,</span>
    <span class="s1">PositionalIndexer</span><span class="s0">,</span>
    <span class="s1">Scalar</span><span class="s0">,</span>
    <span class="s1">ScalarIndexer</span><span class="s0">,</span>
    <span class="s1">SequenceIndexer</span><span class="s0">,</span>
    <span class="s1">TakeIndexer</span><span class="s0">,</span>
    <span class="s1">npt</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.compat </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">pa_version_under1p01</span><span class="s0">,</span>
    <span class="s1">pa_version_under2p0</span><span class="s0">,</span>
    <span class="s1">pa_version_under3p0</span><span class="s0">,</span>
    <span class="s1">pa_version_under4p0</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.util._decorators </span><span class="s0">import </span><span class="s1">doc</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">is_array_like</span><span class="s0">,</span>
    <span class="s1">is_bool_dtype</span><span class="s0">,</span>
    <span class="s1">is_dtype_equal</span><span class="s0">,</span>
    <span class="s1">is_integer</span><span class="s0">,</span>
    <span class="s1">is_integer_dtype</span><span class="s0">,</span>
    <span class="s1">is_object_dtype</span><span class="s0">,</span>
    <span class="s1">is_scalar</span><span class="s0">,</span>
    <span class="s1">is_string_dtype</span><span class="s0">,</span>
    <span class="s1">pandas_dtype</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s0">import </span><span class="s1">isna</span>

<span class="s0">from </span><span class="s1">pandas.core.arraylike </span><span class="s0">import </span><span class="s1">OpsMixin</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.base </span><span class="s0">import </span><span class="s1">ExtensionArray</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.boolean </span><span class="s0">import </span><span class="s1">BooleanDtype</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.integer </span><span class="s0">import </span><span class="s1">Int64Dtype</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.numeric </span><span class="s0">import </span><span class="s1">NumericDtype</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.string_ </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">BaseStringArray</span><span class="s0">,</span>
    <span class="s1">StringDtype</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.indexers </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">check_array_indexer</span><span class="s0">,</span>
    <span class="s1">unpack_tuple_and_ellipses</span><span class="s0">,</span>
    <span class="s1">validate_indices</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.strings.object_array </span><span class="s0">import </span><span class="s1">ObjectStringArrayMixin</span>

<span class="s0">if not </span><span class="s1">pa_version_under1p01:</span>
    <span class="s0">import </span><span class="s1">pyarrow </span><span class="s0">as </span><span class="s1">pa</span>
    <span class="s0">import </span><span class="s1">pyarrow.compute </span><span class="s0">as </span><span class="s1">pc</span>

    <span class="s1">ARROW_CMP_FUNCS = {</span>
        <span class="s3">&quot;eq&quot;</span><span class="s1">: pc.equal</span><span class="s0">,</span>
        <span class="s3">&quot;ne&quot;</span><span class="s1">: pc.not_equal</span><span class="s0">,</span>
        <span class="s3">&quot;lt&quot;</span><span class="s1">: pc.less</span><span class="s0">,</span>
        <span class="s3">&quot;gt&quot;</span><span class="s1">: pc.greater</span><span class="s0">,</span>
        <span class="s3">&quot;le&quot;</span><span class="s1">: pc.less_equal</span><span class="s0">,</span>
        <span class="s3">&quot;ge&quot;</span><span class="s1">: pc.greater_equal</span><span class="s0">,</span>
    <span class="s1">}</span>


<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>

<span class="s1">ArrowStringScalarOrNAT = Union[str</span><span class="s0">, </span><span class="s1">libmissing.NAType]</span>


<span class="s0">def </span><span class="s1">_chk_pyarrow_available() -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s0">if </span><span class="s1">pa_version_under1p01:</span>
        <span class="s1">msg = </span><span class="s3">&quot;pyarrow&gt;=1.0.0 is required for PyArrow backed StringArray.&quot;</span>
        <span class="s0">raise </span><span class="s1">ImportError(msg)</span>


<span class="s2"># TODO: Inherit directly from BaseStringArrayMethods. Currently we inherit from</span>
<span class="s2"># ObjectStringArrayMixin because we want to have the object-dtype based methods as</span>
<span class="s2"># fallback for the ones that pyarrow doesn't yet support</span>


<span class="s0">class </span><span class="s1">ArrowStringArray(OpsMixin</span><span class="s0">, </span><span class="s1">BaseStringArray</span><span class="s0">, </span><span class="s1">ObjectStringArrayMixin):</span>
    <span class="s4">&quot;&quot;&quot; 
    Extension array for string data in a ``pyarrow.ChunkedArray``. 
 
    .. versionadded:: 1.2.0 
 
    .. warning:: 
 
       ArrowStringArray is considered experimental. The implementation and 
       parts of the API may change without warning. 
 
    Parameters 
    ---------- 
    values : pyarrow.Array or pyarrow.ChunkedArray 
        The array of data. 
 
    Attributes 
    ---------- 
    None 
 
    Methods 
    ------- 
    None 
 
    See Also 
    -------- 
    array 
        The recommended function for creating a ArrowStringArray. 
    Series.str 
        The string methods are available on Series backed by 
        a ArrowStringArray. 
 
    Notes 
    ----- 
    ArrowStringArray returns a BooleanArray for comparison methods. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; pd.array(['This is', 'some text', None, 'data.'], dtype=&quot;string[pyarrow]&quot;) 
    &lt;ArrowStringArray&gt; 
    ['This is', 'some text', &lt;NA&gt;, 'data.'] 
    Length: 4, dtype: string 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">values):</span>
        <span class="s1">self._dtype = StringDtype(storage=</span><span class="s3">&quot;pyarrow&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">pa.Array):</span>
            <span class="s1">self._data = pa.chunked_array([values])</span>
        <span class="s0">elif </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">pa.ChunkedArray):</span>
            <span class="s1">self._data = values</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Unsupported type '</span><span class="s0">{</span><span class="s1">type(values)</span><span class="s0">}</span><span class="s3">' for ArrowStringArray&quot;</span><span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">pa.types.is_string(self._data.type):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;ArrowStringArray requires a PyArrow (chunked) array of string type&quot;</span>
            <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_from_sequence(cls</span><span class="s0">, </span><span class="s1">scalars</span><span class="s0">, </span><span class="s1">dtype: Dtype | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">copy: bool = </span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">from </span><span class="s1">pandas.core.arrays.masked </span><span class="s0">import </span><span class="s1">BaseMaskedArray</span>

        <span class="s1">_chk_pyarrow_available()</span>

        <span class="s0">if </span><span class="s1">dtype </span><span class="s0">and not </span><span class="s1">(isinstance(dtype</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">and </span><span class="s1">dtype == </span><span class="s3">&quot;string&quot;</span><span class="s1">):</span>
            <span class="s1">dtype = pandas_dtype(dtype)</span>
            <span class="s0">assert </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">StringDtype) </span><span class="s0">and </span><span class="s1">dtype.storage == </span><span class="s3">&quot;pyarrow&quot;</span>

        <span class="s0">if </span><span class="s1">isinstance(scalars</span><span class="s0">, </span><span class="s1">BaseMaskedArray):</span>
            <span class="s2"># avoid costly conversion to object dtype in ensure_string_array and</span>
            <span class="s2"># numerical issues with Float32Dtype</span>
            <span class="s1">na_values = scalars._mask</span>
            <span class="s1">result = scalars._data</span>
            <span class="s1">result = lib.ensure_string_array(result</span><span class="s0">, </span><span class="s1">copy=copy</span><span class="s0">, </span><span class="s1">convert_na_value=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">cls(pa.array(result</span><span class="s0">, </span><span class="s1">mask=na_values</span><span class="s0">, </span><span class="s1">type=pa.string()))</span>

        <span class="s2"># convert non-na-likes to str</span>
        <span class="s1">result = lib.ensure_string_array(scalars</span><span class="s0">, </span><span class="s1">copy=copy)</span>
        <span class="s0">return </span><span class="s1">cls(pa.array(result</span><span class="s0">, </span><span class="s1">type=pa.string()</span><span class="s0">, </span><span class="s1">from_pandas=</span><span class="s0">True</span><span class="s1">))</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_from_sequence_of_strings(</span>
        <span class="s1">cls</span><span class="s0">, </span><span class="s1">strings</span><span class="s0">, </span><span class="s1">dtype: Dtype | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">copy: bool = </span><span class="s0">False</span>
    <span class="s1">):</span>
        <span class="s0">return </span><span class="s1">cls._from_sequence(strings</span><span class="s0">, </span><span class="s1">dtype=dtype</span><span class="s0">, </span><span class="s1">copy=copy)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">dtype(self) -&gt; StringDtype:</span>
        <span class="s4">&quot;&quot;&quot; 
        An instance of 'string[pyarrow]'. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._dtype</span>

    <span class="s0">def </span><span class="s1">__array__(self</span><span class="s0">, </span><span class="s1">dtype: NpDtype | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">) -&gt; np.ndarray:</span>
        <span class="s4">&quot;&quot;&quot;Correctly construct numpy arrays when passed to `np.asarray()`.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.to_numpy(dtype=dtype)</span>

    <span class="s0">def </span><span class="s1">__arrow_array__(self</span><span class="s0">, </span><span class="s1">type=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Convert myself to a pyarrow Array or ChunkedArray.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._data</span>

    <span class="s0">def </span><span class="s1">to_numpy(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">dtype: npt.DTypeLike | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">copy: bool = </span><span class="s0">False,</span>
        <span class="s1">na_value=lib.no_default</span><span class="s0">,</span>
    <span class="s1">) -&gt; np.ndarray:</span>
        <span class="s4">&quot;&quot;&quot; 
        Convert to a NumPy ndarray. 
        &quot;&quot;&quot;</span>
        <span class="s2"># TODO: copy argument is ignored</span>

        <span class="s1">result = np.array(self._data</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s0">if </span><span class="s1">self._data.null_count &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">na_value </span><span class="s0">is </span><span class="s1">lib.no_default:</span>
                <span class="s0">if </span><span class="s1">dtype </span><span class="s0">and </span><span class="s1">np.issubdtype(dtype</span><span class="s0">, </span><span class="s1">np.floating):</span>
                    <span class="s0">return </span><span class="s1">result</span>
                <span class="s1">na_value = self._dtype.na_value</span>
            <span class="s1">mask = self.isna()</span>
            <span class="s1">result[mask] = na_value</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">__len__(self) -&gt; int:</span>
        <span class="s4">&quot;&quot;&quot; 
        Length of this array. 
 
        Returns 
        ------- 
        length : int 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">len(self._data)</span>

    <span class="s1">@doc(ExtensionArray.factorize)</span>
    <span class="s0">def </span><span class="s1">factorize(self</span><span class="s0">, </span><span class="s1">na_sentinel: int = -</span><span class="s5">1</span><span class="s1">) -&gt; tuple[np.ndarray</span><span class="s0">, </span><span class="s1">ExtensionArray]:</span>
        <span class="s1">encoded = self._data.dictionary_encode()</span>
        <span class="s1">indices = pa.chunked_array(</span>
            <span class="s1">[c.indices </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">encoded.chunks]</span><span class="s0">, </span><span class="s1">type=encoded.type.index_type</span>
        <span class="s1">).to_pandas()</span>
        <span class="s0">if </span><span class="s1">indices.dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
            <span class="s1">indices[np.isnan(indices)] = na_sentinel</span>
        <span class="s1">indices = indices.astype(np.int64</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">encoded.num_chunks:</span>
            <span class="s1">uniques = type(self)(encoded.chunk(</span><span class="s5">0</span><span class="s1">).dictionary)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">uniques = type(self)(pa.array([]</span><span class="s0">, </span><span class="s1">type=encoded.type.value_type))</span>

        <span class="s0">return </span><span class="s1">indices.values</span><span class="s0">, </span><span class="s1">uniques</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_concat_same_type(cls</span><span class="s0">, </span><span class="s1">to_concat) -&gt; ArrowStringArray:</span>
        <span class="s4">&quot;&quot;&quot; 
        Concatenate multiple ArrowStringArray. 
 
        Parameters 
        ---------- 
        to_concat : sequence of ArrowStringArray 
 
        Returns 
        ------- 
        ArrowStringArray 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">cls(</span>
            <span class="s1">pa.chunked_array(</span>
                <span class="s1">[array </span><span class="s0">for </span><span class="s1">ea </span><span class="s0">in </span><span class="s1">to_concat </span><span class="s0">for </span><span class="s1">array </span><span class="s0">in </span><span class="s1">ea._data.iterchunks()]</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">item: ScalarIndexer) -&gt; ArrowStringScalarOrNAT:</span>
        <span class="s1">...</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">__getitem__(self: ArrowStringArray</span><span class="s0">, </span><span class="s1">item: SequenceIndexer) -&gt; ArrowStringArray:</span>
        <span class="s1">...</span>

    <span class="s0">def </span><span class="s1">__getitem__(</span>
        <span class="s1">self: ArrowStringArray</span><span class="s0">, </span><span class="s1">item: PositionalIndexer</span>
    <span class="s1">) -&gt; ArrowStringArray | ArrowStringScalarOrNAT:</span>
        <span class="s4">&quot;&quot;&quot;Select a subset of self. 
 
        Parameters 
        ---------- 
        item : int, slice, or ndarray 
            * int: The position in 'self' to get. 
            * slice: A slice object, where 'start', 'stop', and 'step' are 
              integers or None 
            * ndarray: A 1-d boolean NumPy ndarray the same length as 'self' 
 
        Returns 
        ------- 
        item : scalar or ExtensionArray 
 
        Notes 
        ----- 
        For scalar ``item``, return a scalar value suitable for the array's 
        type. This should be an instance of ``self.dtype.type``. 
        For slice ``key``, return an instance of ``ExtensionArray``, even 
        if the slice is length 0 or 1. 
        For a boolean mask, return an instance of ``ExtensionArray``, filtered 
        to the values where ``item`` is True. 
        &quot;&quot;&quot;</span>
        <span class="s1">item = check_array_indexer(self</span><span class="s0">, </span><span class="s1">item)</span>

        <span class="s0">if </span><span class="s1">isinstance(item</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
            <span class="s0">if not </span><span class="s1">len(item):</span>
                <span class="s0">return </span><span class="s1">type(self)(pa.chunked_array([]</span><span class="s0">, </span><span class="s1">type=pa.string()))</span>
            <span class="s0">elif </span><span class="s1">is_integer_dtype(item.dtype):</span>
                <span class="s0">return </span><span class="s1">self.take(item)</span>
            <span class="s0">elif </span><span class="s1">is_bool_dtype(item.dtype):</span>
                <span class="s0">return </span><span class="s1">type(self)(self._data.filter(item))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">IndexError(</span>
                    <span class="s3">&quot;Only integers, slices and integer or &quot;</span>
                    <span class="s3">&quot;boolean arrays are valid indices.&quot;</span>
                <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">isinstance(item</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s1">item = unpack_tuple_and_ellipses(item)</span>

        <span class="s2"># error: Non-overlapping identity check (left operand type:</span>
        <span class="s2"># &quot;Union[Union[int, integer[Any]], Union[slice, List[int],</span>
        <span class="s2"># ndarray[Any, Any]]]&quot;, right operand type: &quot;ellipsis&quot;)</span>
        <span class="s0">if </span><span class="s1">item </span><span class="s0">is </span><span class="s1">Ellipsis:  </span><span class="s2"># type: ignore[comparison-overlap]</span>
            <span class="s2"># TODO: should be handled by pyarrow?</span>
            <span class="s1">item = slice(</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">is_scalar(item) </span><span class="s0">and not </span><span class="s1">is_integer(item):</span>
            <span class="s2"># e.g. &quot;foo&quot; or 2.5</span>
            <span class="s2"># exception message copied from numpy</span>
            <span class="s0">raise </span><span class="s1">IndexError(</span>
                <span class="s3">r&quot;only integers, slices (`:`), ellipsis (`...`), numpy.newaxis &quot;</span>
                <span class="s3">r&quot;(`None`) and integer or boolean arrays are valid indices&quot;</span>
            <span class="s1">)</span>
        <span class="s2"># We are not an array indexer, so maybe e.g. a slice or integer</span>
        <span class="s2"># indexer. We dispatch to pyarrow.</span>
        <span class="s1">value = self._data[item]</span>
        <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">pa.ChunkedArray):</span>
            <span class="s0">return </span><span class="s1">type(self)(value)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._as_pandas_scalar(value)</span>

    <span class="s0">def </span><span class="s1">_as_pandas_scalar(self</span><span class="s0">, </span><span class="s1">arrow_scalar: pa.Scalar):</span>
        <span class="s1">scalar = arrow_scalar.as_py()</span>
        <span class="s0">if </span><span class="s1">scalar </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._dtype.na_value</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">scalar</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">nbytes(self) -&gt; int:</span>
        <span class="s4">&quot;&quot;&quot; 
        The number of bytes needed to store this object in memory. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._data.nbytes</span>

    <span class="s0">def </span><span class="s1">isna(self) -&gt; np.ndarray:</span>
        <span class="s4">&quot;&quot;&quot; 
        Boolean NumPy array indicating if each value is missing. 
 
        This should return a 1-D array the same length as 'self'. 
        &quot;&quot;&quot;</span>
        <span class="s2"># TODO: Implement .to_numpy for ChunkedArray</span>
        <span class="s0">return </span><span class="s1">self._data.is_null().to_pandas().values</span>

    <span class="s0">def </span><span class="s1">copy(self) -&gt; ArrowStringArray:</span>
        <span class="s4">&quot;&quot;&quot; 
        Return a shallow copy of the array. 
 
        Underlying ChunkedArray is immutable, so a deep copy is unnecessary. 
 
        Returns 
        ------- 
        ArrowStringArray 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">type(self)(self._data)</span>

    <span class="s0">def </span><span class="s1">_cmp_method(self</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">op):</span>
        <span class="s0">from </span><span class="s1">pandas.arrays </span><span class="s0">import </span><span class="s1">BooleanArray</span>

        <span class="s1">pc_func = ARROW_CMP_FUNCS[op.__name__]</span>
        <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">ArrowStringArray):</span>
            <span class="s1">result = pc_func(self._data</span><span class="s0">, </span><span class="s1">other._data)</span>
        <span class="s0">elif </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">(np.ndarray</span><span class="s0">, </span><span class="s1">list)):</span>
            <span class="s1">result = pc_func(self._data</span><span class="s0">, </span><span class="s1">other)</span>
        <span class="s0">elif </span><span class="s1">is_scalar(other):</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">result = pc_func(self._data</span><span class="s0">, </span><span class="s1">pa.scalar(other))</span>
            <span class="s0">except </span><span class="s1">(pa.lib.ArrowNotImplementedError</span><span class="s0">, </span><span class="s1">pa.lib.ArrowInvalid):</span>
                <span class="s1">mask = isna(self) | isna(other)</span>
                <span class="s1">valid = ~mask</span>
                <span class="s1">result = np.zeros(len(self)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;bool&quot;</span><span class="s1">)</span>
                <span class="s1">result[valid] = op(np.array(self)[valid]</span><span class="s0">, </span><span class="s1">other)</span>
                <span class="s0">return </span><span class="s1">BooleanArray(result</span><span class="s0">, </span><span class="s1">mask)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">NotImplemented</span>

        <span class="s2"># TODO(ARROW-9429): Add a .to_numpy() to ChunkedArray</span>
        <span class="s0">return </span><span class="s1">BooleanArray._from_sequence(result.to_pandas().values)</span>

    <span class="s0">def </span><span class="s1">insert(self</span><span class="s0">, </span><span class="s1">loc: int</span><span class="s0">, </span><span class="s1">item):</span>
        <span class="s0">if not </span><span class="s1">isinstance(item</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">and </span><span class="s1">item </span><span class="s0">is not </span><span class="s1">libmissing.NA:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Scalar must be NA or str&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">super().insert(loc</span><span class="s0">, </span><span class="s1">item)</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">key: int | slice | np.ndarray</span><span class="s0">, </span><span class="s1">value: Any) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Set one or more values inplace. 
 
        Parameters 
        ---------- 
        key : int, ndarray, or slice 
            When called from, e.g. ``Series.__setitem__``, ``key`` will be 
            one of 
 
            * scalar int 
            * ndarray of integers. 
            * boolean ndarray 
            * slice object 
 
        value : ExtensionDtype.type, Sequence[ExtensionDtype.type], or object 
            value or values to be set of ``key``. 
 
        Returns 
        ------- 
        None 
        &quot;&quot;&quot;</span>
        <span class="s1">key = check_array_indexer(self</span><span class="s0">, </span><span class="s1">key)</span>

        <span class="s0">if </span><span class="s1">is_integer(key):</span>
            <span class="s1">key = cast(int</span><span class="s0">, </span><span class="s1">key)</span>

            <span class="s0">if not </span><span class="s1">is_scalar(value):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Must pass scalars with scalar indexer&quot;</span><span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">isna(value):</span>
                <span class="s1">value = </span><span class="s0">None</span>
            <span class="s0">elif not </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Scalar must be NA or str&quot;</span><span class="s1">)</span>

            <span class="s2"># Slice data and insert in-between</span>
            <span class="s1">new_data = [</span>
                <span class="s1">*self._data[</span><span class="s5">0</span><span class="s1">:key].chunks</span><span class="s0">,</span>
                <span class="s1">pa.array([value]</span><span class="s0">, </span><span class="s1">type=pa.string())</span><span class="s0">,</span>
                <span class="s1">*self._data[(key + </span><span class="s5">1</span><span class="s1">) :].chunks</span><span class="s0">,</span>
            <span class="s1">]</span>
            <span class="s1">self._data = pa.chunked_array(new_data)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># Convert to integer indices and iteratively assign.</span>
            <span class="s2"># TODO: Make a faster variant of this in Arrow upstream.</span>
            <span class="s2">#       This is probably extremely slow.</span>

            <span class="s2"># Convert all possible input key types to an array of integers</span>
            <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">slice):</span>
                <span class="s1">key_array = np.array(range(len(self))[key])</span>
            <span class="s0">elif </span><span class="s1">is_bool_dtype(key):</span>
                <span class="s2"># TODO(ARROW-9430): Directly support setitem(booleans)</span>
                <span class="s1">key_array = np.argwhere(key).flatten()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># TODO(ARROW-9431): Directly support setitem(integers)</span>
                <span class="s1">key_array = np.asanyarray(key)</span>

            <span class="s0">if </span><span class="s1">is_scalar(value):</span>
                <span class="s1">value = np.broadcast_to(value</span><span class="s0">, </span><span class="s1">len(key_array))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">value = np.asarray(value)</span>

            <span class="s0">if </span><span class="s1">len(key_array) != len(value):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Length of indexer and values mismatch&quot;</span><span class="s1">)</span>

            <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">zip(key_array</span><span class="s0">, </span><span class="s1">value):</span>
                <span class="s1">self[k] = v</span>

    <span class="s0">def </span><span class="s1">take(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">indices: TakeIndexer</span><span class="s0">,</span>
        <span class="s1">allow_fill: bool = </span><span class="s0">False,</span>
        <span class="s1">fill_value: Any = </span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Take elements from an array. 
 
        Parameters 
        ---------- 
        indices : sequence of int or one-dimensional np.ndarray of int 
            Indices to be taken. 
        allow_fill : bool, default False 
            How to handle negative values in `indices`. 
 
            * False: negative values in `indices` indicate positional indices 
              from the right (the default). This is similar to 
              :func:`numpy.take`. 
 
            * True: negative values in `indices` indicate 
              missing values. These values are set to `fill_value`. Any other 
              other negative values raise a ``ValueError``. 
 
        fill_value : any, optional 
            Fill value to use for NA-indices when `allow_fill` is True. 
            This may be ``None``, in which case the default NA value for 
            the type, ``self.dtype.na_value``, is used. 
 
            For many ExtensionArrays, there will be two representations of 
            `fill_value`: a user-facing &quot;boxed&quot; scalar, and a low-level 
            physical NA value. `fill_value` should be the user-facing version, 
            and the implementation should handle translating that to the 
            physical version for processing the take if necessary. 
 
        Returns 
        ------- 
        ExtensionArray 
 
        Raises 
        ------ 
        IndexError 
            When the indices are out of bounds for the array. 
        ValueError 
            When `indices` contains negative values other than ``-1`` 
            and `allow_fill` is True. 
 
        See Also 
        -------- 
        numpy.take 
        api.extensions.take 
 
        Notes 
        ----- 
        ExtensionArray.take is called by ``Series.__getitem__``, ``.loc``, 
        ``iloc``, when `indices` is a sequence of values. Additionally, 
        it's called by :meth:`Series.reindex`, or any other method 
        that causes realignment, with a `fill_value`. 
        &quot;&quot;&quot;</span>
        <span class="s2"># TODO: Remove once we got rid of the (indices &lt; 0) check</span>
        <span class="s0">if not </span><span class="s1">is_array_like(indices):</span>
            <span class="s1">indices_array = np.asanyarray(indices)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># error: Incompatible types in assignment (expression has type</span>
            <span class="s2"># &quot;Sequence[int]&quot;, variable has type &quot;ndarray&quot;)</span>
            <span class="s1">indices_array = indices  </span><span class="s2"># type: ignore[assignment]</span>

        <span class="s0">if </span><span class="s1">len(self._data) == </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">(indices_array &gt;= </span><span class="s5">0</span><span class="s1">).any():</span>
            <span class="s0">raise </span><span class="s1">IndexError(</span><span class="s3">&quot;cannot do a non-empty take&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">indices_array.size &gt; </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">indices_array.max() &gt;= len(self._data):</span>
            <span class="s0">raise </span><span class="s1">IndexError(</span><span class="s3">&quot;out of bounds value in 'indices'.&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">allow_fill:</span>
            <span class="s1">fill_mask = indices_array &lt; </span><span class="s5">0</span>
            <span class="s0">if </span><span class="s1">fill_mask.any():</span>
                <span class="s1">validate_indices(indices_array</span><span class="s0">, </span><span class="s1">len(self._data))</span>
                <span class="s2"># TODO(ARROW-9433): Treat negative indices as NULL</span>
                <span class="s1">indices_array = pa.array(indices_array</span><span class="s0">, </span><span class="s1">mask=fill_mask)</span>
                <span class="s1">result = self._data.take(indices_array)</span>
                <span class="s0">if </span><span class="s1">isna(fill_value):</span>
                    <span class="s0">return </span><span class="s1">type(self)(result)</span>
                <span class="s2"># TODO: ArrowNotImplementedError: Function fill_null has no</span>
                <span class="s2"># kernel matching input types (array[string], scalar[string])</span>
                <span class="s1">result = type(self)(result)</span>
                <span class="s1">result[fill_mask] = fill_value</span>
                <span class="s0">return </span><span class="s1">result</span>
                <span class="s2"># return type(self)(pc.fill_null(result, pa.scalar(fill_value)))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># Nothing to fill</span>
                <span class="s0">return </span><span class="s1">type(self)(self._data.take(indices))</span>
        <span class="s0">else</span><span class="s1">:  </span><span class="s2"># allow_fill=False</span>
            <span class="s2"># TODO(ARROW-9432): Treat negative indices as indices from the right.</span>
            <span class="s0">if </span><span class="s1">(indices_array &lt; </span><span class="s5">0</span><span class="s1">).any():</span>
                <span class="s2"># Don't modify in-place</span>
                <span class="s1">indices_array = np.copy(indices_array)</span>
                <span class="s1">indices_array[indices_array &lt; </span><span class="s5">0</span><span class="s1">] += len(self._data)</span>
            <span class="s0">return </span><span class="s1">type(self)(self._data.take(indices_array))</span>

    <span class="s0">def </span><span class="s1">isin(self</span><span class="s0">, </span><span class="s1">values):</span>
        <span class="s0">if </span><span class="s1">pa_version_under2p0:</span>
            <span class="s0">return </span><span class="s1">super().isin(values)</span>

        <span class="s1">value_set = [</span>
            <span class="s1">pa_scalar.as_py()</span>
            <span class="s0">for </span><span class="s1">pa_scalar </span><span class="s0">in </span><span class="s1">[pa.scalar(value</span><span class="s0">, </span><span class="s1">from_pandas=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">for </span><span class="s1">value </span><span class="s0">in </span><span class="s1">values]</span>
            <span class="s0">if </span><span class="s1">pa_scalar.type </span><span class="s0">in </span><span class="s1">(pa.string()</span><span class="s0">, </span><span class="s1">pa.null())</span>
        <span class="s1">]</span>

        <span class="s2"># for an empty value_set pyarrow 3.0.0 segfaults and pyarrow 2.0.0 returns True</span>
        <span class="s2"># for null values, so we short-circuit to return all False array.</span>
        <span class="s0">if not </span><span class="s1">len(value_set):</span>
            <span class="s0">return </span><span class="s1">np.zeros(len(self)</span><span class="s0">, </span><span class="s1">dtype=bool)</span>

        <span class="s1">kwargs = {}</span>
        <span class="s0">if </span><span class="s1">pa_version_under3p0:</span>
            <span class="s2"># in pyarrow 2.0.0 skip_null is ignored but is a required keyword and raises</span>
            <span class="s2"># with unexpected keyword argument in pyarrow 3.0.0+</span>
            <span class="s1">kwargs[</span><span class="s3">&quot;skip_null&quot;</span><span class="s1">] = </span><span class="s0">True</span>

        <span class="s1">result = pc.is_in(self._data</span><span class="s0">, </span><span class="s1">value_set=pa.array(value_set)</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s2"># pyarrow 2.0.0 returned nulls, so we explicily specify dtype to convert nulls</span>
        <span class="s2"># to False</span>
        <span class="s0">return </span><span class="s1">np.array(result</span><span class="s0">, </span><span class="s1">dtype=np.bool_)</span>

    <span class="s0">def </span><span class="s1">value_counts(self</span><span class="s0">, </span><span class="s1">dropna: bool = </span><span class="s0">True</span><span class="s1">) -&gt; Series:</span>
        <span class="s4">&quot;&quot;&quot; 
        Return a Series containing counts of each unique value. 
 
        Parameters 
        ---------- 
        dropna : bool, default True 
            Don't include counts of missing values. 
 
        Returns 
        ------- 
        counts : Series 
 
        See Also 
        -------- 
        Series.value_counts 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
            <span class="s1">Index</span><span class="s0">,</span>
            <span class="s1">Series</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">vc = self._data.value_counts()</span>

        <span class="s1">values = vc.field(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">counts = vc.field(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">dropna </span><span class="s0">and </span><span class="s1">self._data.null_count &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">mask = values.is_valid()</span>
            <span class="s1">values = values.filter(mask)</span>
            <span class="s1">counts = counts.filter(mask)</span>

        <span class="s2"># No missing values so we can adhere to the interface and return a numpy array.</span>
        <span class="s1">counts = np.array(counts)</span>

        <span class="s1">index = Index(type(self)(values))</span>

        <span class="s0">return </span><span class="s1">Series(counts</span><span class="s0">, </span><span class="s1">index=index).astype(</span><span class="s3">&quot;Int64&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">astype(self</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">copy: bool = </span><span class="s0">True</span><span class="s1">):</span>
        <span class="s1">dtype = pandas_dtype(dtype)</span>

        <span class="s0">if </span><span class="s1">is_dtype_equal(dtype</span><span class="s0">, </span><span class="s1">self.dtype):</span>
            <span class="s0">if </span><span class="s1">copy:</span>
                <span class="s0">return </span><span class="s1">self.copy()</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s0">elif </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">NumericDtype):</span>
            <span class="s1">data = self._data.cast(pa.from_numpy_dtype(dtype.numpy_dtype))</span>
            <span class="s0">return </span><span class="s1">dtype.__from_arrow__(data)</span>

        <span class="s0">return </span><span class="s1">super().astype(dtype</span><span class="s0">, </span><span class="s1">copy=copy)</span>

    <span class="s2"># ------------------------------------------------------------------------</span>
    <span class="s2"># String methods interface</span>

    <span class="s2"># error: Cannot determine type of 'na_value'</span>
    <span class="s1">_str_na_value = StringDtype.na_value  </span><span class="s2"># type: ignore[has-type]</span>

    <span class="s0">def </span><span class="s1">_str_map(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">na_value=</span><span class="s0">None, </span><span class="s1">dtype: Dtype | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">convert: bool = </span><span class="s0">True</span>
    <span class="s1">):</span>
        <span class="s2"># TODO: de-duplicate with StringArray method. This method is moreless copy and</span>
        <span class="s2"># paste.</span>

        <span class="s0">from </span><span class="s1">pandas.arrays </span><span class="s0">import </span><span class="s1">(</span>
            <span class="s1">BooleanArray</span><span class="s0">,</span>
            <span class="s1">IntegerArray</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">dtype = self.dtype</span>
        <span class="s0">if </span><span class="s1">na_value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">na_value = self.dtype.na_value</span>

        <span class="s1">mask = isna(self)</span>
        <span class="s1">arr = np.asarray(self)</span>

        <span class="s0">if </span><span class="s1">is_integer_dtype(dtype) </span><span class="s0">or </span><span class="s1">is_bool_dtype(dtype):</span>
            <span class="s1">constructor: type[IntegerArray] | type[BooleanArray]</span>
            <span class="s0">if </span><span class="s1">is_integer_dtype(dtype):</span>
                <span class="s1">constructor = IntegerArray</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">constructor = BooleanArray</span>

            <span class="s1">na_value_is_na = isna(na_value)</span>
            <span class="s0">if </span><span class="s1">na_value_is_na:</span>
                <span class="s1">na_value = </span><span class="s5">1</span>
            <span class="s1">result = lib.map_infer_mask(</span>
                <span class="s1">arr</span><span class="s0">,</span>
                <span class="s1">f</span><span class="s0">,</span>
                <span class="s1">mask.view(</span><span class="s3">&quot;uint8&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">convert=</span><span class="s0">False,</span>
                <span class="s1">na_value=na_value</span><span class="s0">,</span>
                <span class="s2"># error: Argument 1 to &quot;dtype&quot; has incompatible type</span>
                <span class="s2"># &quot;Union[ExtensionDtype, str, dtype[Any], Type[object]]&quot;; expected</span>
                <span class="s2"># &quot;Type[object]&quot;</span>
                <span class="s1">dtype=np.dtype(dtype)</span><span class="s0">,  </span><span class="s2"># type: ignore[arg-type]</span>
            <span class="s1">)</span>

            <span class="s0">if not </span><span class="s1">na_value_is_na:</span>
                <span class="s1">mask[:] = </span><span class="s0">False</span>

            <span class="s0">return </span><span class="s1">constructor(result</span><span class="s0">, </span><span class="s1">mask)</span>

        <span class="s0">elif </span><span class="s1">is_string_dtype(dtype) </span><span class="s0">and not </span><span class="s1">is_object_dtype(dtype):</span>
            <span class="s2"># i.e. StringDtype</span>
            <span class="s1">result = lib.map_infer_mask(</span>
                <span class="s1">arr</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">mask.view(</span><span class="s3">&quot;uint8&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">convert=</span><span class="s0">False, </span><span class="s1">na_value=na_value</span>
            <span class="s1">)</span>
            <span class="s1">result = pa.array(result</span><span class="s0">, </span><span class="s1">mask=mask</span><span class="s0">, </span><span class="s1">type=pa.string()</span><span class="s0">, </span><span class="s1">from_pandas=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">type(self)(result)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s2"># This is when the result type is object. We reach this when</span>
            <span class="s2"># -&gt; We know the result type is truly object (e.g. .encode returns bytes</span>
            <span class="s2">#    or .findall returns a list).</span>
            <span class="s2"># -&gt; We don't know the result type. E.g. `.get` can return anything.</span>
            <span class="s0">return </span><span class="s1">lib.map_infer_mask(arr</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">mask.view(</span><span class="s3">&quot;uint8&quot;</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">_str_contains(self</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">case=</span><span class="s0">True, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">na=np.nan</span><span class="s0">, </span><span class="s1">regex: bool = </span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">flags:</span>
            <span class="s0">return </span><span class="s1">super()._str_contains(pat</span><span class="s0">, </span><span class="s1">case</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">na</span><span class="s0">, </span><span class="s1">regex)</span>

        <span class="s0">if </span><span class="s1">regex:</span>
            <span class="s0">if </span><span class="s1">pa_version_under4p0 </span><span class="s0">or </span><span class="s1">case </span><span class="s0">is False</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">super()._str_contains(pat</span><span class="s0">, </span><span class="s1">case</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">na</span><span class="s0">, </span><span class="s1">regex)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">result = pc.match_substring_regex(self._data</span><span class="s0">, </span><span class="s1">pat)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">case:</span>
                <span class="s1">result = pc.match_substring(self._data</span><span class="s0">, </span><span class="s1">pat)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">result = pc.match_substring(pc.utf8_upper(self._data)</span><span class="s0">, </span><span class="s1">pat.upper())</span>
        <span class="s1">result = BooleanDtype().__from_arrow__(result)</span>
        <span class="s0">if not </span><span class="s1">isna(na):</span>
            <span class="s1">result[isna(result)] = bool(na)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_str_startswith(self</span><span class="s0">, </span><span class="s1">pat: str</span><span class="s0">, </span><span class="s1">na=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">pa_version_under4p0:</span>
            <span class="s0">return </span><span class="s1">super()._str_startswith(pat</span><span class="s0">, </span><span class="s1">na)</span>

        <span class="s1">pat = </span><span class="s3">&quot;^&quot; </span><span class="s1">+ re.escape(pat)</span>
        <span class="s0">return </span><span class="s1">self._str_contains(pat</span><span class="s0">, </span><span class="s1">na=na</span><span class="s0">, </span><span class="s1">regex=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_endswith(self</span><span class="s0">, </span><span class="s1">pat: str</span><span class="s0">, </span><span class="s1">na=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">pa_version_under4p0:</span>
            <span class="s0">return </span><span class="s1">super()._str_endswith(pat</span><span class="s0">, </span><span class="s1">na)</span>

        <span class="s1">pat = re.escape(pat) + </span><span class="s3">&quot;$&quot;</span>
        <span class="s0">return </span><span class="s1">self._str_contains(pat</span><span class="s0">, </span><span class="s1">na=na</span><span class="s0">, </span><span class="s1">regex=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_replace(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">pat: str | re.Pattern</span><span class="s0">,</span>
        <span class="s1">repl: str | Callable</span><span class="s0">,</span>
        <span class="s1">n: int = -</span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">case: bool = </span><span class="s0">True,</span>
        <span class="s1">flags: int = </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">regex: bool = </span><span class="s0">True,</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">pa_version_under4p0</span>
            <span class="s0">or </span><span class="s1">isinstance(pat</span><span class="s0">, </span><span class="s1">re.Pattern)</span>
            <span class="s0">or </span><span class="s1">callable(repl)</span>
            <span class="s0">or not </span><span class="s1">case</span>
            <span class="s0">or </span><span class="s1">flags</span>
        <span class="s1">):</span>
            <span class="s0">return </span><span class="s1">super()._str_replace(pat</span><span class="s0">, </span><span class="s1">repl</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">case</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">regex)</span>

        <span class="s1">func = pc.replace_substring_regex </span><span class="s0">if </span><span class="s1">regex </span><span class="s0">else </span><span class="s1">pc.replace_substring</span>
        <span class="s1">result = func(self._data</span><span class="s0">, </span><span class="s1">pattern=pat</span><span class="s0">, </span><span class="s1">replacement=repl</span><span class="s0">, </span><span class="s1">max_replacements=n)</span>
        <span class="s0">return </span><span class="s1">type(self)(result)</span>

    <span class="s0">def </span><span class="s1">_str_match(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">pat: str</span><span class="s0">, </span><span class="s1">case: bool = </span><span class="s0">True, </span><span class="s1">flags: int = </span><span class="s5">0</span><span class="s0">, </span><span class="s1">na: Scalar = </span><span class="s0">None</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">pa_version_under4p0:</span>
            <span class="s0">return </span><span class="s1">super()._str_match(pat</span><span class="s0">, </span><span class="s1">case</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">na)</span>

        <span class="s0">if not </span><span class="s1">pat.startswith(</span><span class="s3">&quot;^&quot;</span><span class="s1">):</span>
            <span class="s1">pat = </span><span class="s3">&quot;^&quot; </span><span class="s1">+ pat</span>
        <span class="s0">return </span><span class="s1">self._str_contains(pat</span><span class="s0">, </span><span class="s1">case</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">na</span><span class="s0">, </span><span class="s1">regex=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_str_fullmatch(self</span><span class="s0">, </span><span class="s1">pat</span><span class="s0">, </span><span class="s1">case: bool = </span><span class="s0">True, </span><span class="s1">flags: int = </span><span class="s5">0</span><span class="s0">, </span><span class="s1">na: Scalar = </span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">pa_version_under4p0:</span>
            <span class="s0">return </span><span class="s1">super()._str_fullmatch(pat</span><span class="s0">, </span><span class="s1">case</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">na)</span>

        <span class="s0">if not </span><span class="s1">pat.endswith(</span><span class="s3">&quot;$&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s1">pat.endswith(</span><span class="s3">&quot;//$&quot;</span><span class="s1">):</span>
            <span class="s1">pat = pat + </span><span class="s3">&quot;$&quot;</span>
        <span class="s0">return </span><span class="s1">self._str_match(pat</span><span class="s0">, </span><span class="s1">case</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">na)</span>

    <span class="s0">def </span><span class="s1">_str_isalnum(self):</span>
        <span class="s1">result = pc.utf8_is_alnum(self._data)</span>
        <span class="s0">return </span><span class="s1">BooleanDtype().__from_arrow__(result)</span>

    <span class="s0">def </span><span class="s1">_str_isalpha(self):</span>
        <span class="s1">result = pc.utf8_is_alpha(self._data)</span>
        <span class="s0">return </span><span class="s1">BooleanDtype().__from_arrow__(result)</span>

    <span class="s0">def </span><span class="s1">_str_isdecimal(self):</span>
        <span class="s1">result = pc.utf8_is_decimal(self._data)</span>
        <span class="s0">return </span><span class="s1">BooleanDtype().__from_arrow__(result)</span>

    <span class="s0">def </span><span class="s1">_str_isdigit(self):</span>
        <span class="s1">result = pc.utf8_is_digit(self._data)</span>
        <span class="s0">return </span><span class="s1">BooleanDtype().__from_arrow__(result)</span>

    <span class="s0">def </span><span class="s1">_str_islower(self):</span>
        <span class="s1">result = pc.utf8_is_lower(self._data)</span>
        <span class="s0">return </span><span class="s1">BooleanDtype().__from_arrow__(result)</span>

    <span class="s0">def </span><span class="s1">_str_isnumeric(self):</span>
        <span class="s1">result = pc.utf8_is_numeric(self._data)</span>
        <span class="s0">return </span><span class="s1">BooleanDtype().__from_arrow__(result)</span>

    <span class="s0">def </span><span class="s1">_str_isspace(self):</span>
        <span class="s0">if </span><span class="s1">pa_version_under2p0:</span>
            <span class="s0">return </span><span class="s1">super()._str_isspace()</span>

        <span class="s1">result = pc.utf8_is_space(self._data)</span>
        <span class="s0">return </span><span class="s1">BooleanDtype().__from_arrow__(result)</span>

    <span class="s0">def </span><span class="s1">_str_istitle(self):</span>
        <span class="s1">result = pc.utf8_is_title(self._data)</span>
        <span class="s0">return </span><span class="s1">BooleanDtype().__from_arrow__(result)</span>

    <span class="s0">def </span><span class="s1">_str_isupper(self):</span>
        <span class="s1">result = pc.utf8_is_upper(self._data)</span>
        <span class="s0">return </span><span class="s1">BooleanDtype().__from_arrow__(result)</span>

    <span class="s0">def </span><span class="s1">_str_len(self):</span>
        <span class="s0">if </span><span class="s1">pa_version_under4p0:</span>
            <span class="s0">return </span><span class="s1">super()._str_len()</span>

        <span class="s1">result = pc.utf8_length(self._data)</span>
        <span class="s0">return </span><span class="s1">Int64Dtype().__from_arrow__(result)</span>

    <span class="s0">def </span><span class="s1">_str_lower(self):</span>
        <span class="s0">return </span><span class="s1">type(self)(pc.utf8_lower(self._data))</span>

    <span class="s0">def </span><span class="s1">_str_upper(self):</span>
        <span class="s0">return </span><span class="s1">type(self)(pc.utf8_upper(self._data))</span>

    <span class="s0">def </span><span class="s1">_str_strip(self</span><span class="s0">, </span><span class="s1">to_strip=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">pa_version_under4p0:</span>
            <span class="s0">return </span><span class="s1">super()._str_strip(to_strip)</span>

        <span class="s0">if </span><span class="s1">to_strip </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">result = pc.utf8_trim_whitespace(self._data)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = pc.utf8_trim(self._data</span><span class="s0">, </span><span class="s1">characters=to_strip)</span>
        <span class="s0">return </span><span class="s1">type(self)(result)</span>

    <span class="s0">def </span><span class="s1">_str_lstrip(self</span><span class="s0">, </span><span class="s1">to_strip=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">pa_version_under4p0:</span>
            <span class="s0">return </span><span class="s1">super()._str_lstrip(to_strip)</span>

        <span class="s0">if </span><span class="s1">to_strip </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">result = pc.utf8_ltrim_whitespace(self._data)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = pc.utf8_ltrim(self._data</span><span class="s0">, </span><span class="s1">characters=to_strip)</span>
        <span class="s0">return </span><span class="s1">type(self)(result)</span>

    <span class="s0">def </span><span class="s1">_str_rstrip(self</span><span class="s0">, </span><span class="s1">to_strip=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">pa_version_under4p0:</span>
            <span class="s0">return </span><span class="s1">super()._str_rstrip(to_strip)</span>

        <span class="s0">if </span><span class="s1">to_strip </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">result = pc.utf8_rtrim_whitespace(self._data)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = pc.utf8_rtrim(self._data</span><span class="s0">, </span><span class="s1">characters=to_strip)</span>
        <span class="s0">return </span><span class="s1">type(self)(result)</span>
</pre>
</body>
</html>