<html>
<head>
<title>_templates.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_templates.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">absolute_import</span>

<span class="s0">import </span><span class="s1">textwrap</span>
<span class="s0">import </span><span class="s1">pkgutil</span>

<span class="s0">import </span><span class="s1">copy</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">json</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">reduce</span>

<span class="s0">from </span><span class="s1">six </span><span class="s0">import </span><span class="s1">string_types</span>

<span class="s0">try</span><span class="s1">:</span>
    <span class="s0">from </span><span class="s1">math </span><span class="s0">import </span><span class="s1">gcd</span>
<span class="s0">except </span><span class="s1">ImportError:</span>
    <span class="s2"># Python 2</span>
    <span class="s0">from </span><span class="s1">fractions </span><span class="s0">import </span><span class="s1">gcd</span>

<span class="s2"># Create Lazy sentinal object to indicate that a template should be loaded</span>
<span class="s2"># on-demand from package_data</span>
<span class="s1">Lazy = object()</span>


<span class="s2"># Templates configuration class</span>
<span class="s2"># -----------------------------</span>
<span class="s0">class </span><span class="s1">TemplatesConfig(object):</span>
    <span class="s3">&quot;&quot;&quot; 
    Singleton object containing the current figure templates (aka themes) 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self):</span>

        <span class="s2"># Initialize properties dict</span>
        <span class="s1">self._templates = {}</span>

        <span class="s2"># Initialize built-in templates</span>
        <span class="s1">default_templates = [</span>
            <span class="s4">&quot;ggplot2&quot;</span><span class="s0">,</span>
            <span class="s4">&quot;seaborn&quot;</span><span class="s0">,</span>
            <span class="s4">&quot;simple_white&quot;</span><span class="s0">,</span>
            <span class="s4">&quot;plotly&quot;</span><span class="s0">,</span>
            <span class="s4">&quot;plotly_white&quot;</span><span class="s0">,</span>
            <span class="s4">&quot;plotly_dark&quot;</span><span class="s0">,</span>
            <span class="s4">&quot;presentation&quot;</span><span class="s0">,</span>
            <span class="s4">&quot;xgridoff&quot;</span><span class="s0">,</span>
            <span class="s4">&quot;ygridoff&quot;</span><span class="s0">,</span>
            <span class="s4">&quot;gridon&quot;</span><span class="s0">,</span>
            <span class="s4">&quot;none&quot;</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">template_name </span><span class="s0">in </span><span class="s1">default_templates:</span>
            <span class="s1">self._templates[template_name] = Lazy</span>

        <span class="s1">self._validator = </span><span class="s0">None</span>
        <span class="s1">self._default = </span><span class="s0">None</span>

    <span class="s2"># ### Magic methods ###</span>
    <span class="s2"># Make this act as a dict of templates</span>
    <span class="s0">def </span><span class="s1">__len__(self):</span>
        <span class="s0">return </span><span class="s1">len(self._templates)</span>

    <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">item):</span>
        <span class="s0">return </span><span class="s1">item </span><span class="s0">in </span><span class="s1">self._templates</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">return </span><span class="s1">iter(self._templates)</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">item):</span>
        <span class="s0">if </span><span class="s1">isinstance(item</span><span class="s0">, </span><span class="s1">string_types):</span>
            <span class="s1">template_names = item.split(</span><span class="s4">&quot;+&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">template_names = [item]</span>

        <span class="s1">templates = []</span>
        <span class="s0">for </span><span class="s1">template_name </span><span class="s0">in </span><span class="s1">template_names:</span>
            <span class="s1">template = self._templates[template_name]</span>
            <span class="s0">if </span><span class="s1">template </span><span class="s0">is </span><span class="s1">Lazy:</span>
                <span class="s0">from </span><span class="s1">plotly.graph_objs.layout </span><span class="s0">import </span><span class="s1">Template</span>

                <span class="s0">if </span><span class="s1">template_name == </span><span class="s4">&quot;none&quot;</span><span class="s1">:</span>
                    <span class="s2"># &quot;none&quot; is a special built-in named template that applied no defaults</span>
                    <span class="s1">template = Template(data_scatter=[{}])</span>
                    <span class="s1">self._templates[template_name] = template</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s2"># Load template from package data</span>
                    <span class="s1">path = os.path.join(</span>
                        <span class="s4">&quot;package_data&quot;</span><span class="s0">, </span><span class="s4">&quot;templates&quot;</span><span class="s0">, </span><span class="s1">template_name + </span><span class="s4">&quot;.json&quot;</span>
                    <span class="s1">)</span>
                    <span class="s1">template_str = pkgutil.get_data(</span><span class="s4">&quot;plotly&quot;</span><span class="s0">, </span><span class="s1">path).decode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">)</span>
                    <span class="s1">template_dict = json.loads(template_str)</span>
                    <span class="s1">template = Template(template_dict</span><span class="s0">, </span><span class="s1">_validate=</span><span class="s0">False</span><span class="s1">)</span>

                    <span class="s1">self._templates[template_name] = template</span>
            <span class="s1">templates.append(self._templates[template_name])</span>

        <span class="s0">return </span><span class="s1">self.merge_templates(*templates)</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">self._templates[key] = self._validate(value)</span>

    <span class="s0">def </span><span class="s1">__delitem__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s2"># Remove template</span>
        <span class="s0">del </span><span class="s1">self._templates[key]</span>

        <span class="s2"># Check if we need to remove it as the default</span>
        <span class="s0">if </span><span class="s1">self._default == key:</span>
            <span class="s1">self._default = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_validate(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s0">if not </span><span class="s1">self._validator:</span>
            <span class="s0">from </span><span class="s1">plotly.validators.layout </span><span class="s0">import </span><span class="s1">TemplateValidator</span>

            <span class="s1">self._validator = TemplateValidator()</span>

        <span class="s0">return </span><span class="s1">self._validator.validate_coerce(value)</span>

    <span class="s0">def </span><span class="s1">keys(self):</span>
        <span class="s0">return </span><span class="s1">self._templates.keys()</span>

    <span class="s0">def </span><span class="s1">items(self):</span>
        <span class="s0">return </span><span class="s1">self._templates.items()</span>

    <span class="s0">def </span><span class="s1">update(self</span><span class="s0">, </span><span class="s1">d={}</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3">&quot;&quot;&quot; 
        Update one or more templates from a dict or from input keyword 
        arguments. 
 
        Parameters 
        ---------- 
        d: dict 
            Dictionary from template names to new template values. 
 
        kwargs 
            Named argument value pairs where the name is a template name 
            and the value is a new template value. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">dict(d</span><span class="s0">, </span><span class="s1">**kwargs).items():</span>
            <span class="s1">self[k] = v</span>

    <span class="s2"># ### Properties ###</span>
    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">default(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        The name of the default template, or None if no there is no default 
 
        If not None, the default template is automatically applied to all 
        figures during figure construction if no explicit template is 
        specified. 
 
        The names of available templates may be retrieved with: 
 
        &gt;&gt;&gt; import plotly.io as pio 
        &gt;&gt;&gt; list(pio.templates) 
 
        Returns 
        ------- 
        str 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._default</span>

    <span class="s1">@default.setter</span>
    <span class="s0">def </span><span class="s1">default(self</span><span class="s0">, </span><span class="s1">value):</span>

        <span class="s2"># Validate value</span>
        <span class="s2"># Could be a Template object, the key of a registered template,</span>
        <span class="s2"># Or a string containing the names of multiple templates joined on</span>
        <span class="s2"># '+' characters</span>
        <span class="s1">self._validate(value)</span>
        <span class="s1">self._default = value</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s4">&quot;&quot;&quot;</span><span class="s0">\ 
</span><span class="s4">Templates configuration 
----------------------- 
    Default template: {default} 
    Available templates: 
{available} 
&quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">default=repr(self.default)</span><span class="s0">, </span><span class="s1">available=self._available_templates_str()</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_available_templates_str(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return nicely wrapped string representation of all 
        available template names 
        &quot;&quot;&quot;</span>
        <span class="s1">available = </span><span class="s4">&quot;</span><span class="s0">\n</span><span class="s4">&quot;</span><span class="s1">.join(</span>
            <span class="s1">textwrap.wrap(</span>
                <span class="s1">repr(list(self))</span><span class="s0">,</span>
                <span class="s1">width=</span><span class="s5">79 </span><span class="s1">- </span><span class="s5">8</span><span class="s0">,</span>
                <span class="s1">initial_indent=</span><span class="s4">&quot; &quot; </span><span class="s1">* </span><span class="s5">8</span><span class="s0">,</span>
                <span class="s1">subsequent_indent=</span><span class="s4">&quot; &quot; </span><span class="s1">* </span><span class="s5">9</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">available</span>

    <span class="s0">def </span><span class="s1">merge_templates(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s3">&quot;&quot;&quot; 
        Merge a collection of templates into a single combined template. 
        Templates are process from left to right so if multiple templates 
        specify the same propery, the right-most template will take 
        precedence. 
 
        Parameters 
        ---------- 
        args: list of Template 
            Zero or more template objects (or dicts with compatible properties) 
 
        Returns 
        ------- 
        template: 
            A combined template object 
 
        Examples 
        -------- 
 
        &gt;&gt;&gt; pio.templates.merge_templates( 
        ...     go.layout.Template(layout={'font': {'size': 20}}), 
        ...     go.layout.Template(data={'scatter': [{'mode': 'markers'}]}), 
        ...     go.layout.Template(layout={'font': {'family': 'Courier'}})) 
        layout.Template({ 
            'data': {'scatter': [{'mode': 'markers', 'type': 'scatter'}]}, 
            'layout': {'font': {'family': 'Courier', 'size': 20}} 
        }) 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">args:</span>
            <span class="s0">return </span><span class="s1">reduce(self._merge_2_templates</span><span class="s0">, </span><span class="s1">args)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">from </span><span class="s1">plotly.graph_objs.layout </span><span class="s0">import </span><span class="s1">Template</span>

            <span class="s0">return </span><span class="s1">Template()</span>

    <span class="s0">def </span><span class="s1">_merge_2_templates(self</span><span class="s0">, </span><span class="s1">template1</span><span class="s0">, </span><span class="s1">template2):</span>
        <span class="s3">&quot;&quot;&quot; 
        Helper function for merge_templates that merges exactly two templates 
 
        Parameters 
        ---------- 
        template1: Template 
        template2: Template 
 
        Returns 
        ------- 
        Template: 
            merged template 
        &quot;&quot;&quot;</span>
        <span class="s2"># Validate/copy input templates</span>
        <span class="s1">result = self._validate(template1)</span>
        <span class="s1">other = self._validate(template2)</span>

        <span class="s2"># Cycle traces</span>
        <span class="s0">for </span><span class="s1">trace_type </span><span class="s0">in </span><span class="s1">result.data:</span>
            <span class="s1">result_traces = result.data[trace_type]</span>
            <span class="s1">other_traces = other.data[trace_type]</span>

            <span class="s0">if </span><span class="s1">result_traces </span><span class="s0">and </span><span class="s1">other_traces:</span>
                <span class="s1">lcm = (</span>
                    <span class="s1">len(result_traces)</span>
                    <span class="s1">* len(other_traces)</span>
                    <span class="s1">// gcd(len(result_traces)</span><span class="s0">, </span><span class="s1">len(other_traces))</span>
                <span class="s1">)</span>

                <span class="s2"># Cycle result traces</span>
                <span class="s1">result.data[trace_type] = result_traces * (lcm // len(result_traces))</span>

                <span class="s2"># Cycle other traces</span>
                <span class="s1">other.data[trace_type] = other_traces * (lcm // len(other_traces))</span>

        <span class="s2"># Perform update</span>
        <span class="s1">result.update(other)</span>

        <span class="s0">return </span><span class="s1">result</span>


<span class="s2"># Make config a singleton object</span>
<span class="s2"># ------------------------------</span>
<span class="s1">templates = TemplatesConfig()</span>
<span class="s0">del </span><span class="s1">TemplatesConfig</span>

<span class="s2"># Template utilities</span>
<span class="s2"># ------------------</span>
<span class="s0">def </span><span class="s1">walk_push_to_template(fig_obj</span><span class="s0">, </span><span class="s1">template_obj</span><span class="s0">, </span><span class="s1">skip):</span>
    <span class="s3">&quot;&quot;&quot; 
    Move style properties from fig_obj to template_obj. 
 
    Parameters 
    ---------- 
    fig_obj: plotly.basedatatypes.BasePlotlyType 
    template_obj: plotly.basedatatypes.BasePlotlyType 
    skip: set of str 
        Set of names of properties to skip 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">_plotly_utils.basevalidators </span><span class="s0">import </span><span class="s1">(</span>
        <span class="s1">CompoundValidator</span><span class="s0">,</span>
        <span class="s1">CompoundArrayValidator</span><span class="s0">,</span>
        <span class="s1">is_array</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">for </span><span class="s1">prop </span><span class="s0">in </span><span class="s1">list(fig_obj._props):</span>
        <span class="s0">if </span><span class="s1">prop == </span><span class="s4">&quot;template&quot; </span><span class="s0">or </span><span class="s1">prop </span><span class="s0">in </span><span class="s1">skip:</span>
            <span class="s2"># Avoid infinite recursion</span>
            <span class="s0">continue</span>

        <span class="s1">fig_val = fig_obj[prop]</span>
        <span class="s1">template_val = template_obj[prop]</span>

        <span class="s1">validator = fig_obj._get_validator(prop)</span>

        <span class="s0">if </span><span class="s1">isinstance(validator</span><span class="s0">, </span><span class="s1">CompoundValidator):</span>
            <span class="s1">walk_push_to_template(fig_val</span><span class="s0">, </span><span class="s1">template_val</span><span class="s0">, </span><span class="s1">skip)</span>
            <span class="s0">if not </span><span class="s1">fig_val._props:</span>
                <span class="s2"># Check if we can remove prop itself</span>
                <span class="s1">fig_obj[prop] = </span><span class="s0">None</span>
        <span class="s0">elif </span><span class="s1">isinstance(validator</span><span class="s0">, </span><span class="s1">CompoundArrayValidator) </span><span class="s0">and </span><span class="s1">fig_val:</span>
            <span class="s1">template_elements = list(template_val)</span>
            <span class="s1">template_element_names = [el.name </span><span class="s0">for </span><span class="s1">el </span><span class="s0">in </span><span class="s1">template_elements]</span>
            <span class="s1">template_propdefaults = template_obj[prop[:-</span><span class="s5">1</span><span class="s1">] + </span><span class="s4">&quot;defaults&quot;</span><span class="s1">]</span>

            <span class="s0">for </span><span class="s1">fig_el </span><span class="s0">in </span><span class="s1">fig_val:</span>
                <span class="s1">element_name = fig_el.name</span>
                <span class="s0">if </span><span class="s1">element_name:</span>
                    <span class="s2"># No properties are skipped inside a named array element</span>
                    <span class="s1">skip = set()</span>
                    <span class="s0">if </span><span class="s1">fig_el.name </span><span class="s0">in </span><span class="s1">template_element_names:</span>
                        <span class="s1">item_index = template_element_names.index(fig_el.name)</span>
                        <span class="s1">template_el = template_elements[item_index]</span>
                        <span class="s1">walk_push_to_template(fig_el</span><span class="s0">, </span><span class="s1">template_el</span><span class="s0">, </span><span class="s1">skip)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">template_el = fig_el.__class__()</span>
                        <span class="s1">walk_push_to_template(fig_el</span><span class="s0">, </span><span class="s1">template_el</span><span class="s0">, </span><span class="s1">skip)</span>
                        <span class="s1">template_elements.append(template_el)</span>
                        <span class="s1">template_element_names.append(fig_el.name)</span>

                    <span class="s2"># Restore element name</span>
                    <span class="s2"># since it was pushed to template above</span>
                    <span class="s1">fig_el.name = element_name</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">walk_push_to_template(fig_el</span><span class="s0">, </span><span class="s1">template_propdefaults</span><span class="s0">, </span><span class="s1">skip)</span>

            <span class="s1">template_obj[prop] = template_elements</span>

        <span class="s0">elif not </span><span class="s1">validator.array_ok </span><span class="s0">or not </span><span class="s1">is_array(fig_val):</span>
            <span class="s2"># Move property value from figure to template</span>
            <span class="s1">template_obj[prop] = fig_val</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">fig_obj[prop] = </span><span class="s0">None</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s2"># Property cannot be set to None, move on.</span>
                <span class="s0">pass</span>


<span class="s0">def </span><span class="s1">to_templated(fig</span><span class="s0">, </span><span class="s1">skip=(</span><span class="s4">&quot;title&quot;</span><span class="s0">, </span><span class="s4">&quot;text&quot;</span><span class="s1">)):</span>
    <span class="s3">&quot;&quot;&quot; 
    Return a copy of a figure where all styling properties have been moved 
    into the figure's template.  The template property of the resulting figure 
    may then be used to set the default styling of other figures. 
 
    Parameters 
    ---------- 
    fig 
        Figure object or dict representing a figure 
    skip 
        A collection of names of properties to skip when moving properties to 
        the template. Defaults to ('title', 'text') so that the text 
        of figure titles, axis titles, and annotations does not become part of 
        the template 
 
    Examples 
    -------- 
    Imports 
 
    &gt;&gt;&gt; import plotly.graph_objs as go 
    &gt;&gt;&gt; import plotly.io as pio 
 
    Construct a figure with large courier text 
 
    &gt;&gt;&gt; fig = go.Figure(layout={'title': 'Figure Title', 
    ...                         'font': {'size': 20, 'family': 'Courier'}, 
    ...                         'template':&quot;none&quot;}) 
    &gt;&gt;&gt; fig # doctest: +NORMALIZE_WHITESPACE 
    Figure({ 
        'data': [], 
        'layout': {'font': {'family': 'Courier', 'size': 20}, 
                   'template': '...', 'title': {'text': 'Figure Title'}} 
    }) 
 
    Convert to a figure with a template. Note how the 'font' properties have 
    been moved into the template property. 
 
    &gt;&gt;&gt; templated_fig = pio.to_templated(fig) 
    &gt;&gt;&gt; templated_fig.layout.template 
    layout.Template({ 
        'layout': {'font': {'family': 'Courier', 'size': 20}} 
    }) 
    &gt;&gt;&gt; templated_fig 
    Figure({ 
        'data': [], 'layout': {'template': '...', 'title': {'text': 'Figure Title'}} 
    }) 
 
 
    Next create a new figure with this template 
 
    &gt;&gt;&gt; fig2 = go.Figure(layout={ 
    ...     'title': 'Figure 2 Title', 
    ...     'template': templated_fig.layout.template}) 
    &gt;&gt;&gt; fig2.layout.template 
    layout.Template({ 
        'layout': {'font': {'family': 'Courier', 'size': 20}} 
    }) 
 
    The default font in fig2 will now be size 20 Courier. 
 
    Next, register as a named template... 
 
    &gt;&gt;&gt; pio.templates['large_courier'] = templated_fig.layout.template 
 
    and specify this template by name when constructing a figure. 
 
    &gt;&gt;&gt; go.Figure(layout={ 
    ...     'title': 'Figure 3 Title', 
    ...     'template': 'large_courier'}) # doctest: +ELLIPSIS 
    Figure(...) 
 
    Finally, set this as the default template to be applied to all new figures 
 
    &gt;&gt;&gt; pio.templates.default = 'large_courier' 
    &gt;&gt;&gt; fig = go.Figure(layout={'title': 'Figure 4 Title'}) 
    &gt;&gt;&gt; fig.layout.template 
    layout.Template({ 
        'layout': {'font': {'family': 'Courier', 'size': 20}} 
    }) 
 
    Returns 
    ------- 
    go.Figure 
    &quot;&quot;&quot;</span>

    <span class="s2"># process fig</span>
    <span class="s0">from </span><span class="s1">plotly.basedatatypes </span><span class="s0">import </span><span class="s1">BaseFigure</span>
    <span class="s0">from </span><span class="s1">plotly.graph_objs </span><span class="s0">import </span><span class="s1">Figure</span>

    <span class="s0">if not </span><span class="s1">isinstance(fig</span><span class="s0">, </span><span class="s1">BaseFigure):</span>
        <span class="s1">fig = Figure(fig)</span>

    <span class="s2"># Process skip</span>
    <span class="s0">if not </span><span class="s1">skip:</span>
        <span class="s1">skip = set()</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">skip = set(skip)</span>

    <span class="s2"># Always skip uids</span>
    <span class="s1">skip.add(</span><span class="s4">&quot;uid&quot;</span><span class="s1">)</span>

    <span class="s2"># Initialize templated figure with deep copy of input figure</span>
    <span class="s1">templated_fig = copy.deepcopy(fig)</span>

    <span class="s2"># Handle layout</span>
    <span class="s1">walk_push_to_template(</span>
        <span class="s1">templated_fig.layout</span><span class="s0">, </span><span class="s1">templated_fig.layout.template.layout</span><span class="s0">, </span><span class="s1">skip=skip</span>
    <span class="s1">)</span>

    <span class="s2"># Handle traces</span>
    <span class="s1">trace_type_indexes = {}</span>
    <span class="s0">for </span><span class="s1">trace </span><span class="s0">in </span><span class="s1">list(templated_fig.data):</span>
        <span class="s1">template_index = trace_type_indexes.get(trace.type</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s2"># Extend template traces if necessary</span>
        <span class="s1">template_traces = list(templated_fig.layout.template.data[trace.type])</span>
        <span class="s0">while </span><span class="s1">len(template_traces) &lt;= template_index:</span>
            <span class="s2"># Append empty trace</span>
            <span class="s1">template_traces.append(trace.__class__())</span>

        <span class="s2"># Get corresponding template trace</span>
        <span class="s1">template_trace = template_traces[template_index]</span>

        <span class="s2"># Perform push properties to template</span>
        <span class="s1">walk_push_to_template(trace</span><span class="s0">, </span><span class="s1">template_trace</span><span class="s0">, </span><span class="s1">skip=skip)</span>

        <span class="s2"># Update template traces in templated_fig</span>
        <span class="s1">templated_fig.layout.template.data[trace.type] = template_traces</span>

        <span class="s2"># Update trace_type_indexes</span>
        <span class="s1">trace_type_indexes[trace.type] = template_index + </span><span class="s5">1</span>

    <span class="s2"># Remove useless trace arrays</span>
    <span class="s1">any_non_empty = </span><span class="s0">False</span>
    <span class="s0">for </span><span class="s1">trace_type </span><span class="s0">in </span><span class="s1">templated_fig.layout.template.data:</span>
        <span class="s1">traces = templated_fig.layout.template.data[trace_type]</span>
        <span class="s1">is_empty = [trace.to_plotly_json() == {</span><span class="s4">&quot;type&quot;</span><span class="s1">: trace_type} </span><span class="s0">for </span><span class="s1">trace </span><span class="s0">in </span><span class="s1">traces]</span>
        <span class="s0">if </span><span class="s1">all(is_empty):</span>
            <span class="s1">templated_fig.layout.template.data[trace_type] = </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">any_non_empty = </span><span class="s0">True</span>

    <span class="s2"># Check if we can remove the data altogether key</span>
    <span class="s0">if not </span><span class="s1">any_non_empty:</span>
        <span class="s1">templated_fig.layout.template.data = </span><span class="s0">None</span>

    <span class="s0">return </span><span class="s1">templated_fig</span>
</pre>
</body>
</html>