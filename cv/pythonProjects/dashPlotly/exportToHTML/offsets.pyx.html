<html>
<head>
<title>offsets.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
offsets.pyx</font>
</center></td></tr></table>
<pre><span class="s0">import operator</span>
<span class="s0">import re</span>
<span class="s0">import time</span>
<span class="s0">import warnings</span>

<span class="s0">import cython</span>

<span class="s0">from cpython.datetime cimport (</span>
    <span class="s0">PyDate_Check,</span>
    <span class="s0">PyDateTime_Check,</span>
    <span class="s0">PyDateTime_IMPORT,</span>
    <span class="s0">PyDelta_Check,</span>
    <span class="s0">date,</span>
    <span class="s0">datetime,</span>
    <span class="s0">time as dt_time,</span>
    <span class="s0">timedelta,</span>
<span class="s0">)</span>

<span class="s0">PyDateTime_IMPORT</span>

<span class="s0">from dateutil.easter import easter</span>
<span class="s0">from dateutil.relativedelta import relativedelta</span>
<span class="s0">import numpy as np</span>

<span class="s0">cimport numpy as cnp</span>
<span class="s0">from numpy cimport (</span>
    <span class="s0">int64_t,</span>
    <span class="s0">ndarray,</span>
<span class="s0">)</span>

<span class="s0">cnp.import_array()</span>

<span class="s0"># TODO: formalize having _libs.properties &quot;above&quot; tslibs in the dependency structure</span>

<span class="s0">from pandas._libs.properties import cache_readonly</span>

<span class="s0">from pandas._libs.tslibs cimport util</span>
<span class="s0">from pandas._libs.tslibs.util cimport (</span>
    <span class="s0">is_datetime64_object,</span>
    <span class="s0">is_float_object,</span>
    <span class="s0">is_integer_object,</span>
<span class="s0">)</span>

<span class="s0">from pandas._libs.tslibs.ccalendar import (</span>
    <span class="s0">MONTH_ALIASES,</span>
    <span class="s0">MONTH_TO_CAL_NUM,</span>
    <span class="s0">int_to_weekday,</span>
    <span class="s0">weekday_to_int,</span>
<span class="s0">)</span>

<span class="s0">from pandas._libs.tslibs.ccalendar cimport (</span>
    <span class="s0">DAY_NANOS,</span>
    <span class="s0">dayofweek,</span>
    <span class="s0">get_days_in_month,</span>
    <span class="s0">get_firstbday,</span>
    <span class="s0">get_lastbday,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.conversion cimport (</span>
    <span class="s0">convert_datetime_to_tsobject,</span>
    <span class="s0">localize_pydatetime,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.nattype cimport (</span>
    <span class="s0">NPY_NAT,</span>
    <span class="s0">c_NaT as NaT,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.np_datetime cimport (</span>
    <span class="s0">dt64_to_dtstruct,</span>
    <span class="s0">dtstruct_to_dt64,</span>
    <span class="s0">npy_datetimestruct,</span>
    <span class="s0">pydate_to_dtstruct,</span>
<span class="s0">)</span>
<span class="s0">from pandas._libs.tslibs.tzconversion cimport tz_convert_from_utc_single</span>

<span class="s0">from .dtypes cimport PeriodDtypeCode</span>
<span class="s0">from .timedeltas cimport (</span>
    <span class="s0">delta_to_nanoseconds,</span>
    <span class="s0">is_any_td_scalar,</span>
<span class="s0">)</span>

<span class="s0">from .timedeltas import Timedelta</span>

<span class="s0">from .timestamps cimport _Timestamp</span>

<span class="s0">from .timestamps import Timestamp</span>

<span class="s0"># ---------------------------------------------------------------------</span>
<span class="s0"># Misc Helpers</span>

<span class="s0">cdef bint is_offset_object(object obj):</span>
    <span class="s0">return isinstance(obj, BaseOffset)</span>


<span class="s0">cdef bint is_tick_object(object obj):</span>
    <span class="s0">return isinstance(obj, Tick)</span>


<span class="s0">cdef datetime _as_datetime(datetime obj):</span>
    <span class="s0">if isinstance(obj, _Timestamp):</span>
        <span class="s0">return obj.to_pydatetime()</span>
    <span class="s0">return obj</span>


<span class="s0">cdef bint _is_normalized(datetime dt):</span>
    <span class="s0">if dt.hour != 0 or dt.minute != 0 or dt.second != 0 or dt.microsecond != 0:</span>
        <span class="s0"># Regardless of whether dt is datetime vs Timestamp</span>
        <span class="s0">return False</span>
    <span class="s0">if isinstance(dt, _Timestamp):</span>
        <span class="s0">return dt.nanosecond == 0</span>
    <span class="s0">return True</span>


<span class="s0">def apply_wrapper_core(func, self, other) -&gt; ndarray:</span>
    <span class="s0">result = func(self, other)</span>
    <span class="s0">result = np.asarray(result)</span>

    <span class="s0">if self.normalize:</span>
        <span class="s0"># TODO: Avoid circular/runtime import</span>
        <span class="s0">from .vectorized import normalize_i8_timestamps</span>
        <span class="s0">result = normalize_i8_timestamps(result.view(&quot;i8&quot;), None)</span>

    <span class="s0">return result</span>


<span class="s0">def apply_index_wraps(func):</span>
    <span class="s0"># Note: normally we would use `@functools.wraps(func)`, but this does</span>
    <span class="s0"># not play nicely with cython class methods</span>
    <span class="s0">def wrapper(self, other):</span>
        <span class="s0"># other is a DatetimeArray</span>
        <span class="s0">result = apply_wrapper_core(func, self, other)</span>
        <span class="s0">result = type(other)(result)</span>
        <span class="s0">warnings.warn(&quot;'Offset.apply_index(other)' is deprecated. &quot;</span>
                      <span class="s0">&quot;Use 'offset + other' instead.&quot;, FutureWarning)</span>
        <span class="s0">return result</span>

    <span class="s0">return wrapper</span>


<span class="s0">def apply_array_wraps(func):</span>
    <span class="s0"># Note: normally we would use `@functools.wraps(func)`, but this does</span>
    <span class="s0"># not play nicely with cython class methods</span>
    <span class="s0">def wrapper(self, other) -&gt; np.ndarray:</span>
        <span class="s0"># other is a DatetimeArray</span>
        <span class="s0">result = apply_wrapper_core(func, self, other)</span>
        <span class="s0">return result</span>

    <span class="s0"># do @functools.wraps(func) manually since it doesn't work on cdef funcs</span>
    <span class="s0">wrapper.__name__ = func.__name__</span>
    <span class="s0">wrapper.__doc__ = func.__doc__</span>
    <span class="s0">return wrapper</span>


<span class="s0">def apply_wraps(func):</span>
    <span class="s0"># Note: normally we would use `@functools.wraps(func)`, but this does</span>
    <span class="s0"># not play nicely with cython class methods</span>

    <span class="s0">def wrapper(self, other):</span>

        <span class="s0">if other is NaT:</span>
            <span class="s0">return NaT</span>
        <span class="s0">elif (</span>
            <span class="s0">isinstance(other, BaseOffset)</span>
            <span class="s0">or PyDelta_Check(other)</span>
            <span class="s0">or util.is_timedelta64_object(other)</span>
        <span class="s0">):</span>
            <span class="s0"># timedelta path</span>
            <span class="s0">return func(self, other)</span>
        <span class="s0">elif is_datetime64_object(other) or PyDate_Check(other):</span>
            <span class="s0"># PyDate_Check includes date, datetime</span>
            <span class="s0">other = Timestamp(other)</span>
        <span class="s0">else:</span>
            <span class="s0"># This will end up returning NotImplemented back in __add__</span>
            <span class="s0">raise ApplyTypeError</span>

        <span class="s0">tz = other.tzinfo</span>
        <span class="s0">nano = other.nanosecond</span>

        <span class="s0">if self._adjust_dst:</span>
            <span class="s0">other = other.tz_localize(None)</span>

        <span class="s0">result = func(self, other)</span>

        <span class="s0">result = Timestamp(result)</span>
        <span class="s0">if self._adjust_dst:</span>
            <span class="s0">result = result.tz_localize(tz)</span>

        <span class="s0">if self.normalize:</span>
            <span class="s0">result = result.normalize()</span>

        <span class="s0"># If the offset object does not have a nanoseconds component,</span>
        <span class="s0"># the result's nanosecond component may be lost.</span>
        <span class="s0">if not self.normalize and nano != 0 and not hasattr(self, &quot;nanoseconds&quot;):</span>
            <span class="s0">if result.nanosecond != nano:</span>
                <span class="s0">if result.tz is not None:</span>
                    <span class="s0"># convert to UTC</span>
                    <span class="s0">value = result.tz_localize(None).value</span>
                <span class="s0">else:</span>
                    <span class="s0">value = result.value</span>
                <span class="s0">result = Timestamp(value + nano)</span>

        <span class="s0">if tz is not None and result.tzinfo is None:</span>
            <span class="s0">result = result.tz_localize(tz)</span>

        <span class="s0">return result</span>

    <span class="s0"># do @functools.wraps(func) manually since it doesn't work on cdef funcs</span>
    <span class="s0">wrapper.__name__ = func.__name__</span>
    <span class="s0">wrapper.__doc__ = func.__doc__</span>
    <span class="s0">return wrapper</span>


<span class="s0">cdef _wrap_timedelta_result(result):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Tick operations dispatch to their Timedelta counterparts.  Wrap the result</span>
    <span class="s0">of these operations in a Tick if possible.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">result : object</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">object</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if PyDelta_Check(result):</span>
        <span class="s0"># convert Timedelta back to a Tick</span>
        <span class="s0">return delta_to_tick(result)</span>

    <span class="s0">return result</span>

<span class="s0"># ---------------------------------------------------------------------</span>
<span class="s0"># Business Helpers</span>


<span class="s0">cdef _get_calendar(weekmask, holidays, calendar):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Generate busdaycalendar</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if isinstance(calendar, np.busdaycalendar):</span>
        <span class="s0">if not holidays:</span>
            <span class="s0">holidays = tuple(calendar.holidays)</span>
        <span class="s0">elif not isinstance(holidays, tuple):</span>
            <span class="s0">holidays = tuple(holidays)</span>
        <span class="s0">else:</span>
            <span class="s0"># trust that calendar.holidays and holidays are</span>
            <span class="s0"># consistent</span>
            <span class="s0">pass</span>
        <span class="s0">return calendar, holidays</span>

    <span class="s0">if holidays is None:</span>
        <span class="s0">holidays = []</span>
    <span class="s0">try:</span>
        <span class="s0">holidays = holidays + calendar.holidays().tolist()</span>
    <span class="s0">except AttributeError:</span>
        <span class="s0">pass</span>
    <span class="s0">holidays = [_to_dt64D(dt) for dt in holidays]</span>
    <span class="s0">holidays = tuple(sorted(holidays))</span>

    <span class="s0">kwargs = {'weekmask': weekmask}</span>
    <span class="s0">if holidays:</span>
        <span class="s0">kwargs['holidays'] = holidays</span>

    <span class="s0">busdaycalendar = np.busdaycalendar(**kwargs)</span>
    <span class="s0">return busdaycalendar, holidays</span>


<span class="s0">cdef _to_dt64D(dt):</span>
    <span class="s0"># Currently</span>
    <span class="s0"># &gt; np.datetime64(dt.datetime(2013,5,1),dtype='datetime64[D]')</span>
    <span class="s0"># numpy.datetime64('2013-05-01T02:00:00.000000+0200')</span>
    <span class="s0"># Thus astype is needed to cast datetime to datetime64[D]</span>
    <span class="s0">if getattr(dt, 'tzinfo', None) is not None:</span>
        <span class="s0"># Get the nanosecond timestamp,</span>
        <span class="s0">#  equiv `Timestamp(dt).value` or `dt.timestamp() * 10**9`</span>
        <span class="s0">nanos = getattr(dt, &quot;nanosecond&quot;, 0)</span>
        <span class="s0">i8 = convert_datetime_to_tsobject(dt, tz=None, nanos=nanos).value</span>
        <span class="s0">dt = tz_convert_from_utc_single(i8, dt.tzinfo)</span>
        <span class="s0">dt = np.int64(dt).astype('datetime64[ns]')</span>
    <span class="s0">else:</span>
        <span class="s0">dt = np.datetime64(dt)</span>
    <span class="s0">if dt.dtype.name != &quot;datetime64[D]&quot;:</span>
        <span class="s0">dt = dt.astype(&quot;datetime64[D]&quot;)</span>
    <span class="s0">return dt</span>


<span class="s0"># ---------------------------------------------------------------------</span>
<span class="s0"># Validation</span>


<span class="s0">cdef _validate_business_time(t_input):</span>
    <span class="s0">if isinstance(t_input, str):</span>
        <span class="s0">try:</span>
            <span class="s0">t = time.strptime(t_input, '%H:%M')</span>
            <span class="s0">return dt_time(hour=t.tm_hour, minute=t.tm_min)</span>
        <span class="s0">except ValueError:</span>
            <span class="s0">raise ValueError(&quot;time data must match '%H:%M' format&quot;)</span>
    <span class="s0">elif isinstance(t_input, dt_time):</span>
        <span class="s0">if t_input.second != 0 or t_input.microsecond != 0:</span>
            <span class="s0">raise ValueError(</span>
                <span class="s0">&quot;time data must be specified only with hour and minute&quot;)</span>
        <span class="s0">return t_input</span>
    <span class="s0">else:</span>
        <span class="s0">raise ValueError(&quot;time data must be string or datetime.time&quot;)</span>


<span class="s0"># ---------------------------------------------------------------------</span>
<span class="s0"># Constructor Helpers</span>

<span class="s0">_relativedelta_kwds = {&quot;years&quot;, &quot;months&quot;, &quot;weeks&quot;, &quot;days&quot;, &quot;year&quot;, &quot;month&quot;,</span>
                       <span class="s0">&quot;day&quot;, &quot;weekday&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;,</span>
                       <span class="s0">&quot;microsecond&quot;, &quot;nanosecond&quot;, &quot;nanoseconds&quot;, &quot;hours&quot;,</span>
                       <span class="s0">&quot;minutes&quot;, &quot;seconds&quot;, &quot;microseconds&quot;}</span>


<span class="s0">cdef _determine_offset(kwds):</span>
    <span class="s0"># timedelta is used for sub-daily plural offsets and all singular</span>
    <span class="s0"># offsets relativedelta is used for plural offsets of daily length or</span>
    <span class="s0"># more nanosecond(s) are handled by apply_wraps</span>
    <span class="s0">kwds_no_nanos = dict(</span>
        <span class="s0">(k, v) for k, v in kwds.items()</span>
        <span class="s0">if k not in ('nanosecond', 'nanoseconds')</span>
    <span class="s0">)</span>
    <span class="s0"># TODO: Are nanosecond and nanoseconds allowed somewhere?</span>

    <span class="s0">_kwds_use_relativedelta = ('years', 'months', 'weeks', 'days',</span>
                               <span class="s0">'year', 'month', 'week', 'day', 'weekday',</span>
                               <span class="s0">'hour', 'minute', 'second', 'microsecond')</span>

    <span class="s0">use_relativedelta = False</span>
    <span class="s0">if len(kwds_no_nanos) &gt; 0:</span>
        <span class="s0">if any(k in _kwds_use_relativedelta for k in kwds_no_nanos):</span>
            <span class="s0">offset = relativedelta(**kwds_no_nanos)</span>
            <span class="s0">use_relativedelta = True</span>
        <span class="s0">else:</span>
            <span class="s0"># sub-daily offset - use timedelta (tz-aware)</span>
            <span class="s0">offset = timedelta(**kwds_no_nanos)</span>
    <span class="s0">else:</span>
        <span class="s0">offset = timedelta(0)</span>
    <span class="s0">return offset, use_relativedelta</span>


<span class="s0"># ---------------------------------------------------------------------</span>
<span class="s0"># Mixins &amp; Singletons</span>


<span class="s0">class ApplyTypeError(TypeError):</span>
    <span class="s0"># sentinel class for catching the apply error to return NotImplemented</span>
    <span class="s0">pass</span>


<span class="s0"># ---------------------------------------------------------------------</span>
<span class="s0"># Base Classes</span>

<span class="s0">cdef class BaseOffset:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Base class for DateOffset methods that are not overridden by subclasses.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0"># ensure that reversed-ops with numpy scalars return NotImplemented</span>
    <span class="s0">__array_priority__ = 1000</span>

    <span class="s0">_day_opt = None</span>
    <span class="s0">_attributes = tuple([&quot;n&quot;, &quot;normalize&quot;])</span>
    <span class="s0">_use_relativedelta = False</span>
    <span class="s0">_adjust_dst = True</span>
    <span class="s0">_deprecations = frozenset([&quot;isAnchored&quot;, &quot;onOffset&quot;])</span>

    <span class="s0"># cdef readonly:</span>
    <span class="s0">#    int64_t n</span>
    <span class="s0">#    bint normalize</span>
    <span class="s0">#    dict _cache</span>

    <span class="s0">def __init__(self, n=1, normalize=False):</span>
        <span class="s0">n = self._validate_n(n)</span>
        <span class="s0">self.n = n</span>
        <span class="s0">self.normalize = normalize</span>
        <span class="s0">self._cache = {}</span>

    <span class="s0">def __eq__(self, other) -&gt; bool:</span>
        <span class="s0">if isinstance(other, str):</span>
            <span class="s0">try:</span>
                <span class="s0"># GH#23524 if to_offset fails, we are dealing with an</span>
                <span class="s0">#  incomparable type so == is False and != is True</span>
                <span class="s0">other = to_offset(other)</span>
            <span class="s0">except ValueError:</span>
                <span class="s0"># e.g. &quot;infer&quot;</span>
                <span class="s0">return False</span>
        <span class="s0">try:</span>
            <span class="s0">return self._params == other._params</span>
        <span class="s0">except AttributeError:</span>
            <span class="s0"># other is not a DateOffset object</span>
            <span class="s0">return False</span>

    <span class="s0">def __ne__(self, other):</span>
        <span class="s0">return not self == other</span>

    <span class="s0">def __hash__(self) -&gt; int:</span>
        <span class="s0">return hash(self._params)</span>

    <span class="s0">@cache_readonly</span>
    <span class="s0">def _params(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Returns a tuple containing all of the attributes needed to evaluate</span>
        <span class="s0">equality between two DateOffset objects.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">d = getattr(self, &quot;__dict__&quot;, {})</span>
        <span class="s0">all_paras = d.copy()</span>
        <span class="s0">all_paras[&quot;n&quot;] = self.n</span>
        <span class="s0">all_paras[&quot;normalize&quot;] = self.normalize</span>
        <span class="s0">for attr in self._attributes:</span>
            <span class="s0">if hasattr(self, attr) and attr not in d:</span>
                <span class="s0"># cython attributes are not in __dict__</span>
                <span class="s0">all_paras[attr] = getattr(self, attr)</span>

        <span class="s0">if 'holidays' in all_paras and not all_paras['holidays']:</span>
            <span class="s0">all_paras.pop('holidays')</span>
        <span class="s0">exclude = ['kwds', 'name', 'calendar']</span>
        <span class="s0">attrs = [(k, v) for k, v in all_paras.items()</span>
                 <span class="s0">if (k not in exclude) and (k[0] != '_')]</span>
        <span class="s0">attrs = sorted(set(attrs))</span>
        <span class="s0">params = tuple([str(type(self))] + attrs)</span>
        <span class="s0">return params</span>

    <span class="s0">@property</span>
    <span class="s0">def kwds(self) -&gt; dict:</span>
        <span class="s0"># for backwards-compatibility</span>
        <span class="s0">kwds = {name: getattr(self, name, None) for name in self._attributes</span>
                <span class="s0">if name not in [&quot;n&quot;, &quot;normalize&quot;]}</span>
        <span class="s0">return {name: kwds[name] for name in kwds if kwds[name] is not None}</span>

    <span class="s0">@property</span>
    <span class="s0">def base(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Returns a copy of the calling offset object with n=1 and all other</span>
        <span class="s0">attributes equal.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return type(self)(n=1, normalize=self.normalize, **self.kwds)</span>

    <span class="s0">def __add__(self, other):</span>
        <span class="s0">if not isinstance(self, BaseOffset):</span>
            <span class="s0"># cython semantics; this is __radd__</span>
            <span class="s0">return other.__add__(self)</span>

        <span class="s0">elif util.is_array(other) and other.dtype == object:</span>
            <span class="s0">return np.array([self + x for x in other])</span>

        <span class="s0">try:</span>
            <span class="s0">return self._apply(other)</span>
        <span class="s0">except ApplyTypeError:</span>
            <span class="s0">return NotImplemented</span>

    <span class="s0">def __sub__(self, other):</span>
        <span class="s0">if PyDateTime_Check(other):</span>
            <span class="s0">raise TypeError('Cannot subtract datetime from offset.')</span>
        <span class="s0">elif type(other) == type(self):</span>
            <span class="s0">return type(self)(self.n - other.n, normalize=self.normalize,</span>
                              <span class="s0">**self.kwds)</span>
        <span class="s0">elif not isinstance(self, BaseOffset):</span>
            <span class="s0"># cython semantics, this is __rsub__</span>
            <span class="s0">return (-other).__add__(self)</span>
        <span class="s0">else:</span>
            <span class="s0"># e.g. PeriodIndex</span>
            <span class="s0">return NotImplemented</span>

    <span class="s0">def __call__(self, other):</span>
        <span class="s0">warnings.warn(</span>
            <span class="s0">&quot;DateOffset.__call__ is deprecated and will be removed in a future &quot;</span>
            <span class="s0">&quot;version.  Use `offset + other` instead.&quot;,</span>
            <span class="s0">FutureWarning,</span>
            <span class="s0">stacklevel=1,</span>
        <span class="s0">)</span>
        <span class="s0">return self._apply(other)</span>

    <span class="s0">def apply(self, other):</span>
        <span class="s0"># GH#44522</span>
        <span class="s0">warnings.warn(</span>
            <span class="s0">f&quot;{type(self).__name__}.apply is deprecated and will be removed &quot;</span>
            <span class="s0">&quot;in a future version. Use `offset + other` instead&quot;,</span>
            <span class="s0">FutureWarning,</span>
            <span class="s0">stacklevel=2,</span>
        <span class="s0">)</span>
        <span class="s0">return self._apply(other)</span>

    <span class="s0">def __mul__(self, other):</span>
        <span class="s0">if util.is_array(other):</span>
            <span class="s0">return np.array([self * x for x in other])</span>
        <span class="s0">elif is_integer_object(other):</span>
            <span class="s0">return type(self)(n=other * self.n, normalize=self.normalize,</span>
                              <span class="s0">**self.kwds)</span>
        <span class="s0">elif not isinstance(self, BaseOffset):</span>
            <span class="s0"># cython semantics, this is __rmul__</span>
            <span class="s0">return other.__mul__(self)</span>
        <span class="s0">return NotImplemented</span>

    <span class="s0">def __neg__(self):</span>
        <span class="s0"># Note: we are deferring directly to __mul__ instead of __rmul__, as</span>
        <span class="s0"># that allows us to use methods that can go in a `cdef class`</span>
        <span class="s0">return self * -1</span>

    <span class="s0">def copy(self):</span>
        <span class="s0"># Note: we are deferring directly to __mul__ instead of __rmul__, as</span>
        <span class="s0"># that allows us to use methods that can go in a `cdef class`</span>
        <span class="s0">return self * 1</span>

    <span class="s0"># ------------------------------------------------------------------</span>
    <span class="s0"># Name and Rendering Methods</span>

    <span class="s0">def __repr__(self) -&gt; str:</span>
        <span class="s0"># _output_name used by B(Year|Quarter)(End|Begin) to</span>
        <span class="s0">#  expand &quot;B&quot; -&gt; &quot;Business&quot;</span>
        <span class="s0">class_name = getattr(self, &quot;_output_name&quot;, type(self).__name__)</span>

        <span class="s0">if abs(self.n) != 1:</span>
            <span class="s0">plural = &quot;s&quot;</span>
        <span class="s0">else:</span>
            <span class="s0">plural = &quot;&quot;</span>

        <span class="s0">n_str = &quot;&quot;</span>
        <span class="s0">if self.n != 1:</span>
            <span class="s0">n_str = f&quot;{self.n} * &quot;</span>

        <span class="s0">out = f&quot;&lt;{n_str}{class_name}{plural}{self._repr_attrs()}&gt;&quot;</span>
        <span class="s0">return out</span>

    <span class="s0">def _repr_attrs(self) -&gt; str:</span>
        <span class="s0">exclude = {&quot;n&quot;, &quot;inc&quot;, &quot;normalize&quot;}</span>
        <span class="s0">attrs = []</span>
        <span class="s0">for attr in sorted(self._attributes):</span>
            <span class="s0"># _attributes instead of __dict__ because cython attrs are not in __dict__</span>
            <span class="s0">if attr.startswith(&quot;_&quot;) or attr == &quot;kwds&quot; or not hasattr(self, attr):</span>
                <span class="s0"># DateOffset may not have some of these attributes</span>
                <span class="s0">continue</span>
            <span class="s0">elif attr not in exclude:</span>
                <span class="s0">value = getattr(self, attr)</span>
                <span class="s0">attrs.append(f&quot;{attr}={value}&quot;)</span>

        <span class="s0">out = &quot;&quot;</span>
        <span class="s0">if attrs:</span>
            <span class="s0">out += &quot;: &quot; + &quot;, &quot;.join(attrs)</span>
        <span class="s0">return out</span>

    <span class="s0">@property</span>
    <span class="s0">def name(self) -&gt; str:</span>
        <span class="s0">return self.rule_code</span>

    <span class="s0">@property</span>
    <span class="s0">def _prefix(self) -&gt; str:</span>
        <span class="s0">raise NotImplementedError(&quot;Prefix not defined&quot;)</span>

    <span class="s0">@property</span>
    <span class="s0">def rule_code(self) -&gt; str:</span>
        <span class="s0">return self._prefix</span>

    <span class="s0">@cache_readonly</span>
    <span class="s0">def freqstr(self) -&gt; str:</span>
        <span class="s0">try:</span>
            <span class="s0">code = self.rule_code</span>
        <span class="s0">except NotImplementedError:</span>
            <span class="s0">return str(repr(self))</span>

        <span class="s0">if self.n != 1:</span>
            <span class="s0">fstr = f&quot;{self.n}{code}&quot;</span>
        <span class="s0">else:</span>
            <span class="s0">fstr = code</span>

        <span class="s0">try:</span>
            <span class="s0">if self._offset:</span>
                <span class="s0">fstr += self._offset_str()</span>
        <span class="s0">except AttributeError:</span>
            <span class="s0"># TODO: standardize `_offset` vs `offset` naming convention</span>
            <span class="s0">pass</span>

        <span class="s0">return fstr</span>

    <span class="s0">def _offset_str(self) -&gt; str:</span>
        <span class="s0">return &quot;&quot;</span>

    <span class="s0"># ------------------------------------------------------------------</span>

    <span class="s0">@apply_index_wraps</span>
    <span class="s0">def apply_index(self, dtindex):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Vectorized apply of DateOffset to DatetimeIndex,</span>
        <span class="s0">raises NotImplementedError for offsets without a</span>
        <span class="s0">vectorized implementation.</span>

        <span class="s0">.. deprecated:: 1.1.0</span>

           <span class="s0">Use ``offset + dtindex`` instead.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">index : DatetimeIndex</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">DatetimeIndex</span>

        <span class="s0">Raises</span>
        <span class="s0">------</span>
        <span class="s0">NotImplementedError</span>
            <span class="s0">When the specific offset subclass does not have a vectorized</span>
            <span class="s0">implementation.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">raise NotImplementedError(  # pragma: no cover</span>
            <span class="s0">f&quot;DateOffset subclass {type(self).__name__} &quot;</span>
            <span class="s0">&quot;does not have a vectorized implementation&quot;</span>
        <span class="s0">)</span>

    <span class="s0">@apply_array_wraps</span>
    <span class="s0">def _apply_array(self, dtarr):</span>
        <span class="s0">raise NotImplementedError(</span>
            <span class="s0">f&quot;DateOffset subclass {type(self).__name__} &quot;</span>
            <span class="s0">&quot;does not have a vectorized implementation&quot;</span>
        <span class="s0">)</span>

    <span class="s0">def rollback(self, dt) -&gt; datetime:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Roll provided date backward to next offset only if not on offset.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">TimeStamp</span>
            <span class="s0">Rolled timestamp if not on offset, otherwise unchanged timestamp.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">dt = Timestamp(dt)</span>
        <span class="s0">if not self.is_on_offset(dt):</span>
            <span class="s0">dt = dt - type(self)(1, normalize=self.normalize, **self.kwds)</span>
        <span class="s0">return dt</span>

    <span class="s0">def rollforward(self, dt) -&gt; datetime:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Roll provided date forward to next offset only if not on offset.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">TimeStamp</span>
            <span class="s0">Rolled timestamp if not on offset, otherwise unchanged timestamp.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">dt = Timestamp(dt)</span>
        <span class="s0">if not self.is_on_offset(dt):</span>
            <span class="s0">dt = dt + type(self)(1, normalize=self.normalize, **self.kwds)</span>
        <span class="s0">return dt</span>

    <span class="s0">def _get_offset_day(self, other: datetime) -&gt; int:</span>
        <span class="s0"># subclass must implement `_day_opt`; calling from the base class</span>
        <span class="s0"># will implicitly assume day_opt = &quot;business_end&quot;, see get_day_of_month.</span>
        <span class="s0">cdef:</span>
            <span class="s0">npy_datetimestruct dts</span>
        <span class="s0">pydate_to_dtstruct(other, &amp;dts)</span>
        <span class="s0">return get_day_of_month(&amp;dts, self._day_opt)</span>

    <span class="s0">def is_on_offset(self, dt: datetime) -&gt; bool:</span>
        <span class="s0">if self.normalize and not _is_normalized(dt):</span>
            <span class="s0">return False</span>

        <span class="s0"># Default (slow) method for determining if some date is a member of the</span>
        <span class="s0"># date range generated by this offset. Subclasses may have this</span>
        <span class="s0"># re-implemented in a nicer way.</span>
        <span class="s0">a = dt</span>
        <span class="s0">b = (dt + self) - self</span>
        <span class="s0">return a == b</span>

    <span class="s0"># ------------------------------------------------------------------</span>

    <span class="s0"># Staticmethod so we can call from Tick.__init__, will be unnecessary</span>
    <span class="s0">#  once BaseOffset is a cdef class and is inherited by Tick</span>
    <span class="s0">@staticmethod</span>
    <span class="s0">def _validate_n(n) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Require that `n` be an integer.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">n : int</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">nint : int</span>

        <span class="s0">Raises</span>
        <span class="s0">------</span>
        <span class="s0">TypeError if `int(n)` raises</span>
        <span class="s0">ValueError if n != int(n)</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if util.is_timedelta64_object(n):</span>
            <span class="s0">raise TypeError(f'`n` argument must be an integer, got {type(n)}')</span>
        <span class="s0">try:</span>
            <span class="s0">nint = int(n)</span>
        <span class="s0">except (ValueError, TypeError):</span>
            <span class="s0">raise TypeError(f'`n` argument must be an integer, got {type(n)}')</span>
        <span class="s0">if n != nint:</span>
            <span class="s0">raise ValueError(f'`n` argument must be an integer, got {n}')</span>
        <span class="s0">return nint</span>

    <span class="s0">def __setstate__(self, state):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Reconstruct an instance from a pickled state</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self.n = state.pop(&quot;n&quot;)</span>
        <span class="s0">self.normalize = state.pop(&quot;normalize&quot;)</span>
        <span class="s0">self._cache = state.pop(&quot;_cache&quot;, {})</span>
        <span class="s0"># At this point we expect state to be empty</span>

    <span class="s0">def __getstate__(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return a pickleable state</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">state = {}</span>
        <span class="s0">state[&quot;n&quot;] = self.n</span>
        <span class="s0">state[&quot;normalize&quot;] = self.normalize</span>

        <span class="s0"># we don't want to actually pickle the calendar object</span>
        <span class="s0"># as its a np.busyday; we recreate on deserialization</span>
        <span class="s0">state.pop(&quot;calendar&quot;, None)</span>
        <span class="s0">if &quot;kwds&quot; in state:</span>
            <span class="s0">state[&quot;kwds&quot;].pop(&quot;calendar&quot;, None)</span>

        <span class="s0">return state</span>

    <span class="s0">@property</span>
    <span class="s0">def nanos(self):</span>
        <span class="s0">raise ValueError(f&quot;{self} is a non-fixed frequency&quot;)</span>

    <span class="s0">def onOffset(self, dt) -&gt; bool:</span>
        <span class="s0">warnings.warn(</span>
            <span class="s0">&quot;onOffset is a deprecated, use is_on_offset instead.&quot;,</span>
            <span class="s0">FutureWarning,</span>
            <span class="s0">stacklevel=1,</span>
        <span class="s0">)</span>
        <span class="s0">return self.is_on_offset(dt)</span>

    <span class="s0">def isAnchored(self) -&gt; bool:</span>
        <span class="s0">warnings.warn(</span>
            <span class="s0">&quot;isAnchored is a deprecated, use is_anchored instead.&quot;,</span>
            <span class="s0">FutureWarning,</span>
            <span class="s0">stacklevel=1,</span>
        <span class="s0">)</span>
        <span class="s0">return self.is_anchored()</span>

    <span class="s0">def is_anchored(self) -&gt; bool:</span>
        <span class="s0"># TODO: Does this make sense for the general case?  It would help</span>
        <span class="s0"># if there were a canonical docstring for what is_anchored means.</span>
        <span class="s0">return self.n == 1</span>

    <span class="s0"># ------------------------------------------------------------------</span>

    <span class="s0">def is_month_start(self, _Timestamp ts):</span>
        <span class="s0">return ts._get_start_end_field(&quot;is_month_start&quot;, self)</span>

    <span class="s0">def is_month_end(self, _Timestamp ts):</span>
        <span class="s0">return ts._get_start_end_field(&quot;is_month_end&quot;, self)</span>

    <span class="s0">def is_quarter_start(self, _Timestamp ts):</span>
        <span class="s0">return ts._get_start_end_field(&quot;is_quarter_start&quot;, self)</span>

    <span class="s0">def is_quarter_end(self, _Timestamp ts):</span>
        <span class="s0">return ts._get_start_end_field(&quot;is_quarter_end&quot;, self)</span>

    <span class="s0">def is_year_start(self, _Timestamp ts):</span>
        <span class="s0">return ts._get_start_end_field(&quot;is_year_start&quot;, self)</span>

    <span class="s0">def is_year_end(self, _Timestamp ts):</span>
        <span class="s0">return ts._get_start_end_field(&quot;is_year_end&quot;, self)</span>


<span class="s0">cdef class SingleConstructorOffset(BaseOffset):</span>
    <span class="s0">@classmethod</span>
    <span class="s0">def _from_name(cls, suffix=None):</span>
        <span class="s0"># default _from_name calls cls with no args</span>
        <span class="s0">if suffix:</span>
            <span class="s0">raise ValueError(f&quot;Bad freq suffix {suffix}&quot;)</span>
        <span class="s0">return cls()</span>

    <span class="s0">def __reduce__(self):</span>
        <span class="s0"># This __reduce__ implementation is for all BaseOffset subclasses</span>
        <span class="s0">#  except for RelativeDeltaOffset</span>
        <span class="s0"># np.busdaycalendar objects do not pickle nicely, but we can reconstruct</span>
        <span class="s0">#  from attributes that do get pickled.</span>
        <span class="s0">tup = tuple(</span>
            <span class="s0">getattr(self, attr) if attr != &quot;calendar&quot; else None</span>
            <span class="s0">for attr in self._attributes</span>
        <span class="s0">)</span>
        <span class="s0">return type(self), tup</span>


<span class="s0"># ---------------------------------------------------------------------</span>
<span class="s0"># Tick Offsets</span>

<span class="s0">cdef class Tick(SingleConstructorOffset):</span>
    <span class="s0">_adjust_dst = False</span>
    <span class="s0">_prefix = &quot;undefined&quot;</span>
    <span class="s0">_attributes = tuple([&quot;n&quot;, &quot;normalize&quot;])</span>

    <span class="s0">def __init__(self, n=1, normalize=False):</span>
        <span class="s0">n = self._validate_n(n)</span>
        <span class="s0">self.n = n</span>
        <span class="s0">self.normalize = False</span>
        <span class="s0">self._cache = {}</span>
        <span class="s0">if normalize:</span>
            <span class="s0"># GH#21427</span>
            <span class="s0">raise ValueError(</span>
                <span class="s0">&quot;Tick offset with `normalize=True` are not allowed.&quot;</span>
            <span class="s0">)</span>

    <span class="s0"># Note: Without making this cpdef, we get AttributeError when calling</span>
    <span class="s0">#  from __mul__</span>
    <span class="s0">cpdef Tick _next_higher_resolution(Tick self):</span>
        <span class="s0">if type(self) is Day:</span>
            <span class="s0">return Hour(self.n * 24)</span>
        <span class="s0">if type(self) is Hour:</span>
            <span class="s0">return Minute(self.n * 60)</span>
        <span class="s0">if type(self) is Minute:</span>
            <span class="s0">return Second(self.n * 60)</span>
        <span class="s0">if type(self) is Second:</span>
            <span class="s0">return Milli(self.n * 1000)</span>
        <span class="s0">if type(self) is Milli:</span>
            <span class="s0">return Micro(self.n * 1000)</span>
        <span class="s0">if type(self) is Micro:</span>
            <span class="s0">return Nano(self.n * 1000)</span>
        <span class="s0">raise ValueError(&quot;Could not convert to integer offset at any resolution&quot;)</span>

    <span class="s0"># --------------------------------------------------------------------</span>

    <span class="s0">def _repr_attrs(self) -&gt; str:</span>
        <span class="s0"># Since cdef classes have no __dict__, we need to override</span>
        <span class="s0">return &quot;&quot;</span>

    <span class="s0">@property</span>
    <span class="s0">def delta(self):</span>
        <span class="s0">return self.n * Timedelta(self._nanos_inc)</span>

    <span class="s0">@property</span>
    <span class="s0">def nanos(self) -&gt; int64_t:</span>
        <span class="s0">return self.n * self._nanos_inc</span>

    <span class="s0">def is_on_offset(self, dt: datetime) -&gt; bool:</span>
        <span class="s0">return True</span>

    <span class="s0">def is_anchored(self) -&gt; bool:</span>
        <span class="s0">return False</span>

    <span class="s0"># This is identical to BaseOffset.__hash__, but has to be redefined here</span>
    <span class="s0"># for Python 3, because we've redefined __eq__.</span>
    <span class="s0">def __hash__(self) -&gt; int:</span>
        <span class="s0">return hash(self._params)</span>

    <span class="s0"># --------------------------------------------------------------------</span>
    <span class="s0"># Comparison and Arithmetic Methods</span>

    <span class="s0">def __eq__(self, other):</span>
        <span class="s0">if isinstance(other, str):</span>
            <span class="s0">try:</span>
                <span class="s0"># GH#23524 if to_offset fails, we are dealing with an</span>
                <span class="s0">#  incomparable type so == is False and != is True</span>
                <span class="s0">other = to_offset(other)</span>
            <span class="s0">except ValueError:</span>
                <span class="s0"># e.g. &quot;infer&quot;</span>
                <span class="s0">return False</span>
        <span class="s0">return self.delta == other</span>

    <span class="s0">def __ne__(self, other):</span>
        <span class="s0">return not (self == other)</span>

    <span class="s0">def __le__(self, other):</span>
        <span class="s0">return self.delta.__le__(other)</span>

    <span class="s0">def __lt__(self, other):</span>
        <span class="s0">return self.delta.__lt__(other)</span>

    <span class="s0">def __ge__(self, other):</span>
        <span class="s0">return self.delta.__ge__(other)</span>

    <span class="s0">def __gt__(self, other):</span>
        <span class="s0">return self.delta.__gt__(other)</span>

    <span class="s0">def __mul__(self, other):</span>
        <span class="s0">if not isinstance(self, Tick):</span>
            <span class="s0"># cython semantics, this is __rmul__</span>
            <span class="s0">return other.__mul__(self)</span>
        <span class="s0">if is_float_object(other):</span>
            <span class="s0">n = other * self.n</span>
            <span class="s0"># If the new `n` is an integer, we can represent it using the</span>
            <span class="s0">#  same Tick subclass as self, otherwise we need to move up</span>
            <span class="s0">#  to a higher-resolution subclass</span>
            <span class="s0">if np.isclose(n % 1, 0):</span>
                <span class="s0">return type(self)(int(n))</span>
            <span class="s0">new_self = self._next_higher_resolution()</span>
            <span class="s0">return new_self * other</span>
        <span class="s0">return BaseOffset.__mul__(self, other)</span>

    <span class="s0">def __truediv__(self, other):</span>
        <span class="s0">if not isinstance(self, Tick):</span>
            <span class="s0"># cython semantics mean the args are sometimes swapped</span>
            <span class="s0">result = other.delta.__rtruediv__(self)</span>
        <span class="s0">else:</span>
            <span class="s0">result = self.delta.__truediv__(other)</span>
        <span class="s0">return _wrap_timedelta_result(result)</span>

    <span class="s0">def __add__(self, other):</span>
        <span class="s0">if not isinstance(self, Tick):</span>
            <span class="s0"># cython semantics; this is __radd__</span>
            <span class="s0">return other.__add__(self)</span>

        <span class="s0">if isinstance(other, Tick):</span>
            <span class="s0">if type(self) == type(other):</span>
                <span class="s0">return type(self)(self.n + other.n)</span>
            <span class="s0">else:</span>
                <span class="s0">return delta_to_tick(self.delta + other.delta)</span>
        <span class="s0">try:</span>
            <span class="s0">return self._apply(other)</span>
        <span class="s0">except ApplyTypeError:</span>
            <span class="s0"># Includes pd.Period</span>
            <span class="s0">return NotImplemented</span>
        <span class="s0">except OverflowError as err:</span>
            <span class="s0">raise OverflowError(</span>
                <span class="s0">f&quot;the add operation between {self} and {other} will overflow&quot;</span>
            <span class="s0">) from err</span>

    <span class="s0">def _apply(self, other):</span>
        <span class="s0"># Timestamp can handle tz and nano sec, thus no need to use apply_wraps</span>
        <span class="s0">if isinstance(other, _Timestamp):</span>
            <span class="s0"># GH#15126</span>
            <span class="s0">return other + self.delta</span>
        <span class="s0">elif other is NaT:</span>
            <span class="s0">return NaT</span>
        <span class="s0">elif is_datetime64_object(other) or PyDate_Check(other):</span>
            <span class="s0"># PyDate_Check includes date, datetime</span>
            <span class="s0">return Timestamp(other) + self</span>

        <span class="s0">if util.is_timedelta64_object(other) or PyDelta_Check(other):</span>
            <span class="s0">return other + self.delta</span>
        <span class="s0">elif isinstance(other, type(self)):</span>
            <span class="s0"># TODO(2.0): remove once apply deprecation is enforced.</span>
            <span class="s0">#  This is reached in tests that specifically call apply,</span>
            <span class="s0">#  but should not be reached &quot;naturally&quot; because __add__ should</span>
            <span class="s0">#  catch this case first.</span>
            <span class="s0">return type(self)(self.n + other.n)</span>

        <span class="s0">raise ApplyTypeError(f&quot;Unhandled type: {type(other).__name__}&quot;)</span>

    <span class="s0"># --------------------------------------------------------------------</span>
    <span class="s0"># Pickle Methods</span>

    <span class="s0">def __setstate__(self, state):</span>
        <span class="s0">self.n = state[&quot;n&quot;]</span>
        <span class="s0">self.normalize = False</span>


<span class="s0">cdef class Day(Tick):</span>
    <span class="s0">_nanos_inc = 24 * 3600 * 1_000_000_000</span>
    <span class="s0">_prefix = &quot;D&quot;</span>
    <span class="s0">_period_dtype_code = PeriodDtypeCode.D</span>


<span class="s0">cdef class Hour(Tick):</span>
    <span class="s0">_nanos_inc = 3600 * 1_000_000_000</span>
    <span class="s0">_prefix = &quot;H&quot;</span>
    <span class="s0">_period_dtype_code = PeriodDtypeCode.H</span>


<span class="s0">cdef class Minute(Tick):</span>
    <span class="s0">_nanos_inc = 60 * 1_000_000_000</span>
    <span class="s0">_prefix = &quot;T&quot;</span>
    <span class="s0">_period_dtype_code = PeriodDtypeCode.T</span>


<span class="s0">cdef class Second(Tick):</span>
    <span class="s0">_nanos_inc = 1_000_000_000</span>
    <span class="s0">_prefix = &quot;S&quot;</span>
    <span class="s0">_period_dtype_code = PeriodDtypeCode.S</span>


<span class="s0">cdef class Milli(Tick):</span>
    <span class="s0">_nanos_inc = 1_000_000</span>
    <span class="s0">_prefix = &quot;L&quot;</span>
    <span class="s0">_period_dtype_code = PeriodDtypeCode.L</span>


<span class="s0">cdef class Micro(Tick):</span>
    <span class="s0">_nanos_inc = 1000</span>
    <span class="s0">_prefix = &quot;U&quot;</span>
    <span class="s0">_period_dtype_code = PeriodDtypeCode.U</span>


<span class="s0">cdef class Nano(Tick):</span>
    <span class="s0">_nanos_inc = 1</span>
    <span class="s0">_prefix = &quot;N&quot;</span>
    <span class="s0">_period_dtype_code = PeriodDtypeCode.N</span>


<span class="s0">def delta_to_tick(delta: timedelta) -&gt; Tick:</span>
    <span class="s0">if delta.microseconds == 0 and getattr(delta, &quot;nanoseconds&quot;, 0) == 0:</span>
        <span class="s0"># nanoseconds only for pd.Timedelta</span>
        <span class="s0">if delta.seconds == 0:</span>
            <span class="s0">return Day(delta.days)</span>
        <span class="s0">else:</span>
            <span class="s0">seconds = delta.days * 86400 + delta.seconds</span>
            <span class="s0">if seconds % 3600 == 0:</span>
                <span class="s0">return Hour(seconds / 3600)</span>
            <span class="s0">elif seconds % 60 == 0:</span>
                <span class="s0">return Minute(seconds / 60)</span>
            <span class="s0">else:</span>
                <span class="s0">return Second(seconds)</span>
    <span class="s0">else:</span>
        <span class="s0">nanos = delta_to_nanoseconds(delta)</span>
        <span class="s0">if nanos % 1_000_000 == 0:</span>
            <span class="s0">return Milli(nanos // 1_000_000)</span>
        <span class="s0">elif nanos % 1000 == 0:</span>
            <span class="s0">return Micro(nanos // 1000)</span>
        <span class="s0">else:  # pragma: no cover</span>
            <span class="s0">return Nano(nanos)</span>


<span class="s0"># --------------------------------------------------------------------</span>

<span class="s0">cdef class RelativeDeltaOffset(BaseOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset subclass backed by a dateutil relativedelta object.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">_attributes = tuple([&quot;n&quot;, &quot;normalize&quot;] + list(_relativedelta_kwds))</span>
    <span class="s0">_adjust_dst = False</span>

    <span class="s0">def __init__(self, n=1, normalize=False, **kwds):</span>
        <span class="s0">BaseOffset.__init__(self, n, normalize)</span>

        <span class="s0">off, use_rd = _determine_offset(kwds)</span>
        <span class="s0">object.__setattr__(self, &quot;_offset&quot;, off)</span>
        <span class="s0">object.__setattr__(self, &quot;_use_relativedelta&quot;, use_rd)</span>
        <span class="s0">for key in kwds:</span>
            <span class="s0">val = kwds[key]</span>
            <span class="s0">object.__setattr__(self, key, val)</span>

    <span class="s0">def __getstate__(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return a pickleable state</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0"># RelativeDeltaOffset (technically DateOffset) is the only non-cdef</span>
        <span class="s0">#  class, so the only one with __dict__</span>
        <span class="s0">state = self.__dict__.copy()</span>
        <span class="s0">state[&quot;n&quot;] = self.n</span>
        <span class="s0">state[&quot;normalize&quot;] = self.normalize</span>
        <span class="s0">return state</span>

    <span class="s0">def __setstate__(self, state):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Reconstruct an instance from a pickled state</span>
        <span class="s0">&quot;&quot;&quot;</span>

        <span class="s0">if &quot;offset&quot; in state:</span>
            <span class="s0"># Older (&lt;0.22.0) versions have offset attribute instead of _offset</span>
            <span class="s0">if &quot;_offset&quot; in state:  # pragma: no cover</span>
                <span class="s0">raise AssertionError(&quot;Unexpected key `_offset`&quot;)</span>
            <span class="s0">state[&quot;_offset&quot;] = state.pop(&quot;offset&quot;)</span>
            <span class="s0">state[&quot;kwds&quot;][&quot;offset&quot;] = state[&quot;_offset&quot;]</span>

        <span class="s0">self.n = state.pop(&quot;n&quot;)</span>
        <span class="s0">self.normalize = state.pop(&quot;normalize&quot;)</span>
        <span class="s0">self._cache = state.pop(&quot;_cache&quot;, {})</span>

        <span class="s0">self.__dict__.update(state)</span>

    <span class="s0">@apply_wraps</span>
    <span class="s0">def _apply(self, other: datetime) -&gt; datetime:</span>
        <span class="s0">if self._use_relativedelta:</span>
            <span class="s0">other = _as_datetime(other)</span>

        <span class="s0">if len(self.kwds) &gt; 0:</span>
            <span class="s0">tzinfo = getattr(other, &quot;tzinfo&quot;, None)</span>
            <span class="s0">if tzinfo is not None and self._use_relativedelta:</span>
                <span class="s0"># perform calculation in UTC</span>
                <span class="s0">other = other.replace(tzinfo=None)</span>

            <span class="s0">if hasattr(self, &quot;nanoseconds&quot;):</span>
                <span class="s0">td_nano = Timedelta(nanoseconds=self.nanoseconds)</span>
            <span class="s0">else:</span>
                <span class="s0">td_nano = Timedelta(0)</span>

            <span class="s0">if self.n &gt; 0:</span>
                <span class="s0">for i in range(self.n):</span>
                    <span class="s0">other = other + self._offset + td_nano</span>
            <span class="s0">else:</span>
                <span class="s0">for i in range(-self.n):</span>
                    <span class="s0">other = other - self._offset - td_nano</span>

            <span class="s0">if tzinfo is not None and self._use_relativedelta:</span>
                <span class="s0"># bring tz back from UTC calculation</span>
                <span class="s0">other = localize_pydatetime(other, tzinfo)</span>

            <span class="s0">return Timestamp(other)</span>
        <span class="s0">else:</span>
            <span class="s0">return other + timedelta(self.n)</span>

    <span class="s0">@apply_index_wraps</span>
    <span class="s0">def apply_index(self, dtindex):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Vectorized apply of DateOffset to DatetimeIndex,</span>
        <span class="s0">raises NotImplementedError for offsets without a</span>
        <span class="s0">vectorized implementation.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">index : DatetimeIndex</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">ndarray[datetime64[ns]]</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self._apply_array(dtindex)</span>

    <span class="s0">@apply_array_wraps</span>
    <span class="s0">def _apply_array(self, dtarr):</span>
        <span class="s0">dt64other = np.asarray(dtarr)</span>
        <span class="s0">kwds = self.kwds</span>
        <span class="s0">relativedelta_fast = {</span>
            <span class="s0">&quot;years&quot;,</span>
            <span class="s0">&quot;months&quot;,</span>
            <span class="s0">&quot;weeks&quot;,</span>
            <span class="s0">&quot;days&quot;,</span>
            <span class="s0">&quot;hours&quot;,</span>
            <span class="s0">&quot;minutes&quot;,</span>
            <span class="s0">&quot;seconds&quot;,</span>
            <span class="s0">&quot;microseconds&quot;,</span>
        <span class="s0">}</span>
        <span class="s0"># relativedelta/_offset path only valid for base DateOffset</span>
        <span class="s0">if self._use_relativedelta and set(kwds).issubset(relativedelta_fast):</span>

            <span class="s0">months = (kwds.get(&quot;years&quot;, 0) * 12 + kwds.get(&quot;months&quot;, 0)) * self.n</span>
            <span class="s0">if months:</span>
                <span class="s0">shifted = shift_months(dt64other.view(&quot;i8&quot;), months)</span>
                <span class="s0">dt64other = shifted.view(&quot;datetime64[ns]&quot;)</span>

            <span class="s0">weeks = kwds.get(&quot;weeks&quot;, 0) * self.n</span>
            <span class="s0">if weeks:</span>
                <span class="s0">dt64other = dt64other + Timedelta(days=7 * weeks)</span>

            <span class="s0">timedelta_kwds = {</span>
                <span class="s0">k: v</span>
                <span class="s0">for k, v in kwds.items()</span>
                <span class="s0">if k in [&quot;days&quot;, &quot;hours&quot;, &quot;minutes&quot;, &quot;seconds&quot;, &quot;microseconds&quot;]</span>
            <span class="s0">}</span>
            <span class="s0">if timedelta_kwds:</span>
                <span class="s0">delta = Timedelta(**timedelta_kwds)</span>
                <span class="s0">dt64other = dt64other + (self.n * delta)</span>
            <span class="s0">return dt64other</span>
        <span class="s0">elif not self._use_relativedelta and hasattr(self, &quot;_offset&quot;):</span>
            <span class="s0"># timedelta</span>
            <span class="s0">return dt64other + Timedelta(self._offset * self.n)</span>
        <span class="s0">else:</span>
            <span class="s0"># relativedelta with other keywords</span>
            <span class="s0">kwd = set(kwds) - relativedelta_fast</span>
            <span class="s0">raise NotImplementedError(</span>
                <span class="s0">&quot;DateOffset with relativedelta &quot;</span>
                <span class="s0">f&quot;keyword(s) {kwd} not able to be &quot;</span>
                <span class="s0">&quot;applied vectorized&quot;</span>
            <span class="s0">)</span>

    <span class="s0">def is_on_offset(self, dt: datetime) -&gt; bool:</span>
        <span class="s0">if self.normalize and not _is_normalized(dt):</span>
            <span class="s0">return False</span>
        <span class="s0">return True</span>


<span class="s0">class OffsetMeta(type):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Metaclass that allows us to pretend that all BaseOffset subclasses</span>
    <span class="s0">inherit from DateOffset (which is needed for backward-compatibility).</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def __instancecheck__(cls, obj) -&gt; bool:</span>
        <span class="s0">return isinstance(obj, BaseOffset)</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def __subclasscheck__(cls, obj) -&gt; bool:</span>
        <span class="s0">return issubclass(obj, BaseOffset)</span>


<span class="s0"># TODO: figure out a way to use a metaclass with a cdef class</span>
<span class="s0">class DateOffset(RelativeDeltaOffset, metaclass=OffsetMeta):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Standard kind of date increment used for a date range.</span>

    <span class="s0">Works exactly like the keyword argument form of relativedelta.</span>
    <span class="s0">Note that the positional argument form of relativedelata is not</span>
    <span class="s0">supported. Use of the keyword n is discouraged-- you would be better</span>
    <span class="s0">off specifying n in the keywords you use, but regardless it is</span>
    <span class="s0">there for you. n is needed for DateOffset subclasses.</span>

    <span class="s0">DateOffset works as follows.  Each offset specify a set of dates</span>
    <span class="s0">that conform to the DateOffset.  For example, Bday defines this</span>
    <span class="s0">set to be the set of dates that are weekdays (M-F).  To test if a</span>
    <span class="s0">date is in the set of a DateOffset dateOffset we can use the</span>
    <span class="s0">is_on_offset method: dateOffset.is_on_offset(date).</span>

    <span class="s0">If a date is not on a valid date, the rollback and rollforward</span>
    <span class="s0">methods can be used to roll the date to the nearest valid date</span>
    <span class="s0">before/after the date.</span>

    <span class="s0">DateOffsets can be created to move dates forward a given number of</span>
    <span class="s0">valid dates.  For example, Bday(2) can be added to a date to move</span>
    <span class="s0">it two business days forward.  If the date does not start on a</span>
    <span class="s0">valid date, first it is moved to a valid date.  Thus pseudo code</span>
    <span class="s0">is:</span>

    <span class="s0">def __add__(date):</span>
      <span class="s0">date = rollback(date) # does nothing if date is valid</span>
      <span class="s0">return date + &lt;n number of periods&gt;</span>

    <span class="s0">When a date offset is created for a negative number of periods,</span>
    <span class="s0">the date is first rolled forward.  The pseudo code is:</span>

    <span class="s0">def __add__(date):</span>
      <span class="s0">date = rollforward(date) # does nothing is date is valid</span>
      <span class="s0">return date + &lt;n number of periods&gt;</span>

    <span class="s0">Zero presents a problem.  Should it roll forward or back?  We</span>
    <span class="s0">arbitrarily have it rollforward:</span>

    <span class="s0">date + BDay(0) == BDay.rollforward(date)</span>

    <span class="s0">Since 0 is a bit weird, we suggest avoiding its use.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">n : int, default 1</span>
        <span class="s0">The number of time periods the offset represents.</span>
    <span class="s0">normalize : bool, default False</span>
        <span class="s0">Whether to round the result of a DateOffset addition down to the</span>
        <span class="s0">previous midnight.</span>
    <span class="s0">**kwds</span>
        <span class="s0">Temporal parameter that add to or replace the offset value.</span>

        <span class="s0">Parameters that **add** to the offset (like Timedelta):</span>

        <span class="s0">- years</span>
        <span class="s0">- months</span>
        <span class="s0">- weeks</span>
        <span class="s0">- days</span>
        <span class="s0">- hours</span>
        <span class="s0">- minutes</span>
        <span class="s0">- seconds</span>
        <span class="s0">- microseconds</span>
        <span class="s0">- nanoseconds</span>

        <span class="s0">Parameters that **replace** the offset value:</span>

        <span class="s0">- year</span>
        <span class="s0">- month</span>
        <span class="s0">- day</span>
        <span class="s0">- weekday</span>
        <span class="s0">- hour</span>
        <span class="s0">- minute</span>
        <span class="s0">- second</span>
        <span class="s0">- microsecond</span>
        <span class="s0">- nanosecond.</span>

    <span class="s0">See Also</span>
    <span class="s0">--------</span>
    <span class="s0">dateutil.relativedelta.relativedelta : The relativedelta type is designed</span>
        <span class="s0">to be applied to an existing datetime an can replace specific components of</span>
        <span class="s0">that datetime, or represents an interval of time.</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">&gt;&gt;&gt; from pandas.tseries.offsets import DateOffset</span>
    <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2017-01-01 09:10:11')</span>
    <span class="s0">&gt;&gt;&gt; ts + DateOffset(months=3)</span>
    <span class="s0">Timestamp('2017-04-01 09:10:11')</span>

    <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2017-01-01 09:10:11')</span>
    <span class="s0">&gt;&gt;&gt; ts + DateOffset(months=2)</span>
    <span class="s0">Timestamp('2017-03-01 09:10:11')</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">def __setattr__(self, name, value):</span>
        <span class="s0">raise AttributeError(&quot;DateOffset objects are immutable.&quot;)</span>

<span class="s0"># --------------------------------------------------------------------</span>


<span class="s0">cdef class BusinessMixin(SingleConstructorOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Mixin to business types to provide related functions.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">cdef readonly:</span>
        <span class="s0">timedelta _offset</span>
        <span class="s0"># Only Custom subclasses use weekmask, holiday, calendar</span>
        <span class="s0">object weekmask, holidays, calendar</span>

    <span class="s0">def __init__(self, n=1, normalize=False, offset=timedelta(0)):</span>
        <span class="s0">BaseOffset.__init__(self, n, normalize)</span>
        <span class="s0">self._offset = offset</span>

    <span class="s0">cpdef _init_custom(self, weekmask, holidays, calendar):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Additional __init__ for Custom subclasses.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">calendar, holidays = _get_calendar(</span>
            <span class="s0">weekmask=weekmask, holidays=holidays, calendar=calendar</span>
        <span class="s0">)</span>
        <span class="s0"># Custom offset instances are identified by the</span>
        <span class="s0"># following two attributes. See DateOffset._params()</span>
        <span class="s0"># holidays, weekmask</span>
        <span class="s0">self.weekmask = weekmask</span>
        <span class="s0">self.holidays = holidays</span>
        <span class="s0">self.calendar = calendar</span>

    <span class="s0">@property</span>
    <span class="s0">def offset(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Alias for self._offset.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0"># Alias for backward compat</span>
        <span class="s0">return self._offset</span>

    <span class="s0">def _repr_attrs(self) -&gt; str:</span>
        <span class="s0">if self.offset:</span>
            <span class="s0">attrs = [f&quot;offset={repr(self.offset)}&quot;]</span>
        <span class="s0">else:</span>
            <span class="s0">attrs = []</span>
        <span class="s0">out = &quot;&quot;</span>
        <span class="s0">if attrs:</span>
            <span class="s0">out += &quot;: &quot; + &quot;, &quot;.join(attrs)</span>
        <span class="s0">return out</span>

    <span class="s0">cpdef __setstate__(self, state):</span>
        <span class="s0"># We need to use a cdef/cpdef method to set the readonly _offset attribute</span>
        <span class="s0">if &quot;_offset&quot; in state:</span>
            <span class="s0">self._offset = state.pop(&quot;_offset&quot;)</span>
        <span class="s0">elif &quot;offset&quot; in state:</span>
            <span class="s0"># Older (&lt;0.22.0) versions have offset attribute instead of _offset</span>
            <span class="s0">self._offset = state.pop(&quot;offset&quot;)</span>

        <span class="s0">if self._prefix.startswith(&quot;C&quot;):</span>
            <span class="s0"># i.e. this is a Custom class</span>
            <span class="s0">weekmask = state.pop(&quot;weekmask&quot;)</span>
            <span class="s0">holidays = state.pop(&quot;holidays&quot;)</span>
            <span class="s0">calendar, holidays = _get_calendar(weekmask=weekmask,</span>
                                               <span class="s0">holidays=holidays,</span>
                                               <span class="s0">calendar=None)</span>
            <span class="s0">self.weekmask = weekmask</span>
            <span class="s0">self.calendar = calendar</span>
            <span class="s0">self.holidays = holidays</span>

        <span class="s0">BaseOffset.__setstate__(self, state)</span>


<span class="s0">cdef class BusinessDay(BusinessMixin):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset subclass representing possibly n business days.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">_period_dtype_code = PeriodDtypeCode.B</span>
    <span class="s0">_prefix = &quot;B&quot;</span>
    <span class="s0">_attributes = tuple([&quot;n&quot;, &quot;normalize&quot;, &quot;offset&quot;])</span>

    <span class="s0">cpdef __setstate__(self, state):</span>
        <span class="s0">self.n = state.pop(&quot;n&quot;)</span>
        <span class="s0">self.normalize = state.pop(&quot;normalize&quot;)</span>
        <span class="s0">if &quot;_offset&quot; in state:</span>
            <span class="s0">self._offset = state.pop(&quot;_offset&quot;)</span>
        <span class="s0">elif &quot;offset&quot; in state:</span>
            <span class="s0">self._offset = state.pop(&quot;offset&quot;)</span>
        <span class="s0">self._cache = state.pop(&quot;_cache&quot;, {})</span>

    <span class="s0">def _offset_str(self) -&gt; str:</span>
        <span class="s0">def get_str(td):</span>
            <span class="s0">off_str = &quot;&quot;</span>
            <span class="s0">if td.days &gt; 0:</span>
                <span class="s0">off_str += str(td.days) + &quot;D&quot;</span>
            <span class="s0">if td.seconds &gt; 0:</span>
                <span class="s0">s = td.seconds</span>
                <span class="s0">hrs = int(s / 3600)</span>
                <span class="s0">if hrs != 0:</span>
                    <span class="s0">off_str += str(hrs) + &quot;H&quot;</span>
                    <span class="s0">s -= hrs * 3600</span>
                <span class="s0">mts = int(s / 60)</span>
                <span class="s0">if mts != 0:</span>
                    <span class="s0">off_str += str(mts) + &quot;Min&quot;</span>
                    <span class="s0">s -= mts * 60</span>
                <span class="s0">if s != 0:</span>
                    <span class="s0">off_str += str(s) + &quot;s&quot;</span>
            <span class="s0">if td.microseconds &gt; 0:</span>
                <span class="s0">off_str += str(td.microseconds) + &quot;us&quot;</span>
            <span class="s0">return off_str</span>

        <span class="s0">if PyDelta_Check(self.offset):</span>
            <span class="s0">zero = timedelta(0, 0, 0)</span>
            <span class="s0">if self.offset &gt;= zero:</span>
                <span class="s0">off_str = &quot;+&quot; + get_str(self.offset)</span>
            <span class="s0">else:</span>
                <span class="s0">off_str = &quot;-&quot; + get_str(-self.offset)</span>
            <span class="s0">return off_str</span>
        <span class="s0">else:</span>
            <span class="s0">return &quot;+&quot; + repr(self.offset)</span>

    <span class="s0">@apply_wraps</span>
    <span class="s0">def _apply(self, other):</span>
        <span class="s0">if PyDateTime_Check(other):</span>
            <span class="s0">n = self.n</span>
            <span class="s0">wday = other.weekday()</span>

            <span class="s0"># avoid slowness below by operating on weeks first</span>
            <span class="s0">weeks = n // 5</span>
            <span class="s0">if n &lt;= 0 and wday &gt; 4:</span>
                <span class="s0"># roll forward</span>
                <span class="s0">n += 1</span>

            <span class="s0">n -= 5 * weeks</span>

            <span class="s0"># n is always &gt;= 0 at this point</span>
            <span class="s0">if n == 0 and wday &gt; 4:</span>
                <span class="s0"># roll back</span>
                <span class="s0">days = 4 - wday</span>
            <span class="s0">elif wday &gt; 4:</span>
                <span class="s0"># roll forward</span>
                <span class="s0">days = (7 - wday) + (n - 1)</span>
            <span class="s0">elif wday + n &lt;= 4:</span>
                <span class="s0"># shift by n days without leaving the current week</span>
                <span class="s0">days = n</span>
            <span class="s0">else:</span>
                <span class="s0"># shift by n days plus 2 to get past the weekend</span>
                <span class="s0">days = n + 2</span>

            <span class="s0">result = other + timedelta(days=7 * weeks + days)</span>
            <span class="s0">if self.offset:</span>
                <span class="s0">result = result + self.offset</span>
            <span class="s0">return result</span>

        <span class="s0">elif is_any_td_scalar(other):</span>
            <span class="s0">td = Timedelta(self.offset) + other</span>
            <span class="s0">return BusinessDay(</span>
                <span class="s0">self.n, offset=td.to_pytimedelta(), normalize=self.normalize</span>
            <span class="s0">)</span>
        <span class="s0">else:</span>
            <span class="s0">raise ApplyTypeError(</span>
                <span class="s0">&quot;Only know how to combine business day with datetime or timedelta.&quot;</span>
            <span class="s0">)</span>

    <span class="s0">@apply_index_wraps</span>
    <span class="s0">def apply_index(self, dtindex):</span>
        <span class="s0">return self._apply_array(dtindex)</span>

    <span class="s0">@apply_array_wraps</span>
    <span class="s0">def _apply_array(self, dtarr):</span>
        <span class="s0">i8other = dtarr.view(&quot;i8&quot;)</span>
        <span class="s0">res = _shift_bdays(i8other, self.n)</span>
        <span class="s0">if self.offset:</span>
            <span class="s0">res = res.view(&quot;M8[ns]&quot;) + Timedelta(self.offset)</span>
            <span class="s0">res = res.view(&quot;i8&quot;)</span>
        <span class="s0">return res</span>

    <span class="s0">def is_on_offset(self, dt: datetime) -&gt; bool:</span>
        <span class="s0">if self.normalize and not _is_normalized(dt):</span>
            <span class="s0">return False</span>
        <span class="s0">return dt.weekday() &lt; 5</span>


<span class="s0">cdef class BusinessHour(BusinessMixin):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset subclass representing possibly n business hours.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">n : int, default 1</span>
        <span class="s0">The number of months represented.</span>
    <span class="s0">normalize : bool, default False</span>
        <span class="s0">Normalize start/end dates to midnight before generating date range.</span>
    <span class="s0">weekmask : str, Default 'Mon Tue Wed Thu Fri'</span>
        <span class="s0">Weekmask of valid business days, passed to ``numpy.busdaycalendar``.</span>
    <span class="s0">start : str, default &quot;09:00&quot;</span>
        <span class="s0">Start time of your custom business hour in 24h format.</span>
    <span class="s0">end : str, default: &quot;17:00&quot;</span>
        <span class="s0">End time of your custom business hour in 24h format.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">_prefix = &quot;BH&quot;</span>
    <span class="s0">_anchor = 0</span>
    <span class="s0">_attributes = tuple([&quot;n&quot;, &quot;normalize&quot;, &quot;start&quot;, &quot;end&quot;, &quot;offset&quot;])</span>
    <span class="s0">_adjust_dst = False</span>

    <span class="s0">cdef readonly:</span>
        <span class="s0">tuple start, end</span>

    <span class="s0">def __init__(</span>
            <span class="s0">self, n=1, normalize=False, start=&quot;09:00&quot;, end=&quot;17:00&quot;, offset=timedelta(0)</span>
    <span class="s0">):</span>
        <span class="s0">BusinessMixin.__init__(self, n, normalize, offset)</span>

        <span class="s0"># must be validated here to equality check</span>
        <span class="s0">if np.ndim(start) == 0:</span>
            <span class="s0"># i.e. not is_list_like</span>
            <span class="s0">start = [start]</span>
        <span class="s0">if not len(start):</span>
            <span class="s0">raise ValueError(&quot;Must include at least 1 start time&quot;)</span>

        <span class="s0">if np.ndim(end) == 0:</span>
            <span class="s0"># i.e. not is_list_like</span>
            <span class="s0">end = [end]</span>
        <span class="s0">if not len(end):</span>
            <span class="s0">raise ValueError(&quot;Must include at least 1 end time&quot;)</span>

        <span class="s0">start = np.array([_validate_business_time(x) for x in start])</span>
        <span class="s0">end = np.array([_validate_business_time(x) for x in end])</span>

        <span class="s0"># Validation of input</span>
        <span class="s0">if len(start) != len(end):</span>
            <span class="s0">raise ValueError(&quot;number of starting time and ending time must be the same&quot;)</span>
        <span class="s0">num_openings = len(start)</span>

        <span class="s0"># sort starting and ending time by starting time</span>
        <span class="s0">index = np.argsort(start)</span>

        <span class="s0"># convert to tuple so that start and end are hashable</span>
        <span class="s0">start = tuple(start[index])</span>
        <span class="s0">end = tuple(end[index])</span>

        <span class="s0">total_secs = 0</span>
        <span class="s0">for i in range(num_openings):</span>
            <span class="s0">total_secs += self._get_business_hours_by_sec(start[i], end[i])</span>
            <span class="s0">total_secs += self._get_business_hours_by_sec(</span>
                <span class="s0">end[i], start[(i + 1) % num_openings]</span>
            <span class="s0">)</span>
        <span class="s0">if total_secs != 24 * 60 * 60:</span>
            <span class="s0">raise ValueError(</span>
                <span class="s0">&quot;invalid starting and ending time(s): &quot;</span>
                <span class="s0">&quot;opening hours should not touch or overlap with &quot;</span>
                <span class="s0">&quot;one another&quot;</span>
            <span class="s0">)</span>

        <span class="s0">self.start = start</span>
        <span class="s0">self.end = end</span>

    <span class="s0">cpdef __setstate__(self, state):</span>
        <span class="s0">start = state.pop(&quot;start&quot;)</span>
        <span class="s0">start = (start,) if np.ndim(start) == 0 else tuple(start)</span>
        <span class="s0">end = state.pop(&quot;end&quot;)</span>
        <span class="s0">end = (end,) if np.ndim(end) == 0 else tuple(end)</span>
        <span class="s0">self.start = start</span>
        <span class="s0">self.end = end</span>

        <span class="s0">state.pop(&quot;kwds&quot;, {})</span>
        <span class="s0">state.pop(&quot;next_bday&quot;, None)</span>
        <span class="s0">BusinessMixin.__setstate__(self, state)</span>

    <span class="s0">def _repr_attrs(self) -&gt; str:</span>
        <span class="s0">out = super()._repr_attrs()</span>
        <span class="s0">hours = &quot;,&quot;.join(</span>
            <span class="s0">f'{st.strftime(&quot;%H:%M&quot;)}-{en.strftime(&quot;%H:%M&quot;)}'</span>
            <span class="s0">for st, en in zip(self.start, self.end)</span>
        <span class="s0">)</span>
        <span class="s0">attrs = [f&quot;{self._prefix}={hours}&quot;]</span>
        <span class="s0">out += &quot;: &quot; + &quot;, &quot;.join(attrs)</span>
        <span class="s0">return out</span>

    <span class="s0">def _get_business_hours_by_sec(self, start, end):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Return business hours in a day by seconds.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0"># create dummy datetime to calculate business hours in a day</span>
        <span class="s0">dtstart = datetime(2014, 4, 1, start.hour, start.minute)</span>
        <span class="s0">day = 1 if start &lt; end else 2</span>
        <span class="s0">until = datetime(2014, 4, day, end.hour, end.minute)</span>
        <span class="s0">return int((until - dtstart).total_seconds())</span>

    <span class="s0">def _get_closing_time(self, dt: datetime) -&gt; datetime:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Get the closing time of a business hour interval by its opening time.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">dt : datetime</span>
            <span class="s0">Opening time of a business hour interval.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">result : datetime</span>
            <span class="s0">Corresponding closing time.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">for i, st in enumerate(self.start):</span>
            <span class="s0">if st.hour == dt.hour and st.minute == dt.minute:</span>
                <span class="s0">return dt + timedelta(</span>
                    <span class="s0">seconds=self._get_business_hours_by_sec(st, self.end[i])</span>
                <span class="s0">)</span>
        <span class="s0">assert False</span>

    <span class="s0">@cache_readonly</span>
    <span class="s0">def next_bday(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Used for moving to next business day.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self.n &gt;= 0:</span>
            <span class="s0">nb_offset = 1</span>
        <span class="s0">else:</span>
            <span class="s0">nb_offset = -1</span>
        <span class="s0">if self._prefix.startswith(&quot;C&quot;):</span>
            <span class="s0"># CustomBusinessHour</span>
            <span class="s0">return CustomBusinessDay(</span>
                <span class="s0">n=nb_offset,</span>
                <span class="s0">weekmask=self.weekmask,</span>
                <span class="s0">holidays=self.holidays,</span>
                <span class="s0">calendar=self.calendar,</span>
            <span class="s0">)</span>
        <span class="s0">else:</span>
            <span class="s0">return BusinessDay(n=nb_offset)</span>

    <span class="s0">def _next_opening_time(self, other, sign=1):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">If self.n and sign have the same sign, return the earliest opening time</span>
        <span class="s0">later than or equal to current time.</span>
        <span class="s0">Otherwise the latest opening time earlier than or equal to current</span>
        <span class="s0">time.</span>

        <span class="s0">Opening time always locates on BusinessDay.</span>
        <span class="s0">However, closing time may not if business hour extends over midnight.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">other : datetime</span>
            <span class="s0">Current time.</span>
        <span class="s0">sign : int, default 1.</span>
            <span class="s0">Either 1 or -1. Going forward in time if it has the same sign as</span>
            <span class="s0">self.n. Going backward in time otherwise.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">result : datetime</span>
            <span class="s0">Next opening time.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">earliest_start = self.start[0]</span>
        <span class="s0">latest_start = self.start[-1]</span>

        <span class="s0">if not self.next_bday.is_on_offset(other):</span>
            <span class="s0"># today is not business day</span>
            <span class="s0">other = other + sign * self.next_bday</span>
            <span class="s0">if self.n * sign &gt;= 0:</span>
                <span class="s0">hour, minute = earliest_start.hour, earliest_start.minute</span>
            <span class="s0">else:</span>
                <span class="s0">hour, minute = latest_start.hour, latest_start.minute</span>
        <span class="s0">else:</span>
            <span class="s0">if self.n * sign &gt;= 0:</span>
                <span class="s0">if latest_start &lt; other.time():</span>
                    <span class="s0"># current time is after latest starting time in today</span>
                    <span class="s0">other = other + sign * self.next_bday</span>
                    <span class="s0">hour, minute = earliest_start.hour, earliest_start.minute</span>
                <span class="s0">else:</span>
                    <span class="s0"># find earliest starting time no earlier than current time</span>
                    <span class="s0">for st in self.start:</span>
                        <span class="s0">if other.time() &lt;= st:</span>
                            <span class="s0">hour, minute = st.hour, st.minute</span>
                            <span class="s0">break</span>
            <span class="s0">else:</span>
                <span class="s0">if other.time() &lt; earliest_start:</span>
                    <span class="s0"># current time is before earliest starting time in today</span>
                    <span class="s0">other = other + sign * self.next_bday</span>
                    <span class="s0">hour, minute = latest_start.hour, latest_start.minute</span>
                <span class="s0">else:</span>
                    <span class="s0"># find latest starting time no later than current time</span>
                    <span class="s0">for st in reversed(self.start):</span>
                        <span class="s0">if other.time() &gt;= st:</span>
                            <span class="s0">hour, minute = st.hour, st.minute</span>
                            <span class="s0">break</span>

        <span class="s0">return datetime(other.year, other.month, other.day, hour, minute)</span>

    <span class="s0">def _prev_opening_time(self, other: datetime) -&gt; datetime:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">If n is positive, return the latest opening time earlier than or equal</span>
        <span class="s0">to current time.</span>
        <span class="s0">Otherwise the earliest opening time later than or equal to current</span>
        <span class="s0">time.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">other : datetime</span>
            <span class="s0">Current time.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">result : datetime</span>
            <span class="s0">Previous opening time.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self._next_opening_time(other, sign=-1)</span>

    <span class="s0">@apply_wraps</span>
    <span class="s0">def rollback(self, dt: datetime) -&gt; datetime:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Roll provided date backward to next offset only if not on offset.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if not self.is_on_offset(dt):</span>
            <span class="s0">if self.n &gt;= 0:</span>
                <span class="s0">dt = self._prev_opening_time(dt)</span>
            <span class="s0">else:</span>
                <span class="s0">dt = self._next_opening_time(dt)</span>
            <span class="s0">return self._get_closing_time(dt)</span>
        <span class="s0">return dt</span>

    <span class="s0">@apply_wraps</span>
    <span class="s0">def rollforward(self, dt: datetime) -&gt; datetime:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Roll provided date forward to next offset only if not on offset.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if not self.is_on_offset(dt):</span>
            <span class="s0">if self.n &gt;= 0:</span>
                <span class="s0">return self._next_opening_time(dt)</span>
            <span class="s0">else:</span>
                <span class="s0">return self._prev_opening_time(dt)</span>
        <span class="s0">return dt</span>

    <span class="s0">@apply_wraps</span>
    <span class="s0">def _apply(self, other: datetime) -&gt; datetime:</span>
        <span class="s0"># used for detecting edge condition</span>
        <span class="s0">nanosecond = getattr(other, &quot;nanosecond&quot;, 0)</span>
        <span class="s0"># reset timezone and nanosecond</span>
        <span class="s0"># other may be a Timestamp, thus not use replace</span>
        <span class="s0">other = datetime(</span>
            <span class="s0">other.year,</span>
            <span class="s0">other.month,</span>
            <span class="s0">other.day,</span>
            <span class="s0">other.hour,</span>
            <span class="s0">other.minute,</span>
            <span class="s0">other.second,</span>
            <span class="s0">other.microsecond,</span>
        <span class="s0">)</span>
        <span class="s0">n = self.n</span>

        <span class="s0"># adjust other to reduce number of cases to handle</span>
        <span class="s0">if n &gt;= 0:</span>
            <span class="s0">if other.time() in self.end or not self._is_on_offset(other):</span>
                <span class="s0">other = self._next_opening_time(other)</span>
        <span class="s0">else:</span>
            <span class="s0">if other.time() in self.start:</span>
                <span class="s0"># adjustment to move to previous business day</span>
                <span class="s0">other = other - timedelta(seconds=1)</span>
            <span class="s0">if not self._is_on_offset(other):</span>
                <span class="s0">other = self._next_opening_time(other)</span>
                <span class="s0">other = self._get_closing_time(other)</span>

        <span class="s0"># get total business hours by sec in one business day</span>
        <span class="s0">businesshours = sum(</span>
            <span class="s0">self._get_business_hours_by_sec(st, en)</span>
            <span class="s0">for st, en in zip(self.start, self.end)</span>
        <span class="s0">)</span>

        <span class="s0">bd, r = divmod(abs(n * 60), businesshours // 60)</span>
        <span class="s0">if n &lt; 0:</span>
            <span class="s0">bd, r = -bd, -r</span>

        <span class="s0"># adjust by business days first</span>
        <span class="s0">if bd != 0:</span>
            <span class="s0">if self._prefix.startswith(&quot;C&quot;):</span>
                <span class="s0"># GH#30593 this is a Custom offset</span>
                <span class="s0">skip_bd = CustomBusinessDay(</span>
                    <span class="s0">n=bd,</span>
                    <span class="s0">weekmask=self.weekmask,</span>
                    <span class="s0">holidays=self.holidays,</span>
                    <span class="s0">calendar=self.calendar,</span>
                <span class="s0">)</span>
            <span class="s0">else:</span>
                <span class="s0">skip_bd = BusinessDay(n=bd)</span>
            <span class="s0"># midnight business hour may not on BusinessDay</span>
            <span class="s0">if not self.next_bday.is_on_offset(other):</span>
                <span class="s0">prev_open = self._prev_opening_time(other)</span>
                <span class="s0">remain = other - prev_open</span>
                <span class="s0">other = prev_open + skip_bd + remain</span>
            <span class="s0">else:</span>
                <span class="s0">other = other + skip_bd</span>

        <span class="s0"># remaining business hours to adjust</span>
        <span class="s0">bhour_remain = timedelta(minutes=r)</span>

        <span class="s0">if n &gt;= 0:</span>
            <span class="s0">while bhour_remain != timedelta(0):</span>
                <span class="s0"># business hour left in this business time interval</span>
                <span class="s0">bhour = (</span>
                    <span class="s0">self._get_closing_time(self._prev_opening_time(other)) - other</span>
                <span class="s0">)</span>
                <span class="s0">if bhour_remain &lt; bhour:</span>
                    <span class="s0"># finish adjusting if possible</span>
                    <span class="s0">other += bhour_remain</span>
                    <span class="s0">bhour_remain = timedelta(0)</span>
                <span class="s0">else:</span>
                    <span class="s0"># go to next business time interval</span>
                    <span class="s0">bhour_remain -= bhour</span>
                    <span class="s0">other = self._next_opening_time(other + bhour)</span>
        <span class="s0">else:</span>
            <span class="s0">while bhour_remain != timedelta(0):</span>
                <span class="s0"># business hour left in this business time interval</span>
                <span class="s0">bhour = self._next_opening_time(other) - other</span>
                <span class="s0">if (</span>
                    <span class="s0">bhour_remain &gt; bhour</span>
                    <span class="s0">or bhour_remain == bhour</span>
                    <span class="s0">and nanosecond != 0</span>
                <span class="s0">):</span>
                    <span class="s0"># finish adjusting if possible</span>
                    <span class="s0">other += bhour_remain</span>
                    <span class="s0">bhour_remain = timedelta(0)</span>
                <span class="s0">else:</span>
                    <span class="s0"># go to next business time interval</span>
                    <span class="s0">bhour_remain -= bhour</span>
                    <span class="s0">other = self._get_closing_time(</span>
                        <span class="s0">self._next_opening_time(</span>
                            <span class="s0">other + bhour - timedelta(seconds=1)</span>
                        <span class="s0">)</span>
                    <span class="s0">)</span>

        <span class="s0">return other</span>

    <span class="s0">def is_on_offset(self, dt: datetime) -&gt; bool:</span>
        <span class="s0">if self.normalize and not _is_normalized(dt):</span>
            <span class="s0">return False</span>

        <span class="s0">if dt.tzinfo is not None:</span>
            <span class="s0">dt = datetime(</span>
                <span class="s0">dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second, dt.microsecond</span>
            <span class="s0">)</span>
        <span class="s0"># Valid BH can be on the different BusinessDay during midnight</span>
        <span class="s0"># Distinguish by the time spent from previous opening time</span>
        <span class="s0">return self._is_on_offset(dt)</span>

    <span class="s0">def _is_on_offset(self, dt: datetime) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Slight speedups using calculated values.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0"># if self.normalize and not _is_normalized(dt):</span>
        <span class="s0">#     return False</span>
        <span class="s0"># Valid BH can be on the different BusinessDay during midnight</span>
        <span class="s0"># Distinguish by the time spent from previous opening time</span>
        <span class="s0">if self.n &gt;= 0:</span>
            <span class="s0">op = self._prev_opening_time(dt)</span>
        <span class="s0">else:</span>
            <span class="s0">op = self._next_opening_time(dt)</span>
        <span class="s0">span = (dt - op).total_seconds()</span>
        <span class="s0">businesshours = 0</span>
        <span class="s0">for i, st in enumerate(self.start):</span>
            <span class="s0">if op.hour == st.hour and op.minute == st.minute:</span>
                <span class="s0">businesshours = self._get_business_hours_by_sec(st, self.end[i])</span>
        <span class="s0">if span &lt;= businesshours:</span>
            <span class="s0">return True</span>
        <span class="s0">else:</span>
            <span class="s0">return False</span>


<span class="s0">cdef class WeekOfMonthMixin(SingleConstructorOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Mixin for methods common to WeekOfMonth and LastWeekOfMonth.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">cdef readonly:</span>
        <span class="s0">int weekday, week</span>

    <span class="s0">def __init__(self, n=1, normalize=False, weekday=0):</span>
        <span class="s0">BaseOffset.__init__(self, n, normalize)</span>
        <span class="s0">self.weekday = weekday</span>

        <span class="s0">if weekday &lt; 0 or weekday &gt; 6:</span>
            <span class="s0">raise ValueError(f&quot;Day must be 0&lt;=day&lt;=6, got {weekday}&quot;)</span>

    <span class="s0">@apply_wraps</span>
    <span class="s0">def _apply(self, other: datetime) -&gt; datetime:</span>
        <span class="s0">compare_day = self._get_offset_day(other)</span>

        <span class="s0">months = self.n</span>
        <span class="s0">months = roll_convention(other.day, months, compare_day)</span>

        <span class="s0">shifted = shift_month(other, months, &quot;start&quot;)</span>
        <span class="s0">to_day = self._get_offset_day(shifted)</span>
        <span class="s0">return shift_day(shifted, to_day - shifted.day)</span>

    <span class="s0">def is_on_offset(self, dt: datetime) -&gt; bool:</span>
        <span class="s0">if self.normalize and not _is_normalized(dt):</span>
            <span class="s0">return False</span>
        <span class="s0">return dt.day == self._get_offset_day(dt)</span>

    <span class="s0">@property</span>
    <span class="s0">def rule_code(self) -&gt; str:</span>
        <span class="s0">weekday = int_to_weekday.get(self.weekday, &quot;&quot;)</span>
        <span class="s0">if self.week == -1:</span>
            <span class="s0"># LastWeekOfMonth</span>
            <span class="s0">return f&quot;{self._prefix}-{weekday}&quot;</span>
        <span class="s0">return f&quot;{self._prefix}-{self.week + 1}{weekday}&quot;</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Year-Based Offset Classes</span>

<span class="s0">cdef class YearOffset(SingleConstructorOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset that just needs a month.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">_attributes = tuple([&quot;n&quot;, &quot;normalize&quot;, &quot;month&quot;])</span>

    <span class="s0"># FIXME(cython#4446): python annotation here gives compile-time errors</span>
    <span class="s0"># _default_month: int</span>

    <span class="s0">cdef readonly:</span>
        <span class="s0">int month</span>

    <span class="s0">def __init__(self, n=1, normalize=False, month=None):</span>
        <span class="s0">BaseOffset.__init__(self, n, normalize)</span>

        <span class="s0">month = month if month is not None else self._default_month</span>
        <span class="s0">self.month = month</span>

        <span class="s0">if month &lt; 1 or month &gt; 12:</span>
            <span class="s0">raise ValueError(&quot;Month must go from 1 to 12&quot;)</span>

    <span class="s0">cpdef __setstate__(self, state):</span>
        <span class="s0">self.month = state.pop(&quot;month&quot;)</span>
        <span class="s0">self.n = state.pop(&quot;n&quot;)</span>
        <span class="s0">self.normalize = state.pop(&quot;normalize&quot;)</span>
        <span class="s0">self._cache = {}</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def _from_name(cls, suffix=None):</span>
        <span class="s0">kwargs = {}</span>
        <span class="s0">if suffix:</span>
            <span class="s0">kwargs[&quot;month&quot;] = MONTH_TO_CAL_NUM[suffix]</span>
        <span class="s0">return cls(**kwargs)</span>

    <span class="s0">@property</span>
    <span class="s0">def rule_code(self) -&gt; str:</span>
        <span class="s0">month = MONTH_ALIASES[self.month]</span>
        <span class="s0">return f&quot;{self._prefix}-{month}&quot;</span>

    <span class="s0">def is_on_offset(self, dt: datetime) -&gt; bool:</span>
        <span class="s0">if self.normalize and not _is_normalized(dt):</span>
            <span class="s0">return False</span>
        <span class="s0">return dt.month == self.month and dt.day == self._get_offset_day(dt)</span>

    <span class="s0">def _get_offset_day(self, other: datetime) -&gt; int:</span>
        <span class="s0"># override BaseOffset method to use self.month instead of other.month</span>
        <span class="s0">cdef:</span>
            <span class="s0">npy_datetimestruct dts</span>
        <span class="s0">pydate_to_dtstruct(other, &amp;dts)</span>
        <span class="s0">dts.month = self.month</span>
        <span class="s0">return get_day_of_month(&amp;dts, self._day_opt)</span>

    <span class="s0">@apply_wraps</span>
    <span class="s0">def _apply(self, other: datetime) -&gt; datetime:</span>
        <span class="s0">years = roll_qtrday(other, self.n, self.month, self._day_opt, modby=12)</span>
        <span class="s0">months = years * 12 + (self.month - other.month)</span>
        <span class="s0">return shift_month(other, months, self._day_opt)</span>

    <span class="s0">@apply_index_wraps</span>
    <span class="s0">def apply_index(self, dtindex):</span>
        <span class="s0">return self._apply_array(dtindex)</span>

    <span class="s0">@apply_array_wraps</span>
    <span class="s0">def _apply_array(self, dtarr):</span>
        <span class="s0">shifted = shift_quarters(</span>
            <span class="s0">dtarr.view(&quot;i8&quot;), self.n, self.month, self._day_opt, modby=12</span>
        <span class="s0">)</span>
        <span class="s0">return shifted</span>


<span class="s0">cdef class BYearEnd(YearOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset increments between the last business day of the year.</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">&gt;&gt;&gt; from pandas.tseries.offsets import BYearEnd</span>
    <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-05-24 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts - BYearEnd()</span>
    <span class="s0">Timestamp('2019-12-31 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BYearEnd()</span>
    <span class="s0">Timestamp('2020-12-31 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BYearEnd(3)</span>
    <span class="s0">Timestamp('2022-12-30 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BYearEnd(-3)</span>
    <span class="s0">Timestamp('2017-12-29 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BYearEnd(month=11)</span>
    <span class="s0">Timestamp('2020-11-30 05:01:15')</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">_outputName = &quot;BusinessYearEnd&quot;</span>
    <span class="s0">_default_month = 12</span>
    <span class="s0">_prefix = &quot;BA&quot;</span>
    <span class="s0">_day_opt = &quot;business_end&quot;</span>


<span class="s0">cdef class BYearBegin(YearOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset increments between the first business day of the year.</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">&gt;&gt;&gt; from pandas.tseries.offsets import BYearBegin</span>
    <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-05-24 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BYearBegin()</span>
    <span class="s0">Timestamp('2021-01-01 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts - BYearBegin()</span>
    <span class="s0">Timestamp('2020-01-01 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BYearBegin(-1)</span>
    <span class="s0">Timestamp('2020-01-01 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BYearBegin(2)</span>
    <span class="s0">Timestamp('2022-01-03 05:01:15')</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">_outputName = &quot;BusinessYearBegin&quot;</span>
    <span class="s0">_default_month = 1</span>
    <span class="s0">_prefix = &quot;BAS&quot;</span>
    <span class="s0">_day_opt = &quot;business_start&quot;</span>


<span class="s0">cdef class YearEnd(YearOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset increments between calendar year ends.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">_default_month = 12</span>
    <span class="s0">_prefix = &quot;A&quot;</span>
    <span class="s0">_day_opt = &quot;end&quot;</span>

    <span class="s0">cdef readonly:</span>
        <span class="s0">int _period_dtype_code</span>

    <span class="s0">def __init__(self, n=1, normalize=False, month=None):</span>
        <span class="s0"># Because YearEnd can be the freq for a Period, define its</span>
        <span class="s0">#  _period_dtype_code at construction for performance</span>
        <span class="s0">YearOffset.__init__(self, n, normalize, month)</span>
        <span class="s0">self._period_dtype_code = PeriodDtypeCode.A + self.month % 12</span>


<span class="s0">cdef class YearBegin(YearOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset increments between calendar year begin dates.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">_default_month = 1</span>
    <span class="s0">_prefix = &quot;AS&quot;</span>
    <span class="s0">_day_opt = &quot;start&quot;</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Quarter-Based Offset Classes</span>

<span class="s0">cdef class QuarterOffset(SingleConstructorOffset):</span>
    <span class="s0">_attributes = tuple([&quot;n&quot;, &quot;normalize&quot;, &quot;startingMonth&quot;])</span>
    <span class="s0"># TODO: Consider combining QuarterOffset and YearOffset __init__ at some</span>
    <span class="s0">#       point.  Also apply_index, is_on_offset, rule_code if</span>
    <span class="s0">#       startingMonth vs month attr names are resolved</span>

    <span class="s0"># FIXME(cython#4446): python annotation here gives compile-time errors</span>
    <span class="s0"># _default_starting_month: int</span>
    <span class="s0"># _from_name_starting_month: int</span>

    <span class="s0">cdef readonly:</span>
        <span class="s0">int startingMonth</span>

    <span class="s0">def __init__(self, n=1, normalize=False, startingMonth=None):</span>
        <span class="s0">BaseOffset.__init__(self, n, normalize)</span>

        <span class="s0">if startingMonth is None:</span>
            <span class="s0">startingMonth = self._default_starting_month</span>
        <span class="s0">self.startingMonth = startingMonth</span>

    <span class="s0">cpdef __setstate__(self, state):</span>
        <span class="s0">self.startingMonth = state.pop(&quot;startingMonth&quot;)</span>
        <span class="s0">self.n = state.pop(&quot;n&quot;)</span>
        <span class="s0">self.normalize = state.pop(&quot;normalize&quot;)</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def _from_name(cls, suffix=None):</span>
        <span class="s0">kwargs = {}</span>
        <span class="s0">if suffix:</span>
            <span class="s0">kwargs[&quot;startingMonth&quot;] = MONTH_TO_CAL_NUM[suffix]</span>
        <span class="s0">else:</span>
            <span class="s0">if cls._from_name_starting_month is not None:</span>
                <span class="s0">kwargs[&quot;startingMonth&quot;] = cls._from_name_starting_month</span>
        <span class="s0">return cls(**kwargs)</span>

    <span class="s0">@property</span>
    <span class="s0">def rule_code(self) -&gt; str:</span>
        <span class="s0">month = MONTH_ALIASES[self.startingMonth]</span>
        <span class="s0">return f&quot;{self._prefix}-{month}&quot;</span>

    <span class="s0">def is_anchored(self) -&gt; bool:</span>
        <span class="s0">return self.n == 1 and self.startingMonth is not None</span>

    <span class="s0">def is_on_offset(self, dt: datetime) -&gt; bool:</span>
        <span class="s0">if self.normalize and not _is_normalized(dt):</span>
            <span class="s0">return False</span>
        <span class="s0">mod_month = (dt.month - self.startingMonth) % 3</span>
        <span class="s0">return mod_month == 0 and dt.day == self._get_offset_day(dt)</span>

    <span class="s0">@apply_wraps</span>
    <span class="s0">def _apply(self, other: datetime) -&gt; datetime:</span>
        <span class="s0"># months_since: find the calendar quarter containing other.month,</span>
        <span class="s0"># e.g. if other.month == 8, the calendar quarter is [Jul, Aug, Sep].</span>
        <span class="s0"># Then find the month in that quarter containing an is_on_offset date for</span>
        <span class="s0"># self.  `months_since` is the number of months to shift other.month</span>
        <span class="s0"># to get to this on-offset month.</span>
        <span class="s0">months_since = other.month % 3 - self.startingMonth % 3</span>
        <span class="s0">qtrs = roll_qtrday(</span>
            <span class="s0">other, self.n, self.startingMonth, day_opt=self._day_opt, modby=3</span>
        <span class="s0">)</span>
        <span class="s0">months = qtrs * 3 - months_since</span>
        <span class="s0">return shift_month(other, months, self._day_opt)</span>

    <span class="s0">@apply_index_wraps</span>
    <span class="s0">def apply_index(self, dtindex):</span>
        <span class="s0">return self._apply_array(dtindex)</span>

    <span class="s0">@apply_array_wraps</span>
    <span class="s0">def _apply_array(self, dtarr):</span>
        <span class="s0">shifted = shift_quarters(</span>
            <span class="s0">dtarr.view(&quot;i8&quot;), self.n, self.startingMonth, self._day_opt</span>
        <span class="s0">)</span>
        <span class="s0">return shifted</span>


<span class="s0">cdef class BQuarterEnd(QuarterOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset increments between the last business day of each Quarter.</span>

    <span class="s0">startingMonth = 1 corresponds to dates like 1/31/2007, 4/30/2007, ...</span>
    <span class="s0">startingMonth = 2 corresponds to dates like 2/28/2007, 5/31/2007, ...</span>
    <span class="s0">startingMonth = 3 corresponds to dates like 3/30/2007, 6/29/2007, ...</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">&gt;&gt;&gt; from pandas.tseries.offsets import BQuarterEnd</span>
    <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-05-24 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BQuarterEnd()</span>
    <span class="s0">Timestamp('2020-06-30 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BQuarterEnd(2)</span>
    <span class="s0">Timestamp('2020-09-30 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BQuarterEnd(1, startingMonth=2)</span>
    <span class="s0">Timestamp('2020-05-29 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BQuarterEnd(startingMonth=2)</span>
    <span class="s0">Timestamp('2020-05-29 05:01:15')</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">_output_name = &quot;BusinessQuarterEnd&quot;</span>
    <span class="s0">_default_starting_month = 3</span>
    <span class="s0">_from_name_starting_month = 12</span>
    <span class="s0">_prefix = &quot;BQ&quot;</span>
    <span class="s0">_day_opt = &quot;business_end&quot;</span>


<span class="s0">cdef class BQuarterBegin(QuarterOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset increments between the first business day of each Quarter.</span>

    <span class="s0">startingMonth = 1 corresponds to dates like 1/01/2007, 4/01/2007, ...</span>
    <span class="s0">startingMonth = 2 corresponds to dates like 2/01/2007, 5/01/2007, ...</span>
    <span class="s0">startingMonth = 3 corresponds to dates like 3/01/2007, 6/01/2007, ...</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">&gt;&gt;&gt; from pandas.tseries.offsets import BQuarterBegin</span>
    <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-05-24 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BQuarterBegin()</span>
    <span class="s0">Timestamp('2020-06-01 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BQuarterBegin(2)</span>
    <span class="s0">Timestamp('2020-09-01 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BQuarterBegin(startingMonth=2)</span>
    <span class="s0">Timestamp('2020-08-03 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BQuarterBegin(-1)</span>
    <span class="s0">Timestamp('2020-03-02 05:01:15')</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">_output_name = &quot;BusinessQuarterBegin&quot;</span>
    <span class="s0">_default_starting_month = 3</span>
    <span class="s0">_from_name_starting_month = 1</span>
    <span class="s0">_prefix = &quot;BQS&quot;</span>
    <span class="s0">_day_opt = &quot;business_start&quot;</span>


<span class="s0">cdef class QuarterEnd(QuarterOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset increments between Quarter end dates.</span>

    <span class="s0">startingMonth = 1 corresponds to dates like 1/31/2007, 4/30/2007, ...</span>
    <span class="s0">startingMonth = 2 corresponds to dates like 2/28/2007, 5/31/2007, ...</span>
    <span class="s0">startingMonth = 3 corresponds to dates like 3/31/2007, 6/30/2007, ...</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">_default_starting_month = 3</span>
    <span class="s0">_prefix = &quot;Q&quot;</span>
    <span class="s0">_day_opt = &quot;end&quot;</span>

    <span class="s0">cdef readonly:</span>
        <span class="s0">int _period_dtype_code</span>

    <span class="s0">def __init__(self, n=1, normalize=False, startingMonth=None):</span>
        <span class="s0"># Because QuarterEnd can be the freq for a Period, define its</span>
        <span class="s0">#  _period_dtype_code at construction for performance</span>
        <span class="s0">QuarterOffset.__init__(self, n, normalize, startingMonth)</span>
        <span class="s0">self._period_dtype_code = PeriodDtypeCode.Q_DEC + self.startingMonth % 12</span>


<span class="s0">cdef class QuarterBegin(QuarterOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset increments between Quarter start dates.</span>

    <span class="s0">startingMonth = 1 corresponds to dates like 1/01/2007, 4/01/2007, ...</span>
    <span class="s0">startingMonth = 2 corresponds to dates like 2/01/2007, 5/01/2007, ...</span>
    <span class="s0">startingMonth = 3 corresponds to dates like 3/01/2007, 6/01/2007, ...</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">_default_starting_month = 3</span>
    <span class="s0">_from_name_starting_month = 1</span>
    <span class="s0">_prefix = &quot;QS&quot;</span>
    <span class="s0">_day_opt = &quot;start&quot;</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Month-Based Offset Classes</span>

<span class="s0">cdef class MonthOffset(SingleConstructorOffset):</span>
    <span class="s0">def is_on_offset(self, dt: datetime) -&gt; bool:</span>
        <span class="s0">if self.normalize and not _is_normalized(dt):</span>
            <span class="s0">return False</span>
        <span class="s0">return dt.day == self._get_offset_day(dt)</span>

    <span class="s0">@apply_wraps</span>
    <span class="s0">def _apply(self, other: datetime) -&gt; datetime:</span>
        <span class="s0">compare_day = self._get_offset_day(other)</span>
        <span class="s0">n = roll_convention(other.day, self.n, compare_day)</span>
        <span class="s0">return shift_month(other, n, self._day_opt)</span>

    <span class="s0">@apply_index_wraps</span>
    <span class="s0">def apply_index(self, dtindex):</span>
        <span class="s0">return self._apply_array(dtindex)</span>

    <span class="s0">@apply_array_wraps</span>
    <span class="s0">def _apply_array(self, dtarr):</span>
        <span class="s0">shifted = shift_months(dtarr.view(&quot;i8&quot;), self.n, self._day_opt)</span>
        <span class="s0">return shifted</span>

    <span class="s0">cpdef __setstate__(self, state):</span>
        <span class="s0">state.pop(&quot;_use_relativedelta&quot;, False)</span>
        <span class="s0">state.pop(&quot;offset&quot;, None)</span>
        <span class="s0">state.pop(&quot;_offset&quot;, None)</span>
        <span class="s0">state.pop(&quot;kwds&quot;, {})</span>

        <span class="s0">BaseOffset.__setstate__(self, state)</span>


<span class="s0">cdef class MonthEnd(MonthOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset of one month end.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">_period_dtype_code = PeriodDtypeCode.M</span>
    <span class="s0">_prefix = &quot;M&quot;</span>
    <span class="s0">_day_opt = &quot;end&quot;</span>


<span class="s0">cdef class MonthBegin(MonthOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset of one month at beginning.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">_prefix = &quot;MS&quot;</span>
    <span class="s0">_day_opt = &quot;start&quot;</span>


<span class="s0">cdef class BusinessMonthEnd(MonthOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset increments between the last business day of the month.</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">&gt;&gt;&gt; from pandas.tseries.offsets import BMonthEnd</span>
    <span class="s0">&gt;&gt;&gt; ts = pd.Timestamp('2020-05-24 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BMonthEnd()</span>
    <span class="s0">Timestamp('2020-05-29 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BMonthEnd(2)</span>
    <span class="s0">Timestamp('2020-06-30 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BMonthEnd(-2)</span>
    <span class="s0">Timestamp('2020-03-31 05:01:15')</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">_prefix = &quot;BM&quot;</span>
    <span class="s0">_day_opt = &quot;business_end&quot;</span>


<span class="s0">cdef class BusinessMonthBegin(MonthOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset of one month at the first business day.</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">&gt;&gt;&gt; from pandas.tseries.offsets import BMonthBegin</span>
    <span class="s0">&gt;&gt;&gt; ts=pd.Timestamp('2020-05-24 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BMonthBegin()</span>
    <span class="s0">Timestamp('2020-06-01 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BMonthBegin(2)</span>
    <span class="s0">Timestamp('2020-07-01 05:01:15')</span>
    <span class="s0">&gt;&gt;&gt; ts + BMonthBegin(-3)</span>
    <span class="s0">Timestamp('2020-03-02 05:01:15')</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">_prefix = &quot;BMS&quot;</span>
    <span class="s0">_day_opt = &quot;business_start&quot;</span>


<span class="s0"># ---------------------------------------------------------------------</span>
<span class="s0"># Semi-Month Based Offsets</span>

<span class="s0">cdef class SemiMonthOffset(SingleConstructorOffset):</span>
    <span class="s0">_default_day_of_month = 15</span>
    <span class="s0">_min_day_of_month = 2</span>
    <span class="s0">_attributes = tuple([&quot;n&quot;, &quot;normalize&quot;, &quot;day_of_month&quot;])</span>

    <span class="s0">cdef readonly:</span>
        <span class="s0">int day_of_month</span>

    <span class="s0">def __init__(self, n=1, normalize=False, day_of_month=None):</span>
        <span class="s0">BaseOffset.__init__(self, n, normalize)</span>

        <span class="s0">if day_of_month is None:</span>
            <span class="s0">day_of_month = self._default_day_of_month</span>

        <span class="s0">self.day_of_month = int(day_of_month)</span>
        <span class="s0">if not self._min_day_of_month &lt;= self.day_of_month &lt;= 27:</span>
            <span class="s0">raise ValueError(</span>
                <span class="s0">&quot;day_of_month must be &quot;</span>
                <span class="s0">f&quot;{self._min_day_of_month}&lt;=day_of_month&lt;=27, &quot;</span>
                <span class="s0">f&quot;got {self.day_of_month}&quot;</span>
            <span class="s0">)</span>

    <span class="s0">cpdef __setstate__(self, state):</span>
        <span class="s0">self.n = state.pop(&quot;n&quot;)</span>
        <span class="s0">self.normalize = state.pop(&quot;normalize&quot;)</span>
        <span class="s0">self.day_of_month = state.pop(&quot;day_of_month&quot;)</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def _from_name(cls, suffix=None):</span>
        <span class="s0">return cls(day_of_month=suffix)</span>

    <span class="s0">@property</span>
    <span class="s0">def rule_code(self) -&gt; str:</span>
        <span class="s0">suffix = f&quot;-{self.day_of_month}&quot;</span>
        <span class="s0">return self._prefix + suffix</span>

    <span class="s0">@apply_wraps</span>
    <span class="s0">def _apply(self, other: datetime) -&gt; datetime:</span>
        <span class="s0">is_start = isinstance(self, SemiMonthBegin)</span>

        <span class="s0"># shift `other` to self.day_of_month, incrementing `n` if necessary</span>
        <span class="s0">n = roll_convention(other.day, self.n, self.day_of_month)</span>

        <span class="s0">days_in_month = get_days_in_month(other.year, other.month)</span>
        <span class="s0"># For SemiMonthBegin on other.day == 1 and</span>
        <span class="s0"># SemiMonthEnd on other.day == days_in_month,</span>
        <span class="s0"># shifting `other` to `self.day_of_month` _always_ requires</span>
        <span class="s0"># incrementing/decrementing `n`, regardless of whether it is</span>
        <span class="s0"># initially positive.</span>
        <span class="s0">if is_start and (self.n &lt;= 0 and other.day == 1):</span>
            <span class="s0">n -= 1</span>
        <span class="s0">elif (not is_start) and (self.n &gt; 0 and other.day == days_in_month):</span>
            <span class="s0">n += 1</span>

        <span class="s0">if is_start:</span>
            <span class="s0">months = n // 2 + n % 2</span>
            <span class="s0">to_day = 1 if n % 2 else self.day_of_month</span>
        <span class="s0">else:</span>
            <span class="s0">months = n // 2</span>
            <span class="s0">to_day = 31 if n % 2 else self.day_of_month</span>

        <span class="s0">return shift_month(other, months, to_day)</span>

    <span class="s0">@apply_index_wraps</span>
    <span class="s0">@cython.wraparound(False)</span>
    <span class="s0">@cython.boundscheck(False)</span>
    <span class="s0">def apply_index(self, dtindex):</span>
        <span class="s0">return self._apply_array(dtindex)</span>

    <span class="s0">@apply_array_wraps</span>
    <span class="s0">@cython.wraparound(False)</span>
    <span class="s0">@cython.boundscheck(False)</span>
    <span class="s0">def _apply_array(self, dtarr):</span>
        <span class="s0">cdef:</span>
            <span class="s0">int64_t[:] i8other = dtarr.view(&quot;i8&quot;)</span>
            <span class="s0">Py_ssize_t i, count = len(i8other)</span>
            <span class="s0">int64_t val</span>
            <span class="s0">int64_t[:] out = np.empty(count, dtype=&quot;i8&quot;)</span>
            <span class="s0">npy_datetimestruct dts</span>
            <span class="s0">int months, to_day, nadj, n = self.n</span>
            <span class="s0">int days_in_month, day, anchor_dom = self.day_of_month</span>
            <span class="s0">bint is_start = isinstance(self, SemiMonthBegin)</span>

        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">val = i8other[i]</span>
                <span class="s0">if val == NPY_NAT:</span>
                    <span class="s0">out[i] = NPY_NAT</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(val, &amp;dts)</span>
                <span class="s0">day = dts.day</span>

                <span class="s0"># Adjust so that we are always looking at self.day_of_month,</span>
                <span class="s0">#  incrementing/decrementing n if necessary.</span>
                <span class="s0">nadj = roll_convention(day, n, anchor_dom)</span>

                <span class="s0">days_in_month = get_days_in_month(dts.year, dts.month)</span>
                <span class="s0"># For SemiMonthBegin on other.day == 1 and</span>
                <span class="s0">#  SemiMonthEnd on other.day == days_in_month,</span>
                <span class="s0">#  shifting `other` to `self.day_of_month` _always_ requires</span>
                <span class="s0">#  incrementing/decrementing `n`, regardless of whether it is</span>
                <span class="s0">#  initially positive.</span>
                <span class="s0">if is_start and (n &lt;= 0 and day == 1):</span>
                    <span class="s0">nadj -= 1</span>
                <span class="s0">elif (not is_start) and (n &gt; 0 and day == days_in_month):</span>
                    <span class="s0">nadj += 1</span>

                <span class="s0">if is_start:</span>
                    <span class="s0"># See also: SemiMonthBegin._apply</span>
                    <span class="s0">months = nadj // 2 + nadj % 2</span>
                    <span class="s0">to_day = 1 if nadj % 2 else anchor_dom</span>

                <span class="s0">else:</span>
                    <span class="s0"># See also: SemiMonthEnd._apply</span>
                    <span class="s0">months = nadj // 2</span>
                    <span class="s0">to_day = 31 if nadj % 2 else anchor_dom</span>

                <span class="s0">dts.year = year_add_months(dts, months)</span>
                <span class="s0">dts.month = month_add_months(dts, months)</span>
                <span class="s0">days_in_month = get_days_in_month(dts.year, dts.month)</span>
                <span class="s0">dts.day = min(to_day, days_in_month)</span>

                <span class="s0">out[i] = dtstruct_to_dt64(&amp;dts)</span>

        <span class="s0">return out.base</span>


<span class="s0">cdef class SemiMonthEnd(SemiMonthOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Two DateOffset's per month repeating on the last</span>
    <span class="s0">day of the month and day_of_month.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">n : int</span>
    <span class="s0">normalize : bool, default False</span>
    <span class="s0">day_of_month : int, {1, 3,...,27}, default 15</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">_prefix = &quot;SM&quot;</span>
    <span class="s0">_min_day_of_month = 1</span>

    <span class="s0">def is_on_offset(self, dt: datetime) -&gt; bool:</span>
        <span class="s0">if self.normalize and not _is_normalized(dt):</span>
            <span class="s0">return False</span>
        <span class="s0">days_in_month = get_days_in_month(dt.year, dt.month)</span>
        <span class="s0">return dt.day in (self.day_of_month, days_in_month)</span>


<span class="s0">cdef class SemiMonthBegin(SemiMonthOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Two DateOffset's per month repeating on the first</span>
    <span class="s0">day of the month and day_of_month.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">n : int</span>
    <span class="s0">normalize : bool, default False</span>
    <span class="s0">day_of_month : int, {2, 3,...,27}, default 15</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">_prefix = &quot;SMS&quot;</span>

    <span class="s0">def is_on_offset(self, dt: datetime) -&gt; bool:</span>
        <span class="s0">if self.normalize and not _is_normalized(dt):</span>
            <span class="s0">return False</span>
        <span class="s0">return dt.day in (1, self.day_of_month)</span>


<span class="s0"># ---------------------------------------------------------------------</span>
<span class="s0"># Week-Based Offset Classes</span>


<span class="s0">cdef class Week(SingleConstructorOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Weekly offset.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">weekday : int or None, default None</span>
        <span class="s0">Always generate specific day of week. 0 for Monday.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">_inc = timedelta(weeks=1)</span>
    <span class="s0">_prefix = &quot;W&quot;</span>
    <span class="s0">_attributes = tuple([&quot;n&quot;, &quot;normalize&quot;, &quot;weekday&quot;])</span>

    <span class="s0">cdef readonly:</span>
        <span class="s0">object weekday  # int or None</span>
        <span class="s0">int _period_dtype_code</span>

    <span class="s0">def __init__(self, n=1, normalize=False, weekday=None):</span>
        <span class="s0">BaseOffset.__init__(self, n, normalize)</span>
        <span class="s0">self.weekday = weekday</span>

        <span class="s0">if self.weekday is not None:</span>
            <span class="s0">if self.weekday &lt; 0 or self.weekday &gt; 6:</span>
                <span class="s0">raise ValueError(f&quot;Day must be 0&lt;=day&lt;=6, got {self.weekday}&quot;)</span>

            <span class="s0">self._period_dtype_code = PeriodDtypeCode.W_SUN + (weekday + 1) % 7</span>

    <span class="s0">cpdef __setstate__(self, state):</span>
        <span class="s0">self.n = state.pop(&quot;n&quot;)</span>
        <span class="s0">self.normalize = state.pop(&quot;normalize&quot;)</span>
        <span class="s0">self.weekday = state.pop(&quot;weekday&quot;)</span>
        <span class="s0">self._cache = state.pop(&quot;_cache&quot;, {})</span>

    <span class="s0">def is_anchored(self) -&gt; bool:</span>
        <span class="s0">return self.n == 1 and self.weekday is not None</span>

    <span class="s0">@apply_wraps</span>
    <span class="s0">def _apply(self, other):</span>
        <span class="s0">if self.weekday is None:</span>
            <span class="s0">return other + self.n * self._inc</span>

        <span class="s0">if not PyDateTime_Check(other):</span>
            <span class="s0">raise TypeError(</span>
                <span class="s0">f&quot;Cannot add {type(other).__name__} to {type(self).__name__}&quot;</span>
            <span class="s0">)</span>

        <span class="s0">k = self.n</span>
        <span class="s0">otherDay = other.weekday()</span>
        <span class="s0">if otherDay != self.weekday:</span>
            <span class="s0">other = other + timedelta((self.weekday - otherDay) % 7)</span>
            <span class="s0">if k &gt; 0:</span>
                <span class="s0">k -= 1</span>

        <span class="s0">return other + timedelta(weeks=k)</span>

    <span class="s0">@apply_index_wraps</span>
    <span class="s0">def apply_index(self, dtindex):</span>
        <span class="s0">return self._apply_array(dtindex)</span>

    <span class="s0">@apply_array_wraps</span>
    <span class="s0">def _apply_array(self, dtarr):</span>
        <span class="s0">if self.weekday is None:</span>
            <span class="s0">td = timedelta(days=7 * self.n)</span>
            <span class="s0">td64 = np.timedelta64(td, &quot;ns&quot;)</span>
            <span class="s0">return dtarr + td64</span>
        <span class="s0">else:</span>
            <span class="s0">i8other = dtarr.view(&quot;i8&quot;)</span>
            <span class="s0">return self._end_apply_index(i8other)</span>

    <span class="s0">@cython.wraparound(False)</span>
    <span class="s0">@cython.boundscheck(False)</span>
    <span class="s0">cdef _end_apply_index(self, const int64_t[:] i8other):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Add self to the given DatetimeIndex, specialized for case where</span>
        <span class="s0">self.weekday is non-null.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">i8other : const int64_t[:]</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">ndarray[int64_t]</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t i, count = len(i8other)</span>
            <span class="s0">int64_t val</span>
            <span class="s0">int64_t[:] out = np.empty(count, dtype=&quot;i8&quot;)</span>
            <span class="s0">npy_datetimestruct dts</span>
            <span class="s0">int wday, days, weeks, n = self.n</span>
            <span class="s0">int anchor_weekday = self.weekday</span>

        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">val = i8other[i]</span>
                <span class="s0">if val == NPY_NAT:</span>
                    <span class="s0">out[i] = NPY_NAT</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(val, &amp;dts)</span>
                <span class="s0">wday = dayofweek(dts.year, dts.month, dts.day)</span>

                <span class="s0">days = 0</span>
                <span class="s0">weeks = n</span>
                <span class="s0">if wday != anchor_weekday:</span>
                    <span class="s0">days = (anchor_weekday - wday) % 7</span>
                    <span class="s0">if weeks &gt; 0:</span>
                        <span class="s0">weeks -= 1</span>

                <span class="s0">out[i] = val + (7 * weeks + days) * DAY_NANOS</span>

        <span class="s0">return out.base</span>

    <span class="s0">def is_on_offset(self, dt: datetime) -&gt; bool:</span>
        <span class="s0">if self.normalize and not _is_normalized(dt):</span>
            <span class="s0">return False</span>
        <span class="s0">elif self.weekday is None:</span>
            <span class="s0">return True</span>
        <span class="s0">return dt.weekday() == self.weekday</span>

    <span class="s0">@property</span>
    <span class="s0">def rule_code(self) -&gt; str:</span>
        <span class="s0">suffix = &quot;&quot;</span>
        <span class="s0">if self.weekday is not None:</span>
            <span class="s0">weekday = int_to_weekday[self.weekday]</span>
            <span class="s0">suffix = f&quot;-{weekday}&quot;</span>
        <span class="s0">return self._prefix + suffix</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def _from_name(cls, suffix=None):</span>
        <span class="s0">if not suffix:</span>
            <span class="s0">weekday = None</span>
        <span class="s0">else:</span>
            <span class="s0">weekday = weekday_to_int[suffix]</span>
        <span class="s0">return cls(weekday=weekday)</span>


<span class="s0">cdef class WeekOfMonth(WeekOfMonthMixin):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Describes monthly dates like &quot;the Tuesday of the 2nd week of each month&quot;.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">n : int</span>
    <span class="s0">week : int {0, 1, 2, 3, ...}, default 0</span>
        <span class="s0">A specific integer for the week of the month.</span>
        <span class="s0">e.g. 0 is 1st week of month, 1 is the 2nd week, etc.</span>
    <span class="s0">weekday : int {0, 1, ..., 6}, default 0</span>
        <span class="s0">A specific integer for the day of the week.</span>

        <span class="s0">- 0 is Monday</span>
        <span class="s0">- 1 is Tuesday</span>
        <span class="s0">- 2 is Wednesday</span>
        <span class="s0">- 3 is Thursday</span>
        <span class="s0">- 4 is Friday</span>
        <span class="s0">- 5 is Saturday</span>
        <span class="s0">- 6 is Sunday.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">_prefix = &quot;WOM&quot;</span>
    <span class="s0">_attributes = tuple([&quot;n&quot;, &quot;normalize&quot;, &quot;week&quot;, &quot;weekday&quot;])</span>

    <span class="s0">def __init__(self, n=1, normalize=False, week=0, weekday=0):</span>
        <span class="s0">WeekOfMonthMixin.__init__(self, n, normalize, weekday)</span>
        <span class="s0">self.week = week</span>

        <span class="s0">if self.week &lt; 0 or self.week &gt; 3:</span>
            <span class="s0">raise ValueError(f&quot;Week must be 0&lt;=week&lt;=3, got {self.week}&quot;)</span>

    <span class="s0">cpdef __setstate__(self, state):</span>
        <span class="s0">self.n = state.pop(&quot;n&quot;)</span>
        <span class="s0">self.normalize = state.pop(&quot;normalize&quot;)</span>
        <span class="s0">self.weekday = state.pop(&quot;weekday&quot;)</span>
        <span class="s0">self.week = state.pop(&quot;week&quot;)</span>

    <span class="s0">def _get_offset_day(self, other: datetime) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Find the day in the same month as other that has the same</span>
        <span class="s0">weekday as self.weekday and is the self.week'th such day in the month.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">other : datetime</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">day : int</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">mstart = datetime(other.year, other.month, 1)</span>
        <span class="s0">wday = mstart.weekday()</span>
        <span class="s0">shift_days = (self.weekday - wday) % 7</span>
        <span class="s0">return 1 + shift_days + self.week * 7</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def _from_name(cls, suffix=None):</span>
        <span class="s0">if not suffix:</span>
            <span class="s0">raise ValueError(f&quot;Prefix {repr(cls._prefix)} requires a suffix.&quot;)</span>
        <span class="s0"># only one digit weeks (1 --&gt; week 0, 2 --&gt; week 1, etc.)</span>
        <span class="s0">week = int(suffix[0]) - 1</span>
        <span class="s0">weekday = weekday_to_int[suffix[1:]]</span>
        <span class="s0">return cls(week=week, weekday=weekday)</span>


<span class="s0">cdef class LastWeekOfMonth(WeekOfMonthMixin):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Describes monthly dates in last week of month like &quot;the last Tuesday of</span>
    <span class="s0">each month&quot;.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">n : int, default 1</span>
    <span class="s0">weekday : int {0, 1, ..., 6}, default 0</span>
        <span class="s0">A specific integer for the day of the week.</span>

        <span class="s0">- 0 is Monday</span>
        <span class="s0">- 1 is Tuesday</span>
        <span class="s0">- 2 is Wednesday</span>
        <span class="s0">- 3 is Thursday</span>
        <span class="s0">- 4 is Friday</span>
        <span class="s0">- 5 is Saturday</span>
        <span class="s0">- 6 is Sunday.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">_prefix = &quot;LWOM&quot;</span>
    <span class="s0">_attributes = tuple([&quot;n&quot;, &quot;normalize&quot;, &quot;weekday&quot;])</span>

    <span class="s0">def __init__(self, n=1, normalize=False, weekday=0):</span>
        <span class="s0">WeekOfMonthMixin.__init__(self, n, normalize, weekday)</span>
        <span class="s0">self.week = -1</span>

        <span class="s0">if self.n == 0:</span>
            <span class="s0">raise ValueError(&quot;N cannot be 0&quot;)</span>

    <span class="s0">cpdef __setstate__(self, state):</span>
        <span class="s0">self.n = state.pop(&quot;n&quot;)</span>
        <span class="s0">self.normalize = state.pop(&quot;normalize&quot;)</span>
        <span class="s0">self.weekday = state.pop(&quot;weekday&quot;)</span>
        <span class="s0">self.week = -1</span>

    <span class="s0">def _get_offset_day(self, other: datetime) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Find the day in the same month as other that has the same</span>
        <span class="s0">weekday as self.weekday and is the last such day in the month.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">other: datetime</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">day: int</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">dim = get_days_in_month(other.year, other.month)</span>
        <span class="s0">mend = datetime(other.year, other.month, dim)</span>
        <span class="s0">wday = mend.weekday()</span>
        <span class="s0">shift_days = (wday - self.weekday) % 7</span>
        <span class="s0">return dim - shift_days</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def _from_name(cls, suffix=None):</span>
        <span class="s0">if not suffix:</span>
            <span class="s0">raise ValueError(f&quot;Prefix {repr(cls._prefix)} requires a suffix.&quot;)</span>
        <span class="s0">weekday = weekday_to_int[suffix]</span>
        <span class="s0">return cls(weekday=weekday)</span>


<span class="s0"># ---------------------------------------------------------------------</span>
<span class="s0"># Special Offset Classes</span>

<span class="s0">cdef class FY5253Mixin(SingleConstructorOffset):</span>
    <span class="s0">cdef readonly:</span>
        <span class="s0">int startingMonth</span>
        <span class="s0">int weekday</span>
        <span class="s0">str variation</span>

    <span class="s0">def __init__(</span>
        <span class="s0">self, n=1, normalize=False, weekday=0, startingMonth=1, variation=&quot;nearest&quot;</span>
    <span class="s0">):</span>
        <span class="s0">BaseOffset.__init__(self, n, normalize)</span>
        <span class="s0">self.startingMonth = startingMonth</span>
        <span class="s0">self.weekday = weekday</span>
        <span class="s0">self.variation = variation</span>

        <span class="s0">if self.n == 0:</span>
            <span class="s0">raise ValueError(&quot;N cannot be 0&quot;)</span>

        <span class="s0">if self.variation not in [&quot;nearest&quot;, &quot;last&quot;]:</span>
            <span class="s0">raise ValueError(f&quot;{self.variation} is not a valid variation&quot;)</span>

    <span class="s0">cpdef __setstate__(self, state):</span>
        <span class="s0">self.n = state.pop(&quot;n&quot;)</span>
        <span class="s0">self.normalize = state.pop(&quot;normalize&quot;)</span>
        <span class="s0">self.weekday = state.pop(&quot;weekday&quot;)</span>
        <span class="s0">self.variation = state.pop(&quot;variation&quot;)</span>

    <span class="s0">def is_anchored(self) -&gt; bool:</span>
        <span class="s0">return (</span>
            <span class="s0">self.n == 1 and self.startingMonth is not None and self.weekday is not None</span>
        <span class="s0">)</span>

    <span class="s0"># --------------------------------------------------------------------</span>
    <span class="s0"># Name-related methods</span>

    <span class="s0">@property</span>
    <span class="s0">def rule_code(self) -&gt; str:</span>
        <span class="s0">prefix = self._prefix</span>
        <span class="s0">suffix = self.get_rule_code_suffix()</span>
        <span class="s0">return f&quot;{prefix}-{suffix}&quot;</span>

    <span class="s0">def _get_suffix_prefix(self) -&gt; str:</span>
        <span class="s0">if self.variation == &quot;nearest&quot;:</span>
            <span class="s0">return &quot;N&quot;</span>
        <span class="s0">else:</span>
            <span class="s0">return &quot;L&quot;</span>

    <span class="s0">def get_rule_code_suffix(self) -&gt; str:</span>
        <span class="s0">prefix = self._get_suffix_prefix()</span>
        <span class="s0">month = MONTH_ALIASES[self.startingMonth]</span>
        <span class="s0">weekday = int_to_weekday[self.weekday]</span>
        <span class="s0">return f&quot;{prefix}-{month}-{weekday}&quot;</span>


<span class="s0">cdef class FY5253(FY5253Mixin):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Describes 52-53 week fiscal year. This is also known as a 4-4-5 calendar.</span>

    <span class="s0">It is used by companies that desire that their</span>
    <span class="s0">fiscal year always end on the same day of the week.</span>

    <span class="s0">It is a method of managing accounting periods.</span>
    <span class="s0">It is a common calendar structure for some industries,</span>
    <span class="s0">such as retail, manufacturing and parking industry.</span>

    <span class="s0">For more information see:</span>
    <span class="s0">https://en.wikipedia.org/wiki/4-4-5_calendar</span>

    <span class="s0">The year may either:</span>

    <span class="s0">- end on the last X day of the Y month.</span>
    <span class="s0">- end on the last X day closest to the last day of the Y month.</span>

    <span class="s0">X is a specific day of the week.</span>
    <span class="s0">Y is a certain month of the year</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">n : int</span>
    <span class="s0">weekday : int {0, 1, ..., 6}, default 0</span>
        <span class="s0">A specific integer for the day of the week.</span>

        <span class="s0">- 0 is Monday</span>
        <span class="s0">- 1 is Tuesday</span>
        <span class="s0">- 2 is Wednesday</span>
        <span class="s0">- 3 is Thursday</span>
        <span class="s0">- 4 is Friday</span>
        <span class="s0">- 5 is Saturday</span>
        <span class="s0">- 6 is Sunday.</span>

    <span class="s0">startingMonth : int {1, 2, ... 12}, default 1</span>
        <span class="s0">The month in which the fiscal year ends.</span>

    <span class="s0">variation : str, default &quot;nearest&quot;</span>
        <span class="s0">Method of employing 4-4-5 calendar.</span>

        <span class="s0">There are two options:</span>

        <span class="s0">- &quot;nearest&quot; means year end is **weekday** closest to last day of month in year.</span>
        <span class="s0">- &quot;last&quot; means year end is final **weekday** of the final month in fiscal year.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">_prefix = &quot;RE&quot;</span>
    <span class="s0">_attributes = tuple([&quot;n&quot;, &quot;normalize&quot;, &quot;weekday&quot;, &quot;startingMonth&quot;, &quot;variation&quot;])</span>

    <span class="s0">def is_on_offset(self, dt: datetime) -&gt; bool:</span>
        <span class="s0">if self.normalize and not _is_normalized(dt):</span>
            <span class="s0">return False</span>
        <span class="s0">dt = datetime(dt.year, dt.month, dt.day)</span>
        <span class="s0">year_end = self.get_year_end(dt)</span>

        <span class="s0">if self.variation == &quot;nearest&quot;:</span>
            <span class="s0"># We have to check the year end of &quot;this&quot; cal year AND the previous</span>
            <span class="s0">return year_end == dt or self.get_year_end(shift_month(dt, -1, None)) == dt</span>
        <span class="s0">else:</span>
            <span class="s0">return year_end == dt</span>

    <span class="s0">@apply_wraps</span>
    <span class="s0">def _apply(self, other: datetime) -&gt; datetime:</span>
        <span class="s0">norm = Timestamp(other).normalize()</span>

        <span class="s0">n = self.n</span>
        <span class="s0">prev_year = self.get_year_end(datetime(other.year - 1, self.startingMonth, 1))</span>
        <span class="s0">cur_year = self.get_year_end(datetime(other.year, self.startingMonth, 1))</span>
        <span class="s0">next_year = self.get_year_end(datetime(other.year + 1, self.startingMonth, 1))</span>

        <span class="s0">prev_year = localize_pydatetime(prev_year, other.tzinfo)</span>
        <span class="s0">cur_year = localize_pydatetime(cur_year, other.tzinfo)</span>
        <span class="s0">next_year = localize_pydatetime(next_year, other.tzinfo)</span>

        <span class="s0"># Note: next_year.year == other.year + 1, so we will always</span>
        <span class="s0"># have other &lt; next_year</span>
        <span class="s0">if norm == prev_year:</span>
            <span class="s0">n -= 1</span>
        <span class="s0">elif norm == cur_year:</span>
            <span class="s0">pass</span>
        <span class="s0">elif n &gt; 0:</span>
            <span class="s0">if norm &lt; prev_year:</span>
                <span class="s0">n -= 2</span>
            <span class="s0">elif prev_year &lt; norm &lt; cur_year:</span>
                <span class="s0">n -= 1</span>
            <span class="s0">elif cur_year &lt; norm &lt; next_year:</span>
                <span class="s0">pass</span>
        <span class="s0">else:</span>
            <span class="s0">if cur_year &lt; norm &lt; next_year:</span>
                <span class="s0">n += 1</span>
            <span class="s0">elif prev_year &lt; norm &lt; cur_year:</span>
                <span class="s0">pass</span>
            <span class="s0">elif (</span>
                <span class="s0">norm.year == prev_year.year</span>
                <span class="s0">and norm &lt; prev_year</span>
                <span class="s0">and prev_year - norm &lt;= timedelta(6)</span>
            <span class="s0">):</span>
                <span class="s0"># GH#14774, error when next_year.year == cur_year.year</span>
                <span class="s0"># e.g. prev_year == datetime(2004, 1, 3),</span>
                <span class="s0"># other == datetime(2004, 1, 1)</span>
                <span class="s0">n -= 1</span>
            <span class="s0">else:</span>
                <span class="s0">assert False</span>

        <span class="s0">shifted = datetime(other.year + n, self.startingMonth, 1)</span>
        <span class="s0">result = self.get_year_end(shifted)</span>
        <span class="s0">result = datetime(</span>
            <span class="s0">result.year,</span>
            <span class="s0">result.month,</span>
            <span class="s0">result.day,</span>
            <span class="s0">other.hour,</span>
            <span class="s0">other.minute,</span>
            <span class="s0">other.second,</span>
            <span class="s0">other.microsecond,</span>
        <span class="s0">)</span>
        <span class="s0">return result</span>

    <span class="s0">def get_year_end(self, dt: datetime) -&gt; datetime:</span>
        <span class="s0">assert dt.tzinfo is None</span>

        <span class="s0">dim = get_days_in_month(dt.year, self.startingMonth)</span>
        <span class="s0">target_date = datetime(dt.year, self.startingMonth, dim)</span>
        <span class="s0">wkday_diff = self.weekday - target_date.weekday()</span>
        <span class="s0">if wkday_diff == 0:</span>
            <span class="s0"># year_end is the same for &quot;last&quot; and &quot;nearest&quot; cases</span>
            <span class="s0">return target_date</span>

        <span class="s0">if self.variation == &quot;last&quot;:</span>
            <span class="s0">days_forward = (wkday_diff % 7) - 7</span>

            <span class="s0"># days_forward is always negative, so we always end up</span>
            <span class="s0"># in the same year as dt</span>
            <span class="s0">return target_date + timedelta(days=days_forward)</span>
        <span class="s0">else:</span>
            <span class="s0"># variation == &quot;nearest&quot;:</span>
            <span class="s0">days_forward = wkday_diff % 7</span>
            <span class="s0">if days_forward &lt;= 3:</span>
                <span class="s0"># The upcoming self.weekday is closer than the previous one</span>
                <span class="s0">return target_date + timedelta(days_forward)</span>
            <span class="s0">else:</span>
                <span class="s0"># The previous self.weekday is closer than the upcoming one</span>
                <span class="s0">return target_date + timedelta(days_forward - 7)</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def _parse_suffix(cls, varion_code, startingMonth_code, weekday_code):</span>
        <span class="s0">if varion_code == &quot;N&quot;:</span>
            <span class="s0">variation = &quot;nearest&quot;</span>
        <span class="s0">elif varion_code == &quot;L&quot;:</span>
            <span class="s0">variation = &quot;last&quot;</span>
        <span class="s0">else:</span>
            <span class="s0">raise ValueError(f&quot;Unable to parse varion_code: {varion_code}&quot;)</span>

        <span class="s0">startingMonth = MONTH_TO_CAL_NUM[startingMonth_code]</span>
        <span class="s0">weekday = weekday_to_int[weekday_code]</span>

        <span class="s0">return {</span>
            <span class="s0">&quot;weekday&quot;: weekday,</span>
            <span class="s0">&quot;startingMonth&quot;: startingMonth,</span>
            <span class="s0">&quot;variation&quot;: variation,</span>
        <span class="s0">}</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def _from_name(cls, *args):</span>
        <span class="s0">return cls(**cls._parse_suffix(*args))</span>


<span class="s0">cdef class FY5253Quarter(FY5253Mixin):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset increments between business quarter dates</span>
    <span class="s0">for 52-53 week fiscal year (also known as a 4-4-5 calendar).</span>

    <span class="s0">It is used by companies that desire that their</span>
    <span class="s0">fiscal year always end on the same day of the week.</span>

    <span class="s0">It is a method of managing accounting periods.</span>
    <span class="s0">It is a common calendar structure for some industries,</span>
    <span class="s0">such as retail, manufacturing and parking industry.</span>

    <span class="s0">For more information see:</span>
    <span class="s0">https://en.wikipedia.org/wiki/4-4-5_calendar</span>

    <span class="s0">The year may either:</span>

    <span class="s0">- end on the last X day of the Y month.</span>
    <span class="s0">- end on the last X day closest to the last day of the Y month.</span>

    <span class="s0">X is a specific day of the week.</span>
    <span class="s0">Y is a certain month of the year</span>

    <span class="s0">startingMonth = 1 corresponds to dates like 1/31/2007, 4/30/2007, ...</span>
    <span class="s0">startingMonth = 2 corresponds to dates like 2/28/2007, 5/31/2007, ...</span>
    <span class="s0">startingMonth = 3 corresponds to dates like 3/30/2007, 6/29/2007, ...</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">n : int</span>
    <span class="s0">weekday : int {0, 1, ..., 6}, default 0</span>
        <span class="s0">A specific integer for the day of the week.</span>

        <span class="s0">- 0 is Monday</span>
        <span class="s0">- 1 is Tuesday</span>
        <span class="s0">- 2 is Wednesday</span>
        <span class="s0">- 3 is Thursday</span>
        <span class="s0">- 4 is Friday</span>
        <span class="s0">- 5 is Saturday</span>
        <span class="s0">- 6 is Sunday.</span>

    <span class="s0">startingMonth : int {1, 2, ..., 12}, default 1</span>
        <span class="s0">The month in which fiscal years end.</span>

    <span class="s0">qtr_with_extra_week : int {1, 2, 3, 4}, default 1</span>
        <span class="s0">The quarter number that has the leap or 14 week when needed.</span>

    <span class="s0">variation : str, default &quot;nearest&quot;</span>
        <span class="s0">Method of employing 4-4-5 calendar.</span>

        <span class="s0">There are two options:</span>

        <span class="s0">- &quot;nearest&quot; means year end is **weekday** closest to last day of month in year.</span>
        <span class="s0">- &quot;last&quot; means year end is final **weekday** of the final month in fiscal year.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">_prefix = &quot;REQ&quot;</span>
    <span class="s0">_attributes = tuple(</span>
        <span class="s0">[</span>
            <span class="s0">&quot;n&quot;,</span>
            <span class="s0">&quot;normalize&quot;,</span>
            <span class="s0">&quot;weekday&quot;,</span>
            <span class="s0">&quot;startingMonth&quot;,</span>
            <span class="s0">&quot;qtr_with_extra_week&quot;,</span>
            <span class="s0">&quot;variation&quot;,</span>
        <span class="s0">]</span>
    <span class="s0">)</span>

    <span class="s0">cdef readonly:</span>
        <span class="s0">int qtr_with_extra_week</span>

    <span class="s0">def __init__(</span>
        <span class="s0">self,</span>
        <span class="s0">n=1,</span>
        <span class="s0">normalize=False,</span>
        <span class="s0">weekday=0,</span>
        <span class="s0">startingMonth=1,</span>
        <span class="s0">qtr_with_extra_week=1,</span>
        <span class="s0">variation=&quot;nearest&quot;,</span>
    <span class="s0">):</span>
        <span class="s0">FY5253Mixin.__init__(</span>
            <span class="s0">self, n, normalize, weekday, startingMonth, variation</span>
        <span class="s0">)</span>
        <span class="s0">self.qtr_with_extra_week = qtr_with_extra_week</span>

    <span class="s0">cpdef __setstate__(self, state):</span>
        <span class="s0">FY5253Mixin.__setstate__(self, state)</span>
        <span class="s0">self.qtr_with_extra_week = state.pop(&quot;qtr_with_extra_week&quot;)</span>

    <span class="s0">@cache_readonly</span>
    <span class="s0">def _offset(self):</span>
        <span class="s0">return FY5253(</span>
            <span class="s0">startingMonth=self.startingMonth,</span>
            <span class="s0">weekday=self.weekday,</span>
            <span class="s0">variation=self.variation,</span>
        <span class="s0">)</span>

    <span class="s0">def _rollback_to_year(self, other: datetime):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Roll `other` back to the most recent date that was on a fiscal year</span>
        <span class="s0">end.</span>

        <span class="s0">Return the date of that year-end, the number of full quarters</span>
        <span class="s0">elapsed between that year-end and other, and the remaining Timedelta</span>
        <span class="s0">since the most recent quarter-end.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">other : datetime or Timestamp</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">tuple of</span>
        <span class="s0">prev_year_end : Timestamp giving most recent fiscal year end</span>
        <span class="s0">num_qtrs : int</span>
        <span class="s0">tdelta : Timedelta</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">num_qtrs = 0</span>

        <span class="s0">norm = Timestamp(other).tz_localize(None)</span>
        <span class="s0">start = self._offset.rollback(norm)</span>
        <span class="s0"># Note: start &lt;= norm and self._offset.is_on_offset(start)</span>

        <span class="s0">if start &lt; norm:</span>
            <span class="s0"># roll adjustment</span>
            <span class="s0">qtr_lens = self.get_weeks(norm)</span>

            <span class="s0"># check that qtr_lens is consistent with self._offset addition</span>
            <span class="s0">end = shift_day(start, days=7 * sum(qtr_lens))</span>
            <span class="s0">assert self._offset.is_on_offset(end), (start, end, qtr_lens)</span>

            <span class="s0">tdelta = norm - start</span>
            <span class="s0">for qlen in qtr_lens:</span>
                <span class="s0">if qlen * 7 &lt;= tdelta.days:</span>
                    <span class="s0">num_qtrs += 1</span>
                    <span class="s0">tdelta -= Timedelta(days=qlen * 7)</span>
                <span class="s0">else:</span>
                    <span class="s0">break</span>
        <span class="s0">else:</span>
            <span class="s0">tdelta = Timedelta(0)</span>

        <span class="s0"># Note: we always have tdelta.value &gt;= 0</span>
        <span class="s0">return start, num_qtrs, tdelta</span>

    <span class="s0">@apply_wraps</span>
    <span class="s0">def _apply(self, other: datetime) -&gt; datetime:</span>
        <span class="s0"># Note: self.n == 0 is not allowed.</span>

        <span class="s0">n = self.n</span>

        <span class="s0">prev_year_end, num_qtrs, tdelta = self._rollback_to_year(other)</span>
        <span class="s0">res = prev_year_end</span>
        <span class="s0">n += num_qtrs</span>
        <span class="s0">if self.n &lt;= 0 and tdelta.value &gt; 0:</span>
            <span class="s0">n += 1</span>

        <span class="s0"># Possible speedup by handling years first.</span>
        <span class="s0">years = n // 4</span>
        <span class="s0">if years:</span>
            <span class="s0">res += self._offset * years</span>
            <span class="s0">n -= years * 4</span>

        <span class="s0"># Add an extra day to make *sure* we are getting the quarter lengths</span>
        <span class="s0"># for the upcoming year, not the previous year</span>
        <span class="s0">qtr_lens = self.get_weeks(res + Timedelta(days=1))</span>

        <span class="s0"># Note: we always have 0 &lt;= n &lt; 4</span>
        <span class="s0">weeks = sum(qtr_lens[:n])</span>
        <span class="s0">if weeks:</span>
            <span class="s0">res = shift_day(res, days=weeks * 7)</span>

        <span class="s0">return res</span>

    <span class="s0">def get_weeks(self, dt: datetime):</span>
        <span class="s0">ret = [13] * 4</span>

        <span class="s0">year_has_extra_week = self.year_has_extra_week(dt)</span>

        <span class="s0">if year_has_extra_week:</span>
            <span class="s0">ret[self.qtr_with_extra_week - 1] = 14</span>

        <span class="s0">return ret</span>

    <span class="s0">def year_has_extra_week(self, dt: datetime) -&gt; bool:</span>
        <span class="s0"># Avoid round-down errors --&gt; normalize to get</span>
        <span class="s0"># e.g. '370D' instead of '360D23H'</span>
        <span class="s0">norm = Timestamp(dt).normalize().tz_localize(None)</span>

        <span class="s0">next_year_end = self._offset.rollforward(norm)</span>
        <span class="s0">prev_year_end = norm - self._offset</span>
        <span class="s0">weeks_in_year = (next_year_end - prev_year_end).days / 7</span>
        <span class="s0">assert weeks_in_year in [52, 53], weeks_in_year</span>
        <span class="s0">return weeks_in_year == 53</span>

    <span class="s0">def is_on_offset(self, dt: datetime) -&gt; bool:</span>
        <span class="s0">if self.normalize and not _is_normalized(dt):</span>
            <span class="s0">return False</span>
        <span class="s0">if self._offset.is_on_offset(dt):</span>
            <span class="s0">return True</span>

        <span class="s0">next_year_end = dt - self._offset</span>

        <span class="s0">qtr_lens = self.get_weeks(dt)</span>

        <span class="s0">current = next_year_end</span>
        <span class="s0">for qtr_len in qtr_lens:</span>
            <span class="s0">current = shift_day(current, days=qtr_len * 7)</span>
            <span class="s0">if dt == current:</span>
                <span class="s0">return True</span>
        <span class="s0">return False</span>

    <span class="s0">@property</span>
    <span class="s0">def rule_code(self) -&gt; str:</span>
        <span class="s0">suffix = FY5253Mixin.rule_code.__get__(self)</span>
        <span class="s0">qtr = self.qtr_with_extra_week</span>
        <span class="s0">return f&quot;{suffix}-{qtr}&quot;</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def _from_name(cls, *args):</span>
        <span class="s0">return cls(</span>
            <span class="s0">**dict(FY5253._parse_suffix(*args[:-1]), qtr_with_extra_week=int(args[-1]))</span>
        <span class="s0">)</span>


<span class="s0">cdef class Easter(SingleConstructorOffset):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset for the Easter holiday using logic defined in dateutil.</span>

    <span class="s0">Right now uses the revised method which is valid in years 1583-4099.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">cpdef __setstate__(self, state):</span>
        <span class="s0">self.n = state.pop(&quot;n&quot;)</span>
        <span class="s0">self.normalize = state.pop(&quot;normalize&quot;)</span>

    <span class="s0">@apply_wraps</span>
    <span class="s0">def _apply(self, other: datetime) -&gt; datetime:</span>
        <span class="s0">current_easter = easter(other.year)</span>
        <span class="s0">current_easter = datetime(</span>
            <span class="s0">current_easter.year, current_easter.month, current_easter.day</span>
        <span class="s0">)</span>
        <span class="s0">current_easter = localize_pydatetime(current_easter, other.tzinfo)</span>

        <span class="s0">n = self.n</span>
        <span class="s0">if n &gt;= 0 and other &lt; current_easter:</span>
            <span class="s0">n -= 1</span>
        <span class="s0">elif n &lt; 0 and other &gt; current_easter:</span>
            <span class="s0">n += 1</span>
        <span class="s0"># TODO: Why does this handle the 0 case the opposite of others?</span>

        <span class="s0"># NOTE: easter returns a datetime.date so we have to convert to type of</span>
        <span class="s0"># other</span>
        <span class="s0">new = easter(other.year + n)</span>
        <span class="s0">new = datetime(</span>
            <span class="s0">new.year,</span>
            <span class="s0">new.month,</span>
            <span class="s0">new.day,</span>
            <span class="s0">other.hour,</span>
            <span class="s0">other.minute,</span>
            <span class="s0">other.second,</span>
            <span class="s0">other.microsecond,</span>
        <span class="s0">)</span>
        <span class="s0">return new</span>

    <span class="s0">def is_on_offset(self, dt: datetime) -&gt; bool:</span>
        <span class="s0">if self.normalize and not _is_normalized(dt):</span>
            <span class="s0">return False</span>
        <span class="s0">return date(dt.year, dt.month, dt.day) == easter(dt.year)</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># Custom Offset classes</span>


<span class="s0">cdef class CustomBusinessDay(BusinessDay):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset subclass representing custom business days excluding holidays.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">n : int, default 1</span>
    <span class="s0">normalize : bool, default False</span>
        <span class="s0">Normalize start/end dates to midnight before generating date range.</span>
    <span class="s0">weekmask : str, Default 'Mon Tue Wed Thu Fri'</span>
        <span class="s0">Weekmask of valid business days, passed to ``numpy.busdaycalendar``.</span>
    <span class="s0">holidays : list</span>
        <span class="s0">List/array of dates to exclude from the set of valid business days,</span>
        <span class="s0">passed to ``numpy.busdaycalendar``.</span>
    <span class="s0">calendar : pd.HolidayCalendar or np.busdaycalendar</span>
    <span class="s0">offset : timedelta, default timedelta(0)</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">_prefix = &quot;C&quot;</span>
    <span class="s0">_attributes = tuple(</span>
        <span class="s0">[&quot;n&quot;, &quot;normalize&quot;, &quot;weekmask&quot;, &quot;holidays&quot;, &quot;calendar&quot;, &quot;offset&quot;]</span>
    <span class="s0">)</span>

    <span class="s0">def __init__(</span>
        <span class="s0">self,</span>
        <span class="s0">n=1,</span>
        <span class="s0">normalize=False,</span>
        <span class="s0">weekmask=&quot;Mon Tue Wed Thu Fri&quot;,</span>
        <span class="s0">holidays=None,</span>
        <span class="s0">calendar=None,</span>
        <span class="s0">offset=timedelta(0),</span>
    <span class="s0">):</span>
        <span class="s0">BusinessDay.__init__(self, n, normalize, offset)</span>
        <span class="s0">self._init_custom(weekmask, holidays, calendar)</span>

    <span class="s0">cpdef __setstate__(self, state):</span>
        <span class="s0">self.holidays = state.pop(&quot;holidays&quot;)</span>
        <span class="s0">self.weekmask = state.pop(&quot;weekmask&quot;)</span>
        <span class="s0">BusinessDay.__setstate__(self, state)</span>

    <span class="s0">@apply_wraps</span>
    <span class="s0">def _apply(self, other):</span>
        <span class="s0">if self.n &lt;= 0:</span>
            <span class="s0">roll = &quot;forward&quot;</span>
        <span class="s0">else:</span>
            <span class="s0">roll = &quot;backward&quot;</span>

        <span class="s0">if PyDateTime_Check(other):</span>
            <span class="s0">date_in = other</span>
            <span class="s0">np_dt = np.datetime64(date_in.date())</span>

            <span class="s0">np_incr_dt = np.busday_offset(</span>
                <span class="s0">np_dt, self.n, roll=roll, busdaycal=self.calendar</span>
            <span class="s0">)</span>

            <span class="s0">dt_date = np_incr_dt.astype(datetime)</span>
            <span class="s0">result = datetime.combine(dt_date, date_in.time())</span>

            <span class="s0">if self.offset:</span>
                <span class="s0">result = result + self.offset</span>
            <span class="s0">return result</span>

        <span class="s0">elif is_any_td_scalar(other):</span>
            <span class="s0">td = Timedelta(self.offset) + other</span>
            <span class="s0">return BDay(self.n, offset=td.to_pytimedelta(), normalize=self.normalize)</span>
        <span class="s0">else:</span>
            <span class="s0">raise ApplyTypeError(</span>
                <span class="s0">&quot;Only know how to combine trading day with &quot;</span>
                <span class="s0">&quot;datetime, datetime64 or timedelta.&quot;</span>
            <span class="s0">)</span>

    <span class="s0">def apply_index(self, dtindex):</span>
        <span class="s0">raise NotImplementedError</span>

    <span class="s0">def _apply_array(self, dtarr):</span>
        <span class="s0">raise NotImplementedError</span>

    <span class="s0">def is_on_offset(self, dt: datetime) -&gt; bool:</span>
        <span class="s0">if self.normalize and not _is_normalized(dt):</span>
            <span class="s0">return False</span>
        <span class="s0">day64 = _to_dt64D(dt)</span>
        <span class="s0">return np.is_busday(day64, busdaycal=self.calendar)</span>


<span class="s0">cdef class CustomBusinessHour(BusinessHour):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset subclass representing possibly n custom business days.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">n : int, default 1</span>
        <span class="s0">The number of months represented.</span>
    <span class="s0">normalize : bool, default False</span>
        <span class="s0">Normalize start/end dates to midnight before generating date range.</span>
    <span class="s0">weekmask : str, Default 'Mon Tue Wed Thu Fri'</span>
        <span class="s0">Weekmask of valid business days, passed to ``numpy.busdaycalendar``.</span>
    <span class="s0">start : str, default &quot;09:00&quot;</span>
        <span class="s0">Start time of your custom business hour in 24h format.</span>
    <span class="s0">end : str, default: &quot;17:00&quot;</span>
        <span class="s0">End time of your custom business hour in 24h format.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">_prefix = &quot;CBH&quot;</span>
    <span class="s0">_anchor = 0</span>
    <span class="s0">_attributes = tuple(</span>
        <span class="s0">[&quot;n&quot;, &quot;normalize&quot;, &quot;weekmask&quot;, &quot;holidays&quot;, &quot;calendar&quot;, &quot;start&quot;, &quot;end&quot;, &quot;offset&quot;]</span>
    <span class="s0">)</span>

    <span class="s0">def __init__(</span>
        <span class="s0">self,</span>
        <span class="s0">n=1,</span>
        <span class="s0">normalize=False,</span>
        <span class="s0">weekmask=&quot;Mon Tue Wed Thu Fri&quot;,</span>
        <span class="s0">holidays=None,</span>
        <span class="s0">calendar=None,</span>
        <span class="s0">start=&quot;09:00&quot;,</span>
        <span class="s0">end=&quot;17:00&quot;,</span>
        <span class="s0">offset=timedelta(0),</span>
    <span class="s0">):</span>
        <span class="s0">BusinessHour.__init__(self, n, normalize, start=start, end=end, offset=offset)</span>
        <span class="s0">self._init_custom(weekmask, holidays, calendar)</span>


<span class="s0">cdef class _CustomBusinessMonth(BusinessMixin):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">DateOffset subclass representing custom business month(s).</span>

    <span class="s0">Increments between beginning/end of month dates.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">n : int, default 1</span>
        <span class="s0">The number of months represented.</span>
    <span class="s0">normalize : bool, default False</span>
        <span class="s0">Normalize start/end dates to midnight before generating date range.</span>
    <span class="s0">weekmask : str, Default 'Mon Tue Wed Thu Fri'</span>
        <span class="s0">Weekmask of valid business days, passed to ``numpy.busdaycalendar``.</span>
    <span class="s0">holidays : list</span>
        <span class="s0">List/array of dates to exclude from the set of valid business days,</span>
        <span class="s0">passed to ``numpy.busdaycalendar``.</span>
    <span class="s0">calendar : pd.HolidayCalendar or np.busdaycalendar</span>
        <span class="s0">Calendar to integrate.</span>
    <span class="s0">offset : timedelta, default timedelta(0)</span>
        <span class="s0">Time offset to apply.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">_attributes = tuple(</span>
        <span class="s0">[&quot;n&quot;, &quot;normalize&quot;, &quot;weekmask&quot;, &quot;holidays&quot;, &quot;calendar&quot;, &quot;offset&quot;]</span>
    <span class="s0">)</span>

    <span class="s0">def __init__(</span>
        <span class="s0">self,</span>
        <span class="s0">n=1,</span>
        <span class="s0">normalize=False,</span>
        <span class="s0">weekmask=&quot;Mon Tue Wed Thu Fri&quot;,</span>
        <span class="s0">holidays=None,</span>
        <span class="s0">calendar=None,</span>
        <span class="s0">offset=timedelta(0),</span>
    <span class="s0">):</span>
        <span class="s0">BusinessMixin.__init__(self, n, normalize, offset)</span>
        <span class="s0">self._init_custom(weekmask, holidays, calendar)</span>

    <span class="s0">@cache_readonly</span>
    <span class="s0">def cbday_roll(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Define default roll function to be called in apply method.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cbday_kwds = self.kwds.copy()</span>
        <span class="s0">cbday_kwds['offset'] = timedelta(0)</span>

        <span class="s0">cbday = CustomBusinessDay(n=1, normalize=False, **cbday_kwds)</span>

        <span class="s0">if self._prefix.endswith(&quot;S&quot;):</span>
            <span class="s0"># MonthBegin</span>
            <span class="s0">roll_func = cbday.rollforward</span>
        <span class="s0">else:</span>
            <span class="s0"># MonthEnd</span>
            <span class="s0">roll_func = cbday.rollback</span>
        <span class="s0">return roll_func</span>

    <span class="s0">@cache_readonly</span>
    <span class="s0">def m_offset(self):</span>
        <span class="s0">if self._prefix.endswith(&quot;S&quot;):</span>
            <span class="s0"># MonthBegin</span>
            <span class="s0">moff = MonthBegin(n=1, normalize=False)</span>
        <span class="s0">else:</span>
            <span class="s0"># MonthEnd</span>
            <span class="s0">moff = MonthEnd(n=1, normalize=False)</span>
        <span class="s0">return moff</span>

    <span class="s0">@cache_readonly</span>
    <span class="s0">def month_roll(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Define default roll function to be called in apply method.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self._prefix.endswith(&quot;S&quot;):</span>
            <span class="s0"># MonthBegin</span>
            <span class="s0">roll_func = self.m_offset.rollback</span>
        <span class="s0">else:</span>
            <span class="s0"># MonthEnd</span>
            <span class="s0">roll_func = self.m_offset.rollforward</span>
        <span class="s0">return roll_func</span>

    <span class="s0">@apply_wraps</span>
    <span class="s0">def _apply(self, other: datetime) -&gt; datetime:</span>
        <span class="s0"># First move to month offset</span>
        <span class="s0">cur_month_offset_date = self.month_roll(other)</span>

        <span class="s0"># Find this custom month offset</span>
        <span class="s0">compare_date = self.cbday_roll(cur_month_offset_date)</span>
        <span class="s0">n = roll_convention(other.day, self.n, compare_date.day)</span>

        <span class="s0">new = cur_month_offset_date + n * self.m_offset</span>
        <span class="s0">result = self.cbday_roll(new)</span>

        <span class="s0">if self.offset:</span>
            <span class="s0">result = result + self.offset</span>
        <span class="s0">return result</span>


<span class="s0">cdef class CustomBusinessMonthEnd(_CustomBusinessMonth):</span>
    <span class="s0">_prefix = &quot;CBM&quot;</span>


<span class="s0">cdef class CustomBusinessMonthBegin(_CustomBusinessMonth):</span>
    <span class="s0">_prefix = &quot;CBMS&quot;</span>


<span class="s0">BDay = BusinessDay</span>
<span class="s0">BMonthEnd = BusinessMonthEnd</span>
<span class="s0">BMonthBegin = BusinessMonthBegin</span>
<span class="s0">CBMonthEnd = CustomBusinessMonthEnd</span>
<span class="s0">CBMonthBegin = CustomBusinessMonthBegin</span>
<span class="s0">CDay = CustomBusinessDay</span>

<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># to_offset helpers</span>

<span class="s0">prefix_mapping = {</span>
    <span class="s0">offset._prefix: offset</span>
    <span class="s0">for offset in [</span>
        <span class="s0">YearBegin,  # 'AS'</span>
        <span class="s0">YearEnd,  # 'A'</span>
        <span class="s0">BYearBegin,  # 'BAS'</span>
        <span class="s0">BYearEnd,  # 'BA'</span>
        <span class="s0">BusinessDay,  # 'B'</span>
        <span class="s0">BusinessMonthBegin,  # 'BMS'</span>
        <span class="s0">BusinessMonthEnd,  # 'BM'</span>
        <span class="s0">BQuarterEnd,  # 'BQ'</span>
        <span class="s0">BQuarterBegin,  # 'BQS'</span>
        <span class="s0">BusinessHour,  # 'BH'</span>
        <span class="s0">CustomBusinessDay,  # 'C'</span>
        <span class="s0">CustomBusinessMonthEnd,  # 'CBM'</span>
        <span class="s0">CustomBusinessMonthBegin,  # 'CBMS'</span>
        <span class="s0">CustomBusinessHour,  # 'CBH'</span>
        <span class="s0">MonthEnd,  # 'M'</span>
        <span class="s0">MonthBegin,  # 'MS'</span>
        <span class="s0">Nano,  # 'N'</span>
        <span class="s0">SemiMonthEnd,  # 'SM'</span>
        <span class="s0">SemiMonthBegin,  # 'SMS'</span>
        <span class="s0">Week,  # 'W'</span>
        <span class="s0">Second,  # 'S'</span>
        <span class="s0">Minute,  # 'T'</span>
        <span class="s0">Micro,  # 'U'</span>
        <span class="s0">QuarterEnd,  # 'Q'</span>
        <span class="s0">QuarterBegin,  # 'QS'</span>
        <span class="s0">Milli,  # 'L'</span>
        <span class="s0">Hour,  # 'H'</span>
        <span class="s0">Day,  # 'D'</span>
        <span class="s0">WeekOfMonth,  # 'WOM'</span>
        <span class="s0">FY5253,</span>
        <span class="s0">FY5253Quarter,</span>
    <span class="s0">]</span>
<span class="s0">}</span>

<span class="s0"># hack to handle WOM-1MON</span>
<span class="s0">opattern = re.compile(</span>
    <span class="s0">r&quot;([+\-]?\d*|[+\-]?\d*\.\d*)\s*([A-Za-z]+([\-][\dA-Za-z\-]+)?)&quot;</span>
<span class="s0">)</span>

<span class="s0">_lite_rule_alias = {</span>
    <span class="s0">&quot;W&quot;: &quot;W-SUN&quot;,</span>
    <span class="s0">&quot;Q&quot;: &quot;Q-DEC&quot;,</span>

    <span class="s0">&quot;A&quot;: &quot;A-DEC&quot;,      # YearEnd(month=12),</span>
    <span class="s0">&quot;Y&quot;: &quot;A-DEC&quot;,</span>
    <span class="s0">&quot;AS&quot;: &quot;AS-JAN&quot;,    # YearBegin(month=1),</span>
    <span class="s0">&quot;YS&quot;: &quot;AS-JAN&quot;,</span>
    <span class="s0">&quot;BA&quot;: &quot;BA-DEC&quot;,    # BYearEnd(month=12),</span>
    <span class="s0">&quot;BY&quot;: &quot;BA-DEC&quot;,</span>
    <span class="s0">&quot;BAS&quot;: &quot;BAS-JAN&quot;,  # BYearBegin(month=1),</span>
    <span class="s0">&quot;BYS&quot;: &quot;BAS-JAN&quot;,</span>

    <span class="s0">&quot;Min&quot;: &quot;T&quot;,</span>
    <span class="s0">&quot;min&quot;: &quot;T&quot;,</span>
    <span class="s0">&quot;ms&quot;: &quot;L&quot;,</span>
    <span class="s0">&quot;us&quot;: &quot;U&quot;,</span>
    <span class="s0">&quot;ns&quot;: &quot;N&quot;,</span>
<span class="s0">}</span>

<span class="s0">_dont_uppercase = {&quot;MS&quot;, &quot;ms&quot;}</span>

<span class="s0">INVALID_FREQ_ERR_MSG = &quot;Invalid frequency: {0}&quot;</span>

<span class="s0"># TODO: still needed?</span>
<span class="s0"># cache of previously seen offsets</span>
<span class="s0">_offset_map = {}</span>


<span class="s0"># TODO: better name?</span>
<span class="s0">def _get_offset(name: str) -&gt; BaseOffset:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Return DateOffset object associated with rule name.</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">_get_offset('EOM') --&gt; BMonthEnd(1)</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if name not in _dont_uppercase:</span>
        <span class="s0">name = name.upper()</span>
        <span class="s0">name = _lite_rule_alias.get(name, name)</span>
        <span class="s0">name = _lite_rule_alias.get(name.lower(), name)</span>
    <span class="s0">else:</span>
        <span class="s0">name = _lite_rule_alias.get(name, name)</span>

    <span class="s0">if name not in _offset_map:</span>
        <span class="s0">try:</span>
            <span class="s0">split = name.split(&quot;-&quot;)</span>
            <span class="s0">klass = prefix_mapping[split[0]]</span>
            <span class="s0"># handles case where there's no suffix (and will TypeError if too</span>
            <span class="s0"># many '-')</span>
            <span class="s0">offset = klass._from_name(*split[1:])</span>
        <span class="s0">except (ValueError, TypeError, KeyError) as err:</span>
            <span class="s0"># bad prefix or suffix</span>
            <span class="s0">raise ValueError(INVALID_FREQ_ERR_MSG.format(name)) from err</span>
        <span class="s0"># cache</span>
        <span class="s0">_offset_map[name] = offset</span>

    <span class="s0">return _offset_map[name]</span>


<span class="s0">cpdef to_offset(freq):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Return DateOffset object from string or tuple representation</span>
    <span class="s0">or datetime.timedelta object.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">freq : str, datetime.timedelta, BaseOffset or None</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">DateOffset or None</span>

    <span class="s0">Raises</span>
    <span class="s0">------</span>
    <span class="s0">ValueError</span>
        <span class="s0">If freq is an invalid frequency</span>

    <span class="s0">See Also</span>
    <span class="s0">--------</span>
    <span class="s0">BaseOffset : Standard kind of date increment used for a date range.</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">&gt;&gt;&gt; to_offset(&quot;5min&quot;)</span>
    <span class="s0">&lt;5 * Minutes&gt;</span>

    <span class="s0">&gt;&gt;&gt; to_offset(&quot;1D1H&quot;)</span>
    <span class="s0">&lt;25 * Hours&gt;</span>

    <span class="s0">&gt;&gt;&gt; to_offset(&quot;2W&quot;)</span>
    <span class="s0">&lt;2 * Weeks: weekday=6&gt;</span>

    <span class="s0">&gt;&gt;&gt; to_offset(&quot;2B&quot;)</span>
    <span class="s0">&lt;2 * BusinessDays&gt;</span>

    <span class="s0">&gt;&gt;&gt; to_offset(pd.Timedelta(days=1))</span>
    <span class="s0">&lt;Day&gt;</span>

    <span class="s0">&gt;&gt;&gt; to_offset(Hour())</span>
    <span class="s0">&lt;Hour&gt;</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if freq is None:</span>
        <span class="s0">return None</span>

    <span class="s0">if isinstance(freq, BaseOffset):</span>
        <span class="s0">return freq</span>

    <span class="s0">if isinstance(freq, tuple):</span>
        <span class="s0">raise TypeError(</span>
            <span class="s0">f&quot;to_offset does not support tuples {freq}, pass as a string instead&quot;</span>
        <span class="s0">)</span>

    <span class="s0">elif PyDelta_Check(freq):</span>
        <span class="s0">return delta_to_tick(freq)</span>

    <span class="s0">elif isinstance(freq, str):</span>
        <span class="s0">delta = None</span>
        <span class="s0">stride_sign = None</span>

        <span class="s0">try:</span>
            <span class="s0">split = opattern.split(freq)</span>
            <span class="s0">if split[-1] != &quot;&quot; and not split[-1].isspace():</span>
                <span class="s0"># the last element must be blank</span>
                <span class="s0">raise ValueError(&quot;last element must be blank&quot;)</span>

            <span class="s0">tups = zip(split[0::4], split[1::4], split[2::4])</span>
            <span class="s0">for n, (sep, stride, name) in enumerate(tups):</span>
                <span class="s0">if sep != &quot;&quot; and not sep.isspace():</span>
                    <span class="s0">raise ValueError(&quot;separator must be spaces&quot;)</span>
                <span class="s0">prefix = _lite_rule_alias.get(name) or name</span>
                <span class="s0">if stride_sign is None:</span>
                    <span class="s0">stride_sign = -1 if stride.startswith(&quot;-&quot;) else 1</span>
                <span class="s0">if not stride:</span>
                    <span class="s0">stride = 1</span>

                <span class="s0">if prefix in {&quot;D&quot;, &quot;H&quot;, &quot;T&quot;, &quot;S&quot;, &quot;L&quot;, &quot;U&quot;, &quot;N&quot;}:</span>
                    <span class="s0"># For these prefixes, we have something like &quot;3H&quot; or</span>
                    <span class="s0">#  &quot;2.5T&quot;, so we can construct a Timedelta with the</span>
                    <span class="s0">#  matching unit and get our offset from delta_to_tick</span>
                    <span class="s0">td = Timedelta(1, unit=prefix)</span>
                    <span class="s0">off = delta_to_tick(td)</span>
                    <span class="s0">offset = off * float(stride)</span>
                    <span class="s0">if n != 0:</span>
                        <span class="s0"># If n==0, then stride_sign is already incorporated</span>
                        <span class="s0">#  into the offset</span>
                        <span class="s0">offset *= stride_sign</span>
                <span class="s0">else:</span>
                    <span class="s0">stride = int(stride)</span>
                    <span class="s0">offset = _get_offset(name)</span>
                    <span class="s0">offset = offset * int(np.fabs(stride) * stride_sign)</span>

                <span class="s0">if delta is None:</span>
                    <span class="s0">delta = offset</span>
                <span class="s0">else:</span>
                    <span class="s0">delta = delta + offset</span>
        <span class="s0">except (ValueError, TypeError) as err:</span>
            <span class="s0">raise ValueError(INVALID_FREQ_ERR_MSG.format(freq)) from err</span>
    <span class="s0">else:</span>
        <span class="s0">delta = None</span>

    <span class="s0">if delta is None:</span>
        <span class="s0">raise ValueError(INVALID_FREQ_ERR_MSG.format(freq))</span>

    <span class="s0">return delta</span>


<span class="s0"># ----------------------------------------------------------------------</span>
<span class="s0"># RelativeDelta Arithmetic</span>

<span class="s0">def shift_day(other: datetime, days: int) -&gt; datetime:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Increment the datetime `other` by the given number of days, retaining</span>
    <span class="s0">the time-portion of the datetime.  For tz-naive datetimes this is</span>
    <span class="s0">equivalent to adding a timedelta.  For tz-aware datetimes it is similar to</span>
    <span class="s0">dateutil's relativedelta.__add__, but handles pytz tzinfo objects.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">other : datetime or Timestamp</span>
    <span class="s0">days : int</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">shifted: datetime or Timestamp</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if other.tzinfo is None:</span>
        <span class="s0">return other + timedelta(days=days)</span>

    <span class="s0">tz = other.tzinfo</span>
    <span class="s0">naive = other.replace(tzinfo=None)</span>
    <span class="s0">shifted = naive + timedelta(days=days)</span>
    <span class="s0">return localize_pydatetime(shifted, tz)</span>


<span class="s0">cdef inline int year_add_months(npy_datetimestruct dts, int months) nogil:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">New year number after shifting npy_datetimestruct number of months.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">return dts.year + (dts.month + months - 1) // 12</span>


<span class="s0">cdef inline int month_add_months(npy_datetimestruct dts, int months) nogil:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">New month number after shifting npy_datetimestruct</span>
    <span class="s0">number of months.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">int new_month = (dts.month + months) % 12</span>
    <span class="s0">return 12 if new_month == 0 else new_month</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">cdef shift_quarters(</span>
    <span class="s0">const int64_t[:] dtindex,</span>
    <span class="s0">int quarters,</span>
    <span class="s0">int q1start_month,</span>
    <span class="s0">object day_opt,</span>
    <span class="s0">int modby=3,</span>
<span class="s0">):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Given an int64 array representing nanosecond timestamps, shift all elements</span>
    <span class="s0">by the specified number of quarters using DateOffset semantics.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">dtindex : int64_t[:] timestamps for input dates</span>
    <span class="s0">quarters : int number of quarters to shift</span>
    <span class="s0">q1start_month : int month in which Q1 begins by convention</span>
    <span class="s0">day_opt : {'start', 'end', 'business_start', 'business_end'}</span>
    <span class="s0">modby : int (3 for quarters, 12 for years)</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">out : ndarray[int64_t]</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t count = len(dtindex)</span>
        <span class="s0">int64_t[:] out = np.empty(count, dtype=&quot;int64&quot;)</span>

    <span class="s0">if day_opt not in [&quot;start&quot;, &quot;end&quot;, &quot;business_start&quot;, &quot;business_end&quot;]:</span>
        <span class="s0">raise ValueError(&quot;day must be None, 'start', 'end', &quot;</span>
                         <span class="s0">&quot;'business_start', or 'business_end'&quot;)</span>

    <span class="s0">_shift_quarters(dtindex, out, count, quarters, q1start_month, day_opt, modby)</span>
    <span class="s0">return np.asarray(out)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">def shift_months(const int64_t[:] dtindex, int months, object day_opt=None):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Given an int64-based datetime index, shift all elements</span>
    <span class="s0">specified number of months using DateOffset semantics</span>

    <span class="s0">day_opt: {None, 'start', 'end', 'business_start', 'business_end'}</span>
       <span class="s0">* None: day of month</span>
       <span class="s0">* 'start' 1st day of month</span>
       <span class="s0">* 'end' last day of month</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i</span>
        <span class="s0">npy_datetimestruct dts</span>
        <span class="s0">int count = len(dtindex)</span>
        <span class="s0">int64_t[:] out = np.empty(count, dtype=&quot;int64&quot;)</span>

    <span class="s0">if day_opt is None:</span>
        <span class="s0">with nogil:</span>
            <span class="s0">for i in range(count):</span>
                <span class="s0">if dtindex[i] == NPY_NAT:</span>
                    <span class="s0">out[i] = NPY_NAT</span>
                    <span class="s0">continue</span>

                <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
                <span class="s0">dts.year = year_add_months(dts, months)</span>
                <span class="s0">dts.month = month_add_months(dts, months)</span>

                <span class="s0">dts.day = min(dts.day, get_days_in_month(dts.year, dts.month))</span>
                <span class="s0">out[i] = dtstruct_to_dt64(&amp;dts)</span>
    <span class="s0">elif day_opt in [&quot;start&quot;, &quot;end&quot;, &quot;business_start&quot;, &quot;business_end&quot;]:</span>
        <span class="s0">_shift_months(dtindex, out, count, months, day_opt)</span>
    <span class="s0">else:</span>
        <span class="s0">raise ValueError(&quot;day must be None, 'start', 'end', &quot;</span>
                         <span class="s0">&quot;'business_start', or 'business_end'&quot;)</span>

    <span class="s0">return np.asarray(out)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">cdef inline void _shift_months(const int64_t[:] dtindex,</span>
                               <span class="s0">int64_t[:] out,</span>
                               <span class="s0">Py_ssize_t count,</span>
                               <span class="s0">int months,</span>
                               <span class="s0">str day_opt) nogil:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">See shift_months.__doc__</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i</span>
        <span class="s0">int months_to_roll</span>
        <span class="s0">npy_datetimestruct dts</span>

    <span class="s0">for i in range(count):</span>
        <span class="s0">if dtindex[i] == NPY_NAT:</span>
            <span class="s0">out[i] = NPY_NAT</span>
            <span class="s0">continue</span>

        <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
        <span class="s0">months_to_roll = months</span>

        <span class="s0">months_to_roll = _roll_qtrday(&amp;dts, months_to_roll, 0, day_opt)</span>

        <span class="s0">dts.year = year_add_months(dts, months_to_roll)</span>
        <span class="s0">dts.month = month_add_months(dts, months_to_roll)</span>
        <span class="s0">dts.day = get_day_of_month(&amp;dts, day_opt)</span>

        <span class="s0">out[i] = dtstruct_to_dt64(&amp;dts)</span>


<span class="s0">@cython.wraparound(False)</span>
<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">cdef inline void _shift_quarters(const int64_t[:] dtindex,</span>
                                 <span class="s0">int64_t[:] out,</span>
                                 <span class="s0">Py_ssize_t count,</span>
                                 <span class="s0">int quarters,</span>
                                 <span class="s0">int q1start_month,</span>
                                 <span class="s0">str day_opt,</span>
                                 <span class="s0">int modby) nogil:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">See shift_quarters.__doc__</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i</span>
        <span class="s0">int months_since, n</span>
        <span class="s0">npy_datetimestruct dts</span>

    <span class="s0">for i in range(count):</span>
        <span class="s0">if dtindex[i] == NPY_NAT:</span>
            <span class="s0">out[i] = NPY_NAT</span>
            <span class="s0">continue</span>

        <span class="s0">dt64_to_dtstruct(dtindex[i], &amp;dts)</span>
        <span class="s0">n = quarters</span>

        <span class="s0">months_since = (dts.month - q1start_month) % modby</span>
        <span class="s0">n = _roll_qtrday(&amp;dts, n, months_since, day_opt)</span>

        <span class="s0">dts.year = year_add_months(dts, modby * n - months_since)</span>
        <span class="s0">dts.month = month_add_months(dts, modby * n - months_since)</span>
        <span class="s0">dts.day = get_day_of_month(&amp;dts, day_opt)</span>

        <span class="s0">out[i] = dtstruct_to_dt64(&amp;dts)</span>


<span class="s0">cdef ndarray[int64_t] _shift_bdays(const int64_t[:] i8other, int periods):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Implementation of BusinessDay.apply_offset.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">i8other : const int64_t[:]</span>
    <span class="s0">periods : int</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">ndarray[int64_t]</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n = len(i8other)</span>
        <span class="s0">int64_t[:] result = np.empty(n, dtype=&quot;i8&quot;)</span>
        <span class="s0">int64_t val, res</span>
        <span class="s0">int wday, nadj, days</span>
        <span class="s0">npy_datetimestruct dts</span>

    <span class="s0">for i in range(n):</span>
        <span class="s0">val = i8other[i]</span>
        <span class="s0">if val == NPY_NAT:</span>
            <span class="s0">result[i] = NPY_NAT</span>
        <span class="s0">else:</span>
            <span class="s0"># The rest of this is effectively a copy of BusinessDay.apply</span>
            <span class="s0">nadj = periods</span>
            <span class="s0">weeks = nadj // 5</span>
            <span class="s0">dt64_to_dtstruct(val, &amp;dts)</span>
            <span class="s0">wday = dayofweek(dts.year, dts.month, dts.day)</span>

            <span class="s0">if nadj &lt;= 0 and wday &gt; 4:</span>
                <span class="s0"># roll forward</span>
                <span class="s0">nadj += 1</span>

            <span class="s0">nadj -= 5 * weeks</span>

            <span class="s0"># nadj is always &gt;= 0 at this point</span>
            <span class="s0">if nadj == 0 and wday &gt; 4:</span>
                <span class="s0"># roll back</span>
                <span class="s0">days = 4 - wday</span>
            <span class="s0">elif wday &gt; 4:</span>
                <span class="s0"># roll forward</span>
                <span class="s0">days = (7 - wday) + (nadj - 1)</span>
            <span class="s0">elif wday + nadj &lt;= 4:</span>
                <span class="s0"># shift by n days without leaving the current week</span>
                <span class="s0">days = nadj</span>
            <span class="s0">else:</span>
                <span class="s0"># shift by nadj days plus 2 to get past the weekend</span>
                <span class="s0">days = nadj + 2</span>

            <span class="s0">res = val + (7 * weeks + days) * DAY_NANOS</span>
            <span class="s0">result[i] = res</span>

    <span class="s0">return result.base</span>


<span class="s0">def shift_month(stamp: datetime, months: int, day_opt: object = None) -&gt; datetime:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Given a datetime (or Timestamp) `stamp`, an integer `months` and an</span>
    <span class="s0">option `day_opt`, return a new datetimelike that many months later,</span>
    <span class="s0">with day determined by `day_opt` using relativedelta semantics.</span>

    <span class="s0">Scalar analogue of shift_months</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">stamp : datetime or Timestamp</span>
    <span class="s0">months : int</span>
    <span class="s0">day_opt : None, 'start', 'end', 'business_start', 'business_end', or int</span>
        <span class="s0">None: returned datetimelike has the same day as the input, or the</span>
              <span class="s0">last day of the month if the new month is too short</span>
        <span class="s0">'start': returned datetimelike has day=1</span>
        <span class="s0">'end': returned datetimelike has day on the last day of the month</span>
        <span class="s0">'business_start': returned datetimelike has day on the first</span>
            <span class="s0">business day of the month</span>
        <span class="s0">'business_end': returned datetimelike has day on the last</span>
            <span class="s0">business day of the month</span>
        <span class="s0">int: returned datetimelike has day equal to day_opt</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">shifted : datetime or Timestamp (same as input `stamp`)</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">int year, month, day</span>
        <span class="s0">int days_in_month, dy</span>

    <span class="s0">dy = (stamp.month + months) // 12</span>
    <span class="s0">month = (stamp.month + months) % 12</span>

    <span class="s0">if month == 0:</span>
        <span class="s0">month = 12</span>
        <span class="s0">dy -= 1</span>
    <span class="s0">year = stamp.year + dy</span>

    <span class="s0">if day_opt is None:</span>
        <span class="s0">days_in_month = get_days_in_month(year, month)</span>
        <span class="s0">day = min(stamp.day, days_in_month)</span>
    <span class="s0">elif day_opt == &quot;start&quot;:</span>
        <span class="s0">day = 1</span>
    <span class="s0">elif day_opt == &quot;end&quot;:</span>
        <span class="s0">day = get_days_in_month(year, month)</span>
    <span class="s0">elif day_opt == &quot;business_start&quot;:</span>
        <span class="s0"># first business day of month</span>
        <span class="s0">day = get_firstbday(year, month)</span>
    <span class="s0">elif day_opt == &quot;business_end&quot;:</span>
        <span class="s0"># last business day of month</span>
        <span class="s0">day = get_lastbday(year, month)</span>
    <span class="s0">elif is_integer_object(day_opt):</span>
        <span class="s0">days_in_month = get_days_in_month(year, month)</span>
        <span class="s0">day = min(day_opt, days_in_month)</span>
    <span class="s0">else:</span>
        <span class="s0">raise ValueError(day_opt)</span>
    <span class="s0">return stamp.replace(year=year, month=month, day=day)</span>


<span class="s0">cdef inline int get_day_of_month(npy_datetimestruct* dts, str day_opt) nogil:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Find the day in `other`'s month that satisfies a DateOffset's is_on_offset</span>
    <span class="s0">policy, as described by the `day_opt` argument.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">dts : npy_datetimestruct*</span>
    <span class="s0">day_opt : {'start', 'end', 'business_start', 'business_end'}</span>
        <span class="s0">'start': returns 1</span>
        <span class="s0">'end': returns last day of the month</span>
        <span class="s0">'business_start': returns the first business day of the month</span>
        <span class="s0">'business_end': returns the last business day of the month</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">day_of_month : int</span>

    <span class="s0">Examples</span>
    <span class="s0">-------</span>
    <span class="s0">&gt;&gt;&gt; other = datetime(2017, 11, 14)</span>
    <span class="s0">&gt;&gt;&gt; get_day_of_month(other, 'start')</span>
    <span class="s0">1</span>
    <span class="s0">&gt;&gt;&gt; get_day_of_month(other, 'end')</span>
    <span class="s0">30</span>

    <span class="s0">Notes</span>
    <span class="s0">-----</span>
    <span class="s0">Caller is responsible for ensuring one of the four accepted day_opt values</span>
    <span class="s0">is passed.</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">if day_opt == &quot;start&quot;:</span>
        <span class="s0">return 1</span>
    <span class="s0">elif day_opt == &quot;end&quot;:</span>
        <span class="s0">return get_days_in_month(dts.year, dts.month)</span>
    <span class="s0">elif day_opt == &quot;business_start&quot;:</span>
        <span class="s0"># first business day of month</span>
        <span class="s0">return get_firstbday(dts.year, dts.month)</span>
    <span class="s0">else:</span>
        <span class="s0"># i.e. day_opt == &quot;business_end&quot;:</span>
        <span class="s0"># last business day of month</span>
        <span class="s0">return get_lastbday(dts.year, dts.month)</span>


<span class="s0">cpdef int roll_convention(int other, int n, int compare) nogil:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Possibly increment or decrement the number of periods to shift</span>
    <span class="s0">based on rollforward/rollbackward conventions.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">other : int, generally the day component of a datetime</span>
    <span class="s0">n : number of periods to increment, before adjusting for rolling</span>
    <span class="s0">compare : int, generally the day component of a datetime, in the same</span>
              <span class="s0">month as the datetime form which `other` was taken.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">n : int number of periods to increment</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">if n &gt; 0 and other &lt; compare:</span>
        <span class="s0">n -= 1</span>
    <span class="s0">elif n &lt;= 0 and other &gt; compare:</span>
        <span class="s0"># as if rolled forward already</span>
        <span class="s0">n += 1</span>
    <span class="s0">return n</span>


<span class="s0">def roll_qtrday(other: datetime, n: int, month: int,</span>
                <span class="s0">day_opt: str, modby: int) -&gt; int:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Possibly increment or decrement the number of periods to shift</span>
    <span class="s0">based on rollforward/rollbackward conventions.</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">other : datetime or Timestamp</span>
    <span class="s0">n : number of periods to increment, before adjusting for rolling</span>
    <span class="s0">month : int reference month giving the first month of the year</span>
    <span class="s0">day_opt : {'start', 'end', 'business_start', 'business_end'}</span>
        <span class="s0">The convention to use in finding the day in a given month against</span>
        <span class="s0">which to compare for rollforward/rollbackward decisions.</span>
    <span class="s0">modby : int 3 for quarters, 12 for years</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">n : int number of periods to increment</span>

    <span class="s0">See Also</span>
    <span class="s0">--------</span>
    <span class="s0">get_day_of_month : Find the day in a month provided an offset.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">int months_since</span>
        <span class="s0">npy_datetimestruct dts</span>

    <span class="s0">if day_opt not in [&quot;start&quot;, &quot;end&quot;, &quot;business_start&quot;, &quot;business_end&quot;]:</span>
        <span class="s0">raise ValueError(day_opt)</span>

    <span class="s0">pydate_to_dtstruct(other, &amp;dts)</span>

    <span class="s0">if modby == 12:</span>
        <span class="s0"># We care about the month-of-year, not month-of-quarter, so skip mod</span>
        <span class="s0">months_since = other.month - month</span>
    <span class="s0">else:</span>
        <span class="s0">months_since = other.month % modby - month % modby</span>

    <span class="s0">return _roll_qtrday(&amp;dts, n, months_since, day_opt)</span>


<span class="s0">cdef inline int _roll_qtrday(npy_datetimestruct* dts,</span>
                             <span class="s0">int n,</span>
                             <span class="s0">int months_since,</span>
                             <span class="s0">str day_opt) nogil except? -1:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">See roll_qtrday.__doc__</span>
    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">if n &gt; 0:</span>
        <span class="s0">if months_since &lt; 0 or (months_since == 0 and</span>
                                <span class="s0">dts.day &lt; get_day_of_month(dts, day_opt)):</span>
            <span class="s0"># pretend to roll back if on same month but</span>
            <span class="s0"># before compare_day</span>
            <span class="s0">n -= 1</span>
    <span class="s0">else:</span>
        <span class="s0">if months_since &gt; 0 or (months_since == 0 and</span>
                                <span class="s0">dts.day &gt; get_day_of_month(dts, day_opt)):</span>
            <span class="s0"># make sure to roll forward, so negate</span>
            <span class="s0">n += 1</span>
    <span class="s0">return n</span>
</pre>
</body>
</html>