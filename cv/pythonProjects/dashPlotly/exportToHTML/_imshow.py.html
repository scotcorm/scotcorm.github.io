<html>
<head>
<title>_imshow.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_imshow.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">plotly.graph_objs </span><span class="s0">as </span><span class="s1">go</span>
<span class="s0">from </span><span class="s1">_plotly_utils.basevalidators </span><span class="s0">import </span><span class="s1">ColorscaleValidator</span>
<span class="s0">from </span><span class="s1">._core </span><span class="s0">import </span><span class="s1">apply_default_cascade</span><span class="s0">, </span><span class="s1">init_figure</span><span class="s0">, </span><span class="s1">configure_animation_controls</span>
<span class="s0">from </span><span class="s1">.imshow_utils </span><span class="s0">import </span><span class="s1">rescale_intensity</span><span class="s0">, </span><span class="s1">_integer_ranges</span><span class="s0">, </span><span class="s1">_integer_types</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">from </span><span class="s1">plotly.utils </span><span class="s0">import </span><span class="s1">image_array_to_data_uri</span>

<span class="s0">try</span><span class="s1">:</span>
    <span class="s0">import </span><span class="s1">xarray</span>

    <span class="s1">xarray_imported = </span><span class="s0">True</span>
<span class="s0">except </span><span class="s1">ImportError:</span>
    <span class="s1">xarray_imported = </span><span class="s0">False</span>

<span class="s1">_float_types = []</span>


<span class="s0">def </span><span class="s1">_vectorize_zvalue(z</span><span class="s0">, </span><span class="s1">mode=</span><span class="s2">&quot;max&quot;</span><span class="s1">):</span>
    <span class="s1">alpha = </span><span class="s3">255 </span><span class="s0">if </span><span class="s1">mode == </span><span class="s2">&quot;max&quot; </span><span class="s0">else </span><span class="s3">0</span>
    <span class="s0">if </span><span class="s1">z </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">z</span>
    <span class="s0">elif </span><span class="s1">np.isscalar(z):</span>
        <span class="s0">return </span><span class="s1">[z] * </span><span class="s3">3 </span><span class="s1">+ [alpha]</span>
    <span class="s0">elif </span><span class="s1">len(z) == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">list(z) * </span><span class="s3">3 </span><span class="s1">+ [alpha]</span>
    <span class="s0">elif </span><span class="s1">len(z) == </span><span class="s3">3</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">list(z) + [alpha]</span>
    <span class="s0">elif </span><span class="s1">len(z) == </span><span class="s3">4</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">z</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s2">&quot;zmax can be a scalar, or an iterable of length 1, 3 or 4. &quot;</span>
            <span class="s2">&quot;A value of %s was passed for zmax.&quot; </span><span class="s1">% str(z)</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_infer_zmax_from_type(img):</span>
    <span class="s1">dt = img.dtype.type</span>
    <span class="s1">rtol = </span><span class="s3">1.05</span>
    <span class="s0">if </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">_integer_types:</span>
        <span class="s0">return </span><span class="s1">_integer_ranges[dt][</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">im_max = img[np.isfinite(img)].max()</span>
        <span class="s0">if </span><span class="s1">im_max &lt;= </span><span class="s3">1 </span><span class="s1">* rtol:</span>
            <span class="s0">return </span><span class="s3">1</span>
        <span class="s0">elif </span><span class="s1">im_max &lt;= </span><span class="s3">255 </span><span class="s1">* rtol:</span>
            <span class="s0">return </span><span class="s3">255</span>
        <span class="s0">elif </span><span class="s1">im_max &lt;= </span><span class="s3">65535 </span><span class="s1">* rtol:</span>
            <span class="s0">return </span><span class="s3">65535</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s3">2 </span><span class="s1">** </span><span class="s3">32</span>


<span class="s0">def </span><span class="s1">imshow(</span>
    <span class="s1">img</span><span class="s0">,</span>
    <span class="s1">zmin=</span><span class="s0">None,</span>
    <span class="s1">zmax=</span><span class="s0">None,</span>
    <span class="s1">origin=</span><span class="s0">None,</span>
    <span class="s1">labels={}</span><span class="s0">,</span>
    <span class="s1">x=</span><span class="s0">None,</span>
    <span class="s1">y=</span><span class="s0">None,</span>
    <span class="s1">animation_frame=</span><span class="s0">None,</span>
    <span class="s1">facet_col=</span><span class="s0">None,</span>
    <span class="s1">facet_col_wrap=</span><span class="s0">None,</span>
    <span class="s1">facet_col_spacing=</span><span class="s0">None,</span>
    <span class="s1">facet_row_spacing=</span><span class="s0">None,</span>
    <span class="s1">color_continuous_scale=</span><span class="s0">None,</span>
    <span class="s1">color_continuous_midpoint=</span><span class="s0">None,</span>
    <span class="s1">range_color=</span><span class="s0">None,</span>
    <span class="s1">title=</span><span class="s0">None,</span>
    <span class="s1">template=</span><span class="s0">None,</span>
    <span class="s1">width=</span><span class="s0">None,</span>
    <span class="s1">height=</span><span class="s0">None,</span>
    <span class="s1">aspect=</span><span class="s0">None,</span>
    <span class="s1">contrast_rescaling=</span><span class="s0">None,</span>
    <span class="s1">binary_string=</span><span class="s0">None,</span>
    <span class="s1">binary_backend=</span><span class="s2">&quot;auto&quot;</span><span class="s0">,</span>
    <span class="s1">binary_compression_level=</span><span class="s3">4</span><span class="s0">,</span>
    <span class="s1">binary_format=</span><span class="s2">&quot;png&quot;</span><span class="s0">,</span>
    <span class="s1">text_auto=</span><span class="s0">False,</span>
<span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Display an image, i.e. data on a 2D regular raster. 
 
    Parameters 
    ---------- 
 
    img: array-like image, or xarray 
        The image data. Supported array shapes are 
 
        - (M, N): an image with scalar data. The data is visualized 
          using a colormap. 
        - (M, N, 3): an image with RGB values. 
        - (M, N, 4): an image with RGBA values, i.e. including transparency. 
 
    zmin, zmax : scalar or iterable, optional 
        zmin and zmax define the scalar range that the colormap covers. By default, 
        zmin and zmax correspond to the min and max values of the datatype for integer 
        datatypes (ie [0-255] for uint8 images, [0, 65535] for uint16 images, etc.). For 
        a multichannel image of floats, the max of the image is computed and zmax is the 
        smallest power of 256 (1, 255, 65535) greater than this max value, 
        with a 5% tolerance. For a single-channel image, the max of the image is used. 
        Overridden by range_color. 
 
    origin : str, 'upper' or 'lower' (default 'upper') 
        position of the [0, 0] pixel of the image array, in the upper left or lower left 
        corner. The convention 'upper' is typically used for matrices and images. 
 
    labels : dict with str keys and str values (default `{}`) 
        Sets names used in the figure for axis titles (keys ``x`` and ``y``), 
        colorbar title and hoverlabel (key ``color``). The values should correspond 
        to the desired label to be displayed. If ``img`` is an xarray, dimension 
        names are used for axis titles, and long name for the colorbar title 
        (unless overridden in ``labels``). Possible keys are: x, y, and color. 
 
    x, y: list-like, optional 
        x and y are used to label the axes of single-channel heatmap visualizations and 
        their lengths must match the lengths of the second and first dimensions of the 
        img argument. They are auto-populated if the input is an xarray. 
 
    animation_frame: int or str, optional (default None) 
        axis number along which the image array is sliced to create an animation plot. 
        If `img` is an xarray, `animation_frame` can be the name of one the dimensions. 
 
    facet_col: int or str, optional (default None) 
        axis number along which the image array is sliced to create a facetted plot. 
        If `img` is an xarray, `facet_col` can be the name of one the dimensions. 
 
    facet_col_wrap: int 
        Maximum number of facet columns. Wraps the column variable at this width, 
        so that the column facets span multiple rows. 
        Ignored if `facet_col` is None. 
 
    facet_col_spacing: float between 0 and 1 
        Spacing between facet columns, in paper units. Default is 0.02. 
 
    facet_row_spacing: float between 0 and 1 
        Spacing between facet rows created when ``facet_col_wrap`` is used, in 
        paper units. Default is 0.0.7. 
 
    color_continuous_scale : str or list of str 
        colormap used to map scalar data to colors (for a 2D image). This parameter is 
        not used for RGB or RGBA images. If a string is provided, it should be the name 
        of a known color scale, and if a list is provided, it should be a list of CSS- 
        compatible colors. 
 
    color_continuous_midpoint : number 
        If set, computes the bounds of the continuous color scale to have the desired 
        midpoint. Overridden by range_color or zmin and zmax. 
 
    range_color : list of two numbers 
        If provided, overrides auto-scaling on the continuous color scale, including 
        overriding `color_continuous_midpoint`. Also overrides zmin and zmax. Used only 
        for single-channel images. 
 
    title : str 
        The figure title. 
 
    template : str or dict or plotly.graph_objects.layout.Template instance 
        The figure template name or definition. 
 
    width : number 
        The figure width in pixels. 
 
    height: number 
        The figure height in pixels. 
 
    aspect: 'equal', 'auto', or None 
      - 'equal': Ensures an aspect ratio of 1 or pixels (square pixels) 
      - 'auto': The axes is kept fixed and the aspect ratio of pixels is 
        adjusted so that the data fit in the axes. In general, this will 
        result in non-square pixels. 
      - if None, 'equal' is used for numpy arrays and 'auto' for xarrays 
        (which have typically heterogeneous coordinates) 
 
    contrast_rescaling: 'minmax', 'infer', or None 
        how to determine data values corresponding to the bounds of the color 
        range, when zmin or zmax are not passed. If `minmax`, the min and max 
        values of the image are used. If `infer`, a heuristic based on the image 
        data type is used. 
 
    binary_string: bool, default None 
        if True, the image data are first rescaled and encoded as uint8 and 
        then passed to plotly.js as a b64 PNG string. If False, data are passed 
        unchanged as a numerical array. Setting to True may lead to performance 
        gains, at the cost of a loss of precision depending on the original data 
        type. If None, use_binary_string is set to True for multichannel (eg) RGB 
        arrays, and to False for single-channel (2D) arrays. 2D arrays are 
        represented as grayscale and with no colorbar if use_binary_string is 
        True. 
 
    binary_backend: str, 'auto' (default), 'pil' or 'pypng' 
        Third-party package for the transformation of numpy arrays to 
        png b64 strings. If 'auto', Pillow is used if installed,  otherwise 
        pypng. 
 
    binary_compression_level: int, between 0 and 9 (default 4) 
        png compression level to be passed to the backend when transforming an 
        array to a png b64 string. Increasing `binary_compression` decreases the 
        size of the png string, but the compression step takes more time. For most 
        images it is not worth using levels greater than 5, but it's possible to 
        test `len(fig.data[0].source)` and to time the execution of `imshow` to 
        tune the level of compression. 0 means no compression (not recommended). 
 
    binary_format: str, 'png' (default) or 'jpg' 
        compression format used to generate b64 string. 'png' is recommended 
        since it uses lossless compression, but 'jpg' (lossy) compression can 
        result if smaller binary strings for natural images. 
 
    text_auto: bool or str (default `False`) 
        If `True` or a string, single-channel `img` values will be displayed as text. 
        A string like `'.2f'` will be interpreted as a `texttemplate` numeric formatting directive. 
 
    Returns 
    ------- 
    fig : graph_objects.Figure containing the displayed image 
 
    See also 
    -------- 
 
    plotly.graph_objects.Image : image trace 
    plotly.graph_objects.Heatmap : heatmap trace 
 
    Notes 
    ----- 
 
    In order to update and customize the returned figure, use 
    `go.Figure.update_traces` or `go.Figure.update_layout`. 
 
    If an xarray is passed, dimensions names and coordinates are used for 
    axes labels and ticks. 
    &quot;&quot;&quot;</span>
    <span class="s1">args = locals()</span>
    <span class="s1">apply_default_cascade(args)</span>
    <span class="s1">labels = labels.copy()</span>
    <span class="s1">nslices_facet = </span><span class="s3">1</span>
    <span class="s0">if </span><span class="s1">facet_col </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">isinstance(facet_col</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">facet_col = img.dims.index(facet_col)</span>
        <span class="s1">nslices_facet = img.shape[facet_col]</span>
        <span class="s1">facet_slices = range(nslices_facet)</span>
        <span class="s1">ncols = int(facet_col_wrap) </span><span class="s0">if </span><span class="s1">facet_col_wrap </span><span class="s0">is not None else </span><span class="s1">nslices_facet</span>
        <span class="s1">nrows = (</span>
            <span class="s1">nslices_facet // ncols + </span><span class="s3">1</span>
            <span class="s0">if </span><span class="s1">nslices_facet % ncols</span>
            <span class="s0">else </span><span class="s1">nslices_facet // ncols</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">nrows = </span><span class="s3">1</span>
        <span class="s1">ncols = </span><span class="s3">1</span>
    <span class="s0">if </span><span class="s1">animation_frame </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">isinstance(animation_frame</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">animation_frame = img.dims.index(animation_frame)</span>
        <span class="s1">nslices_animation = img.shape[animation_frame]</span>
        <span class="s1">animation_slices = range(nslices_animation)</span>
    <span class="s1">slice_dimensions = (facet_col </span><span class="s0">is not None</span><span class="s1">) + (</span>
        <span class="s1">animation_frame </span><span class="s0">is not None</span>
    <span class="s1">)  </span><span class="s5"># 0, 1, or 2</span>
    <span class="s1">facet_label = </span><span class="s0">None</span>
    <span class="s1">animation_label = </span><span class="s0">None</span>
    <span class="s1">img_is_xarray = </span><span class="s0">False</span>
    <span class="s5"># ----- Define x and y, set labels if img is an xarray -------------------</span>
    <span class="s0">if </span><span class="s1">xarray_imported </span><span class="s0">and </span><span class="s1">isinstance(img</span><span class="s0">, </span><span class="s1">xarray.DataArray):</span>
        <span class="s1">dims = list(img.dims)</span>
        <span class="s1">img_is_xarray = </span><span class="s0">True</span>
        <span class="s0">if </span><span class="s1">facet_col </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">facet_slices = img.coords[img.dims[facet_col]].values</span>
            <span class="s1">_ = dims.pop(facet_col)</span>
            <span class="s1">facet_label = img.dims[facet_col]</span>
        <span class="s0">if </span><span class="s1">animation_frame </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">animation_slices = img.coords[img.dims[animation_frame]].values</span>
            <span class="s1">_ = dims.pop(animation_frame)</span>
            <span class="s1">animation_label = img.dims[animation_frame]</span>
        <span class="s1">y_label</span><span class="s0">, </span><span class="s1">x_label = dims[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dims[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s5"># np.datetime64 is not handled correctly by go.Heatmap</span>
        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">[x_label</span><span class="s0">, </span><span class="s1">y_label]:</span>
            <span class="s0">if </span><span class="s1">np.issubdtype(img.coords[ax].dtype</span><span class="s0">, </span><span class="s1">np.datetime64):</span>
                <span class="s1">img.coords[ax] = img.coords[ax].astype(str)</span>
        <span class="s0">if </span><span class="s1">x </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">x = img.coords[x_label].values</span>
        <span class="s0">if </span><span class="s1">y </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">y = img.coords[y_label].values</span>
        <span class="s0">if </span><span class="s1">aspect </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">aspect = </span><span class="s2">&quot;auto&quot;</span>
        <span class="s0">if </span><span class="s1">labels.get(</span><span class="s2">&quot;x&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">labels[</span><span class="s2">&quot;x&quot;</span><span class="s1">] = x_label</span>
        <span class="s0">if </span><span class="s1">labels.get(</span><span class="s2">&quot;y&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">labels[</span><span class="s2">&quot;y&quot;</span><span class="s1">] = y_label</span>
        <span class="s0">if </span><span class="s1">labels.get(</span><span class="s2">&quot;animation_frame&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">labels[</span><span class="s2">&quot;animation_frame&quot;</span><span class="s1">] = animation_label</span>
        <span class="s0">if </span><span class="s1">labels.get(</span><span class="s2">&quot;facet_col&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">labels[</span><span class="s2">&quot;facet_col&quot;</span><span class="s1">] = facet_label</span>
        <span class="s0">if </span><span class="s1">labels.get(</span><span class="s2">&quot;color&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">labels[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = xarray.plot.utils.label_from_attrs(img)</span>
            <span class="s1">labels[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = labels[</span><span class="s2">&quot;color&quot;</span><span class="s1">].replace(</span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">&quot;&lt;br&gt;&quot;</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">hasattr(img</span><span class="s0">, </span><span class="s2">&quot;columns&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">hasattr(img.columns</span><span class="s0">, </span><span class="s2">&quot;__len__&quot;</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">x </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">x = img.columns</span>
            <span class="s0">if </span><span class="s1">labels.get(</span><span class="s2">&quot;x&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is None and </span><span class="s1">hasattr(img.columns</span><span class="s0">, </span><span class="s2">&quot;name&quot;</span><span class="s1">):</span>
                <span class="s1">labels[</span><span class="s2">&quot;x&quot;</span><span class="s1">] = img.columns.name </span><span class="s0">or </span><span class="s2">&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">hasattr(img</span><span class="s0">, </span><span class="s2">&quot;index&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">hasattr(img.index</span><span class="s0">, </span><span class="s2">&quot;__len__&quot;</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">y </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">y = img.index</span>
            <span class="s0">if </span><span class="s1">labels.get(</span><span class="s2">&quot;y&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is None and </span><span class="s1">hasattr(img.index</span><span class="s0">, </span><span class="s2">&quot;name&quot;</span><span class="s1">):</span>
                <span class="s1">labels[</span><span class="s2">&quot;y&quot;</span><span class="s1">] = img.index.name </span><span class="s0">or </span><span class="s2">&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">labels.get(</span><span class="s2">&quot;x&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">labels[</span><span class="s2">&quot;x&quot;</span><span class="s1">] = </span><span class="s2">&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">labels.get(</span><span class="s2">&quot;y&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">labels[</span><span class="s2">&quot;y&quot;</span><span class="s1">] = </span><span class="s2">&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">labels.get(</span><span class="s2">&quot;color&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">labels[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = </span><span class="s2">&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">aspect </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">aspect = </span><span class="s2">&quot;equal&quot;</span>

    <span class="s5"># --- Set the value of binary_string (forbidden for pandas)</span>
    <span class="s0">if </span><span class="s1">isinstance(img</span><span class="s0">, </span><span class="s1">pd.DataFrame):</span>
        <span class="s0">if </span><span class="s1">binary_string:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Binary strings cannot be used with pandas arrays&quot;</span><span class="s1">)</span>
        <span class="s1">is_dataframe = </span><span class="s0">True</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">is_dataframe = </span><span class="s0">False</span>

    <span class="s5"># --------------- Starting from here img is always a numpy array --------</span>
    <span class="s1">img = np.asanyarray(img)</span>
    <span class="s5"># Reshape array so that animation dimension comes first, then facets, then images</span>
    <span class="s0">if </span><span class="s1">facet_col </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">img = np.moveaxis(img</span><span class="s0">, </span><span class="s1">facet_col</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">animation_frame </span><span class="s0">is not None and </span><span class="s1">animation_frame &lt; facet_col:</span>
            <span class="s1">animation_frame += </span><span class="s3">1</span>
        <span class="s1">facet_col = </span><span class="s0">True</span>
    <span class="s0">if </span><span class="s1">animation_frame </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">img = np.moveaxis(img</span><span class="s0">, </span><span class="s1">animation_frame</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">animation_frame = </span><span class="s0">True</span>
        <span class="s1">args[</span><span class="s2">&quot;animation_frame&quot;</span><span class="s1">] = (</span>
            <span class="s2">&quot;animation_frame&quot;</span>
            <span class="s0">if </span><span class="s1">labels.get(</span><span class="s2">&quot;animation_frame&quot;</span><span class="s1">) </span><span class="s0">is None</span>
            <span class="s0">else </span><span class="s1">labels[</span><span class="s2">&quot;animation_frame&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
    <span class="s1">iterables = ()</span>
    <span class="s0">if </span><span class="s1">animation_frame </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">iterables += (range(nslices_animation)</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">facet_col </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">iterables += (range(nslices_facet)</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s5"># Default behaviour of binary_string: True for RGB images, False for 2D</span>
    <span class="s0">if </span><span class="s1">binary_string </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">binary_string = img.ndim &gt;= (</span><span class="s3">3 </span><span class="s1">+ slice_dimensions) </span><span class="s0">and not </span><span class="s1">is_dataframe</span>

    <span class="s5"># Cast bools to uint8 (also one byte)</span>
    <span class="s0">if </span><span class="s1">img.dtype == np.bool:</span>
        <span class="s1">img = </span><span class="s3">255 </span><span class="s1">* img.astype(np.uint8)</span>

    <span class="s0">if </span><span class="s1">range_color </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">zmin = range_color[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">zmax = range_color[</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s5"># -------- Contrast rescaling: either minmax or infer ------------------</span>
    <span class="s0">if </span><span class="s1">contrast_rescaling </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">contrast_rescaling = </span><span class="s2">&quot;minmax&quot; </span><span class="s0">if </span><span class="s1">img.ndim == (</span><span class="s3">2 </span><span class="s1">+ slice_dimensions) </span><span class="s0">else </span><span class="s2">&quot;infer&quot;</span>

    <span class="s5"># We try to set zmin and zmax only if necessary, because traces have good defaults</span>
    <span class="s0">if </span><span class="s1">contrast_rescaling == </span><span class="s2">&quot;minmax&quot;</span><span class="s1">:</span>
        <span class="s5"># When using binary_string and minmax we need to set zmin and zmax to rescale the image</span>
        <span class="s0">if </span><span class="s1">(zmin </span><span class="s0">is not None or </span><span class="s1">binary_string) </span><span class="s0">and </span><span class="s1">zmax </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">zmax = img.max()</span>
        <span class="s0">if </span><span class="s1">(zmax </span><span class="s0">is not None or </span><span class="s1">binary_string) </span><span class="s0">and </span><span class="s1">zmin </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">zmin = img.min()</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s5"># For uint8 data and infer we let zmin and zmax to be None if passed as None</span>
        <span class="s0">if </span><span class="s1">zmax </span><span class="s0">is None and </span><span class="s1">img.dtype != np.uint8:</span>
            <span class="s1">zmax = _infer_zmax_from_type(img)</span>
        <span class="s0">if </span><span class="s1">zmin </span><span class="s0">is None and </span><span class="s1">zmax </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">zmin = </span><span class="s3">0</span>

    <span class="s5"># For 2d data, use Heatmap trace, unless binary_string is True</span>
    <span class="s0">if </span><span class="s1">img.ndim == </span><span class="s3">2 </span><span class="s1">+ slice_dimensions </span><span class="s0">and not </span><span class="s1">binary_string:</span>
        <span class="s1">y_index = slice_dimensions</span>
        <span class="s0">if </span><span class="s1">y </span><span class="s0">is not None and </span><span class="s1">img.shape[y_index] != len(y):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;The length of the y vector must match the length of the first &quot;</span>
                <span class="s1">+ </span><span class="s2">&quot;dimension of the img matrix.&quot;</span>
            <span class="s1">)</span>
        <span class="s1">x_index = slice_dimensions + </span><span class="s3">1</span>
        <span class="s0">if </span><span class="s1">x </span><span class="s0">is not None and </span><span class="s1">img.shape[x_index] != len(x):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;The length of the x vector must match the length of the second &quot;</span>
                <span class="s1">+ </span><span class="s2">&quot;dimension of the img matrix.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">texttemplate = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">text_auto </span><span class="s0">is True</span><span class="s1">:</span>
            <span class="s1">texttemplate = </span><span class="s2">&quot;%{z}&quot;</span>
        <span class="s0">elif </span><span class="s1">text_auto </span><span class="s0">is not False</span><span class="s1">:</span>
            <span class="s1">texttemplate = </span><span class="s2">&quot;%{z:&quot; </span><span class="s1">+ text_auto + </span><span class="s2">&quot;}&quot;</span>

        <span class="s1">traces = [</span>
            <span class="s1">go.Heatmap(</span>
                <span class="s1">x=x</span><span class="s0">,</span>
                <span class="s1">y=y</span><span class="s0">,</span>
                <span class="s1">z=img[index_tup]</span><span class="s0">,</span>
                <span class="s1">coloraxis=</span><span class="s2">&quot;coloraxis1&quot;</span><span class="s0">,</span>
                <span class="s1">name=str(i)</span><span class="s0">,</span>
                <span class="s1">texttemplate=texttemplate</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">index_tup </span><span class="s0">in </span><span class="s1">enumerate(itertools.product(*iterables))</span>
        <span class="s1">]</span>
        <span class="s1">autorange = </span><span class="s0">True if </span><span class="s1">origin == </span><span class="s2">&quot;lower&quot; </span><span class="s0">else </span><span class="s2">&quot;reversed&quot;</span>
        <span class="s1">layout = dict(yaxis=dict(autorange=autorange))</span>
        <span class="s0">if </span><span class="s1">aspect == </span><span class="s2">&quot;equal&quot;</span><span class="s1">:</span>
            <span class="s1">layout[</span><span class="s2">&quot;xaxis&quot;</span><span class="s1">] = dict(scaleanchor=</span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s1">constrain=</span><span class="s2">&quot;domain&quot;</span><span class="s1">)</span>
            <span class="s1">layout[</span><span class="s2">&quot;yaxis&quot;</span><span class="s1">][</span><span class="s2">&quot;constrain&quot;</span><span class="s1">] = </span><span class="s2">&quot;domain&quot;</span>
        <span class="s1">colorscale_validator = ColorscaleValidator(</span><span class="s2">&quot;colorscale&quot;</span><span class="s0">, </span><span class="s2">&quot;imshow&quot;</span><span class="s1">)</span>
        <span class="s1">layout[</span><span class="s2">&quot;coloraxis1&quot;</span><span class="s1">] = dict(</span>
            <span class="s1">colorscale=colorscale_validator.validate_coerce(</span>
                <span class="s1">args[</span><span class="s2">&quot;color_continuous_scale&quot;</span><span class="s1">]</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">cmid=color_continuous_midpoint</span><span class="s0">,</span>
            <span class="s1">cmin=zmin</span><span class="s0">,</span>
            <span class="s1">cmax=zmax</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">labels[</span><span class="s2">&quot;color&quot;</span><span class="s1">]:</span>
            <span class="s1">layout[</span><span class="s2">&quot;coloraxis1&quot;</span><span class="s1">][</span><span class="s2">&quot;colorbar&quot;</span><span class="s1">] = dict(title_text=labels[</span><span class="s2">&quot;color&quot;</span><span class="s1">])</span>

    <span class="s5"># For 2D+RGB data, use Image trace</span>
    <span class="s0">elif </span><span class="s1">(</span>
        <span class="s1">img.ndim &gt;= </span><span class="s3">3</span>
        <span class="s0">and </span><span class="s1">(img.shape[-</span><span class="s3">1</span><span class="s1">] </span><span class="s0">in </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">] </span><span class="s0">or </span><span class="s1">slice_dimensions </span><span class="s0">and </span><span class="s1">binary_string)</span>
    <span class="s1">) </span><span class="s0">or </span><span class="s1">(img.ndim == </span><span class="s3">2 </span><span class="s0">and </span><span class="s1">binary_string):</span>
        <span class="s1">rescale_image = </span><span class="s0">True  </span><span class="s5"># to check whether image has been modified</span>
        <span class="s0">if </span><span class="s1">zmin </span><span class="s0">is not None and </span><span class="s1">zmax </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">zmin</span><span class="s0">, </span><span class="s1">zmax = (</span>
                <span class="s1">_vectorize_zvalue(zmin</span><span class="s0">, </span><span class="s1">mode=</span><span class="s2">&quot;min&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">_vectorize_zvalue(zmax</span><span class="s0">, </span><span class="s1">mode=</span><span class="s2">&quot;max&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">x0</span><span class="s0">, </span><span class="s1">y0</span><span class="s0">, </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">dy = (</span><span class="s0">None,</span><span class="s1">) * </span><span class="s3">4</span>
        <span class="s1">error_msg_xarray = (</span>
            <span class="s2">&quot;Non-numerical coordinates were passed with xarray `img`, but &quot;</span>
            <span class="s2">&quot;the Image trace cannot handle it. Please use `binary_string=False` &quot;</span>
            <span class="s2">&quot;for 2D data or pass instead the numpy array `img.values` to `px.imshow`.&quot;</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">x </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">x = np.asanyarray(x)</span>
            <span class="s0">if </span><span class="s1">np.issubdtype(x.dtype</span><span class="s0">, </span><span class="s1">np.number):</span>
                <span class="s1">x0 = x[</span><span class="s3">0</span><span class="s1">]</span>
                <span class="s1">dx = x[</span><span class="s3">1</span><span class="s1">] - x[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">error_msg = (</span>
                    <span class="s1">error_msg_xarray</span>
                    <span class="s0">if </span><span class="s1">img_is_xarray</span>
                    <span class="s0">else </span><span class="s1">(</span>
                        <span class="s2">&quot;Only numerical values are accepted for the `x` parameter &quot;</span>
                        <span class="s2">&quot;when an Image trace is used.&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s0">raise </span><span class="s1">ValueError(error_msg)</span>
        <span class="s0">if </span><span class="s1">y </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">y = np.asanyarray(y)</span>
            <span class="s0">if </span><span class="s1">np.issubdtype(y.dtype</span><span class="s0">, </span><span class="s1">np.number):</span>
                <span class="s1">y0 = y[</span><span class="s3">0</span><span class="s1">]</span>
                <span class="s1">dy = y[</span><span class="s3">1</span><span class="s1">] - y[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">error_msg = (</span>
                    <span class="s1">error_msg_xarray</span>
                    <span class="s0">if </span><span class="s1">img_is_xarray</span>
                    <span class="s0">else </span><span class="s1">(</span>
                        <span class="s2">&quot;Only numerical values are accepted for the `y` parameter &quot;</span>
                        <span class="s2">&quot;when an Image trace is used.&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s0">raise </span><span class="s1">ValueError(error_msg)</span>
        <span class="s0">if </span><span class="s1">binary_string:</span>
            <span class="s0">if </span><span class="s1">zmin </span><span class="s0">is None and </span><span class="s1">zmax </span><span class="s0">is None</span><span class="s1">:  </span><span class="s5"># no rescaling, faster</span>
                <span class="s1">img_rescaled = img</span>
                <span class="s1">rescale_image = </span><span class="s0">False</span>
            <span class="s0">elif </span><span class="s1">img.ndim == </span><span class="s3">2 </span><span class="s1">+ slice_dimensions:  </span><span class="s5"># single-channel image</span>
                <span class="s1">img_rescaled = rescale_intensity(</span>
                    <span class="s1">img</span><span class="s0">, </span><span class="s1">in_range=(zmin[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">zmax[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">out_range=np.uint8</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">img_rescaled = np.stack(</span>
                    <span class="s1">[</span>
                        <span class="s1">rescale_intensity(</span>
                            <span class="s1">img[...</span><span class="s0">, </span><span class="s1">ch]</span><span class="s0">,</span>
                            <span class="s1">in_range=(zmin[ch]</span><span class="s0">, </span><span class="s1">zmax[ch])</span><span class="s0">,</span>
                            <span class="s1">out_range=np.uint8</span><span class="s0">,</span>
                        <span class="s1">)</span>
                        <span class="s0">for </span><span class="s1">ch </span><span class="s0">in </span><span class="s1">range(img.shape[-</span><span class="s3">1</span><span class="s1">])</span>
                    <span class="s1">]</span><span class="s0">,</span>
                    <span class="s1">axis=-</span><span class="s3">1</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s1">img_str = [</span>
                <span class="s1">image_array_to_data_uri(</span>
                    <span class="s1">img_rescaled[index_tup]</span><span class="s0">,</span>
                    <span class="s1">backend=binary_backend</span><span class="s0">,</span>
                    <span class="s1">compression=binary_compression_level</span><span class="s0">,</span>
                    <span class="s1">ext=binary_format</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s0">for </span><span class="s1">index_tup </span><span class="s0">in </span><span class="s1">itertools.product(*iterables)</span>
            <span class="s1">]</span>

            <span class="s1">traces = [</span>
                <span class="s1">go.Image(source=img_str_slice</span><span class="s0">, </span><span class="s1">name=str(i)</span><span class="s0">, </span><span class="s1">x0=x0</span><span class="s0">, </span><span class="s1">y0=y0</span><span class="s0">, </span><span class="s1">dx=dx</span><span class="s0">, </span><span class="s1">dy=dy)</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">img_str_slice </span><span class="s0">in </span><span class="s1">enumerate(img_str)</span>
            <span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">colormodel = </span><span class="s2">&quot;rgb&quot; </span><span class="s0">if </span><span class="s1">img.shape[-</span><span class="s3">1</span><span class="s1">] == </span><span class="s3">3 </span><span class="s0">else </span><span class="s2">&quot;rgba256&quot;</span>
            <span class="s1">traces = [</span>
                <span class="s1">go.Image(</span>
                    <span class="s1">z=img[index_tup]</span><span class="s0">,</span>
                    <span class="s1">zmin=zmin</span><span class="s0">,</span>
                    <span class="s1">zmax=zmax</span><span class="s0">,</span>
                    <span class="s1">colormodel=colormodel</span><span class="s0">,</span>
                    <span class="s1">x0=x0</span><span class="s0">,</span>
                    <span class="s1">y0=y0</span><span class="s0">,</span>
                    <span class="s1">dx=dx</span><span class="s0">,</span>
                    <span class="s1">dy=dy</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s0">for </span><span class="s1">index_tup </span><span class="s0">in </span><span class="s1">itertools.product(*iterables)</span>
            <span class="s1">]</span>
        <span class="s1">layout = {}</span>
        <span class="s0">if </span><span class="s1">origin == </span><span class="s2">&quot;lower&quot; </span><span class="s0">or </span><span class="s1">(dy </span><span class="s0">is not None and </span><span class="s1">dy &lt; </span><span class="s3">0</span><span class="s1">):</span>
            <span class="s1">layout[</span><span class="s2">&quot;yaxis&quot;</span><span class="s1">] = dict(autorange=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">dx </span><span class="s0">is not None and </span><span class="s1">dx &lt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">layout[</span><span class="s2">&quot;xaxis&quot;</span><span class="s1">] = dict(autorange=</span><span class="s2">&quot;reversed&quot;</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s2">&quot;px.imshow only accepts 2D single-channel, RGB or RGBA images. &quot;</span>
            <span class="s2">&quot;An image of shape %s was provided. &quot;</span>
            <span class="s2">&quot;Alternatively, 3- or 4-D single or multichannel datasets can be &quot;</span>
            <span class="s2">&quot;visualized using the `facet_col` or/and `animation_frame` arguments.&quot;</span>
            <span class="s1">% str(img.shape)</span>
        <span class="s1">)</span>

    <span class="s5"># Now build figure</span>
    <span class="s1">col_labels = []</span>
    <span class="s0">if </span><span class="s1">facet_col </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">slice_label = (</span>
            <span class="s2">&quot;facet_col&quot; </span><span class="s0">if </span><span class="s1">labels.get(</span><span class="s2">&quot;facet_col&quot;</span><span class="s1">) </span><span class="s0">is None else </span><span class="s1">labels[</span><span class="s2">&quot;facet_col&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">col_labels = [</span><span class="s2">&quot;%s=%d&quot; </span><span class="s1">% (slice_label</span><span class="s0">, </span><span class="s1">i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">facet_slices]</span>
    <span class="s1">fig = init_figure(args</span><span class="s0">, </span><span class="s2">&quot;xy&quot;</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">nrows</span><span class="s0">, </span><span class="s1">ncols</span><span class="s0">, </span><span class="s1">col_labels</span><span class="s0">, </span><span class="s1">[])</span>
    <span class="s0">for </span><span class="s1">attr_name </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;height&quot;</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s1">]:</span>
        <span class="s0">if </span><span class="s1">args[attr_name]:</span>
            <span class="s1">layout[attr_name] = args[attr_name]</span>
    <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;title&quot;</span><span class="s1">]:</span>
        <span class="s1">layout[</span><span class="s2">&quot;title_text&quot;</span><span class="s1">] = args[</span><span class="s2">&quot;title&quot;</span><span class="s1">]</span>
    <span class="s0">elif </span><span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">].layout.margin.t </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">layout[</span><span class="s2">&quot;margin&quot;</span><span class="s1">] = {</span><span class="s2">&quot;t&quot;</span><span class="s1">: </span><span class="s3">60</span><span class="s1">}</span>

    <span class="s1">frame_list = []</span>
    <span class="s0">for </span><span class="s1">index</span><span class="s0">, </span><span class="s1">trace </span><span class="s0">in </span><span class="s1">enumerate(traces):</span>
        <span class="s0">if </span><span class="s1">(facet_col </span><span class="s0">and </span><span class="s1">index &lt; nrows * ncols) </span><span class="s0">or </span><span class="s1">index == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">fig.add_trace(trace</span><span class="s0">, </span><span class="s1">row=nrows - index // ncols</span><span class="s0">, </span><span class="s1">col=index % ncols + </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">animation_frame </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">index </span><span class="s0">in </span><span class="s1">zip(range(nslices_animation)</span><span class="s0">, </span><span class="s1">animation_slices):</span>
            <span class="s1">frame_list.append(</span>
                <span class="s1">dict(</span>
                    <span class="s1">data=traces[nslices_facet * i : nslices_facet * (i + </span><span class="s3">1</span><span class="s1">)]</span><span class="s0">,</span>
                    <span class="s1">layout=layout</span><span class="s0">,</span>
                    <span class="s1">name=str(index)</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">animation_frame:</span>
        <span class="s1">fig.frames = frame_list</span>
    <span class="s1">fig.update_layout(layout)</span>
    <span class="s5"># Hover name, z or color</span>
    <span class="s0">if </span><span class="s1">binary_string </span><span class="s0">and </span><span class="s1">rescale_image </span><span class="s0">and not </span><span class="s1">np.all(img == img_rescaled):</span>
        <span class="s5"># we rescaled the image, hence z is not displayed in hover since it does</span>
        <span class="s5"># not correspond to img values</span>
        <span class="s1">hovertemplate = </span><span class="s2">&quot;%s: %%{x}&lt;br&gt;%s: %%{y}&lt;extra&gt;&lt;/extra&gt;&quot; </span><span class="s1">% (</span>
            <span class="s1">labels[</span><span class="s2">&quot;x&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s2">&quot;x&quot;</span><span class="s0">,</span>
            <span class="s1">labels[</span><span class="s2">&quot;y&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s2">&quot;y&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">trace[</span><span class="s2">&quot;type&quot;</span><span class="s1">] == </span><span class="s2">&quot;heatmap&quot;</span><span class="s1">:</span>
            <span class="s1">hover_name = </span><span class="s2">&quot;%{z}&quot;</span>
        <span class="s0">elif </span><span class="s1">img.ndim == </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s1">hover_name = </span><span class="s2">&quot;%{z[0]}&quot;</span>
        <span class="s0">elif </span><span class="s1">img.ndim == </span><span class="s3">3 </span><span class="s0">and </span><span class="s1">img.shape[-</span><span class="s3">1</span><span class="s1">] == </span><span class="s3">3</span><span class="s1">:</span>
            <span class="s1">hover_name = </span><span class="s2">&quot;[%{z[0]}, %{z[1]}, %{z[2]}]&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">hover_name = </span><span class="s2">&quot;%{z}&quot;</span>
        <span class="s1">hovertemplate = </span><span class="s2">&quot;%s: %%{x}&lt;br&gt;%s: %%{y}&lt;br&gt;%s: %s&lt;extra&gt;&lt;/extra&gt;&quot; </span><span class="s1">% (</span>
            <span class="s1">labels[</span><span class="s2">&quot;x&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s2">&quot;x&quot;</span><span class="s0">,</span>
            <span class="s1">labels[</span><span class="s2">&quot;y&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s2">&quot;y&quot;</span><span class="s0">,</span>
            <span class="s1">labels[</span><span class="s2">&quot;color&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s2">&quot;color&quot;</span><span class="s0">,</span>
            <span class="s1">hover_name</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s1">fig.update_traces(hovertemplate=hovertemplate)</span>
    <span class="s0">if </span><span class="s1">labels[</span><span class="s2">&quot;x&quot;</span><span class="s1">]:</span>
        <span class="s1">fig.update_xaxes(title_text=labels[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">row=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">labels[</span><span class="s2">&quot;y&quot;</span><span class="s1">]:</span>
        <span class="s1">fig.update_yaxes(title_text=labels[</span><span class="s2">&quot;y&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">col=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">configure_animation_controls(args</span><span class="s0">, </span><span class="s1">go.Image</span><span class="s0">, </span><span class="s1">fig)</span>
    <span class="s1">fig.update_layout(template=args[</span><span class="s2">&quot;template&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">overwrite=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">fig</span>
</pre>
</body>
</html>