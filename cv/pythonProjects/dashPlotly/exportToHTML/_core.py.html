<html>
<head>
<title>_core.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_core.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">plotly.graph_objs </span><span class="s0">as </span><span class="s1">go</span>
<span class="s0">import </span><span class="s1">plotly.io </span><span class="s0">as </span><span class="s1">pio</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">namedtuple</span><span class="s0">, </span><span class="s1">OrderedDict</span>
<span class="s0">from </span><span class="s1">._special_inputs </span><span class="s0">import </span><span class="s1">IdentityMap</span><span class="s0">, </span><span class="s1">Constant</span><span class="s0">, </span><span class="s1">Range</span>
<span class="s0">from </span><span class="s1">.trendline_functions </span><span class="s0">import </span><span class="s1">ols</span><span class="s0">, </span><span class="s1">lowess</span><span class="s0">, </span><span class="s1">rolling</span><span class="s0">, </span><span class="s1">expanding</span><span class="s0">, </span><span class="s1">ewm</span>

<span class="s0">from </span><span class="s1">_plotly_utils.basevalidators </span><span class="s0">import </span><span class="s1">ColorscaleValidator</span>
<span class="s0">from </span><span class="s1">plotly.colors </span><span class="s0">import </span><span class="s1">qualitative</span><span class="s0">, </span><span class="s1">sequential</span>
<span class="s0">import </span><span class="s1">math</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">plotly.subplots </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">make_subplots</span><span class="s0">,</span>
    <span class="s1">_set_trace_grid_reference</span><span class="s0">,</span>
    <span class="s1">_subplot_type_for_trace_type</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s1">NO_COLOR = </span><span class="s2">&quot;px_no_color_constant&quot;</span>
<span class="s1">trendline_functions = dict(</span>
    <span class="s1">lowess=lowess</span><span class="s0">, </span><span class="s1">rolling=rolling</span><span class="s0">, </span><span class="s1">ewm=ewm</span><span class="s0">, </span><span class="s1">expanding=expanding</span><span class="s0">, </span><span class="s1">ols=ols</span>
<span class="s1">)</span>

<span class="s3"># Declare all supported attributes, across all plot types</span>
<span class="s1">direct_attrables = (</span>
    <span class="s1">[</span><span class="s2">&quot;base&quot;</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;z&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;r&quot;</span><span class="s0">, </span><span class="s2">&quot;theta&quot;</span><span class="s0">, </span><span class="s2">&quot;size&quot;</span><span class="s0">, </span><span class="s2">&quot;x_start&quot;</span><span class="s0">, </span><span class="s2">&quot;x_end&quot;</span><span class="s1">]</span>
    <span class="s1">+ [</span><span class="s2">&quot;hover_name&quot;</span><span class="s0">, </span><span class="s2">&quot;text&quot;</span><span class="s0">, </span><span class="s2">&quot;names&quot;</span><span class="s0">, </span><span class="s2">&quot;values&quot;</span><span class="s0">, </span><span class="s2">&quot;parents&quot;</span><span class="s0">, </span><span class="s2">&quot;wide_cross&quot;</span><span class="s1">]</span>
    <span class="s1">+ [</span><span class="s2">&quot;ids&quot;</span><span class="s0">, </span><span class="s2">&quot;error_x&quot;</span><span class="s0">, </span><span class="s2">&quot;error_x_minus&quot;</span><span class="s0">, </span><span class="s2">&quot;error_y&quot;</span><span class="s0">, </span><span class="s2">&quot;error_y_minus&quot;</span><span class="s0">, </span><span class="s2">&quot;error_z&quot;</span><span class="s1">]</span>
    <span class="s1">+ [</span><span class="s2">&quot;error_z_minus&quot;</span><span class="s0">, </span><span class="s2">&quot;lat&quot;</span><span class="s0">, </span><span class="s2">&quot;lon&quot;</span><span class="s0">, </span><span class="s2">&quot;locations&quot;</span><span class="s0">, </span><span class="s2">&quot;animation_group&quot;</span><span class="s1">]</span>
<span class="s1">)</span>
<span class="s1">array_attrables = [</span><span class="s2">&quot;dimensions&quot;</span><span class="s0">, </span><span class="s2">&quot;custom_data&quot;</span><span class="s0">, </span><span class="s2">&quot;hover_data&quot;</span><span class="s0">, </span><span class="s2">&quot;path&quot;</span><span class="s0">, </span><span class="s2">&quot;wide_variable&quot;</span><span class="s1">]</span>
<span class="s1">group_attrables = [</span><span class="s2">&quot;animation_frame&quot;</span><span class="s0">, </span><span class="s2">&quot;facet_row&quot;</span><span class="s0">, </span><span class="s2">&quot;facet_col&quot;</span><span class="s0">, </span><span class="s2">&quot;line_group&quot;</span><span class="s1">]</span>
<span class="s1">renameable_group_attrables = [</span>
    <span class="s2">&quot;color&quot;</span><span class="s0">,  </span><span class="s3"># renamed to marker.color or line.color in infer_config</span>
    <span class="s2">&quot;symbol&quot;</span><span class="s0">,  </span><span class="s3"># renamed to marker.symbol in infer_config</span>
    <span class="s2">&quot;line_dash&quot;</span><span class="s0">,  </span><span class="s3"># renamed to line.dash in infer_config</span>
    <span class="s2">&quot;pattern_shape&quot;</span><span class="s0">,  </span><span class="s3"># renamed to marker.pattern.shape in infer_config</span>
<span class="s1">]</span>
<span class="s1">all_attrables = (</span>
    <span class="s1">direct_attrables + array_attrables + group_attrables + renameable_group_attrables</span>
<span class="s1">)</span>

<span class="s1">cartesians = [go.Scatter</span><span class="s0">, </span><span class="s1">go.Scattergl</span><span class="s0">, </span><span class="s1">go.Bar</span><span class="s0">, </span><span class="s1">go.Funnel</span><span class="s0">, </span><span class="s1">go.Box</span><span class="s0">, </span><span class="s1">go.Violin]</span>
<span class="s1">cartesians += [go.Histogram</span><span class="s0">, </span><span class="s1">go.Histogram2d</span><span class="s0">, </span><span class="s1">go.Histogram2dContour]</span>


<span class="s0">class </span><span class="s1">PxDefaults(object):</span>
    <span class="s1">__slots__ = [</span>
        <span class="s2">&quot;template&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;width&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;height&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;color_discrete_sequence&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;color_discrete_map&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;color_continuous_scale&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;symbol_sequence&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;symbol_map&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;line_dash_sequence&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;line_dash_map&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;pattern_shape_sequence&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;pattern_shape_map&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;size_max&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;category_orders&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;labels&quot;</span><span class="s0">,</span>
    <span class="s1">]</span>

    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.reset()</span>

    <span class="s0">def </span><span class="s1">reset(self):</span>
        <span class="s1">self.template = </span><span class="s0">None</span>
        <span class="s1">self.width = </span><span class="s0">None</span>
        <span class="s1">self.height = </span><span class="s0">None</span>
        <span class="s1">self.color_discrete_sequence = </span><span class="s0">None</span>
        <span class="s1">self.color_discrete_map = {}</span>
        <span class="s1">self.color_continuous_scale = </span><span class="s0">None</span>
        <span class="s1">self.symbol_sequence = </span><span class="s0">None</span>
        <span class="s1">self.symbol_map = {}</span>
        <span class="s1">self.line_dash_sequence = </span><span class="s0">None</span>
        <span class="s1">self.line_dash_map = {}</span>
        <span class="s1">self.pattern_shape_sequence = </span><span class="s0">None</span>
        <span class="s1">self.pattern_shape_map = {}</span>
        <span class="s1">self.size_max = </span><span class="s4">20</span>
        <span class="s1">self.category_orders = {}</span>
        <span class="s1">self.labels = {}</span>


<span class="s1">defaults = PxDefaults()</span>
<span class="s0">del </span><span class="s1">PxDefaults</span>


<span class="s1">MAPBOX_TOKEN = </span><span class="s0">None</span>


<span class="s0">def </span><span class="s1">set_mapbox_access_token(token):</span>
    <span class="s5">&quot;&quot;&quot; 
    Arguments: 
        token: A Mapbox token to be used in `plotly.express.scatter_mapbox` and \ 
        `plotly.express.line_mapbox` figures. See \ 
        https://docs.mapbox.com/help/how-mapbox-works/access-tokens/ for more details 
    &quot;&quot;&quot;</span>
    <span class="s0">global </span><span class="s1">MAPBOX_TOKEN</span>
    <span class="s1">MAPBOX_TOKEN = token</span>


<span class="s0">def </span><span class="s1">get_trendline_results(fig):</span>
    <span class="s5">&quot;&quot;&quot; 
    Extracts fit statistics for trendlines (when applied to figures generated with 
    the `trendline` argument set to `&quot;ols&quot;`). 
 
    Arguments: 
        fig: the output of a `plotly.express` charting call 
    Returns: 
        A `pandas.DataFrame` with a column &quot;px_fit_results&quot; containing the `statsmodels` 
        results objects, along with columns identifying the subset of the data the 
        trendline was fit on. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">fig._px_trendlines</span>


<span class="s1">Mapping = namedtuple(</span>
    <span class="s2">&quot;Mapping&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s2">&quot;show_in_trace_name&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;grouper&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;val_map&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;sequence&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;updater&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;variable&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;facet&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">TraceSpec = namedtuple(</span><span class="s2">&quot;TraceSpec&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;constructor&quot;</span><span class="s0">, </span><span class="s2">&quot;attrs&quot;</span><span class="s0">, </span><span class="s2">&quot;trace_patch&quot;</span><span class="s0">, </span><span class="s2">&quot;marginal&quot;</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">get_label(args</span><span class="s0">, </span><span class="s1">column):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">args[</span><span class="s2">&quot;labels&quot;</span><span class="s1">][column]</span>
    <span class="s0">except </span><span class="s1">Exception:</span>
        <span class="s0">return </span><span class="s1">column</span>


<span class="s0">def </span><span class="s1">invert_label(args</span><span class="s0">, </span><span class="s1">column):</span>
    <span class="s5">&quot;&quot;&quot;Invert mapping. 
    Find key corresponding to value column in dict args[&quot;labels&quot;]. 
    Returns `column` if the value does not exist. 
    &quot;&quot;&quot;</span>
    <span class="s1">reversed_labels = {value: key </span><span class="s0">for </span><span class="s1">(key</span><span class="s0">, </span><span class="s1">value) </span><span class="s0">in </span><span class="s1">args[</span><span class="s2">&quot;labels&quot;</span><span class="s1">].items()}</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">reversed_labels[column]</span>
    <span class="s0">except </span><span class="s1">Exception:</span>
        <span class="s0">return </span><span class="s1">column</span>


<span class="s0">def </span><span class="s1">_is_continuous(df</span><span class="s0">, </span><span class="s1">col_name):</span>
    <span class="s0">return </span><span class="s1">df[col_name].dtype.kind </span><span class="s0">in </span><span class="s2">&quot;ifc&quot;</span>


<span class="s0">def </span><span class="s1">get_decorated_label(args</span><span class="s0">, </span><span class="s1">column</span><span class="s0">, </span><span class="s1">role):</span>
    <span class="s1">original_label = label = get_label(args</span><span class="s0">, </span><span class="s1">column)</span>
    <span class="s0">if </span><span class="s2">&quot;histfunc&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">(</span>
        <span class="s1">(role == </span><span class="s2">&quot;z&quot;</span><span class="s1">)</span>
        <span class="s0">or </span><span class="s1">(role == </span><span class="s2">&quot;x&quot; </span><span class="s0">and </span><span class="s2">&quot;orientation&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] == </span><span class="s2">&quot;h&quot;</span><span class="s1">)</span>
        <span class="s0">or </span><span class="s1">(role == </span><span class="s2">&quot;y&quot; </span><span class="s0">and </span><span class="s2">&quot;orientation&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] == </span><span class="s2">&quot;v&quot;</span><span class="s1">)</span>
    <span class="s1">):</span>
        <span class="s1">histfunc = args[</span><span class="s2">&quot;histfunc&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s2">&quot;count&quot;</span>
        <span class="s0">if </span><span class="s1">histfunc != </span><span class="s2">&quot;count&quot;</span><span class="s1">:</span>
            <span class="s1">label = </span><span class="s2">&quot;%s of %s&quot; </span><span class="s1">% (histfunc</span><span class="s0">, </span><span class="s1">label)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">label = </span><span class="s2">&quot;count&quot;</span>

        <span class="s0">if </span><span class="s2">&quot;histnorm&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;histnorm&quot;</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">label == </span><span class="s2">&quot;count&quot;</span><span class="s1">:</span>
                <span class="s1">label = args[</span><span class="s2">&quot;histnorm&quot;</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">histnorm = args[</span><span class="s2">&quot;histnorm&quot;</span><span class="s1">]</span>
                <span class="s0">if </span><span class="s1">histfunc == </span><span class="s2">&quot;sum&quot;</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">histnorm == </span><span class="s2">&quot;probability&quot;</span><span class="s1">:</span>
                        <span class="s1">label = </span><span class="s2">&quot;%s of %s&quot; </span><span class="s1">% (</span><span class="s2">&quot;fraction&quot;</span><span class="s0">, </span><span class="s1">label)</span>
                    <span class="s0">elif </span><span class="s1">histnorm == </span><span class="s2">&quot;percent&quot;</span><span class="s1">:</span>
                        <span class="s1">label = </span><span class="s2">&quot;%s of %s&quot; </span><span class="s1">% (histnorm</span><span class="s0">, </span><span class="s1">label)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">label = </span><span class="s2">&quot;%s weighted by %s&quot; </span><span class="s1">% (histnorm</span><span class="s0">, </span><span class="s1">original_label)</span>
                <span class="s0">elif </span><span class="s1">histnorm == </span><span class="s2">&quot;probability&quot;</span><span class="s1">:</span>
                    <span class="s1">label = </span><span class="s2">&quot;%s of sum of %s&quot; </span><span class="s1">% (</span><span class="s2">&quot;fraction&quot;</span><span class="s0">, </span><span class="s1">label)</span>
                <span class="s0">elif </span><span class="s1">histnorm == </span><span class="s2">&quot;percent&quot;</span><span class="s1">:</span>
                    <span class="s1">label = </span><span class="s2">&quot;%s of sum of %s&quot; </span><span class="s1">% (</span><span class="s2">&quot;percent&quot;</span><span class="s0">, </span><span class="s1">label)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">label = </span><span class="s2">&quot;%s of %s&quot; </span><span class="s1">% (histnorm</span><span class="s0">, </span><span class="s1">label)</span>

        <span class="s0">if </span><span class="s2">&quot;barnorm&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;barnorm&quot;</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">label = </span><span class="s2">&quot;%s (normalized as %s)&quot; </span><span class="s1">% (label</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;barnorm&quot;</span><span class="s1">])</span>

    <span class="s0">return </span><span class="s1">label</span>


<span class="s0">def </span><span class="s1">make_mapping(args</span><span class="s0">, </span><span class="s1">variable):</span>
    <span class="s0">if </span><span class="s1">variable == </span><span class="s2">&quot;line_group&quot; </span><span class="s0">or </span><span class="s1">variable == </span><span class="s2">&quot;animation_frame&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">Mapping(</span>
            <span class="s1">show_in_trace_name=</span><span class="s0">False,</span>
            <span class="s1">grouper=args[variable]</span><span class="s0">,</span>
            <span class="s1">val_map={}</span><span class="s0">,</span>
            <span class="s1">sequence=[</span><span class="s2">&quot;&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">variable=variable</span><span class="s0">,</span>
            <span class="s1">updater=(</span><span class="s0">lambda </span><span class="s1">trace</span><span class="s0">, </span><span class="s1">v: v)</span><span class="s0">,</span>
            <span class="s1">facet=</span><span class="s0">None,</span>
        <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">variable == </span><span class="s2">&quot;facet_row&quot; </span><span class="s0">or </span><span class="s1">variable == </span><span class="s2">&quot;facet_col&quot;</span><span class="s1">:</span>
        <span class="s1">letter = </span><span class="s2">&quot;x&quot; </span><span class="s0">if </span><span class="s1">variable == </span><span class="s2">&quot;facet_col&quot; </span><span class="s0">else </span><span class="s2">&quot;y&quot;</span>
        <span class="s0">return </span><span class="s1">Mapping(</span>
            <span class="s1">show_in_trace_name=</span><span class="s0">False,</span>
            <span class="s1">variable=letter</span><span class="s0">,</span>
            <span class="s1">grouper=args[variable]</span><span class="s0">,</span>
            <span class="s1">val_map={}</span><span class="s0">,</span>
            <span class="s1">sequence=[i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1000</span><span class="s1">)]</span><span class="s0">,</span>
            <span class="s1">updater=(</span><span class="s0">lambda </span><span class="s1">trace</span><span class="s0">, </span><span class="s1">v: v)</span><span class="s0">,</span>
            <span class="s1">facet=</span><span class="s2">&quot;row&quot; </span><span class="s0">if </span><span class="s1">variable == </span><span class="s2">&quot;facet_row&quot; </span><span class="s0">else </span><span class="s2">&quot;col&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s1">(parent</span><span class="s0">, </span><span class="s1">variable</span><span class="s0">, </span><span class="s1">*other_variables) = variable.split(</span><span class="s2">&quot;.&quot;</span><span class="s1">)</span>
    <span class="s1">vprefix = variable</span>
    <span class="s1">arg_name = variable</span>
    <span class="s0">if </span><span class="s1">variable == </span><span class="s2">&quot;color&quot;</span><span class="s1">:</span>
        <span class="s1">vprefix = </span><span class="s2">&quot;color_discrete&quot;</span>
    <span class="s0">if </span><span class="s1">variable == </span><span class="s2">&quot;dash&quot;</span><span class="s1">:</span>
        <span class="s1">arg_name = </span><span class="s2">&quot;line_dash&quot;</span>
        <span class="s1">vprefix = </span><span class="s2">&quot;line_dash&quot;</span>
    <span class="s0">if </span><span class="s1">variable == </span><span class="s2">&quot;pattern&quot;</span><span class="s1">:</span>
        <span class="s1">arg_name = </span><span class="s2">&quot;pattern_shape&quot;</span>
        <span class="s1">vprefix = </span><span class="s2">&quot;pattern_shape&quot;</span>
    <span class="s0">if </span><span class="s1">args[vprefix + </span><span class="s2">&quot;_map&quot;</span><span class="s1">] == </span><span class="s2">&quot;identity&quot;</span><span class="s1">:</span>
        <span class="s1">val_map = IdentityMap()</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">val_map = args[vprefix + </span><span class="s2">&quot;_map&quot;</span><span class="s1">].copy()</span>
    <span class="s0">return </span><span class="s1">Mapping(</span>
        <span class="s1">show_in_trace_name=</span><span class="s0">True,</span>
        <span class="s1">variable=variable</span><span class="s0">,</span>
        <span class="s1">grouper=args[arg_name]</span><span class="s0">,</span>
        <span class="s1">val_map=val_map</span><span class="s0">,</span>
        <span class="s1">sequence=args[vprefix + </span><span class="s2">&quot;_sequence&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">updater=</span><span class="s0">lambda </span><span class="s1">trace</span><span class="s0">, </span><span class="s1">v: trace.update(</span>
            <span class="s1">{parent: {</span><span class="s2">&quot;.&quot;</span><span class="s1">.join([variable] + other_variables): v}}</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">facet=</span><span class="s0">None,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">make_trace_kwargs(args</span><span class="s0">, </span><span class="s1">trace_spec</span><span class="s0">, </span><span class="s1">trace_data</span><span class="s0">, </span><span class="s1">mapping_labels</span><span class="s0">, </span><span class="s1">sizeref):</span>
    <span class="s5">&quot;&quot;&quot;Populates a dict with arguments to update trace 
 
    Parameters 
    ---------- 
    args : dict 
        args to be used for the trace 
    trace_spec : NamedTuple 
        which kind of trace to be used (has constructor, marginal etc. 
        attributes) 
    trace_data : pandas DataFrame 
        data 
    mapping_labels : dict 
        to be used for hovertemplate 
    sizeref : float 
        marker sizeref 
 
    Returns 
    ------- 
    trace_patch : dict 
        dict to be used to update trace 
    fit_results : dict 
        fit information to be used for trendlines 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s2">&quot;line_close&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;line_close&quot;</span><span class="s1">]:</span>
        <span class="s1">trace_data = trace_data.append(trace_data.iloc[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">trace_patch = trace_spec.trace_patch.copy() </span><span class="s0">or </span><span class="s1">{}</span>
    <span class="s1">fit_results = </span><span class="s0">None</span>
    <span class="s1">hover_header = </span><span class="s2">&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">attr_name </span><span class="s0">in </span><span class="s1">trace_spec.attrs:</span>
        <span class="s1">attr_value = args[attr_name]</span>
        <span class="s1">attr_label = get_decorated_label(args</span><span class="s0">, </span><span class="s1">attr_value</span><span class="s0">, </span><span class="s1">attr_name)</span>
        <span class="s0">if </span><span class="s1">attr_name == </span><span class="s2">&quot;dimensions&quot;</span><span class="s1">:</span>
            <span class="s1">dims = [</span>
                <span class="s1">(name</span><span class="s0">, </span><span class="s1">column)</span>
                <span class="s0">for </span><span class="s1">(name</span><span class="s0">, </span><span class="s1">column) </span><span class="s0">in </span><span class="s1">trace_data.iteritems()</span>
                <span class="s0">if </span><span class="s1">((</span><span class="s0">not </span><span class="s1">attr_value) </span><span class="s0">or </span><span class="s1">(name </span><span class="s0">in </span><span class="s1">attr_value))</span>
                <span class="s0">and </span><span class="s1">(</span>
                    <span class="s1">trace_spec.constructor != go.Parcoords</span>
                    <span class="s0">or </span><span class="s1">_is_continuous(args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name)</span>
                <span class="s1">)</span>
                <span class="s0">and </span><span class="s1">(</span>
                    <span class="s1">trace_spec.constructor != go.Parcats</span>
                    <span class="s0">or </span><span class="s1">(attr_value </span><span class="s0">is not None and </span><span class="s1">name </span><span class="s0">in </span><span class="s1">attr_value)</span>
                    <span class="s0">or </span><span class="s1">len(args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">][name].unique())</span>
                    <span class="s1">&lt;= args[</span><span class="s2">&quot;dimensions_max_cardinality&quot;</span><span class="s1">]</span>
                <span class="s1">)</span>
            <span class="s1">]</span>
            <span class="s1">trace_patch[</span><span class="s2">&quot;dimensions&quot;</span><span class="s1">] = [</span>
                <span class="s1">dict(label=get_label(args</span><span class="s0">, </span><span class="s1">name)</span><span class="s0">, </span><span class="s1">values=column)</span>
                <span class="s0">for </span><span class="s1">(name</span><span class="s0">, </span><span class="s1">column) </span><span class="s0">in </span><span class="s1">dims</span>
            <span class="s1">]</span>
            <span class="s0">if </span><span class="s1">trace_spec.constructor == go.Splom:</span>
                <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">trace_patch[</span><span class="s2">&quot;dimensions&quot;</span><span class="s1">]:</span>
                    <span class="s1">d[</span><span class="s2">&quot;axis&quot;</span><span class="s1">] = dict(matches=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s1">mapping_labels[</span><span class="s2">&quot;%{xaxis.title.text}&quot;</span><span class="s1">] = </span><span class="s2">&quot;%{x}&quot;</span>
                <span class="s1">mapping_labels[</span><span class="s2">&quot;%{yaxis.title.text}&quot;</span><span class="s1">] = </span><span class="s2">&quot;%{y}&quot;</span>

        <span class="s0">elif </span><span class="s1">attr_value </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">attr_name == </span><span class="s2">&quot;size&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s2">&quot;marker&quot; </span><span class="s0">not in </span><span class="s1">trace_patch:</span>
                    <span class="s1">trace_patch[</span><span class="s2">&quot;marker&quot;</span><span class="s1">] = dict()</span>
                <span class="s1">trace_patch[</span><span class="s2">&quot;marker&quot;</span><span class="s1">][</span><span class="s2">&quot;size&quot;</span><span class="s1">] = trace_data[attr_value]</span>
                <span class="s1">trace_patch[</span><span class="s2">&quot;marker&quot;</span><span class="s1">][</span><span class="s2">&quot;sizemode&quot;</span><span class="s1">] = </span><span class="s2">&quot;area&quot;</span>
                <span class="s1">trace_patch[</span><span class="s2">&quot;marker&quot;</span><span class="s1">][</span><span class="s2">&quot;sizeref&quot;</span><span class="s1">] = sizeref</span>
                <span class="s1">mapping_labels[attr_label] = </span><span class="s2">&quot;%{marker.size}&quot;</span>
            <span class="s0">elif </span><span class="s1">attr_name == </span><span class="s2">&quot;marginal_x&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">trace_spec.constructor == go.Histogram:</span>
                    <span class="s1">mapping_labels[</span><span class="s2">&quot;count&quot;</span><span class="s1">] = </span><span class="s2">&quot;%{y}&quot;</span>
            <span class="s0">elif </span><span class="s1">attr_name == </span><span class="s2">&quot;marginal_y&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">trace_spec.constructor == go.Histogram:</span>
                    <span class="s1">mapping_labels[</span><span class="s2">&quot;count&quot;</span><span class="s1">] = </span><span class="s2">&quot;%{x}&quot;</span>
            <span class="s0">elif </span><span class="s1">attr_name == </span><span class="s2">&quot;trendline&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">(</span>
                    <span class="s1">args[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span>
                    <span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;y&quot;</span><span class="s1">]</span>
                    <span class="s0">and </span><span class="s1">len(trace_data[[args[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;y&quot;</span><span class="s1">]]].dropna()) &gt; </span><span class="s4">1</span>
                <span class="s1">):</span>

                    <span class="s3"># sorting is bad but trace_specs with &quot;trendline&quot; have no other attrs</span>
                    <span class="s1">sorted_trace_data = trace_data.sort_values(by=args[</span><span class="s2">&quot;x&quot;</span><span class="s1">])</span>
                    <span class="s1">y = sorted_trace_data[args[</span><span class="s2">&quot;y&quot;</span><span class="s1">]].values</span>
                    <span class="s1">x = sorted_trace_data[args[</span><span class="s2">&quot;x&quot;</span><span class="s1">]].values</span>

                    <span class="s0">if </span><span class="s1">x.dtype.type == np.datetime64:</span>
                        <span class="s1">x = x.astype(int) / </span><span class="s4">10 </span><span class="s1">** </span><span class="s4">9  </span><span class="s3"># convert to unix epoch seconds</span>
                    <span class="s0">elif </span><span class="s1">x.dtype.type == np.object_:</span>
                        <span class="s0">try</span><span class="s1">:</span>
                            <span class="s1">x = x.astype(np.float64)</span>
                        <span class="s0">except </span><span class="s1">ValueError:</span>
                            <span class="s0">raise </span><span class="s1">ValueError(</span>
                                <span class="s2">&quot;Could not convert value of 'x' ('%s') into a numeric type. &quot;</span>
                                <span class="s2">&quot;If 'x' contains stringified dates, please convert to a datetime column.&quot;</span>
                                <span class="s1">% args[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span>
                            <span class="s1">)</span>
                    <span class="s0">if </span><span class="s1">y.dtype.type == np.object_:</span>
                        <span class="s0">try</span><span class="s1">:</span>
                            <span class="s1">y = y.astype(np.float64)</span>
                        <span class="s0">except </span><span class="s1">ValueError:</span>
                            <span class="s0">raise </span><span class="s1">ValueError(</span>
                                <span class="s2">&quot;Could not convert value of 'y' into a numeric type.&quot;</span>
                            <span class="s1">)</span>

                    <span class="s3"># preserve original values of &quot;x&quot; in case they're dates</span>
                    <span class="s3"># otherwise numpy/pandas can mess with the timezones</span>
                    <span class="s3"># NB this means trendline functions must output one-to-one with the input series</span>
                    <span class="s3"># i.e. we can't do resampling, because then the X values might not line up!</span>
                    <span class="s1">non_missing = np.logical_not(</span>
                        <span class="s1">np.logical_or(np.isnan(y)</span><span class="s0">, </span><span class="s1">np.isnan(x))</span>
                    <span class="s1">)</span>
                    <span class="s1">trace_patch[</span><span class="s2">&quot;x&quot;</span><span class="s1">] = sorted_trace_data[args[</span><span class="s2">&quot;x&quot;</span><span class="s1">]][non_missing]</span>
                    <span class="s1">trendline_function = trendline_functions[attr_value]</span>
                    <span class="s1">y_out</span><span class="s0">, </span><span class="s1">hover_header</span><span class="s0">, </span><span class="s1">fit_results = trendline_function(</span>
                        <span class="s1">args[</span><span class="s2">&quot;trendline_options&quot;</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">sorted_trace_data[args[</span><span class="s2">&quot;x&quot;</span><span class="s1">]]</span><span class="s0">,</span>
                        <span class="s1">x</span><span class="s0">,</span>
                        <span class="s1">y</span><span class="s0">,</span>
                        <span class="s1">args[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">args[</span><span class="s2">&quot;y&quot;</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">non_missing</span><span class="s0">,</span>
                    <span class="s1">)</span>
                    <span class="s0">assert </span><span class="s1">len(y_out) == len(</span>
                        <span class="s1">trace_patch[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span>
                    <span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;missing-data-handling failure in trendline code&quot;</span>
                    <span class="s1">trace_patch[</span><span class="s2">&quot;y&quot;</span><span class="s1">] = y_out</span>
                    <span class="s1">mapping_labels[get_label(args</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;x&quot;</span><span class="s1">])] = </span><span class="s2">&quot;%{x}&quot;</span>
                    <span class="s1">mapping_labels[get_label(args</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;y&quot;</span><span class="s1">])] = </span><span class="s2">&quot;%{y} &lt;b&gt;(trend)&lt;/b&gt;&quot;</span>
            <span class="s0">elif </span><span class="s1">attr_name.startswith(</span><span class="s2">&quot;error&quot;</span><span class="s1">):</span>
                <span class="s1">error_xy = attr_name[:</span><span class="s4">7</span><span class="s1">]</span>
                <span class="s1">arr = </span><span class="s2">&quot;arrayminus&quot; </span><span class="s0">if </span><span class="s1">attr_name.endswith(</span><span class="s2">&quot;minus&quot;</span><span class="s1">) </span><span class="s0">else </span><span class="s2">&quot;array&quot;</span>
                <span class="s0">if </span><span class="s1">error_xy </span><span class="s0">not in </span><span class="s1">trace_patch:</span>
                    <span class="s1">trace_patch[error_xy] = {}</span>
                <span class="s1">trace_patch[error_xy][arr] = trace_data[attr_value]</span>
            <span class="s0">elif </span><span class="s1">attr_name == </span><span class="s2">&quot;custom_data&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">len(attr_value) &gt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s3"># here we store a data frame in customdata, and it's serialized</span>
                    <span class="s3"># as a list of row lists, which is what we want</span>
                    <span class="s1">trace_patch[</span><span class="s2">&quot;customdata&quot;</span><span class="s1">] = trace_data[attr_value]</span>
            <span class="s0">elif </span><span class="s1">attr_name == </span><span class="s2">&quot;hover_name&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">trace_spec.constructor </span><span class="s0">not in </span><span class="s1">[</span>
                    <span class="s1">go.Histogram</span><span class="s0">,</span>
                    <span class="s1">go.Histogram2d</span><span class="s0">,</span>
                    <span class="s1">go.Histogram2dContour</span><span class="s0">,</span>
                <span class="s1">]:</span>
                    <span class="s1">trace_patch[</span><span class="s2">&quot;hovertext&quot;</span><span class="s1">] = trace_data[attr_value]</span>
                    <span class="s0">if </span><span class="s1">hover_header == </span><span class="s2">&quot;&quot;</span><span class="s1">:</span>
                        <span class="s1">hover_header = </span><span class="s2">&quot;&lt;b&gt;%{hovertext}&lt;/b&gt;&lt;br&gt;&lt;br&gt;&quot;</span>
            <span class="s0">elif </span><span class="s1">attr_name == </span><span class="s2">&quot;hover_data&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">trace_spec.constructor </span><span class="s0">not in </span><span class="s1">[</span>
                    <span class="s1">go.Histogram</span><span class="s0">,</span>
                    <span class="s1">go.Histogram2d</span><span class="s0">,</span>
                    <span class="s1">go.Histogram2dContour</span><span class="s0">,</span>
                <span class="s1">]:</span>
                    <span class="s1">hover_is_dict = isinstance(attr_value</span><span class="s0">, </span><span class="s1">dict)</span>
                    <span class="s1">customdata_cols = args.get(</span><span class="s2">&quot;custom_data&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s1">[]</span>
                    <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">attr_value:</span>
                        <span class="s0">if </span><span class="s1">hover_is_dict </span><span class="s0">and not </span><span class="s1">attr_value[col]:</span>
                            <span class="s0">continue</span>
                        <span class="s0">if </span><span class="s1">col </span><span class="s0">in </span><span class="s1">[</span>
                            <span class="s1">args.get(</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">args.get(</span><span class="s2">&quot;y&quot;</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">args.get(</span><span class="s2">&quot;z&quot;</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">args.get(</span><span class="s2">&quot;base&quot;</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">]:</span>
                            <span class="s0">continue</span>
                        <span class="s0">try</span><span class="s1">:</span>
                            <span class="s1">position = args[</span><span class="s2">&quot;custom_data&quot;</span><span class="s1">].index(col)</span>
                        <span class="s0">except </span><span class="s1">(ValueError</span><span class="s0">, </span><span class="s1">AttributeError</span><span class="s0">, </span><span class="s1">KeyError):</span>
                            <span class="s1">position = len(customdata_cols)</span>
                            <span class="s1">customdata_cols.append(col)</span>
                        <span class="s1">attr_label_col = get_decorated_label(args</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, None</span><span class="s1">)</span>
                        <span class="s1">mapping_labels[attr_label_col] = </span><span class="s2">&quot;%%{customdata[%d]}&quot; </span><span class="s1">% (</span>
                            <span class="s1">position</span>
                        <span class="s1">)</span>

                    <span class="s0">if </span><span class="s1">len(customdata_cols) &gt; </span><span class="s4">0</span><span class="s1">:</span>
                        <span class="s3"># here we store a data frame in customdata, and it's serialized</span>
                        <span class="s3"># as a list of row lists, which is what we want</span>
                        <span class="s1">trace_patch[</span><span class="s2">&quot;customdata&quot;</span><span class="s1">] = trace_data[customdata_cols]</span>
            <span class="s0">elif </span><span class="s1">attr_name == </span><span class="s2">&quot;color&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">trace_spec.constructor </span><span class="s0">in </span><span class="s1">[go.Choropleth</span><span class="s0">, </span><span class="s1">go.Choroplethmapbox]:</span>
                    <span class="s1">trace_patch[</span><span class="s2">&quot;z&quot;</span><span class="s1">] = trace_data[attr_value]</span>
                    <span class="s1">trace_patch[</span><span class="s2">&quot;coloraxis&quot;</span><span class="s1">] = </span><span class="s2">&quot;coloraxis1&quot;</span>
                    <span class="s1">mapping_labels[attr_label] = </span><span class="s2">&quot;%{z}&quot;</span>
                <span class="s0">elif </span><span class="s1">trace_spec.constructor </span><span class="s0">in </span><span class="s1">[</span>
                    <span class="s1">go.Sunburst</span><span class="s0">,</span>
                    <span class="s1">go.Treemap</span><span class="s0">,</span>
                    <span class="s1">go.Icicle</span><span class="s0">,</span>
                    <span class="s1">go.Pie</span><span class="s0">,</span>
                    <span class="s1">go.Funnelarea</span><span class="s0">,</span>
                <span class="s1">]:</span>
                    <span class="s0">if </span><span class="s2">&quot;marker&quot; </span><span class="s0">not in </span><span class="s1">trace_patch:</span>
                        <span class="s1">trace_patch[</span><span class="s2">&quot;marker&quot;</span><span class="s1">] = dict()</span>

                    <span class="s0">if </span><span class="s1">args.get(</span><span class="s2">&quot;color_is_continuous&quot;</span><span class="s1">):</span>
                        <span class="s1">trace_patch[</span><span class="s2">&quot;marker&quot;</span><span class="s1">][</span><span class="s2">&quot;colors&quot;</span><span class="s1">] = trace_data[attr_value]</span>
                        <span class="s1">trace_patch[</span><span class="s2">&quot;marker&quot;</span><span class="s1">][</span><span class="s2">&quot;coloraxis&quot;</span><span class="s1">] = </span><span class="s2">&quot;coloraxis1&quot;</span>
                        <span class="s1">mapping_labels[attr_label] = </span><span class="s2">&quot;%{color}&quot;</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">trace_patch[</span><span class="s2">&quot;marker&quot;</span><span class="s1">][</span><span class="s2">&quot;colors&quot;</span><span class="s1">] = []</span>
                        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;color_discrete_map&quot;</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
                            <span class="s1">mapping = args[</span><span class="s2">&quot;color_discrete_map&quot;</span><span class="s1">].copy()</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">mapping = {}</span>
                        <span class="s0">for </span><span class="s1">cat </span><span class="s0">in </span><span class="s1">trace_data[attr_value]:</span>
                            <span class="s0">if </span><span class="s1">mapping.get(cat) </span><span class="s0">is None</span><span class="s1">:</span>
                                <span class="s1">mapping[cat] = args[</span><span class="s2">&quot;color_discrete_sequence&quot;</span><span class="s1">][</span>
                                    <span class="s1">len(mapping) % len(args[</span><span class="s2">&quot;color_discrete_sequence&quot;</span><span class="s1">])</span>
                                <span class="s1">]</span>
                            <span class="s1">trace_patch[</span><span class="s2">&quot;marker&quot;</span><span class="s1">][</span><span class="s2">&quot;colors&quot;</span><span class="s1">].append(mapping[cat])</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">colorable = </span><span class="s2">&quot;marker&quot;</span>
                    <span class="s0">if </span><span class="s1">trace_spec.constructor </span><span class="s0">in </span><span class="s1">[go.Parcats</span><span class="s0">, </span><span class="s1">go.Parcoords]:</span>
                        <span class="s1">colorable = </span><span class="s2">&quot;line&quot;</span>
                    <span class="s0">if </span><span class="s1">colorable </span><span class="s0">not in </span><span class="s1">trace_patch:</span>
                        <span class="s1">trace_patch[colorable] = dict()</span>
                    <span class="s1">trace_patch[colorable][</span><span class="s2">&quot;color&quot;</span><span class="s1">] = trace_data[attr_value]</span>
                    <span class="s1">trace_patch[colorable][</span><span class="s2">&quot;coloraxis&quot;</span><span class="s1">] = </span><span class="s2">&quot;coloraxis1&quot;</span>
                    <span class="s1">mapping_labels[attr_label] = </span><span class="s2">&quot;%%{%s.color}&quot; </span><span class="s1">% colorable</span>
            <span class="s0">elif </span><span class="s1">attr_name == </span><span class="s2">&quot;animation_group&quot;</span><span class="s1">:</span>
                <span class="s1">trace_patch[</span><span class="s2">&quot;ids&quot;</span><span class="s1">] = trace_data[attr_value]</span>
            <span class="s0">elif </span><span class="s1">attr_name == </span><span class="s2">&quot;locations&quot;</span><span class="s1">:</span>
                <span class="s1">trace_patch[attr_name] = trace_data[attr_value]</span>
                <span class="s1">mapping_labels[attr_label] = </span><span class="s2">&quot;%{location}&quot;</span>
            <span class="s0">elif </span><span class="s1">attr_name == </span><span class="s2">&quot;values&quot;</span><span class="s1">:</span>
                <span class="s1">trace_patch[attr_name] = trace_data[attr_value]</span>
                <span class="s1">_label = </span><span class="s2">&quot;value&quot; </span><span class="s0">if </span><span class="s1">attr_label == </span><span class="s2">&quot;values&quot; </span><span class="s0">else </span><span class="s1">attr_label</span>
                <span class="s1">mapping_labels[_label] = </span><span class="s2">&quot;%{value}&quot;</span>
            <span class="s0">elif </span><span class="s1">attr_name == </span><span class="s2">&quot;parents&quot;</span><span class="s1">:</span>
                <span class="s1">trace_patch[attr_name] = trace_data[attr_value]</span>
                <span class="s1">_label = </span><span class="s2">&quot;parent&quot; </span><span class="s0">if </span><span class="s1">attr_label == </span><span class="s2">&quot;parents&quot; </span><span class="s0">else </span><span class="s1">attr_label</span>
                <span class="s1">mapping_labels[_label] = </span><span class="s2">&quot;%{parent}&quot;</span>
            <span class="s0">elif </span><span class="s1">attr_name == </span><span class="s2">&quot;ids&quot;</span><span class="s1">:</span>
                <span class="s1">trace_patch[attr_name] = trace_data[attr_value]</span>
                <span class="s1">_label = </span><span class="s2">&quot;id&quot; </span><span class="s0">if </span><span class="s1">attr_label == </span><span class="s2">&quot;ids&quot; </span><span class="s0">else </span><span class="s1">attr_label</span>
                <span class="s1">mapping_labels[_label] = </span><span class="s2">&quot;%{id}&quot;</span>
            <span class="s0">elif </span><span class="s1">attr_name == </span><span class="s2">&quot;names&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">trace_spec.constructor </span><span class="s0">in </span><span class="s1">[</span>
                    <span class="s1">go.Sunburst</span><span class="s0">,</span>
                    <span class="s1">go.Treemap</span><span class="s0">,</span>
                    <span class="s1">go.Icicle</span><span class="s0">,</span>
                    <span class="s1">go.Pie</span><span class="s0">,</span>
                    <span class="s1">go.Funnelarea</span><span class="s0">,</span>
                <span class="s1">]:</span>
                    <span class="s1">trace_patch[</span><span class="s2">&quot;labels&quot;</span><span class="s1">] = trace_data[attr_value]</span>
                    <span class="s1">_label = </span><span class="s2">&quot;label&quot; </span><span class="s0">if </span><span class="s1">attr_label == </span><span class="s2">&quot;names&quot; </span><span class="s0">else </span><span class="s1">attr_label</span>
                    <span class="s1">mapping_labels[_label] = </span><span class="s2">&quot;%{label}&quot;</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">trace_patch[attr_name] = trace_data[attr_value]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">trace_patch[attr_name] = trace_data[attr_value]</span>
                <span class="s1">mapping_labels[attr_label] = </span><span class="s2">&quot;%%{%s}&quot; </span><span class="s1">% attr_name</span>
        <span class="s0">elif </span><span class="s1">(trace_spec.constructor == go.Histogram </span><span class="s0">and </span><span class="s1">attr_name </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">]) </span><span class="s0">or </span><span class="s1">(</span>
            <span class="s1">trace_spec.constructor </span><span class="s0">in </span><span class="s1">[go.Histogram2d</span><span class="s0">, </span><span class="s1">go.Histogram2dContour]</span>
            <span class="s0">and </span><span class="s1">attr_name == </span><span class="s2">&quot;z&quot;</span>
        <span class="s1">):</span>
            <span class="s3"># ensure that stuff like &quot;count&quot; gets into the hoverlabel</span>
            <span class="s1">mapping_labels[attr_label] = </span><span class="s2">&quot;%%{%s}&quot; </span><span class="s1">% attr_name</span>
    <span class="s0">if </span><span class="s1">trace_spec.constructor </span><span class="s0">not in </span><span class="s1">[go.Parcoords</span><span class="s0">, </span><span class="s1">go.Parcats]:</span>
        <span class="s3"># Modify mapping_labels according to hover_data keys</span>
        <span class="s3"># if hover_data is a dict</span>
        <span class="s1">mapping_labels_copy = OrderedDict(mapping_labels)</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">] </span><span class="s0">and </span><span class="s1">isinstance(args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dict):</span>
            <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">mapping_labels.items():</span>
                <span class="s3"># We need to invert the mapping here</span>
                <span class="s1">k_args = invert_label(args</span><span class="s0">, </span><span class="s1">k)</span>
                <span class="s0">if </span><span class="s1">k_args </span><span class="s0">in </span><span class="s1">args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">]:</span>
                    <span class="s1">formatter = args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">][k_args][</span><span class="s4">0</span><span class="s1">]</span>
                    <span class="s0">if </span><span class="s1">formatter:</span>
                        <span class="s0">if </span><span class="s1">isinstance(formatter</span><span class="s0">, </span><span class="s1">str):</span>
                            <span class="s1">mapping_labels_copy[k] = v.replace(</span><span class="s2">&quot;}&quot;</span><span class="s0">, </span><span class="s2">&quot;%s}&quot; </span><span class="s1">% formatter)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">_ = mapping_labels_copy.pop(k)</span>
        <span class="s1">hover_lines = [k + </span><span class="s2">&quot;=&quot; </span><span class="s1">+ v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">mapping_labels_copy.items()]</span>
        <span class="s1">trace_patch[</span><span class="s2">&quot;hovertemplate&quot;</span><span class="s1">] = hover_header + </span><span class="s2">&quot;&lt;br&gt;&quot;</span><span class="s1">.join(hover_lines)</span>
        <span class="s1">trace_patch[</span><span class="s2">&quot;hovertemplate&quot;</span><span class="s1">] += </span><span class="s2">&quot;&lt;extra&gt;&lt;/extra&gt;&quot;</span>
    <span class="s0">return </span><span class="s1">trace_patch</span><span class="s0">, </span><span class="s1">fit_results</span>


<span class="s0">def </span><span class="s1">configure_axes(args</span><span class="s0">, </span><span class="s1">constructor</span><span class="s0">, </span><span class="s1">fig</span><span class="s0">, </span><span class="s1">orders):</span>
    <span class="s1">configurators = {</span>
        <span class="s1">go.Scatter3d: configure_3d_axes</span><span class="s0">,</span>
        <span class="s1">go.Scatterternary: configure_ternary_axes</span><span class="s0">,</span>
        <span class="s1">go.Scatterpolar: configure_polar_axes</span><span class="s0">,</span>
        <span class="s1">go.Scatterpolargl: configure_polar_axes</span><span class="s0">,</span>
        <span class="s1">go.Barpolar: configure_polar_axes</span><span class="s0">,</span>
        <span class="s1">go.Scattermapbox: configure_mapbox</span><span class="s0">,</span>
        <span class="s1">go.Choroplethmapbox: configure_mapbox</span><span class="s0">,</span>
        <span class="s1">go.Densitymapbox: configure_mapbox</span><span class="s0">,</span>
        <span class="s1">go.Scattergeo: configure_geo</span><span class="s0">,</span>
        <span class="s1">go.Choropleth: configure_geo</span><span class="s0">,</span>
    <span class="s1">}</span>
    <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">cartesians:</span>
        <span class="s1">configurators[c] = configure_cartesian_axes</span>
    <span class="s0">if </span><span class="s1">constructor </span><span class="s0">in </span><span class="s1">configurators:</span>
        <span class="s1">configurators[constructor](args</span><span class="s0">, </span><span class="s1">fig</span><span class="s0">, </span><span class="s1">orders)</span>


<span class="s0">def </span><span class="s1">set_cartesian_axis_opts(args</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">letter</span><span class="s0">, </span><span class="s1">orders):</span>
    <span class="s1">log_key = </span><span class="s2">&quot;log_&quot; </span><span class="s1">+ letter</span>
    <span class="s1">range_key = </span><span class="s2">&quot;range_&quot; </span><span class="s1">+ letter</span>
    <span class="s0">if </span><span class="s1">log_key </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[log_key]:</span>
        <span class="s1">axis[</span><span class="s2">&quot;type&quot;</span><span class="s1">] = </span><span class="s2">&quot;log&quot;</span>
        <span class="s0">if </span><span class="s1">range_key </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[range_key]:</span>
            <span class="s1">axis[</span><span class="s2">&quot;range&quot;</span><span class="s1">] = [math.log(r</span><span class="s0">, </span><span class="s4">10</span><span class="s1">) </span><span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">args[range_key]]</span>
    <span class="s0">elif </span><span class="s1">range_key </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[range_key]:</span>
        <span class="s1">axis[</span><span class="s2">&quot;range&quot;</span><span class="s1">] = args[range_key]</span>

    <span class="s0">if </span><span class="s1">args[letter] </span><span class="s0">in </span><span class="s1">orders:</span>
        <span class="s1">axis[</span><span class="s2">&quot;categoryorder&quot;</span><span class="s1">] = </span><span class="s2">&quot;array&quot;</span>
        <span class="s1">axis[</span><span class="s2">&quot;categoryarray&quot;</span><span class="s1">] = (</span>
            <span class="s1">orders[args[letter]]</span>
            <span class="s0">if </span><span class="s1">isinstance(axis</span><span class="s0">, </span><span class="s1">go.layout.XAxis)</span>
            <span class="s0">else </span><span class="s1">list(reversed(orders[args[letter]]))  </span><span class="s3"># top down for Y axis</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">configure_cartesian_marginal_axes(args</span><span class="s0">, </span><span class="s1">fig</span><span class="s0">, </span><span class="s1">orders):</span>

    <span class="s0">if </span><span class="s2">&quot;histogram&quot; </span><span class="s0">in </span><span class="s1">[args[</span><span class="s2">&quot;marginal_x&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;marginal_y&quot;</span><span class="s1">]]:</span>
        <span class="s1">fig.layout[</span><span class="s2">&quot;barmode&quot;</span><span class="s1">] = </span><span class="s2">&quot;overlay&quot;</span>

    <span class="s1">nrows = len(fig._grid_ref)</span>
    <span class="s1">ncols = len(fig._grid_ref[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s3"># Set y-axis titles and axis options in the left-most column</span>
    <span class="s0">for </span><span class="s1">yaxis </span><span class="s0">in </span><span class="s1">fig.select_yaxes(col=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">set_cartesian_axis_opts(args</span><span class="s0">, </span><span class="s1">yaxis</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s1">orders)</span>

    <span class="s3"># Set x-axis titles and axis options in the bottom-most row</span>
    <span class="s0">for </span><span class="s1">xaxis </span><span class="s0">in </span><span class="s1">fig.select_xaxes(row=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">set_cartesian_axis_opts(args</span><span class="s0">, </span><span class="s1">xaxis</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">orders)</span>

    <span class="s3"># Configure axis ticks on marginal subplots</span>
    <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;marginal_x&quot;</span><span class="s1">]:</span>
        <span class="s1">fig.update_yaxes(</span>
            <span class="s1">showticklabels=</span><span class="s0">False, </span><span class="s1">showline=</span><span class="s0">False, </span><span class="s1">ticks=</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">range=</span><span class="s0">None, </span><span class="s1">row=nrows</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">].layout.yaxis.showgrid </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">fig.update_yaxes(showgrid=args[</span><span class="s2">&quot;marginal_x&quot;</span><span class="s1">] == </span><span class="s2">&quot;histogram&quot;</span><span class="s0">, </span><span class="s1">row=nrows)</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">].layout.xaxis.showgrid </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">fig.update_xaxes(showgrid=</span><span class="s0">True, </span><span class="s1">row=nrows)</span>

    <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;marginal_y&quot;</span><span class="s1">]:</span>
        <span class="s1">fig.update_xaxes(</span>
            <span class="s1">showticklabels=</span><span class="s0">False, </span><span class="s1">showline=</span><span class="s0">False, </span><span class="s1">ticks=</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">range=</span><span class="s0">None, </span><span class="s1">col=ncols</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">].layout.xaxis.showgrid </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">fig.update_xaxes(showgrid=args[</span><span class="s2">&quot;marginal_y&quot;</span><span class="s1">] == </span><span class="s2">&quot;histogram&quot;</span><span class="s0">, </span><span class="s1">col=ncols)</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">].layout.yaxis.showgrid </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">fig.update_yaxes(showgrid=</span><span class="s0">True, </span><span class="s1">col=ncols)</span>

    <span class="s3"># Add axis titles to non-marginal subplots</span>
    <span class="s1">y_title = get_decorated_label(args</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;y&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;marginal_x&quot;</span><span class="s1">]:</span>
        <span class="s1">fig.update_yaxes(title_text=y_title</span><span class="s0">, </span><span class="s1">row=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">col=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">row </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">nrows + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">fig.update_yaxes(title_text=y_title</span><span class="s0">, </span><span class="s1">row=row</span><span class="s0">, </span><span class="s1">col=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">x_title = get_decorated_label(args</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;marginal_y&quot;</span><span class="s1">]:</span>
        <span class="s1">fig.update_xaxes(title_text=x_title</span><span class="s0">, </span><span class="s1">row=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">col=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">ncols + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">fig.update_xaxes(title_text=x_title</span><span class="s0">, </span><span class="s1">row=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">col=col)</span>

    <span class="s3"># Configure axis type across all x-axes</span>
    <span class="s0">if </span><span class="s2">&quot;log_x&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;log_x&quot;</span><span class="s1">]:</span>
        <span class="s1">fig.update_xaxes(type=</span><span class="s2">&quot;log&quot;</span><span class="s1">)</span>

    <span class="s3"># Configure axis type across all y-axes</span>
    <span class="s0">if </span><span class="s2">&quot;log_y&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;log_y&quot;</span><span class="s1">]:</span>
        <span class="s1">fig.update_yaxes(type=</span><span class="s2">&quot;log&quot;</span><span class="s1">)</span>

    <span class="s3"># Configure matching and axis type for marginal y-axes</span>
    <span class="s1">matches_y = </span><span class="s2">&quot;y&quot; </span><span class="s1">+ str(ncols + </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;marginal_x&quot;</span><span class="s1">]:</span>
        <span class="s0">for </span><span class="s1">row </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">2</span><span class="s0">, </span><span class="s1">nrows + </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">):</span>
            <span class="s1">fig.update_yaxes(matches=matches_y</span><span class="s0">, </span><span class="s1">type=</span><span class="s0">None, </span><span class="s1">row=row)</span>

    <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;marginal_y&quot;</span><span class="s1">]:</span>
        <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">2</span><span class="s0">, </span><span class="s1">ncols + </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">):</span>
            <span class="s1">fig.update_xaxes(matches=</span><span class="s2">&quot;x2&quot;</span><span class="s0">, </span><span class="s1">type=</span><span class="s0">None, </span><span class="s1">col=col)</span>


<span class="s0">def </span><span class="s1">configure_cartesian_axes(args</span><span class="s0">, </span><span class="s1">fig</span><span class="s0">, </span><span class="s1">orders):</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s2">&quot;marginal_x&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;marginal_x&quot;</span><span class="s1">]) </span><span class="s0">or </span><span class="s1">(</span>
        <span class="s2">&quot;marginal_y&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;marginal_y&quot;</span><span class="s1">]</span>
    <span class="s1">):</span>
        <span class="s1">configure_cartesian_marginal_axes(args</span><span class="s0">, </span><span class="s1">fig</span><span class="s0">, </span><span class="s1">orders)</span>
        <span class="s0">return</span>

    <span class="s3"># Set y-axis titles and axis options in the left-most column</span>
    <span class="s1">y_title = get_decorated_label(args</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;y&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">yaxis </span><span class="s0">in </span><span class="s1">fig.select_yaxes(col=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">yaxis.update(title_text=y_title)</span>
        <span class="s1">set_cartesian_axis_opts(args</span><span class="s0">, </span><span class="s1">yaxis</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s1">orders)</span>

    <span class="s3"># Set x-axis titles and axis options in the bottom-most row</span>
    <span class="s1">x_title = get_decorated_label(args</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">xaxis </span><span class="s0">in </span><span class="s1">fig.select_xaxes(row=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s2">&quot;is_timeline&quot; </span><span class="s0">not in </span><span class="s1">args:</span>
            <span class="s1">xaxis.update(title_text=x_title)</span>
        <span class="s1">set_cartesian_axis_opts(args</span><span class="s0">, </span><span class="s1">xaxis</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">orders)</span>

    <span class="s3"># Configure axis type across all x-axes</span>
    <span class="s0">if </span><span class="s2">&quot;log_x&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;log_x&quot;</span><span class="s1">]:</span>
        <span class="s1">fig.update_xaxes(type=</span><span class="s2">&quot;log&quot;</span><span class="s1">)</span>

    <span class="s3"># Configure axis type across all y-axes</span>
    <span class="s0">if </span><span class="s2">&quot;log_y&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;log_y&quot;</span><span class="s1">]:</span>
        <span class="s1">fig.update_yaxes(type=</span><span class="s2">&quot;log&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s2">&quot;is_timeline&quot; </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s1">fig.update_xaxes(type=</span><span class="s2">&quot;date&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s2">&quot;ecdfmode&quot; </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] == </span><span class="s2">&quot;v&quot;</span><span class="s1">:</span>
            <span class="s1">fig.update_yaxes(rangemode=</span><span class="s2">&quot;tozero&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">fig.update_xaxes(rangemode=</span><span class="s2">&quot;tozero&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">configure_ternary_axes(args</span><span class="s0">, </span><span class="s1">fig</span><span class="s0">, </span><span class="s1">orders):</span>
    <span class="s1">fig.update_ternaries(</span>
        <span class="s1">aaxis=dict(title_text=get_label(args</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;a&quot;</span><span class="s1">]))</span><span class="s0">,</span>
        <span class="s1">baxis=dict(title_text=get_label(args</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;b&quot;</span><span class="s1">]))</span><span class="s0">,</span>
        <span class="s1">caxis=dict(title_text=get_label(args</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;c&quot;</span><span class="s1">]))</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">configure_polar_axes(args</span><span class="s0">, </span><span class="s1">fig</span><span class="s0">, </span><span class="s1">orders):</span>
    <span class="s1">patch = dict(</span>
        <span class="s1">angularaxis=dict(direction=args[</span><span class="s2">&quot;direction&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rotation=args[</span><span class="s2">&quot;start_angle&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">radialaxis=dict()</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">for </span><span class="s1">var</span><span class="s0">, </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">[(</span><span class="s2">&quot;r&quot;</span><span class="s0">, </span><span class="s2">&quot;radialaxis&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;theta&quot;</span><span class="s0">, </span><span class="s2">&quot;angularaxis&quot;</span><span class="s1">)]:</span>
        <span class="s0">if </span><span class="s1">args[var] </span><span class="s0">in </span><span class="s1">orders:</span>
            <span class="s1">patch[axis][</span><span class="s2">&quot;categoryorder&quot;</span><span class="s1">] = </span><span class="s2">&quot;array&quot;</span>
            <span class="s1">patch[axis][</span><span class="s2">&quot;categoryarray&quot;</span><span class="s1">] = orders[args[var]]</span>

    <span class="s1">radialaxis = patch[</span><span class="s2">&quot;radialaxis&quot;</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;log_r&quot;</span><span class="s1">]:</span>
        <span class="s1">radialaxis[</span><span class="s2">&quot;type&quot;</span><span class="s1">] = </span><span class="s2">&quot;log&quot;</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;range_r&quot;</span><span class="s1">]:</span>
            <span class="s1">radialaxis[</span><span class="s2">&quot;range&quot;</span><span class="s1">] = [math.log(x</span><span class="s0">, </span><span class="s4">10</span><span class="s1">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">args[</span><span class="s2">&quot;range_r&quot;</span><span class="s1">]]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;range_r&quot;</span><span class="s1">]:</span>
            <span class="s1">radialaxis[</span><span class="s2">&quot;range&quot;</span><span class="s1">] = args[</span><span class="s2">&quot;range_r&quot;</span><span class="s1">]</span>

    <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;range_theta&quot;</span><span class="s1">]:</span>
        <span class="s1">patch[</span><span class="s2">&quot;sector&quot;</span><span class="s1">] = args[</span><span class="s2">&quot;range_theta&quot;</span><span class="s1">]</span>
    <span class="s1">fig.update_polars(patch)</span>


<span class="s0">def </span><span class="s1">configure_3d_axes(args</span><span class="s0">, </span><span class="s1">fig</span><span class="s0">, </span><span class="s1">orders):</span>
    <span class="s1">patch = dict(</span>
        <span class="s1">xaxis=dict(title_text=get_label(args</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;x&quot;</span><span class="s1">]))</span><span class="s0">,</span>
        <span class="s1">yaxis=dict(title_text=get_label(args</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;y&quot;</span><span class="s1">]))</span><span class="s0">,</span>
        <span class="s1">zaxis=dict(title_text=get_label(args</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;z&quot;</span><span class="s1">]))</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">for </span><span class="s1">letter </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;z&quot;</span><span class="s1">]:</span>
        <span class="s1">axis = patch[letter + </span><span class="s2">&quot;axis&quot;</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;log_&quot; </span><span class="s1">+ letter]:</span>
            <span class="s1">axis[</span><span class="s2">&quot;type&quot;</span><span class="s1">] = </span><span class="s2">&quot;log&quot;</span>
            <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;range_&quot; </span><span class="s1">+ letter]:</span>
                <span class="s1">axis[</span><span class="s2">&quot;range&quot;</span><span class="s1">] = [math.log(x</span><span class="s0">, </span><span class="s4">10</span><span class="s1">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">args[</span><span class="s2">&quot;range_&quot; </span><span class="s1">+ letter]]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;range_&quot; </span><span class="s1">+ letter]:</span>
                <span class="s1">axis[</span><span class="s2">&quot;range&quot;</span><span class="s1">] = args[</span><span class="s2">&quot;range_&quot; </span><span class="s1">+ letter]</span>
        <span class="s0">if </span><span class="s1">args[letter] </span><span class="s0">in </span><span class="s1">orders:</span>
            <span class="s1">axis[</span><span class="s2">&quot;categoryorder&quot;</span><span class="s1">] = </span><span class="s2">&quot;array&quot;</span>
            <span class="s1">axis[</span><span class="s2">&quot;categoryarray&quot;</span><span class="s1">] = orders[args[letter]]</span>
    <span class="s1">fig.update_scenes(patch)</span>


<span class="s0">def </span><span class="s1">configure_mapbox(args</span><span class="s0">, </span><span class="s1">fig</span><span class="s0">, </span><span class="s1">orders):</span>
    <span class="s1">center = args[</span><span class="s2">&quot;center&quot;</span><span class="s1">]</span>
    <span class="s0">if not </span><span class="s1">center </span><span class="s0">and </span><span class="s2">&quot;lat&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s2">&quot;lon&quot; </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s1">center = dict(</span>
            <span class="s1">lat=args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">][args[</span><span class="s2">&quot;lat&quot;</span><span class="s1">]].mean()</span><span class="s0">,</span>
            <span class="s1">lon=args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">][args[</span><span class="s2">&quot;lon&quot;</span><span class="s1">]].mean()</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s1">fig.update_mapboxes(</span>
        <span class="s1">accesstoken=MAPBOX_TOKEN</span><span class="s0">,</span>
        <span class="s1">center=center</span><span class="s0">,</span>
        <span class="s1">zoom=args[</span><span class="s2">&quot;zoom&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">style=args[</span><span class="s2">&quot;mapbox_style&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">configure_geo(args</span><span class="s0">, </span><span class="s1">fig</span><span class="s0">, </span><span class="s1">orders):</span>
    <span class="s1">fig.update_geos(</span>
        <span class="s1">center=args[</span><span class="s2">&quot;center&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">scope=args[</span><span class="s2">&quot;scope&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">fitbounds=args[</span><span class="s2">&quot;fitbounds&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">visible=args[</span><span class="s2">&quot;basemap_visible&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">projection=dict(type=args[</span><span class="s2">&quot;projection&quot;</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">configure_animation_controls(args</span><span class="s0">, </span><span class="s1">constructor</span><span class="s0">, </span><span class="s1">fig):</span>
    <span class="s0">def </span><span class="s1">frame_args(duration):</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s2">&quot;frame&quot;</span><span class="s1">: {</span><span class="s2">&quot;duration&quot;</span><span class="s1">: duration</span><span class="s0">, </span><span class="s2">&quot;redraw&quot;</span><span class="s1">: constructor != go.Scatter}</span><span class="s0">,</span>
            <span class="s2">&quot;mode&quot;</span><span class="s1">: </span><span class="s2">&quot;immediate&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;fromcurrent&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">&quot;transition&quot;</span><span class="s1">: {</span><span class="s2">&quot;duration&quot;</span><span class="s1">: duration</span><span class="s0">, </span><span class="s2">&quot;easing&quot;</span><span class="s1">: </span><span class="s2">&quot;linear&quot;</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s1">}</span>

    <span class="s0">if </span><span class="s2">&quot;animation_frame&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;animation_frame&quot;</span><span class="s1">] </span><span class="s0">and </span><span class="s1">len(fig.frames) &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">fig.layout.updatemenus = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;buttons&quot;</span><span class="s1">: [</span>
                    <span class="s1">{</span>
                        <span class="s2">&quot;args&quot;</span><span class="s1">: [</span><span class="s0">None, </span><span class="s1">frame_args(</span><span class="s4">500</span><span class="s1">)]</span><span class="s0">,</span>
                        <span class="s2">&quot;label&quot;</span><span class="s1">: </span><span class="s2">&quot;&amp;#9654;&quot;</span><span class="s0">,</span>
                        <span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;animate&quot;</span><span class="s0">,</span>
                    <span class="s1">}</span><span class="s0">,</span>
                    <span class="s1">{</span>
                        <span class="s2">&quot;args&quot;</span><span class="s1">: [[</span><span class="s0">None</span><span class="s1">]</span><span class="s0">, </span><span class="s1">frame_args(</span><span class="s4">0</span><span class="s1">)]</span><span class="s0">,</span>
                        <span class="s2">&quot;label&quot;</span><span class="s1">: </span><span class="s2">&quot;&amp;#9724;&quot;</span><span class="s0">,</span>
                        <span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;animate&quot;</span><span class="s0">,</span>
                    <span class="s1">}</span><span class="s0">,</span>
                <span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;direction&quot;</span><span class="s1">: </span><span class="s2">&quot;left&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;pad&quot;</span><span class="s1">: {</span><span class="s2">&quot;r&quot;</span><span class="s1">: </span><span class="s4">10</span><span class="s0">, </span><span class="s2">&quot;t&quot;</span><span class="s1">: </span><span class="s4">70</span><span class="s1">}</span><span class="s0">,</span>
                <span class="s2">&quot;showactive&quot;</span><span class="s1">: </span><span class="s0">False,</span>
                <span class="s2">&quot;type&quot;</span><span class="s1">: </span><span class="s2">&quot;buttons&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s4">0.1</span><span class="s0">,</span>
                <span class="s2">&quot;xanchor&quot;</span><span class="s1">: </span><span class="s2">&quot;right&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s0">,</span>
                <span class="s2">&quot;yanchor&quot;</span><span class="s1">: </span><span class="s2">&quot;top&quot;</span><span class="s0">,</span>
            <span class="s1">}</span>
        <span class="s1">]</span>
        <span class="s1">fig.layout.sliders = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;active&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s0">,</span>
                <span class="s2">&quot;yanchor&quot;</span><span class="s1">: </span><span class="s2">&quot;top&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;xanchor&quot;</span><span class="s1">: </span><span class="s2">&quot;left&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;currentvalue&quot;</span><span class="s1">: {</span>
                    <span class="s2">&quot;prefix&quot;</span><span class="s1">: get_label(args</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;animation_frame&quot;</span><span class="s1">]) + </span><span class="s2">&quot;=&quot;</span>
                <span class="s1">}</span><span class="s0">,</span>
                <span class="s2">&quot;pad&quot;</span><span class="s1">: {</span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s4">10</span><span class="s0">, </span><span class="s2">&quot;t&quot;</span><span class="s1">: </span><span class="s4">60</span><span class="s1">}</span><span class="s0">,</span>
                <span class="s2">&quot;len&quot;</span><span class="s1">: </span><span class="s4">0.9</span><span class="s0">,</span>
                <span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s4">0.1</span><span class="s0">,</span>
                <span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s0">,</span>
                <span class="s2">&quot;steps&quot;</span><span class="s1">: [</span>
                    <span class="s1">{</span>
                        <span class="s2">&quot;args&quot;</span><span class="s1">: [[f.name]</span><span class="s0">, </span><span class="s1">frame_args(</span><span class="s4">0</span><span class="s1">)]</span><span class="s0">,</span>
                        <span class="s2">&quot;label&quot;</span><span class="s1">: f.name</span><span class="s0">,</span>
                        <span class="s2">&quot;method&quot;</span><span class="s1">: </span><span class="s2">&quot;animate&quot;</span><span class="s0">,</span>
                    <span class="s1">}</span>
                    <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">fig.frames</span>
                <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">}</span>
        <span class="s1">]</span>


<span class="s0">def </span><span class="s1">make_trace_spec(args</span><span class="s0">, </span><span class="s1">constructor</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">trace_patch):</span>
    <span class="s0">if </span><span class="s1">constructor </span><span class="s0">in </span><span class="s1">[go.Scatter</span><span class="s0">, </span><span class="s1">go.Scatterpolar]:</span>
        <span class="s0">if </span><span class="s2">&quot;render_mode&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">(</span>
            <span class="s1">args[</span><span class="s2">&quot;render_mode&quot;</span><span class="s1">] == </span><span class="s2">&quot;webgl&quot;</span>
            <span class="s0">or </span><span class="s1">(</span>
                <span class="s1">args[</span><span class="s2">&quot;render_mode&quot;</span><span class="s1">] == </span><span class="s2">&quot;auto&quot;</span>
                <span class="s0">and </span><span class="s1">len(args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">]) &gt; </span><span class="s4">1000</span>
                <span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;animation_frame&quot;</span><span class="s1">] </span><span class="s0">is None</span>
            <span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s0">if </span><span class="s1">constructor == go.Scatter:</span>
                <span class="s1">constructor = go.Scattergl</span>
                <span class="s0">if </span><span class="s2">&quot;orientation&quot; </span><span class="s0">in </span><span class="s1">trace_patch:</span>
                    <span class="s0">del </span><span class="s1">trace_patch[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">constructor = go.Scatterpolargl</span>
    <span class="s3"># Create base trace specification</span>
    <span class="s1">result = [TraceSpec(constructor</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">trace_patch</span><span class="s0">, None</span><span class="s1">)]</span>

    <span class="s3"># Add marginal trace specifications</span>
    <span class="s0">for </span><span class="s1">letter </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">]:</span>
        <span class="s0">if </span><span class="s2">&quot;marginal_&quot; </span><span class="s1">+ letter </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;marginal_&quot; </span><span class="s1">+ letter]:</span>
            <span class="s1">trace_spec = </span><span class="s0">None</span>
            <span class="s1">axis_map = dict(</span>
                <span class="s1">xaxis=</span><span class="s2">&quot;x1&quot; </span><span class="s0">if </span><span class="s1">letter == </span><span class="s2">&quot;x&quot; </span><span class="s0">else </span><span class="s2">&quot;x2&quot;</span><span class="s0">,</span>
                <span class="s1">yaxis=</span><span class="s2">&quot;y1&quot; </span><span class="s0">if </span><span class="s1">letter == </span><span class="s2">&quot;y&quot; </span><span class="s0">else </span><span class="s2">&quot;y2&quot;</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;marginal_&quot; </span><span class="s1">+ letter] == </span><span class="s2">&quot;histogram&quot;</span><span class="s1">:</span>
                <span class="s1">trace_spec = TraceSpec(</span>
                    <span class="s1">constructor=go.Histogram</span><span class="s0">,</span>
                    <span class="s1">attrs=[letter</span><span class="s0">, </span><span class="s2">&quot;marginal_&quot; </span><span class="s1">+ letter]</span><span class="s0">,</span>
                    <span class="s1">trace_patch=dict(opacity=</span><span class="s4">0.5</span><span class="s0">, </span><span class="s1">bingroup=letter</span><span class="s0">, </span><span class="s1">**axis_map)</span><span class="s0">,</span>
                    <span class="s1">marginal=letter</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">args[</span><span class="s2">&quot;marginal_&quot; </span><span class="s1">+ letter] == </span><span class="s2">&quot;violin&quot;</span><span class="s1">:</span>
                <span class="s1">trace_spec = TraceSpec(</span>
                    <span class="s1">constructor=go.Violin</span><span class="s0">,</span>
                    <span class="s1">attrs=[letter</span><span class="s0">, </span><span class="s2">&quot;hover_name&quot;</span><span class="s0">, </span><span class="s2">&quot;hover_data&quot;</span><span class="s1">]</span><span class="s0">,</span>
                    <span class="s1">trace_patch=dict(scalegroup=letter)</span><span class="s0">,</span>
                    <span class="s1">marginal=letter</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">args[</span><span class="s2">&quot;marginal_&quot; </span><span class="s1">+ letter] == </span><span class="s2">&quot;box&quot;</span><span class="s1">:</span>
                <span class="s1">trace_spec = TraceSpec(</span>
                    <span class="s1">constructor=go.Box</span><span class="s0">,</span>
                    <span class="s1">attrs=[letter</span><span class="s0">, </span><span class="s2">&quot;hover_name&quot;</span><span class="s0">, </span><span class="s2">&quot;hover_data&quot;</span><span class="s1">]</span><span class="s0">,</span>
                    <span class="s1">trace_patch=dict(notched=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">marginal=letter</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">args[</span><span class="s2">&quot;marginal_&quot; </span><span class="s1">+ letter] == </span><span class="s2">&quot;rug&quot;</span><span class="s1">:</span>
                <span class="s1">symbols = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s2">&quot;line-ns-open&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s2">&quot;line-ew-open&quot;</span><span class="s1">}</span>
                <span class="s1">trace_spec = TraceSpec(</span>
                    <span class="s1">constructor=go.Box</span><span class="s0">,</span>
                    <span class="s1">attrs=[letter</span><span class="s0">, </span><span class="s2">&quot;hover_name&quot;</span><span class="s0">, </span><span class="s2">&quot;hover_data&quot;</span><span class="s1">]</span><span class="s0">,</span>
                    <span class="s1">trace_patch=dict(</span>
                        <span class="s1">fillcolor=</span><span class="s2">&quot;rgba(255,255,255,0)&quot;</span><span class="s0">,</span>
                        <span class="s1">line={</span><span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s2">&quot;rgba(255,255,255,0)&quot;</span><span class="s1">}</span><span class="s0">,</span>
                        <span class="s1">boxpoints=</span><span class="s2">&quot;all&quot;</span><span class="s0">,</span>
                        <span class="s1">jitter=</span><span class="s4">0</span><span class="s0">,</span>
                        <span class="s1">hoveron=</span><span class="s2">&quot;points&quot;</span><span class="s0">,</span>
                        <span class="s1">marker={</span><span class="s2">&quot;symbol&quot;</span><span class="s1">: symbols[letter]}</span><span class="s0">,</span>
                    <span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">marginal=letter</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">if </span><span class="s2">&quot;color&quot; </span><span class="s0">in </span><span class="s1">attrs </span><span class="s0">or </span><span class="s2">&quot;color&quot; </span><span class="s0">not in </span><span class="s1">args:</span>
                <span class="s0">if </span><span class="s2">&quot;marker&quot; </span><span class="s0">not in </span><span class="s1">trace_spec.trace_patch:</span>
                    <span class="s1">trace_spec.trace_patch[</span><span class="s2">&quot;marker&quot;</span><span class="s1">] = dict()</span>
                <span class="s1">first_default_color = args[</span><span class="s2">&quot;color_continuous_scale&quot;</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">trace_spec.trace_patch[</span><span class="s2">&quot;marker&quot;</span><span class="s1">][</span><span class="s2">&quot;color&quot;</span><span class="s1">] = first_default_color</span>
            <span class="s1">result.append(trace_spec)</span>

    <span class="s3"># Add trendline trace specifications</span>
    <span class="s0">if </span><span class="s1">args.get(</span><span class="s2">&quot;trendline&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">args.get(</span><span class="s2">&quot;trendline_scope&quot;</span><span class="s0">, </span><span class="s2">&quot;trace&quot;</span><span class="s1">) == </span><span class="s2">&quot;trace&quot;</span><span class="s1">:</span>
        <span class="s1">result.append(make_trendline_spec(args</span><span class="s0">, </span><span class="s1">constructor))</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">make_trendline_spec(args</span><span class="s0">, </span><span class="s1">constructor):</span>
    <span class="s1">trace_spec = TraceSpec(</span>
        <span class="s1">constructor=go.Scattergl</span>
        <span class="s0">if </span><span class="s1">constructor == go.Scattergl  </span><span class="s3"># could be contour</span>
        <span class="s0">else </span><span class="s1">go.Scatter</span><span class="s0">,</span>
        <span class="s1">attrs=[</span><span class="s2">&quot;trendline&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">trace_patch=dict(mode=</span><span class="s2">&quot;lines&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">marginal=</span><span class="s0">None,</span>
    <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;trendline_color_override&quot;</span><span class="s1">]:</span>
        <span class="s1">trace_spec.trace_patch[</span><span class="s2">&quot;line&quot;</span><span class="s1">] = dict(color=args[</span><span class="s2">&quot;trendline_color_override&quot;</span><span class="s1">])</span>
    <span class="s0">return </span><span class="s1">trace_spec</span>


<span class="s0">def </span><span class="s1">one_group(x):</span>
    <span class="s0">return </span><span class="s2">&quot;&quot;</span>


<span class="s0">def </span><span class="s1">apply_default_cascade(args):</span>
    <span class="s3"># first we apply px.defaults to unspecified args</span>

    <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">defaults.__slots__:</span>
        <span class="s0">if </span><span class="s1">param </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[param] </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">args[param] = getattr(defaults</span><span class="s0">, </span><span class="s1">param)</span>

    <span class="s3"># load the default template if set, otherwise &quot;plotly&quot;</span>
    <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">pio.templates.default </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">] = pio.templates.default</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">] = </span><span class="s2">&quot;plotly&quot;</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s3"># retrieve the actual template if we were given a name</span>
        <span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">] = pio.templates[args[</span><span class="s2">&quot;template&quot;</span><span class="s1">]]</span>
    <span class="s0">except </span><span class="s1">Exception:</span>
        <span class="s3"># otherwise try to build a real template</span>
        <span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">] = go.layout.Template(args[</span><span class="s2">&quot;template&quot;</span><span class="s1">])</span>

    <span class="s3"># if colors not set explicitly or in px.defaults, defer to a template</span>
    <span class="s3"># if the template doesn't have one, we set some final fallback defaults</span>
    <span class="s0">if </span><span class="s2">&quot;color_continuous_scale&quot; </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">args[</span><span class="s2">&quot;color_continuous_scale&quot;</span><span class="s1">] </span><span class="s0">is None</span>
            <span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">].layout.colorscale.sequential</span>
        <span class="s1">):</span>
            <span class="s1">args[</span><span class="s2">&quot;color_continuous_scale&quot;</span><span class="s1">] = [</span>
                <span class="s1">x[</span><span class="s4">1</span><span class="s1">] </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">].layout.colorscale.sequential</span>
            <span class="s1">]</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;color_continuous_scale&quot;</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">args[</span><span class="s2">&quot;color_continuous_scale&quot;</span><span class="s1">] = sequential.Viridis</span>

    <span class="s0">if </span><span class="s2">&quot;color_discrete_sequence&quot; </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;color_discrete_sequence&quot;</span><span class="s1">] </span><span class="s0">is None and </span><span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">].layout.colorway:</span>
            <span class="s1">args[</span><span class="s2">&quot;color_discrete_sequence&quot;</span><span class="s1">] = args[</span><span class="s2">&quot;template&quot;</span><span class="s1">].layout.colorway</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;color_discrete_sequence&quot;</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">args[</span><span class="s2">&quot;color_discrete_sequence&quot;</span><span class="s1">] = qualitative.D3</span>

    <span class="s3"># if symbol_sequence/line_dash_sequence not set explicitly or in px.defaults,</span>
    <span class="s3"># see if we can defer to template. If not, set reasonable defaults</span>
    <span class="s0">if </span><span class="s2">&quot;symbol_sequence&quot; </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;symbol_sequence&quot;</span><span class="s1">] </span><span class="s0">is None and </span><span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">].data.scatter:</span>
            <span class="s1">args[</span><span class="s2">&quot;symbol_sequence&quot;</span><span class="s1">] = [</span>
                <span class="s1">scatter.marker.symbol </span><span class="s0">for </span><span class="s1">scatter </span><span class="s0">in </span><span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">].data.scatter</span>
            <span class="s1">]</span>
        <span class="s0">if not </span><span class="s1">args[</span><span class="s2">&quot;symbol_sequence&quot;</span><span class="s1">] </span><span class="s0">or not </span><span class="s1">any(args[</span><span class="s2">&quot;symbol_sequence&quot;</span><span class="s1">]):</span>
            <span class="s1">args[</span><span class="s2">&quot;symbol_sequence&quot;</span><span class="s1">] = [</span><span class="s2">&quot;circle&quot;</span><span class="s0">, </span><span class="s2">&quot;diamond&quot;</span><span class="s0">, </span><span class="s2">&quot;square&quot;</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;cross&quot;</span><span class="s1">]</span>

    <span class="s0">if </span><span class="s2">&quot;line_dash_sequence&quot; </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;line_dash_sequence&quot;</span><span class="s1">] </span><span class="s0">is None and </span><span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">].data.scatter:</span>
            <span class="s1">args[</span><span class="s2">&quot;line_dash_sequence&quot;</span><span class="s1">] = [</span>
                <span class="s1">scatter.line.dash </span><span class="s0">for </span><span class="s1">scatter </span><span class="s0">in </span><span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">].data.scatter</span>
            <span class="s1">]</span>
        <span class="s0">if not </span><span class="s1">args[</span><span class="s2">&quot;line_dash_sequence&quot;</span><span class="s1">] </span><span class="s0">or not </span><span class="s1">any(args[</span><span class="s2">&quot;line_dash_sequence&quot;</span><span class="s1">]):</span>
            <span class="s1">args[</span><span class="s2">&quot;line_dash_sequence&quot;</span><span class="s1">] = [</span>
                <span class="s2">&quot;solid&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;dot&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;dash&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;longdash&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;dashdot&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;longdashdot&quot;</span><span class="s0">,</span>
            <span class="s1">]</span>

    <span class="s0">if </span><span class="s2">&quot;pattern_shape_sequence&quot; </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;pattern_shape_sequence&quot;</span><span class="s1">] </span><span class="s0">is None and </span><span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">].data.bar:</span>
            <span class="s1">args[</span><span class="s2">&quot;pattern_shape_sequence&quot;</span><span class="s1">] = [</span>
                <span class="s1">bar.marker.pattern.shape </span><span class="s0">for </span><span class="s1">bar </span><span class="s0">in </span><span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">].data.bar</span>
            <span class="s1">]</span>
        <span class="s0">if not </span><span class="s1">args[</span><span class="s2">&quot;pattern_shape_sequence&quot;</span><span class="s1">] </span><span class="s0">or not </span><span class="s1">any(</span>
            <span class="s1">args[</span><span class="s2">&quot;pattern_shape_sequence&quot;</span><span class="s1">]</span>
        <span class="s1">):</span>
            <span class="s1">args[</span><span class="s2">&quot;pattern_shape_sequence&quot;</span><span class="s1">] = [</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;/&quot;</span><span class="s0">, </span><span class="s2">&quot;</span><span class="s0">\\</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;+&quot;</span><span class="s0">, </span><span class="s2">&quot;.&quot;</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">_check_name_not_reserved(field_name</span><span class="s0">, </span><span class="s1">reserved_names):</span>
    <span class="s0">if </span><span class="s1">field_name </span><span class="s0">not in </span><span class="s1">reserved_names:</span>
        <span class="s0">return </span><span class="s1">field_name</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">NameError(</span>
            <span class="s2">&quot;A name conflict was encountered for argument '%s'. &quot;</span>
            <span class="s2">&quot;A column or index with name '%s' is ambiguous.&quot; </span><span class="s1">% (field_name</span><span class="s0">, </span><span class="s1">field_name)</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_get_reserved_col_names(args):</span>
    <span class="s5">&quot;&quot;&quot; 
    This function builds a list of columns of the data_frame argument used 
    as arguments, either as str/int arguments or given as columns 
    (pandas series type). 
    &quot;&quot;&quot;</span>
    <span class="s1">df = args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">]</span>
    <span class="s1">reserved_names = set()</span>
    <span class="s0">for </span><span class="s1">field </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s0">if </span><span class="s1">field </span><span class="s0">not in </span><span class="s1">all_attrables:</span>
            <span class="s0">continue</span>
        <span class="s1">names = args[field] </span><span class="s0">if </span><span class="s1">field </span><span class="s0">in </span><span class="s1">array_attrables </span><span class="s0">else </span><span class="s1">[args[field]]</span>
        <span class="s0">if </span><span class="s1">names </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">continue</span>
        <span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">names:</span>
            <span class="s0">if </span><span class="s1">arg </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">continue</span>
            <span class="s0">elif </span><span class="s1">isinstance(arg</span><span class="s0">, </span><span class="s1">str):  </span><span class="s3"># no need to add ints since kw arg are not ints</span>
                <span class="s1">reserved_names.add(arg)</span>
            <span class="s0">elif </span><span class="s1">isinstance(arg</span><span class="s0">, </span><span class="s1">pd.Series):</span>
                <span class="s1">arg_name = arg.name</span>
                <span class="s0">if </span><span class="s1">arg_name </span><span class="s0">and </span><span class="s1">hasattr(df</span><span class="s0">, </span><span class="s1">arg_name):</span>
                    <span class="s1">in_df = arg </span><span class="s0">is </span><span class="s1">df[arg_name]</span>
                    <span class="s0">if </span><span class="s1">in_df:</span>
                        <span class="s1">reserved_names.add(arg_name)</span>
            <span class="s0">elif </span><span class="s1">arg </span><span class="s0">is </span><span class="s1">df.index </span><span class="s0">and </span><span class="s1">arg.name </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">reserved_names.add(arg.name)</span>

    <span class="s0">return </span><span class="s1">reserved_names</span>


<span class="s0">def </span><span class="s1">_is_col_list(df_input</span><span class="s0">, </span><span class="s1">arg):</span>
    <span class="s5">&quot;&quot;&quot;Returns True if arg looks like it's a list of columns or references to columns 
    in df_input, and False otherwise (in which case it's assumed to be a single column 
    or reference to a column). 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">arg </span><span class="s0">is None or </span><span class="s1">isinstance(arg</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">or </span><span class="s1">isinstance(arg</span><span class="s0">, </span><span class="s1">int):</span>
        <span class="s0">return False</span>
    <span class="s0">if </span><span class="s1">isinstance(arg</span><span class="s0">, </span><span class="s1">pd.MultiIndex):</span>
        <span class="s0">return False  </span><span class="s3"># just to keep existing behaviour for now</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">iter(arg)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">return False  </span><span class="s3"># not iterable</span>
    <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">arg:</span>
        <span class="s0">if </span><span class="s1">isinstance(c</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">or </span><span class="s1">isinstance(c</span><span class="s0">, </span><span class="s1">int):</span>
            <span class="s0">if </span><span class="s1">df_input </span><span class="s0">is None or </span><span class="s1">c </span><span class="s0">not in </span><span class="s1">df_input.columns:</span>
                <span class="s0">return False</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">iter(c)</span>
            <span class="s0">except </span><span class="s1">TypeError:</span>
                <span class="s0">return False  </span><span class="s3"># not iterable</span>
    <span class="s0">return True</span>


<span class="s0">def </span><span class="s1">_isinstance_listlike(x):</span>
    <span class="s5">&quot;&quot;&quot;Returns True if x is an iterable which can be transformed into a pandas Series, 
    False for the other types of possible values of a `hover_data` dict. 
    A tuple of length 2 is a special case corresponding to a (format, data) tuple. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">str)</span>
        <span class="s0">or </span><span class="s1">(isinstance(x</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">and </span><span class="s1">len(x) == </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s0">or </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">bool)</span>
        <span class="s0">or </span><span class="s1">x </span><span class="s0">is None</span>
    <span class="s1">):</span>
        <span class="s0">return False</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return True</span>


<span class="s0">def </span><span class="s1">_escape_col_name(df_input</span><span class="s0">, </span><span class="s1">col_name</span><span class="s0">, </span><span class="s1">extra):</span>
    <span class="s0">while </span><span class="s1">df_input </span><span class="s0">is not None and </span><span class="s1">(col_name </span><span class="s0">in </span><span class="s1">df_input.columns </span><span class="s0">or </span><span class="s1">col_name </span><span class="s0">in </span><span class="s1">extra):</span>
        <span class="s1">col_name = </span><span class="s2">&quot;_&quot; </span><span class="s1">+ col_name</span>
    <span class="s0">return </span><span class="s1">col_name</span>


<span class="s0">def </span><span class="s1">to_unindexed_series(x):</span>
    <span class="s5">&quot;&quot;&quot; 
    assuming x is list-like or even an existing pd.Series, return a new pd.Series with 
    no index, without extracting the data from an existing Series via numpy, which 
    seems to mangle datetime columns. Stripping the index from existing pd.Series is 
    required to get things to match up right in the new DataFrame we're building 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">pd.Series(x).reset_index(drop=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">process_args_into_dataframe(args</span><span class="s0">, </span><span class="s1">wide_mode</span><span class="s0">, </span><span class="s1">var_name</span><span class="s0">, </span><span class="s1">value_name):</span>
    <span class="s5">&quot;&quot;&quot; 
    After this function runs, the `all_attrables` keys of `args` all contain only 
    references to columns of `df_output`. This function handles the extraction of data 
    from `args[&quot;attrable&quot;]` and column-name-generation as appropriate, and adds the 
    data to `df_output` and then replaces `args[&quot;attrable&quot;]` with the appropriate 
    reference. 
    &quot;&quot;&quot;</span>

    <span class="s1">df_input = args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">]</span>
    <span class="s1">df_provided = df_input </span><span class="s0">is not None</span>

    <span class="s1">df_output = pd.DataFrame()</span>
    <span class="s1">constants = dict()</span>
    <span class="s1">ranges = list()</span>
    <span class="s1">wide_id_vars = set()</span>
    <span class="s1">reserved_names = _get_reserved_col_names(args) </span><span class="s0">if </span><span class="s1">df_provided </span><span class="s0">else </span><span class="s1">set()</span>

    <span class="s3"># Case of functions with a &quot;dimensions&quot; kw: scatter_matrix, parcats, parcoords</span>
    <span class="s0">if </span><span class="s2">&quot;dimensions&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;dimensions&quot;</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">if not </span><span class="s1">df_provided:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;No data were provided. Please provide data either with the `data_frame` or with the `dimensions` argument.&quot;</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">df_output[df_input.columns] = df_input[df_input.columns]</span>

    <span class="s3"># hover_data is a dict</span>
    <span class="s1">hover_data_is_dict = (</span>
        <span class="s2">&quot;hover_data&quot; </span><span class="s0">in </span><span class="s1">args</span>
        <span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">]</span>
        <span class="s0">and </span><span class="s1">isinstance(args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dict)</span>
    <span class="s1">)</span>
    <span class="s3"># If dict, convert all values of hover_data to tuples to simplify processing</span>
    <span class="s0">if </span><span class="s1">hover_data_is_dict:</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">]:</span>
            <span class="s0">if </span><span class="s1">_isinstance_listlike(args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">][k]):</span>
                <span class="s1">args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">][k] = (</span><span class="s0">True, </span><span class="s1">args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">][k])</span>
            <span class="s0">if not </span><span class="s1">isinstance(args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">][k]</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">][k] = (args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">][k]</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">df_provided </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">][k][</span><span class="s4">1</span><span class="s1">] </span><span class="s0">is not None and </span><span class="s1">k </span><span class="s0">in </span><span class="s1">df_input:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">&quot;Ambiguous input: values for '%s' appear both in hover_data and data_frame&quot;</span>
                    <span class="s1">% k</span>
                <span class="s1">)</span>
    <span class="s3"># Loop over possible arguments</span>
    <span class="s0">for </span><span class="s1">field_name </span><span class="s0">in </span><span class="s1">all_attrables:</span>
        <span class="s3"># Massaging variables</span>
        <span class="s1">argument_list = (</span>
            <span class="s1">[args.get(field_name)]</span>
            <span class="s0">if </span><span class="s1">field_name </span><span class="s0">not in </span><span class="s1">array_attrables</span>
            <span class="s0">else </span><span class="s1">args.get(field_name)</span>
        <span class="s1">)</span>
        <span class="s3"># argument not specified, continue</span>
        <span class="s0">if </span><span class="s1">argument_list </span><span class="s0">is None or </span><span class="s1">argument_list </span><span class="s0">is </span><span class="s1">[</span><span class="s0">None</span><span class="s1">]:</span>
            <span class="s0">continue</span>
        <span class="s3"># Argument name: field_name if the argument is not a list</span>
        <span class="s3"># Else we give names like [&quot;hover_data_0, hover_data_1&quot;] etc.</span>
        <span class="s1">field_list = (</span>
            <span class="s1">[field_name]</span>
            <span class="s0">if </span><span class="s1">field_name </span><span class="s0">not in </span><span class="s1">array_attrables</span>
            <span class="s0">else </span><span class="s1">[field_name + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ str(i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(argument_list))]</span>
        <span class="s1">)</span>
        <span class="s3"># argument_list and field_list ready, iterate over them</span>
        <span class="s3"># Core of the loop starts here</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">(argument</span><span class="s0">, </span><span class="s1">field) </span><span class="s0">in </span><span class="s1">enumerate(zip(argument_list</span><span class="s0">, </span><span class="s1">field_list)):</span>
            <span class="s1">length = len(df_output)</span>
            <span class="s0">if </span><span class="s1">argument </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">continue</span>
            <span class="s1">col_name = </span><span class="s0">None</span>
            <span class="s3"># Case of multiindex</span>
            <span class="s0">if </span><span class="s1">isinstance(argument</span><span class="s0">, </span><span class="s1">pd.MultiIndex):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s2">&quot;Argument '%s' is a pandas MultiIndex. &quot;</span>
                    <span class="s2">&quot;pandas MultiIndex is not supported by plotly express &quot;</span>
                    <span class="s2">&quot;at the moment.&quot; </span><span class="s1">% field</span>
                <span class="s1">)</span>
            <span class="s3"># ----------------- argument is a special value ----------------------</span>
            <span class="s0">if </span><span class="s1">isinstance(argument</span><span class="s0">, </span><span class="s1">Constant) </span><span class="s0">or </span><span class="s1">isinstance(argument</span><span class="s0">, </span><span class="s1">Range):</span>
                <span class="s1">col_name = _check_name_not_reserved(</span>
                    <span class="s1">str(argument.label) </span><span class="s0">if </span><span class="s1">argument.label </span><span class="s0">is not None else </span><span class="s1">field</span><span class="s0">,</span>
                    <span class="s1">reserved_names</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s0">if </span><span class="s1">isinstance(argument</span><span class="s0">, </span><span class="s1">Constant):</span>
                    <span class="s1">constants[col_name] = argument.value</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">ranges.append(col_name)</span>
            <span class="s3"># ----------------- argument is likely a col name ----------------------</span>
            <span class="s0">elif </span><span class="s1">isinstance(argument</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">or not </span><span class="s1">hasattr(argument</span><span class="s0">, </span><span class="s2">&quot;__len__&quot;</span><span class="s1">):</span>
                <span class="s0">if </span><span class="s1">(</span>
                    <span class="s1">field_name == </span><span class="s2">&quot;hover_data&quot;</span>
                    <span class="s0">and </span><span class="s1">hover_data_is_dict</span>
                    <span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">][str(argument)][</span><span class="s4">1</span><span class="s1">] </span><span class="s0">is not None</span>
                <span class="s1">):</span>
                    <span class="s3"># hover_data has onboard data</span>
                    <span class="s3"># previously-checked to have no name-conflict with data_frame</span>
                    <span class="s1">col_name = str(argument)</span>
                    <span class="s1">real_argument = args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">][col_name][</span><span class="s4">1</span><span class="s1">]</span>

                    <span class="s0">if </span><span class="s1">length </span><span class="s0">and </span><span class="s1">len(real_argument) != length:</span>
                        <span class="s0">raise </span><span class="s1">ValueError(</span>
                            <span class="s2">&quot;All arguments should have the same length. &quot;</span>
                            <span class="s2">&quot;The length of hover_data key `%s` is %d, whereas the &quot;</span>
                            <span class="s2">&quot;length of previously-processed arguments %s is %d&quot;</span>
                            <span class="s1">% (</span>
                                <span class="s1">argument</span><span class="s0">,</span>
                                <span class="s1">len(real_argument)</span><span class="s0">,</span>
                                <span class="s1">str(list(df_output.columns))</span><span class="s0">,</span>
                                <span class="s1">length</span><span class="s0">,</span>
                            <span class="s1">)</span>
                        <span class="s1">)</span>
                    <span class="s1">df_output[col_name] = to_unindexed_series(real_argument)</span>
                <span class="s0">elif not </span><span class="s1">df_provided:</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span>
                        <span class="s2">&quot;String or int arguments are only possible when a &quot;</span>
                        <span class="s2">&quot;DataFrame or an array is provided in the `data_frame` &quot;</span>
                        <span class="s2">&quot;argument. No DataFrame was provided, but argument &quot;</span>
                        <span class="s2">&quot;'%s' is of type str or int.&quot; </span><span class="s1">% field</span>
                    <span class="s1">)</span>
                <span class="s3"># Check validity of column name</span>
                <span class="s0">elif </span><span class="s1">argument </span><span class="s0">not in </span><span class="s1">df_input.columns:</span>
                    <span class="s0">if </span><span class="s1">wide_mode </span><span class="s0">and </span><span class="s1">argument </span><span class="s0">in </span><span class="s1">(value_name</span><span class="s0">, </span><span class="s1">var_name):</span>
                        <span class="s0">continue</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">err_msg = (</span>
                            <span class="s2">&quot;Value of '%s' is not the name of a column in 'data_frame'. &quot;</span>
                            <span class="s2">&quot;Expected one of %s but received: %s&quot;</span>
                            <span class="s1">% (field</span><span class="s0">, </span><span class="s1">str(list(df_input.columns))</span><span class="s0">, </span><span class="s1">argument)</span>
                        <span class="s1">)</span>
                        <span class="s0">if </span><span class="s1">argument == </span><span class="s2">&quot;index&quot;</span><span class="s1">:</span>
                            <span class="s1">err_msg += </span><span class="s2">&quot;</span><span class="s0">\n </span><span class="s2">To use the index, pass it in directly as `df.index`.&quot;</span>
                        <span class="s0">raise </span><span class="s1">ValueError(err_msg)</span>
                <span class="s0">elif </span><span class="s1">length </span><span class="s0">and </span><span class="s1">len(df_input[argument]) != length:</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span>
                        <span class="s2">&quot;All arguments should have the same length. &quot;</span>
                        <span class="s2">&quot;The length of column argument `df[%s]` is %d, whereas the &quot;</span>
                        <span class="s2">&quot;length of  previously-processed arguments %s is %d&quot;</span>
                        <span class="s1">% (</span>
                            <span class="s1">field</span><span class="s0">,</span>
                            <span class="s1">len(df_input[argument])</span><span class="s0">,</span>
                            <span class="s1">str(list(df_output.columns))</span><span class="s0">,</span>
                            <span class="s1">length</span><span class="s0">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">col_name = str(argument)</span>
                    <span class="s1">df_output[col_name] = to_unindexed_series(df_input[argument])</span>
            <span class="s3"># ----------------- argument is likely a column / array / list.... -------</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">df_provided </span><span class="s0">and </span><span class="s1">hasattr(argument</span><span class="s0">, </span><span class="s2">&quot;name&quot;</span><span class="s1">):</span>
                    <span class="s0">if </span><span class="s1">argument </span><span class="s0">is </span><span class="s1">df_input.index:</span>
                        <span class="s0">if </span><span class="s1">argument.name </span><span class="s0">is None or </span><span class="s1">argument.name </span><span class="s0">in </span><span class="s1">df_input:</span>
                            <span class="s1">col_name = </span><span class="s2">&quot;index&quot;</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">col_name = argument.name</span>
                        <span class="s1">col_name = _escape_col_name(</span>
                            <span class="s1">df_input</span><span class="s0">, </span><span class="s1">col_name</span><span class="s0">, </span><span class="s1">[var_name</span><span class="s0">, </span><span class="s1">value_name]</span>
                        <span class="s1">)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s0">if </span><span class="s1">(</span>
                            <span class="s1">argument.name </span><span class="s0">is not None</span>
                            <span class="s0">and </span><span class="s1">argument.name </span><span class="s0">in </span><span class="s1">df_input</span>
                            <span class="s0">and </span><span class="s1">argument </span><span class="s0">is </span><span class="s1">df_input[argument.name]</span>
                        <span class="s1">):</span>
                            <span class="s1">col_name = argument.name</span>
                <span class="s0">if </span><span class="s1">col_name </span><span class="s0">is None</span><span class="s1">:  </span><span class="s3"># numpy array, list...</span>
                    <span class="s1">col_name = _check_name_not_reserved(field</span><span class="s0">, </span><span class="s1">reserved_names)</span>

                <span class="s0">if </span><span class="s1">length </span><span class="s0">and </span><span class="s1">len(argument) != length:</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span>
                        <span class="s2">&quot;All arguments should have the same length. &quot;</span>
                        <span class="s2">&quot;The length of argument `%s` is %d, whereas the &quot;</span>
                        <span class="s2">&quot;length of  previously-processed arguments %s is %d&quot;</span>
                        <span class="s1">% (field</span><span class="s0">, </span><span class="s1">len(argument)</span><span class="s0">, </span><span class="s1">str(list(df_output.columns))</span><span class="s0">, </span><span class="s1">length)</span>
                    <span class="s1">)</span>
                <span class="s1">df_output[str(col_name)] = to_unindexed_series(argument)</span>

            <span class="s3"># Finally, update argument with column name now that column exists</span>
            <span class="s0">assert </span><span class="s1">col_name </span><span class="s0">is not None, </span><span class="s1">(</span>
                <span class="s2">&quot;Data-frame processing failure, likely due to a internal bug. &quot;</span>
                <span class="s2">&quot;Please report this to &quot;</span>
                <span class="s2">&quot;https://github.com/plotly/plotly.py/issues/new and we will try to &quot;</span>
                <span class="s2">&quot;replicate and fix it.&quot;</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">field_name </span><span class="s0">not in </span><span class="s1">array_attrables:</span>
                <span class="s1">args[field_name] = str(col_name)</span>
            <span class="s0">elif </span><span class="s1">isinstance(args[field_name]</span><span class="s0">, </span><span class="s1">dict):</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">args[field_name][i] = str(col_name)</span>
            <span class="s0">if </span><span class="s1">field_name != </span><span class="s2">&quot;wide_variable&quot;</span><span class="s1">:</span>
                <span class="s1">wide_id_vars.add(str(col_name))</span>

    <span class="s0">for </span><span class="s1">col_name </span><span class="s0">in </span><span class="s1">ranges:</span>
        <span class="s1">df_output[col_name] = range(len(df_output))</span>

    <span class="s0">for </span><span class="s1">col_name </span><span class="s0">in </span><span class="s1">constants:</span>
        <span class="s1">df_output[col_name] = constants[col_name]</span>

    <span class="s0">return </span><span class="s1">df_output</span><span class="s0">, </span><span class="s1">wide_id_vars</span>


<span class="s0">def </span><span class="s1">build_dataframe(args</span><span class="s0">, </span><span class="s1">constructor):</span>
    <span class="s5">&quot;&quot;&quot; 
    Constructs a dataframe and modifies `args` in-place. 
 
    The argument values in `args` can be either strings corresponding to 
    existing columns of a dataframe, or data arrays (lists, numpy arrays, 
    pandas columns, series). 
 
    Parameters 
    ---------- 
    args : OrderedDict 
        arguments passed to the px function and subsequently modified 
    constructor : graph_object trace class 
        the trace type selected for this figure 
    &quot;&quot;&quot;</span>

    <span class="s3"># make copies of all the fields via dict() and list()</span>
    <span class="s0">for </span><span class="s1">field </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s0">if </span><span class="s1">field </span><span class="s0">in </span><span class="s1">array_attrables </span><span class="s0">and </span><span class="s1">args[field] </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">args[field] = (</span>
                <span class="s1">dict(args[field])</span>
                <span class="s0">if </span><span class="s1">isinstance(args[field]</span><span class="s0">, </span><span class="s1">dict)</span>
                <span class="s0">else </span><span class="s1">list(args[field])</span>
            <span class="s1">)</span>

    <span class="s3"># Cast data_frame argument to DataFrame (it could be a numpy array, dict etc.)</span>
    <span class="s1">df_provided = args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">] </span><span class="s0">is not None</span>
    <span class="s0">if </span><span class="s1">df_provided </span><span class="s0">and not </span><span class="s1">isinstance(args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pd.DataFrame):</span>
        <span class="s1">args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">] = pd.DataFrame(args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">])</span>
    <span class="s1">df_input = args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">]</span>

    <span class="s3"># now we handle special cases like wide-mode or x-xor-y specification</span>
    <span class="s3"># by rearranging args to tee things up for process_args_into_dataframe to work</span>
    <span class="s1">no_x = args.get(</span><span class="s2">&quot;x&quot;</span><span class="s1">) </span><span class="s0">is None</span>
    <span class="s1">no_y = args.get(</span><span class="s2">&quot;y&quot;</span><span class="s1">) </span><span class="s0">is None</span>
    <span class="s1">wide_x = </span><span class="s0">False if </span><span class="s1">no_x </span><span class="s0">else </span><span class="s1">_is_col_list(df_input</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;x&quot;</span><span class="s1">])</span>
    <span class="s1">wide_y = </span><span class="s0">False if </span><span class="s1">no_y </span><span class="s0">else </span><span class="s1">_is_col_list(df_input</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;y&quot;</span><span class="s1">])</span>

    <span class="s1">wide_mode = </span><span class="s0">False</span>
    <span class="s1">var_name = </span><span class="s0">None  </span><span class="s3"># will likely be &quot;variable&quot; in wide_mode</span>
    <span class="s1">wide_cross_name = </span><span class="s0">None  </span><span class="s3"># will likely be &quot;index&quot; in wide_mode</span>
    <span class="s1">value_name = </span><span class="s0">None  </span><span class="s3"># will likely be &quot;value&quot; in wide_mode</span>
    <span class="s1">hist2d_types = [go.Histogram2d</span><span class="s0">, </span><span class="s1">go.Histogram2dContour]</span>
    <span class="s1">hist1d_orientation = constructor == go.Histogram </span><span class="s0">or </span><span class="s2">&quot;ecdfmode&quot; </span><span class="s0">in </span><span class="s1">args</span>
    <span class="s0">if </span><span class="s1">constructor </span><span class="s0">in </span><span class="s1">cartesians:</span>
        <span class="s0">if </span><span class="s1">wide_x </span><span class="s0">and </span><span class="s1">wide_y:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;Cannot accept list of column references or list of columns for both `x` and `y`.&quot;</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">df_provided </span><span class="s0">and </span><span class="s1">no_x </span><span class="s0">and </span><span class="s1">no_y:</span>
            <span class="s1">wide_mode = </span><span class="s0">True</span>
            <span class="s0">if </span><span class="s1">isinstance(df_input.columns</span><span class="s0">, </span><span class="s1">pd.MultiIndex):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s2">&quot;Data frame columns is a pandas MultiIndex. &quot;</span>
                    <span class="s2">&quot;pandas MultiIndex is not supported by plotly express &quot;</span>
                    <span class="s2">&quot;at the moment.&quot;</span>
                <span class="s1">)</span>
            <span class="s1">args[</span><span class="s2">&quot;wide_variable&quot;</span><span class="s1">] = list(df_input.columns)</span>
            <span class="s1">var_name = df_input.columns.name</span>
            <span class="s0">if </span><span class="s1">var_name </span><span class="s0">in </span><span class="s1">[</span><span class="s0">None, </span><span class="s2">&quot;value&quot;</span><span class="s0">, </span><span class="s2">&quot;index&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s1">var_name </span><span class="s0">in </span><span class="s1">df_input:</span>
                <span class="s1">var_name = </span><span class="s2">&quot;variable&quot;</span>
            <span class="s0">if </span><span class="s1">constructor == go.Funnel:</span>
                <span class="s1">wide_orientation = args.get(</span><span class="s2">&quot;orientation&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s2">&quot;h&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">wide_orientation = args.get(</span><span class="s2">&quot;orientation&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s2">&quot;v&quot;</span>
            <span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] = wide_orientation</span>
            <span class="s1">args[</span><span class="s2">&quot;wide_cross&quot;</span><span class="s1">] = </span><span class="s0">None</span>
        <span class="s0">elif </span><span class="s1">wide_x != wide_y:</span>
            <span class="s1">wide_mode = </span><span class="s0">True</span>
            <span class="s1">args[</span><span class="s2">&quot;wide_variable&quot;</span><span class="s1">] = args[</span><span class="s2">&quot;y&quot;</span><span class="s1">] </span><span class="s0">if </span><span class="s1">wide_y </span><span class="s0">else </span><span class="s1">args[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">df_provided </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;wide_variable&quot;</span><span class="s1">] </span><span class="s0">is </span><span class="s1">df_input.columns:</span>
                <span class="s1">var_name = df_input.columns.name</span>
            <span class="s0">if </span><span class="s1">isinstance(args[</span><span class="s2">&quot;wide_variable&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pd.Index):</span>
                <span class="s1">args[</span><span class="s2">&quot;wide_variable&quot;</span><span class="s1">] = list(args[</span><span class="s2">&quot;wide_variable&quot;</span><span class="s1">])</span>
            <span class="s0">if </span><span class="s1">var_name </span><span class="s0">in </span><span class="s1">[</span><span class="s0">None, </span><span class="s2">&quot;value&quot;</span><span class="s0">, </span><span class="s2">&quot;index&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s1">(</span>
                <span class="s1">df_provided </span><span class="s0">and </span><span class="s1">var_name </span><span class="s0">in </span><span class="s1">df_input</span>
            <span class="s1">):</span>
                <span class="s1">var_name = </span><span class="s2">&quot;variable&quot;</span>
            <span class="s0">if </span><span class="s1">hist1d_orientation:</span>
                <span class="s1">wide_orientation = </span><span class="s2">&quot;v&quot; </span><span class="s0">if </span><span class="s1">wide_x </span><span class="s0">else </span><span class="s2">&quot;h&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">wide_orientation = </span><span class="s2">&quot;v&quot; </span><span class="s0">if </span><span class="s1">wide_y </span><span class="s0">else </span><span class="s2">&quot;h&quot;</span>
            <span class="s1">args[</span><span class="s2">&quot;y&quot; </span><span class="s0">if </span><span class="s1">wide_y </span><span class="s0">else </span><span class="s2">&quot;x&quot;</span><span class="s1">] = </span><span class="s0">None</span>
            <span class="s1">args[</span><span class="s2">&quot;wide_cross&quot;</span><span class="s1">] = </span><span class="s0">None</span>
            <span class="s0">if not </span><span class="s1">no_x </span><span class="s0">and not </span><span class="s1">no_y:</span>
                <span class="s1">wide_cross_name = </span><span class="s2">&quot;__x__&quot; </span><span class="s0">if </span><span class="s1">wide_y </span><span class="s0">else </span><span class="s2">&quot;__y__&quot;</span>

    <span class="s0">if </span><span class="s1">wide_mode:</span>
        <span class="s1">value_name = _escape_col_name(df_input</span><span class="s0">, </span><span class="s2">&quot;value&quot;</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">var_name = _escape_col_name(df_input</span><span class="s0">, </span><span class="s1">var_name</span><span class="s0">, </span><span class="s1">[])</span>

    <span class="s1">missing_bar_dim = </span><span class="s0">None</span>
    <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">constructor </span><span class="s0">in </span><span class="s1">[go.Scatter</span><span class="s0">, </span><span class="s1">go.Bar</span><span class="s0">, </span><span class="s1">go.Funnel] + hist2d_types</span>
        <span class="s0">and not </span><span class="s1">hist1d_orientation</span>
    <span class="s1">):</span>
        <span class="s0">if not </span><span class="s1">wide_mode </span><span class="s0">and </span><span class="s1">(no_x != no_y):</span>
            <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">]:</span>
                <span class="s0">if </span><span class="s1">args.get(ax) </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">args[ax] = df_input.index </span><span class="s0">if </span><span class="s1">df_provided </span><span class="s0">else </span><span class="s1">Range()</span>
                    <span class="s0">if </span><span class="s1">constructor == go.Bar:</span>
                        <span class="s1">missing_bar_dim = ax</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
                            <span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] = </span><span class="s2">&quot;v&quot; </span><span class="s0">if </span><span class="s1">ax == </span><span class="s2">&quot;x&quot; </span><span class="s0">else </span><span class="s2">&quot;h&quot;</span>
        <span class="s0">if </span><span class="s1">wide_mode </span><span class="s0">and </span><span class="s1">wide_cross_name </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">no_x != no_y </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] = </span><span class="s2">&quot;v&quot; </span><span class="s0">if </span><span class="s1">no_x </span><span class="s0">else </span><span class="s2">&quot;h&quot;</span>
            <span class="s0">if </span><span class="s1">df_provided:</span>
                <span class="s0">if </span><span class="s1">isinstance(df_input.index</span><span class="s0">, </span><span class="s1">pd.MultiIndex):</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span>
                        <span class="s2">&quot;Data frame index is a pandas MultiIndex. &quot;</span>
                        <span class="s2">&quot;pandas MultiIndex is not supported by plotly express &quot;</span>
                        <span class="s2">&quot;at the moment.&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">args[</span><span class="s2">&quot;wide_cross&quot;</span><span class="s1">] = df_input.index</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">args[</span><span class="s2">&quot;wide_cross&quot;</span><span class="s1">] = Range(</span>
                    <span class="s1">label=_escape_col_name(df_input</span><span class="s0">, </span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s1">[var_name</span><span class="s0">, </span><span class="s1">value_name])</span>
                <span class="s1">)</span>

    <span class="s1">no_color = </span><span class="s0">False</span>
    <span class="s0">if </span><span class="s1">type(args.get(</span><span class="s2">&quot;color&quot;</span><span class="s1">)) == str </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">] == NO_COLOR:</span>
        <span class="s1">no_color = </span><span class="s0">True</span>
        <span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = </span><span class="s0">None</span>
    <span class="s3"># now that things have been prepped, we do the systematic rewriting of `args`</span>

    <span class="s1">df_output</span><span class="s0">, </span><span class="s1">wide_id_vars = process_args_into_dataframe(</span>
        <span class="s1">args</span><span class="s0">, </span><span class="s1">wide_mode</span><span class="s0">, </span><span class="s1">var_name</span><span class="s0">, </span><span class="s1">value_name</span>
    <span class="s1">)</span>

    <span class="s3"># now that `df_output` exists and `args` contains only references, we complete</span>
    <span class="s3"># the special-case and wide-mode handling by further rewriting args and/or mutating</span>
    <span class="s3"># df_output</span>

    <span class="s1">count_name = _escape_col_name(df_output</span><span class="s0">, </span><span class="s2">&quot;count&quot;</span><span class="s0">, </span><span class="s1">[var_name</span><span class="s0">, </span><span class="s1">value_name])</span>
    <span class="s0">if not </span><span class="s1">wide_mode </span><span class="s0">and </span><span class="s1">missing_bar_dim </span><span class="s0">and </span><span class="s1">constructor == go.Bar:</span>
        <span class="s3"># now that we've populated df_output, we check to see if the non-missing</span>
        <span class="s3"># dimension is categorical: if so, then setting the missing dimension to a</span>
        <span class="s3"># constant 1 is a less-insane thing to do than setting it to the index by</span>
        <span class="s3"># default and we let the normal auto-orientation-code do its thing later</span>
        <span class="s1">other_dim = </span><span class="s2">&quot;x&quot; </span><span class="s0">if </span><span class="s1">missing_bar_dim == </span><span class="s2">&quot;y&quot; </span><span class="s0">else </span><span class="s2">&quot;y&quot;</span>
        <span class="s0">if not </span><span class="s1">_is_continuous(df_output</span><span class="s0">, </span><span class="s1">args[other_dim]):</span>
            <span class="s1">args[missing_bar_dim] = count_name</span>
            <span class="s1">df_output[count_name] = </span><span class="s4">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># on the other hand, if the non-missing dimension is continuous, then we</span>
            <span class="s3"># can use this information to override the normal auto-orientation code</span>
            <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] = </span><span class="s2">&quot;v&quot; </span><span class="s0">if </span><span class="s1">missing_bar_dim == </span><span class="s2">&quot;x&quot; </span><span class="s0">else </span><span class="s2">&quot;h&quot;</span>

    <span class="s0">if </span><span class="s1">constructor </span><span class="s0">in </span><span class="s1">hist2d_types:</span>
        <span class="s0">del </span><span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">]</span>

    <span class="s0">if </span><span class="s1">wide_mode:</span>
        <span class="s3"># at this point, `df_output` is semi-long/semi-wide, but we know which columns</span>
        <span class="s3"># are which, so we melt it and reassign `args` to refer to the newly-tidy</span>
        <span class="s3"># columns, keeping track of various names and manglings set up above</span>
        <span class="s1">wide_value_vars = [c </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">args[</span><span class="s2">&quot;wide_variable&quot;</span><span class="s1">] </span><span class="s0">if </span><span class="s1">c </span><span class="s0">not in </span><span class="s1">wide_id_vars]</span>
        <span class="s0">del </span><span class="s1">args[</span><span class="s2">&quot;wide_variable&quot;</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">wide_cross_name == </span><span class="s2">&quot;__x__&quot;</span><span class="s1">:</span>
            <span class="s1">wide_cross_name = args[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span>
        <span class="s0">elif </span><span class="s1">wide_cross_name == </span><span class="s2">&quot;__y__&quot;</span><span class="s1">:</span>
            <span class="s1">wide_cross_name = args[</span><span class="s2">&quot;y&quot;</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">wide_cross_name = args[</span><span class="s2">&quot;wide_cross&quot;</span><span class="s1">]</span>
        <span class="s0">del </span><span class="s1">args[</span><span class="s2">&quot;wide_cross&quot;</span><span class="s1">]</span>
        <span class="s1">dtype = </span><span class="s0">None</span>
        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">wide_value_vars:</span>
            <span class="s1">v_dtype = df_output[v].dtype.kind</span>
            <span class="s1">v_dtype = </span><span class="s2">&quot;number&quot; </span><span class="s0">if </span><span class="s1">v_dtype </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;i&quot;</span><span class="s0">, </span><span class="s2">&quot;f&quot;</span><span class="s0">, </span><span class="s2">&quot;u&quot;</span><span class="s1">] </span><span class="s0">else </span><span class="s1">v_dtype</span>
            <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">dtype = v_dtype</span>
            <span class="s0">elif </span><span class="s1">dtype != v_dtype:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">&quot;Plotly Express cannot process wide-form data with columns of different type.&quot;</span>
                <span class="s1">)</span>
        <span class="s1">df_output = df_output.melt(</span>
            <span class="s1">id_vars=wide_id_vars</span><span class="s0">,</span>
            <span class="s1">value_vars=wide_value_vars</span><span class="s0">,</span>
            <span class="s1">var_name=var_name</span><span class="s0">,</span>
            <span class="s1">value_name=value_name</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">len(df_output.columns) == len(set(df_output.columns))</span><span class="s0">, </span><span class="s1">(</span>
            <span class="s2">&quot;Wide-mode name-inference failure, likely due to a internal bug. &quot;</span>
            <span class="s2">&quot;Please report this to &quot;</span>
            <span class="s2">&quot;https://github.com/plotly/plotly.py/issues/new and we will try to &quot;</span>
            <span class="s2">&quot;replicate and fix it.&quot;</span>
        <span class="s1">)</span>
        <span class="s1">df_output[var_name] = df_output[var_name].astype(str)</span>
        <span class="s1">orient_v = wide_orientation == </span><span class="s2">&quot;v&quot;</span>

        <span class="s0">if </span><span class="s1">hist1d_orientation:</span>
            <span class="s1">args[</span><span class="s2">&quot;x&quot; </span><span class="s0">if </span><span class="s1">orient_v </span><span class="s0">else </span><span class="s2">&quot;y&quot;</span><span class="s1">] = value_name</span>
            <span class="s1">args[</span><span class="s2">&quot;y&quot; </span><span class="s0">if </span><span class="s1">orient_v </span><span class="s0">else </span><span class="s2">&quot;x&quot;</span><span class="s1">] = wide_cross_name</span>
            <span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = args[</span><span class="s2">&quot;color&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s1">var_name</span>
        <span class="s0">elif </span><span class="s1">constructor </span><span class="s0">in </span><span class="s1">[go.Scatter</span><span class="s0">, </span><span class="s1">go.Funnel] + hist2d_types:</span>
            <span class="s1">args[</span><span class="s2">&quot;x&quot; </span><span class="s0">if </span><span class="s1">orient_v </span><span class="s0">else </span><span class="s2">&quot;y&quot;</span><span class="s1">] = wide_cross_name</span>
            <span class="s1">args[</span><span class="s2">&quot;y&quot; </span><span class="s0">if </span><span class="s1">orient_v </span><span class="s0">else </span><span class="s2">&quot;x&quot;</span><span class="s1">] = value_name</span>
            <span class="s0">if </span><span class="s1">constructor != go.Histogram2d:</span>
                <span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = args[</span><span class="s2">&quot;color&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s1">var_name</span>
            <span class="s0">if </span><span class="s2">&quot;line_group&quot; </span><span class="s0">in </span><span class="s1">args:</span>
                <span class="s1">args[</span><span class="s2">&quot;line_group&quot;</span><span class="s1">] = args[</span><span class="s2">&quot;line_group&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s1">var_name</span>
        <span class="s0">elif </span><span class="s1">constructor == go.Bar:</span>
            <span class="s0">if </span><span class="s1">_is_continuous(df_output</span><span class="s0">, </span><span class="s1">value_name):</span>
                <span class="s1">args[</span><span class="s2">&quot;x&quot; </span><span class="s0">if </span><span class="s1">orient_v </span><span class="s0">else </span><span class="s2">&quot;y&quot;</span><span class="s1">] = wide_cross_name</span>
                <span class="s1">args[</span><span class="s2">&quot;y&quot; </span><span class="s0">if </span><span class="s1">orient_v </span><span class="s0">else </span><span class="s2">&quot;x&quot;</span><span class="s1">] = value_name</span>
                <span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = args[</span><span class="s2">&quot;color&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s1">var_name</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">args[</span><span class="s2">&quot;x&quot; </span><span class="s0">if </span><span class="s1">orient_v </span><span class="s0">else </span><span class="s2">&quot;y&quot;</span><span class="s1">] = value_name</span>
                <span class="s1">args[</span><span class="s2">&quot;y&quot; </span><span class="s0">if </span><span class="s1">orient_v </span><span class="s0">else </span><span class="s2">&quot;x&quot;</span><span class="s1">] = count_name</span>
                <span class="s1">df_output[count_name] = </span><span class="s4">1</span>
                <span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = args[</span><span class="s2">&quot;color&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s1">var_name</span>
        <span class="s0">elif </span><span class="s1">constructor </span><span class="s0">in </span><span class="s1">[go.Violin</span><span class="s0">, </span><span class="s1">go.Box]:</span>
            <span class="s1">args[</span><span class="s2">&quot;x&quot; </span><span class="s0">if </span><span class="s1">orient_v </span><span class="s0">else </span><span class="s2">&quot;y&quot;</span><span class="s1">] = wide_cross_name </span><span class="s0">or </span><span class="s1">var_name</span>
            <span class="s1">args[</span><span class="s2">&quot;y&quot; </span><span class="s0">if </span><span class="s1">orient_v </span><span class="s0">else </span><span class="s2">&quot;x&quot;</span><span class="s1">] = value_name</span>

    <span class="s0">if </span><span class="s1">hist1d_orientation </span><span class="s0">and </span><span class="s1">constructor == go.Scatter:</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;x&quot;</span><span class="s1">] </span><span class="s0">is not None and </span><span class="s1">args[</span><span class="s2">&quot;y&quot;</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">args[</span><span class="s2">&quot;histfunc&quot;</span><span class="s1">] = </span><span class="s2">&quot;sum&quot;</span>
        <span class="s0">elif </span><span class="s1">args[</span><span class="s2">&quot;x&quot;</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">args[</span><span class="s2">&quot;histfunc&quot;</span><span class="s1">] = </span><span class="s0">None</span>
            <span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] = </span><span class="s2">&quot;h&quot;</span>
            <span class="s1">args[</span><span class="s2">&quot;x&quot;</span><span class="s1">] = count_name</span>
            <span class="s1">df_output[count_name] = </span><span class="s4">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">args[</span><span class="s2">&quot;histfunc&quot;</span><span class="s1">] = </span><span class="s0">None</span>
            <span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] = </span><span class="s2">&quot;v&quot;</span>
            <span class="s1">args[</span><span class="s2">&quot;y&quot;</span><span class="s1">] = count_name</span>
            <span class="s1">df_output[count_name] = </span><span class="s4">1</span>

    <span class="s0">if </span><span class="s1">no_color:</span>
        <span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = </span><span class="s0">None</span>
    <span class="s1">args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">] = df_output</span>
    <span class="s0">return </span><span class="s1">args</span>


<span class="s0">def </span><span class="s1">_check_dataframe_all_leaves(df):</span>
    <span class="s1">df_sorted = df.sort_values(by=list(df.columns))</span>
    <span class="s1">null_mask = df_sorted.isnull()</span>
    <span class="s1">df_sorted = df_sorted.astype(str)</span>
    <span class="s1">null_indices = np.nonzero(null_mask.any(axis=</span><span class="s4">1</span><span class="s1">).values)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s0">for </span><span class="s1">null_row_index </span><span class="s0">in </span><span class="s1">null_indices:</span>
        <span class="s1">row = null_mask.iloc[null_row_index]</span>
        <span class="s1">i = np.nonzero(row.values)[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">if not </span><span class="s1">row[i:].all():</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;None entries cannot have not-None children&quot;</span><span class="s0">,</span>
                <span class="s1">df_sorted.iloc[null_row_index]</span><span class="s0">,</span>
            <span class="s1">)</span>
    <span class="s1">df_sorted[null_mask] = </span><span class="s2">&quot;&quot;</span>
    <span class="s1">row_strings = list(df_sorted.apply(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;&quot;</span><span class="s1">.join(x)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">))</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">row </span><span class="s0">in </span><span class="s1">enumerate(row_strings[:-</span><span class="s4">1</span><span class="s1">]):</span>
        <span class="s0">if </span><span class="s1">row_strings[i + </span><span class="s4">1</span><span class="s1">] </span><span class="s0">in </span><span class="s1">row </span><span class="s0">and </span><span class="s1">(i + </span><span class="s4">1</span><span class="s1">) </span><span class="s0">in </span><span class="s1">null_indices:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;Non-leaves rows are not permitted in the dataframe </span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s0">,</span>
                <span class="s1">df_sorted.iloc[i + </span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;is not a leaf.&quot;</span><span class="s0">,</span>
            <span class="s1">)</span>


<span class="s0">def </span><span class="s1">process_dataframe_hierarchy(args):</span>
    <span class="s5">&quot;&quot;&quot; 
    Build dataframe for sunburst, treemap, or icicle when the path argument is provided. 
    &quot;&quot;&quot;</span>
    <span class="s1">df = args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">]</span>
    <span class="s1">path = args[</span><span class="s2">&quot;path&quot;</span><span class="s1">][::-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">_check_dataframe_all_leaves(df[path[::-</span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">discrete_color = </span><span class="s0">False</span>

    <span class="s1">new_path = []</span>
    <span class="s0">for </span><span class="s1">col_name </span><span class="s0">in </span><span class="s1">path:</span>
        <span class="s1">new_col_name = col_name + </span><span class="s2">&quot;_path_copy&quot;</span>
        <span class="s1">new_path.append(new_col_name)</span>
        <span class="s1">df[new_col_name] = df[col_name]</span>
    <span class="s1">path = new_path</span>
    <span class="s3"># ------------ Define aggregation functions --------------------------------</span>

    <span class="s0">def </span><span class="s1">aggfunc_discrete(x):</span>
        <span class="s1">uniques = x.unique()</span>
        <span class="s0">if </span><span class="s1">len(uniques) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">uniques[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s2">&quot;(?)&quot;</span>

    <span class="s1">agg_f = {}</span>
    <span class="s1">aggfunc_color = </span><span class="s0">None</span>
    <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;values&quot;</span><span class="s1">]:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">df[args[</span><span class="s2">&quot;values&quot;</span><span class="s1">]] = pd.to_numeric(df[args[</span><span class="s2">&quot;values&quot;</span><span class="s1">]])</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;Column `%s` of `df` could not be converted to a numerical data type.&quot;</span>
                <span class="s1">% args[</span><span class="s2">&quot;values&quot;</span><span class="s1">]</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">]:</span>
            <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">] == args[</span><span class="s2">&quot;values&quot;</span><span class="s1">]:</span>
                <span class="s1">new_value_col_name = args[</span><span class="s2">&quot;values&quot;</span><span class="s1">] + </span><span class="s2">&quot;_sum&quot;</span>
                <span class="s1">df[new_value_col_name] = df[args[</span><span class="s2">&quot;values&quot;</span><span class="s1">]]</span>
                <span class="s1">args[</span><span class="s2">&quot;values&quot;</span><span class="s1">] = new_value_col_name</span>
        <span class="s1">count_colname = args[</span><span class="s2">&quot;values&quot;</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s3"># we need a count column for the first groupby and the weighted mean of color</span>
        <span class="s3"># trick to be sure the col name is unused: take the sum of existing names</span>
        <span class="s1">count_colname = (</span>
            <span class="s2">&quot;count&quot;</span>
            <span class="s0">if </span><span class="s2">&quot;count&quot; </span><span class="s0">not in </span><span class="s1">df.columns</span>
            <span class="s0">else </span><span class="s2">&quot;&quot;</span><span class="s1">.join([str(el) </span><span class="s0">for </span><span class="s1">el </span><span class="s0">in </span><span class="s1">list(df.columns)])</span>
        <span class="s1">)</span>
        <span class="s3"># we can modify df because it's a copy of the px argument</span>
        <span class="s1">df[count_colname] = </span><span class="s4">1</span>
        <span class="s1">args[</span><span class="s2">&quot;values&quot;</span><span class="s1">] = count_colname</span>
    <span class="s1">agg_f[count_colname] = </span><span class="s2">&quot;sum&quot;</span>

    <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">]:</span>
        <span class="s0">if not </span><span class="s1">_is_continuous(df</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">]):</span>
            <span class="s1">aggfunc_color = aggfunc_discrete</span>
            <span class="s1">discrete_color = </span><span class="s0">True</span>
        <span class="s0">else</span><span class="s1">:</span>

            <span class="s0">def </span><span class="s1">aggfunc_continuous(x):</span>
                <span class="s0">return </span><span class="s1">np.average(x</span><span class="s0">, </span><span class="s1">weights=df.loc[x.index</span><span class="s0">, </span><span class="s1">count_colname])</span>

            <span class="s1">aggfunc_color = aggfunc_continuous</span>
        <span class="s1">agg_f[args[</span><span class="s2">&quot;color&quot;</span><span class="s1">]] = aggfunc_color</span>

    <span class="s3">#  Other columns (for color, hover_data, custom_data etc.)</span>
    <span class="s1">cols = list(set(df.columns).difference(path))</span>
    <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">cols:  </span><span class="s3"># for hover_data, custom_data etc.</span>
        <span class="s0">if </span><span class="s1">col </span><span class="s0">not in </span><span class="s1">agg_f:</span>
            <span class="s1">agg_f[col] = aggfunc_discrete</span>
    <span class="s3"># Avoid collisions with reserved names - columns in the path have been copied already</span>
    <span class="s1">cols = list(set(cols) - set([</span><span class="s2">&quot;labels&quot;</span><span class="s0">, </span><span class="s2">&quot;parent&quot;</span><span class="s0">, </span><span class="s2">&quot;id&quot;</span><span class="s1">]))</span>
    <span class="s3"># ----------------------------------------------------------------------------</span>
    <span class="s1">df_all_trees = pd.DataFrame(columns=[</span><span class="s2">&quot;labels&quot;</span><span class="s0">, </span><span class="s2">&quot;parent&quot;</span><span class="s0">, </span><span class="s2">&quot;id&quot;</span><span class="s1">] + cols)</span>
    <span class="s3">#  Set column type here (useful for continuous vs discrete colorscale)</span>
    <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">cols:</span>
        <span class="s1">df_all_trees[col] = df_all_trees[col].astype(df[col].dtype)</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">level </span><span class="s0">in </span><span class="s1">enumerate(path):</span>
        <span class="s1">df_tree = pd.DataFrame(columns=df_all_trees.columns)</span>
        <span class="s1">dfg = df.groupby(path[i:]).agg(agg_f)</span>
        <span class="s1">dfg = dfg.reset_index()</span>
        <span class="s3"># Path label massaging</span>
        <span class="s1">df_tree[</span><span class="s2">&quot;labels&quot;</span><span class="s1">] = dfg[level].copy().astype(str)</span>
        <span class="s1">df_tree[</span><span class="s2">&quot;parent&quot;</span><span class="s1">] = </span><span class="s2">&quot;&quot;</span>
        <span class="s1">df_tree[</span><span class="s2">&quot;id&quot;</span><span class="s1">] = dfg[level].copy().astype(str)</span>
        <span class="s0">if </span><span class="s1">i &lt; len(path) - </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">j = i + </span><span class="s4">1</span>
            <span class="s0">while </span><span class="s1">j &lt; len(path):</span>
                <span class="s1">df_tree[</span><span class="s2">&quot;parent&quot;</span><span class="s1">] = (</span>
                    <span class="s1">dfg[path[j]].copy().astype(str) + </span><span class="s2">&quot;/&quot; </span><span class="s1">+ df_tree[</span><span class="s2">&quot;parent&quot;</span><span class="s1">]</span>
                <span class="s1">)</span>
                <span class="s1">df_tree[</span><span class="s2">&quot;id&quot;</span><span class="s1">] = dfg[path[j]].copy().astype(str) + </span><span class="s2">&quot;/&quot; </span><span class="s1">+ df_tree[</span><span class="s2">&quot;id&quot;</span><span class="s1">]</span>
                <span class="s1">j += </span><span class="s4">1</span>

        <span class="s1">df_tree[</span><span class="s2">&quot;parent&quot;</span><span class="s1">] = df_tree[</span><span class="s2">&quot;parent&quot;</span><span class="s1">].str.rstrip(</span><span class="s2">&quot;/&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">cols:</span>
            <span class="s1">df_tree[cols] = dfg[cols]</span>
        <span class="s1">df_all_trees = df_all_trees.append(df_tree</span><span class="s0">, </span><span class="s1">ignore_index=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s3"># we want to make sure than (?) is the first color of the sequence</span>
    <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">] </span><span class="s0">and </span><span class="s1">discrete_color:</span>
        <span class="s1">sort_col_name = </span><span class="s2">&quot;sort_color_if_discrete_color&quot;</span>
        <span class="s0">while </span><span class="s1">sort_col_name </span><span class="s0">in </span><span class="s1">df_all_trees.columns:</span>
            <span class="s1">sort_col_name += </span><span class="s2">&quot;0&quot;</span>
        <span class="s1">df_all_trees[sort_col_name] = df[args[</span><span class="s2">&quot;color&quot;</span><span class="s1">]].astype(str)</span>
        <span class="s1">df_all_trees = df_all_trees.sort_values(by=sort_col_name)</span>

    <span class="s3"># Now modify arguments</span>
    <span class="s1">args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">] = df_all_trees</span>
    <span class="s1">args[</span><span class="s2">&quot;path&quot;</span><span class="s1">] = </span><span class="s0">None</span>
    <span class="s1">args[</span><span class="s2">&quot;ids&quot;</span><span class="s1">] = </span><span class="s2">&quot;id&quot;</span>
    <span class="s1">args[</span><span class="s2">&quot;names&quot;</span><span class="s1">] = </span><span class="s2">&quot;labels&quot;</span>
    <span class="s1">args[</span><span class="s2">&quot;parents&quot;</span><span class="s1">] = </span><span class="s2">&quot;parent&quot;</span>
    <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">]:</span>
        <span class="s0">if not </span><span class="s1">args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">]:</span>
            <span class="s1">args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">] = [args[</span><span class="s2">&quot;color&quot;</span><span class="s1">]]</span>
        <span class="s0">elif </span><span class="s1">isinstance(args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dict):</span>
            <span class="s0">if not </span><span class="s1">args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">].get(args[</span><span class="s2">&quot;color&quot;</span><span class="s1">]):</span>
                <span class="s1">args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">][args[</span><span class="s2">&quot;color&quot;</span><span class="s1">]] = (</span><span class="s0">True, None</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">].append(args[</span><span class="s2">&quot;color&quot;</span><span class="s1">])</span>
    <span class="s0">return </span><span class="s1">args</span>


<span class="s0">def </span><span class="s1">process_dataframe_timeline(args):</span>
    <span class="s5">&quot;&quot;&quot; 
    Massage input for bar traces for px.timeline() 
    &quot;&quot;&quot;</span>
    <span class="s1">args[</span><span class="s2">&quot;is_timeline&quot;</span><span class="s1">] = </span><span class="s0">True</span>
    <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;x_start&quot;</span><span class="s1">] </span><span class="s0">is None or </span><span class="s1">args[</span><span class="s2">&quot;x_end&quot;</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Both x_start and x_end are required&quot;</span><span class="s1">)</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">x_start = pd.to_datetime(args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">][args[</span><span class="s2">&quot;x_start&quot;</span><span class="s1">]])</span>
        <span class="s1">x_end = pd.to_datetime(args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">][args[</span><span class="s2">&quot;x_end&quot;</span><span class="s1">]])</span>
    <span class="s0">except </span><span class="s1">(ValueError</span><span class="s0">, </span><span class="s1">TypeError):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span>
            <span class="s2">&quot;Both x_start and x_end must refer to data convertible to datetimes.&quot;</span>
        <span class="s1">)</span>

    <span class="s3"># note that we are not adding any columns to the data frame here, so no risk of overwrite</span>
    <span class="s1">args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">][args[</span><span class="s2">&quot;x_end&quot;</span><span class="s1">]] = (x_end - x_start).astype(</span><span class="s2">&quot;timedelta64[ms]&quot;</span><span class="s1">)</span>
    <span class="s1">args[</span><span class="s2">&quot;x&quot;</span><span class="s1">] = args[</span><span class="s2">&quot;x_end&quot;</span><span class="s1">]</span>
    <span class="s0">del </span><span class="s1">args[</span><span class="s2">&quot;x_end&quot;</span><span class="s1">]</span>
    <span class="s1">args[</span><span class="s2">&quot;base&quot;</span><span class="s1">] = args[</span><span class="s2">&quot;x_start&quot;</span><span class="s1">]</span>
    <span class="s0">del </span><span class="s1">args[</span><span class="s2">&quot;x_start&quot;</span><span class="s1">]</span>
    <span class="s0">return </span><span class="s1">args</span>


<span class="s0">def </span><span class="s1">infer_config(args</span><span class="s0">, </span><span class="s1">constructor</span><span class="s0">, </span><span class="s1">trace_patch</span><span class="s0">, </span><span class="s1">layout_patch):</span>
    <span class="s1">attrs = [k </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">direct_attrables + array_attrables </span><span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">args]</span>
    <span class="s1">grouped_attrs = []</span>

    <span class="s3"># Compute sizeref</span>
    <span class="s1">sizeref = </span><span class="s4">0</span>
    <span class="s0">if </span><span class="s2">&quot;size&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;size&quot;</span><span class="s1">]:</span>
        <span class="s1">sizeref = args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">][args[</span><span class="s2">&quot;size&quot;</span><span class="s1">]].max() / args[</span><span class="s2">&quot;size_max&quot;</span><span class="s1">] ** </span><span class="s4">2</span>

    <span class="s3"># Compute color attributes and grouping attributes</span>
    <span class="s0">if </span><span class="s2">&quot;color&quot; </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s0">if </span><span class="s2">&quot;color_continuous_scale&quot; </span><span class="s0">in </span><span class="s1">args:</span>
            <span class="s0">if </span><span class="s2">&quot;color_discrete_sequence&quot; </span><span class="s0">not in </span><span class="s1">args:</span>
                <span class="s1">attrs.append(</span><span class="s2">&quot;color&quot;</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">] </span><span class="s0">and </span><span class="s1">_is_continuous(args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">]):</span>
                    <span class="s1">attrs.append(</span><span class="s2">&quot;color&quot;</span><span class="s1">)</span>
                    <span class="s1">args[</span><span class="s2">&quot;color_is_continuous&quot;</span><span class="s1">] = </span><span class="s0">True</span>
                <span class="s0">elif </span><span class="s1">constructor </span><span class="s0">in </span><span class="s1">[go.Sunburst</span><span class="s0">, </span><span class="s1">go.Treemap</span><span class="s0">, </span><span class="s1">go.Icicle]:</span>
                    <span class="s1">attrs.append(</span><span class="s2">&quot;color&quot;</span><span class="s1">)</span>
                    <span class="s1">args[</span><span class="s2">&quot;color_is_continuous&quot;</span><span class="s1">] = </span><span class="s0">False</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">grouped_attrs.append(</span><span class="s2">&quot;marker.color&quot;</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s2">&quot;line_group&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">or </span><span class="s1">constructor == go.Histogram2dContour:</span>
            <span class="s1">grouped_attrs.append(</span><span class="s2">&quot;line.color&quot;</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">constructor </span><span class="s0">in </span><span class="s1">[go.Pie</span><span class="s0">, </span><span class="s1">go.Funnelarea]:</span>
            <span class="s1">attrs.append(</span><span class="s2">&quot;color&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">]:</span>
                <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">] = []</span>
                <span class="s1">args[</span><span class="s2">&quot;hover_data&quot;</span><span class="s1">].append(args[</span><span class="s2">&quot;color&quot;</span><span class="s1">])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">grouped_attrs.append(</span><span class="s2">&quot;marker.color&quot;</span><span class="s1">)</span>

        <span class="s1">show_colorbar = bool(</span>
            <span class="s2">&quot;color&quot; </span><span class="s0">in </span><span class="s1">attrs</span>
            <span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">]</span>
            <span class="s0">and </span><span class="s1">constructor </span><span class="s0">not in </span><span class="s1">[go.Pie</span><span class="s0">, </span><span class="s1">go.Funnelarea]</span>
            <span class="s0">and </span><span class="s1">(</span>
                <span class="s1">constructor </span><span class="s0">not in </span><span class="s1">[go.Treemap</span><span class="s0">, </span><span class="s1">go.Sunburst</span><span class="s0">, </span><span class="s1">go.Icicle]</span>
                <span class="s0">or </span><span class="s1">args.get(</span><span class="s2">&quot;color_is_continuous&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">show_colorbar = </span><span class="s0">False</span>

    <span class="s0">if </span><span class="s2">&quot;line_dash&quot; </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s1">grouped_attrs.append(</span><span class="s2">&quot;line.dash&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s2">&quot;symbol&quot; </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s1">grouped_attrs.append(</span><span class="s2">&quot;marker.symbol&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s2">&quot;pattern_shape&quot; </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s1">grouped_attrs.append(</span><span class="s2">&quot;marker.pattern.shape&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s2">&quot;orientation&quot; </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s1">has_x = args[</span><span class="s2">&quot;x&quot;</span><span class="s1">] </span><span class="s0">is not None</span>
        <span class="s1">has_y = args[</span><span class="s2">&quot;y&quot;</span><span class="s1">] </span><span class="s0">is not None</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">constructor </span><span class="s0">in </span><span class="s1">[go.Histogram</span><span class="s0">, </span><span class="s1">go.Scatter]:</span>
                <span class="s0">if </span><span class="s1">has_y </span><span class="s0">and not </span><span class="s1">has_x:</span>
                    <span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] = </span><span class="s2">&quot;h&quot;</span>
            <span class="s0">elif </span><span class="s1">constructor </span><span class="s0">in </span><span class="s1">[go.Violin</span><span class="s0">, </span><span class="s1">go.Box</span><span class="s0">, </span><span class="s1">go.Bar</span><span class="s0">, </span><span class="s1">go.Funnel]:</span>
                <span class="s0">if </span><span class="s1">has_x </span><span class="s0">and not </span><span class="s1">has_y:</span>
                    <span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] = </span><span class="s2">&quot;h&quot;</span>

        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] </span><span class="s0">is None and </span><span class="s1">has_x </span><span class="s0">and </span><span class="s1">has_y:</span>
            <span class="s1">x_is_continuous = _is_continuous(args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;x&quot;</span><span class="s1">])</span>
            <span class="s1">y_is_continuous = _is_continuous(args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;y&quot;</span><span class="s1">])</span>
            <span class="s0">if </span><span class="s1">x_is_continuous </span><span class="s0">and not </span><span class="s1">y_is_continuous:</span>
                <span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] = </span><span class="s2">&quot;h&quot;</span>
            <span class="s0">if </span><span class="s1">y_is_continuous </span><span class="s0">and not </span><span class="s1">x_is_continuous:</span>
                <span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] = </span><span class="s2">&quot;v&quot;</span>

        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] = </span><span class="s2">&quot;v&quot;</span>

        <span class="s0">if </span><span class="s1">constructor == go.Histogram:</span>
            <span class="s0">if </span><span class="s1">has_x </span><span class="s0">and </span><span class="s1">has_y </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;histfunc&quot;</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">args[</span><span class="s2">&quot;histfunc&quot;</span><span class="s1">] = trace_patch[</span><span class="s2">&quot;histfunc&quot;</span><span class="s1">] = </span><span class="s2">&quot;sum&quot;</span>

            <span class="s1">orientation = args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">]</span>
            <span class="s1">nbins = args[</span><span class="s2">&quot;nbins&quot;</span><span class="s1">]</span>
            <span class="s1">trace_patch[</span><span class="s2">&quot;nbinsx&quot;</span><span class="s1">] = nbins </span><span class="s0">if </span><span class="s1">orientation == </span><span class="s2">&quot;v&quot; </span><span class="s0">else None</span>
            <span class="s1">trace_patch[</span><span class="s2">&quot;nbinsy&quot;</span><span class="s1">] = </span><span class="s0">None if </span><span class="s1">orientation == </span><span class="s2">&quot;v&quot; </span><span class="s0">else </span><span class="s1">nbins</span>
            <span class="s1">trace_patch[</span><span class="s2">&quot;bingroup&quot;</span><span class="s1">] = </span><span class="s2">&quot;x&quot; </span><span class="s0">if </span><span class="s1">orientation == </span><span class="s2">&quot;v&quot; </span><span class="s0">else </span><span class="s2">&quot;y&quot;</span>
        <span class="s1">trace_patch[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] = args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">constructor </span><span class="s0">in </span><span class="s1">[go.Violin</span><span class="s0">, </span><span class="s1">go.Box]:</span>
            <span class="s1">mode = </span><span class="s2">&quot;boxmode&quot; </span><span class="s0">if </span><span class="s1">constructor == go.Box </span><span class="s0">else </span><span class="s2">&quot;violinmode&quot;</span>
            <span class="s0">if </span><span class="s1">layout_patch[mode] </span><span class="s0">is None and </span><span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;y&quot;</span><span class="s1">] == args[</span><span class="s2">&quot;color&quot;</span><span class="s1">] </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] == </span><span class="s2">&quot;h&quot;</span><span class="s1">:</span>
                    <span class="s1">layout_patch[mode] = </span><span class="s2">&quot;overlay&quot;</span>
                <span class="s0">elif </span><span class="s1">args[</span><span class="s2">&quot;x&quot;</span><span class="s1">] == args[</span><span class="s2">&quot;color&quot;</span><span class="s1">] </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] == </span><span class="s2">&quot;v&quot;</span><span class="s1">:</span>
                    <span class="s1">layout_patch[mode] = </span><span class="s2">&quot;overlay&quot;</span>
            <span class="s0">if </span><span class="s1">layout_patch[mode] </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">layout_patch[mode] = </span><span class="s2">&quot;group&quot;</span>

    <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">constructor == go.Histogram2d</span>
        <span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;z&quot;</span><span class="s1">] </span><span class="s0">is not None</span>
        <span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;histfunc&quot;</span><span class="s1">] </span><span class="s0">is None</span>
    <span class="s1">):</span>
        <span class="s1">args[</span><span class="s2">&quot;histfunc&quot;</span><span class="s1">] = trace_patch[</span><span class="s2">&quot;histfunc&quot;</span><span class="s1">] = </span><span class="s2">&quot;sum&quot;</span>

    <span class="s0">if </span><span class="s1">args.get(</span><span class="s2">&quot;text_auto&quot;</span><span class="s0">, False</span><span class="s1">) </span><span class="s0">is not False</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">constructor </span><span class="s0">in </span><span class="s1">[go.Histogram2d</span><span class="s0">, </span><span class="s1">go.Histogram2dContour]:</span>
            <span class="s1">letter = </span><span class="s2">&quot;z&quot;</span>
        <span class="s0">elif </span><span class="s1">constructor == go.Bar:</span>
            <span class="s1">letter = </span><span class="s2">&quot;y&quot; </span><span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] == </span><span class="s2">&quot;v&quot; </span><span class="s0">else </span><span class="s2">&quot;x&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">letter = </span><span class="s2">&quot;value&quot;</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;text_auto&quot;</span><span class="s1">] </span><span class="s0">is True</span><span class="s1">:</span>
            <span class="s1">trace_patch[</span><span class="s2">&quot;texttemplate&quot;</span><span class="s1">] = </span><span class="s2">&quot;%{&quot; </span><span class="s1">+ letter + </span><span class="s2">&quot;}&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">trace_patch[</span><span class="s2">&quot;texttemplate&quot;</span><span class="s1">] = </span><span class="s2">&quot;%{&quot; </span><span class="s1">+ letter + </span><span class="s2">&quot;:&quot; </span><span class="s1">+ args[</span><span class="s2">&quot;text_auto&quot;</span><span class="s1">] + </span><span class="s2">&quot;}&quot;</span>

    <span class="s0">if </span><span class="s1">constructor </span><span class="s0">in </span><span class="s1">[go.Histogram2d</span><span class="s0">, </span><span class="s1">go.Densitymapbox]:</span>
        <span class="s1">show_colorbar = </span><span class="s0">True</span>
        <span class="s1">trace_patch[</span><span class="s2">&quot;coloraxis&quot;</span><span class="s1">] = </span><span class="s2">&quot;coloraxis1&quot;</span>

    <span class="s0">if </span><span class="s2">&quot;opacity&quot; </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;opacity&quot;</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s2">&quot;barmode&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;barmode&quot;</span><span class="s1">] == </span><span class="s2">&quot;overlay&quot;</span><span class="s1">:</span>
                <span class="s1">trace_patch[</span><span class="s2">&quot;marker&quot;</span><span class="s1">] = dict(opacity=</span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">constructor </span><span class="s0">in </span><span class="s1">[go.Densitymapbox</span><span class="s0">, </span><span class="s1">go.Pie</span><span class="s0">, </span><span class="s1">go.Funnel</span><span class="s0">, </span><span class="s1">go.Funnelarea]:</span>
            <span class="s1">trace_patch[</span><span class="s2">&quot;opacity&quot;</span><span class="s1">] = args[</span><span class="s2">&quot;opacity&quot;</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">trace_patch[</span><span class="s2">&quot;marker&quot;</span><span class="s1">] = dict(opacity=args[</span><span class="s2">&quot;opacity&quot;</span><span class="s1">])</span>
    <span class="s0">if </span><span class="s1">(</span>
        <span class="s2">&quot;line_group&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">or </span><span class="s2">&quot;line_dash&quot; </span><span class="s0">in </span><span class="s1">args</span>
    <span class="s1">):  </span><span class="s3"># px.line, px.line_*, px.area, px.ecdf</span>
        <span class="s1">modes = set()</span>
        <span class="s0">if </span><span class="s1">args.get(</span><span class="s2">&quot;lines&quot;</span><span class="s0">, True</span><span class="s1">):</span>
            <span class="s1">modes.add(</span><span class="s2">&quot;lines&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">args.get(</span><span class="s2">&quot;text&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s1">args.get(</span><span class="s2">&quot;symbol&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s1">args.get(</span><span class="s2">&quot;markers&quot;</span><span class="s1">):</span>
            <span class="s1">modes.add(</span><span class="s2">&quot;markers&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">args.get(</span><span class="s2">&quot;text&quot;</span><span class="s1">):</span>
            <span class="s1">modes.add(</span><span class="s2">&quot;text&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">len(modes) == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">modes.add(</span><span class="s2">&quot;lines&quot;</span><span class="s1">)</span>
        <span class="s1">trace_patch[</span><span class="s2">&quot;mode&quot;</span><span class="s1">] = </span><span class="s2">&quot;+&quot;</span><span class="s1">.join(modes)</span>
    <span class="s0">elif </span><span class="s1">constructor != go.Splom </span><span class="s0">and </span><span class="s1">(</span>
        <span class="s2">&quot;symbol&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">or </span><span class="s1">constructor == go.Scattermapbox</span>
    <span class="s1">):</span>
        <span class="s1">trace_patch[</span><span class="s2">&quot;mode&quot;</span><span class="s1">] = </span><span class="s2">&quot;markers&quot; </span><span class="s1">+ (</span><span class="s2">&quot;+text&quot; </span><span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;text&quot;</span><span class="s1">] </span><span class="s0">else </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s2">&quot;line_shape&quot; </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s1">trace_patch[</span><span class="s2">&quot;line&quot;</span><span class="s1">] = dict(shape=args[</span><span class="s2">&quot;line_shape&quot;</span><span class="s1">])</span>
    <span class="s0">elif </span><span class="s2">&quot;ecdfmode&quot; </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s1">trace_patch[</span><span class="s2">&quot;line&quot;</span><span class="s1">] = dict(</span>
            <span class="s1">shape=</span><span class="s2">&quot;vh&quot; </span><span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;ecdfmode&quot;</span><span class="s1">] == </span><span class="s2">&quot;reversed&quot; </span><span class="s0">else </span><span class="s2">&quot;hv&quot;</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s2">&quot;geojson&quot; </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s1">trace_patch[</span><span class="s2">&quot;featureidkey&quot;</span><span class="s1">] = args[</span><span class="s2">&quot;featureidkey&quot;</span><span class="s1">]</span>
        <span class="s1">trace_patch[</span><span class="s2">&quot;geojson&quot;</span><span class="s1">] = (</span>
            <span class="s1">args[</span><span class="s2">&quot;geojson&quot;</span><span class="s1">]</span>
            <span class="s0">if not </span><span class="s1">hasattr(args[</span><span class="s2">&quot;geojson&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;__geo_interface__&quot;</span><span class="s1">)  </span><span class="s3"># for geopandas</span>
            <span class="s0">else </span><span class="s1">args[</span><span class="s2">&quot;geojson&quot;</span><span class="s1">].__geo_interface__</span>
        <span class="s1">)</span>

    <span class="s3"># Compute marginal attribute: copy to appropriate marginal_*</span>
    <span class="s0">if </span><span class="s2">&quot;marginal&quot; </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s1">position = </span><span class="s2">&quot;marginal_x&quot; </span><span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] == </span><span class="s2">&quot;v&quot; </span><span class="s0">else </span><span class="s2">&quot;marginal_y&quot;</span>
        <span class="s1">other_position = </span><span class="s2">&quot;marginal_x&quot; </span><span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] == </span><span class="s2">&quot;h&quot; </span><span class="s0">else </span><span class="s2">&quot;marginal_y&quot;</span>
        <span class="s1">args[position] = args[</span><span class="s2">&quot;marginal&quot;</span><span class="s1">]</span>
        <span class="s1">args[other_position] = </span><span class="s0">None</span>

    <span class="s3"># If both marginals and faceting are specified, faceting wins</span>
    <span class="s0">if </span><span class="s1">args.get(</span><span class="s2">&quot;facet_col&quot;</span><span class="s1">) </span><span class="s0">is not None and </span><span class="s1">args.get(</span><span class="s2">&quot;marginal_y&quot;</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">args[</span><span class="s2">&quot;marginal_y&quot;</span><span class="s1">] = </span><span class="s0">None</span>

    <span class="s0">if </span><span class="s1">args.get(</span><span class="s2">&quot;facet_row&quot;</span><span class="s1">) </span><span class="s0">is not None and </span><span class="s1">args.get(</span><span class="s2">&quot;marginal_x&quot;</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">args[</span><span class="s2">&quot;marginal_x&quot;</span><span class="s1">] = </span><span class="s0">None</span>

    <span class="s3"># facet_col_wrap only works if no marginals or row faceting is used</span>
    <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">args.get(</span><span class="s2">&quot;marginal_x&quot;</span><span class="s1">) </span><span class="s0">is not None</span>
        <span class="s0">or </span><span class="s1">args.get(</span><span class="s2">&quot;marginal_y&quot;</span><span class="s1">) </span><span class="s0">is not None</span>
        <span class="s0">or </span><span class="s1">args.get(</span><span class="s2">&quot;facet_row&quot;</span><span class="s1">) </span><span class="s0">is not None</span>
    <span class="s1">):</span>
        <span class="s1">args[</span><span class="s2">&quot;facet_col_wrap&quot;</span><span class="s1">] = </span><span class="s4">0</span>

    <span class="s0">if </span><span class="s2">&quot;trendline&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;trendline&quot;</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;trendline&quot;</span><span class="s1">] </span><span class="s0">not in </span><span class="s1">trendline_functions:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;Value '%s' for `trendline` must be one of %s&quot;</span>
                <span class="s1">% (args[</span><span class="s2">&quot;trendline&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">trendline_functions.keys())</span>
            <span class="s1">)</span>

    <span class="s0">if </span><span class="s2">&quot;trendline_options&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;trendline_options&quot;</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">args[</span><span class="s2">&quot;trendline_options&quot;</span><span class="s1">] = dict()</span>

    <span class="s0">if </span><span class="s2">&quot;ecdfnorm&quot; </span><span class="s0">in </span><span class="s1">args:</span>
        <span class="s0">if </span><span class="s1">args.get(</span><span class="s2">&quot;ecdfnorm&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">not in </span><span class="s1">[</span><span class="s0">None, </span><span class="s2">&quot;percent&quot;</span><span class="s0">, </span><span class="s2">&quot;probability&quot;</span><span class="s1">]:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;`ecdfnorm` must be one of None, 'percent' or 'probability'. &quot;</span>
                <span class="s1">+ </span><span class="s2">&quot;'%s' was provided.&quot; </span><span class="s1">% args[</span><span class="s2">&quot;ecdfnorm&quot;</span><span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s1">args[</span><span class="s2">&quot;histnorm&quot;</span><span class="s1">] = args[</span><span class="s2">&quot;ecdfnorm&quot;</span><span class="s1">]</span>

    <span class="s3"># Compute applicable grouping attributes</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">group_attrables:</span>
        <span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">args:</span>
            <span class="s1">grouped_attrs.append(k)</span>

    <span class="s3"># Create grouped mappings</span>
    <span class="s1">grouped_mappings = [make_mapping(args</span><span class="s0">, </span><span class="s1">a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">grouped_attrs]</span>

    <span class="s3"># Create trace specs</span>
    <span class="s1">trace_specs = make_trace_spec(args</span><span class="s0">, </span><span class="s1">constructor</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">trace_patch)</span>
    <span class="s0">return </span><span class="s1">trace_specs</span><span class="s0">, </span><span class="s1">grouped_mappings</span><span class="s0">, </span><span class="s1">sizeref</span><span class="s0">, </span><span class="s1">show_colorbar</span>


<span class="s0">def </span><span class="s1">get_orderings(args</span><span class="s0">, </span><span class="s1">grouper</span><span class="s0">, </span><span class="s1">grouped):</span>
    <span class="s5">&quot;&quot;&quot; 
    `orders` is the user-supplied ordering with the remaining data-frame-supplied 
    ordering appended if the column is used for grouping. It includes anything the user 
    gave, for any variable, including values not present in the dataset. It's a dict 
    where the keys are e.g. &quot;x&quot; or &quot;color&quot; 
 
    `sorted_group_names` is the set of groups, ordered by the order above. It's a list 
    of tuples like [(&quot;value1&quot;, &quot;&quot;), (&quot;value2&quot;, &quot;&quot;)] where each tuple contains the name 
    of a single dimension-group 
    &quot;&quot;&quot;</span>

    <span class="s1">orders = {} </span><span class="s0">if </span><span class="s2">&quot;category_orders&quot; </span><span class="s0">not in </span><span class="s1">args </span><span class="s0">else </span><span class="s1">args[</span><span class="s2">&quot;category_orders&quot;</span><span class="s1">].copy()</span>
    <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">grouper:</span>
        <span class="s0">if </span><span class="s1">col != one_group:</span>
            <span class="s1">uniques = list(args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">][col].unique())</span>
            <span class="s0">if </span><span class="s1">col </span><span class="s0">not in </span><span class="s1">orders:</span>
                <span class="s1">orders[col] = uniques</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">orders[col] = list(OrderedDict.fromkeys(list(orders[col]) + uniques))</span>

    <span class="s1">sorted_group_names = []</span>
    <span class="s0">for </span><span class="s1">group_name </span><span class="s0">in </span><span class="s1">grouped.groups:</span>
        <span class="s0">if </span><span class="s1">len(grouper) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">group_name = (group_name</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">sorted_group_names.append(group_name)</span>

    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">col </span><span class="s0">in </span><span class="s1">reversed(list(enumerate(grouper))):</span>
        <span class="s0">if </span><span class="s1">col != one_group:</span>
            <span class="s1">sorted_group_names = sorted(</span>
                <span class="s1">sorted_group_names</span><span class="s0">,</span>
                <span class="s1">key=</span><span class="s0">lambda </span><span class="s1">g: orders[col].index(g[i]) </span><span class="s0">if </span><span class="s1">g[i] </span><span class="s0">in </span><span class="s1">orders[col] </span><span class="s0">else </span><span class="s1">-</span><span class="s4">1</span><span class="s0">,</span>
            <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">orders</span><span class="s0">, </span><span class="s1">sorted_group_names</span>


<span class="s0">def </span><span class="s1">make_figure(args</span><span class="s0">, </span><span class="s1">constructor</span><span class="s0">, </span><span class="s1">trace_patch=</span><span class="s0">None, </span><span class="s1">layout_patch=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">trace_patch = trace_patch </span><span class="s0">or </span><span class="s1">{}</span>
    <span class="s1">layout_patch = layout_patch </span><span class="s0">or </span><span class="s1">{}</span>
    <span class="s1">apply_default_cascade(args)</span>

    <span class="s1">args = build_dataframe(args</span><span class="s0">, </span><span class="s1">constructor)</span>
    <span class="s0">if </span><span class="s1">constructor </span><span class="s0">in </span><span class="s1">[go.Treemap</span><span class="s0">, </span><span class="s1">go.Sunburst</span><span class="s0">, </span><span class="s1">go.Icicle] </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;path&quot;</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">args = process_dataframe_hierarchy(args)</span>
    <span class="s0">if </span><span class="s1">constructor == </span><span class="s2">&quot;timeline&quot;</span><span class="s1">:</span>
        <span class="s1">constructor = go.Bar</span>
        <span class="s1">args = process_dataframe_timeline(args)</span>

    <span class="s1">trace_specs</span><span class="s0">, </span><span class="s1">grouped_mappings</span><span class="s0">, </span><span class="s1">sizeref</span><span class="s0">, </span><span class="s1">show_colorbar = infer_config(</span>
        <span class="s1">args</span><span class="s0">, </span><span class="s1">constructor</span><span class="s0">, </span><span class="s1">trace_patch</span><span class="s0">, </span><span class="s1">layout_patch</span>
    <span class="s1">)</span>
    <span class="s1">grouper = [x.grouper </span><span class="s0">or </span><span class="s1">one_group </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">grouped_mappings] </span><span class="s0">or </span><span class="s1">[one_group]</span>
    <span class="s1">grouped = args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">].groupby(grouper</span><span class="s0">, </span><span class="s1">sort=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">orders</span><span class="s0">, </span><span class="s1">sorted_group_names = get_orderings(args</span><span class="s0">, </span><span class="s1">grouper</span><span class="s0">, </span><span class="s1">grouped)</span>

    <span class="s1">col_labels = []</span>
    <span class="s1">row_labels = []</span>
    <span class="s1">nrows = ncols = </span><span class="s4">1</span>
    <span class="s0">for </span><span class="s1">m </span><span class="s0">in </span><span class="s1">grouped_mappings:</span>
        <span class="s0">if </span><span class="s1">m.grouper </span><span class="s0">not in </span><span class="s1">orders:</span>
            <span class="s1">m.val_map[</span><span class="s2">&quot;&quot;</span><span class="s1">] = m.sequence[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">sorted_values = orders[m.grouper]</span>
            <span class="s0">if </span><span class="s1">m.facet == </span><span class="s2">&quot;col&quot;</span><span class="s1">:</span>
                <span class="s1">prefix = get_label(args</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;facet_col&quot;</span><span class="s1">]) + </span><span class="s2">&quot;=&quot;</span>
                <span class="s1">col_labels = [prefix + str(s) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">sorted_values]</span>
                <span class="s1">ncols = len(col_labels)</span>
            <span class="s0">if </span><span class="s1">m.facet == </span><span class="s2">&quot;row&quot;</span><span class="s1">:</span>
                <span class="s1">prefix = get_label(args</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;facet_row&quot;</span><span class="s1">]) + </span><span class="s2">&quot;=&quot;</span>
                <span class="s1">row_labels = [prefix + str(s) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">sorted_values]</span>
                <span class="s1">nrows = len(row_labels)</span>
            <span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">sorted_values:</span>
                <span class="s0">if </span><span class="s1">val </span><span class="s0">not in </span><span class="s1">m.val_map:  </span><span class="s3"># always False if it's an IdentityMap</span>
                    <span class="s1">m.val_map[val] = m.sequence[len(m.val_map) % len(m.sequence)]</span>

    <span class="s1">subplot_type = _subplot_type_for_trace_type(constructor().type)</span>

    <span class="s1">trace_names_by_frame = {}</span>
    <span class="s1">frames = OrderedDict()</span>
    <span class="s1">trendline_rows = []</span>
    <span class="s1">trace_name_labels = </span><span class="s0">None</span>
    <span class="s1">facet_col_wrap = args.get(</span><span class="s2">&quot;facet_col_wrap&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">group_name </span><span class="s0">in </span><span class="s1">sorted_group_names:</span>
        <span class="s1">group = grouped.get_group(group_name </span><span class="s0">if </span><span class="s1">len(group_name) &gt; </span><span class="s4">1 </span><span class="s0">else </span><span class="s1">group_name[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">mapping_labels = OrderedDict()</span>
        <span class="s1">trace_name_labels = OrderedDict()</span>
        <span class="s1">frame_name = </span><span class="s2">&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">col</span><span class="s0">, </span><span class="s1">val</span><span class="s0">, </span><span class="s1">m </span><span class="s0">in </span><span class="s1">zip(grouper</span><span class="s0">, </span><span class="s1">group_name</span><span class="s0">, </span><span class="s1">grouped_mappings):</span>
            <span class="s0">if </span><span class="s1">col != one_group:</span>
                <span class="s1">key = get_label(args</span><span class="s0">, </span><span class="s1">col)</span>
                <span class="s0">if not </span><span class="s1">isinstance(m.val_map</span><span class="s0">, </span><span class="s1">IdentityMap):</span>
                    <span class="s1">mapping_labels[key] = str(val)</span>
                    <span class="s0">if </span><span class="s1">m.show_in_trace_name:</span>
                        <span class="s1">trace_name_labels[key] = str(val)</span>
                <span class="s0">if </span><span class="s1">m.variable == </span><span class="s2">&quot;animation_frame&quot;</span><span class="s1">:</span>
                    <span class="s1">frame_name = val</span>
        <span class="s1">trace_name = </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(trace_name_labels.values())</span>
        <span class="s0">if </span><span class="s1">frame_name </span><span class="s0">not in </span><span class="s1">trace_names_by_frame:</span>
            <span class="s1">trace_names_by_frame[frame_name] = set()</span>
        <span class="s1">trace_names = trace_names_by_frame[frame_name]</span>

        <span class="s0">for </span><span class="s1">trace_spec </span><span class="s0">in </span><span class="s1">trace_specs:</span>
            <span class="s3"># Create the trace</span>
            <span class="s1">trace = trace_spec.constructor(name=trace_name)</span>
            <span class="s0">if </span><span class="s1">trace_spec.constructor </span><span class="s0">not in </span><span class="s1">[</span>
                <span class="s1">go.Parcats</span><span class="s0">,</span>
                <span class="s1">go.Parcoords</span><span class="s0">,</span>
                <span class="s1">go.Choropleth</span><span class="s0">,</span>
                <span class="s1">go.Choroplethmapbox</span><span class="s0">,</span>
                <span class="s1">go.Densitymapbox</span><span class="s0">,</span>
                <span class="s1">go.Histogram2d</span><span class="s0">,</span>
                <span class="s1">go.Sunburst</span><span class="s0">,</span>
                <span class="s1">go.Treemap</span><span class="s0">,</span>
                <span class="s1">go.Icicle</span><span class="s0">,</span>
            <span class="s1">]:</span>
                <span class="s1">trace.update(</span>
                    <span class="s1">legendgroup=trace_name</span><span class="s0">,</span>
                    <span class="s1">showlegend=(trace_name != </span><span class="s2">&quot;&quot; </span><span class="s0">and </span><span class="s1">trace_name </span><span class="s0">not in </span><span class="s1">trace_names)</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">trace_spec.constructor </span><span class="s0">in </span><span class="s1">[go.Bar</span><span class="s0">, </span><span class="s1">go.Violin</span><span class="s0">, </span><span class="s1">go.Box</span><span class="s0">, </span><span class="s1">go.Histogram]:</span>
                <span class="s1">trace.update(alignmentgroup=</span><span class="s0">True, </span><span class="s1">offsetgroup=trace_name)</span>
            <span class="s1">trace_names.add(trace_name)</span>

            <span class="s3"># Init subplot row/col</span>
            <span class="s1">trace._subplot_row = </span><span class="s4">1</span>
            <span class="s1">trace._subplot_col = </span><span class="s4">1</span>

            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">m </span><span class="s0">in </span><span class="s1">enumerate(grouped_mappings):</span>
                <span class="s1">val = group_name[i]</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">m.updater(trace</span><span class="s0">, </span><span class="s1">m.val_map[val])  </span><span class="s3"># covers most cases</span>
                <span class="s0">except </span><span class="s1">ValueError:</span>
                    <span class="s3"># this catches some odd cases like marginals</span>
                    <span class="s0">if </span><span class="s1">(</span>
                        <span class="s1">trace_spec != trace_specs[</span><span class="s4">0</span><span class="s1">]</span>
                        <span class="s0">and </span><span class="s1">(</span>
                            <span class="s1">trace_spec.constructor </span><span class="s0">in </span><span class="s1">[go.Violin</span><span class="s0">, </span><span class="s1">go.Box]</span>
                            <span class="s0">and </span><span class="s1">m.variable </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;symbol&quot;</span><span class="s0">, </span><span class="s2">&quot;pattern&quot;</span><span class="s0">, </span><span class="s2">&quot;dash&quot;</span><span class="s1">]</span>
                        <span class="s1">)</span>
                        <span class="s0">or </span><span class="s1">(</span>
                            <span class="s1">trace_spec.constructor </span><span class="s0">in </span><span class="s1">[go.Histogram]</span>
                            <span class="s0">and </span><span class="s1">m.variable </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;symbol&quot;</span><span class="s0">, </span><span class="s2">&quot;dash&quot;</span><span class="s1">]</span>
                        <span class="s1">)</span>
                    <span class="s1">):</span>
                        <span class="s0">pass</span>
                    <span class="s0">elif </span><span class="s1">(</span>
                        <span class="s1">trace_spec != trace_specs[</span><span class="s4">0</span><span class="s1">]</span>
                        <span class="s0">and </span><span class="s1">trace_spec.constructor </span><span class="s0">in </span><span class="s1">[go.Histogram]</span>
                        <span class="s0">and </span><span class="s1">m.variable == </span><span class="s2">&quot;color&quot;</span>
                    <span class="s1">):</span>
                        <span class="s1">trace.update(marker=dict(color=m.val_map[val]))</span>
                    <span class="s0">elif </span><span class="s1">(</span>
                        <span class="s1">trace_spec.constructor </span><span class="s0">in </span><span class="s1">[go.Choropleth</span><span class="s0">, </span><span class="s1">go.Choroplethmapbox]</span>
                        <span class="s0">and </span><span class="s1">m.variable == </span><span class="s2">&quot;color&quot;</span>
                    <span class="s1">):</span>
                        <span class="s1">trace.update(</span>
                            <span class="s1">z=[</span><span class="s4">1</span><span class="s1">] * len(group)</span><span class="s0">,</span>
                            <span class="s1">colorscale=[m.val_map[val]] * </span><span class="s4">2</span><span class="s0">,</span>
                            <span class="s1">showscale=</span><span class="s0">False,</span>
                            <span class="s1">showlegend=</span><span class="s0">True,</span>
                        <span class="s1">)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s0">raise</span>

                <span class="s3"># Find row for trace, handling facet_row and marginal_x</span>
                <span class="s0">if </span><span class="s1">m.facet == </span><span class="s2">&quot;row&quot;</span><span class="s1">:</span>
                    <span class="s1">row = m.val_map[val]</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">(</span>
                        <span class="s1">args.get(</span><span class="s2">&quot;marginal_x&quot;</span><span class="s1">) </span><span class="s0">is not None  </span><span class="s3"># there is a marginal</span>
                        <span class="s0">and </span><span class="s1">trace_spec.marginal != </span><span class="s2">&quot;x&quot;  </span><span class="s3"># and we're not it</span>
                    <span class="s1">):</span>
                        <span class="s1">row = </span><span class="s4">2</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">row = </span><span class="s4">1</span>

                <span class="s3"># Find col for trace, handling facet_col and marginal_y</span>
                <span class="s0">if </span><span class="s1">m.facet == </span><span class="s2">&quot;col&quot;</span><span class="s1">:</span>
                    <span class="s1">col = m.val_map[val]</span>
                    <span class="s0">if </span><span class="s1">facet_col_wrap:  </span><span class="s3"># assumes no facet_row, no marginals</span>
                        <span class="s1">row = </span><span class="s4">1 </span><span class="s1">+ ((col - </span><span class="s4">1</span><span class="s1">) // facet_col_wrap)</span>
                        <span class="s1">col = </span><span class="s4">1 </span><span class="s1">+ ((col - </span><span class="s4">1</span><span class="s1">) % facet_col_wrap)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">trace_spec.marginal == </span><span class="s2">&quot;y&quot;</span><span class="s1">:</span>
                        <span class="s1">col = </span><span class="s4">2</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">col = </span><span class="s4">1</span>

                <span class="s0">if </span><span class="s1">row &gt; </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s1">trace._subplot_row = row</span>

                <span class="s0">if </span><span class="s1">col &gt; </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s1">trace._subplot_col = col</span>
            <span class="s0">if </span><span class="s1">(</span>
                <span class="s1">trace_specs[</span><span class="s4">0</span><span class="s1">].constructor == go.Histogram2dContour</span>
                <span class="s0">and </span><span class="s1">trace_spec.constructor == go.Box</span>
                <span class="s0">and </span><span class="s1">trace.line.color</span>
            <span class="s1">):</span>
                <span class="s1">trace.update(marker=dict(color=trace.line.color))</span>

            <span class="s0">if </span><span class="s2">&quot;ecdfmode&quot; </span><span class="s0">in </span><span class="s1">args:</span>
                <span class="s1">base = args[</span><span class="s2">&quot;x&quot;</span><span class="s1">] </span><span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] == </span><span class="s2">&quot;v&quot; </span><span class="s0">else </span><span class="s1">args[</span><span class="s2">&quot;y&quot;</span><span class="s1">]</span>
                <span class="s1">var = args[</span><span class="s2">&quot;x&quot;</span><span class="s1">] </span><span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;orientation&quot;</span><span class="s1">] == </span><span class="s2">&quot;h&quot; </span><span class="s0">else </span><span class="s1">args[</span><span class="s2">&quot;y&quot;</span><span class="s1">]</span>
                <span class="s1">ascending = args.get(</span><span class="s2">&quot;ecdfmode&quot;</span><span class="s0">, </span><span class="s2">&quot;standard&quot;</span><span class="s1">) != </span><span class="s2">&quot;reversed&quot;</span>
                <span class="s1">group = group.sort_values(by=base</span><span class="s0">, </span><span class="s1">ascending=ascending)</span>
                <span class="s1">group_sum = group[var].sum()  </span><span class="s3"># compute here before next line mutates</span>
                <span class="s1">group[var] = group[var].cumsum()</span>
                <span class="s0">if not </span><span class="s1">ascending:</span>
                    <span class="s1">group = group.sort_values(by=base</span><span class="s0">, </span><span class="s1">ascending=</span><span class="s0">True</span><span class="s1">)</span>

                <span class="s0">if </span><span class="s1">args.get(</span><span class="s2">&quot;ecdfmode&quot;</span><span class="s0">, </span><span class="s2">&quot;standard&quot;</span><span class="s1">) == </span><span class="s2">&quot;complementary&quot;</span><span class="s1">:</span>
                    <span class="s1">group[var] = group_sum - group[var]</span>

                <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;ecdfnorm&quot;</span><span class="s1">] == </span><span class="s2">&quot;probability&quot;</span><span class="s1">:</span>
                    <span class="s1">group[var] = group[var] / group_sum</span>
                <span class="s0">elif </span><span class="s1">args[</span><span class="s2">&quot;ecdfnorm&quot;</span><span class="s1">] == </span><span class="s2">&quot;percent&quot;</span><span class="s1">:</span>
                    <span class="s1">group[var] = </span><span class="s4">100.0 </span><span class="s1">* group[var] / group_sum</span>

            <span class="s1">patch</span><span class="s0">, </span><span class="s1">fit_results = make_trace_kwargs(</span>
                <span class="s1">args</span><span class="s0">, </span><span class="s1">trace_spec</span><span class="s0">, </span><span class="s1">group</span><span class="s0">, </span><span class="s1">mapping_labels.copy()</span><span class="s0">, </span><span class="s1">sizeref</span>
            <span class="s1">)</span>
            <span class="s1">trace.update(patch)</span>
            <span class="s0">if </span><span class="s1">fit_results </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">trendline_rows.append(mapping_labels.copy())</span>
                <span class="s1">trendline_rows[-</span><span class="s4">1</span><span class="s1">][</span><span class="s2">&quot;px_fit_results&quot;</span><span class="s1">] = fit_results</span>
            <span class="s0">if </span><span class="s1">frame_name </span><span class="s0">not in </span><span class="s1">frames:</span>
                <span class="s1">frames[frame_name] = dict(data=[]</span><span class="s0">, </span><span class="s1">name=frame_name)</span>
            <span class="s1">frames[frame_name][</span><span class="s2">&quot;data&quot;</span><span class="s1">].append(trace)</span>
    <span class="s1">frame_list = [f </span><span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">frames.values()]</span>
    <span class="s0">if </span><span class="s1">len(frame_list) &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">frame_list = sorted(</span>
            <span class="s1">frame_list</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">lambda </span><span class="s1">f: orders[args[</span><span class="s2">&quot;animation_frame&quot;</span><span class="s1">]].index(f[</span><span class="s2">&quot;name&quot;</span><span class="s1">])</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">show_colorbar:</span>
        <span class="s1">colorvar = </span><span class="s2">&quot;z&quot; </span><span class="s0">if </span><span class="s1">constructor </span><span class="s0">in </span><span class="s1">[go.Histogram2d</span><span class="s0">, </span><span class="s1">go.Densitymapbox] </span><span class="s0">else </span><span class="s2">&quot;color&quot;</span>
        <span class="s1">range_color = args[</span><span class="s2">&quot;range_color&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s1">[</span><span class="s0">None, None</span><span class="s1">]</span>

        <span class="s1">colorscale_validator = ColorscaleValidator(</span><span class="s2">&quot;colorscale&quot;</span><span class="s0">, </span><span class="s2">&quot;make_figure&quot;</span><span class="s1">)</span>
        <span class="s1">layout_patch[</span><span class="s2">&quot;coloraxis1&quot;</span><span class="s1">] = dict(</span>
            <span class="s1">colorscale=colorscale_validator.validate_coerce(</span>
                <span class="s1">args[</span><span class="s2">&quot;color_continuous_scale&quot;</span><span class="s1">]</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">cmid=args[</span><span class="s2">&quot;color_continuous_midpoint&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">cmin=range_color[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">cmax=range_color[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">colorbar=dict(</span>
                <span class="s1">title_text=get_decorated_label(args</span><span class="s0">, </span><span class="s1">args[colorvar]</span><span class="s0">, </span><span class="s1">colorvar)</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;height&quot;</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s1">]:</span>
        <span class="s0">if </span><span class="s1">args[v]:</span>
            <span class="s1">layout_patch[v] = args[v]</span>
    <span class="s1">layout_patch[</span><span class="s2">&quot;legend&quot;</span><span class="s1">] = dict(tracegroupgap=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">trace_name_labels:</span>
        <span class="s1">layout_patch[</span><span class="s2">&quot;legend&quot;</span><span class="s1">][</span><span class="s2">&quot;title_text&quot;</span><span class="s1">] = </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(trace_name_labels)</span>
    <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;title&quot;</span><span class="s1">]:</span>
        <span class="s1">layout_patch[</span><span class="s2">&quot;title_text&quot;</span><span class="s1">] = args[</span><span class="s2">&quot;title&quot;</span><span class="s1">]</span>
    <span class="s0">elif </span><span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">].layout.margin.t </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">layout_patch[</span><span class="s2">&quot;margin&quot;</span><span class="s1">] = {</span><span class="s2">&quot;t&quot;</span><span class="s1">: </span><span class="s4">60</span><span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(</span>
        <span class="s2">&quot;size&quot; </span><span class="s0">in </span><span class="s1">args</span>
        <span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;size&quot;</span><span class="s1">]</span>
        <span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">].layout.legend.itemsizing </span><span class="s0">is None</span>
    <span class="s1">):</span>
        <span class="s1">layout_patch[</span><span class="s2">&quot;legend&quot;</span><span class="s1">][</span><span class="s2">&quot;itemsizing&quot;</span><span class="s1">] = </span><span class="s2">&quot;constant&quot;</span>

    <span class="s0">if </span><span class="s1">facet_col_wrap:</span>
        <span class="s1">nrows = math.ceil(ncols / facet_col_wrap)</span>
        <span class="s1">ncols = min(ncols</span><span class="s0">, </span><span class="s1">facet_col_wrap)</span>

    <span class="s0">if </span><span class="s1">args.get(</span><span class="s2">&quot;marginal_x&quot;</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">nrows += </span><span class="s4">1</span>

    <span class="s0">if </span><span class="s1">args.get(</span><span class="s2">&quot;marginal_y&quot;</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">ncols += </span><span class="s4">1</span>

    <span class="s1">fig = init_figure(</span>
        <span class="s1">args</span><span class="s0">, </span><span class="s1">subplot_type</span><span class="s0">, </span><span class="s1">frame_list</span><span class="s0">, </span><span class="s1">nrows</span><span class="s0">, </span><span class="s1">ncols</span><span class="s0">, </span><span class="s1">col_labels</span><span class="s0">, </span><span class="s1">row_labels</span>
    <span class="s1">)</span>

    <span class="s3"># Position traces in subplots</span>
    <span class="s0">for </span><span class="s1">frame </span><span class="s0">in </span><span class="s1">frame_list:</span>
        <span class="s0">for </span><span class="s1">trace </span><span class="s0">in </span><span class="s1">frame[</span><span class="s2">&quot;data&quot;</span><span class="s1">]:</span>
            <span class="s0">if </span><span class="s1">isinstance(trace</span><span class="s0">, </span><span class="s1">go.Splom):</span>
                <span class="s3"># Special case that is not compatible with make_subplots</span>
                <span class="s0">continue</span>

            <span class="s1">_set_trace_grid_reference(</span>
                <span class="s1">trace</span><span class="s0">,</span>
                <span class="s1">fig.layout</span><span class="s0">,</span>
                <span class="s1">fig._grid_ref</span><span class="s0">,</span>
                <span class="s1">nrows - trace._subplot_row + </span><span class="s4">1</span><span class="s0">,</span>
                <span class="s1">trace._subplot_col</span><span class="s0">,</span>
            <span class="s1">)</span>

    <span class="s3"># Add traces, layout and frames to figure</span>
    <span class="s1">fig.add_traces(frame_list[</span><span class="s4">0</span><span class="s1">][</span><span class="s2">&quot;data&quot;</span><span class="s1">] </span><span class="s0">if </span><span class="s1">len(frame_list) &gt; </span><span class="s4">0 </span><span class="s0">else </span><span class="s1">[])</span>
    <span class="s1">fig.update_layout(layout_patch)</span>
    <span class="s0">if </span><span class="s2">&quot;template&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;template&quot;</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">fig.update_layout(template=args[</span><span class="s2">&quot;template&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">overwrite=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">fig.frames = frame_list </span><span class="s0">if </span><span class="s1">len(frames) &gt; </span><span class="s4">1 </span><span class="s0">else </span><span class="s1">[]</span>

    <span class="s0">if </span><span class="s1">args.get(</span><span class="s2">&quot;trendline&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">args.get(</span><span class="s2">&quot;trendline_scope&quot;</span><span class="s0">, </span><span class="s2">&quot;trace&quot;</span><span class="s1">) == </span><span class="s2">&quot;overall&quot;</span><span class="s1">:</span>
        <span class="s1">trendline_spec = make_trendline_spec(args</span><span class="s0">, </span><span class="s1">constructor)</span>
        <span class="s1">trendline_trace = trendline_spec.constructor(</span>
            <span class="s1">name=</span><span class="s2">&quot;Overall Trendline&quot;</span><span class="s0">, </span><span class="s1">legendgroup=</span><span class="s2">&quot;Overall Trendline&quot;</span><span class="s0">, </span><span class="s1">showlegend=</span><span class="s0">False</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s2">&quot;line&quot; </span><span class="s0">not in </span><span class="s1">trendline_spec.trace_patch:  </span><span class="s3"># no color override</span>
            <span class="s0">for </span><span class="s1">m </span><span class="s0">in </span><span class="s1">grouped_mappings:</span>
                <span class="s0">if </span><span class="s1">m.variable == </span><span class="s2">&quot;color&quot;</span><span class="s1">:</span>
                    <span class="s1">next_color = m.sequence[len(m.val_map) % len(m.sequence)]</span>
                    <span class="s1">trendline_spec.trace_patch[</span><span class="s2">&quot;line&quot;</span><span class="s1">] = dict(color=next_color)</span>
        <span class="s1">patch</span><span class="s0">, </span><span class="s1">fit_results = make_trace_kwargs(</span>
            <span class="s1">args</span><span class="s0">, </span><span class="s1">trendline_spec</span><span class="s0">, </span><span class="s1">args[</span><span class="s2">&quot;data_frame&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s1">sizeref</span>
        <span class="s1">)</span>
        <span class="s1">trendline_trace.update(patch)</span>
        <span class="s1">fig.add_trace(</span>
            <span class="s1">trendline_trace</span><span class="s0">, </span><span class="s1">row=</span><span class="s2">&quot;all&quot;</span><span class="s0">, </span><span class="s1">col=</span><span class="s2">&quot;all&quot;</span><span class="s0">, </span><span class="s1">exclude_empty_subplots=</span><span class="s0">True</span>
        <span class="s1">)</span>
        <span class="s1">fig.update_traces(selector=-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">showlegend=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">fit_results </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">trendline_rows.append(dict(px_fit_results=fit_results))</span>

    <span class="s1">fig._px_trendlines = pd.DataFrame(trendline_rows)</span>

    <span class="s1">configure_axes(args</span><span class="s0">, </span><span class="s1">constructor</span><span class="s0">, </span><span class="s1">fig</span><span class="s0">, </span><span class="s1">orders)</span>
    <span class="s1">configure_animation_controls(args</span><span class="s0">, </span><span class="s1">constructor</span><span class="s0">, </span><span class="s1">fig)</span>
    <span class="s0">return </span><span class="s1">fig</span>


<span class="s0">def </span><span class="s1">init_figure(args</span><span class="s0">, </span><span class="s1">subplot_type</span><span class="s0">, </span><span class="s1">frame_list</span><span class="s0">, </span><span class="s1">nrows</span><span class="s0">, </span><span class="s1">ncols</span><span class="s0">, </span><span class="s1">col_labels</span><span class="s0">, </span><span class="s1">row_labels):</span>
    <span class="s3"># Build subplot specs</span>
    <span class="s1">specs = [[dict(type=subplot_type </span><span class="s0">or </span><span class="s2">&quot;domain&quot;</span><span class="s1">)] * ncols </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(nrows)]</span>

    <span class="s3"># Default row/column widths uniform</span>
    <span class="s1">column_widths = [</span><span class="s4">1.0</span><span class="s1">] * ncols</span>
    <span class="s1">row_heights = [</span><span class="s4">1.0</span><span class="s1">] * nrows</span>
    <span class="s1">facet_col_wrap = args.get(</span><span class="s2">&quot;facet_col_wrap&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3"># Build column_widths/row_heights</span>
    <span class="s0">if </span><span class="s1">subplot_type == </span><span class="s2">&quot;xy&quot;</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">args.get(</span><span class="s2">&quot;marginal_x&quot;</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;marginal_x&quot;</span><span class="s1">] == </span><span class="s2">&quot;histogram&quot; </span><span class="s0">or </span><span class="s1">(</span><span class="s2">&quot;color&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">]):</span>
                <span class="s1">main_size = </span><span class="s4">0.74</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">main_size = </span><span class="s4">0.84</span>

            <span class="s1">row_heights = [main_size] * (nrows - </span><span class="s4">1</span><span class="s1">) + [</span><span class="s4">1 </span><span class="s1">- main_size]</span>
            <span class="s1">vertical_spacing = </span><span class="s4">0.01</span>
        <span class="s0">elif </span><span class="s1">facet_col_wrap:</span>
            <span class="s1">vertical_spacing = args.get(</span><span class="s2">&quot;facet_row_spacing&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s4">0.07</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">vertical_spacing = args.get(</span><span class="s2">&quot;facet_row_spacing&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s4">0.03</span>

        <span class="s0">if </span><span class="s1">args.get(</span><span class="s2">&quot;marginal_y&quot;</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">args[</span><span class="s2">&quot;marginal_y&quot;</span><span class="s1">] == </span><span class="s2">&quot;histogram&quot; </span><span class="s0">or </span><span class="s1">(</span><span class="s2">&quot;color&quot; </span><span class="s0">in </span><span class="s1">args </span><span class="s0">and </span><span class="s1">args[</span><span class="s2">&quot;color&quot;</span><span class="s1">]):</span>
                <span class="s1">main_size = </span><span class="s4">0.74</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">main_size = </span><span class="s4">0.84</span>

            <span class="s1">column_widths = [main_size] * (ncols - </span><span class="s4">1</span><span class="s1">) + [</span><span class="s4">1 </span><span class="s1">- main_size]</span>
            <span class="s1">horizontal_spacing = </span><span class="s4">0.005</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">horizontal_spacing = args.get(</span><span class="s2">&quot;facet_col_spacing&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s4">0.02</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s3"># Other subplot types:</span>
        <span class="s3">#   'scene', 'geo', 'polar', 'ternary', 'mapbox', 'domain', None</span>
        <span class="s3">#</span>
        <span class="s3"># We can customize subplot spacing per type once we enable faceting</span>
        <span class="s3"># for all plot types</span>
        <span class="s0">if </span><span class="s1">facet_col_wrap:</span>
            <span class="s1">vertical_spacing = args.get(</span><span class="s2">&quot;facet_row_spacing&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s4">0.07</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">vertical_spacing = args.get(</span><span class="s2">&quot;facet_row_spacing&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s4">0.03</span>
        <span class="s1">horizontal_spacing = args.get(</span><span class="s2">&quot;facet_col_spacing&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s4">0.02</span>

    <span class="s0">if </span><span class="s1">facet_col_wrap:</span>
        <span class="s1">subplot_labels = [</span><span class="s0">None</span><span class="s1">] * nrows * ncols</span>
        <span class="s0">while </span><span class="s1">len(col_labels) &lt; nrows * ncols:</span>
            <span class="s1">col_labels.append(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(nrows):</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(ncols):</span>
                <span class="s1">subplot_labels[i * ncols + j] = col_labels[(nrows - </span><span class="s4">1 </span><span class="s1">- i) * ncols + j]</span>

    <span class="s0">def </span><span class="s1">_spacing_error_translator(e</span><span class="s0">, </span><span class="s1">direction</span><span class="s0">, </span><span class="s1">facet_arg):</span>
        <span class="s5">&quot;&quot;&quot; 
        Translates the spacing errors thrown by the underlying make_subplots 
        routine into one that describes an argument adjustable through px. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s2">&quot;%s spacing&quot; </span><span class="s1">% (direction</span><span class="s0">,</span><span class="s1">)) </span><span class="s0">in </span><span class="s1">e.args[</span><span class="s4">0</span><span class="s1">]:</span>
            <span class="s1">e.args = (</span>
                <span class="s1">e.args[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">+ </span><span class="s2">&quot;&quot;&quot; 
Use the {facet_arg} argument to adjust this spacing.&quot;&quot;&quot;</span><span class="s1">.format(</span>
                    <span class="s1">facet_arg=facet_arg</span>
                <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">e</span>

    <span class="s3"># Create figure with subplots</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">fig = make_subplots(</span>
            <span class="s1">rows=nrows</span><span class="s0">,</span>
            <span class="s1">cols=ncols</span><span class="s0">,</span>
            <span class="s1">specs=specs</span><span class="s0">,</span>
            <span class="s1">shared_xaxes=</span><span class="s2">&quot;all&quot;</span><span class="s0">,</span>
            <span class="s1">shared_yaxes=</span><span class="s2">&quot;all&quot;</span><span class="s0">,</span>
            <span class="s1">row_titles=[] </span><span class="s0">if </span><span class="s1">facet_col_wrap </span><span class="s0">else </span><span class="s1">list(reversed(row_labels))</span><span class="s0">,</span>
            <span class="s1">column_titles=[] </span><span class="s0">if </span><span class="s1">facet_col_wrap </span><span class="s0">else </span><span class="s1">col_labels</span><span class="s0">,</span>
            <span class="s1">subplot_titles=subplot_labels </span><span class="s0">if </span><span class="s1">facet_col_wrap </span><span class="s0">else </span><span class="s1">[]</span><span class="s0">,</span>
            <span class="s1">horizontal_spacing=horizontal_spacing</span><span class="s0">,</span>
            <span class="s1">vertical_spacing=vertical_spacing</span><span class="s0">,</span>
            <span class="s1">row_heights=row_heights</span><span class="s0">,</span>
            <span class="s1">column_widths=column_widths</span><span class="s0">,</span>
            <span class="s1">start_cell=</span><span class="s2">&quot;bottom-left&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s1">_spacing_error_translator(e</span><span class="s0">, </span><span class="s2">&quot;Horizontal&quot;</span><span class="s0">, </span><span class="s2">&quot;facet_col_spacing&quot;</span><span class="s1">)</span>
        <span class="s1">_spacing_error_translator(e</span><span class="s0">, </span><span class="s2">&quot;Vertical&quot;</span><span class="s0">, </span><span class="s2">&quot;facet_row_spacing&quot;</span><span class="s1">)</span>

    <span class="s3"># Remove explicit font size of row/col titles so template can take over</span>
    <span class="s0">for </span><span class="s1">annot </span><span class="s0">in </span><span class="s1">fig.layout.annotations:</span>
        <span class="s1">annot.update(font=</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">fig</span>
</pre>
</body>
</html>