<html>
<head>
<title>nanops.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
nanops.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Any</span><span class="s0">,</span>
    <span class="s1">cast</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas._config </span><span class="s0">import </span><span class="s1">get_option</span>

<span class="s0">from </span><span class="s1">pandas._libs </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">NaT</span><span class="s0">,</span>
    <span class="s1">NaTType</span><span class="s0">,</span>
    <span class="s1">Timedelta</span><span class="s0">,</span>
    <span class="s1">iNaT</span><span class="s0">,</span>
    <span class="s1">lib</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ArrayLike</span><span class="s0">,</span>
    <span class="s1">Dtype</span><span class="s0">,</span>
    <span class="s1">DtypeObj</span><span class="s0">,</span>
    <span class="s1">F</span><span class="s0">,</span>
    <span class="s1">Scalar</span><span class="s0">,</span>
    <span class="s1">Shape</span><span class="s0">,</span>
    <span class="s1">npt</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.compat._optional </span><span class="s0">import </span><span class="s1">import_optional_dependency</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">is_any_int_dtype</span><span class="s0">,</span>
    <span class="s1">is_bool_dtype</span><span class="s0">,</span>
    <span class="s1">is_complex</span><span class="s0">,</span>
    <span class="s1">is_datetime64_any_dtype</span><span class="s0">,</span>
    <span class="s1">is_float</span><span class="s0">,</span>
    <span class="s1">is_float_dtype</span><span class="s0">,</span>
    <span class="s1">is_integer</span><span class="s0">,</span>
    <span class="s1">is_integer_dtype</span><span class="s0">,</span>
    <span class="s1">is_numeric_dtype</span><span class="s0">,</span>
    <span class="s1">is_object_dtype</span><span class="s0">,</span>
    <span class="s1">is_scalar</span><span class="s0">,</span>
    <span class="s1">is_timedelta64_dtype</span><span class="s0">,</span>
    <span class="s1">needs_i8_conversion</span><span class="s0">,</span>
    <span class="s1">pandas_dtype</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s0">import </span><span class="s1">PeriodDtype</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">isna</span><span class="s0">,</span>
    <span class="s1">na_value_for_dtype</span><span class="s0">,</span>
    <span class="s1">notna</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">pandas.core.construction </span><span class="s0">import </span><span class="s1">extract_array</span>

<span class="s1">bn = import_optional_dependency(</span><span class="s2">&quot;bottleneck&quot;</span><span class="s0">, </span><span class="s1">errors=</span><span class="s2">&quot;warn&quot;</span><span class="s1">)</span>
<span class="s1">_BOTTLENECK_INSTALLED = bn </span><span class="s0">is not None</span>
<span class="s1">_USE_BOTTLENECK = </span><span class="s0">False</span>


<span class="s0">def </span><span class="s1">set_use_bottleneck(v: bool = </span><span class="s0">True</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s3"># set/unset to use bottleneck</span>
    <span class="s0">global </span><span class="s1">_USE_BOTTLENECK</span>
    <span class="s0">if </span><span class="s1">_BOTTLENECK_INSTALLED:</span>
        <span class="s1">_USE_BOTTLENECK = v</span>


<span class="s1">set_use_bottleneck(get_option(</span><span class="s2">&quot;compute.use_bottleneck&quot;</span><span class="s1">))</span>


<span class="s0">class </span><span class="s1">disallow:</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*dtypes: Dtype):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.dtypes = tuple(pandas_dtype(dtype).type </span><span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">dtypes)</span>

    <span class="s0">def </span><span class="s1">check(self</span><span class="s0">, </span><span class="s1">obj) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">hasattr(obj</span><span class="s0">, </span><span class="s2">&quot;dtype&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">issubclass(obj.dtype.type</span><span class="s0">, </span><span class="s1">self.dtypes)</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">f: F) -&gt; F:</span>
        <span class="s1">@functools.wraps(f)</span>
        <span class="s0">def </span><span class="s1">_f(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s1">obj_iter = itertools.chain(args</span><span class="s0">, </span><span class="s1">kwargs.values())</span>
            <span class="s0">if </span><span class="s1">any(self.check(obj) </span><span class="s0">for </span><span class="s1">obj </span><span class="s0">in </span><span class="s1">obj_iter):</span>
                <span class="s1">f_name = f.__name__.replace(</span><span class="s2">&quot;nan&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s2">f&quot;reduction operation '</span><span class="s0">{</span><span class="s1">f_name</span><span class="s0">}</span><span class="s2">' not allowed for this dtype&quot;</span>
                <span class="s1">)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
                    <span class="s0">return </span><span class="s1">f(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">e:</span>
                <span class="s3"># we want to transform an object array</span>
                <span class="s3"># ValueError message to the more typical TypeError</span>
                <span class="s3"># e.g. this is normally a disallowed function on</span>
                <span class="s3"># object arrays that contain strings</span>
                <span class="s0">if </span><span class="s1">is_object_dtype(args[</span><span class="s4">0</span><span class="s1">]):</span>
                    <span class="s0">raise </span><span class="s1">TypeError(e) </span><span class="s0">from </span><span class="s1">e</span>
                <span class="s0">raise</span>

        <span class="s0">return </span><span class="s1">cast(F</span><span class="s0">, </span><span class="s1">_f)</span>


<span class="s0">class </span><span class="s1">bottleneck_switch:</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">name=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.kwargs = kwargs</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">alt: F) -&gt; F:</span>
        <span class="s1">bn_name = self.name </span><span class="s0">or </span><span class="s1">alt.__name__</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">bn_func = getattr(bn</span><span class="s0">, </span><span class="s1">bn_name)</span>
        <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">NameError):  </span><span class="s3"># pragma: no cover</span>
            <span class="s1">bn_func = </span><span class="s0">None</span>

        <span class="s1">@functools.wraps(alt)</span>
        <span class="s0">def </span><span class="s1">f(</span>
            <span class="s1">values: np.ndarray</span><span class="s0">,</span>
            <span class="s1">*</span><span class="s0">,</span>
            <span class="s1">axis: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
            <span class="s1">skipna: bool = </span><span class="s0">True,</span>
            <span class="s1">**kwds</span><span class="s0">,</span>
        <span class="s1">):</span>
            <span class="s0">if </span><span class="s1">len(self.kwargs) &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self.kwargs.items():</span>
                    <span class="s0">if </span><span class="s1">k </span><span class="s0">not in </span><span class="s1">kwds:</span>
                        <span class="s1">kwds[k] = v</span>

            <span class="s0">if </span><span class="s1">values.size == </span><span class="s4">0 </span><span class="s0">and </span><span class="s1">kwds.get(</span><span class="s2">&quot;min_count&quot;</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s3"># We are empty, returning NA for our type</span>
                <span class="s3"># Only applies for the default `min_count` of None</span>
                <span class="s3"># since that affects how empty arrays are handled.</span>
                <span class="s3"># TODO(GH-18976) update all the nanops methods to</span>
                <span class="s3"># correctly handle empty inputs and remove this check.</span>
                <span class="s3"># It *may* just be `var`</span>
                <span class="s0">return </span><span class="s1">_na_for_min_count(values</span><span class="s0">, </span><span class="s1">axis)</span>

            <span class="s0">if </span><span class="s1">_USE_BOTTLENECK </span><span class="s0">and </span><span class="s1">skipna </span><span class="s0">and </span><span class="s1">_bn_ok_dtype(values.dtype</span><span class="s0">, </span><span class="s1">bn_name):</span>
                <span class="s0">if </span><span class="s1">kwds.get(</span><span class="s2">&quot;mask&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s3"># `mask` is not recognised by bottleneck, would raise</span>
                    <span class="s3">#  TypeError if called</span>
                    <span class="s1">kwds.pop(</span><span class="s2">&quot;mask&quot;</span><span class="s0">, None</span><span class="s1">)</span>
                    <span class="s1">result = bn_func(values</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">**kwds)</span>

                    <span class="s3"># prefer to treat inf/-inf as NA, but must compute the func</span>
                    <span class="s3"># twice :(</span>
                    <span class="s0">if </span><span class="s1">_has_infs(result):</span>
                        <span class="s1">result = alt(values</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">**kwds)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">result = alt(values</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">**kwds)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">result = alt(values</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">**kwds)</span>

            <span class="s0">return </span><span class="s1">result</span>

        <span class="s0">return </span><span class="s1">cast(F</span><span class="s0">, </span><span class="s1">f)</span>


<span class="s0">def </span><span class="s1">_bn_ok_dtype(dtype: DtypeObj</span><span class="s0">, </span><span class="s1">name: str) -&gt; bool:</span>
    <span class="s3"># Bottleneck chokes on datetime64, PeriodDtype (or and EA)</span>
    <span class="s0">if not </span><span class="s1">is_object_dtype(dtype) </span><span class="s0">and not </span><span class="s1">needs_i8_conversion(dtype):</span>

        <span class="s3"># GH 15507</span>
        <span class="s3"># bottleneck does not properly upcast during the sum</span>
        <span class="s3"># so can overflow</span>

        <span class="s3"># GH 9422</span>
        <span class="s3"># further we also want to preserve NaN when all elements</span>
        <span class="s3"># are NaN, unlike bottleneck/numpy which consider this</span>
        <span class="s3"># to be 0</span>
        <span class="s0">return </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">[</span><span class="s2">&quot;nansum&quot;</span><span class="s0">, </span><span class="s2">&quot;nanprod&quot;</span><span class="s1">]</span>
    <span class="s0">return False</span>


<span class="s0">def </span><span class="s1">_has_infs(result) -&gt; bool:</span>
    <span class="s0">if </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s0">if </span><span class="s1">result.dtype == </span><span class="s2">&quot;f8&quot; </span><span class="s0">or </span><span class="s1">result.dtype == </span><span class="s2">&quot;f4&quot;</span><span class="s1">:</span>
            <span class="s3"># Note: outside of an nanops-specific test, we always have</span>
            <span class="s3">#  result.ndim == 1, so there is no risk of this ravel making a copy.</span>
            <span class="s0">return </span><span class="s1">lib.has_infs(result.ravel(</span><span class="s2">&quot;K&quot;</span><span class="s1">))</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">np.isinf(result).any()</span>
    <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">NotImplementedError):</span>
        <span class="s3"># if it doesn't support infs, then it can't have infs</span>
        <span class="s0">return False</span>


<span class="s0">def </span><span class="s1">_get_fill_value(</span>
    <span class="s1">dtype: DtypeObj</span><span class="s0">, </span><span class="s1">fill_value: Scalar | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">fill_value_typ=</span><span class="s0">None</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;return the correct fill value for the dtype of the values&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">fill_value </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">fill_value</span>
    <span class="s0">if </span><span class="s1">_na_ok_dtype(dtype):</span>
        <span class="s0">if </span><span class="s1">fill_value_typ </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">np.nan</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">fill_value_typ == </span><span class="s2">&quot;+inf&quot;</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">np.inf</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">-np.inf</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">fill_value_typ == </span><span class="s2">&quot;+inf&quot;</span><span class="s1">:</span>
            <span class="s3"># need the max int here</span>
            <span class="s0">return </span><span class="s1">lib.i8max</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">iNaT</span>


<span class="s0">def </span><span class="s1">_maybe_get_mask(</span>
    <span class="s1">values: np.ndarray</span><span class="s0">, </span><span class="s1">skipna: bool</span><span class="s0">, </span><span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None</span>
<span class="s1">) -&gt; npt.NDArray[np.bool_] | </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Compute a mask if and only if necessary. 
 
    This function will compute a mask iff it is necessary. Otherwise, 
    return the provided mask (potentially None) when a mask does not need to be 
    computed. 
 
    A mask is never necessary if the values array is of boolean or integer 
    dtypes, as these are incapable of storing NaNs. If passing a NaN-capable 
    dtype that is interpretable as either boolean or integer data (eg, 
    timedelta64), a mask must be provided. 
 
    If the skipna parameter is False, a new mask will not be computed. 
 
    The mask is computed using isna() by default. Setting invert=True selects 
    notna() as the masking function. 
 
    Parameters 
    ---------- 
    values : ndarray 
        input array to potentially compute mask for 
    skipna : bool 
        boolean for whether NaNs should be skipped 
    mask : Optional[ndarray] 
        nan-mask if known 
 
    Returns 
    ------- 
    Optional[np.ndarray[bool]] 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">mask </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">is_bool_dtype(values.dtype) </span><span class="s0">or </span><span class="s1">is_integer_dtype(values.dtype):</span>
            <span class="s3"># Boolean data cannot contain nulls, so signal via mask being None</span>
            <span class="s0">return None</span>

        <span class="s0">if </span><span class="s1">skipna </span><span class="s0">or </span><span class="s1">needs_i8_conversion(values.dtype):</span>
            <span class="s1">mask = isna(values)</span>

    <span class="s0">return </span><span class="s1">mask</span>


<span class="s0">def </span><span class="s1">_get_values(</span>
    <span class="s1">values: np.ndarray</span><span class="s0">,</span>
    <span class="s1">skipna: bool</span><span class="s0">,</span>
    <span class="s1">fill_value: Any = </span><span class="s0">None,</span>
    <span class="s1">fill_value_typ: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
<span class="s1">) -&gt; tuple[np.ndarray</span><span class="s0">, </span><span class="s1">npt.NDArray[np.bool_] | </span><span class="s0">None, </span><span class="s1">np.dtype</span><span class="s0">, </span><span class="s1">np.dtype</span><span class="s0">, </span><span class="s1">Any]:</span>
    <span class="s5">&quot;&quot;&quot; 
    Utility to get the values view, mask, dtype, dtype_max, and fill_value. 
 
    If both mask and fill_value/fill_value_typ are not None and skipna is True, 
    the values array will be copied. 
 
    For input arrays of boolean or integer dtypes, copies will only occur if a 
    precomputed mask, a fill_value/fill_value_typ, and skipna=True are 
    provided. 
 
    Parameters 
    ---------- 
    values : ndarray 
        input array to potentially compute mask for 
    skipna : bool 
        boolean for whether NaNs should be skipped 
    fill_value : Any 
        value to fill NaNs with 
    fill_value_typ : str 
        Set to '+inf' or '-inf' to handle dtype-specific infinities 
    mask : Optional[np.ndarray[bool]] 
        nan-mask if known 
 
    Returns 
    ------- 
    values : ndarray 
        Potential copy of input value array 
    mask : Optional[ndarray[bool]] 
        Mask for values, if deemed necessary to compute 
    dtype : np.dtype 
        dtype for values 
    dtype_max : np.dtype 
        platform independent dtype 
    fill_value : Any 
        fill value used 
    &quot;&quot;&quot;</span>
    <span class="s3"># In _get_values is only called from within nanops, and in all cases</span>
    <span class="s3">#  with scalar fill_value.  This guarantee is important for the</span>
    <span class="s3">#  np.where call below</span>
    <span class="s0">assert </span><span class="s1">is_scalar(fill_value)</span>
    <span class="s3"># error: Incompatible types in assignment (expression has type &quot;Union[Any,</span>
    <span class="s3"># Union[ExtensionArray, ndarray]]&quot;, variable has type &quot;ndarray&quot;)</span>
    <span class="s1">values = extract_array(values</span><span class="s0">, </span><span class="s1">extract_numpy=</span><span class="s0">True</span><span class="s1">)  </span><span class="s3"># type: ignore[assignment]</span>

    <span class="s1">mask = _maybe_get_mask(values</span><span class="s0">, </span><span class="s1">skipna</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s1">dtype = values.dtype</span>

    <span class="s1">datetimelike = </span><span class="s0">False</span>
    <span class="s0">if </span><span class="s1">needs_i8_conversion(values.dtype):</span>
        <span class="s3"># changing timedelta64/datetime64 to int64 needs to happen after</span>
        <span class="s3">#  finding `mask` above</span>
        <span class="s1">values = np.asarray(values.view(</span><span class="s2">&quot;i8&quot;</span><span class="s1">))</span>
        <span class="s1">datetimelike = </span><span class="s0">True</span>

    <span class="s1">dtype_ok = _na_ok_dtype(dtype)</span>

    <span class="s3"># get our fill value (in case we need to provide an alternative</span>
    <span class="s3"># dtype for it)</span>
    <span class="s1">fill_value = _get_fill_value(</span>
        <span class="s1">dtype</span><span class="s0">, </span><span class="s1">fill_value=fill_value</span><span class="s0">, </span><span class="s1">fill_value_typ=fill_value_typ</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">skipna </span><span class="s0">and </span><span class="s1">(mask </span><span class="s0">is not None</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(fill_value </span><span class="s0">is not None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">mask.any():</span>
            <span class="s0">if </span><span class="s1">dtype_ok </span><span class="s0">or </span><span class="s1">datetimelike:</span>
                <span class="s1">values = values.copy()</span>
                <span class="s1">np.putmask(values</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">fill_value)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s3"># np.where will promote if needed</span>
                <span class="s1">values = np.where(~mask</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">fill_value)</span>

    <span class="s3"># return a platform independent precision dtype</span>
    <span class="s1">dtype_max = dtype</span>
    <span class="s0">if </span><span class="s1">is_integer_dtype(dtype) </span><span class="s0">or </span><span class="s1">is_bool_dtype(dtype):</span>
        <span class="s1">dtype_max = np.dtype(np.int64)</span>
    <span class="s0">elif </span><span class="s1">is_float_dtype(dtype):</span>
        <span class="s1">dtype_max = np.dtype(np.float64)</span>

    <span class="s0">return </span><span class="s1">values</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">dtype_max</span><span class="s0">, </span><span class="s1">fill_value</span>


<span class="s0">def </span><span class="s1">_na_ok_dtype(dtype: DtypeObj) -&gt; bool:</span>
    <span class="s0">if </span><span class="s1">needs_i8_conversion(dtype):</span>
        <span class="s0">return False</span>
    <span class="s0">return not </span><span class="s1">issubclass(dtype.type</span><span class="s0">, </span><span class="s1">np.integer)</span>


<span class="s0">def </span><span class="s1">_wrap_results(result</span><span class="s0">, </span><span class="s1">dtype: np.dtype</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;wrap our results if needed&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">result </span><span class="s0">is </span><span class="s1">NaT:</span>
        <span class="s0">pass</span>

    <span class="s0">elif </span><span class="s1">is_datetime64_any_dtype(dtype):</span>
        <span class="s0">if </span><span class="s1">fill_value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s3"># GH#24293</span>
            <span class="s1">fill_value = iNaT</span>
        <span class="s0">if not </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
            <span class="s0">assert not </span><span class="s1">isna(fill_value)</span><span class="s0">, </span><span class="s2">&quot;Expected non-null fill_value&quot;</span>
            <span class="s0">if </span><span class="s1">result == fill_value:</span>
                <span class="s1">result = np.nan</span>

            <span class="s0">if </span><span class="s1">isna(result):</span>
                <span class="s1">result = np.datetime64(</span><span class="s2">&quot;NaT&quot;</span><span class="s0">, </span><span class="s2">&quot;ns&quot;</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">result = np.int64(result).view(</span><span class="s2">&quot;datetime64[ns]&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># If we have float dtype, taking a view will give the wrong result</span>
            <span class="s1">result = result.astype(dtype)</span>
    <span class="s0">elif </span><span class="s1">is_timedelta64_dtype(dtype):</span>
        <span class="s0">if not </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
            <span class="s0">if </span><span class="s1">result == fill_value:</span>
                <span class="s1">result = np.nan</span>

            <span class="s3"># raise if we have a timedelta64[ns] which is too large</span>
            <span class="s0">if </span><span class="s1">np.fabs(result) &gt; lib.i8max:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;overflow in timedelta operation&quot;</span><span class="s1">)</span>

            <span class="s1">result = Timedelta(result</span><span class="s0">, </span><span class="s1">unit=</span><span class="s2">&quot;ns&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = result.astype(</span><span class="s2">&quot;m8[ns]&quot;</span><span class="s1">).view(dtype)</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">_datetimelike_compat(func: F) -&gt; F:</span>
    <span class="s5">&quot;&quot;&quot; 
    If we have datetime64 or timedelta64 values, ensure we have a correct 
    mask before calling the wrapped function, then cast back afterwards. 
    &quot;&quot;&quot;</span>

    <span class="s1">@functools.wraps(func)</span>
    <span class="s0">def </span><span class="s1">new_func(</span>
        <span class="s1">values: np.ndarray</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">axis: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">skipna: bool = </span><span class="s0">True,</span>
        <span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s1">orig_values = values</span>

        <span class="s1">datetimelike = values.dtype.kind </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;m&quot;</span><span class="s0">, </span><span class="s2">&quot;M&quot;</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">datetimelike </span><span class="s0">and </span><span class="s1">mask </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">mask = isna(values)</span>

        <span class="s1">result = func(values</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">mask=mask</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s0">if </span><span class="s1">datetimelike:</span>
            <span class="s1">result = _wrap_results(result</span><span class="s0">, </span><span class="s1">orig_values.dtype</span><span class="s0">, </span><span class="s1">fill_value=iNaT)</span>
            <span class="s0">if not </span><span class="s1">skipna:</span>
                <span class="s0">assert </span><span class="s1">mask </span><span class="s0">is not None  </span><span class="s3"># checked above</span>
                <span class="s1">result = _mask_datetimelike_result(result</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">orig_values)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">return </span><span class="s1">cast(F</span><span class="s0">, </span><span class="s1">new_func)</span>


<span class="s0">def </span><span class="s1">_na_for_min_count(values: np.ndarray</span><span class="s0">, </span><span class="s1">axis: int | </span><span class="s0">None</span><span class="s1">) -&gt; Scalar | np.ndarray:</span>
    <span class="s5">&quot;&quot;&quot; 
    Return the missing value for `values`. 
 
    Parameters 
    ---------- 
    values : ndarray 
    axis : int or None 
        axis for the reduction, required if values.ndim &gt; 1. 
 
    Returns 
    ------- 
    result : scalar or ndarray 
        For 1-D values, returns a scalar of the correct missing type. 
        For 2-D values, returns a 1-D array where each element is missing. 
    &quot;&quot;&quot;</span>
    <span class="s3"># we either return np.nan or pd.NaT</span>
    <span class="s0">if </span><span class="s1">is_numeric_dtype(values):</span>
        <span class="s1">values = values.astype(</span><span class="s2">&quot;float64&quot;</span><span class="s1">)</span>
    <span class="s1">fill_value = na_value_for_dtype(values.dtype)</span>

    <span class="s0">if </span><span class="s1">values.ndim == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">fill_value</span>
    <span class="s0">elif </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">fill_value</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result_shape = values.shape[:axis] + values.shape[axis + </span><span class="s4">1 </span><span class="s1">:]</span>

        <span class="s0">return </span><span class="s1">np.full(result_shape</span><span class="s0">, </span><span class="s1">fill_value</span><span class="s0">, </span><span class="s1">dtype=values.dtype)</span>


<span class="s0">def </span><span class="s1">maybe_operate_rowwise(func: F) -&gt; F:</span>
    <span class="s5">&quot;&quot;&quot; 
    NumPy operations on C-contiguous ndarrays with axis=1 can be 
    very slow if axis 1 &gt;&gt; axis 0. 
    Operate row-by-row and concatenate the results. 
    &quot;&quot;&quot;</span>

    <span class="s1">@functools.wraps(func)</span>
    <span class="s0">def </span><span class="s1">newfunc(values: np.ndarray</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">axis: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">axis == </span><span class="s4">1</span>
            <span class="s0">and </span><span class="s1">values.ndim == </span><span class="s4">2</span>
            <span class="s0">and </span><span class="s1">values.flags[</span><span class="s2">&quot;C_CONTIGUOUS&quot;</span><span class="s1">]</span>
            <span class="s3"># only takes this path for wide arrays (long dataframes), for threshold see</span>
            <span class="s3"># https://github.com/pandas-dev/pandas/pull/43311#issuecomment-974891737</span>
            <span class="s0">and </span><span class="s1">(values.shape[</span><span class="s4">1</span><span class="s1">] / </span><span class="s4">1000</span><span class="s1">) &gt; values.shape[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s0">and </span><span class="s1">values.dtype != object</span>
            <span class="s0">and </span><span class="s1">values.dtype != bool</span>
        <span class="s1">):</span>
            <span class="s1">arrs = list(values)</span>
            <span class="s0">if </span><span class="s1">kwargs.get(</span><span class="s2">&quot;mask&quot;</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">mask = kwargs.pop(</span><span class="s2">&quot;mask&quot;</span><span class="s1">)</span>
                <span class="s1">results = [</span>
                    <span class="s1">func(arrs[i]</span><span class="s0">, </span><span class="s1">mask=mask[i]</span><span class="s0">, </span><span class="s1">**kwargs) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(arrs))</span>
                <span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">results = [func(x</span><span class="s0">, </span><span class="s1">**kwargs) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">arrs]</span>
            <span class="s0">return </span><span class="s1">np.array(results)</span>

        <span class="s0">return </span><span class="s1">func(values</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">return </span><span class="s1">cast(F</span><span class="s0">, </span><span class="s1">newfunc)</span>


<span class="s0">def </span><span class="s1">nanany(</span>
    <span class="s1">values: np.ndarray</span><span class="s0">,</span>
    <span class="s1">*</span><span class="s0">,</span>
    <span class="s1">axis: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">skipna: bool = </span><span class="s0">True,</span>
    <span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
<span class="s1">) -&gt; bool:</span>
    <span class="s5">&quot;&quot;&quot; 
    Check if any elements along an axis evaluate to True. 
 
    Parameters 
    ---------- 
    values : ndarray 
    axis : int, optional 
    skipna : bool, default True 
    mask : ndarray[bool], optional 
        nan-mask if known 
 
    Returns 
    ------- 
    result : bool 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import pandas.core.nanops as nanops 
    &gt;&gt;&gt; s = pd.Series([1, 2]) 
    &gt;&gt;&gt; nanops.nanany(s) 
    True 
 
    &gt;&gt;&gt; import pandas.core.nanops as nanops 
    &gt;&gt;&gt; s = pd.Series([np.nan]) 
    &gt;&gt;&gt; nanops.nanany(s) 
    False 
    &quot;&quot;&quot;</span>
    <span class="s1">values</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_ = _get_values(values</span><span class="s0">, </span><span class="s1">skipna</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s0">False, </span><span class="s1">mask=mask)</span>

    <span class="s3"># For object type, any won't necessarily return</span>
    <span class="s3"># boolean values (numpy/numpy#4352)</span>
    <span class="s0">if </span><span class="s1">is_object_dtype(values):</span>
        <span class="s1">values = values.astype(bool)</span>

    <span class="s3"># error: Incompatible return value type (got &quot;Union[bool_, ndarray]&quot;, expected</span>
    <span class="s3"># &quot;bool&quot;)</span>
    <span class="s0">return </span><span class="s1">values.any(axis)  </span><span class="s3"># type: ignore[return-value]</span>


<span class="s0">def </span><span class="s1">nanall(</span>
    <span class="s1">values: np.ndarray</span><span class="s0">,</span>
    <span class="s1">*</span><span class="s0">,</span>
    <span class="s1">axis: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">skipna: bool = </span><span class="s0">True,</span>
    <span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
<span class="s1">) -&gt; bool:</span>
    <span class="s5">&quot;&quot;&quot; 
    Check if all elements along an axis evaluate to True. 
 
    Parameters 
    ---------- 
    values : ndarray 
    axis : int, optional 
    skipna : bool, default True 
    mask : ndarray[bool], optional 
        nan-mask if known 
 
    Returns 
    ------- 
    result : bool 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import pandas.core.nanops as nanops 
    &gt;&gt;&gt; s = pd.Series([1, 2, np.nan]) 
    &gt;&gt;&gt; nanops.nanall(s) 
    True 
 
    &gt;&gt;&gt; import pandas.core.nanops as nanops 
    &gt;&gt;&gt; s = pd.Series([1, 0]) 
    &gt;&gt;&gt; nanops.nanall(s) 
    False 
    &quot;&quot;&quot;</span>
    <span class="s1">values</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_ = _get_values(values</span><span class="s0">, </span><span class="s1">skipna</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s0">True, </span><span class="s1">mask=mask)</span>

    <span class="s3"># For object type, all won't necessarily return</span>
    <span class="s3"># boolean values (numpy/numpy#4352)</span>
    <span class="s0">if </span><span class="s1">is_object_dtype(values):</span>
        <span class="s1">values = values.astype(bool)</span>

    <span class="s3"># error: Incompatible return value type (got &quot;Union[bool_, ndarray]&quot;, expected</span>
    <span class="s3"># &quot;bool&quot;)</span>
    <span class="s0">return </span><span class="s1">values.all(axis)  </span><span class="s3"># type: ignore[return-value]</span>


<span class="s1">@disallow(</span><span class="s2">&quot;M8&quot;</span><span class="s1">)</span>
<span class="s1">@_datetimelike_compat</span>
<span class="s1">@maybe_operate_rowwise</span>
<span class="s0">def </span><span class="s1">nansum(</span>
    <span class="s1">values: np.ndarray</span><span class="s0">,</span>
    <span class="s1">*</span><span class="s0">,</span>
    <span class="s1">axis: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">skipna: bool = </span><span class="s0">True,</span>
    <span class="s1">min_count: int = </span><span class="s4">0</span><span class="s0">,</span>
    <span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
<span class="s1">) -&gt; float:</span>
    <span class="s5">&quot;&quot;&quot; 
    Sum the elements along an axis ignoring NaNs 
 
    Parameters 
    ---------- 
    values : ndarray[dtype] 
    axis : int, optional 
    skipna : bool, default True 
    min_count: int, default 0 
    mask : ndarray[bool], optional 
        nan-mask if known 
 
    Returns 
    ------- 
    result : dtype 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import pandas.core.nanops as nanops 
    &gt;&gt;&gt; s = pd.Series([1, 2, np.nan]) 
    &gt;&gt;&gt; nanops.nansum(s) 
    3.0 
    &quot;&quot;&quot;</span>
    <span class="s1">values</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">dtype_max</span><span class="s0">, </span><span class="s1">_ = _get_values(</span>
        <span class="s1">values</span><span class="s0">, </span><span class="s1">skipna</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">mask=mask</span>
    <span class="s1">)</span>
    <span class="s1">dtype_sum = dtype_max</span>
    <span class="s0">if </span><span class="s1">is_float_dtype(dtype):</span>
        <span class="s1">dtype_sum = dtype</span>
    <span class="s0">elif </span><span class="s1">is_timedelta64_dtype(dtype):</span>
        <span class="s1">dtype_sum = np.dtype(np.float64)</span>

    <span class="s1">the_sum = values.sum(axis</span><span class="s0">, </span><span class="s1">dtype=dtype_sum)</span>
    <span class="s1">the_sum = _maybe_null_out(the_sum</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">values.shape</span><span class="s0">, </span><span class="s1">min_count=min_count)</span>

    <span class="s0">return </span><span class="s1">the_sum</span>


<span class="s0">def </span><span class="s1">_mask_datetimelike_result(</span>
    <span class="s1">result: np.ndarray | np.datetime64 | np.timedelta64</span><span class="s0">,</span>
    <span class="s1">axis: int | </span><span class="s0">None,</span>
    <span class="s1">mask: npt.NDArray[np.bool_]</span><span class="s0">,</span>
    <span class="s1">orig_values: np.ndarray</span><span class="s0">,</span>
<span class="s1">) -&gt; np.ndarray | np.datetime64 | np.timedelta64 | NaTType:</span>
    <span class="s0">if </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s3"># we need to apply the mask</span>
        <span class="s1">result = result.astype(</span><span class="s2">&quot;i8&quot;</span><span class="s1">).view(orig_values.dtype)</span>
        <span class="s1">axis_mask = mask.any(axis=axis)</span>
        <span class="s3"># error: Unsupported target for indexed assignment (&quot;Union[ndarray[Any, Any],</span>
        <span class="s3"># datetime64, timedelta64]&quot;)</span>
        <span class="s1">result[axis_mask] = iNaT  </span><span class="s3"># type: ignore[index]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">mask.any():</span>
            <span class="s0">return </span><span class="s1">NaT</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s1">@disallow(PeriodDtype)</span>
<span class="s1">@bottleneck_switch()</span>
<span class="s1">@_datetimelike_compat</span>
<span class="s0">def </span><span class="s1">nanmean(</span>
    <span class="s1">values: np.ndarray</span><span class="s0">,</span>
    <span class="s1">*</span><span class="s0">,</span>
    <span class="s1">axis: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">skipna: bool = </span><span class="s0">True,</span>
    <span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
<span class="s1">) -&gt; float:</span>
    <span class="s5">&quot;&quot;&quot; 
    Compute the mean of the element along an axis ignoring NaNs 
 
    Parameters 
    ---------- 
    values : ndarray 
    axis : int, optional 
    skipna : bool, default True 
    mask : ndarray[bool], optional 
        nan-mask if known 
 
    Returns 
    ------- 
    float 
        Unless input is a float array, in which case use the same 
        precision as the input array. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import pandas.core.nanops as nanops 
    &gt;&gt;&gt; s = pd.Series([1, 2, np.nan]) 
    &gt;&gt;&gt; nanops.nanmean(s) 
    1.5 
    &quot;&quot;&quot;</span>
    <span class="s1">values</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">dtype_max</span><span class="s0">, </span><span class="s1">_ = _get_values(</span>
        <span class="s1">values</span><span class="s0">, </span><span class="s1">skipna</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">mask=mask</span>
    <span class="s1">)</span>
    <span class="s1">dtype_sum = dtype_max</span>
    <span class="s1">dtype_count = np.dtype(np.float64)</span>

    <span class="s3"># not using needs_i8_conversion because that includes period</span>
    <span class="s0">if </span><span class="s1">dtype.kind </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;m&quot;</span><span class="s0">, </span><span class="s2">&quot;M&quot;</span><span class="s1">]:</span>
        <span class="s1">dtype_sum = np.dtype(np.float64)</span>
    <span class="s0">elif </span><span class="s1">is_integer_dtype(dtype):</span>
        <span class="s1">dtype_sum = np.dtype(np.float64)</span>
    <span class="s0">elif </span><span class="s1">is_float_dtype(dtype):</span>
        <span class="s1">dtype_sum = dtype</span>
        <span class="s1">dtype_count = dtype</span>

    <span class="s1">count = _get_counts(values.shape</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">dtype=dtype_count)</span>
    <span class="s1">the_sum = _ensure_numeric(values.sum(axis</span><span class="s0">, </span><span class="s1">dtype=dtype_sum))</span>

    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is not None and </span><span class="s1">getattr(the_sum</span><span class="s0">, </span><span class="s2">&quot;ndim&quot;</span><span class="s0">, False</span><span class="s1">):</span>
        <span class="s1">count = cast(np.ndarray</span><span class="s0">, </span><span class="s1">count)</span>
        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s3"># suppress division by zero warnings</span>
            <span class="s1">the_mean = the_sum / count</span>
        <span class="s1">ct_mask = count == </span><span class="s4">0</span>
        <span class="s0">if </span><span class="s1">ct_mask.any():</span>
            <span class="s1">the_mean[ct_mask] = np.nan</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">the_mean = the_sum / count </span><span class="s0">if </span><span class="s1">count &gt; </span><span class="s4">0 </span><span class="s0">else </span><span class="s1">np.nan</span>

    <span class="s0">return </span><span class="s1">the_mean</span>


<span class="s1">@bottleneck_switch()</span>
<span class="s0">def </span><span class="s1">nanmedian(values</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None, </span><span class="s1">skipna=</span><span class="s0">True, </span><span class="s1">mask=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Parameters 
    ---------- 
    values : ndarray 
    axis : int, optional 
    skipna : bool, default True 
    mask : ndarray[bool], optional 
        nan-mask if known 
 
    Returns 
    ------- 
    result : float 
        Unless input is a float array, in which case use the same 
        precision as the input array. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import pandas.core.nanops as nanops 
    &gt;&gt;&gt; s = pd.Series([1, np.nan, 2, 2]) 
    &gt;&gt;&gt; nanops.nanmedian(s) 
    2.0 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">get_median(x):</span>
        <span class="s1">mask = notna(x)</span>
        <span class="s0">if not </span><span class="s1">skipna </span><span class="s0">and not </span><span class="s1">mask.all():</span>
            <span class="s0">return </span><span class="s1">np.nan</span>
        <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s3"># Suppress RuntimeWarning about All-NaN slice</span>
            <span class="s1">warnings.filterwarnings(</span><span class="s2">&quot;ignore&quot;</span><span class="s0">, </span><span class="s2">&quot;All-NaN slice encountered&quot;</span><span class="s1">)</span>
            <span class="s1">res = np.nanmedian(x[mask])</span>
        <span class="s0">return </span><span class="s1">res</span>

    <span class="s1">values</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_ = _get_values(values</span><span class="s0">, </span><span class="s1">skipna</span><span class="s0">, </span><span class="s1">mask=mask)</span>
    <span class="s0">if not </span><span class="s1">is_float_dtype(values.dtype):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">values = values.astype(</span><span class="s2">&quot;f8&quot;</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">err:</span>
            <span class="s3"># e.g. &quot;could not convert string to float: 'a'&quot;</span>
            <span class="s0">raise </span><span class="s1">TypeError(str(err)) </span><span class="s0">from </span><span class="s1">err</span>
        <span class="s0">if </span><span class="s1">mask </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">values[mask] = np.nan</span>

    <span class="s1">notempty = values.size</span>

    <span class="s3"># an array from a frame</span>
    <span class="s0">if </span><span class="s1">values.ndim &gt; </span><span class="s4">1 </span><span class="s0">and </span><span class="s1">axis </span><span class="s0">is not None</span><span class="s1">:</span>

        <span class="s3"># there's a non-empty array to apply over otherwise numpy raises</span>
        <span class="s0">if </span><span class="s1">notempty:</span>
            <span class="s0">if not </span><span class="s1">skipna:</span>
                <span class="s1">res = np.apply_along_axis(get_median</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">values)</span>

            <span class="s0">else</span><span class="s1">:</span>
                <span class="s3"># fastpath for the skipna case</span>
                <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
                    <span class="s3"># Suppress RuntimeWarning about All-NaN slice</span>
                    <span class="s1">warnings.filterwarnings(</span><span class="s2">&quot;ignore&quot;</span><span class="s0">, </span><span class="s2">&quot;All-NaN slice encountered&quot;</span><span class="s1">)</span>
                    <span class="s1">res = np.nanmedian(values</span><span class="s0">, </span><span class="s1">axis)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># must return the correct shape, but median is not defined for the</span>
            <span class="s3"># empty set so return nans of shape &quot;everything but the passed axis&quot;</span>
            <span class="s3"># since &quot;axis&quot; is where the reduction would occur if we had a nonempty</span>
            <span class="s3"># array</span>
            <span class="s1">res = get_empty_reduction_result(values.shape</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">np.float_</span><span class="s0">, </span><span class="s1">np.nan)</span>

    <span class="s0">else</span><span class="s1">:</span>
        <span class="s3"># otherwise return a scalar value</span>
        <span class="s1">res = get_median(values) </span><span class="s0">if </span><span class="s1">notempty </span><span class="s0">else </span><span class="s1">np.nan</span>
    <span class="s0">return </span><span class="s1">_wrap_results(res</span><span class="s0">, </span><span class="s1">dtype)</span>


<span class="s0">def </span><span class="s1">get_empty_reduction_result(</span>
    <span class="s1">shape: tuple[int</span><span class="s0">, </span><span class="s1">...]</span><span class="s0">,</span>
    <span class="s1">axis: int</span><span class="s0">,</span>
    <span class="s1">dtype: np.dtype | type[np.floating]</span><span class="s0">,</span>
    <span class="s1">fill_value: Any</span><span class="s0">,</span>
<span class="s1">) -&gt; np.ndarray:</span>
    <span class="s5">&quot;&quot;&quot; 
    The result from a reduction on an empty ndarray. 
 
    Parameters 
    ---------- 
    shape : Tuple[int] 
    axis : int 
    dtype : np.dtype 
    fill_value : Any 
 
    Returns 
    ------- 
    np.ndarray 
    &quot;&quot;&quot;</span>
    <span class="s1">shp = np.array(shape)</span>
    <span class="s1">dims = np.arange(len(shape))</span>
    <span class="s1">ret = np.empty(shp[dims != axis]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">ret.fill(fill_value)</span>
    <span class="s0">return </span><span class="s1">ret</span>


<span class="s0">def </span><span class="s1">_get_counts_nanvar(</span>
    <span class="s1">values_shape: Shape</span><span class="s0">,</span>
    <span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None,</span>
    <span class="s1">axis: int | </span><span class="s0">None,</span>
    <span class="s1">ddof: int</span><span class="s0">,</span>
    <span class="s1">dtype: np.dtype = np.dtype(np.float64)</span><span class="s0">,</span>
<span class="s1">) -&gt; tuple[int | float | np.ndarray</span><span class="s0">, </span><span class="s1">int | float | np.ndarray]:</span>
    <span class="s5">&quot;&quot;&quot; 
    Get the count of non-null values along an axis, accounting 
    for degrees of freedom. 
 
    Parameters 
    ---------- 
    values_shape : Tuple[int, ...] 
        shape tuple from values ndarray, used if mask is None 
    mask : Optional[ndarray[bool]] 
        locations in values that should be considered missing 
    axis : Optional[int] 
        axis to count along 
    ddof : int 
        degrees of freedom 
    dtype : type, optional 
        type to use for count 
 
    Returns 
    ------- 
    count : int, np.nan or np.ndarray 
    d : int, np.nan or np.ndarray 
    &quot;&quot;&quot;</span>
    <span class="s1">count = _get_counts(values_shape</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">d = count - dtype.type(ddof)</span>

    <span class="s3"># always return NaN, never inf</span>
    <span class="s0">if </span><span class="s1">is_scalar(count):</span>
        <span class="s0">if </span><span class="s1">count &lt;= ddof:</span>
            <span class="s1">count = np.nan</span>
            <span class="s1">d = np.nan</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s3"># count is not narrowed by is_scalar check</span>
        <span class="s1">count = cast(np.ndarray</span><span class="s0">, </span><span class="s1">count)</span>
        <span class="s1">mask = count &lt;= ddof</span>
        <span class="s0">if </span><span class="s1">mask.any():</span>
            <span class="s1">np.putmask(d</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">np.nan)</span>
            <span class="s1">np.putmask(count</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">np.nan)</span>
    <span class="s0">return </span><span class="s1">count</span><span class="s0">, </span><span class="s1">d</span>


<span class="s1">@bottleneck_switch(ddof=</span><span class="s4">1</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">nanstd(values</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None, </span><span class="s1">skipna=</span><span class="s0">True, </span><span class="s1">ddof=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">mask=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Compute the standard deviation along given axis while ignoring NaNs 
 
    Parameters 
    ---------- 
    values : ndarray 
    axis : int, optional 
    skipna : bool, default True 
    ddof : int, default 1 
        Delta Degrees of Freedom. The divisor used in calculations is N - ddof, 
        where N represents the number of elements. 
    mask : ndarray[bool], optional 
        nan-mask if known 
 
    Returns 
    ------- 
    result : float 
        Unless input is a float array, in which case use the same 
        precision as the input array. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import pandas.core.nanops as nanops 
    &gt;&gt;&gt; s = pd.Series([1, np.nan, 2, 3]) 
    &gt;&gt;&gt; nanops.nanstd(s) 
    1.0 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">values.dtype == </span><span class="s2">&quot;M8[ns]&quot;</span><span class="s1">:</span>
        <span class="s1">values = values.view(</span><span class="s2">&quot;m8[ns]&quot;</span><span class="s1">)</span>

    <span class="s1">orig_dtype = values.dtype</span>
    <span class="s1">values</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_ = _get_values(values</span><span class="s0">, </span><span class="s1">skipna</span><span class="s0">, </span><span class="s1">mask=mask)</span>

    <span class="s1">result = np.sqrt(nanvar(values</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">ddof=ddof</span><span class="s0">, </span><span class="s1">mask=mask))</span>
    <span class="s0">return </span><span class="s1">_wrap_results(result</span><span class="s0">, </span><span class="s1">orig_dtype)</span>


<span class="s1">@disallow(</span><span class="s2">&quot;M8&quot;</span><span class="s0">, </span><span class="s2">&quot;m8&quot;</span><span class="s1">)</span>
<span class="s1">@bottleneck_switch(ddof=</span><span class="s4">1</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">nanvar(values</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None, </span><span class="s1">skipna=</span><span class="s0">True, </span><span class="s1">ddof=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">mask=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Compute the variance along given axis while ignoring NaNs 
 
    Parameters 
    ---------- 
    values : ndarray 
    axis : int, optional 
    skipna : bool, default True 
    ddof : int, default 1 
        Delta Degrees of Freedom. The divisor used in calculations is N - ddof, 
        where N represents the number of elements. 
    mask : ndarray[bool], optional 
        nan-mask if known 
 
    Returns 
    ------- 
    result : float 
        Unless input is a float array, in which case use the same 
        precision as the input array. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import pandas.core.nanops as nanops 
    &gt;&gt;&gt; s = pd.Series([1, np.nan, 2, 3]) 
    &gt;&gt;&gt; nanops.nanvar(s) 
    1.0 
    &quot;&quot;&quot;</span>
    <span class="s1">values = extract_array(values</span><span class="s0">, </span><span class="s1">extract_numpy=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">dtype = values.dtype</span>
    <span class="s1">mask = _maybe_get_mask(values</span><span class="s0">, </span><span class="s1">skipna</span><span class="s0">, </span><span class="s1">mask)</span>
    <span class="s0">if </span><span class="s1">is_any_int_dtype(dtype):</span>
        <span class="s1">values = values.astype(</span><span class="s2">&quot;f8&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">mask </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">values[mask] = np.nan</span>

    <span class="s0">if </span><span class="s1">is_float_dtype(values.dtype):</span>
        <span class="s1">count</span><span class="s0">, </span><span class="s1">d = _get_counts_nanvar(values.shape</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">ddof</span><span class="s0">, </span><span class="s1">values.dtype)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">count</span><span class="s0">, </span><span class="s1">d = _get_counts_nanvar(values.shape</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">ddof)</span>

    <span class="s0">if </span><span class="s1">skipna </span><span class="s0">and </span><span class="s1">mask </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">values = values.copy()</span>
        <span class="s1">np.putmask(values</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3"># xref GH10242</span>
    <span class="s3"># Compute variance via two-pass algorithm, which is stable against</span>
    <span class="s3"># cancellation errors and relatively accurate for small numbers of</span>
    <span class="s3"># observations.</span>
    <span class="s3">#</span>
    <span class="s3"># See https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance</span>
    <span class="s1">avg = _ensure_numeric(values.sum(axis=axis</span><span class="s0">, </span><span class="s1">dtype=np.float64)) / count</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">avg = np.expand_dims(avg</span><span class="s0">, </span><span class="s1">axis)</span>
    <span class="s1">sqr = _ensure_numeric((avg - values) ** </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">mask </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">np.putmask(sqr</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">result = sqr.sum(axis=axis</span><span class="s0">, </span><span class="s1">dtype=np.float64) / d</span>

    <span class="s3"># Return variance as np.float64 (the datatype used in the accumulator),</span>
    <span class="s3"># unless we were dealing with a float array, in which case use the same</span>
    <span class="s3"># precision as the original values array.</span>
    <span class="s0">if </span><span class="s1">is_float_dtype(dtype):</span>
        <span class="s1">result = result.astype(dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s1">@disallow(</span><span class="s2">&quot;M8&quot;</span><span class="s0">, </span><span class="s2">&quot;m8&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">nansem(</span>
    <span class="s1">values: np.ndarray</span><span class="s0">,</span>
    <span class="s1">*</span><span class="s0">,</span>
    <span class="s1">axis: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">skipna: bool = </span><span class="s0">True,</span>
    <span class="s1">ddof: int = </span><span class="s4">1</span><span class="s0">,</span>
    <span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
<span class="s1">) -&gt; float:</span>
    <span class="s5">&quot;&quot;&quot; 
    Compute the standard error in the mean along given axis while ignoring NaNs 
 
    Parameters 
    ---------- 
    values : ndarray 
    axis : int, optional 
    skipna : bool, default True 
    ddof : int, default 1 
        Delta Degrees of Freedom. The divisor used in calculations is N - ddof, 
        where N represents the number of elements. 
    mask : ndarray[bool], optional 
        nan-mask if known 
 
    Returns 
    ------- 
    result : float64 
        Unless input is a float array, in which case use the same 
        precision as the input array. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import pandas.core.nanops as nanops 
    &gt;&gt;&gt; s = pd.Series([1, np.nan, 2, 3]) 
    &gt;&gt;&gt; nanops.nansem(s) 
     0.5773502691896258 
    &quot;&quot;&quot;</span>
    <span class="s3"># This checks if non-numeric-like data is passed with numeric_only=False</span>
    <span class="s3"># and raises a TypeError otherwise</span>
    <span class="s1">nanvar(values</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">ddof=ddof</span><span class="s0">, </span><span class="s1">mask=mask)</span>

    <span class="s1">mask = _maybe_get_mask(values</span><span class="s0">, </span><span class="s1">skipna</span><span class="s0">, </span><span class="s1">mask)</span>
    <span class="s0">if not </span><span class="s1">is_float_dtype(values.dtype):</span>
        <span class="s1">values = values.astype(</span><span class="s2">&quot;f8&quot;</span><span class="s1">)</span>

    <span class="s1">count</span><span class="s0">, </span><span class="s1">_ = _get_counts_nanvar(values.shape</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">ddof</span><span class="s0">, </span><span class="s1">values.dtype)</span>
    <span class="s1">var = nanvar(values</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">ddof=ddof)</span>

    <span class="s0">return </span><span class="s1">np.sqrt(var) / np.sqrt(count)</span>


<span class="s0">def </span><span class="s1">_nanminmax(meth</span><span class="s0">, </span><span class="s1">fill_value_typ):</span>
    <span class="s1">@bottleneck_switch(name=</span><span class="s2">&quot;nan&quot; </span><span class="s1">+ meth)</span>
    <span class="s1">@_datetimelike_compat</span>
    <span class="s0">def </span><span class="s1">reduction(</span>
        <span class="s1">values: np.ndarray</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">axis: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">skipna: bool = </span><span class="s0">True,</span>
        <span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">) -&gt; Dtype:</span>

        <span class="s1">values</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">dtype_max</span><span class="s0">, </span><span class="s1">fill_value = _get_values(</span>
            <span class="s1">values</span><span class="s0">, </span><span class="s1">skipna</span><span class="s0">, </span><span class="s1">fill_value_typ=fill_value_typ</span><span class="s0">, </span><span class="s1">mask=mask</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">(axis </span><span class="s0">is not None and </span><span class="s1">values.shape[axis] == </span><span class="s4">0</span><span class="s1">) </span><span class="s0">or </span><span class="s1">values.size == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">result = getattr(values</span><span class="s0">, </span><span class="s1">meth)(axis</span><span class="s0">, </span><span class="s1">dtype=dtype_max)</span>
                <span class="s1">result.fill(np.nan)</span>
            <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">TypeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
                <span class="s1">result = np.nan</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = getattr(values</span><span class="s0">, </span><span class="s1">meth)(axis)</span>

        <span class="s1">result = _maybe_null_out(result</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">values.shape)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">return </span><span class="s1">reduction</span>


<span class="s1">nanmin = _nanminmax(</span><span class="s2">&quot;min&quot;</span><span class="s0">, </span><span class="s1">fill_value_typ=</span><span class="s2">&quot;+inf&quot;</span><span class="s1">)</span>
<span class="s1">nanmax = _nanminmax(</span><span class="s2">&quot;max&quot;</span><span class="s0">, </span><span class="s1">fill_value_typ=</span><span class="s2">&quot;-inf&quot;</span><span class="s1">)</span>


<span class="s1">@disallow(</span><span class="s2">&quot;O&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">nanargmax(</span>
    <span class="s1">values: np.ndarray</span><span class="s0">,</span>
    <span class="s1">*</span><span class="s0">,</span>
    <span class="s1">axis: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">skipna: bool = </span><span class="s0">True,</span>
    <span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
<span class="s1">) -&gt; int | np.ndarray:</span>
    <span class="s5">&quot;&quot;&quot; 
    Parameters 
    ---------- 
    values : ndarray 
    axis : int, optional 
    skipna : bool, default True 
    mask : ndarray[bool], optional 
        nan-mask if known 
 
    Returns 
    ------- 
    result : int or ndarray[int] 
        The index/indices  of max value in specified axis or -1 in the NA case 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import pandas.core.nanops as nanops 
    &gt;&gt;&gt; arr = np.array([1, 2, 3, np.nan, 4]) 
    &gt;&gt;&gt; nanops.nanargmax(arr) 
    4 
 
    &gt;&gt;&gt; arr = np.array(range(12), dtype=np.float64).reshape(4, 3) 
    &gt;&gt;&gt; arr[2:, 2] = np.nan 
    &gt;&gt;&gt; arr 
    array([[ 0.,  1.,  2.], 
           [ 3.,  4.,  5.], 
           [ 6.,  7., nan], 
           [ 9., 10., nan]]) 
    &gt;&gt;&gt; nanops.nanargmax(arr, axis=1) 
    array([2, 2, 1, 1]) 
    &quot;&quot;&quot;</span>
    <span class="s1">values</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_ = _get_values(values</span><span class="s0">, True, </span><span class="s1">fill_value_typ=</span><span class="s2">&quot;-inf&quot;</span><span class="s0">, </span><span class="s1">mask=mask)</span>
    <span class="s3"># error: Need type annotation for 'result'</span>
    <span class="s1">result = values.argmax(axis)  </span><span class="s3"># type: ignore[var-annotated]</span>
    <span class="s1">result = _maybe_arg_null_out(result</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">skipna)</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s1">@disallow(</span><span class="s2">&quot;O&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">nanargmin(</span>
    <span class="s1">values: np.ndarray</span><span class="s0">,</span>
    <span class="s1">*</span><span class="s0">,</span>
    <span class="s1">axis: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">skipna: bool = </span><span class="s0">True,</span>
    <span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
<span class="s1">) -&gt; int | np.ndarray:</span>
    <span class="s5">&quot;&quot;&quot; 
    Parameters 
    ---------- 
    values : ndarray 
    axis : int, optional 
    skipna : bool, default True 
    mask : ndarray[bool], optional 
        nan-mask if known 
 
    Returns 
    ------- 
    result : int or ndarray[int] 
        The index/indices of min value in specified axis or -1 in the NA case 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import pandas.core.nanops as nanops 
    &gt;&gt;&gt; arr = np.array([1, 2, 3, np.nan, 4]) 
    &gt;&gt;&gt; nanops.nanargmin(arr) 
    0 
 
    &gt;&gt;&gt; arr = np.array(range(12), dtype=np.float64).reshape(4, 3) 
    &gt;&gt;&gt; arr[2:, 0] = np.nan 
    &gt;&gt;&gt; arr 
    array([[ 0.,  1.,  2.], 
           [ 3.,  4.,  5.], 
           [nan,  7.,  8.], 
           [nan, 10., 11.]]) 
    &gt;&gt;&gt; nanops.nanargmin(arr, axis=1) 
    array([0, 0, 1, 1]) 
    &quot;&quot;&quot;</span>
    <span class="s1">values</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_ = _get_values(values</span><span class="s0">, True, </span><span class="s1">fill_value_typ=</span><span class="s2">&quot;+inf&quot;</span><span class="s0">, </span><span class="s1">mask=mask)</span>
    <span class="s3"># error: Need type annotation for 'result'</span>
    <span class="s1">result = values.argmin(axis)  </span><span class="s3"># type: ignore[var-annotated]</span>
    <span class="s1">result = _maybe_arg_null_out(result</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">skipna)</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s1">@disallow(</span><span class="s2">&quot;M8&quot;</span><span class="s0">, </span><span class="s2">&quot;m8&quot;</span><span class="s1">)</span>
<span class="s1">@maybe_operate_rowwise</span>
<span class="s0">def </span><span class="s1">nanskew(</span>
    <span class="s1">values: np.ndarray</span><span class="s0">,</span>
    <span class="s1">*</span><span class="s0">,</span>
    <span class="s1">axis: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">skipna: bool = </span><span class="s0">True,</span>
    <span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
<span class="s1">) -&gt; float:</span>
    <span class="s5">&quot;&quot;&quot; 
    Compute the sample skewness. 
 
    The statistic computed here is the adjusted Fisher-Pearson standardized 
    moment coefficient G1. The algorithm computes this coefficient directly 
    from the second and third central moment. 
 
    Parameters 
    ---------- 
    values : ndarray 
    axis : int, optional 
    skipna : bool, default True 
    mask : ndarray[bool], optional 
        nan-mask if known 
 
    Returns 
    ------- 
    result : float64 
        Unless input is a float array, in which case use the same 
        precision as the input array. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import pandas.core.nanops as nanops 
    &gt;&gt;&gt; s = pd.Series([1, np.nan, 1, 2]) 
    &gt;&gt;&gt; nanops.nanskew(s) 
    1.7320508075688787 
    &quot;&quot;&quot;</span>
    <span class="s3"># error: Incompatible types in assignment (expression has type &quot;Union[Any,</span>
    <span class="s3"># Union[ExtensionArray, ndarray]]&quot;, variable has type &quot;ndarray&quot;)</span>
    <span class="s1">values = extract_array(values</span><span class="s0">, </span><span class="s1">extract_numpy=</span><span class="s0">True</span><span class="s1">)  </span><span class="s3"># type: ignore[assignment]</span>
    <span class="s1">mask = _maybe_get_mask(values</span><span class="s0">, </span><span class="s1">skipna</span><span class="s0">, </span><span class="s1">mask)</span>
    <span class="s0">if not </span><span class="s1">is_float_dtype(values.dtype):</span>
        <span class="s1">values = values.astype(</span><span class="s2">&quot;f8&quot;</span><span class="s1">)</span>
        <span class="s1">count = _get_counts(values.shape</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">axis)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">count = _get_counts(values.shape</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">dtype=values.dtype)</span>

    <span class="s0">if </span><span class="s1">skipna </span><span class="s0">and </span><span class="s1">mask </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">values = values.copy()</span>
        <span class="s1">np.putmask(values</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">mean = values.sum(axis</span><span class="s0">, </span><span class="s1">dtype=np.float64) / count</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">mean = np.expand_dims(mean</span><span class="s0">, </span><span class="s1">axis)</span>

    <span class="s1">adjusted = values - mean</span>
    <span class="s0">if </span><span class="s1">skipna </span><span class="s0">and </span><span class="s1">mask </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">np.putmask(adjusted</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">adjusted2 = adjusted ** </span><span class="s4">2</span>
    <span class="s1">adjusted3 = adjusted2 * adjusted</span>
    <span class="s1">m2 = adjusted2.sum(axis</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
    <span class="s1">m3 = adjusted3.sum(axis</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>

    <span class="s3"># floating point error</span>
    <span class="s3">#</span>
    <span class="s3"># #18044 in _libs/windows.pyx calc_skew follow this behavior</span>
    <span class="s3"># to fix the fperr to treat m2 &lt;1e-14 as zero</span>
    <span class="s1">m2 = _zero_out_fperr(m2)</span>
    <span class="s1">m3 = _zero_out_fperr(m3)</span>

    <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">divide=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
        <span class="s1">result = (count * (count - </span><span class="s4">1</span><span class="s1">) ** </span><span class="s4">0.5 </span><span class="s1">/ (count - </span><span class="s4">2</span><span class="s1">)) * (m3 / m2 ** </span><span class="s4">1.5</span><span class="s1">)</span>

    <span class="s1">dtype = values.dtype</span>
    <span class="s0">if </span><span class="s1">is_float_dtype(dtype):</span>
        <span class="s1">result = result.astype(dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s1">result = np.where(m2 == </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">result)</span>
        <span class="s1">result[count &lt; </span><span class="s4">3</span><span class="s1">] = np.nan</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result = </span><span class="s4">0 </span><span class="s0">if </span><span class="s1">m2 == </span><span class="s4">0 </span><span class="s0">else </span><span class="s1">result</span>
        <span class="s0">if </span><span class="s1">count &lt; </span><span class="s4">3</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">np.nan</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s1">@disallow(</span><span class="s2">&quot;M8&quot;</span><span class="s0">, </span><span class="s2">&quot;m8&quot;</span><span class="s1">)</span>
<span class="s1">@maybe_operate_rowwise</span>
<span class="s0">def </span><span class="s1">nankurt(</span>
    <span class="s1">values: np.ndarray</span><span class="s0">,</span>
    <span class="s1">*</span><span class="s0">,</span>
    <span class="s1">axis: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">skipna: bool = </span><span class="s0">True,</span>
    <span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
<span class="s1">) -&gt; float:</span>
    <span class="s5">&quot;&quot;&quot; 
    Compute the sample excess kurtosis 
 
    The statistic computed here is the adjusted Fisher-Pearson standardized 
    moment coefficient G2, computed directly from the second and fourth 
    central moment. 
 
    Parameters 
    ---------- 
    values : ndarray 
    axis : int, optional 
    skipna : bool, default True 
    mask : ndarray[bool], optional 
        nan-mask if known 
 
    Returns 
    ------- 
    result : float64 
        Unless input is a float array, in which case use the same 
        precision as the input array. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import pandas.core.nanops as nanops 
    &gt;&gt;&gt; s = pd.Series([1, np.nan, 1, 3, 2]) 
    &gt;&gt;&gt; nanops.nankurt(s) 
    -1.2892561983471076 
    &quot;&quot;&quot;</span>
    <span class="s3"># error: Incompatible types in assignment (expression has type &quot;Union[Any,</span>
    <span class="s3"># Union[ExtensionArray, ndarray]]&quot;, variable has type &quot;ndarray&quot;)</span>
    <span class="s1">values = extract_array(values</span><span class="s0">, </span><span class="s1">extract_numpy=</span><span class="s0">True</span><span class="s1">)  </span><span class="s3"># type: ignore[assignment]</span>
    <span class="s1">mask = _maybe_get_mask(values</span><span class="s0">, </span><span class="s1">skipna</span><span class="s0">, </span><span class="s1">mask)</span>
    <span class="s0">if not </span><span class="s1">is_float_dtype(values.dtype):</span>
        <span class="s1">values = values.astype(</span><span class="s2">&quot;f8&quot;</span><span class="s1">)</span>
        <span class="s1">count = _get_counts(values.shape</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">axis)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">count = _get_counts(values.shape</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">dtype=values.dtype)</span>

    <span class="s0">if </span><span class="s1">skipna </span><span class="s0">and </span><span class="s1">mask </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">values = values.copy()</span>
        <span class="s1">np.putmask(values</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">mean = values.sum(axis</span><span class="s0">, </span><span class="s1">dtype=np.float64) / count</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">mean = np.expand_dims(mean</span><span class="s0">, </span><span class="s1">axis)</span>

    <span class="s1">adjusted = values - mean</span>
    <span class="s0">if </span><span class="s1">skipna </span><span class="s0">and </span><span class="s1">mask </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">np.putmask(adjusted</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">adjusted2 = adjusted ** </span><span class="s4">2</span>
    <span class="s1">adjusted4 = adjusted2 ** </span><span class="s4">2</span>
    <span class="s1">m2 = adjusted2.sum(axis</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
    <span class="s1">m4 = adjusted4.sum(axis</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>

    <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">divide=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
        <span class="s1">adj = </span><span class="s4">3 </span><span class="s1">* (count - </span><span class="s4">1</span><span class="s1">) ** </span><span class="s4">2 </span><span class="s1">/ ((count - </span><span class="s4">2</span><span class="s1">) * (count - </span><span class="s4">3</span><span class="s1">))</span>
        <span class="s1">numerator = count * (count + </span><span class="s4">1</span><span class="s1">) * (count - </span><span class="s4">1</span><span class="s1">) * m4</span>
        <span class="s1">denominator = (count - </span><span class="s4">2</span><span class="s1">) * (count - </span><span class="s4">3</span><span class="s1">) * m2 ** </span><span class="s4">2</span>

    <span class="s3"># floating point error</span>
    <span class="s3">#</span>
    <span class="s3"># #18044 in _libs/windows.pyx calc_kurt follow this behavior</span>
    <span class="s3"># to fix the fperr to treat denom &lt;1e-14 as zero</span>
    <span class="s1">numerator = _zero_out_fperr(numerator)</span>
    <span class="s1">denominator = _zero_out_fperr(denominator)</span>

    <span class="s0">if not </span><span class="s1">isinstance(denominator</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s3"># if ``denom`` is a scalar, check these corner cases first before</span>
        <span class="s3"># doing division</span>
        <span class="s0">if </span><span class="s1">count &lt; </span><span class="s4">4</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">np.nan</span>
        <span class="s0">if </span><span class="s1">denominator == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s4">0</span>

    <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">divide=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
        <span class="s1">result = numerator / denominator - adj</span>

    <span class="s1">dtype = values.dtype</span>
    <span class="s0">if </span><span class="s1">is_float_dtype(dtype):</span>
        <span class="s1">result = result.astype(dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s1">result = np.where(denominator == </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">result)</span>
        <span class="s1">result[count &lt; </span><span class="s4">4</span><span class="s1">] = np.nan</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s1">@disallow(</span><span class="s2">&quot;M8&quot;</span><span class="s0">, </span><span class="s2">&quot;m8&quot;</span><span class="s1">)</span>
<span class="s1">@maybe_operate_rowwise</span>
<span class="s0">def </span><span class="s1">nanprod(</span>
    <span class="s1">values: np.ndarray</span><span class="s0">,</span>
    <span class="s1">*</span><span class="s0">,</span>
    <span class="s1">axis: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">skipna: bool = </span><span class="s0">True,</span>
    <span class="s1">min_count: int = </span><span class="s4">0</span><span class="s0">,</span>
    <span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
<span class="s1">) -&gt; float:</span>
    <span class="s5">&quot;&quot;&quot; 
    Parameters 
    ---------- 
    values : ndarray[dtype] 
    axis : int, optional 
    skipna : bool, default True 
    min_count: int, default 0 
    mask : ndarray[bool], optional 
        nan-mask if known 
 
    Returns 
    ------- 
    Dtype 
        The product of all elements on a given axis. ( NaNs are treated as 1) 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import pandas.core.nanops as nanops 
    &gt;&gt;&gt; s = pd.Series([1, 2, 3, np.nan]) 
    &gt;&gt;&gt; nanops.nanprod(s) 
    6.0 
    &quot;&quot;&quot;</span>
    <span class="s1">mask = _maybe_get_mask(values</span><span class="s0">, </span><span class="s1">skipna</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s0">if </span><span class="s1">skipna </span><span class="s0">and </span><span class="s1">mask </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">values = values.copy()</span>
        <span class="s1">values[mask] = </span><span class="s4">1</span>
    <span class="s1">result = values.prod(axis)</span>
    <span class="s3"># error: Incompatible return value type (got &quot;Union[ndarray, float]&quot;, expected</span>
    <span class="s3"># &quot;float&quot;)</span>
    <span class="s0">return </span><span class="s1">_maybe_null_out(  </span><span class="s3"># type: ignore[return-value]</span>
        <span class="s1">result</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">values.shape</span><span class="s0">, </span><span class="s1">min_count=min_count</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_maybe_arg_null_out(</span>
    <span class="s1">result: np.ndarray</span><span class="s0">,</span>
    <span class="s1">axis: int | </span><span class="s0">None,</span>
    <span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None,</span>
    <span class="s1">skipna: bool</span><span class="s0">,</span>
<span class="s1">) -&gt; np.ndarray | int:</span>
    <span class="s3"># helper function for nanargmin/nanargmax</span>
    <span class="s0">if </span><span class="s1">mask </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None or not </span><span class="s1">getattr(result</span><span class="s0">, </span><span class="s2">&quot;ndim&quot;</span><span class="s0">, False</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">skipna:</span>
            <span class="s0">if </span><span class="s1">mask.all():</span>
                <span class="s0">return </span><span class="s1">-</span><span class="s4">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">mask.any():</span>
                <span class="s0">return </span><span class="s1">-</span><span class="s4">1</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">skipna:</span>
            <span class="s1">na_mask = mask.all(axis)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">na_mask = mask.any(axis)</span>
        <span class="s0">if </span><span class="s1">na_mask.any():</span>
            <span class="s1">result[na_mask] = -</span><span class="s4">1</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">_get_counts(</span>
    <span class="s1">values_shape: Shape</span><span class="s0">,</span>
    <span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None,</span>
    <span class="s1">axis: int | </span><span class="s0">None,</span>
    <span class="s1">dtype: np.dtype = np.dtype(np.float64)</span><span class="s0">,</span>
<span class="s1">) -&gt; int | float | np.ndarray:</span>
    <span class="s5">&quot;&quot;&quot; 
    Get the count of non-null values along an axis 
 
    Parameters 
    ---------- 
    values_shape : tuple of int 
        shape tuple from values ndarray, used if mask is None 
    mask : Optional[ndarray[bool]] 
        locations in values that should be considered missing 
    axis : Optional[int] 
        axis to count along 
    dtype : type, optional 
        type to use for count 
 
    Returns 
    ------- 
    count : scalar or array 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">mask </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">n = mask.size - mask.sum()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">n = np.prod(values_shape)</span>
        <span class="s0">return </span><span class="s1">dtype.type(n)</span>

    <span class="s0">if </span><span class="s1">mask </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">count = mask.shape[axis] - mask.sum(axis)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">count = values_shape[axis]</span>

    <span class="s0">if </span><span class="s1">is_scalar(count):</span>
        <span class="s0">return </span><span class="s1">dtype.type(count)</span>
    <span class="s0">return </span><span class="s1">count.astype(dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_maybe_null_out(</span>
    <span class="s1">result: np.ndarray | float | NaTType</span><span class="s0">,</span>
    <span class="s1">axis: int | </span><span class="s0">None,</span>
    <span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None,</span>
    <span class="s1">shape: tuple[int</span><span class="s0">, </span><span class="s1">...]</span><span class="s0">,</span>
    <span class="s1">min_count: int = </span><span class="s4">1</span><span class="s0">,</span>
<span class="s1">) -&gt; np.ndarray | float | NaTType:</span>
    <span class="s5">&quot;&quot;&quot; 
    Returns 
    ------- 
    Dtype 
        The product of all elements on a given axis. ( NaNs are treated as 1) 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is not None and </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s0">if </span><span class="s1">mask </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">null_mask = (mask.shape[axis] - mask.sum(axis) - min_count) &lt; </span><span class="s4">0</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># we have no nulls, kept mask=None in _maybe_get_mask</span>
            <span class="s1">below_count = shape[axis] - min_count &lt; </span><span class="s4">0</span>
            <span class="s1">new_shape = shape[:axis] + shape[axis + </span><span class="s4">1 </span><span class="s1">:]</span>
            <span class="s1">null_mask = np.broadcast_to(below_count</span><span class="s0">, </span><span class="s1">new_shape)</span>

        <span class="s0">if </span><span class="s1">np.any(null_mask):</span>
            <span class="s0">if </span><span class="s1">is_numeric_dtype(result):</span>
                <span class="s0">if </span><span class="s1">np.iscomplexobj(result):</span>
                    <span class="s1">result = result.astype(</span><span class="s2">&quot;c16&quot;</span><span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">result = result.astype(</span><span class="s2">&quot;f8&quot;</span><span class="s1">)</span>
                <span class="s1">result[null_mask] = np.nan</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s3"># GH12941, use None to auto cast null</span>
                <span class="s1">result[null_mask] = </span><span class="s0">None</span>
    <span class="s0">elif </span><span class="s1">result </span><span class="s0">is not </span><span class="s1">NaT:</span>
        <span class="s0">if </span><span class="s1">check_below_min_count(shape</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">min_count):</span>
            <span class="s1">result = np.nan</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">check_below_min_count(</span>
    <span class="s1">shape: tuple[int</span><span class="s0">, </span><span class="s1">...]</span><span class="s0">, </span><span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None, </span><span class="s1">min_count: int</span>
<span class="s1">) -&gt; bool:</span>
    <span class="s5">&quot;&quot;&quot; 
    Check for the `min_count` keyword. Returns True if below `min_count` (when 
    missing value should be returned from the reduction). 
 
    Parameters 
    ---------- 
    shape : tuple 
        The shape of the values (`values.shape`). 
    mask : ndarray[bool] or None 
        Boolean numpy array (typically of same shape as `shape`) or None. 
    min_count : int 
        Keyword passed through from sum/prod call. 
 
    Returns 
    ------- 
    bool 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">min_count &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">mask </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s3"># no missing values, only check size</span>
            <span class="s1">non_nulls = np.prod(shape)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">non_nulls = mask.size - mask.sum()</span>
        <span class="s0">if </span><span class="s1">non_nulls &lt; min_count:</span>
            <span class="s0">return True</span>
    <span class="s0">return False</span>


<span class="s0">def </span><span class="s1">_zero_out_fperr(arg):</span>
    <span class="s3"># #18044 reference this behavior to fix rolling skew/kurt issue</span>
    <span class="s0">if </span><span class="s1">isinstance(arg</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">np.where(np.abs(arg) &lt; </span><span class="s4">1e-14</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">arg)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">arg.dtype.type(</span><span class="s4">0</span><span class="s1">) </span><span class="s0">if </span><span class="s1">np.abs(arg) &lt; </span><span class="s4">1e-14 </span><span class="s0">else </span><span class="s1">arg</span>


<span class="s1">@disallow(</span><span class="s2">&quot;M8&quot;</span><span class="s0">, </span><span class="s2">&quot;m8&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">nancorr(</span>
    <span class="s1">a: np.ndarray</span><span class="s0">, </span><span class="s1">b: np.ndarray</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">method=</span><span class="s2">&quot;pearson&quot;</span><span class="s0">, </span><span class="s1">min_periods: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
<span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    a, b: ndarrays 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">len(a) != len(b):</span>
        <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s2">&quot;Operands to nancorr must have same size&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">min_periods </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">min_periods = </span><span class="s4">1</span>

    <span class="s1">valid = notna(a) &amp; notna(b)</span>
    <span class="s0">if not </span><span class="s1">valid.all():</span>
        <span class="s1">a = a[valid]</span>
        <span class="s1">b = b[valid]</span>

    <span class="s0">if </span><span class="s1">len(a) &lt; min_periods:</span>
        <span class="s0">return </span><span class="s1">np.nan</span>

    <span class="s1">f = get_corr_func(method)</span>
    <span class="s0">return </span><span class="s1">f(a</span><span class="s0">, </span><span class="s1">b)</span>


<span class="s0">def </span><span class="s1">get_corr_func(method):</span>
    <span class="s0">if </span><span class="s1">method == </span><span class="s2">&quot;kendall&quot;</span><span class="s1">:</span>
        <span class="s0">from </span><span class="s1">scipy.stats </span><span class="s0">import </span><span class="s1">kendalltau</span>

        <span class="s0">def </span><span class="s1">func(a</span><span class="s0">, </span><span class="s1">b):</span>
            <span class="s0">return </span><span class="s1">kendalltau(a</span><span class="s0">, </span><span class="s1">b)[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s0">return </span><span class="s1">func</span>
    <span class="s0">elif </span><span class="s1">method == </span><span class="s2">&quot;spearman&quot;</span><span class="s1">:</span>
        <span class="s0">from </span><span class="s1">scipy.stats </span><span class="s0">import </span><span class="s1">spearmanr</span>

        <span class="s0">def </span><span class="s1">func(a</span><span class="s0">, </span><span class="s1">b):</span>
            <span class="s0">return </span><span class="s1">spearmanr(a</span><span class="s0">, </span><span class="s1">b)[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s0">return </span><span class="s1">func</span>
    <span class="s0">elif </span><span class="s1">method == </span><span class="s2">&quot;pearson&quot;</span><span class="s1">:</span>

        <span class="s0">def </span><span class="s1">func(a</span><span class="s0">, </span><span class="s1">b):</span>
            <span class="s0">return </span><span class="s1">np.corrcoef(a</span><span class="s0">, </span><span class="s1">b)[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span>

        <span class="s0">return </span><span class="s1">func</span>
    <span class="s0">elif </span><span class="s1">callable(method):</span>
        <span class="s0">return </span><span class="s1">method</span>

    <span class="s0">raise </span><span class="s1">ValueError(</span>
        <span class="s2">f&quot;Unknown method '</span><span class="s0">{</span><span class="s1">method</span><span class="s0">}</span><span class="s2">', expected one of &quot;</span>
        <span class="s2">&quot;'kendall', 'spearman', 'pearson', or callable&quot;</span>
    <span class="s1">)</span>


<span class="s1">@disallow(</span><span class="s2">&quot;M8&quot;</span><span class="s0">, </span><span class="s2">&quot;m8&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">nancov(</span>
    <span class="s1">a: np.ndarray</span><span class="s0">,</span>
    <span class="s1">b: np.ndarray</span><span class="s0">,</span>
    <span class="s1">*</span><span class="s0">,</span>
    <span class="s1">min_periods: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">ddof: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s4">1</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s0">if </span><span class="s1">len(a) != len(b):</span>
        <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s2">&quot;Operands to nancov must have same size&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">min_periods </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">min_periods = </span><span class="s4">1</span>

    <span class="s1">valid = notna(a) &amp; notna(b)</span>
    <span class="s0">if not </span><span class="s1">valid.all():</span>
        <span class="s1">a = a[valid]</span>
        <span class="s1">b = b[valid]</span>

    <span class="s0">if </span><span class="s1">len(a) &lt; min_periods:</span>
        <span class="s0">return </span><span class="s1">np.nan</span>

    <span class="s0">return </span><span class="s1">np.cov(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">ddof=ddof)[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">_ensure_numeric(x):</span>
    <span class="s0">if </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
        <span class="s0">if </span><span class="s1">is_integer_dtype(x) </span><span class="s0">or </span><span class="s1">is_bool_dtype(x):</span>
            <span class="s1">x = x.astype(np.float64)</span>
        <span class="s0">elif </span><span class="s1">is_object_dtype(x):</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">x = x.astype(np.complex128)</span>
            <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">x = x.astype(np.float64)</span>
                <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">err:</span>
                    <span class="s3"># GH#29941 we get here with object arrays containing strs</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">f&quot;Could not convert </span><span class="s0">{</span><span class="s1">x</span><span class="s0">} </span><span class="s2">to numeric&quot;</span><span class="s1">) </span><span class="s0">from </span><span class="s1">err</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if not </span><span class="s1">np.any(np.imag(x)):</span>
                    <span class="s1">x = x.real</span>
    <span class="s0">elif not </span><span class="s1">(is_float(x) </span><span class="s0">or </span><span class="s1">is_integer(x) </span><span class="s0">or </span><span class="s1">is_complex(x)):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">x = float(x)</span>
        <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
            <span class="s3"># e.g. &quot;1+1j&quot; or &quot;foo&quot;</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">x = complex(x)</span>
            <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">err:</span>
                <span class="s3"># e.g. &quot;foo&quot;</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">f&quot;Could not convert </span><span class="s0">{</span><span class="s1">x</span><span class="s0">} </span><span class="s2">to numeric&quot;</span><span class="s1">) </span><span class="s0">from </span><span class="s1">err</span>
    <span class="s0">return </span><span class="s1">x</span>


<span class="s3"># NA-friendly array comparisons</span>


<span class="s0">def </span><span class="s1">make_nancomp(op):</span>
    <span class="s0">def </span><span class="s1">f(x</span><span class="s0">, </span><span class="s1">y):</span>
        <span class="s1">xmask = isna(x)</span>
        <span class="s1">ymask = isna(y)</span>
        <span class="s1">mask = xmask | ymask</span>

        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">result = op(x</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s0">if </span><span class="s1">mask.any():</span>
            <span class="s0">if </span><span class="s1">is_bool_dtype(result):</span>
                <span class="s1">result = result.astype(</span><span class="s2">&quot;O&quot;</span><span class="s1">)</span>
            <span class="s1">np.putmask(result</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">np.nan)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">return </span><span class="s1">f</span>


<span class="s1">nangt = make_nancomp(operator.gt)</span>
<span class="s1">nange = make_nancomp(operator.ge)</span>
<span class="s1">nanlt = make_nancomp(operator.lt)</span>
<span class="s1">nanle = make_nancomp(operator.le)</span>
<span class="s1">naneq = make_nancomp(operator.eq)</span>
<span class="s1">nanne = make_nancomp(operator.ne)</span>


<span class="s0">def </span><span class="s1">na_accum_func(values: ArrayLike</span><span class="s0">, </span><span class="s1">accum_func</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna: bool) -&gt; ArrayLike:</span>
    <span class="s5">&quot;&quot;&quot; 
    Cumulative function with skipna support. 
 
    Parameters 
    ---------- 
    values : np.ndarray or ExtensionArray 
    accum_func : {np.cumprod, np.maximum.accumulate, np.cumsum, np.minimum.accumulate} 
    skipna : bool 
 
    Returns 
    ------- 
    np.ndarray or ExtensionArray 
    &quot;&quot;&quot;</span>
    <span class="s1">mask_a</span><span class="s0">, </span><span class="s1">mask_b = {</span>
        <span class="s1">np.cumprod: (</span><span class="s4">1.0</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">,</span>
        <span class="s1">np.maximum.accumulate: (-np.inf</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">,</span>
        <span class="s1">np.cumsum: (</span><span class="s4">0.0</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">,</span>
        <span class="s1">np.minimum.accumulate: (np.inf</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">,</span>
    <span class="s1">}[accum_func]</span>

    <span class="s3"># We will be applying this function to block values</span>
    <span class="s0">if </span><span class="s1">values.dtype.kind </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;m&quot;</span><span class="s0">, </span><span class="s2">&quot;M&quot;</span><span class="s1">]:</span>
        <span class="s3"># GH#30460, GH#29058</span>
        <span class="s3"># numpy 1.18 started sorting NaTs at the end instead of beginning,</span>
        <span class="s3">#  so we need to work around to maintain backwards-consistency.</span>
        <span class="s1">orig_dtype = values.dtype</span>

        <span class="s3"># We need to define mask before masking NaTs</span>
        <span class="s1">mask = isna(values)</span>

        <span class="s1">y = values.view(</span><span class="s2">&quot;i8&quot;</span><span class="s1">)</span>
        <span class="s3"># Note: the accum_func comparison fails as an &quot;is&quot; comparison</span>
        <span class="s1">changed = accum_func == np.minimum.accumulate</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">changed:</span>
                <span class="s1">y[mask] = lib.i8max</span>

            <span class="s1">result = accum_func(y</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">changed:</span>
                <span class="s3"># restore NaT elements</span>
                <span class="s1">y[mask] = iNaT</span>

        <span class="s0">if </span><span class="s1">skipna:</span>
            <span class="s1">result[mask] = iNaT</span>
        <span class="s0">elif </span><span class="s1">accum_func == np.minimum.accumulate:</span>
            <span class="s3"># Restore NaTs that we masked previously</span>
            <span class="s1">nz = (~np.asarray(mask)).nonzero()[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">len(nz):</span>
                <span class="s3"># everything up to the first non-na entry stays NaT</span>
                <span class="s1">result[: nz[</span><span class="s4">0</span><span class="s1">]] = iNaT</span>

        <span class="s0">if </span><span class="s1">isinstance(values.dtype</span><span class="s0">, </span><span class="s1">np.dtype):</span>
            <span class="s1">result = result.view(orig_dtype)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># DatetimeArray/TimedeltaArray</span>
            <span class="s3"># TODO: have this case go through a DTA method?</span>
            <span class="s3"># For DatetimeTZDtype, view result as M8[ns]</span>
            <span class="s1">npdtype = orig_dtype </span><span class="s0">if </span><span class="s1">isinstance(orig_dtype</span><span class="s0">, </span><span class="s1">np.dtype) </span><span class="s0">else </span><span class="s2">&quot;M8[ns]&quot;</span>
            <span class="s3"># Item &quot;type&quot; of &quot;Union[Type[ExtensionArray], Type[ndarray[Any, Any]]]&quot;</span>
            <span class="s3"># has no attribute &quot;_simple_new&quot;</span>
            <span class="s1">result = type(values)._simple_new(  </span><span class="s3"># type: ignore[union-attr]</span>
                <span class="s1">result.view(npdtype)</span><span class="s0">, </span><span class="s1">dtype=orig_dtype</span>
            <span class="s1">)</span>

    <span class="s0">elif </span><span class="s1">skipna </span><span class="s0">and not </span><span class="s1">issubclass(values.dtype.type</span><span class="s0">, </span><span class="s1">(np.integer</span><span class="s0">, </span><span class="s1">np.bool_)):</span>
        <span class="s1">vals = values.copy()</span>
        <span class="s1">mask = isna(vals)</span>
        <span class="s1">vals[mask] = mask_a</span>
        <span class="s1">result = accum_func(vals</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">result[mask] = mask_b</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result = accum_func(values</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">result</span>
</pre>
</body>
</html>