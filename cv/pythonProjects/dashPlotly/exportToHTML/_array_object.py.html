<html>
<head>
<title>_array_object.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_array_object.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Wrapper class around the ndarray object for the array API standard. 
 
The array API standard defines some behaviors differently than ndarray, in 
particular, type promotion rules are different (the standard has no 
value-based casting). The standard also specifies a more limited subset of 
array methods and functionalities than are implemented on ndarray. Since the 
goal of the array_api namespace is to be a minimal implementation of the array 
API standard, we need to define a separate wrapper class for the array_api 
namespace. 
 
The standard compliant class is only a wrapper class. It is *not* a subclass 
of ndarray. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">from </span><span class="s1">enum </span><span class="s2">import </span><span class="s1">IntEnum</span>
<span class="s2">from </span><span class="s1">._creation_functions </span><span class="s2">import </span><span class="s1">asarray</span>
<span class="s2">from </span><span class="s1">._dtypes </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_all_dtypes</span><span class="s2">,</span>
    <span class="s1">_boolean_dtypes</span><span class="s2">,</span>
    <span class="s1">_integer_dtypes</span><span class="s2">,</span>
    <span class="s1">_integer_or_boolean_dtypes</span><span class="s2">,</span>
    <span class="s1">_floating_dtypes</span><span class="s2">,</span>
    <span class="s1">_numeric_dtypes</span><span class="s2">,</span>
    <span class="s1">_result_type</span><span class="s2">,</span>
    <span class="s1">_dtype_categories</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">, </span><span class="s1">Union</span><span class="s2">, </span><span class="s1">Any</span>
<span class="s2">import </span><span class="s1">types</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">._typing </span><span class="s2">import </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">PyCapsule</span><span class="s2">, </span><span class="s1">Device</span><span class="s2">, </span><span class="s1">Dtype</span>
    <span class="s2">import </span><span class="s1">numpy.typing </span><span class="s2">as </span><span class="s1">npt</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">array_api</span>


<span class="s2">class </span><span class="s1">Array:</span>
    <span class="s0">&quot;&quot;&quot; 
    n-d array object for the array API namespace. 
 
    See the docstring of :py:obj:`np.ndarray &lt;numpy.ndarray&gt;` for more 
    information. 
 
    This is a wrapper around numpy.ndarray that restricts the usage to only 
    those things that are required by the array API namespace. Note, 
    attributes on this object that start with a single underscore are not part 
    of the API specification and should only be used internally. This object 
    should not be constructed directly. Rather, use one of the creation 
    functions, such as asarray(). 
 
    &quot;&quot;&quot;</span>

    <span class="s3"># Use a custom constructor instead of __init__, as manually initializing</span>
    <span class="s3"># this class is not supported API.</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_new(cls</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">/):</span>
        <span class="s0">&quot;&quot;&quot; 
        This is a private method for initializing the array API Array 
        object. 
 
        Functions outside of the array_api submodule should not use this 
        method. Use one of the creation functions instead, such as 
        ``asarray``. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">obj = super().__new__(cls)</span>
        <span class="s3"># Note: The spec does not have array scalars, only 0-D arrays.</span>
        <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">np.generic):</span>
            <span class="s3"># Convert the array scalar to a 0-D array</span>
            <span class="s1">x = np.asarray(x)</span>
        <span class="s2">if </span><span class="s1">x.dtype </span><span class="s2">not in </span><span class="s1">_all_dtypes:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">f&quot;The array_api namespace does not support the dtype '</span><span class="s2">{</span><span class="s1">x.dtype</span><span class="s2">}</span><span class="s4">'&quot;</span>
            <span class="s1">)</span>
        <span class="s1">obj._array = x</span>
        <span class="s2">return </span><span class="s1">obj</span>

    <span class="s3"># Prevent Array() from working</span>
    <span class="s2">def </span><span class="s1">__new__(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span>
            <span class="s4">&quot;The array_api Array object should not be instantiated directly. Use an array creation function, such as asarray(), instead.&quot;</span>
        <span class="s1">)</span>

    <span class="s3"># These functions are not required by the spec, but are implemented for</span>
    <span class="s3"># the sake of usability.</span>

    <span class="s2">def </span><span class="s1">__str__(self: Array</span><span class="s2">, </span><span class="s1">/) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __str__. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._array.__str__().replace(</span><span class="s4">&quot;array&quot;</span><span class="s2">, </span><span class="s4">&quot;Array&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self: Array</span><span class="s2">, </span><span class="s1">/) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __repr__. 
        &quot;&quot;&quot;</span>
        <span class="s1">suffix = </span><span class="s4">f&quot;, dtype=</span><span class="s2">{</span><span class="s1">self.dtype.name</span><span class="s2">}</span><span class="s4">)&quot;</span>
        <span class="s2">if </span><span class="s5">0 </span><span class="s2">in </span><span class="s1">self.shape:</span>
            <span class="s1">prefix = </span><span class="s4">&quot;empty(&quot;</span>
            <span class="s1">mid = str(self.shape)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">prefix = </span><span class="s4">&quot;Array(&quot;</span>
            <span class="s1">mid = np.array2string(self._array</span><span class="s2">, </span><span class="s1">separator=</span><span class="s4">', '</span><span class="s2">, </span><span class="s1">prefix=prefix</span><span class="s2">, </span><span class="s1">suffix=suffix)</span>
        <span class="s2">return </span><span class="s1">prefix + mid + suffix</span>

    <span class="s3"># This function is not required by the spec, but we implement it here for</span>
    <span class="s3"># convenience so that np.asarray(np.array_api.Array) will work.</span>
    <span class="s2">def </span><span class="s1">__array__(self</span><span class="s2">, </span><span class="s1">dtype: </span><span class="s2">None </span><span class="s1">| np.dtype[Any] = </span><span class="s2">None</span><span class="s1">) -&gt; npt.NDArray[Any]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Warning: this method is NOT part of the array API spec. Implementers 
        of other libraries need not include it, and users should not assume it 
        will be present in other implementations. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.asarray(self._array</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s3"># These are various helper functions to make the array behavior match the</span>
    <span class="s3"># spec in places where it either deviates from or is more strict than</span>
    <span class="s3"># NumPy behavior</span>

    <span class="s2">def </span><span class="s1">_check_allowed_dtypes(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">dtype_category</span><span class="s2">, </span><span class="s1">op):</span>
        <span class="s0">&quot;&quot;&quot; 
        Helper function for operators to only allow specific input dtypes 
 
        Use like 
 
            other = self._check_allowed_dtypes(other, 'numeric', '__add__') 
            if other is NotImplemented: 
                return other 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self.dtype </span><span class="s2">not in </span><span class="s1">_dtype_categories[dtype_category]:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;Only </span><span class="s2">{</span><span class="s1">dtype_category</span><span class="s2">} </span><span class="s4">dtypes are allowed in </span><span class="s2">{</span><span class="s1">op</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">(int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">bool)):</span>
            <span class="s1">other = self._promote_scalar(other)</span>
        <span class="s2">elif </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">Array):</span>
            <span class="s2">if </span><span class="s1">other.dtype </span><span class="s2">not in </span><span class="s1">_dtype_categories[dtype_category]:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;Only </span><span class="s2">{</span><span class="s1">dtype_category</span><span class="s2">} </span><span class="s4">dtypes are allowed in </span><span class="s2">{</span><span class="s1">op</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s3"># This will raise TypeError for type combinations that are not allowed</span>
        <span class="s3"># to promote in the spec (even if the NumPy array operator would</span>
        <span class="s3"># promote them).</span>
        <span class="s1">res_dtype = _result_type(self.dtype</span><span class="s2">, </span><span class="s1">other.dtype)</span>
        <span class="s2">if </span><span class="s1">op.startswith(</span><span class="s4">&quot;__i&quot;</span><span class="s1">):</span>
            <span class="s3"># Note: NumPy will allow in-place operators in some cases where</span>
            <span class="s3"># the type promoted operator does not match the left-hand side</span>
            <span class="s3"># operand. For example,</span>

            <span class="s3"># &gt;&gt;&gt; a = np.array(1, dtype=np.int8)</span>
            <span class="s3"># &gt;&gt;&gt; a += np.array(1, dtype=np.int16)</span>

            <span class="s3"># The spec explicitly disallows this.</span>
            <span class="s2">if </span><span class="s1">res_dtype != self.dtype:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">f&quot;Cannot perform </span><span class="s2">{</span><span class="s1">op</span><span class="s2">} </span><span class="s4">with dtypes </span><span class="s2">{</span><span class="s1">self.dtype</span><span class="s2">} </span><span class="s4">and </span><span class="s2">{</span><span class="s1">other.dtype</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">other</span>

    <span class="s3"># Helper function to match the type promotion rules in the spec</span>
    <span class="s2">def </span><span class="s1">_promote_scalar(self</span><span class="s2">, </span><span class="s1">scalar):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a promoted version of a Python scalar appropriate for use with 
        operations on self. 
 
        This may raise an OverflowError in cases where the scalar is an 
        integer that is too large to fit in a NumPy integer dtype, or 
        TypeError when the scalar type is incompatible with the dtype of self. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(scalar</span><span class="s2">, </span><span class="s1">bool):</span>
            <span class="s2">if </span><span class="s1">self.dtype </span><span class="s2">not in </span><span class="s1">_boolean_dtypes:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">&quot;Python bool scalars can only be promoted with bool arrays&quot;</span>
                <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(scalar</span><span class="s2">, </span><span class="s1">int):</span>
            <span class="s2">if </span><span class="s1">self.dtype </span><span class="s2">in </span><span class="s1">_boolean_dtypes:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">&quot;Python int scalars cannot be promoted with bool arrays&quot;</span>
                <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(scalar</span><span class="s2">, </span><span class="s1">float):</span>
            <span class="s2">if </span><span class="s1">self.dtype </span><span class="s2">not in </span><span class="s1">_floating_dtypes:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">&quot;Python float scalars can only be promoted with floating-point arrays.&quot;</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;'scalar' must be a Python scalar&quot;</span><span class="s1">)</span>

        <span class="s3"># Note: the spec only specifies integer-dtype/int promotion</span>
        <span class="s3"># behavior for integers within the bounds of the integer dtype.</span>
        <span class="s3"># Outside of those bounds we use the default NumPy behavior (either</span>
        <span class="s3"># cast or raise OverflowError).</span>
        <span class="s2">return </span><span class="s1">Array._new(np.array(scalar</span><span class="s2">, </span><span class="s1">self.dtype))</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_normalize_two_args(x1</span><span class="s2">, </span><span class="s1">x2):</span>
        <span class="s0">&quot;&quot;&quot; 
        Normalize inputs to two arg functions to fix type promotion rules 
 
        NumPy deviates from the spec type promotion rules in cases where one 
        argument is 0-dimensional and the other is not. For example: 
 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; a = np.array([1.0], dtype=np.float32) 
        &gt;&gt;&gt; b = np.array(1.0, dtype=np.float64) 
        &gt;&gt;&gt; np.add(a, b) # The spec says this should be float64 
        array([2.], dtype=float32) 
 
        To fix this, we add a dimension to the 0-dimension array before passing it 
        through. This works because a dimension would be added anyway from 
        broadcasting, so the resulting shape is the same, but this prevents NumPy 
        from not promoting the dtype. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Another option would be to use signature=(x1.dtype, x2.dtype, None),</span>
        <span class="s3"># but that only works for ufuncs, so we would have to call the ufuncs</span>
        <span class="s3"># directly in the operator methods. One should also note that this</span>
        <span class="s3"># sort of trick wouldn't work for functions like searchsorted, which</span>
        <span class="s3"># don't do normal broadcasting, but there aren't any functions like</span>
        <span class="s3"># that in the array API namespace.</span>
        <span class="s2">if </span><span class="s1">x1.ndim == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">x2.ndim != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3"># The _array[None] workaround was chosen because it is relatively</span>
            <span class="s3"># performant. broadcast_to(x1._array, x2.shape) is much slower. We</span>
            <span class="s3"># could also manually type promote x2, but that is more complicated</span>
            <span class="s3"># and about the same performance as this.</span>
            <span class="s1">x1 = Array._new(x1._array[</span><span class="s2">None</span><span class="s1">])</span>
        <span class="s2">elif </span><span class="s1">x2.ndim == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">x1.ndim != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">x2 = Array._new(x2._array[</span><span class="s2">None</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">x2)</span>

    <span class="s3"># Note: A large fraction of allowed indices are disallowed here (see the</span>
    <span class="s3"># docstring below)</span>
    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_validate_index(key</span><span class="s2">, </span><span class="s1">shape):</span>
        <span class="s0">&quot;&quot;&quot; 
        Validate an index according to the array API. 
 
        The array API specification only requires a subset of indices that are 
        supported by NumPy. This function will reject any index that is 
        allowed by NumPy but not required by the array API specification. We 
        always raise ``IndexError`` on such indices (the spec does not require 
        any specific behavior on them, but this makes the NumPy array API 
        namespace a minimal implementation of the spec). See 
        https://data-apis.org/array-api/latest/API_specification/indexing.html 
        for the full list of required indexing behavior 
 
        This function either raises IndexError if the index ``key`` is 
        invalid, or a new key to be used in place of ``key`` in indexing. It 
        only raises ``IndexError`` on indices that are not already rejected by 
        NumPy, as NumPy will already raise the appropriate error on such 
        indices. ``shape`` may be None, in which case, only cases that are 
        independent of the array shape are checked. 
 
        The following cases are allowed by NumPy, but not specified by the array 
        API specification: 
 
        - Indices to not include an implicit ellipsis at the end. That is, 
          every axis of an array must be explicitly indexed or an ellipsis 
          included. 
 
        - The start and stop of a slice may not be out of bounds. In 
          particular, for a slice ``i:j:k`` on an axis of size ``n``, only the 
          following are allowed: 
 
          - ``i`` or ``j`` omitted (``None``). 
          - ``-n &lt;= i &lt;= max(0, n - 1)``. 
          - For ``k &gt; 0`` or ``k`` omitted (``None``), ``-n &lt;= j &lt;= n``. 
          - For ``k &lt; 0``, ``-n - 1 &lt;= j &lt;= max(0, n - 1)``. 
 
        - Boolean array indices are not allowed as part of a larger tuple 
          index. 
 
        - Integer array indices are not allowed (with the exception of 0-D 
          arrays, which are treated the same as scalars). 
 
        Additionally, it should be noted that indices that would return a 
        scalar in NumPy will return a 0-D array. Array scalars are not allowed 
        in the specification, only 0-D arrays. This is done in the 
        ``Array._new`` constructor, not this function. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">slice):</span>
            <span class="s2">if </span><span class="s1">shape </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">key</span>
            <span class="s2">if </span><span class="s1">shape == ():</span>
                <span class="s2">return </span><span class="s1">key</span>
            <span class="s2">if </span><span class="s1">len(shape) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">IndexError(</span>
                    <span class="s4">&quot;Multidimensional arrays must include an index for every axis or use an ellipsis&quot;</span>
                <span class="s1">)</span>
            <span class="s1">size = shape[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3"># Ensure invalid slice entries are passed through.</span>
            <span class="s2">if </span><span class="s1">key.start </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">operator.index(key.start)</span>
                <span class="s2">except </span><span class="s1">TypeError:</span>
                    <span class="s2">return </span><span class="s1">key</span>
                <span class="s2">if not </span><span class="s1">(-size &lt;= key.start &lt;= size):</span>
                    <span class="s2">raise </span><span class="s1">IndexError(</span>
                        <span class="s4">&quot;Slices with out-of-bounds start are not allowed in the array API namespace&quot;</span>
                    <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">key.stop </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">operator.index(key.stop)</span>
                <span class="s2">except </span><span class="s1">TypeError:</span>
                    <span class="s2">return </span><span class="s1">key</span>
                <span class="s1">step = </span><span class="s5">1 </span><span class="s2">if </span><span class="s1">key.step </span><span class="s2">is None else </span><span class="s1">key.step</span>
                <span class="s2">if </span><span class="s1">(step &gt; </span><span class="s5">0 </span><span class="s2">and not </span><span class="s1">(-size &lt;= key.stop &lt;= size)</span>
                    <span class="s2">or </span><span class="s1">step &lt; </span><span class="s5">0 </span><span class="s2">and not </span><span class="s1">(-size - </span><span class="s5">1 </span><span class="s1">&lt;= key.stop &lt;= max(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">size - </span><span class="s5">1</span><span class="s1">))):</span>
                    <span class="s2">raise </span><span class="s1">IndexError(</span><span class="s4">&quot;Slices with out-of-bounds stop are not allowed in the array API namespace&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">key</span>

        <span class="s2">elif </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">tuple):</span>
            <span class="s1">key = tuple(Array._validate_index(idx</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">key)</span>

            <span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">key:</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">isinstance(idx</span><span class="s2">, </span><span class="s1">np.ndarray)</span>
                    <span class="s2">and </span><span class="s1">idx.dtype </span><span class="s2">in </span><span class="s1">_boolean_dtypes</span>
                    <span class="s2">or </span><span class="s1">isinstance(idx</span><span class="s2">, </span><span class="s1">(bool</span><span class="s2">, </span><span class="s1">np.bool_))</span>
                <span class="s1">):</span>
                    <span class="s2">if </span><span class="s1">len(key) == </span><span class="s5">1</span><span class="s1">:</span>
                        <span class="s2">return </span><span class="s1">key</span>
                    <span class="s2">raise </span><span class="s1">IndexError(</span>
                        <span class="s4">&quot;Boolean array indices combined with other indices are not allowed in the array API namespace&quot;</span>
                    <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">isinstance(idx</span><span class="s2">, </span><span class="s1">tuple):</span>
                    <span class="s2">raise </span><span class="s1">IndexError(</span>
                        <span class="s4">&quot;Nested tuple indices are not allowed in the array API namespace&quot;</span>
                    <span class="s1">)</span>

            <span class="s2">if </span><span class="s1">shape </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">key</span>
            <span class="s1">n_ellipsis = key.count(...)</span>
            <span class="s2">if </span><span class="s1">n_ellipsis &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">key</span>
            <span class="s1">ellipsis_i = key.index(...) </span><span class="s2">if </span><span class="s1">n_ellipsis </span><span class="s2">else </span><span class="s1">len(key)</span>

            <span class="s2">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">size </span><span class="s2">in </span><span class="s1">list(zip(key[:ellipsis_i]</span><span class="s2">, </span><span class="s1">shape)) + list(</span>
                <span class="s1">zip(key[:ellipsis_i:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">shape[:ellipsis_i:-</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s1">):</span>
                <span class="s1">Array._validate_index(idx</span><span class="s2">, </span><span class="s1">(size</span><span class="s2">,</span><span class="s1">))</span>
            <span class="s2">if </span><span class="s1">n_ellipsis == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">len(key) &lt; len(shape):</span>
                <span class="s2">raise </span><span class="s1">IndexError(</span>
                    <span class="s4">&quot;Multidimensional arrays must include an index for every axis or use an ellipsis&quot;</span>
                <span class="s1">)</span>
            <span class="s2">return </span><span class="s1">key</span>
        <span class="s2">elif </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">bool):</span>
            <span class="s2">return </span><span class="s1">key</span>
        <span class="s2">elif </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">Array):</span>
            <span class="s2">if </span><span class="s1">key.dtype </span><span class="s2">in </span><span class="s1">_integer_dtypes:</span>
                <span class="s2">if </span><span class="s1">key.ndim != </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">IndexError(</span>
                        <span class="s4">&quot;Non-zero dimensional integer array indices are not allowed in the array API namespace&quot;</span>
                    <span class="s1">)</span>
            <span class="s2">return </span><span class="s1">key._array</span>
        <span class="s2">elif </span><span class="s1">key </span><span class="s2">is </span><span class="s1">Ellipsis:</span>
            <span class="s2">return </span><span class="s1">key</span>
        <span class="s2">elif </span><span class="s1">key </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">IndexError(</span>
                <span class="s4">&quot;newaxis indices are not allowed in the array API namespace&quot;</span>
            <span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">key = operator.index(key)</span>
            <span class="s2">if </span><span class="s1">shape </span><span class="s2">is not None and </span><span class="s1">len(shape) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">IndexError(</span>
                    <span class="s4">&quot;Multidimensional arrays must include an index for every axis or use an ellipsis&quot;</span>
                <span class="s1">)</span>
            <span class="s2">return </span><span class="s1">key</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s3"># Note: This also omits boolean arrays that are not already in</span>
            <span class="s3"># Array() form, like a list of booleans.</span>
            <span class="s2">raise </span><span class="s1">IndexError(</span>
                <span class="s4">&quot;Only integers, slices (`:`), ellipsis (`...`), and boolean arrays are valid indices in the array API namespace&quot;</span>
            <span class="s1">)</span>

    <span class="s3"># Everything below this line is required by the spec.</span>

    <span class="s2">def </span><span class="s1">__abs__(self: Array</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __abs__. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.dtype </span><span class="s2">not in </span><span class="s1">_numeric_dtypes:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Only numeric dtypes are allowed in __abs__&quot;</span><span class="s1">)</span>
        <span class="s1">res = self._array.__abs__()</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__add__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __add__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__add__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__add__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__and__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __and__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;integer or boolean&quot;</span><span class="s2">, </span><span class="s4">&quot;__and__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__and__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__array_namespace__(</span>
        <span class="s1">self: Array</span><span class="s2">, </span><span class="s1">/</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">api_version: Optional[str] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; types.ModuleType:</span>
        <span class="s2">if </span><span class="s1">api_version </span><span class="s2">is not None and not </span><span class="s1">api_version.startswith(</span><span class="s4">&quot;2021.&quot;</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Unrecognized array API version: </span><span class="s2">{</span><span class="s1">api_version</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">array_api</span>

    <span class="s2">def </span><span class="s1">__bool__(self: Array</span><span class="s2">, </span><span class="s1">/) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __bool__. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Note: This is an error here.</span>
        <span class="s2">if </span><span class="s1">self._array.ndim != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;bool is only allowed on arrays with 0 dimensions&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.dtype </span><span class="s2">not in </span><span class="s1">_boolean_dtypes:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;bool is only allowed on boolean arrays&quot;</span><span class="s1">)</span>
        <span class="s1">res = self._array.__bool__()</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">__dlpack__(self: Array</span><span class="s2">, </span><span class="s1">/</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">stream: </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span><span class="s1">) -&gt; PyCapsule:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __dlpack__. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._array.__dlpack__(stream=stream)</span>

    <span class="s2">def </span><span class="s1">__dlpack_device__(self: Array</span><span class="s2">, </span><span class="s1">/) -&gt; Tuple[IntEnum</span><span class="s2">, </span><span class="s1">int]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __dlpack_device__. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Note: device support is required for this</span>
        <span class="s2">return </span><span class="s1">self._array.__dlpack_device__()</span>

    <span class="s2">def </span><span class="s1">__eq__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __eq__. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Even though &quot;all&quot; dtypes are allowed, we still require them to be</span>
        <span class="s3"># promotable with each other.</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;all&quot;</span><span class="s2">, </span><span class="s4">&quot;__eq__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__eq__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__float__(self: Array</span><span class="s2">, </span><span class="s1">/) -&gt; float:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __float__. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Note: This is an error here.</span>
        <span class="s2">if </span><span class="s1">self._array.ndim != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;float is only allowed on arrays with 0 dimensions&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.dtype </span><span class="s2">not in </span><span class="s1">_floating_dtypes:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;float is only allowed on floating-point arrays&quot;</span><span class="s1">)</span>
        <span class="s1">res = self._array.__float__()</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">__floordiv__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __floordiv__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__floordiv__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__floordiv__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__ge__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __ge__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__ge__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__ge__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__getitem__(</span>
        <span class="s1">self: Array</span><span class="s2">,</span>
        <span class="s1">key: Union[</span>
            <span class="s1">int</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">, </span><span class="s1">ellipsis</span><span class="s2">, </span><span class="s1">Tuple[Union[int</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">, </span><span class="s1">ellipsis]</span><span class="s2">, </span><span class="s1">...]</span><span class="s2">, </span><span class="s1">Array</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">/</span><span class="s2">,</span>
    <span class="s1">) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __getitem__. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Note: Only indices required by the spec are allowed. See the</span>
        <span class="s3"># docstring of _validate_index</span>
        <span class="s1">key = self._validate_index(key</span><span class="s2">, </span><span class="s1">self.shape)</span>
        <span class="s1">res = self._array.__getitem__(key)</span>
        <span class="s2">return </span><span class="s1">self._new(res)</span>

    <span class="s2">def </span><span class="s1">__gt__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __gt__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__gt__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__gt__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__int__(self: Array</span><span class="s2">, </span><span class="s1">/) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __int__. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Note: This is an error here.</span>
        <span class="s2">if </span><span class="s1">self._array.ndim != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;int is only allowed on arrays with 0 dimensions&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.dtype </span><span class="s2">not in </span><span class="s1">_integer_dtypes:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;int is only allowed on integer arrays&quot;</span><span class="s1">)</span>
        <span class="s1">res = self._array.__int__()</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">__index__(self: Array</span><span class="s2">, </span><span class="s1">/) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __index__. 
        &quot;&quot;&quot;</span>
        <span class="s1">res = self._array.__index__()</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">__invert__(self: Array</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __invert__. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.dtype </span><span class="s2">not in </span><span class="s1">_integer_or_boolean_dtypes:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Only integer or boolean dtypes are allowed in __invert__&quot;</span><span class="s1">)</span>
        <span class="s1">res = self._array.__invert__()</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__le__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __le__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__le__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__le__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__lshift__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __lshift__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;integer&quot;</span><span class="s2">, </span><span class="s4">&quot;__lshift__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__lshift__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__lt__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __lt__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__lt__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__lt__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__matmul__(self: Array</span><span class="s2">, </span><span class="s1">other: Array</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __matmul__. 
        &quot;&quot;&quot;</span>
        <span class="s3"># matmul is not defined for scalars, but without this, we may get</span>
        <span class="s3"># the wrong error message from asarray.</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__matmul__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">res = self._array.__matmul__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__mod__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __mod__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__mod__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__mod__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__mul__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __mul__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__mul__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__mul__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__ne__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __ne__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;all&quot;</span><span class="s2">, </span><span class="s4">&quot;__ne__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__ne__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__neg__(self: Array</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __neg__. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.dtype </span><span class="s2">not in </span><span class="s1">_numeric_dtypes:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Only numeric dtypes are allowed in __neg__&quot;</span><span class="s1">)</span>
        <span class="s1">res = self._array.__neg__()</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__or__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __or__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;integer or boolean&quot;</span><span class="s2">, </span><span class="s4">&quot;__or__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__or__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__pos__(self: Array</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __pos__. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.dtype </span><span class="s2">not in </span><span class="s1">_numeric_dtypes:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Only numeric dtypes are allowed in __pos__&quot;</span><span class="s1">)</span>
        <span class="s1">res = self._array.__pos__()</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__pow__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __pow__. 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">._elementwise_functions </span><span class="s2">import </span><span class="s1">pow</span>

        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__pow__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s3"># Note: NumPy's __pow__ does not follow type promotion rules for 0-d</span>
        <span class="s3"># arrays, so we use pow() here instead.</span>
        <span class="s2">return </span><span class="s1">pow(self</span><span class="s2">, </span><span class="s1">other)</span>

    <span class="s2">def </span><span class="s1">__rshift__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __rshift__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;integer&quot;</span><span class="s2">, </span><span class="s4">&quot;__rshift__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__rshift__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__setitem__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">key: Union[</span>
            <span class="s1">int</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">, </span><span class="s1">ellipsis</span><span class="s2">, </span><span class="s1">Tuple[Union[int</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">, </span><span class="s1">ellipsis]</span><span class="s2">, </span><span class="s1">...]</span><span class="s2">, </span><span class="s1">Array</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">value: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">,</span>
        <span class="s1">/</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __setitem__. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Note: Only indices required by the spec are allowed. See the</span>
        <span class="s3"># docstring of _validate_index</span>
        <span class="s1">key = self._validate_index(key</span><span class="s2">, </span><span class="s1">self.shape)</span>
        <span class="s1">self._array.__setitem__(key</span><span class="s2">, </span><span class="s1">asarray(value)._array)</span>

    <span class="s2">def </span><span class="s1">__sub__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __sub__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__sub__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__sub__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s3"># PEP 484 requires int to be a subtype of float, but __truediv__ should</span>
    <span class="s3"># not accept int.</span>
    <span class="s2">def </span><span class="s1">__truediv__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __truediv__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;floating-point&quot;</span><span class="s2">, </span><span class="s4">&quot;__truediv__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__truediv__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__xor__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __xor__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;integer or boolean&quot;</span><span class="s2">, </span><span class="s4">&quot;__xor__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__xor__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__iadd__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __iadd__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__iadd__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self._array.__iadd__(other._array)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__radd__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __radd__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__radd__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__radd__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__iand__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __iand__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;integer or boolean&quot;</span><span class="s2">, </span><span class="s4">&quot;__iand__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self._array.__iand__(other._array)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__rand__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __rand__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;integer or boolean&quot;</span><span class="s2">, </span><span class="s4">&quot;__rand__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__rand__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__ifloordiv__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __ifloordiv__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__ifloordiv__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self._array.__ifloordiv__(other._array)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__rfloordiv__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __rfloordiv__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__rfloordiv__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__rfloordiv__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__ilshift__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __ilshift__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;integer&quot;</span><span class="s2">, </span><span class="s4">&quot;__ilshift__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self._array.__ilshift__(other._array)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__rlshift__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __rlshift__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;integer&quot;</span><span class="s2">, </span><span class="s4">&quot;__rlshift__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__rlshift__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__imatmul__(self: Array</span><span class="s2">, </span><span class="s1">other: Array</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __imatmul__. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Note: NumPy does not implement __imatmul__.</span>

        <span class="s3"># matmul is not defined for scalars, but without this, we may get</span>
        <span class="s3"># the wrong error message from asarray.</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__imatmul__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>

        <span class="s3"># __imatmul__ can only be allowed when it would not change the shape</span>
        <span class="s3"># of self.</span>
        <span class="s1">other_shape = other.shape</span>
        <span class="s2">if </span><span class="s1">self.shape == () </span><span class="s2">or </span><span class="s1">other_shape == ():</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;@= requires at least one dimension&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(other_shape) == </span><span class="s5">1 </span><span class="s2">or </span><span class="s1">other_shape[-</span><span class="s5">1</span><span class="s1">] != other_shape[-</span><span class="s5">2</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;@= cannot change the shape of the input array&quot;</span><span class="s1">)</span>
        <span class="s1">self._array[:] = self._array.__matmul__(other._array)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__rmatmul__(self: Array</span><span class="s2">, </span><span class="s1">other: Array</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __rmatmul__. 
        &quot;&quot;&quot;</span>
        <span class="s3"># matmul is not defined for scalars, but without this, we may get</span>
        <span class="s3"># the wrong error message from asarray.</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__rmatmul__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">res = self._array.__rmatmul__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__imod__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __imod__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__imod__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self._array.__imod__(other._array)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__rmod__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __rmod__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__rmod__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__rmod__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__imul__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __imul__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__imul__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self._array.__imul__(other._array)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__rmul__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __rmul__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__rmul__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__rmul__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__ior__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __ior__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;integer or boolean&quot;</span><span class="s2">, </span><span class="s4">&quot;__ior__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self._array.__ior__(other._array)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__ror__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __ror__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;integer or boolean&quot;</span><span class="s2">, </span><span class="s4">&quot;__ror__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__ror__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__ipow__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __ipow__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__ipow__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self._array.__ipow__(other._array)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__rpow__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __rpow__. 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">._elementwise_functions </span><span class="s2">import </span><span class="s1">pow</span>

        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__rpow__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s3"># Note: NumPy's __pow__ does not follow the spec type promotion rules</span>
        <span class="s3"># for 0-d arrays, so we use pow() here instead.</span>
        <span class="s2">return </span><span class="s1">pow(other</span><span class="s2">, </span><span class="s1">self)</span>

    <span class="s2">def </span><span class="s1">__irshift__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __irshift__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;integer&quot;</span><span class="s2">, </span><span class="s4">&quot;__irshift__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self._array.__irshift__(other._array)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__rrshift__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __rrshift__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;integer&quot;</span><span class="s2">, </span><span class="s4">&quot;__rrshift__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__rrshift__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__isub__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __isub__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__isub__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self._array.__isub__(other._array)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__rsub__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __rsub__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;__rsub__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__rsub__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__itruediv__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __itruediv__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;floating-point&quot;</span><span class="s2">, </span><span class="s4">&quot;__itruediv__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self._array.__itruediv__(other._array)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__rtruediv__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[float</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __rtruediv__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;floating-point&quot;</span><span class="s2">, </span><span class="s4">&quot;__rtruediv__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__rtruediv__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">__ixor__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __ixor__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;integer or boolean&quot;</span><span class="s2">, </span><span class="s4">&quot;__ixor__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self._array.__ixor__(other._array)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__rxor__(self: Array</span><span class="s2">, </span><span class="s1">other: Union[int</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">, </span><span class="s1">/) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Performs the operation __rxor__. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = self._check_allowed_dtypes(other</span><span class="s2">, </span><span class="s4">&quot;integer or boolean&quot;</span><span class="s2">, </span><span class="s4">&quot;__rxor__&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">other </span><span class="s2">is </span><span class="s1">NotImplemented:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">other = self._normalize_two_args(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">res = self._array.__rxor__(other._array)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(res)</span>

    <span class="s2">def </span><span class="s1">to_device(self: Array</span><span class="s2">, </span><span class="s1">device: Device</span><span class="s2">, </span><span class="s1">/</span><span class="s2">, </span><span class="s1">stream: </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span><span class="s1">) -&gt; Array:</span>
        <span class="s2">if </span><span class="s1">stream </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The stream argument to to_device() is not supported&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">device == </span><span class="s4">'cpu'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Unsupported device </span><span class="s2">{</span><span class="s1">device</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">dtype(self) -&gt; Dtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        Array API compatible wrapper for :py:meth:`np.ndarray.dtype &lt;numpy.ndarray.dtype&gt;`. 
 
        See its docstring for more information. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._array.dtype</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">device(self) -&gt; Device:</span>
        <span class="s2">return </span><span class="s4">&quot;cpu&quot;</span>

    <span class="s3"># Note: mT is new in array API spec (see matrix_transpose)</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">mT(self) -&gt; Array:</span>
        <span class="s2">from </span><span class="s1">.linalg </span><span class="s2">import </span><span class="s1">matrix_transpose</span>
        <span class="s2">return </span><span class="s1">matrix_transpose(self)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ndim(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot; 
        Array API compatible wrapper for :py:meth:`np.ndarray.ndim &lt;numpy.ndarray.ndim&gt;`. 
 
        See its docstring for more information. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._array.ndim</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">shape(self) -&gt; Tuple[int</span><span class="s2">, </span><span class="s1">...]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Array API compatible wrapper for :py:meth:`np.ndarray.shape &lt;numpy.ndarray.shape&gt;`. 
 
        See its docstring for more information. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._array.shape</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">size(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot; 
        Array API compatible wrapper for :py:meth:`np.ndarray.size &lt;numpy.ndarray.size&gt;`. 
 
        See its docstring for more information. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._array.size</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">T(self) -&gt; Array:</span>
        <span class="s0">&quot;&quot;&quot; 
        Array API compatible wrapper for :py:meth:`np.ndarray.T &lt;numpy.ndarray.T&gt;`. 
 
        See its docstring for more information. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Note: T only works on 2-dimensional arrays. See the corresponding</span>
        <span class="s3"># note in the specification:</span>
        <span class="s3"># https://data-apis.org/array-api/latest/API_specification/array_object.html#t</span>
        <span class="s2">if </span><span class="s1">self.ndim != </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;x.T requires x to have 2 dimensions. Use x.mT to transpose stacks of matrices and permute_dims() to permute dimensions.&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self.__class__._new(self._array.T)</span>
</pre>
</body>
</html>