<html>
<head>
<title>_iotools.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #a5c261;}
.s5 { color: #6897bb;}
.s6 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_iotools.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;A collection of functions designed to help I/O with ascii files. 
 
&quot;&quot;&quot;</span>
<span class="s1">__docformat__ = </span><span class="s2">&quot;restructuredtext en&quot;</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">numpy.core.numeric </span><span class="s3">as </span><span class="s1">nx</span>
<span class="s3">from </span><span class="s1">numpy.compat </span><span class="s3">import </span><span class="s1">asbytes</span><span class="s3">, </span><span class="s1">asunicode</span>


<span class="s3">def </span><span class="s1">_decode_line(line</span><span class="s3">, </span><span class="s1">encoding=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Decode bytes from binary input streams. 
 
    Defaults to decoding from 'latin1'. That differs from the behavior of 
    np.compat.asunicode that decodes from 'ascii'. 
 
    Parameters 
    ---------- 
    line : str or bytes 
         Line to be decoded. 
    encoding : str 
         Encoding used to decode `line`. 
 
    Returns 
    ------- 
    decoded_line : str 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">type(line) </span><span class="s3">is </span><span class="s1">bytes:</span>
        <span class="s3">if </span><span class="s1">encoding </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">encoding = </span><span class="s2">&quot;latin1&quot;</span>
        <span class="s1">line = line.decode(encoding)</span>

    <span class="s3">return </span><span class="s1">line</span>


<span class="s3">def </span><span class="s1">_is_string_like(obj):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check whether obj behaves like a string. 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">obj + </span><span class="s2">''</span>
    <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">ValueError):</span>
        <span class="s3">return False</span>
    <span class="s3">return True</span>


<span class="s3">def </span><span class="s1">_is_bytes_like(obj):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check whether obj behaves like a bytes object. 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">obj + </span><span class="s4">b''</span>
    <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">ValueError):</span>
        <span class="s3">return False</span>
    <span class="s3">return True</span>


<span class="s3">def </span><span class="s1">has_nested_fields(ndtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns whether one or several fields of a dtype are nested. 
 
    Parameters 
    ---------- 
    ndtype : dtype 
        Data-type of a structured array. 
 
    Raises 
    ------ 
    AttributeError 
        If `ndtype` does not have a `names` attribute. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; dt = np.dtype([('name', 'S4'), ('x', float), ('y', float)]) 
    &gt;&gt;&gt; np.lib._iotools.has_nested_fields(dt) 
    False 
 
    &quot;&quot;&quot;</span>
    <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">ndtype.names </span><span class="s3">or </span><span class="s1">():</span>
        <span class="s3">if </span><span class="s1">ndtype[name].names </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return True</span>
    <span class="s3">return False</span>


<span class="s3">def </span><span class="s1">flatten_dtype(ndtype</span><span class="s3">, </span><span class="s1">flatten_base=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Unpack a structured data-type by collapsing nested fields and/or fields 
    with a shape. 
 
    Note that the field names are lost. 
 
    Parameters 
    ---------- 
    ndtype : dtype 
        The datatype to collapse 
    flatten_base : bool, optional 
       If True, transform a field with a shape into several fields. Default is 
       False. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; dt = np.dtype([('name', 'S4'), ('x', float), ('y', float), 
    ...                ('block', int, (2, 3))]) 
    &gt;&gt;&gt; np.lib._iotools.flatten_dtype(dt) 
    [dtype('S4'), dtype('float64'), dtype('float64'), dtype('int64')] 
    &gt;&gt;&gt; np.lib._iotools.flatten_dtype(dt, flatten_base=True) 
    [dtype('S4'), 
     dtype('float64'), 
     dtype('float64'), 
     dtype('int64'), 
     dtype('int64'), 
     dtype('int64'), 
     dtype('int64'), 
     dtype('int64'), 
     dtype('int64')] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">names = ndtype.names</span>
    <span class="s3">if </span><span class="s1">names </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">flatten_base:</span>
            <span class="s3">return </span><span class="s1">[ndtype.base] * int(np.prod(ndtype.shape))</span>
        <span class="s3">return </span><span class="s1">[ndtype.base]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">types = []</span>
        <span class="s3">for </span><span class="s1">field </span><span class="s3">in </span><span class="s1">names:</span>
            <span class="s1">info = ndtype.fields[field]</span>
            <span class="s1">flat_dt = flatten_dtype(info[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">flatten_base)</span>
            <span class="s1">types.extend(flat_dt)</span>
        <span class="s3">return </span><span class="s1">types</span>


<span class="s3">class </span><span class="s1">LineSplitter:</span>
    <span class="s0">&quot;&quot;&quot; 
    Object to split a string at a given delimiter or at given places. 
 
    Parameters 
    ---------- 
    delimiter : str, int, or sequence of ints, optional 
        If a string, character used to delimit consecutive fields. 
        If an integer or a sequence of integers, width(s) of each field. 
    comments : str, optional 
        Character used to mark the beginning of a comment. Default is '#'. 
    autostrip : bool, optional 
        Whether to strip each individual field. Default is True. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">autostrip(self</span><span class="s3">, </span><span class="s1">method):</span>
        <span class="s0">&quot;&quot;&quot; 
        Wrapper to strip each member of the output of `method`. 
 
        Parameters 
        ---------- 
        method : function 
            Function that takes a single argument and returns a sequence of 
            strings. 
 
        Returns 
        ------- 
        wrapped : function 
            The result of wrapping `method`. `wrapped` takes a single input 
            argument and returns a list of strings that are stripped of 
            white-space. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return lambda </span><span class="s1">input: [_.strip() </span><span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">method(input)]</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">delimiter=</span><span class="s3">None, </span><span class="s1">comments=</span><span class="s2">'#'</span><span class="s3">, </span><span class="s1">autostrip=</span><span class="s3">True,</span>
                 <span class="s1">encoding=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">delimiter = _decode_line(delimiter)</span>
        <span class="s1">comments = _decode_line(comments)</span>

        <span class="s1">self.comments = comments</span>

        <span class="s6"># Delimiter is a character</span>
        <span class="s3">if </span><span class="s1">(delimiter </span><span class="s3">is None</span><span class="s1">) </span><span class="s3">or </span><span class="s1">isinstance(delimiter</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s1">delimiter = delimiter </span><span class="s3">or None</span>
            <span class="s1">_handyman = self._delimited_splitter</span>
        <span class="s6"># Delimiter is a list of field widths</span>
        <span class="s3">elif </span><span class="s1">hasattr(delimiter</span><span class="s3">, </span><span class="s2">'__iter__'</span><span class="s1">):</span>
            <span class="s1">_handyman = self._variablewidth_splitter</span>
            <span class="s1">idx = np.cumsum([</span><span class="s5">0</span><span class="s1">] + list(delimiter))</span>
            <span class="s1">delimiter = [slice(i</span><span class="s3">, </span><span class="s1">j) </span><span class="s3">for </span><span class="s1">(i</span><span class="s3">, </span><span class="s1">j) </span><span class="s3">in </span><span class="s1">zip(idx[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">idx[</span><span class="s5">1</span><span class="s1">:])]</span>
        <span class="s6"># Delimiter is a single integer</span>
        <span class="s3">elif </span><span class="s1">int(delimiter):</span>
            <span class="s1">(_handyman</span><span class="s3">, </span><span class="s1">delimiter) = (</span>
                    <span class="s1">self._fixedwidth_splitter</span><span class="s3">, </span><span class="s1">int(delimiter))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">(_handyman</span><span class="s3">, </span><span class="s1">delimiter) = (self._delimited_splitter</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.delimiter = delimiter</span>
        <span class="s3">if </span><span class="s1">autostrip:</span>
            <span class="s1">self._handyman = self.autostrip(_handyman)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._handyman = _handyman</span>
        <span class="s1">self.encoding = encoding</span>

    <span class="s3">def </span><span class="s1">_delimited_splitter(self</span><span class="s3">, </span><span class="s1">line):</span>
        <span class="s0">&quot;&quot;&quot;Chop off comments, strip, and split at delimiter. &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.comments </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">line = line.split(self.comments)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">line = line.strip(</span><span class="s2">&quot; </span><span class="s3">\r\n</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">line:</span>
            <span class="s3">return </span><span class="s1">[]</span>
        <span class="s3">return </span><span class="s1">line.split(self.delimiter)</span>

    <span class="s3">def </span><span class="s1">_fixedwidth_splitter(self</span><span class="s3">, </span><span class="s1">line):</span>
        <span class="s3">if </span><span class="s1">self.comments </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">line = line.split(self.comments)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">line = line.strip(</span><span class="s2">&quot;</span><span class="s3">\r\n</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">line:</span>
            <span class="s3">return </span><span class="s1">[]</span>
        <span class="s1">fixed = self.delimiter</span>
        <span class="s1">slices = [slice(i</span><span class="s3">, </span><span class="s1">i + fixed) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">len(line)</span><span class="s3">, </span><span class="s1">fixed)]</span>
        <span class="s3">return </span><span class="s1">[line[s] </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">slices]</span>

    <span class="s3">def </span><span class="s1">_variablewidth_splitter(self</span><span class="s3">, </span><span class="s1">line):</span>
        <span class="s3">if </span><span class="s1">self.comments </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">line = line.split(self.comments)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">if not </span><span class="s1">line:</span>
            <span class="s3">return </span><span class="s1">[]</span>
        <span class="s1">slices = self.delimiter</span>
        <span class="s3">return </span><span class="s1">[line[s] </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">slices]</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">line):</span>
        <span class="s3">return </span><span class="s1">self._handyman(_decode_line(line</span><span class="s3">, </span><span class="s1">self.encoding))</span>


<span class="s3">class </span><span class="s1">NameValidator:</span>
    <span class="s0">&quot;&quot;&quot; 
    Object to validate a list of strings to use as field names. 
 
    The strings are stripped of any non alphanumeric character, and spaces 
    are replaced by '_'. During instantiation, the user can define a list 
    of names to exclude, as well as a list of invalid characters. Names in 
    the exclusion list are appended a '_' character. 
 
    Once an instance has been created, it can be called with a list of 
    names, and a list of valid names will be created.  The `__call__` 
    method accepts an optional keyword &quot;default&quot; that sets the default name 
    in case of ambiguity. By default this is 'f', so that names will 
    default to `f0`, `f1`, etc. 
 
    Parameters 
    ---------- 
    excludelist : sequence, optional 
        A list of names to exclude. This list is appended to the default 
        list ['return', 'file', 'print']. Excluded names are appended an 
        underscore: for example, `file` becomes `file_` if supplied. 
    deletechars : str, optional 
        A string combining invalid characters that must be deleted from the 
        names. 
    case_sensitive : {True, False, 'upper', 'lower'}, optional 
        * If True, field names are case-sensitive. 
        * If False or 'upper', field names are converted to upper case. 
        * If 'lower', field names are converted to lower case. 
 
        The default value is True. 
    replace_space : '_', optional 
        Character(s) used in replacement of white spaces. 
 
    Notes 
    ----- 
    Calling an instance of `NameValidator` is the same as calling its 
    method `validate`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; validator = np.lib._iotools.NameValidator() 
    &gt;&gt;&gt; validator(['file', 'field2', 'with space', 'CaSe']) 
    ('file_', 'field2', 'with_space', 'CaSe') 
 
    &gt;&gt;&gt; validator = np.lib._iotools.NameValidator(excludelist=['excl'], 
    ...                                           deletechars='q', 
    ...                                           case_sensitive=False) 
    &gt;&gt;&gt; validator(['excl', 'field2', 'no_q', 'with space', 'CaSe']) 
    ('EXCL', 'FIELD2', 'NO_Q', 'WITH_SPACE', 'CASE') 
 
    &quot;&quot;&quot;</span>

    <span class="s1">defaultexcludelist = [</span><span class="s2">'return'</span><span class="s3">, </span><span class="s2">'file'</span><span class="s3">, </span><span class="s2">'print'</span><span class="s1">]</span>
    <span class="s1">defaultdeletechars = set(</span><span class="s2">r&quot;&quot;&quot;~!@#$%^&amp;*()-=+~\|]}[{';: /?.&gt;,&lt;&quot;&quot;&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">excludelist=</span><span class="s3">None, </span><span class="s1">deletechars=</span><span class="s3">None,</span>
                 <span class="s1">case_sensitive=</span><span class="s3">None, </span><span class="s1">replace_space=</span><span class="s2">'_'</span><span class="s1">):</span>
        <span class="s6"># Process the exclusion list ..</span>
        <span class="s3">if </span><span class="s1">excludelist </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">excludelist = []</span>
        <span class="s1">excludelist.extend(self.defaultexcludelist)</span>
        <span class="s1">self.excludelist = excludelist</span>
        <span class="s6"># Process the list of characters to delete</span>
        <span class="s3">if </span><span class="s1">deletechars </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">delete = self.defaultdeletechars</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">delete = set(deletechars)</span>
        <span class="s1">delete.add(</span><span class="s2">'&quot;'</span><span class="s1">)</span>
        <span class="s1">self.deletechars = delete</span>
        <span class="s6"># Process the case option .....</span>
        <span class="s3">if </span><span class="s1">(case_sensitive </span><span class="s3">is None</span><span class="s1">) </span><span class="s3">or </span><span class="s1">(case_sensitive </span><span class="s3">is True</span><span class="s1">):</span>
            <span class="s1">self.case_converter = </span><span class="s3">lambda </span><span class="s1">x: x</span>
        <span class="s3">elif </span><span class="s1">(case_sensitive </span><span class="s3">is False</span><span class="s1">) </span><span class="s3">or </span><span class="s1">case_sensitive.startswith(</span><span class="s2">'u'</span><span class="s1">):</span>
            <span class="s1">self.case_converter = </span><span class="s3">lambda </span><span class="s1">x: x.upper()</span>
        <span class="s3">elif </span><span class="s1">case_sensitive.startswith(</span><span class="s2">'l'</span><span class="s1">):</span>
            <span class="s1">self.case_converter = </span><span class="s3">lambda </span><span class="s1">x: x.lower()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s2">'unrecognized case_sensitive value %s.' </span><span class="s1">% case_sensitive</span>
            <span class="s3">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s1">self.replace_space = replace_space</span>

    <span class="s3">def </span><span class="s1">validate(self</span><span class="s3">, </span><span class="s1">names</span><span class="s3">, </span><span class="s1">defaultfmt=</span><span class="s2">&quot;f%i&quot;</span><span class="s3">, </span><span class="s1">nbfields=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Validate a list of strings as field names for a structured array. 
 
        Parameters 
        ---------- 
        names : sequence of str 
            Strings to be validated. 
        defaultfmt : str, optional 
            Default format string, used if validating a given string 
            reduces its length to zero. 
        nbfields : integer, optional 
            Final number of validated names, used to expand or shrink the 
            initial list of names. 
 
        Returns 
        ------- 
        validatednames : list of str 
            The list of validated field names. 
 
        Notes 
        ----- 
        A `NameValidator` instance can be called directly, which is the 
        same as calling `validate`. For examples, see `NameValidator`. 
 
        &quot;&quot;&quot;</span>
        <span class="s6"># Initial checks ..............</span>
        <span class="s3">if </span><span class="s1">(names </span><span class="s3">is None</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s1">(nbfields </span><span class="s3">is None</span><span class="s1">):</span>
                <span class="s3">return None</span>
            <span class="s1">names = []</span>
        <span class="s3">if </span><span class="s1">isinstance(names</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s1">names = [names</span><span class="s3">, </span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">nbfields </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">nbnames = len(names)</span>
            <span class="s3">if </span><span class="s1">(nbnames &lt; nbfields):</span>
                <span class="s1">names = list(names) + [</span><span class="s2">''</span><span class="s1">] * (nbfields - nbnames)</span>
            <span class="s3">elif </span><span class="s1">(nbnames &gt; nbfields):</span>
                <span class="s1">names = names[:nbfields]</span>
        <span class="s6"># Set some shortcuts ...........</span>
        <span class="s1">deletechars = self.deletechars</span>
        <span class="s1">excludelist = self.excludelist</span>
        <span class="s1">case_converter = self.case_converter</span>
        <span class="s1">replace_space = self.replace_space</span>
        <span class="s6"># Initializes some variables ...</span>
        <span class="s1">validatednames = []</span>
        <span class="s1">seen = dict()</span>
        <span class="s1">nbempty = </span><span class="s5">0</span>

        <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">names:</span>
            <span class="s1">item = case_converter(item).strip()</span>
            <span class="s3">if </span><span class="s1">replace_space:</span>
                <span class="s1">item = item.replace(</span><span class="s2">' '</span><span class="s3">, </span><span class="s1">replace_space)</span>
            <span class="s1">item = </span><span class="s2">''</span><span class="s1">.join([c </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">item </span><span class="s3">if </span><span class="s1">c </span><span class="s3">not in </span><span class="s1">deletechars])</span>
            <span class="s3">if </span><span class="s1">item == </span><span class="s2">''</span><span class="s1">:</span>
                <span class="s1">item = defaultfmt % nbempty</span>
                <span class="s3">while </span><span class="s1">item </span><span class="s3">in </span><span class="s1">names:</span>
                    <span class="s1">nbempty += </span><span class="s5">1</span>
                    <span class="s1">item = defaultfmt % nbempty</span>
                <span class="s1">nbempty += </span><span class="s5">1</span>
            <span class="s3">elif </span><span class="s1">item </span><span class="s3">in </span><span class="s1">excludelist:</span>
                <span class="s1">item += </span><span class="s2">'_'</span>
            <span class="s1">cnt = seen.get(item</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">cnt &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">validatednames.append(item + </span><span class="s2">'_%d' </span><span class="s1">% cnt)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">validatednames.append(item)</span>
            <span class="s1">seen[item] = cnt + </span><span class="s5">1</span>
        <span class="s3">return </span><span class="s1">tuple(validatednames)</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">names</span><span class="s3">, </span><span class="s1">defaultfmt=</span><span class="s2">&quot;f%i&quot;</span><span class="s3">, </span><span class="s1">nbfields=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">self.validate(names</span><span class="s3">, </span><span class="s1">defaultfmt=defaultfmt</span><span class="s3">, </span><span class="s1">nbfields=nbfields)</span>


<span class="s3">def </span><span class="s1">str2bool(value):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tries to transform a string supposed to represent a boolean to a boolean. 
 
    Parameters 
    ---------- 
    value : str 
        The string that is transformed to a boolean. 
 
    Returns 
    ------- 
    boolval : bool 
        The boolean representation of `value`. 
 
    Raises 
    ------ 
    ValueError 
        If the string is not 'True' or 'False' (case independent) 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.lib._iotools.str2bool('TRUE') 
    True 
    &gt;&gt;&gt; np.lib._iotools.str2bool('false') 
    False 
 
    &quot;&quot;&quot;</span>
    <span class="s1">value = value.upper()</span>
    <span class="s3">if </span><span class="s1">value == </span><span class="s2">'TRUE'</span><span class="s1">:</span>
        <span class="s3">return True</span>
    <span class="s3">elif </span><span class="s1">value == </span><span class="s2">'FALSE'</span><span class="s1">:</span>
        <span class="s3">return False</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Invalid boolean&quot;</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">ConverterError(Exception):</span>
    <span class="s0">&quot;&quot;&quot; 
    Exception raised when an error occurs in a converter for string values. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">ConverterLockError(ConverterError):</span>
    <span class="s0">&quot;&quot;&quot; 
    Exception raised when an attempt is made to upgrade a locked converter. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">ConversionWarning(UserWarning):</span>
    <span class="s0">&quot;&quot;&quot; 
    Warning issued when a string converter has a problem. 
 
    Notes 
    ----- 
    In `genfromtxt` a `ConversionWarning` is issued if raising exceptions 
    is explicitly suppressed with the &quot;invalid_raise&quot; keyword. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">StringConverter:</span>
    <span class="s0">&quot;&quot;&quot; 
    Factory class for function transforming a string into another object 
    (int, float). 
 
    After initialization, an instance can be called to transform a string 
    into another object. If the string is recognized as representing a 
    missing value, a default value is returned. 
 
    Attributes 
    ---------- 
    func : function 
        Function used for the conversion. 
    default : any 
        Default value to return when the input corresponds to a missing 
        value. 
    type : type 
        Type of the output. 
    _status : int 
        Integer representing the order of the conversion. 
    _mapper : sequence of tuples 
        Sequence of tuples (dtype, function, default value) to evaluate in 
        order. 
    _locked : bool 
        Holds `locked` parameter. 
 
    Parameters 
    ---------- 
    dtype_or_func : {None, dtype, function}, optional 
        If a `dtype`, specifies the input data type, used to define a basic 
        function and a default value for missing data. For example, when 
        `dtype` is float, the `func` attribute is set to `float` and the 
        default value to `np.nan`.  If a function, this function is used to 
        convert a string to another object. In this case, it is recommended 
        to give an associated default value as input. 
    default : any, optional 
        Value to return by default, that is, when the string to be 
        converted is flagged as missing. If not given, `StringConverter` 
        tries to supply a reasonable default value. 
    missing_values : {None, sequence of str}, optional 
        ``None`` or sequence of strings indicating a missing value. If ``None`` 
        then missing values are indicated by empty entries. The default is 
        ``None``. 
    locked : bool, optional 
        Whether the StringConverter should be locked to prevent automatic 
        upgrade or not. Default is False. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_mapper = [(nx.bool_</span><span class="s3">, </span><span class="s1">str2bool</span><span class="s3">, False</span><span class="s1">)</span><span class="s3">,</span>
               <span class="s1">(nx.int_</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span><span class="s1">]</span>

    <span class="s6"># On 32-bit systems, we need to make sure that we explicitly include</span>
    <span class="s6"># nx.int64 since ns.int_ is nx.int32.</span>
    <span class="s3">if </span><span class="s1">nx.dtype(nx.int_).itemsize &lt; nx.dtype(nx.int64).itemsize:</span>
        <span class="s1">_mapper.append((nx.int64</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">))</span>

    <span class="s1">_mapper.extend([(nx.float64</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">nx.nan)</span><span class="s3">,</span>
                    <span class="s1">(nx.complex128</span><span class="s3">, </span><span class="s1">complex</span><span class="s3">, </span><span class="s1">nx.nan + </span><span class="s5">0j</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">(nx.longdouble</span><span class="s3">, </span><span class="s1">nx.longdouble</span><span class="s3">, </span><span class="s1">nx.nan)</span><span class="s3">,</span>
                    <span class="s6"># If a non-default dtype is passed, fall back to generic</span>
                    <span class="s6"># ones (should only be used for the converter)</span>
                    <span class="s1">(nx.integer</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">(nx.floating</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">nx.nan)</span><span class="s3">,</span>
                    <span class="s1">(nx.complexfloating</span><span class="s3">, </span><span class="s1">complex</span><span class="s3">, </span><span class="s1">nx.nan + </span><span class="s5">0j</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s6"># Last, try with the string types (must be last, because</span>
                    <span class="s6"># `_mapper[-1]` is used as default in some cases)</span>
                    <span class="s1">(nx.unicode_</span><span class="s3">, </span><span class="s1">asunicode</span><span class="s3">, </span><span class="s2">'???'</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">(nx.string_</span><span class="s3">, </span><span class="s1">asbytes</span><span class="s3">, </span><span class="s2">'???'</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">])</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_getdtype(cls</span><span class="s3">, </span><span class="s1">val):</span>
        <span class="s0">&quot;&quot;&quot;Returns the dtype of the input variable.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">np.array(val).dtype</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_getsubdtype(cls</span><span class="s3">, </span><span class="s1">val):</span>
        <span class="s0">&quot;&quot;&quot;Returns the type of the dtype of the input variable.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">np.array(val).dtype.type</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_dtypeortype(cls</span><span class="s3">, </span><span class="s1">dtype):</span>
        <span class="s0">&quot;&quot;&quot;Returns dtype for datetime64 and type of dtype otherwise.&quot;&quot;&quot;</span>

        <span class="s6"># This is a bit annoying. We want to return the &quot;general&quot; type in most</span>
        <span class="s6"># cases (ie. &quot;string&quot; rather than &quot;S10&quot;), but we want to return the</span>
        <span class="s6"># specific type for datetime64 (ie. &quot;datetime64[us]&quot; rather than</span>
        <span class="s6"># &quot;datetime64&quot;).</span>
        <span class="s3">if </span><span class="s1">dtype.type == np.datetime64:</span>
            <span class="s3">return </span><span class="s1">dtype</span>
        <span class="s3">return </span><span class="s1">dtype.type</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">upgrade_mapper(cls</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Upgrade the mapper of a StringConverter by adding a new function and 
        its corresponding default. 
 
        The input function (or sequence of functions) and its associated 
        default value (if any) is inserted in penultimate position of the 
        mapper.  The corresponding type is estimated from the dtype of the 
        default value. 
 
        Parameters 
        ---------- 
        func : var 
            Function, or sequence of functions 
 
        Examples 
        -------- 
        &gt;&gt;&gt; import dateutil.parser 
        &gt;&gt;&gt; import datetime 
        &gt;&gt;&gt; dateparser = dateutil.parser.parse 
        &gt;&gt;&gt; defaultdate = datetime.date(2000, 1, 1) 
        &gt;&gt;&gt; StringConverter.upgrade_mapper(dateparser, default=defaultdate) 
        &quot;&quot;&quot;</span>
        <span class="s6"># Func is a single functions</span>
        <span class="s3">if </span><span class="s1">hasattr(func</span><span class="s3">, </span><span class="s2">'__call__'</span><span class="s1">):</span>
            <span class="s1">cls._mapper.insert(-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">(cls._getsubdtype(default)</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">default))</span>
            <span class="s3">return</span>
        <span class="s3">elif </span><span class="s1">hasattr(func</span><span class="s3">, </span><span class="s2">'__iter__'</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s1">isinstance(func[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">(tuple</span><span class="s3">, </span><span class="s1">list)):</span>
                <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">func:</span>
                    <span class="s1">cls._mapper.insert(-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">_)</span>
                <span class="s3">return</span>
            <span class="s3">if </span><span class="s1">default </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">default = [</span><span class="s3">None</span><span class="s1">] * len(func)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">default = list(default)</span>
                <span class="s1">default.append([</span><span class="s3">None</span><span class="s1">] * (len(func) - len(default)))</span>
            <span class="s3">for </span><span class="s1">fct</span><span class="s3">, </span><span class="s1">dft </span><span class="s3">in </span><span class="s1">zip(func</span><span class="s3">, </span><span class="s1">default):</span>
                <span class="s1">cls._mapper.insert(-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">(cls._getsubdtype(dft)</span><span class="s3">, </span><span class="s1">fct</span><span class="s3">, </span><span class="s1">dft))</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_find_map_entry(cls</span><span class="s3">, </span><span class="s1">dtype):</span>
        <span class="s6"># if a converter for the specific dtype is available use that</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">(deftype</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">default_def) </span><span class="s3">in </span><span class="s1">enumerate(cls._mapper):</span>
            <span class="s3">if </span><span class="s1">dtype.type == deftype:</span>
                <span class="s3">return </span><span class="s1">i</span><span class="s3">, </span><span class="s1">(deftype</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">default_def)</span>

        <span class="s6"># otherwise find an inexact match</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">(deftype</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">default_def) </span><span class="s3">in </span><span class="s1">enumerate(cls._mapper):</span>
            <span class="s3">if </span><span class="s1">np.issubdtype(dtype.type</span><span class="s3">, </span><span class="s1">deftype):</span>
                <span class="s3">return </span><span class="s1">i</span><span class="s3">, </span><span class="s1">(deftype</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">default_def)</span>

        <span class="s3">raise </span><span class="s1">LookupError</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">dtype_or_func=</span><span class="s3">None, </span><span class="s1">default=</span><span class="s3">None, </span><span class="s1">missing_values=</span><span class="s3">None,</span>
                 <span class="s1">locked=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s6"># Defines a lock for upgrade</span>
        <span class="s1">self._locked = bool(locked)</span>
        <span class="s6"># No input dtype: minimal initialization</span>
        <span class="s3">if </span><span class="s1">dtype_or_func </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.func = str2bool</span>
            <span class="s1">self._status = </span><span class="s5">0</span>
            <span class="s1">self.default = default </span><span class="s3">or False</span>
            <span class="s1">dtype = np.dtype(</span><span class="s2">'bool'</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s6"># Is the input a np.dtype ?</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self.func = </span><span class="s3">None</span>
                <span class="s1">dtype = np.dtype(dtype_or_func)</span>
            <span class="s3">except </span><span class="s1">TypeError:</span>
                <span class="s6"># dtype_or_func must be a function, then</span>
                <span class="s3">if not </span><span class="s1">hasattr(dtype_or_func</span><span class="s3">, </span><span class="s2">'__call__'</span><span class="s1">):</span>
                    <span class="s1">errmsg = (</span><span class="s2">&quot;The input argument `dtype` is neither a&quot;</span>
                              <span class="s2">&quot; function nor a dtype (got '%s' instead)&quot;</span><span class="s1">)</span>
                    <span class="s3">raise </span><span class="s1">TypeError(errmsg % type(dtype_or_func))</span>
                <span class="s6"># Set the function</span>
                <span class="s1">self.func = dtype_or_func</span>
                <span class="s6"># If we don't have a default, try to guess it or set it to</span>
                <span class="s6"># None</span>
                <span class="s3">if </span><span class="s1">default </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s1">default = self.func(</span><span class="s2">'0'</span><span class="s1">)</span>
                    <span class="s3">except </span><span class="s1">ValueError:</span>
                        <span class="s1">default = </span><span class="s3">None</span>
                <span class="s1">dtype = self._getdtype(default)</span>

            <span class="s6"># find the best match in our mapper</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self._status</span><span class="s3">, </span><span class="s1">(_</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">default_def) = self._find_map_entry(dtype)</span>
            <span class="s3">except </span><span class="s1">LookupError:</span>
                <span class="s6"># no match</span>
                <span class="s1">self.default = default</span>
                <span class="s1">_</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">_ = self._mapper[-</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">self._status = </span><span class="s5">0</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s6"># use the found default only if we did not already have one</span>
                <span class="s3">if </span><span class="s1">default </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s1">self.default = default_def</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">self.default = default</span>

            <span class="s6"># If the input was a dtype, set the function to the last we saw</span>
            <span class="s3">if </span><span class="s1">self.func </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">self.func = func</span>

            <span class="s6"># If the status is 1 (int), change the function to</span>
            <span class="s6"># something more robust.</span>
            <span class="s3">if </span><span class="s1">self.func == self._mapper[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]:</span>
                <span class="s3">if </span><span class="s1">issubclass(dtype.type</span><span class="s3">, </span><span class="s1">np.uint64):</span>
                    <span class="s1">self.func = np.uint64</span>
                <span class="s3">elif </span><span class="s1">issubclass(dtype.type</span><span class="s3">, </span><span class="s1">np.int64):</span>
                    <span class="s1">self.func = np.int64</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">self.func = </span><span class="s3">lambda </span><span class="s1">x: int(float(x))</span>
        <span class="s6"># Store the list of strings corresponding to missing values.</span>
        <span class="s3">if </span><span class="s1">missing_values </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.missing_values = {</span><span class="s2">''</span><span class="s1">}</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">isinstance(missing_values</span><span class="s3">, </span><span class="s1">str):</span>
                <span class="s1">missing_values = missing_values.split(</span><span class="s2">&quot;,&quot;</span><span class="s1">)</span>
            <span class="s1">self.missing_values = set(list(missing_values) + [</span><span class="s2">''</span><span class="s1">])</span>

        <span class="s1">self._callingfunction = self._strict_call</span>
        <span class="s1">self.type = self._dtypeortype(dtype)</span>
        <span class="s1">self._checked = </span><span class="s3">False</span>
        <span class="s1">self._initial_default = default</span>

    <span class="s3">def </span><span class="s1">_loose_call(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.func(value)</span>
        <span class="s3">except </span><span class="s1">ValueError:</span>
            <span class="s3">return </span><span class="s1">self.default</span>

    <span class="s3">def </span><span class="s1">_strict_call(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">try</span><span class="s1">:</span>

            <span class="s6"># We check if we can convert the value using the current function</span>
            <span class="s1">new_value = self.func(value)</span>

            <span class="s6"># In addition to having to check whether func can convert the</span>
            <span class="s6"># value, we also have to make sure that we don't get overflow</span>
            <span class="s6"># errors for integers.</span>
            <span class="s3">if </span><span class="s1">self.func </span><span class="s3">is </span><span class="s1">int:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">np.array(value</span><span class="s3">, </span><span class="s1">dtype=self.type)</span>
                <span class="s3">except </span><span class="s1">OverflowError:</span>
                    <span class="s3">raise </span><span class="s1">ValueError</span>

            <span class="s6"># We're still here so we can now return the new value</span>
            <span class="s3">return </span><span class="s1">new_value</span>

        <span class="s3">except </span><span class="s1">ValueError:</span>
            <span class="s3">if </span><span class="s1">value.strip() </span><span class="s3">in </span><span class="s1">self.missing_values:</span>
                <span class="s3">if not </span><span class="s1">self._status:</span>
                    <span class="s1">self._checked = </span><span class="s3">False</span>
                <span class="s3">return </span><span class="s1">self.default</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Cannot convert string '%s'&quot; </span><span class="s1">% value)</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">return </span><span class="s1">self._callingfunction(value)</span>

    <span class="s3">def </span><span class="s1">_do_upgrade(self):</span>
        <span class="s6"># Raise an exception if we locked the converter...</span>
        <span class="s3">if </span><span class="s1">self._locked:</span>
            <span class="s1">errmsg = </span><span class="s2">&quot;Converter is locked and cannot be upgraded&quot;</span>
            <span class="s3">raise </span><span class="s1">ConverterLockError(errmsg)</span>
        <span class="s1">_statusmax = len(self._mapper)</span>
        <span class="s6"># Complains if we try to upgrade by the maximum</span>
        <span class="s1">_status = self._status</span>
        <span class="s3">if </span><span class="s1">_status == _statusmax:</span>
            <span class="s1">errmsg = </span><span class="s2">&quot;Could not find a valid conversion function&quot;</span>
            <span class="s3">raise </span><span class="s1">ConverterError(errmsg)</span>
        <span class="s3">elif </span><span class="s1">_status &lt; _statusmax - </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">_status += </span><span class="s5">1</span>
        <span class="s1">self.type</span><span class="s3">, </span><span class="s1">self.func</span><span class="s3">, </span><span class="s1">default = self._mapper[_status]</span>
        <span class="s1">self._status = _status</span>
        <span class="s3">if </span><span class="s1">self._initial_default </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.default = self._initial_default</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.default = default</span>

    <span class="s3">def </span><span class="s1">upgrade(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot; 
        Find the best converter for a given string, and return the result. 
 
        The supplied string `value` is converted by testing different 
        converters in order. First the `func` method of the 
        `StringConverter` instance is tried, if this fails other available 
        converters are tried.  The order in which these other converters 
        are tried is determined by the `_status` attribute of the instance. 
 
        Parameters 
        ---------- 
        value : str 
            The string to convert. 
 
        Returns 
        ------- 
        out : any 
            The result of converting `value` with the appropriate converter. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._checked = </span><span class="s3">True</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._strict_call(value)</span>
        <span class="s3">except </span><span class="s1">ValueError:</span>
            <span class="s1">self._do_upgrade()</span>
            <span class="s3">return </span><span class="s1">self.upgrade(value)</span>

    <span class="s3">def </span><span class="s1">iterupgrade(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s1">self._checked = </span><span class="s3">True</span>
        <span class="s3">if not </span><span class="s1">hasattr(value</span><span class="s3">, </span><span class="s2">'__iter__'</span><span class="s1">):</span>
            <span class="s1">value = (value</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s1">_strict_call = self._strict_call</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">_m </span><span class="s3">in </span><span class="s1">value:</span>
                <span class="s1">_strict_call(_m)</span>
        <span class="s3">except </span><span class="s1">ValueError:</span>
            <span class="s1">self._do_upgrade()</span>
            <span class="s1">self.iterupgrade(value)</span>

    <span class="s3">def </span><span class="s1">update(self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None, </span><span class="s1">testing_value=</span><span class="s3">None,</span>
               <span class="s1">missing_values=</span><span class="s2">''</span><span class="s3">, </span><span class="s1">locked=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set StringConverter attributes directly. 
 
        Parameters 
        ---------- 
        func : function 
            Conversion function. 
        default : any, optional 
            Value to return by default, that is, when the string to be 
            converted is flagged as missing. If not given, 
            `StringConverter` tries to supply a reasonable default value. 
        testing_value : str, optional 
            A string representing a standard input value of the converter. 
            This string is used to help defining a reasonable default 
            value. 
        missing_values : {sequence of str, None}, optional 
            Sequence of strings indicating a missing value. If ``None``, then 
            the existing `missing_values` are cleared. The default is `''`. 
        locked : bool, optional 
            Whether the StringConverter should be locked to prevent 
            automatic upgrade or not. Default is False. 
 
        Notes 
        ----- 
        `update` takes the same parameters as the constructor of 
        `StringConverter`, except that `func` does not accept a `dtype` 
        whereas `dtype_or_func` in the constructor does. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.func = func</span>
        <span class="s1">self._locked = locked</span>

        <span class="s6"># Don't reset the default to None if we can avoid it</span>
        <span class="s3">if </span><span class="s1">default </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.default = default</span>
            <span class="s1">self.type = self._dtypeortype(self._getdtype(default))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">tester = func(testing_value </span><span class="s3">or </span><span class="s2">'1'</span><span class="s1">)</span>
            <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">ValueError):</span>
                <span class="s1">tester = </span><span class="s3">None</span>
            <span class="s1">self.type = self._dtypeortype(self._getdtype(tester))</span>

        <span class="s6"># Add the missing values to the existing set or clear it.</span>
        <span class="s3">if </span><span class="s1">missing_values </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s6"># Clear all missing values even though the ctor initializes it to</span>
            <span class="s6"># set(['']) when the argument is None.</span>
            <span class="s1">self.missing_values = set()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if not </span><span class="s1">np.iterable(missing_values):</span>
                <span class="s1">missing_values = [missing_values]</span>
            <span class="s3">if not </span><span class="s1">all(isinstance(v</span><span class="s3">, </span><span class="s1">str) </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">missing_values):</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;missing_values must be strings or unicode&quot;</span><span class="s1">)</span>
            <span class="s1">self.missing_values.update(missing_values)</span>


<span class="s3">def </span><span class="s1">easy_dtype(ndtype</span><span class="s3">, </span><span class="s1">names=</span><span class="s3">None, </span><span class="s1">defaultfmt=</span><span class="s2">&quot;f%i&quot;</span><span class="s3">, </span><span class="s1">**validationargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convenience function to create a `np.dtype` object. 
 
    The function processes the input `dtype` and matches it with the given 
    names. 
 
    Parameters 
    ---------- 
    ndtype : var 
        Definition of the dtype. Can be any string or dictionary recognized 
        by the `np.dtype` function, or a sequence of types. 
    names : str or sequence, optional 
        Sequence of strings to use as field names for a structured dtype. 
        For convenience, `names` can be a string of a comma-separated list 
        of names. 
    defaultfmt : str, optional 
        Format string used to define missing names, such as ``&quot;f%i&quot;`` 
        (default) or ``&quot;fields_%02i&quot;``. 
    validationargs : optional 
        A series of optional arguments used to initialize a 
        `NameValidator`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.lib._iotools.easy_dtype(float) 
    dtype('float64') 
    &gt;&gt;&gt; np.lib._iotools.easy_dtype(&quot;i4, f8&quot;) 
    dtype([('f0', '&lt;i4'), ('f1', '&lt;f8')]) 
    &gt;&gt;&gt; np.lib._iotools.easy_dtype(&quot;i4, f8&quot;, defaultfmt=&quot;field_%03i&quot;) 
    dtype([('field_000', '&lt;i4'), ('field_001', '&lt;f8')]) 
 
    &gt;&gt;&gt; np.lib._iotools.easy_dtype((int, float, float), names=&quot;a,b,c&quot;) 
    dtype([('a', '&lt;i8'), ('b', '&lt;f8'), ('c', '&lt;f8')]) 
    &gt;&gt;&gt; np.lib._iotools.easy_dtype(float, names=&quot;a,b,c&quot;) 
    dtype([('a', '&lt;f8'), ('b', '&lt;f8'), ('c', '&lt;f8')]) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">ndtype = np.dtype(ndtype)</span>
    <span class="s3">except </span><span class="s1">TypeError:</span>
        <span class="s1">validate = NameValidator(**validationargs)</span>
        <span class="s1">nbfields = len(ndtype)</span>
        <span class="s3">if </span><span class="s1">names </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">names = [</span><span class="s2">''</span><span class="s1">] * len(ndtype)</span>
        <span class="s3">elif </span><span class="s1">isinstance(names</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s1">names = names.split(</span><span class="s2">&quot;,&quot;</span><span class="s1">)</span>
        <span class="s1">names = validate(names</span><span class="s3">, </span><span class="s1">nbfields=nbfields</span><span class="s3">, </span><span class="s1">defaultfmt=defaultfmt)</span>
        <span class="s1">ndtype = np.dtype(dict(formats=ndtype</span><span class="s3">, </span><span class="s1">names=names))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s6"># Explicit names</span>
        <span class="s3">if </span><span class="s1">names </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">validate = NameValidator(**validationargs)</span>
            <span class="s3">if </span><span class="s1">isinstance(names</span><span class="s3">, </span><span class="s1">str):</span>
                <span class="s1">names = names.split(</span><span class="s2">&quot;,&quot;</span><span class="s1">)</span>
            <span class="s6"># Simple dtype: repeat to match the nb of names</span>
            <span class="s3">if </span><span class="s1">ndtype.names </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">formats = tuple([ndtype.type] * len(names))</span>
                <span class="s1">names = validate(names</span><span class="s3">, </span><span class="s1">defaultfmt=defaultfmt)</span>
                <span class="s1">ndtype = np.dtype(list(zip(names</span><span class="s3">, </span><span class="s1">formats)))</span>
            <span class="s6"># Structured dtype: just validate the names as needed</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">ndtype.names = validate(names</span><span class="s3">, </span><span class="s1">nbfields=len(ndtype.names)</span><span class="s3">,</span>
                                        <span class="s1">defaultfmt=defaultfmt)</span>
        <span class="s6"># No implicit names</span>
        <span class="s3">elif </span><span class="s1">ndtype.names </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">validate = NameValidator(**validationargs)</span>
            <span class="s6"># Default initial names : should we change the format ?</span>
            <span class="s1">numbered_names = tuple(</span><span class="s2">&quot;f%i&quot; </span><span class="s1">% i </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(len(ndtype.names)))</span>
            <span class="s3">if </span><span class="s1">((ndtype.names == numbered_names) </span><span class="s3">and </span><span class="s1">(defaultfmt != </span><span class="s2">&quot;f%i&quot;</span><span class="s1">)):</span>
                <span class="s1">ndtype.names = validate([</span><span class="s2">''</span><span class="s1">] * len(ndtype.names)</span><span class="s3">,</span>
                                        <span class="s1">defaultfmt=defaultfmt)</span>
            <span class="s6"># Explicit initial names : just validate</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">ndtype.names = validate(ndtype.names</span><span class="s3">, </span><span class="s1">defaultfmt=defaultfmt)</span>
    <span class="s3">return </span><span class="s1">ndtype</span>
</pre>
</body>
</html>