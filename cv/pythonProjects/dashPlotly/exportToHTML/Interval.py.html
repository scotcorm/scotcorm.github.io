<html>
<head>
<title>interval.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
interval.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; define the IntervalIndex &quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">operator </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">le</span><span class="s2">,</span>
    <span class="s1">lt</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">textwrap</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Hashable</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">pandas._libs </span><span class="s2">import </span><span class="s1">lib</span>
<span class="s2">from </span><span class="s1">pandas._libs.interval </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Interval</span><span class="s2">,</span>
    <span class="s1">IntervalMixin</span><span class="s2">,</span>
    <span class="s1">IntervalTree</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">BaseOffset</span><span class="s2">,</span>
    <span class="s1">Timedelta</span><span class="s2">,</span>
    <span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">to_offset</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas._typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Dtype</span><span class="s2">,</span>
    <span class="s1">DtypeObj</span><span class="s2">,</span>
    <span class="s1">npt</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.errors </span><span class="s2">import </span><span class="s1">InvalidIndexError</span>
<span class="s2">from </span><span class="s1">pandas.util._decorators </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Appender</span><span class="s2">,</span>
    <span class="s1">cache_readonly</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.util._exceptions </span><span class="s2">import </span><span class="s1">rewrite_exception</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">find_common_type</span><span class="s2">,</span>
    <span class="s1">infer_dtype_from_scalar</span><span class="s2">,</span>
    <span class="s1">maybe_box_datetimelike</span><span class="s2">,</span>
    <span class="s1">maybe_downcast_numeric</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ensure_platform_int</span><span class="s2">,</span>
    <span class="s1">is_datetime64tz_dtype</span><span class="s2">,</span>
    <span class="s1">is_datetime_or_timedelta_dtype</span><span class="s2">,</span>
    <span class="s1">is_dtype_equal</span><span class="s2">,</span>
    <span class="s1">is_float</span><span class="s2">,</span>
    <span class="s1">is_float_dtype</span><span class="s2">,</span>
    <span class="s1">is_integer</span><span class="s2">,</span>
    <span class="s1">is_integer_dtype</span><span class="s2">,</span>
    <span class="s1">is_interval_dtype</span><span class="s2">,</span>
    <span class="s1">is_list_like</span><span class="s2">,</span>
    <span class="s1">is_number</span><span class="s2">,</span>
    <span class="s1">is_object_dtype</span><span class="s2">,</span>
    <span class="s1">is_scalar</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s2">import </span><span class="s1">IntervalDtype</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s2">import </span><span class="s1">is_valid_na_for_dtype</span>

<span class="s2">from </span><span class="s1">pandas.core.algorithms </span><span class="s2">import </span><span class="s1">unique</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays.interval </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">IntervalArray</span><span class="s2">,</span>
    <span class="s1">_interval_shared_docs</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas.core.common </span><span class="s2">as </span><span class="s1">com</span>
<span class="s2">from </span><span class="s1">pandas.core.indexers </span><span class="s2">import </span><span class="s1">is_valid_positional_slice</span>
<span class="s2">import </span><span class="s1">pandas.core.indexes.base </span><span class="s2">as </span><span class="s1">ibase</span>
<span class="s2">from </span><span class="s1">pandas.core.indexes.base </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Index</span><span class="s2">,</span>
    <span class="s1">_index_shared_docs</span><span class="s2">,</span>
    <span class="s1">ensure_index</span><span class="s2">,</span>
    <span class="s1">maybe_extract_name</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.indexes.datetimes </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DatetimeIndex</span><span class="s2">,</span>
    <span class="s1">date_range</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.indexes.extension </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ExtensionIndex</span><span class="s2">,</span>
    <span class="s1">inherit_names</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.indexes.multi </span><span class="s2">import </span><span class="s1">MultiIndex</span>
<span class="s2">from </span><span class="s1">pandas.core.indexes.timedeltas </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">TimedeltaIndex</span><span class="s2">,</span>
    <span class="s1">timedelta_range</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s1">_index_doc_kwargs = dict(ibase._index_doc_kwargs)</span>

<span class="s1">_index_doc_kwargs.update(</span>
    <span class="s1">{</span>
        <span class="s3">&quot;klass&quot;</span><span class="s1">: </span><span class="s3">&quot;IntervalIndex&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;qualname&quot;</span><span class="s1">: </span><span class="s3">&quot;IntervalIndex&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;target_klass&quot;</span><span class="s1">: </span><span class="s3">&quot;IntervalIndex or list of Intervals&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;name&quot;</span><span class="s1">: textwrap.dedent(</span>
            <span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
         </span><span class="s3">name : object, optional 
              Name to be stored in the index. 
         &quot;&quot;&quot;</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">}</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">_get_next_label(label):</span>
    <span class="s1">dtype = getattr(label</span><span class="s2">, </span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">type(label))</span>
    <span class="s2">if </span><span class="s1">isinstance(label</span><span class="s2">, </span><span class="s1">(Timestamp</span><span class="s2">, </span><span class="s1">Timedelta)):</span>
        <span class="s1">dtype = </span><span class="s3">&quot;datetime64&quot;</span>
    <span class="s2">if </span><span class="s1">is_datetime_or_timedelta_dtype(dtype) </span><span class="s2">or </span><span class="s1">is_datetime64tz_dtype(dtype):</span>
        <span class="s2">return </span><span class="s1">label + np.timedelta64(</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">is_integer_dtype(dtype):</span>
        <span class="s2">return </span><span class="s1">label + </span><span class="s4">1</span>
    <span class="s2">elif </span><span class="s1">is_float_dtype(dtype):</span>
        <span class="s2">return </span><span class="s1">np.nextafter(label</span><span class="s2">, </span><span class="s1">np.infty)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;cannot determine next label for type </span><span class="s2">{</span><span class="s1">repr(type(label))</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_get_prev_label(label):</span>
    <span class="s1">dtype = getattr(label</span><span class="s2">, </span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">type(label))</span>
    <span class="s2">if </span><span class="s1">isinstance(label</span><span class="s2">, </span><span class="s1">(Timestamp</span><span class="s2">, </span><span class="s1">Timedelta)):</span>
        <span class="s1">dtype = </span><span class="s3">&quot;datetime64&quot;</span>
    <span class="s2">if </span><span class="s1">is_datetime_or_timedelta_dtype(dtype) </span><span class="s2">or </span><span class="s1">is_datetime64tz_dtype(dtype):</span>
        <span class="s2">return </span><span class="s1">label - np.timedelta64(</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">is_integer_dtype(dtype):</span>
        <span class="s2">return </span><span class="s1">label - </span><span class="s4">1</span>
    <span class="s2">elif </span><span class="s1">is_float_dtype(dtype):</span>
        <span class="s2">return </span><span class="s1">np.nextafter(label</span><span class="s2">, </span><span class="s1">-np.infty)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;cannot determine next label for type </span><span class="s2">{</span><span class="s1">repr(type(label))</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_new_IntervalIndex(cls</span><span class="s2">, </span><span class="s1">d):</span>
    <span class="s0">&quot;&quot;&quot; 
    This is called upon unpickling, rather than the default which doesn't have 
    arguments and breaks __new__. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">cls.from_arrays(**d)</span>


<span class="s1">@Appender(</span>
    <span class="s1">_interval_shared_docs[</span><span class="s3">&quot;class&quot;</span><span class="s1">]</span>
    <span class="s1">% {</span>
        <span class="s3">&quot;klass&quot;</span><span class="s1">: </span><span class="s3">&quot;IntervalIndex&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;summary&quot;</span><span class="s1">: </span><span class="s3">&quot;Immutable index of intervals that are closed on the same side.&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;name&quot;</span><span class="s1">: _index_doc_kwargs[</span><span class="s3">&quot;name&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;versionadded&quot;</span><span class="s1">: </span><span class="s3">&quot;0.20.0&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;extra_attributes&quot;</span><span class="s1">: </span><span class="s3">&quot;is_overlapping</span><span class="s2">\n</span><span class="s3">values</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;extra_methods&quot;</span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;examples&quot;</span><span class="s1">: textwrap.dedent(</span>
            <span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
    </span><span class="s3">Examples 
    -------- 
    A new ``IntervalIndex`` is typically constructed using 
    :func:`interval_range`: 
 
    &gt;&gt;&gt; pd.interval_range(start=0, end=5) 
    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]], 
                  dtype='interval[int64, right]') 
 
    It may also be constructed using one of the constructor 
    methods: :meth:`IntervalIndex.from_arrays`, 
    :meth:`IntervalIndex.from_breaks`, and :meth:`IntervalIndex.from_tuples`. 
 
    See further examples in the doc strings of ``interval_range`` and the 
    mentioned constructor methods. 
    &quot;&quot;&quot;</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">}</span>
<span class="s1">)</span>
<span class="s1">@inherit_names([</span><span class="s3">&quot;set_closed&quot;</span><span class="s2">, </span><span class="s3">&quot;to_tuples&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">IntervalArray</span><span class="s2">, </span><span class="s1">wrap=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s1">@inherit_names(</span>
    <span class="s1">[</span>
        <span class="s3">&quot;__array__&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;overlaps&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;contains&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;closed_left&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;closed_right&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;open_left&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;open_right&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;is_empty&quot;</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">IntervalArray</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s1">@inherit_names([</span><span class="s3">&quot;is_non_overlapping_monotonic&quot;</span><span class="s2">, </span><span class="s3">&quot;closed&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">IntervalArray</span><span class="s2">, </span><span class="s1">cache=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">IntervalIndex(ExtensionIndex):</span>
    <span class="s1">_typ = </span><span class="s3">&quot;intervalindex&quot;</span>

    <span class="s5"># annotate properties pinned via inherit_names</span>
    <span class="s1">closed: str</span>
    <span class="s1">is_non_overlapping_monotonic: bool</span>
    <span class="s1">closed_left: bool</span>
    <span class="s1">closed_right: bool</span>

    <span class="s1">_data: IntervalArray</span>
    <span class="s1">_values: IntervalArray</span>
    <span class="s1">_can_hold_strings = </span><span class="s2">False</span>
    <span class="s1">_data_cls = IntervalArray</span>

    <span class="s5"># --------------------------------------------------------------------</span>
    <span class="s5"># Constructors</span>

    <span class="s2">def </span><span class="s1">__new__(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">data</span><span class="s2">,</span>
        <span class="s1">closed=</span><span class="s2">None,</span>
        <span class="s1">dtype: Dtype | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">copy: bool = </span><span class="s2">False,</span>
        <span class="s1">name: Hashable = </span><span class="s2">None,</span>
        <span class="s1">verify_integrity: bool = </span><span class="s2">True,</span>
    <span class="s1">) -&gt; IntervalIndex:</span>

        <span class="s1">name = maybe_extract_name(name</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">cls)</span>

        <span class="s2">with </span><span class="s1">rewrite_exception(</span><span class="s3">&quot;IntervalArray&quot;</span><span class="s2">, </span><span class="s1">cls.__name__):</span>
            <span class="s1">array = IntervalArray(</span>
                <span class="s1">data</span><span class="s2">,</span>
                <span class="s1">closed=closed</span><span class="s2">,</span>
                <span class="s1">copy=copy</span><span class="s2">,</span>
                <span class="s1">dtype=dtype</span><span class="s2">,</span>
                <span class="s1">verify_integrity=verify_integrity</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">cls._simple_new(array</span><span class="s2">, </span><span class="s1">name)</span>

    <span class="s1">@classmethod</span>
    <span class="s1">@Appender(</span>
        <span class="s1">_interval_shared_docs[</span><span class="s3">&quot;from_breaks&quot;</span><span class="s1">]</span>
        <span class="s1">% {</span>
            <span class="s3">&quot;klass&quot;</span><span class="s1">: </span><span class="s3">&quot;IntervalIndex&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;examples&quot;</span><span class="s1">: textwrap.dedent(</span>
                <span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
        </span><span class="s3">Examples 
        -------- 
        &gt;&gt;&gt; pd.IntervalIndex.from_breaks([0, 1, 2, 3]) 
        IntervalIndex([(0, 1], (1, 2], (2, 3]], 
                      dtype='interval[int64, right]') 
        &quot;&quot;&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">from_breaks(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">breaks</span><span class="s2">,</span>
        <span class="s1">closed: str = </span><span class="s3">&quot;right&quot;</span><span class="s2">,</span>
        <span class="s1">name: Hashable = </span><span class="s2">None,</span>
        <span class="s1">copy: bool = </span><span class="s2">False,</span>
        <span class="s1">dtype: Dtype | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">) -&gt; IntervalIndex:</span>
        <span class="s2">with </span><span class="s1">rewrite_exception(</span><span class="s3">&quot;IntervalArray&quot;</span><span class="s2">, </span><span class="s1">cls.__name__):</span>
            <span class="s1">array = IntervalArray.from_breaks(</span>
                <span class="s1">breaks</span><span class="s2">, </span><span class="s1">closed=closed</span><span class="s2">, </span><span class="s1">copy=copy</span><span class="s2">, </span><span class="s1">dtype=dtype</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">cls._simple_new(array</span><span class="s2">, </span><span class="s1">name=name)</span>

    <span class="s1">@classmethod</span>
    <span class="s1">@Appender(</span>
        <span class="s1">_interval_shared_docs[</span><span class="s3">&quot;from_arrays&quot;</span><span class="s1">]</span>
        <span class="s1">% {</span>
            <span class="s3">&quot;klass&quot;</span><span class="s1">: </span><span class="s3">&quot;IntervalIndex&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;examples&quot;</span><span class="s1">: textwrap.dedent(</span>
                <span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
        </span><span class="s3">Examples 
        -------- 
        &gt;&gt;&gt; pd.IntervalIndex.from_arrays([0, 1, 2], [1, 2, 3]) 
        IntervalIndex([(0, 1], (1, 2], (2, 3]], 
                      dtype='interval[int64, right]') 
        &quot;&quot;&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">from_arrays(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">left</span><span class="s2">,</span>
        <span class="s1">right</span><span class="s2">,</span>
        <span class="s1">closed: str = </span><span class="s3">&quot;right&quot;</span><span class="s2">,</span>
        <span class="s1">name: Hashable = </span><span class="s2">None,</span>
        <span class="s1">copy: bool = </span><span class="s2">False,</span>
        <span class="s1">dtype: Dtype | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">) -&gt; IntervalIndex:</span>
        <span class="s2">with </span><span class="s1">rewrite_exception(</span><span class="s3">&quot;IntervalArray&quot;</span><span class="s2">, </span><span class="s1">cls.__name__):</span>
            <span class="s1">array = IntervalArray.from_arrays(</span>
                <span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">closed</span><span class="s2">, </span><span class="s1">copy=copy</span><span class="s2">, </span><span class="s1">dtype=dtype</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">cls._simple_new(array</span><span class="s2">, </span><span class="s1">name=name)</span>

    <span class="s1">@classmethod</span>
    <span class="s1">@Appender(</span>
        <span class="s1">_interval_shared_docs[</span><span class="s3">&quot;from_tuples&quot;</span><span class="s1">]</span>
        <span class="s1">% {</span>
            <span class="s3">&quot;klass&quot;</span><span class="s1">: </span><span class="s3">&quot;IntervalIndex&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;examples&quot;</span><span class="s1">: textwrap.dedent(</span>
                <span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
        </span><span class="s3">Examples 
        -------- 
        &gt;&gt;&gt; pd.IntervalIndex.from_tuples([(0, 1), (1, 2)]) 
        IntervalIndex([(0, 1], (1, 2]], 
                       dtype='interval[int64, right]') 
        &quot;&quot;&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">from_tuples(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">data</span><span class="s2">,</span>
        <span class="s1">closed: str = </span><span class="s3">&quot;right&quot;</span><span class="s2">,</span>
        <span class="s1">name: Hashable = </span><span class="s2">None,</span>
        <span class="s1">copy: bool = </span><span class="s2">False,</span>
        <span class="s1">dtype: Dtype | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">) -&gt; IntervalIndex:</span>
        <span class="s2">with </span><span class="s1">rewrite_exception(</span><span class="s3">&quot;IntervalArray&quot;</span><span class="s2">, </span><span class="s1">cls.__name__):</span>
            <span class="s1">arr = IntervalArray.from_tuples(data</span><span class="s2">, </span><span class="s1">closed=closed</span><span class="s2">, </span><span class="s1">copy=copy</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s2">return </span><span class="s1">cls._simple_new(arr</span><span class="s2">, </span><span class="s1">name=name)</span>

    <span class="s5"># --------------------------------------------------------------------</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">_engine(self) -&gt; IntervalTree:</span>
        <span class="s1">left = self._maybe_convert_i8(self.left)</span>
        <span class="s1">right = self._maybe_convert_i8(self.right)</span>
        <span class="s2">return </span><span class="s1">IntervalTree(left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">closed=self.closed)</span>

    <span class="s2">def </span><span class="s1">__contains__(self</span><span class="s2">, </span><span class="s1">key: Any) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        return a boolean if this key is IN the index 
        We *only* accept an Interval 
 
        Parameters 
        ---------- 
        key : Interval 
 
        Returns 
        ------- 
        bool 
        &quot;&quot;&quot;</span>
        <span class="s1">hash(key)</span>
        <span class="s2">if not </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">Interval):</span>
            <span class="s2">if </span><span class="s1">is_valid_na_for_dtype(key</span><span class="s2">, </span><span class="s1">self.dtype):</span>
                <span class="s2">return </span><span class="s1">self.hasnans</span>
            <span class="s2">return False</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.get_loc(key)</span>
            <span class="s2">return True</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">return False</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">_multiindex(self) -&gt; MultiIndex:</span>
        <span class="s2">return </span><span class="s1">MultiIndex.from_arrays([self.left</span><span class="s2">, </span><span class="s1">self.right]</span><span class="s2">, </span><span class="s1">names=[</span><span class="s3">&quot;left&quot;</span><span class="s2">, </span><span class="s3">&quot;right&quot;</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">__reduce__(self):</span>
        <span class="s1">d = {</span>
            <span class="s3">&quot;left&quot;</span><span class="s1">: self.left</span><span class="s2">,</span>
            <span class="s3">&quot;right&quot;</span><span class="s1">: self.right</span><span class="s2">,</span>
            <span class="s3">&quot;closed&quot;</span><span class="s1">: self.closed</span><span class="s2">,</span>
            <span class="s3">&quot;name&quot;</span><span class="s1">: self.name</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">_new_IntervalIndex</span><span class="s2">, </span><span class="s1">(type(self)</span><span class="s2">, </span><span class="s1">d)</span><span class="s2">, None</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">inferred_type(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Return a string of the type inferred from the values&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">&quot;interval&quot;</span>

    <span class="s1">@Appender(Index.memory_usage.__doc__)</span>
    <span class="s2">def </span><span class="s1">memory_usage(self</span><span class="s2">, </span><span class="s1">deep: bool = </span><span class="s2">False</span><span class="s1">) -&gt; int:</span>
        <span class="s5"># we don't use an explicit engine</span>
        <span class="s5"># so return the bytes here</span>
        <span class="s2">return </span><span class="s1">self.left.memory_usage(deep=deep) + self.right.memory_usage(deep=deep)</span>

    <span class="s5"># IntervalTree doesn't have a is_monotonic_decreasing, so have to override</span>
    <span class="s5">#  the Index implementation</span>
    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">is_monotonic_decreasing(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return True if the IntervalIndex is monotonic decreasing (only equal or 
        decreasing values), else False 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self[::-</span><span class="s4">1</span><span class="s1">].is_monotonic_increasing</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">is_unique(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return True if the IntervalIndex contains unique elements, else False. 
        &quot;&quot;&quot;</span>
        <span class="s1">left = self.left</span>
        <span class="s1">right = self.right</span>

        <span class="s2">if </span><span class="s1">self.isna().sum() &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">return False</span>

        <span class="s2">if </span><span class="s1">left.is_unique </span><span class="s2">or </span><span class="s1">right.is_unique:</span>
            <span class="s2">return True</span>

        <span class="s1">seen_pairs = set()</span>
        <span class="s1">check_idx = np.where(left.duplicated(keep=</span><span class="s2">False</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">check_idx:</span>
            <span class="s1">pair = (left[idx]</span><span class="s2">, </span><span class="s1">right[idx])</span>
            <span class="s2">if </span><span class="s1">pair </span><span class="s2">in </span><span class="s1">seen_pairs:</span>
                <span class="s2">return False</span>
            <span class="s1">seen_pairs.add(pair)</span>

        <span class="s2">return True</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_overlapping(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return True if the IntervalIndex has overlapping intervals, else False. 
 
        Two intervals overlap if they share a common point, including closed 
        endpoints. Intervals that only have an open endpoint in common do not 
        overlap. 
 
        Returns 
        ------- 
        bool 
            Boolean indicating if the IntervalIndex has overlapping intervals. 
 
        See Also 
        -------- 
        Interval.overlaps : Check whether two Interval objects overlap. 
        IntervalIndex.overlaps : Check an IntervalIndex elementwise for 
            overlaps. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; index = pd.IntervalIndex.from_tuples([(0, 2), (1, 3), (4, 5)]) 
        &gt;&gt;&gt; index 
        IntervalIndex([(0, 2], (1, 3], (4, 5]], 
              dtype='interval[int64, right]') 
        &gt;&gt;&gt; index.is_overlapping 
        True 
 
        Intervals that share closed endpoints overlap: 
 
        &gt;&gt;&gt; index = pd.interval_range(0, 3, closed='both') 
        &gt;&gt;&gt; index 
        IntervalIndex([[0, 1], [1, 2], [2, 3]], 
              dtype='interval[int64, both]') 
        &gt;&gt;&gt; index.is_overlapping 
        True 
 
        Intervals that only have an open endpoint in common do not overlap: 
 
        &gt;&gt;&gt; index = pd.interval_range(0, 3, closed='left') 
        &gt;&gt;&gt; index 
        IntervalIndex([[0, 1), [1, 2), [2, 3)], 
              dtype='interval[int64, left]') 
        &gt;&gt;&gt; index.is_overlapping 
        False 
        &quot;&quot;&quot;</span>
        <span class="s5"># GH 23309</span>
        <span class="s2">return </span><span class="s1">self._engine.is_overlapping</span>

    <span class="s2">def </span><span class="s1">_needs_i8_conversion(self</span><span class="s2">, </span><span class="s1">key) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Check if a given key needs i8 conversion. Conversion is necessary for 
        Timestamp, Timedelta, DatetimeIndex, and TimedeltaIndex keys. An 
        Interval-like requires conversion if its endpoints are one of the 
        aforementioned types. 
 
        Assumes that any list-like data has already been cast to an Index. 
 
        Parameters 
        ---------- 
        key : scalar or Index-like 
            The key that should be checked for i8 conversion 
 
        Returns 
        ------- 
        bool 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">is_interval_dtype(key) </span><span class="s2">or </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">Interval):</span>
            <span class="s2">return </span><span class="s1">self._needs_i8_conversion(key.left)</span>

        <span class="s1">i8_types = (Timestamp</span><span class="s2">, </span><span class="s1">Timedelta</span><span class="s2">, </span><span class="s1">DatetimeIndex</span><span class="s2">, </span><span class="s1">TimedeltaIndex)</span>
        <span class="s2">return </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">i8_types)</span>

    <span class="s2">def </span><span class="s1">_maybe_convert_i8(self</span><span class="s2">, </span><span class="s1">key):</span>
        <span class="s0">&quot;&quot;&quot; 
        Maybe convert a given key to its equivalent i8 value(s). Used as a 
        preprocessing step prior to IntervalTree queries (self._engine), which 
        expects numeric data. 
 
        Parameters 
        ---------- 
        key : scalar or list-like 
            The key that should maybe be converted to i8. 
 
        Returns 
        ------- 
        scalar or list-like 
            The original key if no conversion occurred, int if converted scalar, 
            Int64Index if converted list-like. 
        &quot;&quot;&quot;</span>
        <span class="s1">original = key</span>
        <span class="s2">if </span><span class="s1">is_list_like(key):</span>
            <span class="s1">key = ensure_index(key)</span>

        <span class="s2">if not </span><span class="s1">self._needs_i8_conversion(key):</span>
            <span class="s2">return </span><span class="s1">original</span>

        <span class="s1">scalar = is_scalar(key)</span>
        <span class="s2">if </span><span class="s1">is_interval_dtype(key) </span><span class="s2">or </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">Interval):</span>
            <span class="s5"># convert left/right and reconstruct</span>
            <span class="s1">left = self._maybe_convert_i8(key.left)</span>
            <span class="s1">right = self._maybe_convert_i8(key.right)</span>
            <span class="s1">constructor = Interval </span><span class="s2">if </span><span class="s1">scalar </span><span class="s2">else </span><span class="s1">IntervalIndex.from_arrays</span>
            <span class="s2">return </span><span class="s1">constructor(left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">closed=self.closed)</span>

        <span class="s2">if </span><span class="s1">scalar:</span>
            <span class="s5"># Timestamp/Timedelta</span>
            <span class="s1">key_dtype</span><span class="s2">, </span><span class="s1">key_i8 = infer_dtype_from_scalar(key</span><span class="s2">, </span><span class="s1">pandas_dtype=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">lib.is_period(key):</span>
                <span class="s1">key_i8 = key.ordinal</span>
            <span class="s2">elif </span><span class="s1">isinstance(key_i8</span><span class="s2">, </span><span class="s1">Timestamp):</span>
                <span class="s1">key_i8 = key_i8.value</span>
            <span class="s2">elif </span><span class="s1">isinstance(key_i8</span><span class="s2">, </span><span class="s1">(np.datetime64</span><span class="s2">, </span><span class="s1">np.timedelta64)):</span>
                <span class="s1">key_i8 = key_i8.view(</span><span class="s3">&quot;i8&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># DatetimeIndex/TimedeltaIndex</span>
            <span class="s1">key_dtype</span><span class="s2">, </span><span class="s1">key_i8 = key.dtype</span><span class="s2">, </span><span class="s1">Index(key.asi8)</span>
            <span class="s2">if </span><span class="s1">key.hasnans:</span>
                <span class="s5"># convert NaT from its i8 value to np.nan so it's not viewed</span>
                <span class="s5"># as a valid value, maybe causing errors (e.g. is_overlapping)</span>
                <span class="s1">key_i8 = key_i8.where(~key._isnan)</span>

        <span class="s5"># ensure consistency with IntervalIndex subtype</span>
        <span class="s5"># error: Item &quot;ExtensionDtype&quot;/&quot;dtype[Any]&quot; of &quot;Union[dtype[Any],</span>
        <span class="s5"># ExtensionDtype]&quot; has no attribute &quot;subtype&quot;</span>
        <span class="s1">subtype = self.dtype.subtype  </span><span class="s5"># type: ignore[union-attr]</span>

        <span class="s2">if not </span><span class="s1">is_dtype_equal(subtype</span><span class="s2">, </span><span class="s1">key_dtype):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">f&quot;Cannot index an IntervalIndex of subtype </span><span class="s2">{</span><span class="s1">subtype</span><span class="s2">} </span><span class="s3">with &quot;</span>
                <span class="s3">f&quot;values of dtype </span><span class="s2">{</span><span class="s1">key_dtype</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">key_i8</span>

    <span class="s2">def </span><span class="s1">_searchsorted_monotonic(self</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">side: str = </span><span class="s3">&quot;left&quot;</span><span class="s1">):</span>
        <span class="s2">if not </span><span class="s1">self.is_non_overlapping_monotonic:</span>
            <span class="s2">raise </span><span class="s1">KeyError(</span>
                <span class="s3">&quot;can only get slices from an IntervalIndex if bounds are &quot;</span>
                <span class="s3">&quot;non-overlapping and all monotonic increasing or decreasing&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(label</span><span class="s2">, </span><span class="s1">(IntervalMixin</span><span class="s2">, </span><span class="s1">IntervalIndex)):</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;Interval objects are not currently supported&quot;</span><span class="s1">)</span>

        <span class="s5"># GH 20921: &quot;not is_monotonic_increasing&quot; for the second condition</span>
        <span class="s5"># instead of &quot;is_monotonic_decreasing&quot; to account for single element</span>
        <span class="s5"># indexes being both increasing and decreasing</span>
        <span class="s2">if </span><span class="s1">(side == </span><span class="s3">&quot;left&quot; </span><span class="s2">and </span><span class="s1">self.left.is_monotonic_increasing) </span><span class="s2">or </span><span class="s1">(</span>
            <span class="s1">side == </span><span class="s3">&quot;right&quot; </span><span class="s2">and not </span><span class="s1">self.left.is_monotonic_increasing</span>
        <span class="s1">):</span>
            <span class="s1">sub_idx = self.right</span>
            <span class="s2">if </span><span class="s1">self.open_right:</span>
                <span class="s1">label = _get_next_label(label)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">sub_idx = self.left</span>
            <span class="s2">if </span><span class="s1">self.open_left:</span>
                <span class="s1">label = _get_prev_label(label)</span>

        <span class="s2">return </span><span class="s1">sub_idx._searchsorted_monotonic(label</span><span class="s2">, </span><span class="s1">side)</span>

    <span class="s5"># --------------------------------------------------------------------</span>
    <span class="s5"># Indexing Methods</span>

    <span class="s2">def </span><span class="s1">get_loc(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">method: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None, </span><span class="s1">tolerance=</span><span class="s2">None</span>
    <span class="s1">) -&gt; int | slice | np.ndarray:</span>
        <span class="s0">&quot;&quot;&quot; 
        Get integer location, slice or boolean mask for requested label. 
 
        Parameters 
        ---------- 
        key : label 
        method : {None}, optional 
            * default: matches where the label is within an interval only. 
 
        Returns 
        ------- 
        int if unique index, slice if monotonic index, else mask 
 
        Examples 
        -------- 
        &gt;&gt;&gt; i1, i2 = pd.Interval(0, 1), pd.Interval(1, 2) 
        &gt;&gt;&gt; index = pd.IntervalIndex([i1, i2]) 
        &gt;&gt;&gt; index.get_loc(1) 
        0 
 
        You can also supply a point inside an interval. 
 
        &gt;&gt;&gt; index.get_loc(1.5) 
        1 
 
        If a label is in several intervals, you get the locations of all the 
        relevant intervals. 
 
        &gt;&gt;&gt; i3 = pd.Interval(0, 2) 
        &gt;&gt;&gt; overlapping_index = pd.IntervalIndex([i1, i2, i3]) 
        &gt;&gt;&gt; overlapping_index.get_loc(0.5) 
        array([ True, False,  True]) 
 
        Only exact matches will be returned if an interval is provided. 
 
        &gt;&gt;&gt; index.get_loc(pd.Interval(0, 1)) 
        0 
        &quot;&quot;&quot;</span>
        <span class="s1">self._check_indexing_method(method)</span>
        <span class="s1">self._check_indexing_error(key)</span>

        <span class="s2">if </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">Interval):</span>
            <span class="s2">if </span><span class="s1">self.closed != key.closed:</span>
                <span class="s2">raise </span><span class="s1">KeyError(key)</span>
            <span class="s1">mask = (self.left == key.left) &amp; (self.right == key.right)</span>
        <span class="s2">elif </span><span class="s1">is_valid_na_for_dtype(key</span><span class="s2">, </span><span class="s1">self.dtype):</span>
            <span class="s1">mask = self.isna()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># assume scalar</span>
            <span class="s1">op_left = le </span><span class="s2">if </span><span class="s1">self.closed_left </span><span class="s2">else </span><span class="s1">lt</span>
            <span class="s1">op_right = le </span><span class="s2">if </span><span class="s1">self.closed_right </span><span class="s2">else </span><span class="s1">lt</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">mask = op_left(self.left</span><span class="s2">, </span><span class="s1">key) &amp; op_right(key</span><span class="s2">, </span><span class="s1">self.right)</span>
            <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s5"># scalar is not comparable to II subtype --&gt; invalid label</span>
                <span class="s2">raise </span><span class="s1">KeyError(key) </span><span class="s2">from </span><span class="s1">err</span>

        <span class="s1">matches = mask.sum()</span>
        <span class="s2">if </span><span class="s1">matches == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">KeyError(key)</span>
        <span class="s2">elif </span><span class="s1">matches == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">mask.argmax()</span>

        <span class="s1">res = lib.maybe_booleans_to_slice(mask.view(</span><span class="s3">&quot;u1&quot;</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">isinstance(res</span><span class="s2">, </span><span class="s1">slice) </span><span class="s2">and </span><span class="s1">res.stop </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s5"># TODO: DO this in maybe_booleans_to_slice?</span>
            <span class="s1">res = slice(res.start</span><span class="s2">, </span><span class="s1">len(self)</span><span class="s2">, </span><span class="s1">res.step)</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">_get_indexer(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">target: Index</span><span class="s2">,</span>
        <span class="s1">method: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">limit: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">tolerance: Any | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">) -&gt; npt.NDArray[np.intp]:</span>

        <span class="s2">if </span><span class="s1">isinstance(target</span><span class="s2">, </span><span class="s1">IntervalIndex):</span>
            <span class="s5"># We only get here with not self.is_overlapping</span>
            <span class="s5"># -&gt; at most one match per interval in target</span>
            <span class="s5"># want exact matches -&gt; need both left/right to match, so defer to</span>
            <span class="s5"># left/right get_indexer, compare elementwise, equality -&gt; match</span>
            <span class="s1">indexer = self._get_indexer_unique_sides(target)</span>

        <span class="s2">elif not </span><span class="s1">is_object_dtype(target.dtype):</span>
            <span class="s5"># homogeneous scalar index: use IntervalTree</span>
            <span class="s5"># we should always have self._should_partial_index(target) here</span>
            <span class="s1">target = self._maybe_convert_i8(target)</span>
            <span class="s1">indexer = self._engine.get_indexer(target.values)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># heterogeneous scalar index: defer elementwise to get_loc</span>
            <span class="s5"># we should always have self._should_partial_index(target) here</span>
            <span class="s2">return </span><span class="s1">self._get_indexer_pointwise(target)[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s2">return </span><span class="s1">ensure_platform_int(indexer)</span>

    <span class="s1">@Appender(_index_shared_docs[</span><span class="s3">&quot;get_indexer_non_unique&quot;</span><span class="s1">] % _index_doc_kwargs)</span>
    <span class="s2">def </span><span class="s1">get_indexer_non_unique(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">target: Index</span>
    <span class="s1">) -&gt; tuple[npt.NDArray[np.intp]</span><span class="s2">, </span><span class="s1">npt.NDArray[np.intp]]:</span>
        <span class="s1">target = ensure_index(target)</span>

        <span class="s2">if not </span><span class="s1">self._should_compare(target) </span><span class="s2">and not </span><span class="s1">self._should_partial_index(target):</span>
            <span class="s5"># e.g. IntervalIndex with different closed or incompatible subtype</span>
            <span class="s5">#  -&gt; no matches</span>
            <span class="s2">return </span><span class="s1">self._get_indexer_non_comparable(target</span><span class="s2">, None, </span><span class="s1">unique=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s2">elif </span><span class="s1">isinstance(target</span><span class="s2">, </span><span class="s1">IntervalIndex):</span>
            <span class="s2">if </span><span class="s1">self.left.is_unique </span><span class="s2">and </span><span class="s1">self.right.is_unique:</span>
                <span class="s5"># fastpath available even if we don't have self._index_as_unique</span>
                <span class="s1">indexer = self._get_indexer_unique_sides(target)</span>
                <span class="s1">missing = (indexer == -</span><span class="s4">1</span><span class="s1">).nonzero()[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self._get_indexer_pointwise(target)</span>

        <span class="s2">elif </span><span class="s1">is_object_dtype(target.dtype) </span><span class="s2">or not </span><span class="s1">self._should_partial_index(target):</span>
            <span class="s5"># target might contain intervals: defer elementwise to get_loc</span>
            <span class="s2">return </span><span class="s1">self._get_indexer_pointwise(target)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># Note: this case behaves differently from other Index subclasses</span>
            <span class="s5">#  because IntervalIndex does partial-int indexing</span>
            <span class="s1">target = self._maybe_convert_i8(target)</span>
            <span class="s1">indexer</span><span class="s2">, </span><span class="s1">missing = self._engine.get_indexer_non_unique(target.values)</span>

        <span class="s2">return </span><span class="s1">ensure_platform_int(indexer)</span><span class="s2">, </span><span class="s1">ensure_platform_int(missing)</span>

    <span class="s2">def </span><span class="s1">_get_indexer_unique_sides(self</span><span class="s2">, </span><span class="s1">target: IntervalIndex) -&gt; npt.NDArray[np.intp]:</span>
        <span class="s0">&quot;&quot;&quot; 
        _get_indexer specialized to the case where both of our sides are unique. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Caller is responsible for checking</span>
        <span class="s5">#  `self.left.is_unique and self.right.is_unique`</span>

        <span class="s1">left_indexer = self.left.get_indexer(target.left)</span>
        <span class="s1">right_indexer = self.right.get_indexer(target.right)</span>
        <span class="s1">indexer = np.where(left_indexer == right_indexer</span><span class="s2">, </span><span class="s1">left_indexer</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">indexer</span>

    <span class="s2">def </span><span class="s1">_get_indexer_pointwise(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">target: Index</span>
    <span class="s1">) -&gt; tuple[npt.NDArray[np.intp]</span><span class="s2">, </span><span class="s1">npt.NDArray[np.intp]]:</span>
        <span class="s0">&quot;&quot;&quot; 
        pointwise implementation for get_indexer and get_indexer_non_unique. 
        &quot;&quot;&quot;</span>
        <span class="s1">indexer</span><span class="s2">, </span><span class="s1">missing = []</span><span class="s2">, </span><span class="s1">[]</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">key </span><span class="s2">in </span><span class="s1">enumerate(target):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">locs = self.get_loc(key)</span>
                <span class="s2">if </span><span class="s1">isinstance(locs</span><span class="s2">, </span><span class="s1">slice):</span>
                    <span class="s5"># Only needed for get_indexer_non_unique</span>
                    <span class="s1">locs = np.arange(locs.start</span><span class="s2">, </span><span class="s1">locs.stop</span><span class="s2">, </span><span class="s1">locs.step</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;intp&quot;</span><span class="s1">)</span>
                <span class="s2">elif </span><span class="s1">lib.is_integer(locs):</span>
                    <span class="s1">locs = np.array(locs</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s5"># otherwise we have ndarray[bool]</span>
                    <span class="s1">locs = np.where(locs)[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s1">missing.append(i)</span>
                <span class="s1">locs = np.array([-</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s2">except </span><span class="s1">InvalidIndexError:</span>
                <span class="s5"># i.e. non-scalar key e.g. a tuple.</span>
                <span class="s5"># see test_append_different_columns_types_raises</span>
                <span class="s1">missing.append(i)</span>
                <span class="s1">locs = np.array([-</span><span class="s4">1</span><span class="s1">])</span>

            <span class="s1">indexer.append(locs)</span>

        <span class="s1">indexer = np.concatenate(indexer)</span>
        <span class="s2">return </span><span class="s1">ensure_platform_int(indexer)</span><span class="s2">, </span><span class="s1">ensure_platform_int(missing)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">_index_as_unique(self) -&gt; bool:</span>
        <span class="s2">return not </span><span class="s1">self.is_overlapping </span><span class="s2">and </span><span class="s1">self._engine._na_count &lt; </span><span class="s4">2</span>

    <span class="s1">_requires_unique_msg = (</span>
        <span class="s3">&quot;cannot handle overlapping indices; use IntervalIndex.get_indexer_non_unique&quot;</span>
    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_convert_slice_indexer(self</span><span class="s2">, </span><span class="s1">key: slice</span><span class="s2">, </span><span class="s1">kind: str):</span>
        <span class="s2">if not </span><span class="s1">(key.step </span><span class="s2">is None or </span><span class="s1">key.step == </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s5"># GH#31658 if label-based, we require step == 1,</span>
            <span class="s5">#  if positional, we disallow float start/stop</span>
            <span class="s1">msg = </span><span class="s3">&quot;label-based slicing with step!=1 is not supported for IntervalIndex&quot;</span>
            <span class="s2">if </span><span class="s1">kind == </span><span class="s3">&quot;loc&quot;</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s2">elif </span><span class="s1">kind == </span><span class="s3">&quot;getitem&quot;</span><span class="s1">:</span>
                <span class="s2">if not </span><span class="s1">is_valid_positional_slice(key):</span>
                    <span class="s5"># i.e. this cannot be interpreted as a positional slice</span>
                    <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s2">return </span><span class="s1">super()._convert_slice_indexer(key</span><span class="s2">, </span><span class="s1">kind)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">_should_fallback_to_positional(self) -&gt; bool:</span>
        <span class="s5"># integer lookups in Series.__getitem__ are unambiguously</span>
        <span class="s5">#  positional in this case</span>
        <span class="s5"># error: Item &quot;ExtensionDtype&quot;/&quot;dtype[Any]&quot; of &quot;Union[dtype[Any],</span>
        <span class="s5"># ExtensionDtype]&quot; has no attribute &quot;subtype&quot;</span>
        <span class="s2">return </span><span class="s1">self.dtype.subtype.kind </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;m&quot;</span><span class="s2">, </span><span class="s3">&quot;M&quot;</span><span class="s1">]  </span><span class="s5"># type: ignore[union-attr]</span>

    <span class="s2">def </span><span class="s1">_maybe_cast_slice_bound(self</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">side: str</span><span class="s2">, </span><span class="s1">kind=lib.no_default):</span>
        <span class="s1">self._deprecated_arg(kind</span><span class="s2">, </span><span class="s3">&quot;kind&quot;</span><span class="s2">, </span><span class="s3">&quot;_maybe_cast_slice_bound&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">side)._maybe_cast_slice_bound(label</span><span class="s2">, </span><span class="s1">side)</span>

    <span class="s2">def </span><span class="s1">_is_comparable_dtype(self</span><span class="s2">, </span><span class="s1">dtype: DtypeObj) -&gt; bool:</span>
        <span class="s2">if not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">IntervalDtype):</span>
            <span class="s2">return False</span>
        <span class="s1">common_subtype = find_common_type([self.dtype</span><span class="s2">, </span><span class="s1">dtype])</span>
        <span class="s2">return not </span><span class="s1">is_object_dtype(common_subtype)</span>

    <span class="s5"># --------------------------------------------------------------------</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">left(self) -&gt; Index:</span>
        <span class="s2">return </span><span class="s1">Index(self._data.left</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">right(self) -&gt; Index:</span>
        <span class="s2">return </span><span class="s1">Index(self._data.right</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">mid(self) -&gt; Index:</span>
        <span class="s2">return </span><span class="s1">Index(self._data.mid</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">length(self) -&gt; Index:</span>
        <span class="s2">return </span><span class="s1">Index(self._data.length</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s5"># --------------------------------------------------------------------</span>
    <span class="s5"># Rendering Methods</span>
    <span class="s5"># __repr__ associated methods are based on MultiIndex</span>

    <span class="s2">def </span><span class="s1">_format_with_header(self</span><span class="s2">, </span><span class="s1">header: list[str]</span><span class="s2">, </span><span class="s1">na_rep: str) -&gt; list[str]:</span>
        <span class="s5"># matches base class except for whitespace padding</span>
        <span class="s2">return </span><span class="s1">header + list(self._format_native_types(na_rep=na_rep))</span>

    <span class="s2">def </span><span class="s1">_format_native_types(self</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">na_rep=</span><span class="s3">&quot;NaN&quot;</span><span class="s2">, </span><span class="s1">quoting=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s5"># GH 28210: use base method but with different default na_rep</span>
        <span class="s2">return </span><span class="s1">super()._format_native_types(na_rep=na_rep</span><span class="s2">, </span><span class="s1">quoting=quoting</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">_format_data(self</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None</span><span class="s1">) -&gt; str:</span>
        <span class="s5"># TODO: integrate with categorical and make generic</span>
        <span class="s5"># name argument is unused here; just for compat with base / categorical</span>
        <span class="s2">return </span><span class="s1">self._data._format_data() + </span><span class="s3">&quot;,&quot; </span><span class="s1">+ self._format_space()</span>

    <span class="s5"># --------------------------------------------------------------------</span>
    <span class="s5"># Set Operations</span>

    <span class="s2">def </span><span class="s1">_intersection(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">sort):</span>
        <span class="s0">&quot;&quot;&quot; 
        intersection specialized to the case with matching dtypes. 
        &quot;&quot;&quot;</span>
        <span class="s5"># For IntervalIndex we also know other.closed == self.closed</span>
        <span class="s2">if </span><span class="s1">self.left.is_unique </span><span class="s2">and </span><span class="s1">self.right.is_unique:</span>
            <span class="s1">taken = self._intersection_unique(other)</span>
        <span class="s2">elif </span><span class="s1">other.left.is_unique </span><span class="s2">and </span><span class="s1">other.right.is_unique </span><span class="s2">and </span><span class="s1">self.isna().sum() &lt;= </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s5"># Swap other/self if other is unique and self does not have</span>
            <span class="s5"># multiple NaNs</span>
            <span class="s1">taken = other._intersection_unique(self)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># duplicates</span>
            <span class="s1">taken = self._intersection_non_unique(other)</span>

        <span class="s2">if </span><span class="s1">sort </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">taken = taken.sort_values()</span>

        <span class="s2">return </span><span class="s1">taken</span>

    <span class="s2">def </span><span class="s1">_intersection_unique(self</span><span class="s2">, </span><span class="s1">other: IntervalIndex) -&gt; IntervalIndex:</span>
        <span class="s0">&quot;&quot;&quot; 
        Used when the IntervalIndex does not have any common endpoint, 
        no matter left or right. 
        Return the intersection with another IntervalIndex. 
        Parameters 
        ---------- 
        other : IntervalIndex 
        Returns 
        ------- 
        IntervalIndex 
        &quot;&quot;&quot;</span>
        <span class="s5"># Note: this is much more performant than super()._intersection(other)</span>
        <span class="s1">lindexer = self.left.get_indexer(other.left)</span>
        <span class="s1">rindexer = self.right.get_indexer(other.right)</span>

        <span class="s1">match = (lindexer == rindexer) &amp; (lindexer != -</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">indexer = lindexer.take(match.nonzero()[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">indexer = unique(indexer)</span>

        <span class="s2">return </span><span class="s1">self.take(indexer)</span>

    <span class="s2">def </span><span class="s1">_intersection_non_unique(self</span><span class="s2">, </span><span class="s1">other: IntervalIndex) -&gt; IntervalIndex:</span>
        <span class="s0">&quot;&quot;&quot; 
        Used when the IntervalIndex does have some common endpoints, 
        on either sides. 
        Return the intersection with another IntervalIndex. 
 
        Parameters 
        ---------- 
        other : IntervalIndex 
 
        Returns 
        ------- 
        IntervalIndex 
        &quot;&quot;&quot;</span>
        <span class="s5"># Note: this is about 3.25x faster than super()._intersection(other)</span>
        <span class="s5">#  in IntervalIndexMethod.time_intersection_both_duplicate(1000)</span>
        <span class="s1">mask = np.zeros(len(self)</span><span class="s2">, </span><span class="s1">dtype=bool)</span>

        <span class="s2">if </span><span class="s1">self.hasnans </span><span class="s2">and </span><span class="s1">other.hasnans:</span>
            <span class="s1">first_nan_loc = np.arange(len(self))[self.isna()][</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">mask[first_nan_loc] = </span><span class="s2">True</span>

        <span class="s1">other_tups = set(zip(other.left</span><span class="s2">, </span><span class="s1">other.right))</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">tup </span><span class="s2">in </span><span class="s1">enumerate(zip(self.left</span><span class="s2">, </span><span class="s1">self.right)):</span>
            <span class="s2">if </span><span class="s1">tup </span><span class="s2">in </span><span class="s1">other_tups:</span>
                <span class="s1">mask[i] = </span><span class="s2">True</span>

        <span class="s2">return </span><span class="s1">self[mask]</span>

    <span class="s5"># --------------------------------------------------------------------</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_is_all_dates(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        This is False even when left/right contain datetime-like objects, 
        as the check is done on the Interval itself 
        &quot;&quot;&quot;</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">_get_engine_target(self) -&gt; np.ndarray:</span>
        <span class="s5"># Note: we _could_ use libjoin functions by either casting to object</span>
        <span class="s5">#  dtype or constructing tuples (faster than constructing Intervals)</span>
        <span class="s5">#  but the libjoin fastpaths are no longer fast in these cases.</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s3">&quot;IntervalIndex does not use libjoin fastpaths or pass values to &quot;</span>
            <span class="s3">&quot;IndexEngine objects&quot;</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_from_join_target(self</span><span class="s2">, </span><span class="s1">result):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;IntervalIndex does not use libjoin fastpaths&quot;</span><span class="s1">)</span>

    <span class="s5"># TODO: arithmetic operations</span>


<span class="s2">def </span><span class="s1">_is_valid_endpoint(endpoint) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper for interval_range to check if start/end are valid types. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">any(</span>
        <span class="s1">[</span>
            <span class="s1">is_number(endpoint)</span><span class="s2">,</span>
            <span class="s1">isinstance(endpoint</span><span class="s2">, </span><span class="s1">Timestamp)</span><span class="s2">,</span>
            <span class="s1">isinstance(endpoint</span><span class="s2">, </span><span class="s1">Timedelta)</span><span class="s2">,</span>
            <span class="s1">endpoint </span><span class="s2">is None,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_is_type_compatible(a</span><span class="s2">, </span><span class="s1">b) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper for interval_range to check type compat of start/end/freq. 
    &quot;&quot;&quot;</span>
    <span class="s1">is_ts_compat = </span><span class="s2">lambda </span><span class="s1">x: isinstance(x</span><span class="s2">, </span><span class="s1">(Timestamp</span><span class="s2">, </span><span class="s1">BaseOffset))</span>
    <span class="s1">is_td_compat = </span><span class="s2">lambda </span><span class="s1">x: isinstance(x</span><span class="s2">, </span><span class="s1">(Timedelta</span><span class="s2">, </span><span class="s1">BaseOffset))</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">(is_number(a) </span><span class="s2">and </span><span class="s1">is_number(b))</span>
        <span class="s2">or </span><span class="s1">(is_ts_compat(a) </span><span class="s2">and </span><span class="s1">is_ts_compat(b))</span>
        <span class="s2">or </span><span class="s1">(is_td_compat(a) </span><span class="s2">and </span><span class="s1">is_td_compat(b))</span>
        <span class="s2">or </span><span class="s1">com.any_none(a</span><span class="s2">, </span><span class="s1">b)</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">interval_range(</span>
    <span class="s1">start=</span><span class="s2">None, </span><span class="s1">end=</span><span class="s2">None, </span><span class="s1">periods=</span><span class="s2">None, </span><span class="s1">freq=</span><span class="s2">None, </span><span class="s1">name: Hashable = </span><span class="s2">None, </span><span class="s1">closed=</span><span class="s3">&quot;right&quot;</span>
<span class="s1">) -&gt; IntervalIndex:</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a fixed frequency IntervalIndex. 
 
    Parameters 
    ---------- 
    start : numeric or datetime-like, default None 
        Left bound for generating intervals. 
    end : numeric or datetime-like, default None 
        Right bound for generating intervals. 
    periods : int, default None 
        Number of periods to generate. 
    freq : numeric, str, or DateOffset, default None 
        The length of each interval. Must be consistent with the type of start 
        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1 
        for numeric and 'D' for datetime-like. 
    name : str, default None 
        Name of the resulting IntervalIndex. 
    closed : {'left', 'right', 'both', 'neither'}, default 'right' 
        Whether the intervals are closed on the left-side, right-side, both 
        or neither. 
 
    Returns 
    ------- 
    IntervalIndex 
 
    See Also 
    -------- 
    IntervalIndex : An Index of intervals that are all closed on the same side. 
 
    Notes 
    ----- 
    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``, 
    exactly three must be specified. If ``freq`` is omitted, the resulting 
    ``IntervalIndex`` will have ``periods`` linearly spaced elements between 
    ``start`` and ``end``, inclusively. 
 
    To learn more about datetime-like frequency strings, please see `this link 
    &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`__. 
 
    Examples 
    -------- 
    Numeric ``start`` and  ``end`` is supported. 
 
    &gt;&gt;&gt; pd.interval_range(start=0, end=5) 
    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]], 
                  dtype='interval[int64, right]') 
 
    Additionally, datetime-like input is also supported. 
 
    &gt;&gt;&gt; pd.interval_range(start=pd.Timestamp('2017-01-01'), 
    ...                   end=pd.Timestamp('2017-01-04')) 
    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03], 
                   (2017-01-03, 2017-01-04]], 
                  dtype='interval[datetime64[ns], right]') 
 
    The ``freq`` parameter specifies the frequency between the left and right. 
    endpoints of the individual intervals within the ``IntervalIndex``.  For 
    numeric ``start`` and ``end``, the frequency must also be numeric. 
 
    &gt;&gt;&gt; pd.interval_range(start=0, periods=4, freq=1.5) 
    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]], 
                  dtype='interval[float64, right]') 
 
    Similarly, for datetime-like ``start`` and ``end``, the frequency must be 
    convertible to a DateOffset. 
 
    &gt;&gt;&gt; pd.interval_range(start=pd.Timestamp('2017-01-01'), 
    ...                   periods=3, freq='MS') 
    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01], 
                   (2017-03-01, 2017-04-01]], 
                  dtype='interval[datetime64[ns], right]') 
 
    Specify ``start``, ``end``, and ``periods``; the frequency is generated 
    automatically (linearly spaced). 
 
    &gt;&gt;&gt; pd.interval_range(start=0, end=6, periods=4) 
    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]], 
              dtype='interval[float64, right]') 
 
    The ``closed`` parameter specifies which endpoints of the individual 
    intervals within the ``IntervalIndex`` are closed. 
 
    &gt;&gt;&gt; pd.interval_range(end=5, periods=4, closed='both') 
    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]], 
                  dtype='interval[int64, both]') 
    &quot;&quot;&quot;</span>
    <span class="s1">start = maybe_box_datetimelike(start)</span>
    <span class="s1">end = maybe_box_datetimelike(end)</span>
    <span class="s1">endpoint = start </span><span class="s2">if </span><span class="s1">start </span><span class="s2">is not None else </span><span class="s1">end</span>

    <span class="s2">if </span><span class="s1">freq </span><span class="s2">is None and </span><span class="s1">com.any_none(periods</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end):</span>
        <span class="s1">freq = </span><span class="s4">1 </span><span class="s2">if </span><span class="s1">is_number(endpoint) </span><span class="s2">else </span><span class="s3">&quot;D&quot;</span>

    <span class="s2">if </span><span class="s1">com.count_not_none(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">periods</span><span class="s2">, </span><span class="s1">freq) != </span><span class="s4">3</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;Of the four parameters: start, end, periods, and &quot;</span>
            <span class="s3">&quot;freq, exactly three must be specified&quot;</span>
        <span class="s1">)</span>

    <span class="s2">if not </span><span class="s1">_is_valid_endpoint(start):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;start must be numeric or datetime-like, got </span><span class="s2">{</span><span class="s1">start</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s2">elif not </span><span class="s1">_is_valid_endpoint(end):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;end must be numeric or datetime-like, got </span><span class="s2">{</span><span class="s1">end</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">is_float(periods):</span>
        <span class="s1">periods = int(periods)</span>
    <span class="s2">elif not </span><span class="s1">is_integer(periods) </span><span class="s2">and </span><span class="s1">periods </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;periods must be a number, got </span><span class="s2">{</span><span class="s1">periods</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">freq </span><span class="s2">is not None and not </span><span class="s1">is_number(freq):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">freq = to_offset(freq)</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">f&quot;freq must be numeric or convertible to DateOffset, got </span><span class="s2">{</span><span class="s1">freq</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

    <span class="s5"># verify type compatibility</span>
    <span class="s2">if not </span><span class="s1">all(</span>
        <span class="s1">[</span>
            <span class="s1">_is_type_compatible(start</span><span class="s2">, </span><span class="s1">end)</span><span class="s2">,</span>
            <span class="s1">_is_type_compatible(start</span><span class="s2">, </span><span class="s1">freq)</span><span class="s2">,</span>
            <span class="s1">_is_type_compatible(end</span><span class="s2">, </span><span class="s1">freq)</span><span class="s2">,</span>
        <span class="s1">]</span>
    <span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;start, end, freq need to be type compatible&quot;</span><span class="s1">)</span>

    <span class="s5"># +1 to convert interval count to breaks count (n breaks = n-1 intervals)</span>
    <span class="s2">if </span><span class="s1">periods </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">periods += </span><span class="s4">1</span>

    <span class="s1">breaks: np.ndarray | TimedeltaIndex | DatetimeIndex</span>

    <span class="s2">if </span><span class="s1">is_number(endpoint):</span>
        <span class="s5"># force consistency between start/end/freq (lower end if freq skips it)</span>
        <span class="s2">if </span><span class="s1">com.all_not_none(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">freq):</span>
            <span class="s1">end -= (end - start) % freq</span>

        <span class="s5"># compute the period/start/end if unspecified (at most one)</span>
        <span class="s2">if </span><span class="s1">periods </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">periods = int((end - start) // freq) + </span><span class="s4">1</span>
        <span class="s2">elif </span><span class="s1">start </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">start = end - (periods - </span><span class="s4">1</span><span class="s1">) * freq</span>
        <span class="s2">elif </span><span class="s1">end </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">end = start + (periods - </span><span class="s4">1</span><span class="s1">) * freq</span>

        <span class="s1">breaks = np.linspace(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">periods)</span>
        <span class="s2">if </span><span class="s1">all(is_integer(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">com.not_none(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">freq)):</span>
            <span class="s5"># np.linspace always produces float output</span>

            <span class="s5"># error: Incompatible types in assignment (expression has type</span>
            <span class="s5"># &quot;Union[ExtensionArray, ndarray]&quot;, variable has type &quot;ndarray&quot;)</span>
            <span class="s1">breaks = maybe_downcast_numeric(  </span><span class="s5"># type: ignore[assignment]</span>
                <span class="s1">breaks</span><span class="s2">, </span><span class="s1">np.dtype(</span><span class="s3">&quot;int64&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s5"># delegate to the appropriate range function</span>
        <span class="s2">if </span><span class="s1">isinstance(endpoint</span><span class="s2">, </span><span class="s1">Timestamp):</span>
            <span class="s1">breaks = date_range(start=start</span><span class="s2">, </span><span class="s1">end=end</span><span class="s2">, </span><span class="s1">periods=periods</span><span class="s2">, </span><span class="s1">freq=freq)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">breaks = timedelta_range(start=start</span><span class="s2">, </span><span class="s1">end=end</span><span class="s2">, </span><span class="s1">periods=periods</span><span class="s2">, </span><span class="s1">freq=freq)</span>

    <span class="s2">return </span><span class="s1">IntervalIndex.from_breaks(breaks</span><span class="s2">, </span><span class="s1">name=name</span><span class="s2">, </span><span class="s1">closed=closed)</span>
</pre>
</body>
</html>