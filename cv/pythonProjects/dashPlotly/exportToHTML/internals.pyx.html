<html>
<head>
<title>internals.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
internals.pyx</font>
</center></td></tr></table>
<pre><span class="s0">from collections import defaultdict</span>

<span class="s0">import cython</span>
<span class="s0">from cython import Py_ssize_t</span>

<span class="s0">from cpython.slice cimport PySlice_GetIndicesEx</span>


<span class="s0">cdef extern from &quot;Python.h&quot;:</span>
    <span class="s0">Py_ssize_t PY_SSIZE_T_MAX</span>

<span class="s0">import numpy as np</span>

<span class="s0">cimport numpy as cnp</span>
<span class="s0">from numpy cimport (</span>
    <span class="s0">NPY_INTP,</span>
    <span class="s0">int64_t,</span>
    <span class="s0">intp_t,</span>
    <span class="s0">ndarray,</span>
<span class="s0">)</span>

<span class="s0">cnp.import_array()</span>

<span class="s0">from pandas._libs.algos import ensure_int64</span>

<span class="s0">from pandas._libs.arrays cimport NDArrayBacked</span>
<span class="s0">from pandas._libs.util cimport (</span>
    <span class="s0">is_array,</span>
    <span class="s0">is_integer_object,</span>
<span class="s0">)</span>


<span class="s0">@cython.final</span>
<span class="s0">@cython.freelist(32)</span>
<span class="s0">cdef class BlockPlacement:</span>
    <span class="s0"># __slots__ = '_as_slice', '_as_array', '_len'</span>
    <span class="s0">cdef:</span>
        <span class="s0">slice _as_slice</span>
        <span class="s0">ndarray _as_array  # Note: this still allows `None`; will be intp_t</span>
        <span class="s0">bint _has_slice, _has_array, _is_known_slice_like</span>

    <span class="s0">def __cinit__(self, val):</span>
        <span class="s0">cdef:</span>
            <span class="s0">slice slc</span>

        <span class="s0">self._as_slice = None</span>
        <span class="s0">self._as_array = None</span>
        <span class="s0">self._has_slice = False</span>
        <span class="s0">self._has_array = False</span>

        <span class="s0">if is_integer_object(val):</span>
            <span class="s0">slc = slice(val, val + 1, 1)</span>
            <span class="s0">self._as_slice = slc</span>
            <span class="s0">self._has_slice = True</span>
        <span class="s0">elif isinstance(val, slice):</span>
            <span class="s0">slc = slice_canonize(val)</span>

            <span class="s0">if slc.start != slc.stop:</span>
                <span class="s0">self._as_slice = slc</span>
                <span class="s0">self._has_slice = True</span>
            <span class="s0">else:</span>
                <span class="s0">arr = np.empty(0, dtype=np.intp)</span>
                <span class="s0">self._as_array = arr</span>
                <span class="s0">self._has_array = True</span>
        <span class="s0">else:</span>
            <span class="s0"># Cython memoryview interface requires ndarray to be writeable.</span>
            <span class="s0">if (</span>
                <span class="s0">not is_array(val)</span>
                <span class="s0">or not cnp.PyArray_ISWRITEABLE(val)</span>
                <span class="s0">or (&lt;ndarray&gt;val).descr.type_num != cnp.NPY_INTP</span>
            <span class="s0">):</span>
                <span class="s0">arr = np.require(val, dtype=np.intp, requirements='W')</span>
            <span class="s0">else:</span>
                <span class="s0">arr = val</span>
            <span class="s0"># Caller is responsible for ensuring arr.ndim == 1</span>
            <span class="s0">self._as_array = arr</span>
            <span class="s0">self._has_array = True</span>

    <span class="s0">def __str__(self) -&gt; str:</span>
        <span class="s0">cdef:</span>
            <span class="s0">slice s = self._ensure_has_slice()</span>

        <span class="s0">if s is not None:</span>
            <span class="s0">v = self._as_slice</span>
        <span class="s0">else:</span>
            <span class="s0">v = self._as_array</span>

        <span class="s0">return f&quot;{type(self).__name__}({v})&quot;</span>

    <span class="s0">def __repr__(self) -&gt; str:</span>
        <span class="s0">return str(self)</span>

    <span class="s0">def __len__(self) -&gt; int:</span>
        <span class="s0">cdef:</span>
            <span class="s0">slice s = self._ensure_has_slice()</span>

        <span class="s0">if s is not None:</span>
            <span class="s0">return slice_len(s)</span>
        <span class="s0">else:</span>
            <span class="s0">return len(self._as_array)</span>

    <span class="s0">def __iter__(self):</span>
        <span class="s0">cdef:</span>
            <span class="s0">slice s = self._ensure_has_slice()</span>
            <span class="s0">Py_ssize_t start, stop, step, _</span>

        <span class="s0">if s is not None:</span>
            <span class="s0">start, stop, step, _ = slice_get_indices_ex(s)</span>
            <span class="s0">return iter(range(start, stop, step))</span>
        <span class="s0">else:</span>
            <span class="s0">return iter(self._as_array)</span>

    <span class="s0">@property</span>
    <span class="s0">def as_slice(self) -&gt; slice:</span>
        <span class="s0">cdef:</span>
            <span class="s0">slice s = self._ensure_has_slice()</span>

        <span class="s0">if s is not None:</span>
            <span class="s0">return s</span>
        <span class="s0">else:</span>
            <span class="s0">raise TypeError(&quot;Not slice-like&quot;)</span>

    <span class="s0">@property</span>
    <span class="s0">def indexer(self):</span>
        <span class="s0">cdef:</span>
            <span class="s0">slice s = self._ensure_has_slice()</span>

        <span class="s0">if s is not None:</span>
            <span class="s0">return s</span>
        <span class="s0">else:</span>
            <span class="s0">return self._as_array</span>

    <span class="s0">@property</span>
    <span class="s0">def as_array(self) -&gt; np.ndarray:</span>
        <span class="s0">cdef:</span>
            <span class="s0">Py_ssize_t start, stop, end, _</span>

        <span class="s0">if not self._has_array:</span>
            <span class="s0">start, stop, step, _ = slice_get_indices_ex(self._as_slice)</span>
            <span class="s0"># NOTE: this is the C-optimized equivalent of</span>
            <span class="s0">#  `np.arange(start, stop, step, dtype=np.intp)`</span>
            <span class="s0">self._as_array = cnp.PyArray_Arange(start, stop, step, NPY_INTP)</span>
            <span class="s0">self._has_array = True</span>

        <span class="s0">return self._as_array</span>

    <span class="s0">@property</span>
    <span class="s0">def is_slice_like(self) -&gt; bool:</span>
        <span class="s0">cdef:</span>
            <span class="s0">slice s = self._ensure_has_slice()</span>

        <span class="s0">return s is not None</span>

    <span class="s0">def __getitem__(self, loc):</span>
        <span class="s0">cdef:</span>
            <span class="s0">slice s = self._ensure_has_slice()</span>

        <span class="s0">if s is not None:</span>
            <span class="s0">val = slice_getitem(s, loc)</span>
        <span class="s0">else:</span>
            <span class="s0">val = self._as_array[loc]</span>

        <span class="s0">if not isinstance(val, slice) and val.ndim == 0:</span>
            <span class="s0">return val</span>

        <span class="s0">return BlockPlacement(val)</span>

    <span class="s0">def delete(self, loc) -&gt; BlockPlacement:</span>
        <span class="s0">return BlockPlacement(np.delete(self.as_array, loc, axis=0))</span>

    <span class="s0">def append(self, others) -&gt; BlockPlacement:</span>
        <span class="s0">if not len(others):</span>
            <span class="s0">return self</span>

        <span class="s0">return BlockPlacement(</span>
            <span class="s0">np.concatenate([self.as_array] + [o.as_array for o in others])</span>
        <span class="s0">)</span>

    <span class="s0">cdef BlockPlacement iadd(self, other):</span>
        <span class="s0">cdef:</span>
            <span class="s0">slice s = self._ensure_has_slice()</span>
            <span class="s0">Py_ssize_t other_int, start, stop, step</span>

        <span class="s0">if is_integer_object(other) and s is not None:</span>
            <span class="s0">other_int = &lt;Py_ssize_t&gt;other</span>

            <span class="s0">if other_int == 0:</span>
                <span class="s0"># BlockPlacement is treated as immutable</span>
                <span class="s0">return self</span>

            <span class="s0">start, stop, step, _ = slice_get_indices_ex(s)</span>
            <span class="s0">start += other_int</span>
            <span class="s0">stop += other_int</span>

            <span class="s0">if (step &gt; 0 and start &lt; 0) or (step &lt; 0 and stop &lt; step):</span>
                <span class="s0">raise ValueError(&quot;iadd causes length change&quot;)</span>

            <span class="s0">if stop &lt; 0:</span>
                <span class="s0">val = slice(start, None, step)</span>
            <span class="s0">else:</span>
                <span class="s0">val = slice(start, stop, step)</span>

            <span class="s0">return BlockPlacement(val)</span>
        <span class="s0">else:</span>
            <span class="s0">newarr = self.as_array + other</span>
            <span class="s0">if (newarr &lt; 0).any():</span>
                <span class="s0">raise ValueError(&quot;iadd causes length change&quot;)</span>

            <span class="s0">val = newarr</span>
            <span class="s0">return BlockPlacement(val)</span>

    <span class="s0">def add(self, other) -&gt; BlockPlacement:</span>
        <span class="s0"># We can get here with int or ndarray</span>
        <span class="s0">return self.iadd(other)</span>

    <span class="s0">cdef slice _ensure_has_slice(self):</span>
        <span class="s0">if not self._has_slice:</span>
            <span class="s0">self._as_slice = indexer_as_slice(self._as_array)</span>
            <span class="s0">self._has_slice = True</span>

        <span class="s0">return self._as_slice</span>

    <span class="s0">cpdef BlockPlacement increment_above(self, Py_ssize_t loc):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Increment any entries of 'loc' or above by one.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">slice nv, s = self._ensure_has_slice()</span>
            <span class="s0">Py_ssize_t other_int, start, stop, step</span>
            <span class="s0">ndarray[intp_t, ndim=1] newarr</span>

        <span class="s0">if s is not None:</span>
            <span class="s0"># see if we are either all-above or all-below, each of which</span>
            <span class="s0">#  have fastpaths available.</span>

            <span class="s0">start, stop, step, _ = slice_get_indices_ex(s)</span>

            <span class="s0">if start &lt; loc and stop &lt;= loc:</span>
                <span class="s0"># We are entirely below, nothing to increment</span>
                <span class="s0">return self</span>

            <span class="s0">if start &gt;= loc and stop &gt;= loc:</span>
                <span class="s0"># We are entirely above, we can efficiently increment out slice</span>
                <span class="s0">nv = slice(start + 1, stop + 1, step)</span>
                <span class="s0">return BlockPlacement(nv)</span>

        <span class="s0">if loc == 0:</span>
            <span class="s0"># fastpath where we know everything is &gt;= 0</span>
            <span class="s0">newarr = self.as_array + 1</span>
            <span class="s0">return BlockPlacement(newarr)</span>

        <span class="s0">newarr = self.as_array.copy()</span>
        <span class="s0">newarr[newarr &gt;= loc] += 1</span>
        <span class="s0">return BlockPlacement(newarr)</span>

    <span class="s0">def tile_for_unstack(self, factor: int) -&gt; np.ndarray:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Find the new mgr_locs for the un-stacked version of a Block.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">slice slc = self._ensure_has_slice()</span>
            <span class="s0">slice new_slice</span>
            <span class="s0">ndarray[intp_t, ndim=1] new_placement</span>

        <span class="s0">if slc is not None and slc.step == 1:</span>
            <span class="s0">new_slc = slice(slc.start * factor, slc.stop * factor, 1)</span>
            <span class="s0"># equiv: np.arange(new_slc.start, new_slc.stop, dtype=np.intp)</span>
            <span class="s0">new_placement = cnp.PyArray_Arange(new_slc.start, new_slc.stop, 1, NPY_INTP)</span>
        <span class="s0">else:</span>
            <span class="s0"># Note: test_pivot_table_empty_aggfunc gets here with `slc is not None`</span>
            <span class="s0">mapped = [</span>
                <span class="s0"># equiv: np.arange(x * factor, (x + 1) * factor, dtype=np.intp)</span>
                <span class="s0">cnp.PyArray_Arange(x * factor, (x + 1) * factor, 1, NPY_INTP)</span>
                <span class="s0">for x in self</span>
            <span class="s0">]</span>
            <span class="s0">new_placement = np.concatenate(mapped)</span>
        <span class="s0">return new_placement</span>


<span class="s0">cdef slice slice_canonize(slice s):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Convert slice to canonical bounded form.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t start = 0, stop = 0, step = 1</span>

    <span class="s0">if s.step is None:</span>
        <span class="s0">step = 1</span>
    <span class="s0">else:</span>
        <span class="s0">step = &lt;Py_ssize_t&gt;s.step</span>
        <span class="s0">if step == 0:</span>
            <span class="s0">raise ValueError(&quot;slice step cannot be zero&quot;)</span>

    <span class="s0">if step &gt; 0:</span>
        <span class="s0">if s.stop is None:</span>
            <span class="s0">raise ValueError(&quot;unbounded slice&quot;)</span>

        <span class="s0">stop = &lt;Py_ssize_t&gt;s.stop</span>
        <span class="s0">if s.start is None:</span>
            <span class="s0">start = 0</span>
        <span class="s0">else:</span>
            <span class="s0">start = &lt;Py_ssize_t&gt;s.start</span>
            <span class="s0">if start &gt; stop:</span>
                <span class="s0">start = stop</span>
    <span class="s0">elif step &lt; 0:</span>
        <span class="s0">if s.start is None:</span>
            <span class="s0">raise ValueError(&quot;unbounded slice&quot;)</span>

        <span class="s0">start = &lt;Py_ssize_t&gt;s.start</span>
        <span class="s0">if s.stop is None:</span>
            <span class="s0">stop = -1</span>
        <span class="s0">else:</span>
            <span class="s0">stop = &lt;Py_ssize_t&gt;s.stop</span>
            <span class="s0">if stop &gt; start:</span>
                <span class="s0">stop = start</span>

    <span class="s0">if start &lt; 0 or (stop &lt; 0 and s.stop is not None and step &gt; 0):</span>
        <span class="s0">raise ValueError(&quot;unbounded slice&quot;)</span>

    <span class="s0">if stop &lt; 0:</span>
        <span class="s0">return slice(start, None, step)</span>
    <span class="s0">else:</span>
        <span class="s0">return slice(start, stop, step)</span>


<span class="s0">cpdef Py_ssize_t slice_len(slice slc, Py_ssize_t objlen=PY_SSIZE_T_MAX) except -1:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Get length of a bounded slice.</span>

    <span class="s0">The slice must not have any &quot;open&quot; bounds that would create dependency on</span>
    <span class="s0">container size, i.e.:</span>
    <span class="s0">- if ``s.step is None or s.step &gt; 0``, ``s.stop`` is not ``None``</span>
    <span class="s0">- if ``s.step &lt; 0``, ``s.start`` is not ``None``</span>

    <span class="s0">Otherwise, the result is unreliable.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t start, stop, step, length</span>

    <span class="s0">if slc is None:</span>
        <span class="s0">raise TypeError(&quot;slc must be slice&quot;)  # pragma: no cover</span>

    <span class="s0">PySlice_GetIndicesEx(slc, objlen, &amp;start, &amp;stop, &amp;step, &amp;length)</span>

    <span class="s0">return length</span>


<span class="s0">cdef (Py_ssize_t, Py_ssize_t, Py_ssize_t, Py_ssize_t) slice_get_indices_ex(</span>
    <span class="s0">slice slc, Py_ssize_t objlen=PY_SSIZE_T_MAX</span>
<span class="s0">):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Get (start, stop, step, length) tuple for a slice.</span>

    <span class="s0">If `objlen` is not specified, slice must be bounded, otherwise the result</span>
    <span class="s0">will be wrong.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t start, stop, step, length</span>

    <span class="s0">if slc is None:</span>
        <span class="s0">raise TypeError(&quot;slc should be a slice&quot;)  # pragma: no cover</span>

    <span class="s0">PySlice_GetIndicesEx(slc, objlen, &amp;start, &amp;stop, &amp;step, &amp;length)</span>

    <span class="s0">return start, stop, step, length</span>


<span class="s0">cdef slice_getitem(slice slc, ind):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t s_start, s_stop, s_step, s_len</span>
        <span class="s0">Py_ssize_t ind_start, ind_stop, ind_step, ind_len</span>

    <span class="s0">s_start, s_stop, s_step, s_len = slice_get_indices_ex(slc)</span>

    <span class="s0">if isinstance(ind, slice):</span>
        <span class="s0">ind_start, ind_stop, ind_step, ind_len = slice_get_indices_ex(ind, s_len)</span>

        <span class="s0">if ind_step &gt; 0 and ind_len == s_len:</span>
            <span class="s0"># short-cut for no-op slice</span>
            <span class="s0">if ind_len == s_len:</span>
                <span class="s0">return slc</span>

        <span class="s0">if ind_step &lt; 0:</span>
            <span class="s0">s_start = s_stop - s_step</span>
            <span class="s0">ind_step = -ind_step</span>

        <span class="s0">s_step *= ind_step</span>
        <span class="s0">s_stop = s_start + ind_stop * s_step</span>
        <span class="s0">s_start = s_start + ind_start * s_step</span>

        <span class="s0">if s_step &lt; 0 and s_stop &lt; 0:</span>
            <span class="s0">return slice(s_start, None, s_step)</span>
        <span class="s0">else:</span>
            <span class="s0">return slice(s_start, s_stop, s_step)</span>

    <span class="s0">else:</span>
        <span class="s0"># NOTE:</span>
        <span class="s0"># this is the C-optimized equivalent of</span>
        <span class="s0"># `np.arange(s_start, s_stop, s_step, dtype=np.intp)[ind]`</span>
        <span class="s0">return cnp.PyArray_Arange(s_start, s_stop, s_step, NPY_INTP)[ind]</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">cdef slice indexer_as_slice(intp_t[:] vals):</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i, n, start, stop</span>
        <span class="s0">int64_t d</span>

    <span class="s0">if vals is None:</span>
        <span class="s0">raise TypeError(&quot;vals must be ndarray&quot;)  # pragma: no cover</span>

    <span class="s0">n = vals.shape[0]</span>

    <span class="s0">if n == 0 or vals[0] &lt; 0:</span>
        <span class="s0">return None</span>

    <span class="s0">if n == 1:</span>
        <span class="s0">return slice(vals[0], vals[0] + 1, 1)</span>

    <span class="s0">if vals[1] &lt; 0:</span>
        <span class="s0">return None</span>

    <span class="s0"># n &gt; 2</span>
    <span class="s0">d = vals[1] - vals[0]</span>

    <span class="s0">if d == 0:</span>
        <span class="s0">return None</span>

    <span class="s0">for i in range(2, n):</span>
        <span class="s0">if vals[i] &lt; 0 or vals[i] - vals[i - 1] != d:</span>
            <span class="s0">return None</span>

    <span class="s0">start = vals[0]</span>
    <span class="s0">stop = start + n * d</span>
    <span class="s0">if stop &lt; 0 and d &lt; 0:</span>
        <span class="s0">return slice(start, None, d)</span>
    <span class="s0">else:</span>
        <span class="s0">return slice(start, stop, d)</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">def get_blkno_indexers(</span>
    <span class="s0">int64_t[:] blknos, bint group=True</span>
<span class="s0">) -&gt; list[tuple[int, slice | np.ndarray]]:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Enumerate contiguous runs of integers in ndarray.</span>

    <span class="s0">Iterate over elements of `blknos` yielding ``(blkno, slice(start, stop))``</span>
    <span class="s0">pairs for each contiguous run found.</span>

    <span class="s0">If `group` is True and there is more than one run for a certain blkno,</span>
    <span class="s0">``(blkno, array)`` with an array containing positions of all elements equal</span>
    <span class="s0">to blkno.</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">list[tuple[int, slice | np.ndarray]]</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0"># There's blkno in this function's name because it's used in block &amp;</span>
    <span class="s0"># blockno handling.</span>
    <span class="s0">cdef:</span>
        <span class="s0">int64_t cur_blkno</span>
        <span class="s0">Py_ssize_t i, start, stop, n, diff</span>
        <span class="s0">cnp.npy_intp tot_len</span>
        <span class="s0">int64_t blkno</span>
        <span class="s0">object group_dict = defaultdict(list)</span>
        <span class="s0">ndarray[int64_t, ndim=1] arr</span>

    <span class="s0">n = blknos.shape[0]</span>
    <span class="s0">result = list()</span>
    <span class="s0">start = 0</span>
    <span class="s0">cur_blkno = blknos[start]</span>

    <span class="s0">if n == 0:</span>
        <span class="s0">pass</span>
    <span class="s0">elif group is False:</span>
        <span class="s0">for i in range(1, n):</span>
            <span class="s0">if blknos[i] != cur_blkno:</span>
                <span class="s0">result.append((cur_blkno, slice(start, i)))</span>

                <span class="s0">start = i</span>
                <span class="s0">cur_blkno = blknos[i]</span>

        <span class="s0">result.append((cur_blkno, slice(start, n)))</span>
    <span class="s0">else:</span>
        <span class="s0">for i in range(1, n):</span>
            <span class="s0">if blknos[i] != cur_blkno:</span>
                <span class="s0">group_dict[cur_blkno].append((start, i))</span>

                <span class="s0">start = i</span>
                <span class="s0">cur_blkno = blknos[i]</span>

        <span class="s0">group_dict[cur_blkno].append((start, n))</span>

        <span class="s0">for blkno, slices in group_dict.items():</span>
            <span class="s0">if len(slices) == 1:</span>
                <span class="s0">result.append((blkno, slice(slices[0][0], slices[0][1])))</span>
            <span class="s0">else:</span>
                <span class="s0">tot_len = sum(stop - start for start, stop in slices)</span>
                <span class="s0"># equiv np.empty(tot_len, dtype=np.int64)</span>
                <span class="s0">arr = cnp.PyArray_EMPTY(1, &amp;tot_len, cnp.NPY_INT64, 0)</span>

                <span class="s0">i = 0</span>
                <span class="s0">for start, stop in slices:</span>
                    <span class="s0">for diff in range(start, stop):</span>
                        <span class="s0">arr[i] = diff</span>
                        <span class="s0">i += 1</span>

                <span class="s0">result.append((blkno, arr))</span>

    <span class="s0">return result</span>


<span class="s0">def get_blkno_placements(blknos, group: bool = True):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">blknos : np.ndarray[int64]</span>
    <span class="s0">group : bool, default True</span>

    <span class="s0">Returns</span>
    <span class="s0">-------</span>
    <span class="s0">iterator</span>
        <span class="s0">yield (blkno, BlockPlacement)</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">blknos = ensure_int64(blknos)</span>

    <span class="s0">for blkno, indexer in get_blkno_indexers(blknos, group):</span>
        <span class="s0">yield blkno, BlockPlacement(indexer)</span>


<span class="s0">@cython.boundscheck(False)</span>
<span class="s0">@cython.wraparound(False)</span>
<span class="s0">cpdef update_blklocs_and_blknos(</span>
    <span class="s0">ndarray[intp_t, ndim=1] blklocs,</span>
    <span class="s0">ndarray[intp_t, ndim=1] blknos,</span>
    <span class="s0">Py_ssize_t loc,</span>
    <span class="s0">intp_t nblocks,</span>
<span class="s0">):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Update blklocs and blknos when a new column is inserted at 'loc'.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">Py_ssize_t i</span>
        <span class="s0">cnp.npy_intp length = len(blklocs) + 1</span>
        <span class="s0">ndarray[intp_t, ndim=1] new_blklocs, new_blknos</span>

    <span class="s0"># equiv: new_blklocs = np.empty(length, dtype=np.intp)</span>
    <span class="s0">new_blklocs = cnp.PyArray_EMPTY(1, &amp;length, cnp.NPY_INTP, 0)</span>
    <span class="s0">new_blknos = cnp.PyArray_EMPTY(1, &amp;length, cnp.NPY_INTP, 0)</span>

    <span class="s0">for i in range(loc):</span>
        <span class="s0">new_blklocs[i] = blklocs[i]</span>
        <span class="s0">new_blknos[i] = blknos[i]</span>

    <span class="s0">new_blklocs[loc] = 0</span>
    <span class="s0">new_blknos[loc] = nblocks</span>

    <span class="s0">for i in range(loc, length - 1):</span>
        <span class="s0">new_blklocs[i + 1] = blklocs[i]</span>
        <span class="s0">new_blknos[i + 1] = blknos[i]</span>

    <span class="s0">return new_blklocs, new_blknos</span>


<span class="s0">def _unpickle_block(values, placement, ndim):</span>
    <span class="s0"># We have to do some gymnastics b/c &quot;ndim&quot; is keyword-only</span>

    <span class="s0">from pandas.core.internals.blocks import new_block</span>

    <span class="s0">return new_block(values, placement, ndim=ndim)</span>


<span class="s0">@cython.freelist(64)</span>
<span class="s0">cdef class SharedBlock:</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Defining __init__ in a cython class significantly improves performance.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef:</span>
        <span class="s0">public BlockPlacement _mgr_locs</span>
        <span class="s0">readonly int ndim</span>

    <span class="s0">def __cinit__(self, values, placement: BlockPlacement, ndim: int):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">values : np.ndarray or ExtensionArray</span>
            <span class="s0">We assume maybe_coerce_values has already been called.</span>
        <span class="s0">placement : BlockPlacement</span>
        <span class="s0">ndim : int</span>
            <span class="s0">1 for SingleBlockManager/Series, 2 for BlockManager/DataFrame</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self._mgr_locs = placement</span>
        <span class="s0">self.ndim = ndim</span>

    <span class="s0">cpdef __reduce__(self):</span>
        <span class="s0">args = (self.values, self.mgr_locs.indexer, self.ndim)</span>
        <span class="s0">return _unpickle_block, args</span>

    <span class="s0">cpdef __setstate__(self, state):</span>
        <span class="s0">from pandas.core.construction import extract_array</span>

        <span class="s0">self.mgr_locs = BlockPlacement(state[0])</span>
        <span class="s0">self.values = extract_array(state[1], extract_numpy=True)</span>
        <span class="s0">if len(state) &gt; 2:</span>
            <span class="s0"># we stored ndim</span>
            <span class="s0">self.ndim = state[2]</span>
        <span class="s0">else:</span>
            <span class="s0"># older pickle</span>
            <span class="s0">from pandas.core.internals.api import maybe_infer_ndim</span>

            <span class="s0">ndim = maybe_infer_ndim(self.values, self.mgr_locs)</span>
            <span class="s0">self.ndim = ndim</span>


<span class="s0">cdef class NumpyBlock(SharedBlock):</span>
    <span class="s0">cdef:</span>
        <span class="s0">public ndarray values</span>

    <span class="s0">def __cinit__(self, ndarray values, BlockPlacement placement, int ndim):</span>
        <span class="s0"># set values here the (implicit) call to SharedBlock.__cinit__ will</span>
        <span class="s0">#  set placement and ndim</span>
        <span class="s0">self.values = values</span>

    <span class="s0">cpdef NumpyBlock getitem_block_index(self, slice slicer):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Perform __getitem__-like specialized to slicing along index.</span>

        <span class="s0">Assumes self.ndim == 2</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">new_values = self.values[..., slicer]</span>
        <span class="s0">return type(self)(new_values, self._mgr_locs, ndim=self.ndim)</span>


<span class="s0">cdef class NDArrayBackedBlock(SharedBlock):</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">Block backed by NDArrayBackedExtensionArray</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef public:</span>
        <span class="s0">NDArrayBacked values</span>

    <span class="s0">def __cinit__(self, NDArrayBacked values, BlockPlacement placement, int ndim):</span>
        <span class="s0"># set values here the (implicit) call to SharedBlock.__cinit__ will</span>
        <span class="s0">#  set placement and ndim</span>
        <span class="s0">self.values = values</span>

    <span class="s0">cpdef NDArrayBackedBlock getitem_block_index(self, slice slicer):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Perform __getitem__-like specialized to slicing along index.</span>

        <span class="s0">Assumes self.ndim == 2</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">new_values = self.values[..., slicer]</span>
        <span class="s0">return type(self)(new_values, self._mgr_locs, ndim=self.ndim)</span>


<span class="s0">cdef class Block(SharedBlock):</span>
    <span class="s0">cdef:</span>
        <span class="s0">public object values</span>

    <span class="s0">def __cinit__(self, object values, BlockPlacement placement, int ndim):</span>
        <span class="s0"># set values here the (implicit) call to SharedBlock.__cinit__ will</span>
        <span class="s0">#  set placement and ndim</span>
        <span class="s0">self.values = values</span>


<span class="s0">@cython.freelist(64)</span>
<span class="s0">cdef class BlockManager:</span>
    <span class="s0">cdef:</span>
        <span class="s0">public tuple blocks</span>
        <span class="s0">public list axes</span>
        <span class="s0">public bint _known_consolidated, _is_consolidated</span>
        <span class="s0">public ndarray _blknos, _blklocs</span>

    <span class="s0">def __cinit__(self, blocks=None, axes=None, verify_integrity=True):</span>
        <span class="s0"># None as defaults for unpickling GH#42345</span>
        <span class="s0">if blocks is None:</span>
            <span class="s0"># This adds 1-2 microseconds to DataFrame(np.array([]))</span>
            <span class="s0">return</span>

        <span class="s0">if isinstance(blocks, list):</span>
            <span class="s0"># Backward compat for e.g. pyarrow</span>
            <span class="s0">blocks = tuple(blocks)</span>

        <span class="s0">self.blocks = blocks</span>
        <span class="s0">self.axes = axes.copy()  # copy to make sure we are not remotely-mutable</span>

        <span class="s0"># Populate known_consolidate, blknos, and blklocs lazily</span>
        <span class="s0">self._known_consolidated = False</span>
        <span class="s0">self._is_consolidated = False</span>
        <span class="s0">self._blknos = None</span>
        <span class="s0">self._blklocs = None</span>

    <span class="s0"># -------------------------------------------------------------------</span>
    <span class="s0"># Block Placement</span>

    <span class="s0">def _rebuild_blknos_and_blklocs(self) -&gt; None:</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">Update mgr._blknos / mgr._blklocs.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">intp_t blkno, i, j</span>
            <span class="s0">cnp.npy_intp length = self.shape[0]</span>
            <span class="s0">SharedBlock blk</span>
            <span class="s0">BlockPlacement bp</span>
            <span class="s0">ndarray[intp_t, ndim=1] new_blknos, new_blklocs</span>

        <span class="s0"># equiv: np.empty(length, dtype=np.intp)</span>
        <span class="s0">new_blknos = cnp.PyArray_EMPTY(1, &amp;length, cnp.NPY_INTP, 0)</span>
        <span class="s0">new_blklocs = cnp.PyArray_EMPTY(1, &amp;length, cnp.NPY_INTP, 0)</span>
        <span class="s0"># equiv: new_blknos.fill(-1)</span>
        <span class="s0">cnp.PyArray_FILLWBYTE(new_blknos, -1)</span>
        <span class="s0">cnp.PyArray_FILLWBYTE(new_blklocs, -1)</span>

        <span class="s0">for blkno, blk in enumerate(self.blocks):</span>
            <span class="s0">bp = blk._mgr_locs</span>
            <span class="s0"># Iterating over `bp` is a faster equivalent to</span>
            <span class="s0">#  new_blknos[bp.indexer] = blkno</span>
            <span class="s0">#  new_blklocs[bp.indexer] = np.arange(len(bp))</span>
            <span class="s0">for i, j in enumerate(bp):</span>
                <span class="s0">new_blknos[j] = blkno</span>
                <span class="s0">new_blklocs[j] = i</span>

        <span class="s0">for i in range(length):</span>
            <span class="s0"># faster than `for blkno in new_blknos`</span>
            <span class="s0">#  https://github.com/cython/cython/issues/4393</span>
            <span class="s0">blkno = new_blknos[i]</span>

            <span class="s0"># If there are any -1s remaining, this indicates that our mgr_locs</span>
            <span class="s0">#  are invalid.</span>
            <span class="s0">if blkno == -1:</span>
                <span class="s0">raise AssertionError(&quot;Gaps in blk ref_locs&quot;)</span>

        <span class="s0">self._blknos = new_blknos</span>
        <span class="s0">self._blklocs = new_blklocs</span>

    <span class="s0"># -------------------------------------------------------------------</span>
    <span class="s0"># Pickle</span>

    <span class="s0">cpdef __reduce__(self):</span>
        <span class="s0">if len(self.axes) == 1:</span>
            <span class="s0"># SingleBlockManager, __init__ expects Block, axis</span>
            <span class="s0">args = (self.blocks[0], self.axes[0])</span>
        <span class="s0">else:</span>
            <span class="s0">args = (self.blocks, self.axes)</span>
        <span class="s0">return type(self), args</span>

    <span class="s0">cpdef __setstate__(self, state):</span>
        <span class="s0">from pandas.core.construction import extract_array</span>
        <span class="s0">from pandas.core.internals.blocks import (</span>
            <span class="s0">ensure_block_shape,</span>
            <span class="s0">new_block,</span>
        <span class="s0">)</span>
        <span class="s0">from pandas.core.internals.managers import ensure_index</span>

        <span class="s0">if isinstance(state, tuple) and len(state) &gt;= 4 and &quot;0.14.1&quot; in state[3]:</span>
            <span class="s0">state = state[3][&quot;0.14.1&quot;]</span>
            <span class="s0">axes = [ensure_index(ax) for ax in state[&quot;axes&quot;]]</span>
            <span class="s0">ndim = len(axes)</span>

            <span class="s0">for blk in state[&quot;blocks&quot;]:</span>
                <span class="s0">vals = blk[&quot;values&quot;]</span>
                <span class="s0"># older versions may hold e.g. DatetimeIndex instead of DTA</span>
                <span class="s0">vals = extract_array(vals, extract_numpy=True)</span>
                <span class="s0">blk[&quot;values&quot;] = ensure_block_shape(vals, ndim=ndim)</span>

            <span class="s0">nbs = [</span>
                <span class="s0">new_block(blk[&quot;values&quot;], blk[&quot;mgr_locs&quot;], ndim=ndim)</span>
                <span class="s0">for blk in state[&quot;blocks&quot;]</span>
            <span class="s0">]</span>
            <span class="s0">blocks = tuple(nbs)</span>
            <span class="s0">self.blocks = blocks</span>
            <span class="s0">self.axes = axes</span>

        <span class="s0">else:  # pragma: no cover</span>
            <span class="s0">raise NotImplementedError(&quot;pre-0.14.1 pickles are no longer supported&quot;)</span>

        <span class="s0">self._post_setstate()</span>

    <span class="s0">def _post_setstate(self) -&gt; None:</span>
        <span class="s0">self._is_consolidated = False</span>
        <span class="s0">self._known_consolidated = False</span>
        <span class="s0">self._rebuild_blknos_and_blklocs()</span>

    <span class="s0"># -------------------------------------------------------------------</span>
    <span class="s0"># Indexing</span>

    <span class="s0">cdef BlockManager _get_index_slice(self, slobj):</span>
        <span class="s0">cdef:</span>
            <span class="s0">SharedBlock blk, nb</span>
            <span class="s0">BlockManager mgr</span>
            <span class="s0">ndarray blknos, blklocs</span>

        <span class="s0">nbs = []</span>
        <span class="s0">for blk in self.blocks:</span>
            <span class="s0">nb = blk.getitem_block_index(slobj)</span>
            <span class="s0">nbs.append(nb)</span>

        <span class="s0">new_axes = [self.axes[0], self.axes[1]._getitem_slice(slobj)]</span>
        <span class="s0">mgr = type(self)(tuple(nbs), new_axes, verify_integrity=False)</span>

        <span class="s0"># We can avoid having to rebuild blklocs/blknos</span>
        <span class="s0">blklocs = self._blklocs</span>
        <span class="s0">blknos = self._blknos</span>
        <span class="s0">if blknos is not None:</span>
            <span class="s0">mgr._blknos = blknos.copy()</span>
            <span class="s0">mgr._blklocs = blklocs.copy()</span>
        <span class="s0">return mgr</span>

    <span class="s0">def get_slice(self, slobj: slice, axis: int = 0) -&gt; BlockManager:</span>

        <span class="s0">if axis == 0:</span>
            <span class="s0">new_blocks = self._slice_take_blocks_ax0(slobj)</span>
        <span class="s0">elif axis == 1:</span>
            <span class="s0">return self._get_index_slice(slobj)</span>
        <span class="s0">else:</span>
            <span class="s0">raise IndexError(&quot;Requested axis not found in manager&quot;)</span>

        <span class="s0">new_axes = list(self.axes)</span>
        <span class="s0">new_axes[axis] = new_axes[axis]._getitem_slice(slobj)</span>

        <span class="s0">return type(self)(tuple(new_blocks), new_axes, verify_integrity=False)</span>
</pre>
</body>
</html>