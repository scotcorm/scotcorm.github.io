<html>
<head>
<title>mrecords.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
mrecords.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;:mod:`numpy.ma..mrecords` 
 
Defines the equivalent of :class:`numpy.recarrays` for masked arrays, 
where fields can be accessed as attributes. 
Note that :class:`numpy.ma.MaskedArray` already supports structured datatypes 
and the masking of individual fields. 
 
.. moduleauthor:: Pierre Gerard-Marchant 
 
&quot;&quot;&quot;</span>
<span class="s2">#  We should make sure that no field is called '_mask','mask','_fieldmask',</span>
<span class="s2">#  or whatever restricted keywords.  An idea would be to no bother in the</span>
<span class="s2">#  first place, and then rename the invalid fields with a trailing</span>
<span class="s2">#  underscore. Maybe we could just overload the parser function ?</span>

<span class="s3">from </span><span class="s1">numpy.ma </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">MAError</span><span class="s3">, </span><span class="s1">MaskedArray</span><span class="s3">, </span><span class="s1">masked</span><span class="s3">, </span><span class="s1">nomask</span><span class="s3">, </span><span class="s1">masked_array</span><span class="s3">, </span><span class="s1">getdata</span><span class="s3">,</span>
    <span class="s1">getmaskarray</span><span class="s3">, </span><span class="s1">filled</span>
<span class="s1">)</span>
<span class="s3">import </span><span class="s1">numpy.ma </span><span class="s3">as </span><span class="s1">ma</span>
<span class="s3">import </span><span class="s1">warnings</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">numpy </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">bool_</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">ndarray</span><span class="s3">, </span><span class="s1">recarray</span><span class="s3">, </span><span class="s1">array </span><span class="s3">as </span><span class="s1">narray</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">numpy.core.records </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">fromarrays </span><span class="s3">as </span><span class="s1">recfromarrays</span><span class="s3">, </span><span class="s1">fromrecords </span><span class="s3">as </span><span class="s1">recfromrecords</span>
<span class="s1">)</span>

<span class="s1">_byteorderconv = np.core.records._byteorderconv</span>


<span class="s1">_check_fill_value = ma.core._check_fill_value</span>


<span class="s1">__all__ = [</span>
    <span class="s4">'MaskedRecords'</span><span class="s3">, </span><span class="s4">'mrecarray'</span><span class="s3">, </span><span class="s4">'fromarrays'</span><span class="s3">, </span><span class="s4">'fromrecords'</span><span class="s3">,</span>
    <span class="s4">'fromtextfile'</span><span class="s3">, </span><span class="s4">'addfield'</span><span class="s3">,</span>
<span class="s1">]</span>

<span class="s1">reserved_fields = [</span><span class="s4">'_data'</span><span class="s3">, </span><span class="s4">'_mask'</span><span class="s3">, </span><span class="s4">'_fieldmask'</span><span class="s3">, </span><span class="s4">'dtype'</span><span class="s1">]</span>


<span class="s3">def </span><span class="s1">_checknames(descr</span><span class="s3">, </span><span class="s1">names=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Checks that field names ``descr`` are not reserved keywords. 
 
    If this is the case, a default 'f%i' is substituted.  If the argument 
    `names` is not None, updates the field names to valid names. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">ndescr = len(descr)</span>
    <span class="s1">default_names = [</span><span class="s4">'f%i' </span><span class="s1">% i </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(ndescr)]</span>
    <span class="s3">if </span><span class="s1">names </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">new_names = default_names</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">isinstance(names</span><span class="s3">, </span><span class="s1">(tuple</span><span class="s3">, </span><span class="s1">list)):</span>
            <span class="s1">new_names = names</span>
        <span class="s3">elif </span><span class="s1">isinstance(names</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s1">new_names = names.split(</span><span class="s4">','</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">NameError(</span><span class="s4">f'illegal input names </span><span class="s3">{</span><span class="s1">names</span><span class="s3">!r}</span><span class="s4">'</span><span class="s1">)</span>
        <span class="s1">nnames = len(new_names)</span>
        <span class="s3">if </span><span class="s1">nnames &lt; ndescr:</span>
            <span class="s1">new_names += default_names[nnames:]</span>
    <span class="s1">ndescr = []</span>
    <span class="s3">for </span><span class="s1">(n</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">t) </span><span class="s3">in </span><span class="s1">zip(new_names</span><span class="s3">, </span><span class="s1">default_names</span><span class="s3">, </span><span class="s1">descr.descr):</span>
        <span class="s3">if </span><span class="s1">n </span><span class="s3">in </span><span class="s1">reserved_fields:</span>
            <span class="s3">if </span><span class="s1">t[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">in </span><span class="s1">reserved_fields:</span>
                <span class="s1">ndescr.append((d</span><span class="s3">, </span><span class="s1">t[</span><span class="s5">1</span><span class="s1">]))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">ndescr.append(t)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">ndescr.append((n</span><span class="s3">, </span><span class="s1">t[</span><span class="s5">1</span><span class="s1">]))</span>
    <span class="s3">return </span><span class="s1">np.dtype(ndescr)</span>


<span class="s3">def </span><span class="s1">_get_fieldmask(self):</span>
    <span class="s1">mdescr = [(n</span><span class="s3">, </span><span class="s4">'|b1'</span><span class="s1">) </span><span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">self.dtype.names]</span>
    <span class="s1">fdmask = np.empty(self.shape</span><span class="s3">, </span><span class="s1">dtype=mdescr)</span>
    <span class="s1">fdmask.flat = tuple([</span><span class="s3">False</span><span class="s1">] * len(mdescr))</span>
    <span class="s3">return </span><span class="s1">fdmask</span>


<span class="s3">class </span><span class="s1">MaskedRecords(MaskedArray):</span>
    <span class="s0">&quot;&quot;&quot; 
 
    Attributes 
    ---------- 
    _data : recarray 
        Underlying data, as a record array. 
    _mask : boolean array 
        Mask of the records. A record is masked when all its fields are 
        masked. 
    _fieldmask : boolean recarray 
        Record array of booleans, setting the mask of each individual field 
        of each record. 
    _fill_value : record 
        Filling values for each field. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__new__(cls</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s3">None, </span><span class="s1">buf=</span><span class="s3">None, </span><span class="s1">offset=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">strides=</span><span class="s3">None,</span>
                <span class="s1">formats=</span><span class="s3">None, </span><span class="s1">names=</span><span class="s3">None, </span><span class="s1">titles=</span><span class="s3">None,</span>
                <span class="s1">byteorder=</span><span class="s3">None, </span><span class="s1">aligned=</span><span class="s3">False,</span>
                <span class="s1">mask=nomask</span><span class="s3">, </span><span class="s1">hard_mask=</span><span class="s3">False, </span><span class="s1">fill_value=</span><span class="s3">None, </span><span class="s1">keep_mask=</span><span class="s3">True,</span>
                <span class="s1">copy=</span><span class="s3">False,</span>
                <span class="s1">**options):</span>

        <span class="s1">self = recarray.__new__(cls</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">buf=buf</span><span class="s3">, </span><span class="s1">offset=offset</span><span class="s3">,</span>
                                <span class="s1">strides=strides</span><span class="s3">, </span><span class="s1">formats=formats</span><span class="s3">, </span><span class="s1">names=names</span><span class="s3">,</span>
                                <span class="s1">titles=titles</span><span class="s3">, </span><span class="s1">byteorder=byteorder</span><span class="s3">,</span>
                                <span class="s1">aligned=aligned</span><span class="s3">,</span><span class="s1">)</span>

        <span class="s1">mdtype = ma.make_mask_descr(self.dtype)</span>
        <span class="s3">if </span><span class="s1">mask </span><span class="s3">is </span><span class="s1">nomask </span><span class="s3">or not </span><span class="s1">np.size(mask):</span>
            <span class="s3">if not </span><span class="s1">keep_mask:</span>
                <span class="s1">self._mask = tuple([</span><span class="s3">False</span><span class="s1">] * len(mdtype))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">mask = np.array(mask</span><span class="s3">, </span><span class="s1">copy=copy)</span>
            <span class="s3">if </span><span class="s1">mask.shape != self.shape:</span>
                <span class="s1">(nd</span><span class="s3">, </span><span class="s1">nm) = (self.size</span><span class="s3">, </span><span class="s1">mask.size)</span>
                <span class="s3">if </span><span class="s1">nm == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">mask = np.resize(mask</span><span class="s3">, </span><span class="s1">self.shape)</span>
                <span class="s3">elif </span><span class="s1">nm == nd:</span>
                    <span class="s1">mask = np.reshape(mask</span><span class="s3">, </span><span class="s1">self.shape)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">msg = </span><span class="s4">&quot;Mask and data not compatible: data size is %i, &quot; </span><span class="s1">+ \</span>
                          <span class="s4">&quot;mask size is %i.&quot;</span>
                    <span class="s3">raise </span><span class="s1">MAError(msg % (nd</span><span class="s3">, </span><span class="s1">nm))</span>
            <span class="s3">if not </span><span class="s1">keep_mask:</span>
                <span class="s1">self.__setmask__(mask)</span>
                <span class="s1">self._sharedmask = </span><span class="s3">True</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">mask.dtype == mdtype:</span>
                    <span class="s1">_mask = mask</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">_mask = np.array([tuple([m] * len(mdtype)) </span><span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">mask]</span><span class="s3">,</span>
                                     <span class="s1">dtype=mdtype)</span>
                <span class="s1">self._mask = _mask</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__array_finalize__(self</span><span class="s3">, </span><span class="s1">obj):</span>
        <span class="s2"># Make sure we have a _fieldmask by default</span>
        <span class="s1">_mask = getattr(obj</span><span class="s3">, </span><span class="s4">'_mask'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">_mask </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">objmask = getattr(obj</span><span class="s3">, </span><span class="s4">'_mask'</span><span class="s3">, </span><span class="s1">nomask)</span>
            <span class="s1">_dtype = ndarray.__getattribute__(self</span><span class="s3">, </span><span class="s4">'dtype'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">objmask </span><span class="s3">is </span><span class="s1">nomask:</span>
                <span class="s1">_mask = ma.make_mask_none(self.shape</span><span class="s3">, </span><span class="s1">dtype=_dtype)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">mdescr = ma.make_mask_descr(_dtype)</span>
                <span class="s1">_mask = narray([tuple([m] * len(mdescr)) </span><span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">objmask]</span><span class="s3">,</span>
                               <span class="s1">dtype=mdescr).view(recarray)</span>
        <span class="s2"># Update some of the attributes</span>
        <span class="s1">_dict = self.__dict__</span>
        <span class="s1">_dict.update(_mask=_mask)</span>
        <span class="s1">self._update_from(obj)</span>
        <span class="s3">if </span><span class="s1">_dict[</span><span class="s4">'_baseclass'</span><span class="s1">] == ndarray:</span>
            <span class="s1">_dict[</span><span class="s4">'_baseclass'</span><span class="s1">] = recarray</span>
        <span class="s3">return</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_data(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the data as a recarray. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">ndarray.view(self</span><span class="s3">, </span><span class="s1">recarray)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_fieldmask(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Alias to mask. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._mask</span>

    <span class="s3">def </span><span class="s1">__len__(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the length 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># We have more than one record</span>
        <span class="s3">if </span><span class="s1">self.ndim:</span>
            <span class="s3">return </span><span class="s1">len(self._data)</span>
        <span class="s2"># We have only one record: return the nb of fields</span>
        <span class="s3">return </span><span class="s1">len(self.dtype)</span>

    <span class="s3">def </span><span class="s1">__getattribute__(self</span><span class="s3">, </span><span class="s1">attr):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">object.__getattribute__(self</span><span class="s3">, </span><span class="s1">attr)</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s2"># attr must be a fieldname</span>
            <span class="s3">pass</span>
        <span class="s1">fielddict = ndarray.__getattribute__(self</span><span class="s3">, </span><span class="s4">'dtype'</span><span class="s1">).fields</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">res = fielddict[attr][:</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">KeyError) </span><span class="s3">as </span><span class="s1">e:</span>
            <span class="s3">raise </span><span class="s1">AttributeError(</span>
                <span class="s4">f'record array has no attribute </span><span class="s3">{</span><span class="s1">attr</span><span class="s3">}</span><span class="s4">'</span><span class="s1">) </span><span class="s3">from </span><span class="s1">e</span>
        <span class="s2"># So far, so good</span>
        <span class="s1">_localdict = ndarray.__getattribute__(self</span><span class="s3">, </span><span class="s4">'__dict__'</span><span class="s1">)</span>
        <span class="s1">_data = ndarray.view(self</span><span class="s3">, </span><span class="s1">_localdict[</span><span class="s4">'_baseclass'</span><span class="s1">])</span>
        <span class="s1">obj = _data.getfield(*res)</span>
        <span class="s3">if </span><span class="s1">obj.dtype.names </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;MaskedRecords is currently limited to&quot;</span>
                                      <span class="s4">&quot;simple records.&quot;</span><span class="s1">)</span>
        <span class="s2"># Get some special attributes</span>
        <span class="s2"># Reset the object's mask</span>
        <span class="s1">hasmasked = </span><span class="s3">False</span>
        <span class="s1">_mask = _localdict.get(</span><span class="s4">'_mask'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">_mask </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">_mask = _mask[attr]</span>
            <span class="s3">except </span><span class="s1">IndexError:</span>
                <span class="s2"># Couldn't find a mask: use the default (nomask)</span>
                <span class="s3">pass</span>
            <span class="s1">tp_len = len(_mask.dtype)</span>
            <span class="s1">hasmasked = _mask.view((bool</span><span class="s3">, </span><span class="s1">((tp_len</span><span class="s3">,</span><span class="s1">) </span><span class="s3">if </span><span class="s1">tp_len </span><span class="s3">else </span><span class="s1">()))).any()</span>
        <span class="s3">if </span><span class="s1">(obj.shape </span><span class="s3">or </span><span class="s1">hasmasked):</span>
            <span class="s1">obj = obj.view(MaskedArray)</span>
            <span class="s1">obj._baseclass = ndarray</span>
            <span class="s1">obj._isfield = </span><span class="s3">True</span>
            <span class="s1">obj._mask = _mask</span>
            <span class="s2"># Reset the field values</span>
            <span class="s1">_fill_value = _localdict.get(</span><span class="s4">'_fill_value'</span><span class="s3">, None</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">_fill_value </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">obj._fill_value = _fill_value[attr]</span>
                <span class="s3">except </span><span class="s1">ValueError:</span>
                    <span class="s1">obj._fill_value = </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">obj = obj.item()</span>
        <span class="s3">return </span><span class="s1">obj</span>

    <span class="s3">def </span><span class="s1">__setattr__(self</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">val):</span>
        <span class="s0">&quot;&quot;&quot; 
        Sets the attribute attr to the value val. 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># Should we call __setmask__ first ?</span>
        <span class="s3">if </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">[</span><span class="s4">'mask'</span><span class="s3">, </span><span class="s4">'fieldmask'</span><span class="s1">]:</span>
            <span class="s1">self.__setmask__(val)</span>
            <span class="s3">return</span>
        <span class="s2"># Create a shortcut (so that we don't have to call getattr all the time)</span>
        <span class="s1">_localdict = object.__getattribute__(self</span><span class="s3">, </span><span class="s4">'__dict__'</span><span class="s1">)</span>
        <span class="s2"># Check whether we're creating a new field</span>
        <span class="s1">newattr = attr </span><span class="s3">not in </span><span class="s1">_localdict</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s2"># Is attr a generic attribute ?</span>
            <span class="s1">ret = object.__setattr__(self</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">val)</span>
        <span class="s3">except </span><span class="s1">Exception:</span>
            <span class="s2"># Not a generic attribute: exit if it's not a valid field</span>
            <span class="s1">fielddict = ndarray.__getattribute__(self</span><span class="s3">, </span><span class="s4">'dtype'</span><span class="s1">).fields </span><span class="s3">or </span><span class="s1">{}</span>
            <span class="s1">optinfo = ndarray.__getattribute__(self</span><span class="s3">, </span><span class="s4">'_optinfo'</span><span class="s1">) </span><span class="s3">or </span><span class="s1">{}</span>
            <span class="s3">if not </span><span class="s1">(attr </span><span class="s3">in </span><span class="s1">fielddict </span><span class="s3">or </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">optinfo):</span>
                <span class="s3">raise</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># Get the list of names</span>
            <span class="s1">fielddict = ndarray.__getattribute__(self</span><span class="s3">, </span><span class="s4">'dtype'</span><span class="s1">).fields </span><span class="s3">or </span><span class="s1">{}</span>
            <span class="s2"># Check the attribute</span>
            <span class="s3">if </span><span class="s1">attr </span><span class="s3">not in </span><span class="s1">fielddict:</span>
                <span class="s3">return </span><span class="s1">ret</span>
            <span class="s3">if </span><span class="s1">newattr:</span>
                <span class="s2"># We just added this one or this setattr worked on an</span>
                <span class="s2"># internal attribute.</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">object.__delattr__(self</span><span class="s3">, </span><span class="s1">attr)</span>
                <span class="s3">except </span><span class="s1">Exception:</span>
                    <span class="s3">return </span><span class="s1">ret</span>
        <span class="s2"># Let's try to set the field</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">res = fielddict[attr][:</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">KeyError) </span><span class="s3">as </span><span class="s1">e:</span>
            <span class="s3">raise </span><span class="s1">AttributeError(</span>
                <span class="s4">f'record array has no attribute </span><span class="s3">{</span><span class="s1">attr</span><span class="s3">}</span><span class="s4">'</span><span class="s1">) </span><span class="s3">from </span><span class="s1">e</span>

        <span class="s3">if </span><span class="s1">val </span><span class="s3">is </span><span class="s1">masked:</span>
            <span class="s1">_fill_value = _localdict[</span><span class="s4">'_fill_value'</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">_fill_value </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">dval = _localdict[</span><span class="s4">'_fill_value'</span><span class="s1">][attr]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">dval = val</span>
            <span class="s1">mval = </span><span class="s3">True</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">dval = filled(val)</span>
            <span class="s1">mval = getmaskarray(val)</span>
        <span class="s1">obj = ndarray.__getattribute__(self</span><span class="s3">, </span><span class="s4">'_data'</span><span class="s1">).setfield(dval</span><span class="s3">, </span><span class="s1">*res)</span>
        <span class="s1">_localdict[</span><span class="s4">'_mask'</span><span class="s1">].__setitem__(attr</span><span class="s3">, </span><span class="s1">mval)</span>
        <span class="s3">return </span><span class="s1">obj</span>

    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">indx):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns all the fields sharing the same fieldname base. 
 
        The fieldname base is either `_data` or `_mask`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_localdict = self.__dict__</span>
        <span class="s1">_mask = ndarray.__getattribute__(self</span><span class="s3">, </span><span class="s4">'_mask'</span><span class="s1">)</span>
        <span class="s1">_data = ndarray.view(self</span><span class="s3">, </span><span class="s1">_localdict[</span><span class="s4">'_baseclass'</span><span class="s1">])</span>
        <span class="s2"># We want a field</span>
        <span class="s3">if </span><span class="s1">isinstance(indx</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s2"># Make sure _sharedmask is True to propagate back to _fieldmask</span>
            <span class="s2"># Don't use _set_mask, there are some copies being made that</span>
            <span class="s2"># break propagation Don't force the mask to nomask, that wreaks</span>
            <span class="s2"># easy masking</span>
            <span class="s1">obj = _data[indx].view(MaskedArray)</span>
            <span class="s1">obj._mask = _mask[indx]</span>
            <span class="s1">obj._sharedmask = </span><span class="s3">True</span>
            <span class="s1">fval = _localdict[</span><span class="s4">'_fill_value'</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">fval </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">obj._fill_value = fval[indx]</span>
            <span class="s2"># Force to masked if the mask is True</span>
            <span class="s3">if not </span><span class="s1">obj.ndim </span><span class="s3">and </span><span class="s1">obj._mask:</span>
                <span class="s3">return </span><span class="s1">masked</span>
            <span class="s3">return </span><span class="s1">obj</span>
        <span class="s2"># We want some elements.</span>
        <span class="s2"># First, the data.</span>
        <span class="s1">obj = np.array(_data[indx]</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">).view(mrecarray)</span>
        <span class="s1">obj._mask = np.array(_mask[indx]</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">).view(recarray)</span>
        <span class="s3">return </span><span class="s1">obj</span>

    <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">indx</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot; 
        Sets the given record to value. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">MaskedArray.__setitem__(self</span><span class="s3">, </span><span class="s1">indx</span><span class="s3">, </span><span class="s1">value)</span>
        <span class="s3">if </span><span class="s1">isinstance(indx</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s1">self._mask[indx] = ma.getmaskarray(value)</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Calculates the string representation. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.size &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">mstr = [</span><span class="s4">f&quot;(</span><span class="s3">{</span><span class="s4">','</span><span class="s1">.join([str(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">s])</span><span class="s3">}</span><span class="s4">)&quot;</span>
                    <span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">zip(*[getattr(self</span><span class="s3">, </span><span class="s1">f) </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">self.dtype.names])]</span>
            <span class="s3">return </span><span class="s4">f&quot;[</span><span class="s3">{</span><span class="s4">', '</span><span class="s1">.join(mstr)</span><span class="s3">}</span><span class="s4">]&quot;</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">mstr = [</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s4">','</span><span class="s1">.join([str(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">s])</span><span class="s3">}</span><span class="s4">&quot;</span>
                    <span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">zip([getattr(self</span><span class="s3">, </span><span class="s1">f) </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">self.dtype.names])]</span>
            <span class="s3">return </span><span class="s4">f&quot;(</span><span class="s3">{</span><span class="s4">', '</span><span class="s1">.join(mstr)</span><span class="s3">}</span><span class="s4">)&quot;</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Calculates the repr representation. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_names = self.dtype.names</span>
        <span class="s1">fmt = </span><span class="s4">&quot;%%%is : %%s&quot; </span><span class="s1">% (max([len(n) </span><span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">_names]) + </span><span class="s5">4</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s1">reprstr = [fmt % (f</span><span class="s3">, </span><span class="s1">getattr(self</span><span class="s3">, </span><span class="s1">f)) </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">self.dtype.names]</span>
        <span class="s1">reprstr.insert(</span><span class="s5">0</span><span class="s3">, </span><span class="s4">'masked_records('</span><span class="s1">)</span>
        <span class="s1">reprstr.extend([fmt % (</span><span class="s4">'    fill_value'</span><span class="s3">, </span><span class="s1">self.fill_value)</span><span class="s3">,</span>
                        <span class="s4">'              )'</span><span class="s1">])</span>
        <span class="s3">return </span><span class="s1">str(</span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">.join(reprstr))</span>

    <span class="s3">def </span><span class="s1">view(self</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s3">None, </span><span class="s1">type=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a view of the mrecarray. 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># OK, basic copy-paste from MaskedArray.view.</span>
        <span class="s3">if </span><span class="s1">dtype </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">type </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">output = ndarray.view(self)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">output = ndarray.view(self</span><span class="s3">, </span><span class="s1">type)</span>
        <span class="s2"># Here again.</span>
        <span class="s3">elif </span><span class="s1">type </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">issubclass(dtype</span><span class="s3">, </span><span class="s1">ndarray):</span>
                    <span class="s1">output = ndarray.view(self</span><span class="s3">, </span><span class="s1">dtype)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">output = ndarray.view(self</span><span class="s3">, </span><span class="s1">dtype)</span>
            <span class="s2"># OK, there's the change</span>
            <span class="s3">except </span><span class="s1">TypeError:</span>
                <span class="s1">dtype = np.dtype(dtype)</span>
                <span class="s2"># we need to revert to MaskedArray, but keeping the possibility</span>
                <span class="s2"># of subclasses (eg, TimeSeriesRecords), so we'll force a type</span>
                <span class="s2"># set to the first parent</span>
                <span class="s3">if </span><span class="s1">dtype.fields </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s1">basetype = self.__class__.__bases__[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s1">output = self.__array__().view(dtype</span><span class="s3">, </span><span class="s1">basetype)</span>
                    <span class="s1">output._update_from(self)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">output = ndarray.view(self</span><span class="s3">, </span><span class="s1">dtype)</span>
                <span class="s1">output._fill_value = </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">output = ndarray.view(self</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">type)</span>
        <span class="s2"># Update the mask, just like in MaskedArray.view</span>
        <span class="s3">if </span><span class="s1">(getattr(output</span><span class="s3">, </span><span class="s4">'_mask'</span><span class="s3">, </span><span class="s1">nomask) </span><span class="s3">is not </span><span class="s1">nomask):</span>
            <span class="s1">mdtype = ma.make_mask_descr(output.dtype)</span>
            <span class="s1">output._mask = self._mask.view(mdtype</span><span class="s3">, </span><span class="s1">ndarray)</span>
            <span class="s1">output._mask.shape = output.shape</span>
        <span class="s3">return </span><span class="s1">output</span>

    <span class="s3">def </span><span class="s1">harden_mask(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Forces the mask to hard. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._hardmask = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">soften_mask(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Forces the mask to soft 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._hardmask = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">copy(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a copy of the masked record. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">copied = self._data.copy().view(type(self))</span>
        <span class="s1">copied._mask = self._mask.copy()</span>
        <span class="s3">return </span><span class="s1">copied</span>

    <span class="s3">def </span><span class="s1">tolist(self</span><span class="s3">, </span><span class="s1">fill_value=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the data portion of the array as a list. 
 
        Data items are converted to the nearest compatible Python type. 
        Masked values are converted to fill_value. If fill_value is None, 
        the corresponding entries in the output list will be ``None``. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">fill_value </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.filled(fill_value).tolist()</span>
        <span class="s1">result = narray(self.filled().tolist()</span><span class="s3">, </span><span class="s1">dtype=object)</span>
        <span class="s1">mask = narray(self._mask.tolist())</span>
        <span class="s1">result[mask] = </span><span class="s3">None</span>
        <span class="s3">return </span><span class="s1">result.tolist()</span>

    <span class="s3">def </span><span class="s1">__getstate__(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the internal state of the masked array. 
 
        This is for pickling. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">state = (</span><span class="s5">1</span><span class="s3">,</span>
                 <span class="s1">self.shape</span><span class="s3">,</span>
                 <span class="s1">self.dtype</span><span class="s3">,</span>
                 <span class="s1">self.flags.fnc</span><span class="s3">,</span>
                 <span class="s1">self._data.tobytes()</span><span class="s3">,</span>
                 <span class="s1">self._mask.tobytes()</span><span class="s3">,</span>
                 <span class="s1">self._fill_value</span><span class="s3">,</span>
                 <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">state</span>

    <span class="s3">def </span><span class="s1">__setstate__(self</span><span class="s3">, </span><span class="s1">state):</span>
        <span class="s0">&quot;&quot;&quot; 
        Restore the internal state of the masked array. 
 
        This is for pickling.  ``state`` is typically the output of the 
        ``__getstate__`` output, and is a 5-tuple: 
 
        - class name 
        - a tuple giving the shape of the data 
        - a typecode for the data 
        - a binary string for the data 
        - a binary string for the mask. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">(ver</span><span class="s3">, </span><span class="s1">shp</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">isf</span><span class="s3">, </span><span class="s1">raw</span><span class="s3">, </span><span class="s1">msk</span><span class="s3">, </span><span class="s1">flv) = state</span>
        <span class="s1">ndarray.__setstate__(self</span><span class="s3">, </span><span class="s1">(shp</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">isf</span><span class="s3">, </span><span class="s1">raw))</span>
        <span class="s1">mdtype = dtype([(k</span><span class="s3">, </span><span class="s1">bool_) </span><span class="s3">for </span><span class="s1">(k</span><span class="s3">, </span><span class="s1">_) </span><span class="s3">in </span><span class="s1">self.dtype.descr])</span>
        <span class="s1">self.__dict__[</span><span class="s4">'_mask'</span><span class="s1">].__setstate__((shp</span><span class="s3">, </span><span class="s1">mdtype</span><span class="s3">, </span><span class="s1">isf</span><span class="s3">, </span><span class="s1">msk))</span>
        <span class="s1">self.fill_value = flv</span>

    <span class="s3">def </span><span class="s1">__reduce__(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a 3-tuple for pickling a MaskedArray. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">(_mrreconstruct</span><span class="s3">,</span>
                <span class="s1">(self.__class__</span><span class="s3">, </span><span class="s1">self._baseclass</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s4">'b'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s1">self.__getstate__())</span>


<span class="s3">def </span><span class="s1">_mrreconstruct(subtype</span><span class="s3">, </span><span class="s1">baseclass</span><span class="s3">, </span><span class="s1">baseshape</span><span class="s3">, </span><span class="s1">basetype</span><span class="s3">,</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Build a new MaskedArray from the information stored in a pickle. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_data = ndarray.__new__(baseclass</span><span class="s3">, </span><span class="s1">baseshape</span><span class="s3">, </span><span class="s1">basetype).view(subtype)</span>
    <span class="s1">_mask = ndarray.__new__(ndarray</span><span class="s3">, </span><span class="s1">baseshape</span><span class="s3">, </span><span class="s4">'b1'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">subtype.__new__(subtype</span><span class="s3">, </span><span class="s1">_data</span><span class="s3">, </span><span class="s1">mask=_mask</span><span class="s3">, </span><span class="s1">dtype=basetype</span><span class="s3">,</span><span class="s1">)</span>

<span class="s1">mrecarray = MaskedRecords</span>


<span class="s2">###############################################################################</span>
<span class="s2">#                             Constructors                                    #</span>
<span class="s2">###############################################################################</span>


<span class="s3">def </span><span class="s1">fromarrays(arraylist</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s3">None, </span><span class="s1">shape=</span><span class="s3">None, </span><span class="s1">formats=</span><span class="s3">None,</span>
               <span class="s1">names=</span><span class="s3">None, </span><span class="s1">titles=</span><span class="s3">None, </span><span class="s1">aligned=</span><span class="s3">False, </span><span class="s1">byteorder=</span><span class="s3">None,</span>
               <span class="s1">fill_value=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Creates a mrecarray from a (flat) list of masked arrays. 
 
    Parameters 
    ---------- 
    arraylist : sequence 
        A list of (masked) arrays. Each element of the sequence is first converted 
        to a masked array if needed. If a 2D array is passed as argument, it is 
        processed line by line 
    dtype : {None, dtype}, optional 
        Data type descriptor. 
    shape : {None, integer}, optional 
        Number of records. If None, shape is defined from the shape of the 
        first array in the list. 
    formats : {None, sequence}, optional 
        Sequence of formats for each individual field. If None, the formats will 
        be autodetected by inspecting the fields and selecting the highest dtype 
        possible. 
    names : {None, sequence}, optional 
        Sequence of the names of each field. 
    fill_value : {None, sequence}, optional 
        Sequence of data to be used as filling values. 
 
    Notes 
    ----- 
    Lists of tuples should be preferred over lists of lists for faster processing. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">datalist = [getdata(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">arraylist]</span>
    <span class="s1">masklist = [np.atleast_1d(getmaskarray(x)) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">arraylist]</span>
    <span class="s1">_array = recfromarrays(datalist</span><span class="s3">,</span>
                           <span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">shape=shape</span><span class="s3">, </span><span class="s1">formats=formats</span><span class="s3">,</span>
                           <span class="s1">names=names</span><span class="s3">, </span><span class="s1">titles=titles</span><span class="s3">, </span><span class="s1">aligned=aligned</span><span class="s3">,</span>
                           <span class="s1">byteorder=byteorder).view(mrecarray)</span>
    <span class="s1">_array._mask.flat = list(zip(*masklist))</span>
    <span class="s3">if </span><span class="s1">fill_value </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">_array.fill_value = fill_value</span>
    <span class="s3">return </span><span class="s1">_array</span>


<span class="s3">def </span><span class="s1">fromrecords(reclist</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s3">None, </span><span class="s1">shape=</span><span class="s3">None, </span><span class="s1">formats=</span><span class="s3">None, </span><span class="s1">names=</span><span class="s3">None,</span>
                <span class="s1">titles=</span><span class="s3">None, </span><span class="s1">aligned=</span><span class="s3">False, </span><span class="s1">byteorder=</span><span class="s3">None,</span>
                <span class="s1">fill_value=</span><span class="s3">None, </span><span class="s1">mask=nomask):</span>
    <span class="s0">&quot;&quot;&quot; 
    Creates a MaskedRecords from a list of records. 
 
    Parameters 
    ---------- 
    reclist : sequence 
        A list of records. Each element of the sequence is first converted 
        to a masked array if needed. If a 2D array is passed as argument, it is 
        processed line by line 
    dtype : {None, dtype}, optional 
        Data type descriptor. 
    shape : {None,int}, optional 
        Number of records. If None, ``shape`` is defined from the shape of the 
        first array in the list. 
    formats : {None, sequence}, optional 
        Sequence of formats for each individual field. If None, the formats will 
        be autodetected by inspecting the fields and selecting the highest dtype 
        possible. 
    names : {None, sequence}, optional 
        Sequence of the names of each field. 
    fill_value : {None, sequence}, optional 
        Sequence of data to be used as filling values. 
    mask : {nomask, sequence}, optional. 
        External mask to apply on the data. 
 
    Notes 
    ----- 
    Lists of tuples should be preferred over lists of lists for faster processing. 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># Grab the initial _fieldmask, if needed:</span>
    <span class="s1">_mask = getattr(reclist</span><span class="s3">, </span><span class="s4">'_mask'</span><span class="s3">, None</span><span class="s1">)</span>
    <span class="s2"># Get the list of records.</span>
    <span class="s3">if </span><span class="s1">isinstance(reclist</span><span class="s3">, </span><span class="s1">ndarray):</span>
        <span class="s2"># Make sure we don't have some hidden mask</span>
        <span class="s3">if </span><span class="s1">isinstance(reclist</span><span class="s3">, </span><span class="s1">MaskedArray):</span>
            <span class="s1">reclist = reclist.filled().view(ndarray)</span>
        <span class="s2"># Grab the initial dtype, just in case</span>
        <span class="s3">if </span><span class="s1">dtype </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">dtype = reclist.dtype</span>
        <span class="s1">reclist = reclist.tolist()</span>
    <span class="s1">mrec = recfromrecords(reclist</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">shape=shape</span><span class="s3">, </span><span class="s1">formats=formats</span><span class="s3">,</span>
                          <span class="s1">names=names</span><span class="s3">, </span><span class="s1">titles=titles</span><span class="s3">,</span>
                          <span class="s1">aligned=aligned</span><span class="s3">, </span><span class="s1">byteorder=byteorder).view(mrecarray)</span>
    <span class="s2"># Set the fill_value if needed</span>
    <span class="s3">if </span><span class="s1">fill_value </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">mrec.fill_value = fill_value</span>
    <span class="s2"># Now, let's deal w/ the mask</span>
    <span class="s3">if </span><span class="s1">mask </span><span class="s3">is not </span><span class="s1">nomask:</span>
        <span class="s1">mask = np.array(mask</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">maskrecordlength = len(mask.dtype)</span>
        <span class="s3">if </span><span class="s1">maskrecordlength:</span>
            <span class="s1">mrec._mask.flat = mask</span>
        <span class="s3">elif </span><span class="s1">mask.ndim == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">mrec._mask.flat = [tuple(m) </span><span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">mask]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">mrec.__setmask__(mask)</span>
    <span class="s3">if </span><span class="s1">_mask </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">mrec._mask[:] = _mask</span>
    <span class="s3">return </span><span class="s1">mrec</span>


<span class="s3">def </span><span class="s1">_guessvartypes(arr):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tries to guess the dtypes of the str_ ndarray `arr`. 
 
    Guesses by testing element-wise conversion. Returns a list of dtypes. 
    The array is first converted to ndarray. If the array is 2D, the test 
    is performed on the first line. An exception is raised if the file is 
    3D or more. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">vartypes = []</span>
    <span class="s1">arr = np.asarray(arr)</span>
    <span class="s3">if </span><span class="s1">arr.ndim == </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s1">arr = arr[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s3">elif </span><span class="s1">arr.ndim &gt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The array should be 2D at most!&quot;</span><span class="s1">)</span>
    <span class="s2"># Start the conversion loop.</span>
    <span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">arr:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">int(f)</span>
        <span class="s3">except </span><span class="s1">(ValueError</span><span class="s3">, </span><span class="s1">TypeError):</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">float(f)</span>
            <span class="s3">except </span><span class="s1">(ValueError</span><span class="s3">, </span><span class="s1">TypeError):</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">complex(f)</span>
                <span class="s3">except </span><span class="s1">(ValueError</span><span class="s3">, </span><span class="s1">TypeError):</span>
                    <span class="s1">vartypes.append(arr.dtype)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">vartypes.append(np.dtype(complex))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">vartypes.append(np.dtype(float))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">vartypes.append(np.dtype(int))</span>
    <span class="s3">return </span><span class="s1">vartypes</span>


<span class="s3">def </span><span class="s1">openfile(fname):</span>
    <span class="s0">&quot;&quot;&quot; 
    Opens the file handle of file `fname`. 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># A file handle</span>
    <span class="s3">if </span><span class="s1">hasattr(fname</span><span class="s3">, </span><span class="s4">'readline'</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">fname</span>
    <span class="s2"># Try to open the file and guess its type</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">f = open(fname)</span>
    <span class="s3">except </span><span class="s1">FileNotFoundError </span><span class="s3">as </span><span class="s1">e:</span>
        <span class="s3">raise </span><span class="s1">FileNotFoundError(</span><span class="s4">f&quot;No such file: '</span><span class="s3">{</span><span class="s1">fname</span><span class="s3">}</span><span class="s4">'&quot;</span><span class="s1">) </span><span class="s3">from </span><span class="s1">e</span>
    <span class="s3">if </span><span class="s1">f.readline()[:</span><span class="s5">2</span><span class="s1">] != </span><span class="s4">&quot;</span><span class="s3">\\</span><span class="s4">x&quot;</span><span class="s1">:</span>
        <span class="s1">f.seek(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">f</span>
    <span class="s1">f.close()</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;Wow, binary file&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">fromtextfile(fname</span><span class="s3">, </span><span class="s1">delimiter=</span><span class="s3">None, </span><span class="s1">commentchar=</span><span class="s4">'#'</span><span class="s3">, </span><span class="s1">missingchar=</span><span class="s4">''</span><span class="s3">,</span>
                 <span class="s1">varnames=</span><span class="s3">None, </span><span class="s1">vartypes=</span><span class="s3">None,</span>
                 <span class="s1">*</span><span class="s3">, </span><span class="s1">delimitor=np._NoValue):  </span><span class="s2"># backwards compatibility</span>
    <span class="s0">&quot;&quot;&quot; 
    Creates a mrecarray from data stored in the file `filename`. 
 
    Parameters 
    ---------- 
    fname : {file name/handle} 
        Handle of an opened file. 
    delimiter : {None, string}, optional 
        Alphanumeric character used to separate columns in the file. 
        If None, any (group of) white spacestring(s) will be used. 
    commentchar : {'#', string}, optional 
        Alphanumeric character used to mark the start of a comment. 
    missingchar : {'', string}, optional 
        String indicating missing data, and used to create the masks. 
    varnames : {None, sequence}, optional 
        Sequence of the variable names. If None, a list will be created from 
        the first non empty line of the file. 
    vartypes : {None, sequence}, optional 
        Sequence of the variables dtypes. If None, it will be estimated from 
        the first non-commented line. 
 
 
    Ultra simple: the varnames are in the header, one line&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">delimitor </span><span class="s3">is not </span><span class="s1">np._NoValue:</span>
        <span class="s3">if </span><span class="s1">delimiter </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;fromtextfile() got multiple values for argument &quot;</span>
                            <span class="s4">&quot;'delimiter'&quot;</span><span class="s1">)</span>
        <span class="s2"># NumPy 1.22.0, 2021-09-23</span>
        <span class="s1">warnings.warn(</span><span class="s4">&quot;The 'delimitor' keyword argument of &quot;</span>
                      <span class="s4">&quot;numpy.ma.mrecords.fromtextfile() is deprecated &quot;</span>
                      <span class="s4">&quot;since NumPy 1.22.0, use 'delimiter' instead.&quot;</span><span class="s3">,</span>
                      <span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">delimiter = delimitor</span>

    <span class="s2"># Try to open the file.</span>
    <span class="s1">ftext = openfile(fname)</span>

    <span class="s2"># Get the first non-empty line as the varnames</span>
    <span class="s3">while True</span><span class="s1">:</span>
        <span class="s1">line = ftext.readline()</span>
        <span class="s1">firstline = line[:line.find(commentchar)].strip()</span>
        <span class="s1">_varnames = firstline.split(delimiter)</span>
        <span class="s3">if </span><span class="s1">len(_varnames) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">break</span>
    <span class="s3">if </span><span class="s1">varnames </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">varnames = _varnames</span>

    <span class="s2"># Get the data.</span>
    <span class="s1">_variables = masked_array([line.strip().split(delimiter) </span><span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">ftext</span>
                               <span class="s3">if </span><span class="s1">line[</span><span class="s5">0</span><span class="s1">] != commentchar </span><span class="s3">and </span><span class="s1">len(line) &gt; </span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">(_</span><span class="s3">, </span><span class="s1">nfields) = _variables.shape</span>
    <span class="s1">ftext.close()</span>

    <span class="s2"># Try to guess the dtype.</span>
    <span class="s3">if </span><span class="s1">vartypes </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">vartypes = _guessvartypes(_variables[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">vartypes = [np.dtype(v) </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">vartypes]</span>
        <span class="s3">if </span><span class="s1">len(vartypes) != nfields:</span>
            <span class="s1">msg = </span><span class="s4">&quot;Attempting to %i dtypes for %i fields!&quot;</span>
            <span class="s1">msg += </span><span class="s4">&quot; Reverting to default.&quot;</span>
            <span class="s1">warnings.warn(msg % (len(vartypes)</span><span class="s3">, </span><span class="s1">nfields)</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">vartypes = _guessvartypes(_variables[</span><span class="s5">0</span><span class="s1">])</span>

    <span class="s2"># Construct the descriptor.</span>
    <span class="s1">mdescr = [(n</span><span class="s3">, </span><span class="s1">f) </span><span class="s3">for </span><span class="s1">(n</span><span class="s3">, </span><span class="s1">f) </span><span class="s3">in </span><span class="s1">zip(varnames</span><span class="s3">, </span><span class="s1">vartypes)]</span>
    <span class="s1">mfillv = [ma.default_fill_value(f) </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">vartypes]</span>

    <span class="s2"># Get the data and the mask.</span>
    <span class="s2"># We just need a list of masked_arrays. It's easier to create it like that:</span>
    <span class="s1">_mask = (_variables.T == missingchar)</span>
    <span class="s1">_datalist = [masked_array(a</span><span class="s3">, </span><span class="s1">mask=m</span><span class="s3">, </span><span class="s1">dtype=t</span><span class="s3">, </span><span class="s1">fill_value=f)</span>
                 <span class="s3">for </span><span class="s1">(a</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">f) </span><span class="s3">in </span><span class="s1">zip(_variables.T</span><span class="s3">, </span><span class="s1">_mask</span><span class="s3">, </span><span class="s1">vartypes</span><span class="s3">, </span><span class="s1">mfillv)]</span>

    <span class="s3">return </span><span class="s1">fromarrays(_datalist</span><span class="s3">, </span><span class="s1">dtype=mdescr)</span>


<span class="s3">def </span><span class="s1">addfield(mrecord</span><span class="s3">, </span><span class="s1">newfield</span><span class="s3">, </span><span class="s1">newfieldname=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Adds a new field to the masked record array 
 
    Uses `newfield` as data and `newfieldname` as name. If `newfieldname` 
    is None, the new field name is set to 'fi', where `i` is the number of 
    existing fields. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_data = mrecord._data</span>
    <span class="s1">_mask = mrecord._mask</span>
    <span class="s3">if </span><span class="s1">newfieldname </span><span class="s3">is None or </span><span class="s1">newfieldname </span><span class="s3">in </span><span class="s1">reserved_fields:</span>
        <span class="s1">newfieldname = </span><span class="s4">'f%i' </span><span class="s1">% len(_data.dtype)</span>
    <span class="s1">newfield = ma.array(newfield)</span>
    <span class="s2"># Get the new data.</span>
    <span class="s2"># Create a new empty recarray</span>
    <span class="s1">newdtype = np.dtype(_data.dtype.descr + [(newfieldname</span><span class="s3">, </span><span class="s1">newfield.dtype)])</span>
    <span class="s1">newdata = recarray(_data.shape</span><span class="s3">, </span><span class="s1">newdtype)</span>
    <span class="s2"># Add the existing field</span>
    <span class="s1">[newdata.setfield(_data.getfield(*f)</span><span class="s3">, </span><span class="s1">*f)</span>
     <span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">_data.dtype.fields.values()]</span>
    <span class="s2"># Add the new field</span>
    <span class="s1">newdata.setfield(newfield._data</span><span class="s3">, </span><span class="s1">*newdata.dtype.fields[newfieldname])</span>
    <span class="s1">newdata = newdata.view(MaskedRecords)</span>
    <span class="s2"># Get the new mask</span>
    <span class="s2"># Create a new empty recarray</span>
    <span class="s1">newmdtype = np.dtype([(n</span><span class="s3">, </span><span class="s1">bool_) </span><span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">newdtype.names])</span>
    <span class="s1">newmask = recarray(_data.shape</span><span class="s3">, </span><span class="s1">newmdtype)</span>
    <span class="s2"># Add the old masks</span>
    <span class="s1">[newmask.setfield(_mask.getfield(*f)</span><span class="s3">, </span><span class="s1">*f)</span>
     <span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">_mask.dtype.fields.values()]</span>
    <span class="s2"># Add the mask of the new field</span>
    <span class="s1">newmask.setfield(getmaskarray(newfield)</span><span class="s3">,</span>
                     <span class="s1">*newmask.dtype.fields[newfieldname])</span>
    <span class="s1">newdata._mask = newmask</span>
    <span class="s3">return </span><span class="s1">newdata</span>
</pre>
</body>
</html>